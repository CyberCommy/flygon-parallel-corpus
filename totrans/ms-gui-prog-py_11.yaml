- en: Exploring SQL with Qt SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For about 40 years, **relational databases** managed with the **structured query
    language** (commonly known as SQL) have been the de facto standard technology
    for storing, retrieving, and analyzing the world's data. Whether you are creating
    business applications, games, web applications, or something else, if your application
    deals with a large amount of data, you will almost certainly be working with SQL.
    While Python has many modules available for connecting to a SQL database, Qt's
    `QtSql` module provides us with powerful and convenient classes for integrating
    SQL data into PyQt applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn how to build database-driven PyQt applications
    as we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing SQL queries with Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SQL with model-view widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the basic setup you've been using since [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, you will want the example code found in the GitHub
    repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter09](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: You may also find it helpful to have a copy of **SQLite** to practice the SQL
    examples. SQLite is free and can be downloaded from [https://sqlite.org/download.html](https://sqlite.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xu1r](http://bit.ly/2M5xu1r)
  prefs: []
  type: TYPE_NORMAL
- en: SQL basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into what `QtSql` has to offer, you will need to be familiar
    with the basics of SQL. This section will give you a quick overview of how to
    create, populate, alter, and query data in a SQL database. If you already know
    SQL, you may want to skip ahead to the PyQt part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is a very different language from Python in syntax and structure. It is
    a **declarative** language, meaning that we describe the results we want rather
    than the procedures used to get them. To interact with a SQL database, we execute
    **statements**. Each statement is made up of a SQL **command** followed by a series
    of **clauses**, each of which further describes the results desired.  Statements
    are terminated with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: Although SQL is standardized, all SQL database implementations provide their
    own alterations and extensions to the standard language. We're going to be learning
    the SQLite dialect of SQL, which is reasonably close to standard SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Python, SQL is generally a case-insensitive language; however, it is
    a long-standing convention to write SQL keywords in all uppercase letters. This
    helps them to stand out from data and object names. We will follow this convention
    in the book, but it is optional for your code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL databases are made of relations, also known as **tables**. A table is a
    two-dimensional data structure made of rows and columns. Each row in the table
    represents a single item about which we have information, and each column represents
    a type of information we are storing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tables are defined using the `CREATE TABLE` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `CREATE TABLE` statement is followed by a table name and a list of column
    definitions. In this example, `coffees` is the name of the table we're creating,
    and the column definitions are inside the parentheses. Each column has a name,
    a data type, and any number of **constraints** that describe valid values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` is an integer column. It''s marked as the **primary key**, which means
    it will be a unique value that can be used to identify the row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coffee_brand` and `coffee_name` are both text columns with a `NOT NULL` constraint,
    meaning they cannot have `NULL` for a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints can also be defined on multiple columns. The `UNIQUE` constraint
    added after the fields is not a field, but a table-level constraint that makes
    sure the combination of `coffee _brand` and `coffee _name` is unique for each
    row.
  prefs: []
  type: TYPE_NORMAL
- en: '`NULL` is the SQL equivalent of Python''s `None`. It indicates the absence
    of information.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL databases, at a minimum, support text, numeric, date, time, and binary object
    data types; but it's not uncommon for different database implementations to extend
    SQL with additional data types, such as currency or IP address types. Many databases
    also have `SMALL` and `BIG` variants of numeric types, allowing the developer
    to fine-tune the amount of storage space used by a column.
  prefs: []
  type: TYPE_NORMAL
- en: 'As useful as simple two-dimensional tables are, the real power of a SQL database
    is in joining multiple, related tables together, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `roast_id` column in `coffees` holds values that match the primary keys
    of `roasts`, as indicated by the `REFERENCES` constraint. Rather than having to
    rewrite the description and color of a roast in every coffee record, each `coffees`
    record simply points to a row in `roasts` that holds the information about the
    roast of that coffee. In the same way, the `reviews` table contains the `coffee_id`
    column, which refers to an individual `coffees` entry. These relationships are
    called **foreign key relationships** since the field refers to the key from another
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling data in multiple, related tables like this reduces duplication and
    enforces data **consistency**. Imagine if the data in all three tables were combined
    into one table of coffee reviews—it would be possible for two reviews of the same
    coffee product to have different roasts specified. That shouldn't be possible,
    and with relational data tables, it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once tables are created, we can add new rows of data using an `INSERT` statement
    using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s insert some rows into `roasts` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're providing a `description` and `color` value for each
    new record in the `roasts` table. The `VALUES` clause contains a list of tuples,
    each of which represents a row of data. The number and data types of the values
    in these tuples *must* match the number and data types of the columns specified.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we didn't include all the columns—`id` is missing. Any fields we don't
    specify in an `INSERT` statement will get a default value, which is `NULL` unless
    we specify otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLite, an `INTEGER PRIMARY KEY` field has special behavior in which its
    default value is automatically incremented on each insert. Therefore, the `id`
    values resulting from this query will be `1` for `Light`, `2` for `Medium`, `3`
    for `Dark`, and `4` for `Burnt to a Crisp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important to know, since we need that key value to insert records into
    our `coffees` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unlike Python, SQL string literals *must* use single quotes only. A double-quoted
    string is interpreted as the name of a database object, such as a table or column.
    To escape a single quote in a string, use two of them, as we've done in the preceding
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of our foreign key constraint, it is impossible to insert a row in
    `coffees` that contains a `roast_id` that doesn''t exist in `roasts`. For example,
    this would return an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can insert `NULL` in the `roast_id` field; unless the column was
    defined with a `NOT NULL` constraint, `NULL` is the only value that doesn't have
    to obey the foreign key constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Updating existing rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update existing rows in a table, you use the `UPDATE` statement, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `SET` clause is followed by a list of value assignments for the fields you
    want to change, and the `WHERE` clause describes conditions that must be true
    if a particular row is to be updated. In this case, we're going to change the
    value of the `roast_id` column to `4` for the record where the `id` column is
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: SQL uses a single equals sign for both assignment and equality operations. It
    does not ever use the double-equals sign that Python uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update operations can also affect multiple records, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're incrementing the `roast_id` value on all the `Strawbunks`
    coffees by setting it equal to `roast_id + 1`. Whenever we reference a column's
    value in a query like this, the value will be that of the column in the same row.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most important operation in SQL is the `SELECT` statement, which
    is used to retrieve data. A simple `SELECT` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `SELECT` command is followed by a list of fields, or by the `*` symbol,
    which means *all fields*. The `FROM` clause defines the source of the data; in
    this case, the `reviews` table. The `WHERE` clause, once again, defines conditions
    that must be true for the rows to be included. In this case, we'll only include
    reviews newer than March 1, 2019, by comparing each row's `review_date` field
    (which is a `DATE` type) to the string `'2019-03-01'` (which SQLite will convert
    to a `DATE` to make the comparison). Finally, the `ORDER BY` clause determines
    the sorting of the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Table joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SELECT` statements always return a single table of values. Even if your result
    set has only a single value, it will be in a table of one row and one column,
    and there is no way to return multiple tables from a single query. However, we
    can pull data from multiple tables by combining the data into a single table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using a `JOIN` in the `FROM` clause, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our `FROM` clause contains two `JOIN` statements. The first joins
    `coffees` to `roasts` by matching the `roast_id` field in `coffees` to the `id`
    field in `roasts`. The second joins the `reviews` table by matching the `coffee_id`
    column in `reviews` to the `id` column in `coffees`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The joins are slightly different: notice that the `reviews` join is a `LEFT
    OUTER JOIN`. This means that we''re including rows from `coffees` that don''t
    have any matching `reviews` records; a default `JOIN` is an `INNER` join, meaning
    only rows with matching records in both tables will be shown.'
  prefs: []
  type: TYPE_NORMAL
- en: We're also using an **aggregate function** in this query, `COUNT()`. The `COUNT()`
    function merely tallies up the matching rows. An aggregate function requires that
    we specify a `GROUP BY` clause listing the fields that will be the basis of the
    aggregation. In other words, for each unique combination of `coffee_brand`, `coffee_name`,
    and `roast`, we'll get a tally of the review records in the database. Other standard
    aggregate functions include `SUM` (for summing all matching values), `MIN` (for
    returning the minimum of all matching values), and `MAX` (for returning the maximum
    of all matching values). Different database implementations also include their
    own custom aggregate functions.
  prefs: []
  type: TYPE_NORMAL
- en: SQL subqueries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `SELECT` statement can be embedded in another SQL statement by putting it
    in parentheses. This is called a **subquery**. Exactly where it can be embedded
    depends on what kind of data the query is expected to return:'
  prefs: []
  type: TYPE_NORMAL
- en: If the statement will return a single row and column, it can be embedded wherever
    a single value is expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the statement will return a single column with multiple rows, it can be embedded
    wherever a list of values is expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the statement will return multiple rows and columns, it can be embedded wherever
    a table of values is expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three subqueries here. The first is located in the `FROM` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because it begins with `SELECT *`, we can be sure it will return a table of
    data (or no data, but that's moot). Therefore, it can be used in the `FROM` clause,
    since a table is expected here. Note that we need to give the subquery a name
    using the `AS` keyword. This is required when using a subquery in the `FROM` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'This subquery contains its own subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This query is reasonably certain to give us a single value, so we're using it
    where a single value is expected; in this case, as an operand of a greater-than
    expression. If, for some reason, this query returned multiple rows, our query
    would return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final subquery is in the `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This expression is guaranteed to return only one column but may return multiple
    rows. We're therefore using it as an argument to the `IN` keyword, which expects
    a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries are powerful, but can also cause slowdown and, sometimes, errors
    if our assumptions about the data are incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've only touched on the basics of SQL here, but this should be enough to get
    you started creating and using simple databases, and covers the SQL we'll be using
    in this chapter. See the *Further reading* section at the end of the chapter for
    more in-depth SQL resources. In the next section, you'll see how to combine your
    knowledge of SQL with PyQt to create data-driven applications.
  prefs: []
  type: TYPE_NORMAL
- en: Performing SQL queries with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with different SQL implementations can be frustrating: not only are
    there slight differences in the SQL syntax, but the Python libraries used to connect
    to them are often inconsistent in the various methods they implement. While, in
    some ways, it''s less convenient than the better-known Python SQL libraries, `QtSQL`
    does provide us with a single abstracted API for working with a variety of database
    products in a consistent way. When leveraged properly, it can also save us a large
    amount of code.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to work with SQL data in PyQt, we're going to build a graphical
    frontend for the coffee database we created in the *SQL basics* section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete version of this database can be created from the sample code using
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sqlite3 coffee.db -init coffee.sql`. You will need to create this database
    file before the frontend will work.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our coffee database has three tables: a list of coffee products, a list of
    roasts, and a table of reviews for the products. Our GUI will be designed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It will have a list of coffee brands and products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we double-click an item in the list, it will open a form that will show
    all the information about the coffee and all the reviews associated with that
    product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will allow us to add new products and new reviews or edit any existing information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by copying your basic PyQt application template from [Chapter
    4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building Applications with QMainWindow*
    to a file called `coffee_list1.py`. Then, add an import for `QtSQL` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re going to create a form to display information about our coffee product.
    The basic form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This form has fields for the brand, name, and roast of the coffee, plus a table
    widget for showing the reviews. Note that the constructor requires `roasts`, which
    is a list of roasts for the combo box; we want to get these from the database,
    not hardcode them into the form, since new roasts might get added to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This form is also going to need a way to display a coffee product. Let''s create
    a method that will take coffee data and review it, and populate the form with
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This method assumes that `coffee_data` is a `dict` object containing the brand,
    name, and roast ID and that `reviews` is a list of tuples containing the review
    data. It simply goes through those data structures and populates each field with
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Down in `MainWindow.__init__()`, let''s start the main GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll be using `QStackedWidget` to swap between our coffee list and coffee form
    widgets. Recall that this widget is similar to `QTabWidget` but without the tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can build more of our GUI, we need to get some information from the
    database. Let's talk about how to connect to a database with `QtSQL`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and making simple queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a SQL database with `QtSQL`, we first have to establish a connection.
    There are three steps to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the connection object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the connection object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `MainWindow.__init__()`, let''s create our database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Rather than directly creating a `QSqlDatabase` object, we create one by calling
    the static `addDatabase` method with the name of the database driver we're going
    to use. In this case, we're using Qt's SQLite3 driver. Qt 5.12 comes with nine
    drivers built-in, including ones for MySQL (`QMYSQL`), PostgreSQL (`QPSQL`), and
    ODBC connections (including Microsoft SQL Server) (`QODBC`). A complete list can
    be found at [https://doc.qt.io/qt-5/qsqldatabase.html#QSqlDatabase-2](https://doc.qt.io/qt-5/qsqldatabase.html#QSqlDatabase-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our database object is created, we need to configure it with any required
    connection settings, such as the host, user, password, and database name. For
    SQLite, we only need to specify a filename, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the properties we can configure include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hostName`—The hostname or IP of the database server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`—The network port on which the database service is listening'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userName`—The username to connect with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`—The password to authenticate with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connectOptions`—A string of additional connection options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these can be configured or queried using the usual accessor method (for
    example, `hostName()` and `setHostName()`). If you're working with something other
    than SQLite, consult its documentation to see what settings you need to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Once our connection object is configured, we can open the connection using the
    `open()` method. This method returns a Boolean value, indicating whether or not
    the connection succeeded. If it failed, we can find out why by checking the connection
    object's `lastError` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code demonstrates how we might do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call `self.db.open()` and, if it fails, we retrieve the error from
    `lastError` and display it in a dialog. The `lastError()` call returns a `QSqlError`
    object, which holds data and metadata about the error; to extract the actual error
    text, we call its `text()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once our connection is actually connected, we can use it to start inspecting
    the database. For example, the `tables()` method lists all tables in the database.
    We can use this to check that all required tables are present as follows, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we compare the tables that exist in the database to a set of the required
    tables. If we find any missing, we'll show an error and exit.
  prefs: []
  type: TYPE_NORMAL
- en: '`set` objects are like lists, except that all items in them are unique, and
    they allow for some useful comparisons. In this situation, we''re subtracting
    sets to find out whether there are any items in `required_tables` that aren''t
    in `tables`.'
  prefs: []
  type: TYPE_NORMAL
- en: Making simple queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with our SQL database relies on the `QSqlQuery` class. This class
    represents a request to the SQL engine and can be used to prepare, execute, and
    retrieve data and metadata about a query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a SQL query to the database by using our database object''s `exec()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exec()` method creates a `QSqlQuery` object from our string, executes
    it, and returns it to us. We can then retrieve the results of our query from the
    `query` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's important to get a mental model of what's happening here, because it's
    not terribly intuitive. As you know, SQL queries always return a table of data,
    even if there is just one row and one column. `QSqlQuery` has an implicit *cursor*
    that will be pointed at a row of the data. Initially, this cursor is pointed nowhere,
    but calling the `next()` method moves it to the next available row of data, which,
    in this case, is the first row. The `value()` method is then used to retrieve
    the value of a given column in the currently selected row (`value(0)` will retrieve
    the first column, `value(1)` the second, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what''s happening here is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The query is executed and populated with data. The cursor points nowhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `next()` to point the cursor at the first row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `value(0)` to retrieve the value from the first column of the row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To retrieve a list or table of data from a `QSqlQuery` object, we just need
    to repeat those last two steps until `next()` returns `False` (meaning that there
    is not the next row to point to). For example, we need a list of the coffee roasts
    to populate our form, so let''s retrieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've asked a query to get all the data from the `roasts` table
    and order it by `id`. Then, we call `next()` on our query object until it returns
    `False`; each time, extracting the value of the second field (`query.value(1)`)
    and appending it to our `roasts` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have that data, we can create our `CoffeeForm` and add it to the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In addition to retrieving values using `value()`, we can retrieve an entire
    row by calling the `record()` method. This returns a `QSqlRecord` object containing
    data for the current row (or an empty record, if no row is pointed at). We'll
    use `QSqlRecord` later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Prepared queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, data needs to be passed into a SQL query from an application. For
    example, we need to write a method that looks up a single coffee by ID number
    so that we can display it in our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could start writing that method something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, we're using a format string to put the `coffee_id` value
    directly into our query. Do not do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using string formatting or concatenation to build SQL queries can lead to something
    called a **SQL injection vulnerability**, in which passing a specially crafted
    value can expose or destroy data in the database. In this case, we''re assuming
    that `coffee_id` is going to be an integer, but suppose a malicious user is able
    to send this function a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our string formatting would evaluate this and generate the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The result would be that all the rows in our `coffees` table would be deleted!
    While this may seem trivial or absurd in this context, SQL injection vulnerabilities
    are behind many of the data breaches and hacking scandals you read about in the
    news. It's important to be defensive when working with important data (and what's
    more important than coffee?).
  prefs: []
  type: TYPE_NORMAL
- en: The proper way to do this query and protect your database from such vulnerabilities
    is to use a prepared query. A **prepared query** is a query that contains variables
    to which we can bind values. The database driver will then properly escape our
    values so that they are not accidentally interpreted as SQL code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the code uses a prepared query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've explicitly created an empty `QSqlQuery` object connected to our
    database. Then, we passed a SQL string to the `prepare()` method. Notice the `:id`
    string used in our query; the colon indicates that this is a variable. Once we
    have the prepared query, we can begin binding the variables in the query to variables
    in our code using `bindValue()`. In this case, we've bound the `:id` SQL variable to
    our `coffee_id` Python variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once our query is prepared and the variables are bound, we call its `exec()`
    method to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once executed, we can extract the data from the query object just as we''ve
    done before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the same approach to retrieve the coffee''s review data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we did not pass the database connection object to the `QSqlQuery`
    constructor this time. Since we only have one connection, it's not necessary to
    pass the database connection object to `QSqlQuery`; `QtSQL` will automatically
    use our default connection in any method call that requires a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we're using the column names, rather than their numbers, to
    fetch the values from our `reviews` table. This works just as well, and is a much
    friendlier approach, especially in tables with many columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll finish off this method by populating and showing our coffee form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that prepared queries are only able to introduce *values* into a query.
    You cannot, for example, prepare a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you want to build queries containing variable tables or column names, you'll
    have to resort to string formatting, unfortunately. In such cases, be aware of
    the potential for SQL injection and take extra precautions to ensure that the
    values being interpolated are what you think they are.
  prefs: []
  type: TYPE_NORMAL
- en: Using QSqlQueryModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Populating data into a table widget manually seems like an awful chore; if you
    recall [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating Data
    Interfaces with Model-View Classes*, Qt provides us with model-view classes that
    do the boring work for us. We could subclass `QAbstractTableModel` and create
    a model that is populated from a SQL query, but fortunately, `QtSql` already provides
    this in the form of `QSqlQueryModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, `QSqlQueryModel` is a table model that uses a SQL query
    for its data source. We''ll use one to create our coffee products list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After creating our model, we set its `query` property to a SQL `SELECT` statement.
    The model's data will be drawn from the table returned by this query.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with `QSqlQuery`, we don't need to explicitly pass a database connection
    because there's only one. If you did have multiple database connections active,
    you should pass the one you want to use to `QSqlQueryModel()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the model, we can use it in `QTableView`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating
    Data Interfaces with Model-View Classes*, we've created `QTableView` and passed
    the model to its `setModel()` method. Then, we added the table view to the stacked
    widget and set it as the currently visible widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the table view will use the column names from the query as the
    header labels. We can override this by using the model''s `setHeaderData()` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the `QSqlQueryModel` object is in read-only mode, so there
    is no way to set this table view to editable in order to change details about
    our coffee list. We'll look at how to have an editable SQL model in the next section,
    *Using model-view widgets without SQL*. First, though, let's finish our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our application has both the list and the form widgets, let''s enable
    some navigation between them. First, create a toolbar button to switch from the
    coffee form to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll configure our list so that double-clicking an item will show the
    coffee form with that coffee record in it. Remember that our `MainView.show_coffee()`
    method expects the coffee''s `id` value, but the list widget''s `itemDoubleClicked`
    signal carries the model index of the click. Let''s create a method on `MainView`
    to translate one to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since `id` is in column `0` of the model, we retrieve the index of column `0`
    from whatever row was clicked using `siblingAtColumn(0)`. Then we can retrieve
    the `id` value by passing that index to `model().data()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this, let''s add a connection for the `itemDoubleClicked`
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a simple, read-only application for our coffee database.
    We can certainly keep going with the current approach of using SQL queries to
    manage our data, but Qt provides a more elegant approach. We'll explore that approach
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using model-view widgets without SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having used `QSqlQueryModel` in the last section, you might wonder whether this
    approach can be further generalized to just access tables directly and avoid having
    to write SQL queries altogether. You also might wonder if we can get around the
    read-only limitations of `QSqlQueryModel`. The answer to both questions is *yes*,
    thanks to `QSqlTableModel` and `QSqlRelationalTableModels`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how these work, let''s back up and start over with our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a fresh template copy, calling it `coffee_list2.py`. Add the import
    for `QtSql` and the database connection code from the first application. Now let''s
    start building using table models. For simple situations where we want to create
    a model from a single database table, we can use `QSqlTableModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reviews_model` is now a read-write table model for the `reviews` table.
    Just as we used our CSV table model to edit our CSV file in [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml),
    *Creating Data Interfaces with Model-View Classes*, we can use this model to view
    and edit the `reviews` table. For tables that need to look up values from joined
    tables, we can use`QSqlRelationalTableModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we have a table model that can be used to view and edit the data
    in the SQL table; this time, the `coffees` table. However, the `coffees` table
    has a `roast_id` column that references the `roasts` table. `roast_id` is not
    meaningful to the application user, who would much rather work with the roast''s
    `description` column. To replace `roast_id` with `roasts.description` in our model,
    we can use the `setRelation()` function to join the two tables together, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This method takes two arguments. The first is the column number of the main
    table that we're joining, which we can fetch by name using the model's `fieldIndex()`
    method. The second is a `QSqlRelation` object, which represents a foreign key
    relationship. The arguments it takes are the table name (`roasts`), the related
    column in the joined table (`roasts.id`), and the field to display for this relationship
    (`description`).
  prefs: []
  type: TYPE_NORMAL
- en: The result of setting this relationship is that our table view will use the
    related `description` column from `roasts` in place of the `roast_id` value when
    we join our `coffee_model` to a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can join the model to the view, there''s one more step we need to
    take:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we configure or reconfigure a `QSqlTableModel` or `QSqlRelationalTableModel`,
    we must call its `select()` method. This causes the model to generate and run
    a SQL query to refresh its data and make it available to views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our model is ready, we can try it in a view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program at this point, you should get something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/85eb90e0-609f-4e31-9fff-1299a9c8b9b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that, thanks to our relational table model, we have a `description` column
    containing the description of the roast in place of the `roast_id` column. Just
    what we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, at this point, you can view and edit any of the values in the
    coffee list. `QSqlRelationalTableModel` is read/write by default, and we do not
    need to make any adjustments to the view to make it editable. However, it could
    use some improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and data mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can edit the list, we can't yet add or remove items in the list; let's
    add that capability before we move on to the coffee form itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating some toolbar actions pointing to `MainView` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write the `MainView` methods for those actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To delete a row from the model, we can call its `removeRow()` method, passing
    in the row number desired. This, we can obtain from the `selectedIndexes` property.
    To add a row, we call the model's `insertRows()` method. This code should be familiar,
    from [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating Data Interfaces
    with Model-View Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run the program and try to add a row, notice that you get what is
    essentially a `QLineEdit` in each cell for entering the data. This is fine for
    text fields such as coffee brand and product name, but for the roast description,
    it makes more sense to have something that constrains us to the proper values,
    such as a combo box.
  prefs: []
  type: TYPE_NORMAL
- en: In Qt's model-view system, the object that decides what widget to draw for a
    piece of data is called a **delegate**. The delegate is a property of the view,
    and by setting our own delegate object we can control how data is presented for
    viewing or editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a view backed by `QSqlRelationalTableModel`, we can take advantage
    of a ready-made delegate called `QSqlRelationalDelegate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`QSqlRelationalDelegate` automatically provides a combo box for any field for
    which a `QSqlRelation` has been set. With this simple change, you should find
    that the `description` column now presents you with a combo box containing the
    available description values from the `roasts` table. Much better!'
  prefs: []
  type: TYPE_NORMAL
- en: Data mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our coffee list is in good shape, it's time to deal with the coffee
    form, which will allow us to display and edit the details of individual products
    and their reviews
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the GUI code for the coffee details part of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This section of the form is the exact same information that we displayed in
    the coffee list, except now we're displaying just a single record, using a series
    of distinct widgets. Connecting our `coffees` table model to a view was straightforward,
    but how can we connect a model to a form like this? One answer is with a `QDataWidgetMapper`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of `QDataWidgetMapper` is to map fields from a model to widgets
    in a form. To see how it works, let''s add one to `CoffeeForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The mapper sits between the model and the form's fields, translating the columns
    between them. In order to ensure that data is written properly from the form widgets
    to the relational fields in the model, we also need to set an `itemDelegate` of
    the proper type, in this case, `QSqlRelationalDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a mapper, we need to define the field mappings using the `addMapping`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addMapping()` method takes two arguments: a widget and a model column
    number. We''re using the model''s `fieldIndex()` method to retrieve these column
    numbers by name, but you could also just use integers here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use our combo box, we need to populate it with options. To do
    this, we need to retrieve the `roasts` model from our relational model and pass
    it to the combo box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `relationalModel()` method can be used to retrieve an individual table model
    back from our `coffees_model` object by passing in the field number. Notice we
    retrieve the field number by asking for the field index of `description`, not
    `roast_id`. In our relational model, `roast_id` has been replaced with `description`.
  prefs: []
  type: TYPE_NORMAL
- en: While the coffee list `QTableView` can display all records at once, our `CoffeeForm`
    is designed to show only one record at a time. For this reason, `QDataWidgetMapper`
    has the concept of a *current record* and will populate the widgets only with
    the data of the current record.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to display data in our form, then, we need to control the record that
    the mapper is pointed to. The `QDataWidgetMapper` class has five methods to navigate
    through the table of records:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `toFirst()` | Go to the first record in the table. |'
  prefs: []
  type: TYPE_TB
- en: '| `toLast()` | Go to the last record in the table. |'
  prefs: []
  type: TYPE_TB
- en: '| `toNext()` | Advance to the next record in the table. |'
  prefs: []
  type: TYPE_TB
- en: '| `toPrevious()` | Go back to the previous record. |'
  prefs: []
  type: TYPE_TB
- en: '| `setCurrentIndex()` | Go to a specific row number. |'
  prefs: []
  type: TYPE_TB
- en: 'Since our user is selecting an arbitrary coffee from the list to navigate to,
    we are going to use the last method, `setCurrentIndex()`. We''ll use this in our
    `show_coffee()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`setCurrentIndex()` takes a single integer value that corresponds to the row
    number in the model. Note that this is not the same as the coffee''s `id` value,
    which we used in the previous version of the application. We''re working strictly
    with model index values at this point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our working `CoffeeForm`, let''s create one back in `MainView`
    and connect it to our coffee list''s signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Since we're using indexes instead of row numbers, we can just connect our `doubleClicked`
    signal directly to the form's `show_coffee()` method. We'll also connect it to
    a lambda function to change the current widget to the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re here, let''s go ahead and create a toolbar action to return to
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated callback looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To accommodate possible changes to the data that may have happened while editing
    in `CoffeeForm`, we'll call `resizeColumnsToContents()` and `resizeRowsToContents()`.
    Then, we simply set the stack widget's current widget to `coffee_list`.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing we need to take care of in this application is the review section
    of the coffee form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reviews model, remember, is `QSqlTableModel`, which we pass into the `CoffeeForm`
    constructor. We can easily bind it to `QTableView`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds a table of reviews to our form. Before moving on, let''s take care
    of some cosmetic issues with the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first two columns of the table are the `id` and `coffee_id`, both of which
    are implementation details we don't need to display for the user. The last line
    of code causes the fourth field (`review`) to expand to the right-hand edge of
    the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this, you''ll see we have a slight problem here: we don''t want
    to see *all* the reviews in the table when we view a coffee''s record. We only
    want to display the ones that are associated with the current coffee product.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by applying a **filter** to the table model. In the `show_coffee()`
    method, we''ll add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We begin by extracting the selected coffee's `id` number from our coffee model.
    This may not be the same as the row number, which is why we are consulting the
    value from column 0 of the selected row. We're going to save it as an instance
    variable because we may need it later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the review model's `setFilter()` method. This method takes a string
    that it will quite literally append to a `WHERE` clause in the query used to select
    data from the SQL table. Likewise, `setSort()` will set the `ORDER BY` clause.
    In this case, we're sorting by the review date, with the most recent first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, there is no way to use a bound variable in `setFilter()`, so
    if you want to insert a value, you must use string formatting. As you have learned,
    this opens you up to SQL injection vulnerabilities, so be *very* careful about
    how you insert data. In this example, we've cast `coffee_id` to an `int` to make
    sure it's not SQL injection code.
  prefs: []
  type: TYPE_NORMAL
- en: After setting our filter and sort properties, we need to call `select()` to
    apply them. Then, we can resize our rows and columns to the new content. Now,
    the form should only show reviews for the currently selected coffee.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reviews table contains a column with a date; while we can certainly edit
    dates using a regular `QLineEdit`, it would be nicer if we could use the more
    appropriate `QDateEdit` widget. Unlike the situation with our coffee list view,
    Qt doesn''t have a ready-made delegate that will do this for us. Fortunately,
    we can easily create our own delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `CoffeeForm` class, let''s define a new delegate class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The delegate class inherits `QStyledItemDelegate`, and its `createEditor()`
    method is responsible for returning the widget that will be used for editing the
    data. In this case, we simply need to create `QDateEdit` and return it. We can
    configure the widget any way that we deem appropriate; for instance, we've enabled
    the calendar popup here.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're passing along the `parent` argument—this is critical! If you
    don't explicitly pass the parent widget, your delegate widget will pop up in its
    own top-level window.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes in the reviews table, this is all that we need to change.
    In more complex scenarios, there are a few other methods you might need to override:'
  prefs: []
  type: TYPE_NORMAL
- en: The `setModelData()` method is responsible for extracting data from the widget
    and passing it to the model. You might override this if the raw data from the
    widget needs to be converted or prepped in some way before being updated in the
    model.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setEditorData()` method is responsible for retrieving data from the model
    and writing it to the widget. You might override this if the model data isn't
    in the right format for the widget to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `paint()` method draws the editing widget to the screen. You might override
    this to build a custom widget or to change the appearance of the widget depending
    on the data. If you override this method, you might also need to override `sizeHint()`
    and `updateEditorGeometry()` to make sure enough space is provided for your custom
    widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we''ve created our custom delegate class, we need to tell our table view
    to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've created an instance of `DateDelegate` and told the `reviews`
    view to use it for the `review_date` column. Now, when you edit the review date,
    you'll get `QDateEdit` with a calendar popup.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting custom rows in a table view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last feature we want to implement is adding and deleting rows in our review
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with some buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback for deleting rows is straightforward enough:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with `MainView.coffee_list`, we just iterate through the selected
    indexes and remove them by row number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding new rows presents a problem: we can add rows, but we need to make sure
    they''re set to use the currently selected `coffee_id`. To do this, we''ll use
    a `QSqlRecord` object. This object represents a single row from `QSqlTableModel`,
    and can be created using the model''s `record()` method. Once we have an empty
    `record` object, we can populate it with values and write it back to the model.
    Our callback starts like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To begin with, we extract an empty record from the `reviews_model` by calling
    `record()`. It's important to do this from the model, as it will be prepopulated
    with all the model's fields. Next, we need to set the values. By default, all
    fields are set to `None` (SQL `NULL` ), so we'll need to override this if we want
    a default value or if our fields have a `NOT NULL` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're setting `coffee_id` to the currently shown coffee ID (good
    thing we saved that as an instance variable, eh?) and `review_date` to the current
    date. We're also setting `reviewer` and `review` to empty strings because they
    have `NOT NULL` constraints. Note that we're leaving `id` as `None`, because inserting
    a `NULL` on a field will cause it to use its default value (which, in this case,
    will be an auto-incremented integer).
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting up the `dict`, we iterate through it and write the values to
    the record''s fields. Now we need to insert this prepared record into the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`QSqlTableModel.insertRecord()` takes the index of insertion (`-1` means the
    end of the table) and the record to insert, and returns a simple Boolean value
    indicating whether insertion was successful. If it failed, we can query the model
    for the error text by calling `lastError().text()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `select()` on the model. This will repopulate the view with
    our inserted record and allow us to edit the remaining fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, our application is fully functional. Take some time to insert
    new records and reviews, edit records, and delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about SQL databases and how to use them with PyQt.
    You learned the basics of creating a relational database with SQL, how to connect
    to the database with the `QSqlDatabase` class, and how to execute queries on the
    database. You also learned how to build elegant database applications without
    having to write SQL by using the SQL model-view classes available in `QtSql`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you're going to learn how to create asynchronous applications
    that can deal with slow workloads without locking up your application. You'll
    learn the effective use of the `QTimer` class, as well as how to safely utilize
    `QThread`. We'll also cover the use of `QTheadPool` to enable high-concurrency
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Compose a SQL `CREATE` statement that builds a table to hold television schedule
    listings. Make sure it has fields for date, time, channel, and program name. Also
    make sure it has a primary key and constraints to prevent nonsensical data (such
    as two shows at the same time on the same channel, or a show with no time or date).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following SQL query is returning a syntax error; can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The following SQL query doesn't work correctly; can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The documentation for `QSqlDatabase` can be found at [https://doc.qt.io/qt-5/qsqldatabase.html](https://doc.qt.io/qt-5/qsqldatabase.html).
    Read up on how you can work with multiple database connections; for example, a
    read-only and read/write connection to the same database. How would you create
    two connections and make specific queries to each?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `QSqlQuery`, write code to safely insert the data in the `dict` object
    into the `coffees` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve created a `QSqlTableModel` object and attached it to a `QTableView`.
    You know there is data in the table, but it is not showing in the view. Look at
    the code and decide what is wrong:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a callback attached to the `textChanged` signal of `QLineEdit`.
    Explain why this is not a good idea:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You decide you'd rather have colors than names in the `roasts` combo boxes in
    your coffee list. What changes would you need to make to accomplish this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out these resources for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: A guide to the SQL language used in SQLite can be found at [https://sqlite.org/lang.html](https://sqlite.org/lang.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the `QtSQL` module and its use can be found at [https://doc.qt.io/qt-5/qtsql-index.html](https://doc.qt.io/qt-5/qtsql-index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
