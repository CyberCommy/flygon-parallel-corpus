- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying a Microservice Architecture to Your Enterprise Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to describing highly scalable architectures based
    on small modules called microservices. The microservices architecture allows for
    fine-grained scaling operations where every single module can be scaled as required
    without it affecting the remainder of the system. Moreover, they allow for better
    **Continuous Integration/Continuous Deployment** (**CI/CD**) by permitting every
    system subpart to evolve and be deployed independently of the others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When do microservices help?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does .NET deal with microservices?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which tools are needed to manage microservices?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement a single
    microservice in .NET. *Chapter 6*, *Azure Service Fabric*, and *Chapter 7*, *Azure
    Kubernetes Service*, also explain how to deploy, debug, and manage a whole microservices-based
    application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community edition or better with all the database tools
    installed.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop for Windows if you want to debug Docker containerized microservices
    in Visual Studio ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are microservices?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architectures allow each module that makes up a solution to be
    scaled independently from the others to achieve the maximum throughput with minimal
    cost. In fact, scaling whole systems instead of their current bottlenecks inevitably
    results in a remarkable waste of resources, so fine-grained control of subsystem
    scaling has a considerable impact on the system's overall cost.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: However, microservices are more than scalable components – they are software
    building blocks that can be developed, maintained, and deployed independently
    of each other. Splitting development and maintenance among modules that can be
    independently developed, maintained, and deployed improves the overall system's
    CI/CD cycle (the CI/CD concept was explained in more detail in the *Organizing
    your work using Azure DevOps* section in *Chapter 3*, *Documenting Requirements
    with Azure DevOps*).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The CI/CD improvement is due to microservice *independence* because it enables
    the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Scaling and distributing microservices on different types of hardware.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since each microservice is deployed independently from the others, there can't
    be binary compatibility or database structure compatibility constraints. Therefore,
    there is no need to align the versions of the different microservices that compose
    the system. This means that each of them can evolve, as needed, without being
    constrained by the others.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning their development to completely separate smaller teams, thus simplifying
    job organization and reducing all the inevitable coordination inefficiencies that
    arise when handling large teams.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing each microservice with more adequate technologies and in a more
    adequate environment, since each microservice is an independent deployment unit.
    This means choosing tools that best fit your requirements and an environment that
    minimizes development efforts and/or maximizes performance.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since each microservice can be implemented with different technologies, programming
    languages, tools, and operating systems, enterprises can use all available human
    resources by matching environments with developers' competencies. For instance,
    underused Java developers can also be involved in .NET projects if they implement
    microservices in Java with the same required behavior.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy subsystems can be embedded in independent microservices, thus enabling
    them to cooperate with newer subsystems. This way, companies may reduce the time
    to market of new system versions. Moreover, this way, legacy systems can evolve
    slowly toward more modern systems with an acceptable impact on costs and the organization.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsection explains how the concept of microservices was conceived.
    Then, we will continue this introductory section by exploring basic microservice
    design principles and analyzing why microservices are often designed as Docker
    containers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and the evolution of the concept of modules
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a better understanding of the advantages of microservices, as well as their
    design techniques, we must keep the two-folded nature of software modularity,
    and of software modules, in mind:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Code modularity refers to code organization that makes it easy for us to modify
    a chunk of code without affecting the remainder of the application. It is usually
    enforced with object-oriented design, where modules can be identified with classes.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment modularity** depends on what your deployment units are and which
    properties they have. The simplest deployment units are executable files and libraries.
    Thus, for instance, **dynamic link libraries** (**DLLs**) are, for sure, more
    modular than static libraries since they must not be linked with the main executable
    before being deployed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the fundamental concepts of code modularity have reached stasis, the concept
    of deployment modularity is still evolving and microservices are currently state
    of the art along this evolution path.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: As a short review of the main milestones on the path that led to microservices,
    we can say that, first, monolithic executables were broken into static libraries.
    Later on, DLLs replaced static libraries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: A great change took place when .NET (and other analogous frameworks, such as
    Java) improved the modularity of executables and libraries. In fact, with .NET,
    they can be deployed on different hardware and on different operating systems
    since they are deployed in an intermediary language that's compiled when the library
    is executed for the first time. Moreover, they overcome some versioning issues
    of previous DLLs since any executable brings with it a DLL with a version that
    differs from the version of the same DLL that is installed in the operating system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'However, .NET can''t accept two referenced DLLs – let''s say, *A* and *B* –
    using two different versions of a common dependency – let''s say, *C*. For instance,
    suppose there is a newer version of *A* with a lot of new features we would like
    to use that, in turn, rely on a newer version of *C* that''s not supported by
    *B*. In this situation, we should renounce the newer version of *A* because of
    the incompatibility of *C* with *B*. This difficulty has led to two important
    changes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The development world moved from DLLs and/or single files to package management
    systems such as NuGet and npm, which automatically check version compatibility
    with the help of semantic versioning.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service-Oriented Architecture** (**SOA**). Deployment units started being
    implemented as SOAP and then as REST web services. This solves the version compatibility
    problem since each web service runs in a different process and can use the most
    adequate version of each library with no risk of causing incompatibilities with
    other web services. Moreover, the interface that''s exposed by each web service
    is platform-agnostic, that is, web services can connect with applications using
    any framework and run on any operating system since web service protocols are
    based on universally accepted standards. SOAs and protocols will be discussed
    in more detail in *Chapter 14*, *Applying Service-Oriented Architectures with
    .NET Core*.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices are an evolution of SOA and add more features and more constraints
    that improve the scalability and the modularity of services to improve the overall
    CI/CD cycle. It's sometimes said that *microservices are SOA done well*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是SOA的演变，并增加了更多功能和约束，以改善服务的可伸缩性和模块化，以改善整体的CI/CD周期。有时人们说*微服务是SOA做得好*。
- en: Microservices design principles
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务设计原则
- en: To sums things up, the microservice architecture is an SOA that maximizes independence
    and fine-grained scaling. Now that we've clarified all the advantages of microservice
    independence and fine-grained scaling, as well as the very nature of independence,
    we are in a position to look at microservice design principles.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，微服务架构是最大程度地实现独立性和细粒度扩展的SOA。现在我们已经澄清了微服务独立性和细粒度扩展的所有优势，以及独立性的本质，我们可以看看微服务设计原则。
- en: Let's start with principles that arise from the independence constraint. We
    will discuss them each in a separate subsection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从独立性约束产生的原则开始。我们将在单独的小节中讨论它们。
- en: The independence of design choices
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计选择的独立性
- en: The design of each microservice must not depend on the design choices that were
    made in the implementation of other microservices. This principle enables the
    full independence of each microservice CI/CD cycle and leaves us with more technological
    choices on how to implement each microservice. This way, we can choose the best
    available technology to implement each microservice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务的设计不能依赖于在其他微服务实现中所做的设计选择。这个原则使得每个微服务的CI/CD周期完全独立，并让我们在如何实现每个微服务上有更多的技术选择。这样，我们可以选择最好的可用技术来实现每个微服务。
- en: Another consequence of this principle is that different microservices can't
    connect to the same shared storage (database or filesystem) since sharing the
    same storage also means sharing all the design choices that determined the structure
    of the storage subsystem (database table design, database engine, and so on).
    Thus, either a microservice has its own data storage or it has no storage at all
    and communicates with other microservices that take care of handling storage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则的另一个结果是，不同的微服务不能连接到相同的共享存储（数据库或文件系统），因为共享相同的存储也意味着共享决定存储子系统结构的所有设计选择（数据库表设计，数据库引擎等）。因此，要么一个微服务有自己的数据存储，要么根本没有存储，并与负责处理存储的其他微服务进行通信。
- en: Here, having dedicated data storage doesn't mean that the physical database
    is distributed within the process boundary of the microservice itself, but that
    the microservice has exclusive access to a database or set of database tables
    that are handled by an external database engine. In fact, for performance reasons,
    database engines must run on dedicated hardware and with OS and hardware features
    that are optimized for their storage functionalities.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，拥有专用的数据存储并不意味着物理数据库分布在微服务本身的进程边界内，而是微服务具有对由外部数据库引擎处理的数据库或一组数据库表的独占访问权限。事实上，出于性能原因，数据库引擎必须在专用硬件上运行，并具有针对其存储功能进行优化的操作系统和硬件功能。
- en: Usually, *independence of design choices* is interpreted in a lighter form by
    distinguishing between logical and physical microservices. More specifically,
    a logical microservice is implemented with several physical microservices that
    use the same data storage but that are load-balanced independently. That is, the
    logical microservice is designed as a logical unit and then split into more physical
    microservices to achieve better load balance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*设计选择的独立性*以更轻的形式解释，通过区分逻辑和物理微服务。更具体地说，逻辑微服务是由使用相同数据存储但独立负载平衡的多个物理微服务实现的。也就是说，逻辑微服务被设计为一个逻辑单元，然后分割成更多的物理微服务以实现更好的负载平衡。
- en: Independence from the deployment environment
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立于部署环境
- en: Microservices are scaled out on different hardware nodes and different microservices
    can be hosted on the same node. Therefore, the less a microservice relies on the
    services offered by the operating system and on other installed software, the
    more available hardware nodes it can be deployed on. More node optimization can
    also be performed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在不同的硬件节点上进行扩展，并且不同的微服务可以托管在同一节点上。因此，微服务越少依赖操作系统提供的服务和其他安装的软件，它就可以部署在更多的硬件节点上。还可以进行更多的节点优化。
- en: This is the reason why microservices are usually containerized and use Docker.
    Containers will be discussed in more detail in the *Containers and Docker* subsection
    of this chapter, but basically, containerization is a technique that allows each
    microservice to bring its dependencies with it so that it can run anywhere.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么微服务通常是容器化并使用Docker的原因。容器将在本章的*容器和Docker*小节中更详细地讨论，但基本上，容器化是一种技术，允许每个微服务携带其依赖项，以便它可以在任何地方运行。
- en: Loose coupling
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Each microservice must be loosely coupled with all the other microservices.
    This principle has a two-fold nature. On the one hand, this means that, according
    to object-oriented programming principles, the interface that's exposed by each
    microservice must not be too specific, but as general as possible. However, it
    also means that communications among microservices must be minimized in order
    to reduce communication costs since microservices don't share the same address
    space and run on different hardware nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务必须与所有其他微服务松散耦合。这个原则具有双重性质。一方面，这意味着，根据面向对象编程原则，每个微服务公开的接口不能太具体，而应尽可能通用。然而，这也意味着微服务之间的通信必须最小化，以减少通信成本，因为微服务不共享相同的地址空间，运行在不同的硬件节点上。
- en: No chained requests/responses
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要有链接的请求/响应
- en: When a request reaches a microservice, it must not cause a recursive chain of
    nested requests/responses to other microservices since a similar chain would result
    in an unacceptable response time. Chained requests/responses can be avoided if
    the private data models of all the microservices synchronize with push notifications
    each time they change. In other words, as soon as the data that's handled by a
    microservice changes, those changes are sent to all the microservices that may
    need them to serve their requests. This way, each microservice has all the data
    it needs to serve all its incoming requests in its private data storage, with
    no need to ask other microservices for the data that it lacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达微服务时，它不能引起对其他微服务的递归链式请求/响应，因为类似的链式请求/响应会导致无法接受的响应时间。如果所有微服务的私有数据模型在每次更改时都与推送通知同步，就可以避免链式请求/响应。换句话说，一旦由微服务处理的数据发生变化，这些变化就会发送到可能需要这些数据来处理其请求的所有微服务。这样，每个微服务都在其私有数据存储中拥有处理所有传入请求所需的所有数据，无需向其他微服务请求缺少的数据。
- en: In conclusion, every microservice must contain all the data it needs to serve
    incoming requests and ensure fast responses. To keep their data models up to date
    and ready for incoming requests, microservices must communicate their data changes
    as soon as they take place. These data changes should be communicated through
    asynchronous messages since synchronous nested messages cause unacceptable performance
    because they block all the threads involved in the call tree until a result is
    returned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，每个微服务必须包含其所需的所有数据，以提供传入请求并确保快速响应。为了使其数据模型保持最新并准备好处理传入请求，微服务必须在数据发生变化时立即通知其它微服务。这些数据变化应通过异步消息进行通信，因为同步嵌套消息会导致不可接受的性能问题，因为它们会阻塞所有涉及调用树的线程，直到返回结果。
- en: It is worth pointing out that the *Independence of design choices* principle
    is substantially the bounded context principle of domain-driven design, which
    we will talk about in detail in *Chapter 12*, *Understanding the Different Domains
    in Software Solutions*. In this chapter, we will see that, often, a full domain-driven
    design approach is useful for the *update* subsystem of each microservice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，“设计选择的独立性”原则实际上是领域驱动设计中的有界上下文原则，我们将在《第12章：理解软件解决方案中的不同领域》中详细讨论。在本章中，我们将看到，通常情况下，完整的领域驱动设计方法对于每个微服务的“更新”子系统非常有用。
- en: It's not trivial that, in general, all systems that have been developed according
    to the bounded context principle are better implemented with a microservice architecture.
    In fact, once a system has been decomposed into several completely independent
    and loosely coupled parts, it is very likely that these different parts will need
    to be scaled independently because of different traffic and different resource
    requirements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，按照有界上下文原则开发的所有系统通常都更适合使用微服务架构来实现。实际上，一旦将系统分解为几个完全独立且松耦合的部分，由于不同的流量和不同的资源需求，这些不同的部分很可能需要独立扩展。
- en: At the preceding constraints, we must also add some best practices for building
    a reusable SOA. More details on these best practices will be given in *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*, but nowadays, most
    SOA best practices are automatically enforced by tools and frameworks that are
    used to implement web services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述约束，我们还必须添加一些构建可重用SOA的最佳实践。关于这些最佳实践的更多细节将在《第14章：使用.NET Core应用面向服务的架构》中给出，但是现在，大多数SOA最佳实践都是由用于实现Web服务的工具和框架自动强制执行的。
- en: Fine-grained scaling requires that microservices are small enough to isolate
    well-defined functionalities, but this also requires a complex infrastructure
    that takes care of automatically instantiating microservices, allocating instances
    on various hardware computational resources, commonly called **nodes**, and scaling
    them as needed. These kinds of structures will be introduced in the *Which tools
    are needed to manage microservices?* section of this chapter, and discussed in
    detail in *Chapter 6*, *Azure Service Fabric*, and *Chapter 7*, *Azure Kubernetes*
    *Service*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度的扩展要求微服务足够小，以便隔离明确定义的功能，但这也需要一个复杂的基础架构来自动实例化微服务，将实例分配到各种硬件计算资源上，通常称为“节点”，并根据需要进行扩展。这些结构将在本章的“需要哪些工具来管理微服务？”部分中介绍，并在《第6章：Azure
    Service Fabric》和《第7章：Azure Kubernetes Service》中详细讨论。
- en: Moreover, fine-grained scaling of distributed microservices that communicate
    through asynchronous communication requires each microservice to be resilient.
    In fact, communication that's directed to a specific microservice instance may
    fail due to a hardware fault or for the simple reason that the target instance
    was killed or moved to another node during a load balancing operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过异步通信进行通信的细粒度扩展的分布式微服务要求每个微服务具有弹性。实际上，由于硬件故障或在负载平衡操作期间目标实例被终止或移动到另一个节点的简单原因，针对特定微服务实例的通信可能会失败。
- en: Temporary failures can be overcome with exponential retries. This is where we
    retry the same operation after each failure with a delay that increases exponentially
    until a maximum number of attempts is reached. For instance, first, we would retry
    after 10 milliseconds, and if this retry operation results in a failure, a new
    attempt is made after 20 milliseconds, then after 40 milliseconds, and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 临时故障可以通过指数级重试来克服。这意味着在每次失败后，我们会延迟指数级地重试相同的操作，直到达到最大尝试次数。例如，首先，我们会在10毫秒后重试，如果这次重试操作失败，那么在20毫秒后进行新的尝试，然后是40毫秒，依此类推。
- en: 'On the other hand, long-term failures often cause an explosion of retry operations
    that may saturate all system resources in a way that is similar to a denial-of-service
    attack. Therefore, usually, exponential retries are used together with a *circuit
    break strategy*: after a given number of failures, a long-term failure is assumed
    and access to the resource is prevented for a given time by returning an immediate
    failure without attempting the communication operation.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also fundamental that the congestion of some subsystems, due to either
    failure or to a requests peak, does not propagate to other system parts, in order
    to prevent overall system congestion. **Bulkhead isolation** avoids congestion
    propagation in the following ways:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Only a maximum number of similar simultaneous outbound requests are allowed;
    let's say, 10\. This is similar to putting an upper bound on thread creation.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests exceeding the previous bound are queued.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the maximum queue length is reached, any further requests result in exceptions
    being thrown to abort them.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retry policies may make it so that the same message is received and processed
    several times because the sender has received no confirmation that the message
    has been received or simply because it has timed-out the operation, while the
    receiver actually received the message. The only possible solution to this problem
    is designing all messages so that they're idempotent, that is, designing messages
    in such a way that processing the same message several times has the same effect
    as processing it once.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating a database table field to a value, for instance, is an idempotent
    operation since repeating it once or twice has exactly the same effect. However,
    incrementing a decimal field is not an idempotent operation. Microservice designers
    should make an effort to design the overall application with as many idempotent
    messages as possible. The remaining non-idempotent messages must be transformed
    into idempotent ones in the following way, or with some other similar techniques:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Attach both a time and some identifier that uniquely identify each message.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store all the messages that have been received in a dictionary that's been indexed
    by the unique identifier attached to the message mentioned in the previous point.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reject old messages.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a message that may be a duplicate is received, verify whether it's contained
    in the dictionary. If it is, then it has already been processed, so reject it.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since old messages are rejected, they can be periodically removed from the dictionary
    to avoid it growing exponentially.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use this technique in the example at the end of *Chapter 6*, *Azure
    Service Fabric*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that some message brokers, such as Azure Service Bus,
    offer facilities for implementing the technique described previously. Azure Service
    Bus is discussed in the *.NET communication facilities* subsection.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will talk about microservice containerization based
    on Docker.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Containers and Docker
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already discussed the advantages of having microservices that don''t
    depend on the environment where they run: better hardware usage, the ability to
    mix legacy software with newer modules, the ability to mix several development
    stacks in order to use the best stack for each module implementation, and so on.
    Independence from the hosting environment can be easily achieved by deploying
    each microservice with all its dependencies on a private virtual machine.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: However, starting a virtual machine with its private copy of the operating system
    takes a lot of time, and microservices must be started and stopped quickly to
    reduce load balancing and fault recovery costs. In fact, new microservices may
    be started either to replace faulty ones or because they were moved from one hardware
    node to another to perform load balancing. Moreover, adding a whole copy of the
    operating system to each microservice instance would be an excessive overhead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, microservices can rely on a lighter form of technology: containers.
    Containers are a kind of light virtual machine. They do not virtualize a full
    machine – they just virtualize the OS filesystem level that sits on top of the
    OS kernel. They use the OS of the hosting machine (kernel, DLLs, and drivers)
    and rely on the OS''s native features to isolate processes and resources to ensure
    an isolated environment for the images they run.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微服务可以依赖一种更轻量级的技术：容器。容器是一种轻量级虚拟机。它们不会虚拟化整个机器-它们只是虚拟化位于操作系统内核之上的操作系统文件系统级别。它们使用托管机器的操作系统（内核、DLL和驱动程序），并依赖于操作系统的本机功能来隔离进程和资源，以确保运行的图像的隔离环境。
- en: As a consequence, containers are tied to a specific operating system, but they
    don't suffer the overhead of copying and starting a whole OS in each container
    instance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器与特定的操作系统绑定，但它们不会遭受在每个容器实例中复制和启动整个操作系统的开销。
- en: On each host machine, containers are handled by a runtime that takes care of
    creating them from *images* and creating an isolated environment for each of them.
    The most famous container runtime is Docker, which is a *de facto* standard for
    containerization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在每台主机机器上，容器由运行时处理，该运行时负责从*图像*创建容器，并为每个容器创建一个隔离的环境。最著名的容器运行时是Docker，它是容器化的*事实上的*标准。
- en: Images are files that specify what is put in each container and which container
    resources, such as communication ports, to expose outside the container. Images
    need not to explicitly specify their full content, but they can be layered. This
    way, images are built by adding new software and configuration information on
    top of existing images.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是指定放入每个容器的内容以及要在容器外部公开的容器资源（如通信端口）的文件。图像不需要显式指定其完整内容，但可以分层。这样，通过在现有图像之上添加新的软件和配置信息来构建图像。
- en: For instance, if you want to deploy a .NET application as a Docker image, it
    is enough to just add your software and files to your Docker image and then reference
    an already existing .NET Docker image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想将.NET应用程序部署为Docker镜像，只需将软件和文件添加到Docker镜像中，然后引用已经存在的.NET Docker镜像即可。
- en: 'To allow for easy image referencing, images are grouped into registries that
    may be either public or private. They are similar to NuGet or npm registries.
    Docker offers a public registry ([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry))
    where you can find most of the public images you may need to reference in your
    own images. However, each company can define private registries. For instance,
    Azure offers Microsoft Container Registry, where you can define your private container
    registry service: [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/).
    There, you can also find most of the .NET related images you might need to reference
    in your code.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便图像引用，图像被分组到可能是公共或私有的注册表中。它们类似于NuGet或npm注册表。Docker提供了一个公共注册表（[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)），您可以在其中找到大多数您可能需要在自己的图像中引用的公共图像。然而，每个公司都可以定义私有注册表。例如，Azure提供了Microsoft容器注册表，您可以在其中定义您的私有容器注册表服务：[https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)。在那里，您还可以找到大多数与.NET相关的图像，您可能需要在您的代码中引用它们。
- en: Before instantiating each container, the Docker runtime must solve all the recursive
    references. This cumbersome job is not performed each time a new container is
    created since the Docker runtime has a cache where it stores the fully assembled
    images that correspond to each input image and that it's already processed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化每个容器之前，Docker运行时必须解决所有递归引用。这个繁琐的工作不是每次创建新容器时都执行的，因为Docker运行时有一个缓存，它存储与每个输入图像对应的完全组装的图像。
- en: 'Since each application is usually composed of several modules to be run in
    different containers, Docker also allows `.yml` files, also known as composition
    files, that specify the following information:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个应用程序通常由几个模块组成，这些模块在不同的容器中运行，Docker还允许使用称为`.yml`文件的组合文件，指定以下信息：
- en: Which images to deploy.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署哪些图像。
- en: How the internal resources that are exposed by each image must be mapped to
    the physical resources of the host machine. For instance, how communication ports
    that are exposed by Docker images must be mapped to the ports of the physical
    machine.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将每个图像公开的内部资源映射到主机机器的物理资源。例如，如何将Docker图像公开的通信端口映射到物理机器的端口。
- en: We will analyze Docker images and `.yml` files in the *How does .NET deal with
    microservices?* section of this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的* .NET如何处理微服务？*部分中分析Docker图像和`.yml`文件。
- en: The Docker runtime handles images and containers on a single machine but, usually,
    containerized microservices are deployed and load-balanced on clusters that are
    composed of several machines. Clusters are handled by pieces of software called
    **orchestrators**. Orchestrators will be introduced in the *Which tools are needed
    to manage microservices?* section of this chapter, and described in detail in
    *Chapter 6*, *Azure Service Fabric*, and *Chapter 7*, *Azure Kubernetes Service*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker运行时处理单个机器上的图像和容器，但通常，容器化的微服务是部署和负载均衡在由多台机器组成的集群上的。集群由称为**编排器**的软件组成。编排器将在本章的*需要哪些工具来管理微服务？*部分中介绍，并在*第6章*，*Azure服务织物*和*第7章*，*Azure
    Kubernetes服务*中详细描述。
- en: Now that we have understood what microservices are, what problems they can solve,
    and their basic design principles, we are ready to analyze when and how to use
    them in our system architecture. The next section analyzes when we should use
    them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了微服务是什么，它们可以解决什么问题以及它们的基本设计原则，我们准备分析何时以及如何在我们的系统架构中使用它们。下一节将分析我们应该何时使用它们。
- en: When do microservices help?
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务何时有帮助？
- en: 'The answer to this question requires us to understand the roles microservices
    play in modern software architectures. We will look at this in the following two
    subsections:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题需要我们理解微服务在现代软件架构中的作用。我们将在以下两个小节中进行讨论：
- en: Layered architectures and microservices
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层架构和微服务
- en: When is it worth considering microservice architectures?
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么时候考虑微服务架构是值得的？
- en: Let's start with a detailed look at layered architectures and microservices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解分层架构和微服务。
- en: Layered architectures and microservices
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构和微服务
- en: Enterprise systems are usually organized in logical independent layers. The
    first layer is the one that interacts with the user and is called the presentation
    layer, while the last layer takes care of storing/retrieving data and is called
    the data layer. Requests originate in the presentation layer and pass through
    all the layers until they reach the data layer, and then come back, traversing
    all the layers in reverse until they reach the presentation layer, which takes
    care of presenting the results to the user/client. Layers can't be *jumped*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 企业系统通常以逻辑独立的层组织。第一层是与用户交互的层，称为表示层，而最后一层负责存储/检索数据，称为数据层。请求起源于表示层，并通过所有层传递，直到达到数据层，然后返回，反向穿过所有层，直到达到表示层，表示层负责向用户/客户端呈现结果。层不能“跳过”。
- en: Each layer takes data from the previous layer, processes it, and passes it to
    the next layer. Then, it receives the results from its next layer and sends them
    back to its previous layer. Also, thrown exceptions can't jump layers – each layer
    must take care of intercepting all the exceptions and either *solving them* somehow
    or transforming them into other exceptions that are expressed in the language
    of its previous layer. The layer architecture ensures the complete independence
    of the functionalities of each layer from the functionalities of all the other
    layers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层从前一层获取数据，处理数据，并将其传递给下一层。然后，它从下一层接收结果并将其发送回前一层。此外，抛出的异常不能跨越层 - 每个层必须负责拦截所有异常并解决它们，或将它们转换为以其前一层语言表达的其他异常。层架构确保每个层的功能与所有其他层的功能完全独立。
- en: For instance, we can change the database engine without affecting all the layers
    that are above the data layer. In the same way, we can completely change the user
    interface, that is, the presentation layer, without affecting the remainder of
    the system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更改数据库引擎而不影响数据层以上的所有层。同样，我们可以完全更改用户界面，即表示层，而不影响系统的其余部分。
- en: Moreover, each layer implements a different kind of system specification. The
    data layer takes care of what the system *must remember*, the presentation layer
    takes care of the system-user interaction protocol, and all the layers that are
    in the middle implement the domain rules, which specify how data must be processed
    (for instance, how an employee paycheck must be computed). Typically, the data
    and presentation layers are separated by just one domain rule layer, called the
    business or application layer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个层实现了不同类型的系统规范。数据层负责系统“必须记住”的内容，表示层负责系统用户交互协议，而中间的所有层实现了领域规则，指定数据如何处理（例如，如何计算员工工资）。通常，数据层和表示层之间只有一个领域规则层，称为业务或应用层。
- en: 'Each layer *speaks* a different language: the data layer *speaks* the language
    of the chosen storage engine, the business layer speaks the language of domain
    experts, and the presentation layer speaks the language of users. So, when data
    and exceptions pass from one layer to another, they must be translated into the
    language of the destination layer.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层都“说”不同的语言：数据层“说”所选择的存储引擎的语言，业务层“说”领域专家的语言，表示层“说”用户的语言。因此，当数据和异常从一层传递到另一层时，它们必须被转换为目标层的语言。
- en: A detailed example of how to build a layered architecture will be given in the
    *Use case – understanding the domains of the use case* section in *Chapter 12*,
    *Understanding the Different Domains in Software Solutions*, which is dedicated
    to domain-driven design.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何构建分层架构的详细示例将在《第12章》《理解软件解决方案中的不同领域》的《用例 - 理解用例的领域》部分中给出，该部分专门讨论领域驱动设计。
- en: That being said, how do microservices fit into a layered architecture? Are they
    adequate for the functionalities of all the layers or just some layers? Can a
    single microservice span several layers?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，微服务如何适应分层架构？它们是否适用于所有层的功能还是只适用于某些层？单个微服务是否可以跨越多个层？
- en: 'The last question is the easiest to answer: yes! In fact, we''ve already stated
    that microservices should store the data they need within their logical boundaries.
    Therefore, there are microservices that span the business and data layers. Some
    others take care of encapsulating shared data and remain confined in the data
    layer. Thus, we may have business layer microservices, data layer microservices,
    and microservices that span both layers. So, what about the presentation layer?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题最容易回答：是的！实际上，我们已经说过微服务应该在其逻辑边界内存储所需的数据。因此，有些微服务跨越业务和数据层。其他一些微服务负责封装共享数据并保持在数据层中。因此，我们可能有业务层微服务、数据层微服务以及跨越两个层的微服务。那么，表示层呢？
- en: The presentation layer
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示层
- en: The presentation layer can also fit into a microservice architecture if it is
    implemented on the server side. Single-page applications and mobile applications
    run the presentation layer on the client machine, so they either connect directly
    to the business microservices layer or, more often, to an *API gateway* that exposes
    the public interface and takes care of routing requests to the right microservices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In a microservices architecture, when the presentation layer is a website, it
    can be implemented with a set of microservices. However, if it requires heavy
    web servers and/or heavy frameworks, containerizing them may not be convenient.
    This decision must also consider the loss of performance that happens when containerizing
    the web server and the possible need for hardware firewalls between the web server
    and the remainder of the system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET is a lightweight framework that runs on the light Kestrel web server,
    so it can be containerized efficiently and used in a microservice for intranet
    applications. However, public high-traffic websites require dedicated hardware/software
    components that prevent them from being deployed together with other microservices.
    In fact, while Kestrel is an acceptable solution for an intranet website, public
    websites need a more complete web server such as IIS, Apache, or NGINX. In this
    case, security and load balancing requirements are more compelling and require
    dedicated hardware/software nodes and components. Accordingly, architectures based
    on microservices usually offer specialized components that take care of interfacing
    with the outside world. For instance, in *Chapter 7*, *Azure Kubernetes Service*,
    we will see that in **Kubernetes** clusters, this role is played by the so-called
    **ingresses**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic websites can be easily broken into load-balanced smaller subsites
    without microservice-specific technologies, but a microservice architecture can
    bring all the advantages of microservices into the construction of a single HTML
    page. More specifically, different microservices may take care of different areas
    of each HTML page. Unfortunately, at the time of writing, a similar scenario is
    not easy to implement with the available .NET technology.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'A proof of concept that implements a website with ASP.NET-based microservices
    that cooperate in the construction of each HTML page can be found here: [https://github.com/Particular/Workshop/tree/master/demos/asp-net-core](https://github.com/Particular/Workshop/tree/master/demos/asp-net-core).
    The main limit of this approach is that microservices cooperate just to generate
    the data that''s needed to generate the HTML page and not to generate the actual
    HTML page. Instead, this is handled by a monolithic gateway. In fact, at the time
    of writing, frameworks such as ASP.NET MVC don''t provide any facilities for the
    distribution of HTML generation. We will return to this example in *Chapter 15*,
    *Presenting ASP.NET Core MVC*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've clarified which parts of a system can benefit from the adoption
    of microservices, we are ready to state the rules when it comes to deciding how
    they're adopted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When is it worth considering microservice architectures?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microservices can improve the implementation of both the business and data
    layer, but their adoption has some costs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Allocating instances to nodes and scaling them has a cost in terms of cloud
    fees or internal infrastructures and licenses.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting a unique process into smaller communicating processes increases communication
    costs and hardware needs, especially if the microservices are containerized.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and testing software for a microservice requires more time and increases
    engineering costs, both in time and complexity. In particular, making microservices
    resilient and ensuring that they adequately handle all possible failures, as well
    as verifying these features with integration tests, can increase the development
    time by more than one order of magnitude.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, when are microservices worth the cost of using them? Are there functionalities
    that must be implemented as microservices?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'A rough answer to the second question is: yes, when the application is big
    enough in terms of traffic and/or software complexity. In fact, as an application
    grows in complexity and its traffic increases, it''s recommended that we pay the
    costs connected to scaling it since this allows for more scaling optimization
    and better handling when it comes to the development team. The costs we pay for
    these would soon exceed the cost of microservice adoption.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if fine-grained scaling makes sense for our application, and if we are
    able to estimate the savings that fine-grained scaling and development give us,
    we can easily compute an overall application throughput limit that makes the adoption
    of microservices convenient.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Microservice costs can also be justified by the increase in the market value
    of our products/services. Since the microservice architecture allows us to implement
    each microservice with a technology that has been optimized for its use, the quality
    that's added to our software may justify all or part of the microservice costs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: However, scaling and technology optimizations are not the only parameters to
    consider. Sometimes, we are forced to adopt a microservice architecture without
    being able to perform a detailed cost analysis.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: If the size of the team that takes care of the CI/CD of the overall system grows
    too much, the organization and coordination of this big team cause difficulties
    and inefficiencies. In this type of situation, it is desirable to move to an architecture
    that breaks the whole CI/CD cycle into independent parts that can be taken care
    of by smaller teams.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since these development costs are only justified by a high volume
    of requests, we probably have high traffic being processed by independent modules
    that have been developed by different teams. Therefore, scaling optimizations
    and the need to reduce interaction between development teams make the adoption
    of a microservice architecture very convenient.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: From this, we may conclude that, if the system and the development team grows
    too much, it is necessary to split the development team into smaller teams, each
    working on an efficient bounded context subsystem. It is very likely that, in
    a similar situation, a microservices architecture is the only possible option.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Another situation that forces the adoption of a microservice architecture is
    the integration of newer subparts with legacy subsystems based on different technologies
    since containerized microservices are the only way to implement an efficient interaction
    between the legacy system and the new subparts in order to gradually replace the
    legacy subparts with newer ones. Similarly, if our team is composed of developers
    with experience in different development stacks, an architecture based on containerized
    microservices may become a *must*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will analyze building blocks and tools that are available
    so that we can implement .NET-based microservices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: How does .NET deal with microservices?
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET was conceived as a multi-platform framework that was light and fast enough
    to implement efficient microservices. In particular, ASP.NET is the ideal tool
    for implementing text-REST and binary gRPC APIs to communicate with a microservice,
    since it can run efficiently with light web servers such as Kestrel and is itself
    light and modular.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The whole .NET framework evolved with microservices as a strategic deployment
    platform in mind and has facilities and packages for building efficient and light
    HTTP and gRPC communication to ensure service resiliency and to handle long-running
    tasks. The following subsections describe some of the different tools or solutions
    that we can use to implement a .NET-based microservice architecture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: .NET communication facilities
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices need two kinds of communication channels.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The first is a communication channel to receive external requests, either directly
    or through an API gateway. HTTP is the usual protocol for external communication
    due to available web service standards and tools. .NET's main HTTP/gRPC communication
    facility is ASP.NET since it's a lightweight HTTP/gRPC framework, which makes
    it ideal for implementing Web APIs in small microservices. We will describe ASP.NET
    apps in detail in *Chapter 14*, *Applying Service-Oriented Architectures with
    .NET Core*, which is dedicated to HTTP and gRPC services. .NET also offers an
    efficient and modular HTTP client solution that is able to pool and reuse heavy
    connection objects. Also, the `HttpClient` class will be described in more detail
    in *Chapter 14*, *Applying Service-Oriented Architectures with .NET Core*.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是用于接收外部请求的通信渠道，可以直接接收或通过API网关接收。由于可用的Web服务标准和工具，HTTP是外部通信的常用协议。.NET的主要HTTP/gRPC通信工具是ASP.NET，因为它是一个轻量级的HTTP/gRPC框架，非常适合在小型微服务中实现Web
    API。我们将在*第14章*的*使用.NET Core应用服务导向架构*中详细介绍ASP.NET应用程序，该章节专门介绍HTTP和gRPC服务。.NET还提供了一种高效且模块化的HTTP客户端解决方案，能够池化和重用重型连接对象。此外，`HttpClient`类将在*第14章*的*使用.NET
    Core应用服务导向架构*中详细介绍。
- en: The second is a different type of communication channel to push updates to other
    microservices. In fact, we have already mentioned that intra-microservice communication
    cannot be triggered by an on-going request since a complex tree of blocking calls
    to other microservices would increase request latency to an unacceptable level.
    As a consequence, updates must not be requested immediately before they're used
    and should be pushed whenever state changes take place. Ideally, this kind of
    communication should be asynchronous to achieve acceptable performance. In fact,
    synchronous calls would block the sender while they are waiting for the result,
    thus increasing the idle time of each microservice. However, synchronous communication
    that just puts the request in a processing queue and then returns confirmation
    of the successful communication instead of the final result is acceptable if communication
    is fast enough (low communication latency and high bandwidth). A publisher/subscriber
    communication would be preferable since, in this case, the sender and receiver
    don't need to know each other, thus increasing the microservices' independence.
    In fact, all the receivers that are interested in a certain type of communication
    merely need to register to receive a specific *event*, while senders just need
    to publish those events. All the wiring is performed by a service that takes care
    of queuing events and dispatching them to all the subscribers. The publisher/subscriber
    pattern will be described in more detail in *Chapter 11*, *Design Patterns and
    .NET 5 Implementation*, along with other useful patterns.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种是一种不同类型的通信渠道，用于向其他微服务推送更新。实际上，我们已经提到过，由于对其他微服务的阻塞调用形成了复杂的阻塞调用树，因此无法通过正在进行的请求触发微服务之间的通信，这将增加请求的延迟时间，达到不可接受的水平。因此，在使用更新之前不应立即请求更新，并且应在状态发生变化时推送更新。理想情况下，这种通信应该是异步的，以实现可接受的性能。实际上，同步调用会在等待结果时阻塞发送者，从而增加每个微服务的空闲时间。然而，如果通信足够快（低通信延迟和高带宽），那么只将请求放入处理队列然后返回成功通信的确认而不是最终结果的同步通信是可以接受的。发布者/订阅者通信将是首选，因为在这种情况下，发送者和接收者不需要彼此了解，从而增加了微服务的独立性。实际上，对某种类型的通信感兴趣的所有接收者只需要注册以接收特定的*事件*，而发送者只需要发布这些事件。所有的连接工作由一个负责排队事件并将其分发给所有订阅者的服务执行。发布者/订阅者模式将在*第11章*的*设计模式和.NET
    5实现*中详细描述，以及其他有用的模式。
- en: While .NET doesn't directly offer tools that may help in asynchronous communication
    or client/server tools that implement publisher/subscriber communication, Azure
    offers a similar service with *Azure Service Bus*. Azure Service Bus handles both
    queued asynchronous communication through Azure Service Bus *queues* and publisher/subscriber
    communication through Azure Service Bus *topics*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET没有直接提供可帮助实现异步通信或实现发布者/订阅者通信的客户端/服务器工具，但Azure提供了一个类似的服务，即*Azure Service
    Bus*。Azure Service Bus通过Azure Service Bus *队列*处理队列异步通信和通过Azure Service Bus *主题*处理发布者/订阅者通信。
- en: Once you've configured Azure Service Bus on the Azure portal, you can connect
    to it in order to send messages/events and to receive messages/events through
    a client contained in the `Microsoft.Azure.ServiceBus` NuGet package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在Azure门户上配置了Azure Service Bus，您就可以通过`Microsoft.Azure.ServiceBus` NuGet包中的客户端连接到它，以便发送消息/事件和接收消息/事件。
- en: 'Azure Service Bus has two types of communication: queue-based and topic-based.
    In queue-based communication, each message that''s placed in the queue by a sender
    is removed from the queue by the first receiver that pulls it from the queue.
    Topic-based communication, on the other hand, is an implementation of the publisher/subscriber
    pattern. Each topic has several subscriptions and a different copy of each message
    sent to a topic can be pulled from each topic subscription.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Bus有两种类型的通信：基于队列和基于主题。在基于队列的通信中，发送者放入队列的每个消息都会被第一个从队列中拉取的接收者从队列中删除。另一方面，基于主题的通信是发布者/订阅者模式的一种实现。每个主题都有多个订阅，可以从每个主题订阅中拉取发送到主题的每个消息的不同副本。
- en: 'The design flow is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设计流程如下：
- en: Define an Azure Service Bus private namespace.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义Azure Service Bus的私有命名空间。
- en: Get the root connection strings that were created by the Azure portal and/or
    define new connection strings with fewer privileges.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由Azure门户创建的根连接字符串和/或定义具有较少权限的新连接字符串。
- en: Define queues and/or topics where the sender will send their messages in binary
    format.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义队列和/或主题，发送者将以二进制格式发送其消息。
- en: For each topic, define names for all the required subscriptions.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个主题定义所需订阅的名称。
- en: In the case of queue-based communication, the sender sends messages to a queue
    and the receivers pull messages from the same queue. Each message is delivered
    to one receiver. That is, once a receiver gains access to the queue, it reads
    and removes one or more messages.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of topic-based communication, each sender sends messages to a topic,
    while each receiver pulls messages from the private subscription associated with
    that topic.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are also other commercial alternatives to Azure Service Bus, such as
    NServiceBus, MassTransit, Brighter, and ActiveMQ. There is also a free open source
    option: RabbitMQ. RabbitMQ can be installed locally, on a virtual machine, or
    in a Docker container. Then, you can connect with it through the client contained
    in the `RabbitMQ.Client` NuGet package.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The functionalities of RabbitMQ are similar to the ones offered by Azure Service
    Bus but you have to take care of all the implementation details, confirmations
    of performed operations, and so on, while Azure Service Bus takes care of all
    the low-level operations and offers you a simpler interface. Azure Service Bus
    and RabbitMQ will be described alongside publisher/subscriber-based communication
    in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: If microservices are published to Azure Service Fabric, which will be described
    in the next chapter (*Chapter 6*, *Azure Service Fabric*), we can use built-in
    reliable binary communication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Communication is resilient since communication primitives automatically use
    a retry policy. This communication is synchronous, but this is not a big limitation
    since microservices in Azure Service Fabric have built-in queues; thus, once the
    receiver has received a message, they can just put it in a queue and return it
    immediately, without blocking the sender.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The messages in the queue are then processed by a separate thread. The main
    limitation of this built-in communication is that it is not based on the publisher/subscriber
    pattern; the senders and receivers must know each other. When this is not acceptable,
    you should use Azure Service Bus. We will learn how to use Service Fabric's built-in
    communication in *Chapter 6*, *Azure Service Fabric*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Resilient task execution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resilient communication and, in general, resilient task execution can be implemented
    easily with the help of a .NET library called Polly, whose project is a member
    of the .NET Foundation. Polly is available through the Polly NuGet package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'In Polly, you define policies, and then execute tasks in the context of those
    policies, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part of each policy specifies the exceptions that must be handled.
    Then, you specify what to do when one of those exceptions is captured. In the
    preceding code, the `Execute` method is retried up to three times if a failure
    is reported either by an `HttpRequestException` exception or by an `OperationCanceledException`
    exception.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation of an exponential retry policy:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument of `WaitAndRetry` specifies that a maximum of six retries
    is performed in the event of failure. The lambda function passed as the second
    argument specifies how much time to wait before the next attempt. In this specific
    example, this time grows exponentially with the number of the attempt by a power
    of 2 (2 seconds for the first retry, 4 seconds for the second retry, and so on).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple circuit breaker policy:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After six failures, the task can't be executed for 1 minute since an exception
    is returned.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation of the Bulkhead Isolation policy (see the
    *Microservices design principles* section for more information):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A maximum of 10 parallel executions is allowed in the `Execute` method. Further
    tasks are inserted in an execution queue. This has a limit of 15 tasks. If the
    queue limit is exceeded, an exception is thrown.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: For the Bulkhead Isolation policy to work properly and, in general, for every
    strategy to work properly, task executions must be triggered through the same
    policy instance; otherwise, Polly is unable to count how many executions of a
    specific task are active.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Policies can be combined with the `Wrap` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Polly offers several more options, such as generic methods for tasks that return
    a specific type, timeout policies, task result caching, the ability to define
    custom policies, and so on. It is also possible to configure Polly as part of
    an `HttPClient` definition in the dependency injection section of any ASP.NET
    and .NET application. This way, it is quite immediate to define resilient clients.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The link to the official Polly documentation is in the *Further reading* section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Using generic hosts
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each microservice may need to run several independent threads, each performing
    a different operation on requests received. Such threads need several resources,
    such as database connections, communication channels, specialized modules that
    perform complex operations, and so on. Moreover, all processing threads must be
    adequately initialized when the microservice is started and gracefully stopped
    when the microservice is stopped as a consequence of either load balancing or
    errors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: All of these needs led the .NET team to conceive and implement *hosted services*
    and *hosts*. A host creates an adequate environment for running several tasks,
    known as **hosted services**, and provides them with resources, common settings,
    and graceful start/stop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a web host was mainly conceived to implement the ASP.NET Core
    web framework, but, with effect from .NET Core 2.1, the host concept was extended
    to all .NET applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, a `Host` is automatically created for you
    in any ASP.NET Core or Blazor project, so you have to add it manually only in
    other project types.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: All features related to the concept of a `Host` are contained in the `Microsoft.Extensions.Hosting`
    NuGet package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to configure the host with a fluent interface, starting with
    a `HostBuilder` instance. The final step of this configuration is calling the
    `Build` method, which assembles the actual host with all the configuration information
    we provided:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Host configuration includes defining the common resources, defining the default
    folder for files, loading the configuration parameters from several sources (JSON
    files, environment variables, and any arguments that are passed to the application),
    and declaring all the hosted services.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that ASP.NET Core and Blazor projects use methods that
    perform a pre-configuration of the `Host` that include several of the tasks listed
    previously.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the host can be started, which causes all the hosted services to be started:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program remains blocked on the preceding instruction until the host is shut
    down. The host can be shut down either by one of the hosted services or externally
    by calling `awaithost.StopAsync(timeout)`. Here, `timeout` is a time span defining
    the maximum time to wait for the hosted services to stop gracefully. After this
    time, all the hosted services are aborted if they haven't been terminated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Often, the fact that a microservice is being shut down is signaled by a `cancellationToken`
    being passed when the microservice is started by the orchestrator. This happens
    when microservices are hosted in Azure Service Fabric.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore in most cases, instead of using `host.Start()`, we can use the `RunAsync`
    or `Run` method, possibly passing it a `cancellationToken` that we received from
    the orchestrator or from the operating system:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This way of shutting down is triggered as soon as the `cancellationToken` enters
    a canceled state. By default, the host has a 5-second timeout for shutting down;
    that is, it waits 5 seconds before exiting once a shutdown has been requested.
    This time can be changed within the `ConfigureServices` method, which is used
    to declare *hosted services* and other resources:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, increasing the host timeout doesn't increase the orchestrator timeout,
    so if the host waits too long, the whole microservice is killed by the orchestrator.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If no cancellation token is explicitly passed to `Run` or `RunAsync`, a cancellation
    token is automatically generated and is automatically signaled when the operating
    system informs the application it is going to kill it. This cancellation token
    is passed to all hosted services to give them the opportunity to stop gracefully.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Hosted services are implementations of the `IHostedService` interface, whose
    only methods are `StartAsync(cancellationToken)` and `StopAsync(cancellationToken)`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Both methods are passed a `cancellationToken`. The `cancellationToken` in the
    `StartAsync` method signals that a shutdown was requested. The `StartAsync` method
    periodically checks this `cancellationToken` while performing all operations needed
    to start the host, and if it is signaled, the host start process is aborted. On
    the other hand, the `cancellationToken` in the `StopAsync` method signals that
    the shutdown timeout expired.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Hosted services can be declared in the same `ConfigureServices` method that''s
    used to define host options, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, some project templates, like the ASP.NET Core project template, define
    a `ConfigureServices` method in a different class. This works fine if this method
    receives the same `services` parameter that is available in the `HostBuilder.ConfigureServices`
    method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Most declarations inside `ConfigureServices` require the addition of the following
    namespace:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, the `IHostedService` interface isn't implemented directly but can be
    inherited from the `BackgroundService` abstract class, which exposes the easier-to-implement
    `ExecuteAsync(CancellationToken)` method, which is where we can place the whole
    logic of the service. A shutdown is signaled by passing `cancellationToken` as
    an argument, which is easier to handle. We will look at an implementation of `IHostedService`
    in the example at the end of *Chapter 6*, *Azure Service Fabric*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow a hosted service to shut down the host, we need to declare an `IApplicationLifetime`
    interface as its constructor parameter:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the hosted service is created, it is automatically passed an implementation
    of `IHostApplicationLifetime`, whose `StopApplication` method will trigger the
    host shutdown. This implementation is handled automatically, but we can also declare
    custom resources whose instances will be automatically passed to all the host
    service constructors that declare them as parameters. Therefore, say we define
    a constructor like this one:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are several ways to define the resources needed by the preceding constructor:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we use `AddTransient`, a different instance is created and passed to all
    the constructors that require an instance of that type. On the other hand, with
    `AddSingleton`, a unique instance is created and passed to all the constructors
    that require the declared type. The overload with two generic types allows you
    to pass an interface and a type that implements that interface. This way, a constructor
    requires the interface and is decoupled from the specific implementation of that
    interface.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If resource constructors contain parameters, they will be automatically instantiated
    with the types declared in `ConfigureServices` in a recursive fashion. This pattern
    of interaction with resources is called **dependency injection** (**DI**) and
    will be discussed in detail in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '`HostBuilder` also has a method we can use to define the default folder, that
    is, the folder used to resolve all relative paths mentioned in all .NET methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It also has methods that we can use to add logging targets:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous example shows a console-based logging source, but we can also log
    into Azure targets with adequate providers. The *Further reading* section contains
    links to some Azure logging providers that can work with microservices that have
    been deployed in Azure Service Fabric. Once you've configured logging, you can
    enable your hosted services and log custom messages by adding an `ILoggerFactory`
    or an `ILogger<T>` parameter in their constructors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `HostBuilder` has methods we can use to read configuration parameters
    from various sources:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The way parameters can be used from inside the application will be explained
    in more detail in *Chapter 15*, *Presenting ASP.NET Core MVC*, which is dedicated
    to ASP.NET.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio support for Docker
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio offers support for creating, debugging, and deploying Docker images.
    Docker deployment requires us to install *Docker Desktop for Windows* on our development
    machine so that we can run Docker images. The download link can be found in the
    *Technical requirements* section at the beginning of this chapter. Before we start
    any development activity, we must ensure it is installed and running (you should
    see a Docker icon in the window notification bar when the Docker runtime is running).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker support will be described with a simple ASP.NET MVC project. Let''s
    create one. To do so, follow these steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Name the project `MvcDockerTest`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For simplicity, disable authentication, if not already disabled.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are given the option to add Docker support when you create the project,
    but please don't check the Docker support checkbox. You can test how Docker support
    can be added to any project after it has been created.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have your ASP.NET MVC application scaffolded and running, right-click
    on its project icon in **Solution Explorer** and select **Add** and then **Container
    Orchestrator Support** | **Docker Compose**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: You'll get a dialog asking you to pick what operating system your container
    should use; pick the same one you chose when installing *Docker Desktop for Windows*.
    This will enable not only the creation of a Docker image but also the creation
    of a Docker Compose project, which helps you configure Docker Compose files so
    that they run and deploy several Docker images simultaneously. In fact, if you
    add another MVC project to the solution and enable container orchestrator support
    for it, the new Docker image will be added to the same Docker Compose file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of enabling Docker Compose instead of just `Docker` is that you
    can manually `configure` how the image is run on the development machine, as well
    as how Docker image ports are mapped to external ports by editing the Docker Compose
    files that are added to the solution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: If your Docker runtime has been installed properly and is running, you should
    be able to run the Docker image from Visual Studio.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Docker file
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s analyze the Docker file that was created by Visual Studio. It is a sequence
    of image creation steps. Each step enriches an existing image with something else
    with the help of the `From` instruction, which is a reference to an already existing
    image. The following is the first step:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first step uses the `mcr.microsoft.com/dotnet/aspnet:x.x` ASP.NET (Core)
    runtime that was published by Microsoft in the Docker public repository (where
    `x.x` is the ASP.NET (Core) version that was selected in your project).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WORKDIR` command creates the directory that follows the command within
    the image that is going to be created. If the directory doesn''t exist yet, it
    is created in the image. The two `EXPOSE` commands declare which ports of the
    image ports will be exposed outside the image and mapped to the actual hosting
    machine. Mapped ports are decided in the deployment stage either as command-line
    arguments of a Docker command or within a Docker Compose file. In our case, there
    are two ports: one for HTTP (80) and another for HTTPS (443).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: This intermediate image is cached by Docker, which doesn't need to recompute
    it since it doesn't depend on the code we write but only on the selected version
    of the ASP.NET (Core) runtime.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step produces a different image that will not be used to deploy.
    Instead, it will be used to create application-specific files that will be deployed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This step starts from the ASP.NET SDK image, which contains parts we don't need
    to add for deployment; these are needed to process the project code. The new `src`
    directory is created in the `build` image and makes the current image directory.
    Then, the project file is copied into `/src/MvcDockerTest`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN` command executes an operating system command on the image. In this
    case, it calls the `dotnet` runtime, asking it to restore the NuGet packages that
    were referenced by the previously copied project file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `COPY..` command copies the whole project file tree into the `src`
    image directory. Finally, the project directory is made the current directory
    and the `dotnet` runtime is asked to build the project in release mode and copy
    all the output files into the new `/app/build` directory. Finally, the `dotnet
    publish` task is executed in a new image called `publish`, outputting the published
    binaries into `/app/publish`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step starts from the image that we created in the first step, which
    contains the ASP.NET (Core) runtime, and adds all the files that were published
    in the previous step:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ENTRYPOINT` command specifies the operating system command that's needed
    to execute the image. It accepts an array of strings. In our case, it accepts
    the `dotnet` command and its first command-line argument, that is, the DLL we
    need to execute.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the project
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we right-click on our project and click **Publish**, we are presented with
    several options:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Publish the image to an existing or new web app (automatically created by Visual
    Studio)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish to one of several Docker registries, including a private Azure Container
    Registry that, if it doesn't already exist, can be created from within Visual
    Studio
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose support allows you to run and publish a multi-container application
    and add further images, such as a containerized database that is available everywhere.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Docker Compose file adds two ASP.NET applications to the same
    Docker image:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code references existing Docker files. Any environment-dependent
    information is placed in the `docker-compose.override.yml` file, which is merged
    with the `docker-compose.yml` file when the application is launched from Visual
    Studio:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For each image, the file defines some environment variables, which will be defined
    in the image when the application is launched, the port mappings, and some host
    files.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The files in the host are directly mapped into the images. Each declaration
    contains the path in the host, how the path is mapped in the image, and the desired
    access rights. In our case, `volumes` are used to map the self-signed HTTPS certificate
    that's used by Visual Studio.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we want to add a containerized SQL Server instance. We would need
    something like the following instructions split between `docker-compose.yml` and
    `docker-compose.override.yml`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the preceding code specifies the properties of the SQL Server container,
    as well as the SQL server''s configuration and installation parameters. More specifically,
    the preceding code contains the following information:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`sql.data` is the name that''s given to the container.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image` specifies where to take the image from. In our case, the image is contained
    in a public Docker registry.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment` specifies the environment variables that are needed by SQL Server,
    that is, the administrator password and the acceptance of a SQL Server license.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, `ports` specifies the port mappings.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose.override.yml` is used to run the images from within Visual
    Studio.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to specify parameters for either the production environment or
    the testing environment, you can add further `docker-compose-xxx.override.yml`
    files, such as `docker-compose-staging.override.yml` and `docker-compose-production.override.yml`,
    and then launch them manually in the target environment with something like the
    following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you can destroy all the containers with the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While `docker-compose` has a limited capability when it comes to handling node
    clusters, it is mainly used in testing and development environments. For production
    environments, more sophisticated tools are needed, as we will see later in this
    chapter (in the *Which tools are needed to manage microservices?* section).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Azure and Visual Studio support for microservice orchestration
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio has specific project templates for microservice applications based
    on the Service Fabric platform, where you can define various microservices, configure
    them, and deploy them to Azure Service Fabric, which is a microservice orchestrator.
    Azure Service Fabric will be described in more detail in *Chapter 6*, *Azure Service
    Fabric*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio also has specific project templates for defining microservices
    to be deployed in Azure Kubernetes, and has extensions for debugging a single
    microservice while it communicates with other microservices deployed in Azure
    Kubernetes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Also available are tools for testing and debugging several communicating microservices
    in the development machine with no need to install any Kubernetes software, and
    for deploying them automatically on Azure Kubernetes with just minimal configuration
    information.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: All Visual Studio tools for Azure Kubernetes will be described in *Chapter 7*,
    *Azure Kubernetes Service*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Which tools are needed to manage microservices?
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Effectively handling microservices in your CI/CD cycles requires both a private
    Docker image registry and a state-of-the-art microservice orchestrator that''s
    capable of doing the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Allocating and load-balancing microservices on available hardware nodes
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the health state of services and replacing faulty services if hardware/software
    failures occur
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and presenting analytics
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the designer to dynamically change requirements such as hardware nodes
    allocated to a cluster, the number of service instances, and so on
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following subsection describes the Azure facilities we can use to store
    Docker images. The microservices orchestrators available in Azure are each described
    in a dedicated chapter, namely, *Chapter 6*, *Azure Service Fabric*, and *Chapter
    7*, *Azure Kubernetes Service*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Defining your private Docker registry in Azure
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining your private Docker registry in Azure is easy. Just type `Container
    registries` into the Azure search bar and select **Container registries**. On
    the page that appears, click on the **Add** button.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The following form will appear:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_05_01.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Creating an Azure private Docker registry'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The name you select is used to compose the overall registry URI: `<name>.azurecr.io`.
    As usual, you can specify the subscription, resource group, and location. The
    **SKU** dropdown lets you choose from various levels of offerings that differ
    in terms of performance, available memory, and a few other auxiliary features.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you mention image names in Docker commands or in a Visual Studio publish
    form, you must prefix them with the registry URI: `<name>.azurecr.io/<my imagename>`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: If images are created with Visual Studio, then they can be published by following
    the instructions that appear once you've published the project. Otherwise, you
    must use `docker` commands to push them into your registry.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to use Docker commands that interact with the Azure registry
    is by installing the Azure CLI on your computer. Download the installer from [https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)
    and execute it. Once the Azure CLI has been installed, you can use the `az` command
    from Windows Command Prompt or PowerShell. In order to connect with your Azure
    account, you must execute the following login command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command should start your default browser and should drive you through
    the manual login procedure.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged into your Azure account, you can log in to your private registry
    by typing the following command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s say you have a Docker image in another registry. As a first step,
    let''s pull the image on your local computer:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If there are several versions of the preceding image, the latest will be pulled
    since no version was specified. The version of the image can be specified as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the following command, you should see `myimage` within the list of local
    images:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, tag the image with the path you want to assign in the Azure registry:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both the name and destination tag may have versions (`:<version name>`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, push it to your registry with the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, you can specify a version; otherwise, the latest version is pushed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, you can remove the image from your local computer using the
    following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described what microservices are and how they have evolved
    from the concept of a module. Then, we talked about the advantages of microservices
    and when it is worth using them, as well as general criteria for their design.
    We also explained what Docker containers are and analyzed the strong connection
    between containers and microservice architectures.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Then, we took on a more practical implementation by describing all the tools
    that are available in .NET so that we can implement microservice-based architectures.
    We also described infrastructures that are needed by microservices and how the
    Azure cluster offers Azure Kubernetes Service and Azure Service Fabric.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses the Azure Service Fabric orchestrator in detail.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the two-fold nature of the module concept?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is scaling optimization the only advantage of microservices? If not, list some
    further advantages.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Polly?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Docker support is offered by Visual Studio?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an orchestrator and what orchestrators are available on Azure?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is publisher/subscriber-based communication so important in microservices?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is RabbitMQ?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are idempotent messages so important?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are links to the official documentation for Azure Service Bus
    and RabbitMQ, two event bus technologies:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Service Bus**: [https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RabbitMQ**: [https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for Polly, a tool for reliable communication/tasks, can be
    found here: [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly).'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on Docker can be found on Docker''s official website: [https://docs.docker.com/](https://docs.docker.com/).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Kubernetes and `.yaml` files can be found here:
    [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Kubernetes can be found here: [https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/](https://docs.microsoft.com/en-US/azure/service-fabric/).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Service Fabric''s reliable services can
    be found here: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
