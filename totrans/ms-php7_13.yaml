- en: Resolving Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a loosely coupled code has become an essential skill for any professional
    developer. While legacy applications had a tendency to pack it all up, thus ending
    in one big solid block of code, modern applications take a more gradient approach
    as they largely rely on third-party libraries and other components. Nowadays,
    hardly anyone builds their own mailer, logger, router, template engine, and so
    on. Great deal of these components are out there, waiting to be consumed by our
    application through Composer. As individual components themselves are tested and
    maintained by various community or commercial entities, the cost of maintaining our
    application is significantly reduced. The overall code quality itself improves
    as an indirect consequence of more specialized developers addressing specific
    functionalities that otherwise might fall out of the area of our expertise. Harmony
    that has been made possible via loosely coupled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a multitude of positive side-effects of loosely coupled code, some
    of which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved code maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier cross-platform utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier cross-framework utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspiration towards a single responsibility principle compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This magic of loose coupling is easily achieved by utilizing various language
    features, such as interfaces, and design patterns, such as dependency injection. Moving
    forward, we will take a look at the basic aspects of dependency injection through
    the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating the common problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dependency injection container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigating the common problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependency injection is a well-established software technique that deals
    with the problem of object dependencies, allowing us to write loosely coupled
    classes. While the pattern itself has been around for quite some time, the PHP
    ecosystem hasn''t really picked it up until major frameworks such as Symfony started
    implementing it. Nowadays, it is a de facto standard for anything other than trivial
    types of application. The whole dependency problem is easily observed through
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a simple `Customer` class with a single `loadByEmail()` method.
    The troubling part is the dependency on the database `$mysqli` object being locked
    in a `loadByEmail()` instance method. This makes for tight coupling, which reduces
    code reusability and opens the door for possible system-wide side-effects to be
    induced by later code changes. To mitigate the problem, we need to inject the database
    `$mysqli` object into `$customer`.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Sakila database can be obtained from [https://dev.mysql.com/doc/sakila/en/](https://dev.mysql.com/doc/sakila/en/).
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to inject the dependency into an object*:*
  prefs: []
  type: TYPE_NORMAL
- en: Through an instance method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through a class constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through instance property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whereas the instance method and class constructor approach seem slightly more
    popular than instance property injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the approach of using an instance method
    for dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are injecting an instance of the `$mysqli` object into an instance
    of the `Customer` object through the customer's `loadByEmail()` instance method.
    While this is certainly a better way than instantiating the `$mysqli` object within
    the `loadByEmail()` method itself, it is easy to imagine how quickly our client
    code might become clumsy if our class were to have a dozen of methods, each requiring
    different objects to be passed to it. While this approach might seem tempting,
    injecting dependencies through instance methods violates OOP's principle of encapsulation.
    Furthermore, adding arguments to methods for the sake of dependency is anything but
    an example of best practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach would be to utilize the class constructor method as per the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are injecting an instance of the `$mysqli` object into an instance
    of the `Customer` object through the customer's `__constructor()` method. Whether
    a single or a dozen objects are being injected, the constructor injection comes
    out as the clear winner here. The client application has a single entry point
    for all injections, making it easy to keep a track of things.
  prefs: []
  type: TYPE_NORMAL
- en: Without the notion of dependency injection, a loosely coupled code would be
    impossible to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the introductory section, we touched upon passing dependency through
    the class `__construct()` method. There is more to it than just passing the dependent
    object. Let's consider the following three seemingly similar but different examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though PHP has been supporting type hinting for quite a while now, it isn''t
    uncommon to come across pieces of code, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `App` class `__construct()` method does not utilize the
    PHP type hinting feature. The `$config` and `$logger` variables are assumed by
    the developer to be of a certain type. While this example will work just fine,
    it still keeps our classes tightly coupled. There really is not that much difference
    between this example and the previous one where we had the `$msqli` dependency
    within the `loadByEmail()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding type hinting to the mix allows us to force the types we pass into the `App`
    class `__construct()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This simple move sets us halfway through making our code loosely coupled. Although
    we are now instructing our injectable objects to be of an exact type, we are still
    locked onto a specific type, that is, implementation. Striving for loose coupling
    should not get us locked into a specific implementation; otherwise, there would
    not be much use of a dependency injection pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This third example sets an important differentiation in regards to the first
    two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Favoring interface type hints instead of concrete class type hints is among
    the key ingredients to write loosely coupled code. Although we are still injecting
    dependencies through the class `__construct()`, we are now doing so in a *program
    to an interface, not an implementation* manner. This allows us to avoid tight
    coupling, making our code more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, these examples are ultimately simple. We can imagine how quickly things
    start to complicate when the number of injected objects increase, where each of
    the injected objects might need one, two, or even a dozen of the `__construct()`
    parameters itself. This is where the dependency injection container comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency injection container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dependency injection container is an object that knows how to auto-wire classes
    together. The **auto-wire** term implies both instantiating and properly configuring
    objects. This is by no means an easy task, which is why there are several libraries
    addressing this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The DependencyInjection component provided by the Symfony framework is a neat dependency
    injection container that can be easily installed by Composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, let''s go ahead and create a `di-container` directory where
    we will execute these commands and set up our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output suggests we should install some additional packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/500c7447-11c1-4eb4-b1dd-54811758adb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to make sure we add the `symfony/yaml` and `symfony/config` packages
    by running the following console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `symfony/yaml` package installs the Symfony Yaml component. This component parses
    the YAML strings into PHP arrays and the other way around. The `symfony/config` package
    installs the Symfony Config component. This component provides classes to help
    us find, load, combine, autofill, and validate configuration values from sources,
    such as YAML, XML, INI files, or even a database itself. The `symfony/dependency-injection`,
    `symfony/yaml`, and `symfony/config` packages themselves stand as a nice example
    of loosely coupled components. While the three work hand in hand to deliver the
    full scope of dependency injection functionality, components themselves follow
    the principles of loose coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [http://symfony.com/doc/current/components/dependency_injection.html](http://symfony.com/doc/current/components/dependency_injection.html)
    for more information about the Symfony's DependencyInjection component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go ahead and create the `container.yml` configuration file within
    the `di-container` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `container.yml` file has a specific structure that begins with the keyword
    `services`. Without delving any deeper into it, suffice it to say that the service
    container is the Symfony's name for dependency injection container, while the
    service is any PHP object performing some task--basically, an instance of a class
    of any sort.
  prefs: []
  type: TYPE_NORMAL
- en: Right below the `services` tag, we have the `config`, `logger`, and `app` tags.
    These denote a declaration of three distinctive services. We could have easily
    named them `the_config`, `the_logger`, `the_app`, or whatever else we prefer.
    Drilling deeper into individual services, we see the `class` tag being common
    to all three services. The `class` tag tells the container what class to instantiate
    when a given service instance is asked for. Finally, the `autowire` feature used
    within the `app` service definition allows the autowiring subsystem to detect
    the dependencies of the `App` class by parsing its constructor. This makes it
    dead simple for a client code to get an instance of the `App` class without even
    being aware of the `$config` and `$logger` requirements on the `App` class `__construct()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `container.yml` file in place, let''s go ahead and create the `index.php`
    file within the `di-container` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to replace everything from `ConfigInterface` to `App` with the exact
    code we had in our third example from within the Understanding dependency injection
    section.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by including the `autoload.php` file so we get the auto-loading
    for our dependency container component working. The code following the `use` statements
    is the same code we had in the Understanding dependency injection section. The
    interesting part comes after it. The instance of `ContainerBuilder` is created
    and passed onto `YamlFileLoader`, which loads the `container.yml` file. Right
    after the file is loaded, we call the `compile()` method on the `$container` instance.
    Running `compile()` allows the container to pick up on the `autowire` service
    tag, among other things. Finally, we are using the `get()` method on the `$container`
    instance to fetch an instance of the `app` service. The client, in this case,
    has no upfront knowledge of arguments being passed to the `App` instance; the
    dependency container handled it all by itself based on a `container.yml` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Using interface type hints and the container, we are able to write more reusable,
    testable, and decoupled code.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [http://symfony.com/doc/current/service_container.html](http://symfony.com/doc/current/service_container.html)
    for more information about the Symfony service container.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dependency injection is a simple technique that allows us to escape from
    the shackles of tight coupling. Combined with interface type hints, we get a powerful technique
    to write loosely coupled code. This isolates and minimizes the impact of possible
    future application design changes as well as its defects. Nowadays, it is considered
    irresponsible to even write modular and large code base applications without embracing
    these simple techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will take a closer look at the state of the ecosystem around
    PHP packages, their creation, and distribution.
  prefs: []
  type: TYPE_NORMAL
