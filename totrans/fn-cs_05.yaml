- en: Chapter 5. Querying Any Collection Easily with LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After having a discussion on delegates, lambda expressions, and extension methods,
    we are now ready to continue our discussion about LINQ. In this chapter, we will
    delve into LINQ, which is essential in composing functional code. Here, we will
    discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LINQ Queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding deferred execution in LINQ
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing LINQ fluent syntax and LINQ query expression syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating LINQ operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with LINQ
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Language Integrated Query** ( **LINQ** ), which was introduced in C# 3.0,
    is a language feature of .NET Framework that enables us to query data in collections
    easily implementing the `IEnumerable<T>` interface, such as `ArrayList<T>` , `List<T>`
    , an XML document, and a database. It becomes easier to query any data in a collection
    since, using LINQ, we do not need to learn a different syntax for a different
    source of data. For instance, we don''t need to learn SQL if we use LINQ when
    the data source is a database. Also, using LINQ, we don''t have to learn XQuery
    when we deal with an XML document. Fortunately, LINQ has eased our use of a common
    syntax for all the sources of data.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic data units in LINQ; they are sequences, which include any
    object that implements `IEnumerable<T>` , and elements, which include the items
    in the sequence. Suppose we have the following `int` array named `intArray` :'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding collection, we can say that `intArray` is a sequence, and
    the contents of the array, which include the numbers from 0 to 49, are the elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence can be transformed using a method called a query operator. The query
    operator accepts an input sequence and then produce the transformed sequence.
    The query will transform the sequence when it is enumerated. The query consists
    of at least an input sequence and an operator. Let''s take a look at the following
    code, which we can find in the `SequencesAndElements.csproj` project, which will
    look for the prime number from our preceding collection, `intArray` :'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `IsPrime()` extension method will have the following implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From our preceding code, we can see that we use the `Where` operator, which
    can be found in the `System.Linq.Enumerable` class, to transform the `intArray`
    sequence into the `extractedData` sequence, as shown in the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `extractedData` collection will now contain the prime numbers obtained
    from the `intArray` collection. If we run the project, we will get the following
    output on the console:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with LINQ](img/Image00049.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'We can actually modify our preceding code snippet in a simpler way since all
    query operators are extension methods and can be used directly in the collection.
    The modification of the preceding code snippet is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By modifying the invocation of the `Where` operator, we will get the complete
    implementation, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we run the preceding `ExtractArrayWithMethodSyntax()` method, we will get
    the exact same output with the `ExtractArray()` method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Deferring LINQ execution
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LINQ implements a deferred execution concept when we query the data from a
    collection. This means that the query will not be executed in the constructor
    time but in the enumeration process instead. For example, we use the `Where` operator
    to query data from a collection. Actually, the query is not executed until we
    enumerate it. We can use the `foreach` operation to call the `MoveNext` command
    in order to enumerate the query. To discuss deferred execution in further detail,
    let''s take a look at the following code, which we can find in the `DeferredExecution.csproj`
    project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the implementation of the preceding `DeferredExecution()`
    method, we construct a `List<Member>` member list named `memberList` , which contains
    four instances of every member who has joined to the club. The `Member` class
    itself is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After constructing `memberList` , we query the data from `memberList` , which
    includes the all members who joined after 2014\. Here, we can confirm that only
    three of four members satisfy the requirements. They are Eddie Morgan, Millie
    Duncan, and Emilia Shaw in ascending order, of course, since we use the `orderby
    m.Name` phrase in the query.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have the query, we add a new member to `memberList` and then run the
    `foreach` operation in order to enumerate the query. What will happen next is
    that, because most of the query operators implement deferred execution, which
    will be executed only in the enumeration process, we will have four members after
    enumerating the query since the last member we add to `memberList` satisfies the
    query requirement. To make this clear, let''s take a look at the following output
    we get on the console after invoking the `DeferredExecution()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Deferring LINQ execution](img/Image00050.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: As you can see, `Chloe Day` , who is the last member to have joined the club,
    is included in the query result as well. This is where the deferred execution
    plays its role.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all query operators provide deferred execution but not the operators
    that:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Return a scalar value or a single element, such as `Count` and `First` .
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the result of a query, such as `ToList` , `ToArray` , `ToDictionary`
    , and `ToLookup` . They are also called conversion operators.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Count()` and `First()` method will be executed immediately since they
    return a single object, so it''s almost impossible to provide deferred execution
    as well as conversion operators. Using the conversion operator, we can obtain
    a cached copy of the query results and can avoid repeating the process due to
    the reevaluate operation in deferred execution. Now, let''s take a look at the
    following code, which we can find in the `NonDeferredExecution.csproj` project,
    to demonstrate the nondeferred execution process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, in the preceding code, we have a `List<int>` integer list named `intList`
    , which contains numbers from `0` to `9` . We then create a query named `queryInt`
    in order to select all members of `intList` and multiply them by `2` . We also
    count the total of the query data using the `Count()` method. Since `queryInt`
    is not executed yet, we create a new query named `queryIntCached` , which converts
    `queryInt` to `List<int>` using the `ToList()` conversion operator. We also count
    the total of the data in that query. We have two queries now, `queryInt` and `queryIntCached`
    . We then clear `intList` and enumerate the two queries. The following is the
    result of them being displayed on the console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Deferring LINQ execution](img/Image00051.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding console, the enumeration of `queryInt` results
    in no item. This is clear since we have removed all `intList` items, so `queryInt`
    will find no item in `intList` . However, `queryInt` is counted as ten items since
    we have run the `Count()` method before we clear `intList` , and the method is
    immediately executed right after we construct it. In contrast to `queryInt` ,
    we have ten items' data when we enumerate `queryIntCached` . This is because we
    have invoked the `ToList()` conversion operator and it is immediately executed
    as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more type of deferred execution. It happens when we chain the `OrderBy`
    method after a `Select` method, for instance. The `Select` method will only retrieve
    one element at the time that it has to produce an element, while the `OrderBy`
    method has to consume the entire input sequence before it returns the first element.
    So, when we chain an `OrderBy` method after the `Select` method, the execution
    will be deferred until we retrieve the first element, and then the `OrderBy` method
    will ask `Select` for all the elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between fluent syntax and query expression syntax
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our preceding discussion, we found two types of querying syntaxes so far.
    Let's discuss this further by distinguishing these two syntaxes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code snippet is the fluent syntax type. We invoke the `Select`
    and `Count` operators by invoking their extension method in the `Enumerable` class.
    Using the fluent syntax, we can also chain the method so it will approach functional
    programming as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是流畅语法类型。我们通过调用 `Enumerable` 类中的扩展方法来调用 `Select` 和 `Count` 运算符。使用流畅语法，我们还可以链接方法，使其接近函数式编程，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another syntax type we can use in querying data in LINQ is query expression
    syntax. We applied this syntax type when we discussed deferred execution in the
    previous topic. The code snippet of the query expression syntax is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 LINQ 中查询数据时可以使用的另一种语法类型是查询表达式语法。我们在上一个主题中讨论延迟执行时应用了这种语法类型。查询表达式语法的代码片段如下：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In fact, the fluent syntax and the query expression syntax will do the same
    thing. The difference between them is only the syntax. Each keyword in the query
    expression syntax has its own extension method in the `Enumerable` class. To prove
    this, we can refactor the preceding code snippet to the following fluent syntax
    type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，流畅语法和查询表达式语法将执行相同的操作。它们之间的区别只是语法。查询表达式语法中的每个关键字在 `Enumerable` 类中都有其自己的扩展方法。为了证明这一点，我们可以将前面的代码片段重构为以下流畅语法类型：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Indeed, we will get the exact same output for these two types of syntaxes. However,
    the fluent syntax is closer to the functional approach than the query expression
    syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两种类型的语法将得到完全相同的输出。然而，流畅语法比查询表达式语法更接近函数式方法。
- en: Understanding the LINQ fluent syntax
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 LINQ 流畅语法
- en: 'Basically, the LINQ fluent syntax is the extension methods found in the `Enumerable`
    class. The method will extend any variable implementing the `IEnumerable<T>` interface.
    The fluent syntax takes a lambda expression as the parameter to represent the
    logic that will be performed in the sequence enumeration. As we discussed earlier,
    the fluent syntax implemented the method chain so that it can be used in the functional
    approach. In the beginning of this chapter, we had also discussed the extension
    method from which the query operator can be invoked directly using the static
    method from its class, which is the `Enumerable` class. However, by invoking the
    method directly from its class, we cannot implement the method chain we usually
    use in the functional approach. Let''s take at the following code, which we can
    find in the `FluentSyntax.csproj` project, to demonstrate the advantages of the
    fluent syntax by invoking the extension method instead of the conventional `static`
    method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，LINQ 流畅语法是在 `Enumerable` 类中找到的扩展方法。该方法将扩展任何实现 `IEnumerable<T>` 接口的变量。流畅语法采用
    lambda 表达式作为参数，表示将在序列枚举中执行的逻辑。正如我们之前讨论过的，流畅语法实现了方法链，以便在函数式方法中使用。在本章的开头，我们还讨论了扩展方法，可以直接使用其类的静态方法来调用查询运算符，即
    `Enumerable` 类。然而，通过直接从其类调用方法，我们无法实现通常在函数式方法中使用的方法链。让我们看一下以下代码，我们可以在 `FluentSyntax.csproj`
    项目中找到，以演示通过调用扩展方法而不是传统的 `static` 方法来使用流畅语法的优势：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The names collection we used in the preceding code is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中使用的名称集合如下：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we use three query operators when we query the data from a
    collection in the preceding code. They are the `Where` , `OrderBy` , and `Select`
    operators. Let''s take a look at the following code snippet to make this clear:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当我们在前面的代码中从集合中查询数据时，我们使用了三个查询运算符。它们是 `Where`、`OrderBy` 和 `Select` 运算符。让我们看一下以下代码片段，以澄清这一点：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Based on the preceding query, we will get the string collection in which each
    string contains more than four characters. The collection will be sorted in an
    ascending order by its first letter, and the string will be in uppercase characters.
    Here''s what we get on the console if we run the `UsingExtensionMethod()` method
    as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的查询，我们将得到一个字符串集合，其中每个字符串包含超过四个字符。该集合将按其第一个字母的升序排列，并且字符串将以大写字符显示。如果我们运行以下截图中显示的
    `UsingExtensionMethod()` 方法，我们将在控制台上看到以下内容：
- en: '![Understanding the LINQ fluent syntax](img/Image00052.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![理解 LINQ 流畅语法](img/Image00052.jpg)'
- en: 'Now, let''s refactor the preceding query to use the conventional static method.
    But before we go through it, here are the signatures of the three methods we have
    used in the preceding query:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构前面的查询，使用传统的静态方法。但在我们进行之前，这里是我们在前面的查询中使用的三个方法的签名：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, all three methods take `IEnumerable<TSource>` as the first parameter
    and also return `IEnumerable<TResult>` . We can use this similarity so that the
    return from the first method can be fed to the argument of the second method,
    the return from the second method can be fed to the argument of the third method,
    and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有三个方法都以 `IEnumerable<TSource>` 作为第一个参数，并且还返回 `IEnumerable<TResult>`。我们可以利用这种相似性，使第一个方法的返回值可以作为第二个方法的参数，第二个方法的返回值可以作为第三个方法的参数，依此类推。
- en: In the `Where()` method, we use the second parameter, predicate, to filter the
    sequence based on it. It's a `Func<TSource, bool>` delegate, so we can use a lambda
    expression here. The `Func<TSource, TKey>` delegate can also be found in the second
    parameter of the `OrderBy()` method, which is used as the key to sort the element
    of the sequence in an ascending order. It can be fed by anonymous method. The
    last is the `Select()` method, in which we use its second parameter, `selector`
    , to project each element in the sequence in the new form. The anonymous method
    can also be used as the argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Where()` 方法中，我们使用第二个参数 predicate 来基于它过滤序列。它是一个 `Func<TSource, bool>` 委托，所以我们可以在这里使用
    lambda 表达式。在 `OrderBy()` 方法的第二个参数中也可以找到 `Func<TSource, TKey>` 委托，它用作对序列元素进行升序排序的键。它可以由匿名方法提供。最后是
    `Select()` 方法，在其中我们使用它的第二个参数 `selector`，将序列中的每个元素投影为新形式。匿名方法也可以作为参数使用。
- en: 'Based on the signature of the methods we used in the previous `UsingExtensionMethod()`
    method, we can refactor the query as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在之前的 `UsingExtensionMethod()` 方法中使用的方法的签名，我们可以重构查询如下：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the complete `UsingStaticMethod()` method, which is the refactoring
    code when we use a conventional static method instead of the extension method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的 `UsingStaticMethod()` 方法，这是当我们使用传统的静态方法而不是扩展方法时的重构代码：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By running the `UsingStaticMethod()` method, we will get the exact output on
    the console compared to the `UsingExtensionMethod()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `UsingStaticMethod()` 方法，我们将在控制台上获得与 `UsingExtensionMethod()` 方法相比完全相同的输出。
- en: Understanding the LINQ query expression syntax
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 LINQ 查询表达式语法
- en: A LINQ query expression syntax is a shorthand syntax that we can use to perform
    LINQ queries. In a query expression syntax, .NET framework provides the keywords
    for each query operator but not all operators. By using the query syntax, we can
    invoke the operator like we query the data using SQL in the database. Our code
    will be more readable and will require less coding when we use the query expression
    syntax.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 查询表达式语法是一种简写语法，我们可以使用它执行 LINQ 查询。在查询表达式语法中，.NET Framework 为每个查询操作符提供关键字，但并非所有操作符。通过使用查询语法，我们可以像在数据库中使用
    SQL 查询数据一样调用操作符。当我们使用查询表达式语法时，我们的代码将更易读，并且在编写时需要更少的代码。
- en: 'In the fluent syntax discussion, we created a query to extract the string from
    the string list that contains more than four characters, sorted in an ascending
    order by its first letter and converted to uppercase characters. We can do this
    using the query expression syntax, as shown in the following code, which we can
    find in the `QueryExpressionSyntax.csproj` project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在流畅语法讨论中，我们创建了一个查询，从包含超过四个字符的字符串列表中提取字符串，按其第一个字母的升序排序，并转换为大写字符。我们可以使用查询表达式语法来执行此操作，如下面的代码所示，我们可以在
    `QueryExpressionSyntax.csproj` 项目中找到：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we have refactored the previous code, which uses the fluent
    syntax for the query expression syntax. Indeed, if we run the `InvokingQueryExpression()`
    method, the exact same output will be displayed will be displayed compared to
    the `UsingExtensionMethod()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经重构了之前的代码，它使用了查询表达式语法的流畅语法。事实上，如果我们运行 `InvokingQueryExpression()`
    方法，与 `UsingExtensionMethod()` 方法相比，将显示完全相同的输出。
- en: 'Unfortunately, there are several LINQ operators that have no keyword in the
    query expression syntax, such as the `distinct` operator since it doesn''t take
    a lambda expression. In this case, we have to use the fluent syntax, at least
    in part if we still want to use it. The following are the operators that have
    a keyword in the query expression syntax:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有几个 LINQ 操作符在查询表达式语法中没有关键字，例如 `distinct` 操作符，因为它不接受 lambda 表达式。在这种情况下，如果我们仍然想使用它，我们必须至少部分使用流畅语法。以下是在查询表达式语法中具有关键字的操作符：
- en: '`Where`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where`'
- en: '`Select`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select`'
- en: '`SelectMany`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectMany`'
- en: '`OrderBy`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderBy`'
- en: '`ThenBy`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThenBy`'
- en: '`OrderByDescending`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderByDescending`'
- en: '`ThenByDescending`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThenByDescending`'
- en: '`GroupBy`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupBy`'
- en: '`Join`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Join`'
- en: '`GroupJoin`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupJoin`'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Actually, the compiler converts the query expression syntax into fluent syntax
    in the compiling process. Although the query expression syntax is sometimes easier
    to read, we cannot perform all the operations using it; instead, we have to use
    the fluent syntax, for instance, `count` operators as we discussed in *Deferring
    LINQ execution* topic. What we write in the query expression syntax can also be
    written in the fluent syntax. Therefore, the fluent syntax is the best approach
    when we code using LINQ, especially in the functional approach.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编译器在编译过程中将查询表达式语法转换为流畅语法。虽然查询表达式语法有时更容易阅读，但我们不能使用它执行所有操作；相反，我们必须使用流畅语法，例如我们在
    *延迟 LINQ 执行* 主题中讨论的 `count` 操作符。我们在查询表达式语法中编写的内容也可以用流畅语法编写。因此，在使用 LINQ 编码时，特别是在功能方法中，流畅语法是最佳方法。
- en: Enumerating standard query operators
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举标准查询操作符
- en: There are more than 50 query operators in the `Enumerable` class included in
    the `System.Linq` namespace. They are also known as standard query operators.
    Based on the function of the operators, we can divide them into several operations.
    Here, we are going to discuss all the query operators in LINQ provided by .NET
    Framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `System.Linq` 命名空间中包含的 `Enumerable` 类中有 50 多个查询操作符。它们也被称为标准查询操作符。根据操作符的功能，我们可以将它们分为几个操作。在这里，我们将讨论
    .NET Framework 提供的所有 LINQ 查询操作符。
- en: Filtering
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: Filtering is an operation that will evaluate the element of data so that only
    the element satisfying the condition will be selected. There are six filtering
    operators; they are `Where` , `Take` , `Skip` , `TakeWhile` , `SkipWhile` , and
    `Distinct` . As we know, we have already discussed the `Where` operator in our
    previous sample code, both in the fluent syntax and the query expression syntax,
    and have an idea that it will return a subset of elements satisfying a condition
    given by a predicate. Since we are clear enough about the `Where` operator, we
    can skip it and continue with the remaining five filtering operators.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是一个操作，它将评估数据的元素，以便只选择满足条件的元素。有六个过滤操作符；它们是 `Where` 、`Take` 、`Skip` 、`TakeWhile`
    、`SkipWhile` 和 `Distinct` 。正如我们所知，我们已经在之前的示例代码中讨论了 `Where` 操作符，无论是在流畅语法还是查询表达式语法中，并且知道它将返回满足谓词给定条件的元素子集。由于我们对
    `Where` 操作符已经足够清楚，我们可以跳过它，继续使用剩下的五个过滤操作符。
- en: 'The `Take` operator returns the first `n` elements and dumps the rest. In contrast,
    the `Skip` operator ignores the first `n` elements and returns the rest. Let''s
    take a look at the following code from the `FilteringOperation.csproj` project:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Take` 操作符返回前 `n` 个元素并丢弃其余的元素。相反，`Skip` 操作符忽略前 `n` 个元素并返回其余的元素。让我们来看一下 `FilteringOperation.csproj`
    项目中的以下代码：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have two queries in the preceding code, `queryTake` , which applies the
    `Take` operator, and `querySkip` , which applies the `Skip` operator. They both
    consume `intList` , which is actually a list of integers containing the following
    data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有两个查询，`queryTake`应用了`Take`操作符，`querySkip`应用了`Skip`操作符。它们都消耗`intList`，实际上是一个包含以下数据的整数列表：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the preceding `SimplyTakeAndSkipOperator()` method, we will get the
    following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`SimplyTakeAndSkipOperator()`方法，将会得到以下输出：
- en: '![Filtering](img/Image00053.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00053.jpg)'
- en: 'The preceding `Take` and `Skip` operator sample is simple code, since it deals
    with a collection containing only twenty elements. In fact, the `Take` and `Skip`
    operators are useful when we work with a huge collection, or maybe a database,
    to ease user access to the data. Suppose we have a million elements of the integer
    collection and we are looking for the element that is multiplied by two and seven.
    Without using the `Take` and `Skip` operators, we will have a ton of results,
    and if we show them on the console, they will clutter the console display. Let''s
    take a look at the following code to prove this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Take`和`Skip`操作符示例是简单的代码，因为它处理的是一个只包含二十个元素的集合。事实上，当我们处理大量集合或者数据库时，`Take`和`Skip`操作符非常有用，可以方便用户访问数据。假设我们有一个包含一百万个整数的集合，我们要找到其中一个元素，它乘以二和七。如果不使用`Take`和`Skip`操作符，将会得到大量结果，如果在控制台上显示，会使控制台显示混乱。让我们看一下下面的代码来证明这一点：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see here, we have `hugeQuery` containing huge data. If we run the
    method, it needs about ten seconds to complete the iteration of all elements.
    We can also add the `Count` operator if we want to retrieve the actual elements
    `hugeQuery` contains, which is *71428* elements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里所看到的，我们有一个包含大量数据的`hugeQuery`。如果我们运行该方法，需要大约十秒钟来完成所有元素的迭代。如果我们想要获取`hugeQuery`实际包含的元素，我们也可以添加`Count`操作符，即*71428*个元素。
- en: 'Now, we can modify the code by adding the `Take` and `Skip` operators around
    the `foreach` loop, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`foreach`循环周围添加`Take`和`Skip`操作符来修改代码，如下所示：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding `TakeAndSkipOperator()` method, we add a couple of line of
    code in the highlighted lines. Now, although we have a lot of data, the output
    will be displayed conveniently when we run the method, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`TakeAndSkipOperator()`方法中，我们在高亮显示的行中添加了一些代码。现在，尽管我们有很多数据，但当我们运行该方法时，输出将会很方便地显示如下：
- en: '![Filtering](img/Image00054.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00054.jpg)'
- en: As you can see, the entire result is not presented on the console, only ten
    integers each time. Users can press **Enter** key if they want to continue to
    read the rest of data. This is what we usually call pagination. The `Take` and
    `Skip` operators have done a good job to achieve it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，整个结果并没有全部显示在控制台上，每次只显示十个整数。用户可以按**Enter**键，如果他们想要继续阅读其余的数据。这通常被称为分页。`Take`和`Skip`操作符已经很好地实现了这一点。
- en: 'Besides discussing `Take` and `Skip` operators, we are going to discuss `TakeWhile`
    and `SkipWhile` operators in filtering operators. In `TakeWhile` operator, the
    input collection will be enumerated and each element will be sent to the query
    until the predicate is `false` . In contrast, the input collection will be enumerated,
    and when the predicate is `true` , the element will be sent to the query. Now,
    let''s take a look at the following code to demonstrate the `TakeWhile` and `SkipWhile`
    operators:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了讨论`Take`和`Skip`操作符，我们还将讨论过滤操作符中的`TakeWhile`和`SkipWhile`操作符。在`TakeWhile`操作符中，输入集合将被枚举，每个元素将被发送到查询，直到谓词为`false`。相反，在`SkipWhile`中，当输入集合被枚举时，当谓词为`true`时，元素将被发送到查询。现在，让我们看一下下面的代码来演示`TakeWhile`和`SkipWhile`操作符：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run the preceding method, we will get the following output on the console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的方法时，将在控制台上得到以下输出：
- en: '![Filtering](img/Image00055.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00055.jpg)'
- en: Since we have `n < 50` in the predicate, in `TakeWhile` , the enumeration will
    emit the elements until it reaches `53` , and in `SkipWhile` , the element start
    to be emitted when the enumeration reaches `53` .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在谓词中有`n < 50`，在`TakeWhile`中，枚举将会发出元素，直到达到`53`，而在`SkipWhile`中，当枚举到达`53`时，元素开始被发出。
- en: 'We also have the `Distinct` operator in this filtering operation. The `Distinct`
    operator will return the input sequence without any duplicate elements. Suppose
    we have the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过滤操作中，我们还有`Distinct`操作符。`Distinct`操作符将返回没有任何重复元素的输入序列。假设我们有以下代码：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, we have a string and we intend to remove all duplicate
    letters in that string. We use the `Distinct` operator to get the query and then
    enumerate it. The result will be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有一个字符串，我们打算删除该字符串中的所有重复字母。我们使用`Distinct`操作符来获取查询，然后枚举它。结果将如下所示：
- en: '![Filtering](img/Image00056.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00056.jpg)'
- en: As you can see, there are some letters that have disappeared due to the use
    of the `Distinct` operator. There are no duplicate letters that appear in this
    case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于使用了`Distinct`操作符，一些字母已经消失了。在这种情况下，没有重复的字母出现。
- en: Projection
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影
- en: Projection is an operation that transforms an object into a new form. There
    are two projection operators; they are `Select` and `SelectMany` . Using the `Select`
    operator, we can transform each input element based on the given lambda expression,
    whereas using the `SelectMany` operator, we can transform each input element and
    then and flatten the resulting sequences into one sequence by concatenating them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 投影是将对象转换为新形式的操作。有两个投影操作符，它们是`Select`和`SelectMany`。使用`Select`操作符，我们可以根据给定的lambda表达式转换每个输入元素，而使用`SelectMany`操作符，我们可以转换每个输入元素，然后通过连接它们来将结果序列扁平化为一个序列。
- en: 'We had applied the `Select` operator when we discussed deferring LINQ execution.
    The following is the code snippet that uses the `Select` operator that we extract
    from the sample in Deferring LINQ execution topic:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论延迟执行LINQ时，我们应用了`Select`操作符。以下是使用`Select`操作符的代码片段，我们从延迟执行LINQ主题的示例中提取出来的：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, we use the `Select` operator, which is the `Select` keyword
    in this case since we use the query expression syntax, to select all the resulting
    elements filtered by the `Where` keyword. As we know from the `Select` operator,
    the object can be transformed into another form, and we can transform that element
    typed `Member` class object into the element typed `RecentMember` class object
    using the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the preceding code, we assume that there is a class named `RecentMember`
    , as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the preceding code snippet, we can see that we transform each input element
    using the `Select` operator. We can insert the code snippet into the following
    complete source:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we have enumerated the query using the `foreach` iterator and have written
    the element to the console using the `Console.WriteLine()` method, after running
    the preceding `SelectOperator()` method, we will get the following output on the
    console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Projection](img/Image00057.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding console screenshot, we can see that we have successfully
    transformed the `Member` type input elements into the `RecentMember` type output
    elements. We can also use the fluent syntax to produce the exact same result,
    as shown in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s move on to the `SelectMany` operator. Using this operator, we can
    select more than one sequence and then flatten the result into one sequence. Suppose
    we have two collections and we are going to select all of them; we can achieve
    the goal using the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we have two collections named `numberTypes` and `numbers` and
    want to take any possible combination from their elements. The result is in a
    new form typed `NumberType` with the following definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we run the preceding `SelectManyOperator()` method, the following output
    will be displayed on the console:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Projection](img/Image00058.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'In this code, we actually iterate the two collections to construct the combination
    of two collections since the implementation of the `SelectMany` operator is as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also apply the query expression syntax to replace the preceding fluent
    syntax using the following code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output from the query expression syntax will be exactly the same as the
    fluent syntax.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `from` keyword has two different meanings in the query expression syntax.
    When we use the keyword at the start of the syntax, it will introduce the original
    range variable and the input sequence. When we use the keyword anywhere other
    than at the beginning, it will be translated into the `SelectMany` operator.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Joining
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Joining is an operation that meshes different source sequences with no direct
    object model relationship into a single output sequence. Nevertheless, the elements
    in each source have to share a value that can be compared for equality. There
    are two joining operators in LINQ; they are `Join` and `GroupJoin` .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Join` operator uses a lookup technique to match elements from two sequences
    and then returns a flat result set. To explain this further, let''s take a look
    at the following code, which we can find in the `Joining.csproj` project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code consumes `Student` and `Course` classes with the following
    implementation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we run the preceding `JoinOperator()` method, we will get the following
    output on the console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining](img/Image00059.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding code, we can see that we have two sequences, which are `courses`
    and `students` . We can join these two sequences using the `Join` operator and
    then we create an anonymous type as the result. We can also use the query expression
    syntax to join these two sequences. The following is the code snippet we have
    to replace in our previous query creation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we run the `JoinOperator()` method again, we will get the exact same output
    on the console.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GroupJoin` operator uses the same technique that the `Join` operator uses,
    but it returns a hierarchical result set. Let''s take a look at the following
    code that explains the `GroupJoin` operator:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`操作符使用与`Join`操作符相同的技术，但返回一个分层结果集。让我们看一下下面解释`GroupJoin`操作符的代码：'
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code is similar to the Join operator code that we discussed earlier.
    The difference is in the way we create the query. In the `GroupJoin` operator,
    we join the two sequences into another sequence with a key. Let''s invoke the
    preceding `GroupJoinOperator()` method, and we will get the following output on
    the console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与我们之前讨论过的Join操作符代码类似。不同之处在于我们创建查询的方式。在`GroupJoin`操作符中，我们将两个序列与一个键合并为另一个序列。让我们调用前面的`GroupJoinOperator()`方法，我们将在控制台上得到以下输出：
- en: '![Joining](img/Image00060.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Joining](img/Image00060.jpg)'
- en: As you can see in the output, we group all the students who take a particular
    course. We then enumerate the query to get the result.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中所见，我们对所有选修特定课程的学生进行分组，然后枚举查询以获得结果。
- en: Ordering
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: 'Ordering is an operation that will sort the return sequence from the input
    sequence using the default comparer. For instance, if we have a sequence in the
    string type, the default comparer will perform an alphabetical sort from A to
    Z. Let''s take a look at the following code, which we can find in the `Ordering.csproj`
    project:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是一种操作，它将使用默认比较器对输入序列的返回序列进行排序。例如，如果我们有一个字符串类型的序列，那么默认比较器将按字母顺序从A到Z进行排序。让我们看一下以下代码，可以在`Ordering.csproj`项目中找到：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the sequence that we have to feed to the query, the code is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们必须提供给查询的序列，代码如下：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run the preceding `OrderByOperator()` method, we will get the following
    output on the console:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`OrderByOperator()`方法，将在控制台上得到以下输出：
- en: '![Ordering](img/Image00061.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00061.jpg)'
- en: 'As you can see, we execute the ordering operation using the default comparer,
    so the sequence is sorted alphabetically. We can also use the query expression
    syntax to replace the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用默认比较器执行了排序操作，因此序列按字母顺序排序。我们还可以使用查询表达式语法来替换以下代码片段：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The query expression syntax we have for the sequence is shown in the following
    code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对序列的查询表达式语法如下代码片段所示：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can create our own comparer as the key selector to sort the sequence by
    the last character in each element; here is the code we can use to achieve this
    using the `IComparer<T>` interface. Suppose we want to sort our previous sequence:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的比较器作为键选择器，通过每个元素的最后一个字符对序列进行排序；以下是我们可以使用`IComparer<T>`接口来实现这一点的代码。假设我们要对先前的序列进行排序：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also create a new class, `LastCharacterComparer` , which inherits the `IComparer<string>`
    interface, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新类`LastCharacterComparer`，它继承了`IComparer<string>`接口，如下所示：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will get the following output on the console when we run the preceding `OrderByOperatorWithComparer()`
    method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的`OrderByOperatorWithComparer()`方法时，将在控制台上得到以下输出：
- en: '![Ordering](img/Image00062.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00062.jpg)'
- en: As you can see, we have an ordered sequence now, but the sorting key is the
    last character of each element. This is achieved with the help of our custom comparer.
    Unfortunately, the custom comparer is only available using the fluent syntax.
    In other words, we can't use it in the query expression method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有一个有序的序列，但排序键是每个元素的最后一个字符。这是通过我们自定义的比较器实现的。不幸的是，自定义比较器只能在流畅语法中使用。换句话说，我们不能在查询表达式方法中使用它。
- en: 'When we sort the sequence, we can have more than one comparer as a condition.
    We can use the `ThenBy` extension method for the second condition after we call
    the `OrderBy` method. Let''s take a look at the following code to demonstrate
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对序列进行排序时，可以有多个比较器作为条件。在调用`OrderBy`方法后，我们可以使用`ThenBy`扩展方法来进行第二个条件的排序。让我们看一下以下代码来演示这一点：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From the preceding code, we sort the sequence by the length of each element,
    and then we sort the result alphabetically. If we call the `OrderByThenByOperator()`
    method, we will get the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们按每个元素的长度对序列进行排序，然后按字母顺序对结果进行排序。如果我们调用`OrderByThenByOperator()`方法，将得到以下输出：
- en: '![Ordering](img/Image00063.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00063.jpg)'
- en: 'We can also use query expression syntax when we need to sort a sequence using
    two conditions, as shown in the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用两个条件对序列进行排序时，也可以使用查询表达式语法，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run `OrderByThenByOperator()` method again after replacing the query operation
    with the query expression syntax, we will get the exact same output as we get
    when we use the fluent syntax. However, there is no `ThenBy` keyword in the query
    expression syntax. What we need to do is just separate the condition using a comma.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在用查询表达式语法替换查询操作后再次运行`OrderByThenByOperator()`方法，我们将得到与使用流畅语法时相同的输出。然而，在查询表达式语法中没有`ThenBy`关键字。我们只需要用逗号分隔条件。
- en: 'We can use our custom comparer in the use of the `ThenBy` method as well. Let''s
    take a look at the following code to try this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在使用`ThenBy`方法时使用自定义比较器。让我们看一下以下代码来尝试这个：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this code, we use the same `LastCharacterComparer` class that we use in
    the `OrderByOperatorWithComparer()` method. If we call the `OrderByThenByOperatorWithComparer()`
    method, the following is the output we will get on the console:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了与`OrderByOperatorWithComparer()`方法中相同的`LastCharacterComparer`类。如果我们调用`OrderByThenByOperatorWithComparer()`方法，将在控制台上得到以下输出：
- en: '![Ordering](img/Image00064.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00064.jpg)'
- en: 'Besides ascending sorting, we also have descending sorting. In fluent syntax,
    we can simply use `OrderByDescending()` and `ThenByDescending()` methods. The
    usage in code is exactly the same, as the code for sorting in an ascending order.
    However, in the query expression syntax, we have the descending keyword to achieve
    this goal. We use this keyword just after we define the condition in the `orderby`
    keyword, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, there is a descending keyword in the as well code. Actually,
    we can replace the descending keyword with the ascending keyword in order to sort
    the sequence in an ascending manner. However, ascending sorting is the default
    sorting in LINQ, so the ascending keyword can be omitted. The following is the
    output if we run the code and invoke the `OrderByDescendingOperator()` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering](img/Image00065.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Grouping
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grouping is an operation that will generate a sequence of `IGrouping<TKey, TElement>`
    objects, which are grouped by the `TKey` key value. For instance, we will group
    a sequence of path address files in one directory by their first letters. The
    following code can be found in the `Grouping.csproj` project file and will search
    all file in `G:\packages` , which is the setup files of Visual Studio 2015 Community
    Edition. You can adjust the drive letter and folder name based on the drive letter
    and folder name on your computer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code will find all files in the `G:\packages` folder (including
    all the subdirectories) then group them based on the first letter in their filenames.
    As you can see when we enumerate a query using the `foreach` loop, we have `g.Key`
    , which is the key selector for grouping that string list. If we run the `GroupingByFileNameExtension()`
    method, we will get the following output on the console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping](img/Image00066.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'The `GroupBy` extension method also has a clause in order to be used in the
    query expression syntax. The clauses we can use are `group` and `by` . The following
    code snippet can replace the query in our previous code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will still have the same output as the fluent syntax output, although we
    replace the query using the query expression syntax. As you can see, the grouping
    operation in LINQ only groups the sequence; it does not sort. We can sort the
    result using the `OrderBy` operator provided by LINQ.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding query expression syntax, we see that we do not need the select
    clause again since the group clause will end the query as well. However, we still
    need the select clause when using the group clause if we add a query continuation
    clause. Now let''s we take a look at the following code, which applies the query
    continuation clause to sort the sequence:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see in the preceding code, we modify the query by adding the query
    continuation clause and the `orderby` operator to sort the sequence result. The
    query continuation clause we use is the `into` keyword. Using the `into` keyword,
    we store the grouping result, and then we manipulate the grouping again. If we
    run the preceding code, we will get the following output on the console:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping](img/Image00067.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: We deliberately remove the elements of each group since what we want to examine
    now is the key itself. Now, we can see that the key is in the ascending order.
    This happens since we first store the result of the grouping then we sort the
    key in an ascending manner.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The set operation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The set operation is an operation that returns a result set that is based on
    the presence or the absence of equivalent elements within the same or separate
    collection. There are four set operators that LINQ provides; they are `Concat`
    , `Union` , `Intersect` , and `Except` . For all the four set operators, there
    is no query expression keyword.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `Concat` and `Union` . Using the `Concat` operator, we will
    get all the elements of first sequence followed by all the elements of the second
    sequence as a result. `Union` does this with the `Concat` operator but returns
    only one element for the duplicate elements. The following code, which we can
    find in the `SetOperation.csproj` project, demonstrates the difference between
    `Concat` and `Union` :'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The two sequences we have as as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our preceding code tries to use the `Concat` and `Union` operators. And as
    per our discussion, the following is the output we will get if we run the `ConcatUnionOperator()`
    method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![The set operation](img/Image00068.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'The `Intersect` and `Except` are set operators as well. `Intersect` returns
    the elements that are present in both of the input sequences. `Except` returns
    the elements of the first input sequence, which are not present in the second.
    The following code explains the difference between `Intersect` and `Except` :'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we invoke the `IntersectExceptOperator()` method, the following output will
    be displayed on the console screen:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![The set operation](img/Image00069.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: We apply the two sequences we used earlier in the `ConcatUnionOperator()` method
    as an input. As you can see from the preceding console screenshot, in the `Intersect`
    operation, only duplication elements are returned. In the `Except` operation,
    only the unique element will be returned.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Conversion methods
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main role of conversion methods is to convert one type of collections to
    other types of collection. Here, we will discuss the conversion methods provided
    by LINQ; they are `OfType` , `Cast` , `ToArray` , `ToList` , `ToDictionary` ,
    and `ToLookup` .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OfType` and `Cast` methods have a similar function; they convert `IEnumerable`
    into `IEnumerable<T>` . The difference is that `OfType` will discard the wrong
    type elements, if any, and `Cast` will throw an exception if there is any wrong
    type element. Let''s take a look at the following code, which we can find in the
    `ConversionMethods.csproj` project:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code is a simple example of using the `OfType` and `Cast` conversions.
    We have an array that contains only `int` elements. Indeed, they can be converted
    easily. The following will be the output if we run the `OfTypeCastSimple()` method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Conversion methods](img/Image00070.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In .NET Core, `ArrayList` definition lies in `System.Collections.NonGeneric.dll`
    . Hence, we have to download the NuGet package on [https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add several lines of code to the preceding code. The code will now
    be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the preceding code, we can see that we changed the method name to `OfTypeCastComplex`
    and inserted the code to add a string element to `arrayList` . If we run the method,
    the `OfType` conversion will run successfully and return only the `int` element,
    while the `Cast` conversion will throw an exception since there are some string
    elements in the input sequence.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The others conversion methods are `ToArray()` and `ToList()` . The difference
    between them is that `ToArray()` will convert the sequence into an array and `ToList()`
    into a generic list. Also, `ToDictionary()` and `ToLookup()` method names are
    available for conversion. `ToDictionary()` will create `Dictionary<TKey, TValue>`
    from the sequence based on a specified key selector function, and `ToLookup()`
    will create `Lookup<TKey, TElement>` from the sequence based on the specified
    key selector and element selector functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Element operation
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Element operation is an operation that extracts individual elements from the
    sequence according to their index or using a predicate. There are several element
    operators that exist in LINQ; they are `First` , `FirstOrDefault` , `Last` , `Single`
    , `SingleOrDefault` , `ElementAt` , and `DefaultIfEmpty` . Let's use the sample
    code to understand the function of all these element operators.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to demonstrate the element operator, which we can
    find in the `ElementOperation.csproj` project:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding code demonstrates the use of the `First` and `Last` operators.
    The numbers array is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Before we move further, let''s take a moment to look at the following output
    on the console if we run the `FirstLastOperator()` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Element operation](img/Image00071.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: From the output, we can find that the `First` operator will return the first
    element of the sequence, and the `Last` operator will return the last element.
    We can also use a lambda expression for the `First` and `Last` operators to filter
    the sequence. In the preceding example, we filtered the sequence to numbers that
    can be divided only by four.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the `First` and `Last` operators cannot return an empty value;
    instead, they throw an exception. Let''s examine the following code regarding
    the use of the `First` operator, which will return an empty sequence:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we uncomment all commented code lines in the preceding code, the method will
    throw an exception since there's no number that can be divided by `10` . To solve
    this problem, we can use the `FirstOrDefault` operator instead, and it will return
    the default value because the numbers are in the sequence of integers. So, it
    will return the default value of the integer, which is `0` .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have `Single` and `SingleOrDefault` as element operators, and we can
    take a look at their use in the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we run the preceding code, an exception is thrown due to the following code
    snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, the following code snippet causes an error:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The error occurs because the `Single` operator can only have one matching element.
    In the first code snippet, we have `2` , `4` , `6` , and `8` as the result. In
    the second code snippet, we have `3` , `6` , and `9` as the result.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Element` operation also has `ElementAt` and `ElementAtOrDefault` operators
    to get the nth element from the sequence. Let''s take a look at the following
    code to demonstrate the operators:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Like the `First` and `Last` operators, `ElementAt` has to return the value as
    well. The commented code lines in the preceding code will throw an exception since
    there's no element in index `11` . However, we can overcome this problem using
    `ElementAtOrDefault` , and then the commented lines will return the default value
    of `int` .
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The last in element operation is the `DefaultIfEmpty` operator, which will
    return the default value in a sequence if no element is found in the input sequence.
    The following code will demonstrate the `DefaultIfEmpty` operator:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Since the return of the `DefaultIfEmpty` operator is `IEnumerable<T>` , we have
    to enumerate it, although it contains only one element. As you can see in the
    preceding code, we comment the direct access of the numbers variable because it
    will return the type of variable, not the value of the variable. Instead, we have
    to enumerate the numbers query to get the one and only value stored in the `IEnumerable<T>`
    variable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LINQ has made our task of querying a collection easier because we don''t need
    to learn much syntax to access different types of collections. It implements a
    deferred execution concept, which means that the query will not be executed in
    the constructor time but in the enumeration process. Almost all query operators
    provide the deferred execution concept; however, there are exceptions for the
    operators that do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Return a scalar value or single element, such as `Count` and `First` .
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Convert the result of query; they are `ToList` , `ToArray` , `ToDictionary`
    , and `ToLookup` . They are also called conversion operators.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询的结果转换为`ToList`，`ToArray`，`ToDictionary`和`ToLookup`。它们也被称为转换操作符。
- en: In other words, methods that return a sequence implement deferred execution
    for instance, the `Select` method `(IEnumerable<X>-> Select -> IEnumerable<Y>)`
     and methods that return a single object don't implement deferred execution, for
    instance, the `First` method `(IEnumerable<X>-> First -> Y)` .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，返回序列的方法实现了延迟执行，例如`Select`方法`(IEnumerable<X>-> Select -> IEnumerable<Y>)`，而返回单个对象的方法不实现延迟执行，例如`First`方法`(IEnumerable<X>->
    First -> Y)`。
- en: There are two types of LINQ querying syntaxes; they are the fluent syntax and
    the query expression syntax. The former takes a lambda expression for the parameter
    to represent the logic that will be performed in the sequence enumeration. The
    latter is a shorthand syntax that we can use in order to perform LINQ queries.
    In the query expression syntax, .NET Framework provides the keywords for each
    query operator but not all operators. Our code will be more readable and required
    less coding when we use the query expression syntax. However, both fluent and
    query syntax will do the same thing. The difference between them is only the syntax.
    Each keyword in the query expression syntax has its own extension method in the
    `Enumerable` class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ有两种查询语法；它们是流畅语法和查询表达式语法。前者采用lambda表达式作为参数，表示将在序列枚举中执行的逻辑。后者是一种简写语法，我们可以使用它来执行LINQ查询。在查询表达式语法中，.NET
    Framework为每个查询操作符提供关键字，但并非所有操作符。当我们使用查询表达式语法时，我们的代码将更易读，编码量也会减少。然而，流畅语法和查询语法都会做同样的事情。它们之间的区别只在于语法。查询表达式语法中的每个关键字都在`Enumerable`类中有自己的扩展方法。
- en: By understanding LINQ, we now have had enough knowledge to create functional
    programming. In the next chapter, we will discuss asynchronous programming in
    order to enhance code responsiveness in order to build user-friendly application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解LINQ，我们现在已经有足够的知识来创建函数式编程。在下一章中，我们将讨论异步编程，以增强代码的响应性，从而构建用户友好的应用程序。
