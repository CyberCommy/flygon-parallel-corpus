- en: Chapter 5. Querying Any Collection Easily with LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After having a discussion on delegates, lambda expressions, and extension methods,
    we are now ready to continue our discussion about LINQ. In this chapter, we will
    delve into LINQ, which is essential in composing functional code. Here, we will
    discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LINQ Queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding deferred execution in LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing LINQ fluent syntax and LINQ query expression syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating LINQ operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Language Integrated Query** ( **LINQ** ), which was introduced in C# 3.0,
    is a language feature of .NET Framework that enables us to query data in collections
    easily implementing the `IEnumerable<T>` interface, such as `ArrayList<T>` , `List<T>`
    , an XML document, and a database. It becomes easier to query any data in a collection
    since, using LINQ, we do not need to learn a different syntax for a different
    source of data. For instance, we don''t need to learn SQL if we use LINQ when
    the data source is a database. Also, using LINQ, we don''t have to learn XQuery
    when we deal with an XML document. Fortunately, LINQ has eased our use of a common
    syntax for all the sources of data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic data units in LINQ; they are sequences, which include any
    object that implements `IEnumerable<T>` , and elements, which include the items
    in the sequence. Suppose we have the following `int` array named `intArray` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding collection, we can say that `intArray` is a sequence, and
    the contents of the array, which include the numbers from 0 to 49, are the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence can be transformed using a method called a query operator. The query
    operator accepts an input sequence and then produce the transformed sequence.
    The query will transform the sequence when it is enumerated. The query consists
    of at least an input sequence and an operator. Let''s take a look at the following
    code, which we can find in the `SequencesAndElements.csproj` project, which will
    look for the prime number from our preceding collection, `intArray` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsPrime()` extension method will have the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From our preceding code, we can see that we use the `Where` operator, which
    can be found in the `System.Linq.Enumerable` class, to transform the `intArray`
    sequence into the `extractedData` sequence, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extractedData` collection will now contain the prime numbers obtained
    from the `intArray` collection. If we run the project, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with LINQ](img/Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can actually modify our preceding code snippet in a simpler way since all
    query operators are extension methods and can be used directly in the collection.
    The modification of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By modifying the invocation of the `Where` operator, we will get the complete
    implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding `ExtractArrayWithMethodSyntax()` method, we will get
    the exact same output with the `ExtractArray()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Deferring LINQ execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LINQ implements a deferred execution concept when we query the data from a
    collection. This means that the query will not be executed in the constructor
    time but in the enumeration process instead. For example, we use the `Where` operator
    to query data from a collection. Actually, the query is not executed until we
    enumerate it. We can use the `foreach` operation to call the `MoveNext` command
    in order to enumerate the query. To discuss deferred execution in further detail,
    let''s take a look at the following code, which we can find in the `DeferredExecution.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the implementation of the preceding `DeferredExecution()`
    method, we construct a `List<Member>` member list named `memberList` , which contains
    four instances of every member who has joined to the club. The `Member` class
    itself is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After constructing `memberList` , we query the data from `memberList` , which
    includes the all members who joined after 2014\. Here, we can confirm that only
    three of four members satisfy the requirements. They are Eddie Morgan, Millie
    Duncan, and Emilia Shaw in ascending order, of course, since we use the `orderby
    m.Name` phrase in the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have the query, we add a new member to `memberList` and then run the
    `foreach` operation in order to enumerate the query. What will happen next is
    that, because most of the query operators implement deferred execution, which
    will be executed only in the enumeration process, we will have four members after
    enumerating the query since the last member we add to `memberList` satisfies the
    query requirement. To make this clear, let''s take a look at the following output
    we get on the console after invoking the `DeferredExecution()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deferring LINQ execution](img/Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `Chloe Day` , who is the last member to have joined the club,
    is included in the query result as well. This is where the deferred execution
    plays its role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all query operators provide deferred execution but not the operators
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a scalar value or a single element, such as `Count` and `First` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the result of a query, such as `ToList` , `ToArray` , `ToDictionary`
    , and `ToLookup` . They are also called conversion operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Count()` and `First()` method will be executed immediately since they
    return a single object, so it''s almost impossible to provide deferred execution
    as well as conversion operators. Using the conversion operator, we can obtain
    a cached copy of the query results and can avoid repeating the process due to
    the reevaluate operation in deferred execution. Now, let''s take a look at the
    following code, which we can find in the `NonDeferredExecution.csproj` project,
    to demonstrate the nondeferred execution process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'First, in the preceding code, we have a `List<int>` integer list named `intList`
    , which contains numbers from `0` to `9` . We then create a query named `queryInt`
    in order to select all members of `intList` and multiply them by `2` . We also
    count the total of the query data using the `Count()` method. Since `queryInt`
    is not executed yet, we create a new query named `queryIntCached` , which converts
    `queryInt` to `List<int>` using the `ToList()` conversion operator. We also count
    the total of the data in that query. We have two queries now, `queryInt` and `queryIntCached`
    . We then clear `intList` and enumerate the two queries. The following is the
    result of them being displayed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deferring LINQ execution](img/Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding console, the enumeration of `queryInt` results
    in no item. This is clear since we have removed all `intList` items, so `queryInt`
    will find no item in `intList` . However, `queryInt` is counted as ten items since
    we have run the `Count()` method before we clear `intList` , and the method is
    immediately executed right after we construct it. In contrast to `queryInt` ,
    we have ten items' data when we enumerate `queryIntCached` . This is because we
    have invoked the `ToList()` conversion operator and it is immediately executed
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more type of deferred execution. It happens when we chain the `OrderBy`
    method after a `Select` method, for instance. The `Select` method will only retrieve
    one element at the time that it has to produce an element, while the `OrderBy`
    method has to consume the entire input sequence before it returns the first element.
    So, when we chain an `OrderBy` method after the `Select` method, the execution
    will be deferred until we retrieve the first element, and then the `OrderBy` method
    will ask `Select` for all the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between fluent syntax and query expression syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our preceding discussion, we found two types of querying syntaxes so far.
    Let's discuss this further by distinguishing these two syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is the fluent syntax type. We invoke the `Select`
    and `Count` operators by invoking their extension method in the `Enumerable` class.
    Using the fluent syntax, we can also chain the method so it will approach functional
    programming as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another syntax type we can use in querying data in LINQ is query expression
    syntax. We applied this syntax type when we discussed deferred execution in the
    previous topic. The code snippet of the query expression syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the fluent syntax and the query expression syntax will do the same
    thing. The difference between them is only the syntax. Each keyword in the query
    expression syntax has its own extension method in the `Enumerable` class. To prove
    this, we can refactor the preceding code snippet to the following fluent syntax
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, we will get the exact same output for these two types of syntaxes. However,
    the fluent syntax is closer to the functional approach than the query expression
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LINQ fluent syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basically, the LINQ fluent syntax is the extension methods found in the `Enumerable`
    class. The method will extend any variable implementing the `IEnumerable<T>` interface.
    The fluent syntax takes a lambda expression as the parameter to represent the
    logic that will be performed in the sequence enumeration. As we discussed earlier,
    the fluent syntax implemented the method chain so that it can be used in the functional
    approach. In the beginning of this chapter, we had also discussed the extension
    method from which the query operator can be invoked directly using the static
    method from its class, which is the `Enumerable` class. However, by invoking the
    method directly from its class, we cannot implement the method chain we usually
    use in the functional approach. Let''s take at the following code, which we can
    find in the `FluentSyntax.csproj` project, to demonstrate the advantages of the
    fluent syntax by invoking the extension method instead of the conventional `static`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The names collection we used in the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use three query operators when we query the data from a
    collection in the preceding code. They are the `Where` , `OrderBy` , and `Select`
    operators. Let''s take a look at the following code snippet to make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding query, we will get the string collection in which each
    string contains more than four characters. The collection will be sorted in an
    ascending order by its first letter, and the string will be in uppercase characters.
    Here''s what we get on the console if we run the `UsingExtensionMethod()` method
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the LINQ fluent syntax](img/Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s refactor the preceding query to use the conventional static method.
    But before we go through it, here are the signatures of the three methods we have
    used in the preceding query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all three methods take `IEnumerable<TSource>` as the first parameter
    and also return `IEnumerable<TResult>` . We can use this similarity so that the
    return from the first method can be fed to the argument of the second method,
    the return from the second method can be fed to the argument of the third method,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Where()` method, we use the second parameter, predicate, to filter the
    sequence based on it. It's a `Func<TSource, bool>` delegate, so we can use a lambda
    expression here. The `Func<TSource, TKey>` delegate can also be found in the second
    parameter of the `OrderBy()` method, which is used as the key to sort the element
    of the sequence in an ascending order. It can be fed by anonymous method. The
    last is the `Select()` method, in which we use its second parameter, `selector`
    , to project each element in the sequence in the new form. The anonymous method
    can also be used as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the signature of the methods we used in the previous `UsingExtensionMethod()`
    method, we can refactor the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete `UsingStaticMethod()` method, which is the refactoring
    code when we use a conventional static method instead of the extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By running the `UsingStaticMethod()` method, we will get the exact output on
    the console compared to the `UsingExtensionMethod()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LINQ query expression syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A LINQ query expression syntax is a shorthand syntax that we can use to perform
    LINQ queries. In a query expression syntax, .NET framework provides the keywords
    for each query operator but not all operators. By using the query syntax, we can
    invoke the operator like we query the data using SQL in the database. Our code
    will be more readable and will require less coding when we use the query expression
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fluent syntax discussion, we created a query to extract the string from
    the string list that contains more than four characters, sorted in an ascending
    order by its first letter and converted to uppercase characters. We can do this
    using the query expression syntax, as shown in the following code, which we can
    find in the `QueryExpressionSyntax.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have refactored the previous code, which uses the fluent
    syntax for the query expression syntax. Indeed, if we run the `InvokingQueryExpression()`
    method, the exact same output will be displayed will be displayed compared to
    the `UsingExtensionMethod()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there are several LINQ operators that have no keyword in the
    query expression syntax, such as the `distinct` operator since it doesn''t take
    a lambda expression. In this case, we have to use the fluent syntax, at least
    in part if we still want to use it. The following are the operators that have
    a keyword in the query expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Where`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectMany`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThenBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderByDescending`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThenByDescending`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Join`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupJoin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, the compiler converts the query expression syntax into fluent syntax
    in the compiling process. Although the query expression syntax is sometimes easier
    to read, we cannot perform all the operations using it; instead, we have to use
    the fluent syntax, for instance, `count` operators as we discussed in *Deferring
    LINQ execution* topic. What we write in the query expression syntax can also be
    written in the fluent syntax. Therefore, the fluent syntax is the best approach
    when we code using LINQ, especially in the functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating standard query operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more than 50 query operators in the `Enumerable` class included in
    the `System.Linq` namespace. They are also known as standard query operators.
    Based on the function of the operators, we can divide them into several operations.
    Here, we are going to discuss all the query operators in LINQ provided by .NET
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering is an operation that will evaluate the element of data so that only
    the element satisfying the condition will be selected. There are six filtering
    operators; they are `Where` , `Take` , `Skip` , `TakeWhile` , `SkipWhile` , and
    `Distinct` . As we know, we have already discussed the `Where` operator in our
    previous sample code, both in the fluent syntax and the query expression syntax,
    and have an idea that it will return a subset of elements satisfying a condition
    given by a predicate. Since we are clear enough about the `Where` operator, we
    can skip it and continue with the remaining five filtering operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Take` operator returns the first `n` elements and dumps the rest. In contrast,
    the `Skip` operator ignores the first `n` elements and returns the rest. Let''s
    take a look at the following code from the `FilteringOperation.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two queries in the preceding code, `queryTake` , which applies the
    `Take` operator, and `querySkip` , which applies the `Skip` operator. They both
    consume `intList` , which is actually a list of integers containing the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `SimplyTakeAndSkipOperator()` method, we will get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering](img/Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding `Take` and `Skip` operator sample is simple code, since it deals
    with a collection containing only twenty elements. In fact, the `Take` and `Skip`
    operators are useful when we work with a huge collection, or maybe a database,
    to ease user access to the data. Suppose we have a million elements of the integer
    collection and we are looking for the element that is multiplied by two and seven.
    Without using the `Take` and `Skip` operators, we will have a ton of results,
    and if we show them on the console, they will clutter the console display. Let''s
    take a look at the following code to prove this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we have `hugeQuery` containing huge data. If we run the
    method, it needs about ten seconds to complete the iteration of all elements.
    We can also add the `Count` operator if we want to retrieve the actual elements
    `hugeQuery` contains, which is *71428* elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can modify the code by adding the `Take` and `Skip` operators around
    the `foreach` loop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `TakeAndSkipOperator()` method, we add a couple of line of
    code in the highlighted lines. Now, although we have a lot of data, the output
    will be displayed conveniently when we run the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering](img/Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the entire result is not presented on the console, only ten
    integers each time. Users can press **Enter** key if they want to continue to
    read the rest of data. This is what we usually call pagination. The `Take` and
    `Skip` operators have done a good job to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides discussing `Take` and `Skip` operators, we are going to discuss `TakeWhile`
    and `SkipWhile` operators in filtering operators. In `TakeWhile` operator, the
    input collection will be enumerated and each element will be sent to the query
    until the predicate is `false` . In contrast, the input collection will be enumerated,
    and when the predicate is `true` , the element will be sent to the query. Now,
    let''s take a look at the following code to demonstrate the `TakeWhile` and `SkipWhile`
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding method, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering](img/Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we have `n < 50` in the predicate, in `TakeWhile` , the enumeration will
    emit the elements until it reaches `53` , and in `SkipWhile` , the element start
    to be emitted when the enumeration reaches `53` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the `Distinct` operator in this filtering operation. The `Distinct`
    operator will return the input sequence without any duplicate elements. Suppose
    we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have a string and we intend to remove all duplicate
    letters in that string. We use the `Distinct` operator to get the query and then
    enumerate it. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering](img/Image00056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are some letters that have disappeared due to the use
    of the `Distinct` operator. There are no duplicate letters that appear in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Projection is an operation that transforms an object into a new form. There
    are two projection operators; they are `Select` and `SelectMany` . Using the `Select`
    operator, we can transform each input element based on the given lambda expression,
    whereas using the `SelectMany` operator, we can transform each input element and
    then and flatten the resulting sequences into one sequence by concatenating them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had applied the `Select` operator when we discussed deferring LINQ execution.
    The following is the code snippet that uses the `Select` operator that we extract
    from the sample in Deferring LINQ execution topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use the `Select` operator, which is the `Select` keyword
    in this case since we use the query expression syntax, to select all the resulting
    elements filtered by the `Where` keyword. As we know from the `Select` operator,
    the object can be transformed into another form, and we can transform that element
    typed `Member` class object into the element typed `RecentMember` class object
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding code, we assume that there is a class named `RecentMember`
    , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code snippet, we can see that we transform each input element
    using the `Select` operator. We can insert the code snippet into the following
    complete source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have enumerated the query using the `foreach` iterator and have written
    the element to the console using the `Console.WriteLine()` method, after running
    the preceding `SelectOperator()` method, we will get the following output on the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Projection](img/Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding console screenshot, we can see that we have successfully
    transformed the `Member` type input elements into the `RecentMember` type output
    elements. We can also use the fluent syntax to produce the exact same result,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to the `SelectMany` operator. Using this operator, we can
    select more than one sequence and then flatten the result into one sequence. Suppose
    we have two collections and we are going to select all of them; we can achieve
    the goal using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have two collections named `numberTypes` and `numbers` and
    want to take any possible combination from their elements. The result is in a
    new form typed `NumberType` with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `SelectManyOperator()` method, the following output
    will be displayed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Projection](img/Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this code, we actually iterate the two collections to construct the combination
    of two collections since the implementation of the `SelectMany` operator is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply the query expression syntax to replace the preceding fluent
    syntax using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output from the query expression syntax will be exactly the same as the
    fluent syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `from` keyword has two different meanings in the query expression syntax.
    When we use the keyword at the start of the syntax, it will introduce the original
    range variable and the input sequence. When we use the keyword anywhere other
    than at the beginning, it will be translated into the `SelectMany` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Joining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Joining is an operation that meshes different source sequences with no direct
    object model relationship into a single output sequence. Nevertheless, the elements
    in each source have to share a value that can be compared for equality. There
    are two joining operators in LINQ; they are `Join` and `GroupJoin` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Join` operator uses a lookup technique to match elements from two sequences
    and then returns a flat result set. To explain this further, let''s take a look
    at the following code, which we can find in the `Joining.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code consumes `Student` and `Course` classes with the following
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `JoinOperator()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining](img/Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding code, we can see that we have two sequences, which are `courses`
    and `students` . We can join these two sequences using the `Join` operator and
    then we create an anonymous type as the result. We can also use the query expression
    syntax to join these two sequences. The following is the code snippet we have
    to replace in our previous query creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we run the `JoinOperator()` method again, we will get the exact same output
    on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GroupJoin` operator uses the same technique that the `Join` operator uses,
    but it returns a hierarchical result set. Let''s take a look at the following
    code that explains the `GroupJoin` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is similar to the Join operator code that we discussed earlier.
    The difference is in the way we create the query. In the `GroupJoin` operator,
    we join the two sequences into another sequence with a key. Let''s invoke the
    preceding `GroupJoinOperator()` method, and we will get the following output on
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining](img/Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the output, we group all the students who take a particular
    course. We then enumerate the query to get the result.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ordering is an operation that will sort the return sequence from the input
    sequence using the default comparer. For instance, if we have a sequence in the
    string type, the default comparer will perform an alphabetical sort from A to
    Z. Let''s take a look at the following code, which we can find in the `Ordering.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sequence that we have to feed to the query, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `OrderByOperator()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering](img/Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we execute the ordering operation using the default comparer,
    so the sequence is sorted alphabetically. We can also use the query expression
    syntax to replace the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The query expression syntax we have for the sequence is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create our own comparer as the key selector to sort the sequence by
    the last character in each element; here is the code we can use to achieve this
    using the `IComparer<T>` interface. Suppose we want to sort our previous sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create a new class, `LastCharacterComparer` , which inherits the `IComparer<string>`
    interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the console when we run the preceding `OrderByOperatorWithComparer()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering](img/Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have an ordered sequence now, but the sorting key is the
    last character of each element. This is achieved with the help of our custom comparer.
    Unfortunately, the custom comparer is only available using the fluent syntax.
    In other words, we can't use it in the query expression method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we sort the sequence, we can have more than one comparer as a condition.
    We can use the `ThenBy` extension method for the second condition after we call
    the `OrderBy` method. Let''s take a look at the following code to demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we sort the sequence by the length of each element,
    and then we sort the result alphabetically. If we call the `OrderByThenByOperator()`
    method, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering](img/Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use query expression syntax when we need to sort a sequence using
    two conditions, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we run `OrderByThenByOperator()` method again after replacing the query operation
    with the query expression syntax, we will get the exact same output as we get
    when we use the fluent syntax. However, there is no `ThenBy` keyword in the query
    expression syntax. What we need to do is just separate the condition using a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our custom comparer in the use of the `ThenBy` method as well. Let''s
    take a look at the following code to try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we use the same `LastCharacterComparer` class that we use in
    the `OrderByOperatorWithComparer()` method. If we call the `OrderByThenByOperatorWithComparer()`
    method, the following is the output we will get on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering](img/Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides ascending sorting, we also have descending sorting. In fluent syntax,
    we can simply use `OrderByDescending()` and `ThenByDescending()` methods. The
    usage in code is exactly the same, as the code for sorting in an ascending order.
    However, in the query expression syntax, we have the descending keyword to achieve
    this goal. We use this keyword just after we define the condition in the `orderby`
    keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is a descending keyword in the as well code. Actually,
    we can replace the descending keyword with the ascending keyword in order to sort
    the sequence in an ascending manner. However, ascending sorting is the default
    sorting in LINQ, so the ascending keyword can be omitted. The following is the
    output if we run the code and invoke the `OrderByDescendingOperator()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering](img/Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grouping is an operation that will generate a sequence of `IGrouping<TKey, TElement>`
    objects, which are grouped by the `TKey` key value. For instance, we will group
    a sequence of path address files in one directory by their first letters. The
    following code can be found in the `Grouping.csproj` project file and will search
    all file in `G:\packages` , which is the setup files of Visual Studio 2015 Community
    Edition. You can adjust the drive letter and folder name based on the drive letter
    and folder name on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will find all files in the `G:\packages` folder (including
    all the subdirectories) then group them based on the first letter in their filenames.
    As you can see when we enumerate a query using the `foreach` loop, we have `g.Key`
    , which is the key selector for grouping that string list. If we run the `GroupingByFileNameExtension()`
    method, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping](img/Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `GroupBy` extension method also has a clause in order to be used in the
    query expression syntax. The clauses we can use are `group` and `by` . The following
    code snippet can replace the query in our previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We will still have the same output as the fluent syntax output, although we
    replace the query using the query expression syntax. As you can see, the grouping
    operation in LINQ only groups the sequence; it does not sort. We can sort the
    result using the `OrderBy` operator provided by LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding query expression syntax, we see that we do not need the select
    clause again since the group clause will end the query as well. However, we still
    need the select clause when using the group clause if we add a query continuation
    clause. Now let''s we take a look at the following code, which applies the query
    continuation clause to sort the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we modify the query by adding the query
    continuation clause and the `orderby` operator to sort the sequence result. The
    query continuation clause we use is the `into` keyword. Using the `into` keyword,
    we store the grouping result, and then we manipulate the grouping again. If we
    run the preceding code, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping](img/Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We deliberately remove the elements of each group since what we want to examine
    now is the key itself. Now, we can see that the key is in the ascending order.
    This happens since we first store the result of the grouping then we sort the
    key in an ascending manner.
  prefs: []
  type: TYPE_NORMAL
- en: The set operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The set operation is an operation that returns a result set that is based on
    the presence or the absence of equivalent elements within the same or separate
    collection. There are four set operators that LINQ provides; they are `Concat`
    , `Union` , `Intersect` , and `Except` . For all the four set operators, there
    is no query expression keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `Concat` and `Union` . Using the `Concat` operator, we will
    get all the elements of first sequence followed by all the elements of the second
    sequence as a result. `Union` does this with the `Concat` operator but returns
    only one element for the duplicate elements. The following code, which we can
    find in the `SetOperation.csproj` project, demonstrates the difference between
    `Concat` and `Union` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The two sequences we have as as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Our preceding code tries to use the `Concat` and `Union` operators. And as
    per our discussion, the following is the output we will get if we run the `ConcatUnionOperator()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The set operation](img/Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Intersect` and `Except` are set operators as well. `Intersect` returns
    the elements that are present in both of the input sequences. `Except` returns
    the elements of the first input sequence, which are not present in the second.
    The following code explains the difference between `Intersect` and `Except` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke the `IntersectExceptOperator()` method, the following output will
    be displayed on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The set operation](img/Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We apply the two sequences we used earlier in the `ConcatUnionOperator()` method
    as an input. As you can see from the preceding console screenshot, in the `Intersect`
    operation, only duplication elements are returned. In the `Except` operation,
    only the unique element will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main role of conversion methods is to convert one type of collections to
    other types of collection. Here, we will discuss the conversion methods provided
    by LINQ; they are `OfType` , `Cast` , `ToArray` , `ToList` , `ToDictionary` ,
    and `ToLookup` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OfType` and `Cast` methods have a similar function; they convert `IEnumerable`
    into `IEnumerable<T>` . The difference is that `OfType` will discard the wrong
    type elements, if any, and `Cast` will throw an exception if there is any wrong
    type element. Let''s take a look at the following code, which we can find in the
    `ConversionMethods.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a simple example of using the `OfType` and `Cast` conversions.
    We have an array that contains only `int` elements. Indeed, they can be converted
    easily. The following will be the output if we run the `OfTypeCastSimple()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conversion methods](img/Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In .NET Core, `ArrayList` definition lies in `System.Collections.NonGeneric.dll`
    . Hence, we have to download the NuGet package on [https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add several lines of code to the preceding code. The code will now
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that we changed the method name to `OfTypeCastComplex`
    and inserted the code to add a string element to `arrayList` . If we run the method,
    the `OfType` conversion will run successfully and return only the `int` element,
    while the `Cast` conversion will throw an exception since there are some string
    elements in the input sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The others conversion methods are `ToArray()` and `ToList()` . The difference
    between them is that `ToArray()` will convert the sequence into an array and `ToList()`
    into a generic list. Also, `ToDictionary()` and `ToLookup()` method names are
    available for conversion. `ToDictionary()` will create `Dictionary<TKey, TValue>`
    from the sequence based on a specified key selector function, and `ToLookup()`
    will create `Lookup<TKey, TElement>` from the sequence based on the specified
    key selector and element selector functions.
  prefs: []
  type: TYPE_NORMAL
- en: Element operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Element operation is an operation that extracts individual elements from the
    sequence according to their index or using a predicate. There are several element
    operators that exist in LINQ; they are `First` , `FirstOrDefault` , `Last` , `Single`
    , `SingleOrDefault` , `ElementAt` , and `DefaultIfEmpty` . Let's use the sample
    code to understand the function of all these element operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to demonstrate the element operator, which we can
    find in the `ElementOperation.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code demonstrates the use of the `First` and `Last` operators.
    The numbers array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move further, let''s take a moment to look at the following output
    on the console if we run the `FirstLastOperator()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Element operation](img/Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can find that the `First` operator will return the first
    element of the sequence, and the `Last` operator will return the last element.
    We can also use a lambda expression for the `First` and `Last` operators to filter
    the sequence. In the preceding example, we filtered the sequence to numbers that
    can be divided only by four.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the `First` and `Last` operators cannot return an empty value;
    instead, they throw an exception. Let''s examine the following code regarding
    the use of the `First` operator, which will return an empty sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If we uncomment all commented code lines in the preceding code, the method will
    throw an exception since there's no number that can be divided by `10` . To solve
    this problem, we can use the `FirstOrDefault` operator instead, and it will return
    the default value because the numbers are in the sequence of integers. So, it
    will return the default value of the integer, which is `0` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have `Single` and `SingleOrDefault` as element operators, and we can
    take a look at their use in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, an exception is thrown due to the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the following code snippet causes an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The error occurs because the `Single` operator can only have one matching element.
    In the first code snippet, we have `2` , `4` , `6` , and `8` as the result. In
    the second code snippet, we have `3` , `6` , and `9` as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Element` operation also has `ElementAt` and `ElementAtOrDefault` operators
    to get the nth element from the sequence. Let''s take a look at the following
    code to demonstrate the operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Like the `First` and `Last` operators, `ElementAt` has to return the value as
    well. The commented code lines in the preceding code will throw an exception since
    there's no element in index `11` . However, we can overcome this problem using
    `ElementAtOrDefault` , and then the commented lines will return the default value
    of `int` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The last in element operation is the `DefaultIfEmpty` operator, which will
    return the default value in a sequence if no element is found in the input sequence.
    The following code will demonstrate the `DefaultIfEmpty` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Since the return of the `DefaultIfEmpty` operator is `IEnumerable<T>` , we have
    to enumerate it, although it contains only one element. As you can see in the
    preceding code, we comment the direct access of the numbers variable because it
    will return the type of variable, not the value of the variable. Instead, we have
    to enumerate the numbers query to get the one and only value stored in the `IEnumerable<T>`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LINQ has made our task of querying a collection easier because we don''t need
    to learn much syntax to access different types of collections. It implements a
    deferred execution concept, which means that the query will not be executed in
    the constructor time but in the enumeration process. Almost all query operators
    provide the deferred execution concept; however, there are exceptions for the
    operators that do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a scalar value or single element, such as `Count` and `First` .
  prefs: []
  type: TYPE_NORMAL
- en: Convert the result of query; they are `ToList` , `ToArray` , `ToDictionary`
    , and `ToLookup` . They are also called conversion operators.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, methods that return a sequence implement deferred execution
    for instance, the `Select` method `(IEnumerable<X>-> Select -> IEnumerable<Y>)`
     and methods that return a single object don't implement deferred execution, for
    instance, the `First` method `(IEnumerable<X>-> First -> Y)` .
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of LINQ querying syntaxes; they are the fluent syntax and
    the query expression syntax. The former takes a lambda expression for the parameter
    to represent the logic that will be performed in the sequence enumeration. The
    latter is a shorthand syntax that we can use in order to perform LINQ queries.
    In the query expression syntax, .NET Framework provides the keywords for each
    query operator but not all operators. Our code will be more readable and required
    less coding when we use the query expression syntax. However, both fluent and
    query syntax will do the same thing. The difference between them is only the syntax.
    Each keyword in the query expression syntax has its own extension method in the
    `Enumerable` class.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding LINQ, we now have had enough knowledge to create functional
    programming. In the next chapter, we will discuss asynchronous programming in
    order to enhance code responsiveness in order to build user-friendly application.
  prefs: []
  type: TYPE_NORMAL
