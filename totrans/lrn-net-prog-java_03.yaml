- en: Chapter 3. NIO Support for Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the Java **New IO** (**NIO**) package's `Buffer`
    and `Channels` classes. NIO is an alternative for the earlier Java IO API and
    parts of the network API. While NIO is a broad and complex topic, our interest
    is how it provides support for network applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore several topics, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The nature and relationship between buffers, channels, and selectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of NIO techniques to build a client/server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of handling multiple clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for asynchronous socket channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic buffer operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NIO package provides extensive support to build efficient network applications.
  prefs: []
  type: TYPE_NORMAL
- en: Java NIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java NIO uses three core classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Buffer`: This holds information that is read or written to a channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Channel`: This is a stream-like technique that supports asynchronous read/write
    operations to a data source/sink'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector`: This is a mechanism to handle multiple channels in a single thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conceptually, buffers and channels work together to process data. As shown
    in the next figure, data can be moved in either direction between a buffer and
    a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Java NIO](img/B04915_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The channel is connected to some external data source, while the buffer is used
    internally to process the data. There are several types of channels and buffers.
    A few of these are listed in the following tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table for channels is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Channel class | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FileChannel` | This connects to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `DatagramChannel` | This supports datagram sockets |'
  prefs: []
  type: TYPE_TB
- en: '| `SocketChannel` | This supports streaming sockets |'
  prefs: []
  type: TYPE_TB
- en: '| `ServerSocketChannel` | This listens for socket requests |'
  prefs: []
  type: TYPE_TB
- en: '| `NetworkChannel` | This supports a network socket |'
  prefs: []
  type: TYPE_TB
- en: '| `AsynchronousSocketChannel` | This supports asynchronous streaming sockets
    |'
  prefs: []
  type: TYPE_TB
- en: 'The table for buffers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Buffer class | Data type supported |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ByteBuffer` | `byte` |'
  prefs: []
  type: TYPE_TB
- en: '| `CharBuffer` | `char` |'
  prefs: []
  type: TYPE_TB
- en: '| `DoubleBuffer` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `FloatBuffer` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntBuffer` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `LongBuffer` | `long` |'
  prefs: []
  type: TYPE_TB
- en: '| `ShortBuffer` | `short` |'
  prefs: []
  type: TYPE_TB
- en: The `Selector` class is useful when an application uses many low-traffic connections
    that can be handled using a single thread. This is more efficient than creating
    a thread for each connection. This is also a technique that is used to make an
    application more scalable, something that we will discuss in [Chapter 7](ch07.html
    "Chapter 7. Network Scalability"), *Network Scalability*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create client/server applications to illustrate the
    interaction between channels and buffers. This includes a simple time server,
    a chat server to demonstrate variable length messages, a parts server to illustrate
    one technique to handle multiple clients, and an asynchronous server. We will
    also examine specialized buffer techniques, including bulk transfers and views.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin our discussion with an overview of buffers, and how they work
    with channels.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffers hold data temporarily because it is being moved to and from channels.
    When a buffer is created, it is created with a fixed size or capacity. Part or
    all of a buffer's memory can be used with several `Buffer` class fields available
    to manage the data in a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Buffer` class is abstract. However, it possesses the basic methods used
    to manipulate a buffer, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`capacity`: This returns the number of elements in the buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: This returns the first index of the buffer that should not be accessed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`position`: This returns the index of the next element to be read or written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The element depends on the buffer type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mark` and `reset` methods also control the position within a buffer. The
    `mark` method will set the buffer''s mark to its position. The `reset` method
    restores the mark position to the previously marked position. The following code
    shows the relationships between various buffer terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A buffer can be either **direct** or **non-direct**. A direct buffer will attempt
    to use the native IO methods whenever possible. The creation of a direct buffer
    tends to be more expensive but will perform more efficiently for larger buffers,
    which reside in the memory longer. The `allocateDirect` method is used to create
    a direct buffer and accepts an integer specifying the size of the buffer. The
    `allocate` method also accepts an integer size argument but creates a non-direct
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: A non-direct buffer will not be as efficient as a direct buffer for most operations.
    However, memory used by the non-direct buffer will be reclaimed by the JVM garbage
    collector, whereas direct memory buffers may be outside the control of the JVM.
    This makes the management of memory more predictable with non-direct buffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several methods that are used to transfer data between a channel
    and a buffer. These can be classified as either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute or relative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk transfers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using primitive data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compacting, duplicating, and slicing a byte buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many `Buffer` class's methods support invocation chaining. A put type method
    will transfer data to a buffer, while a get type method retrieves information
    from a buffer. We will be using the get and put methods extensively in our examples.
    These methods will transfer a single byte at a time.
  prefs: []
  type: TYPE_NORMAL
- en: These get and put methods are relative to the current location of the position
    within a buffer. There are also several absolute methods that use an index in
    the buffer to isolate a specific buffer element.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk data transfers contiguous blocks of data. These get and put methods use
    an array of bytes as one of their arguments to hold the data. These are discussed
    in the *Bulk data transfer* section.
  prefs: []
  type: TYPE_NORMAL
- en: When all of the data in a `Buffer` class is of the same type, a **view** can
    be created permitting convenient access to the data using a specific data type
    such as `Float`. We will demonstrate this buffer in the *Using a view* section.
  prefs: []
  type: TYPE_NORMAL
- en: Compacting, duplicating, and slicing type operations are supported. The compacting
    operation will shift the contents of a buffer to eliminate data that has already
    been processed. Duplication will make a copy of a buffer, while slicing creates
    a new buffer that is based on the all or part of the original buffer. Changes
    to either buffer will be reflected in the other. However, the position, limit,
    and mark values of each buffer are independent.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a buffer in action starting with the creation of a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Using channels with a time server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The time server and client that were introduced in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Network Programming"), *Getting Started with Network Programming*,
    will be implemented here to demonstrate the use of buffers and channels. These
    applications are simple, but they illustrate how buffers and channels can be used
    together. We will start by creating a server and then create a client that uses
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a time server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is the initial declaration of the `ServerSocketChannelTimeServer`
    class, which will be our time server. The `ServerSocketChannel` class''s `open`
    method creates a `ServerSocketChannel` instance. The `socket` method retrieves
    the `ServerSocket` instance for the channel. The `bind` method then associates
    this server socket with port `5000`. While the `ServerSocketChannel` class has
    a `close` method, it is easier to use the try-with-resources block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will enter an infinite loop where the `accept` methods blocks until
    a request is received from a client. When this happens, a `SocketChannel` instance
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming this instance is not null, a string containing the current date and
    time is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ByteBuffer` instance is created with a size of 64 bytes. This is more than
    enough for most messages. The `put` method moves the data into the buffer. This
    is a bulk data transfer operation. If the buffer not large enough, then a `BufferOverflowException`
    exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to invoke the `flip` method so that we can use it with the channel''s
    write operation. This has the effect of setting; the limit is set to the current
    position and the position to zero. A while loop is used to write out each byte
    and is terminated when there are no more bytes to write as determined by the `hasRemaining`
    method. The last action is to display the message that is sent to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is started, it will produce an output that is similar to the
    following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to create our client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a time client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client is implemented in the `SocketChannelTimeClient` class, as defined
    next. To simplify the example, the client is assumed to be on the same machine
    as the server. A `SocketAddress` instance is created using the IP address `127.0.0.1`
    and is associated with port `5000`. The `SocketChannel` class''s `open` method
    returns a `SocketChannel` instance, which will be used to handle the response
    from the server within the try-with-resources block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the body of the try block, a `ByteBuffer` instance of size 64 is created.
    Using a size smaller than the actual message will complicate this example. In
    the *Handling variable length messages* section, we will re-examine buffer sizes.
    The message is read from the channel and placed into the `ByteBuffer` instance
    using the `read` method. This buffer is then flipped to prepare it for processing.
    Each byte is read and then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When client is started, its output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date: Tue Aug 18 21:36:25 CDT 2015**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server''s output will now appear similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Date: Tue Aug 18 21:36:25 CDT 2015**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to examine the details of channel and buffer interaction.
  prefs: []
  type: TYPE_NORMAL
- en: The chat server/client applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intent of this section is to demonstrate how buffers and channels work together
    in more depth. We will use client and server applications that pass messages back
    and forth. Specifically, we will create a simple version of a chat server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a server and a client that send messages back and forth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate how to handle variable length messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will demonstrate using a fixed size message using the `sendFixedLengthMessage`
    and `receiveFixedLengthMessage` methods. Then we will use the `sendMessage` and
    `receiveMessage` methods to handle variable length messages. Fixed length messages
    are easier to handle but will not work if the length of a message exceeds the
    size of the buffer. Variable length messages require more careful handling than
    what we have seen in previous examples. These methods have been placed in a class
    called `HelperMethods` to enable their use in multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: The chat server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the server. The server is defined in the `ChatServer` class
    as defined next. A `ServerSocketChannel` instance is created and bound to port
    `5000`. It will be used in the body of the while loop. The `running` variable
    controls the lifetime of the server. Exceptions are caught as needed. As in the
    previous server, the server will block at the `accept` method until a client connects
    to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this chat/server application, communication is restricted. Once a connection
    is made, the server will prompt the user for a message to send to the client.
    The client will wait until this message is received, and then it will prompt its
    user for a reply. The reply is sent back to the server. This sequence is limited
    to simplify the interaction to focus on the channel/buffer interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a connection is made, the server displays a message to that effect and
    then enters a loop as shown next. The user is prompted for a message. The `sendFixedLengthMessage`
    method is invoked. If the user entered `quit`, then a terminating message is sent
    to the server, and the server terminates. Otherwise, the message is sent to the
    server and then the server blocks at the `receiveFixedLengthMessage` method waiting
    for the client to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server starts, its output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: With the server created, let's examine the client application.
  prefs: []
  type: TYPE_NORMAL
- en: The chat client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client application uses the `ChatClient` class, as defined next. Its structure
    is similar to the previous client application. The localhost (`127.0.0.1`) is
    used with a port of `5000`. Once a connection has been established, the program
    enters an infinite loop and waits for the server to send it a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the loop, the program blocks at the `receiveFixedLengthMessage` method
    until the server sends it a message. The message is then displayed, and the user
    is prompted for a message to send back to the server. If the message is **quit**,
    then a terminating message is sent to the server using the `sendFixedLengthMessage`
    method, and the application terminates. Otherwise the message is sent to the server,
    and the program waits for another message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the client and server created, let's take a look at how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: Server/client interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the server started, start the client application. The client''s output
    will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Chat Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for message from the server ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server output will reflect this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the message `Hello`. You will then get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**> Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for message from client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client side will now appear as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message: Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a reply of `Hi!` The client output will appear as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**> Hi!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Hi!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for message from the server ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will appear as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message: Hi!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: We can continue this process until either side enters the `quit` command. However,
    entering a message that exceeds the 64 byte buffer limit will result in a `BufferOverflowException`
    exception being thrown. Replacing the `sendFixedLengthMessage` method with the
    `sendMessage` method and the `receiveFixedLengthMessage` method with the `receiveMessage`
    method will avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine how these send and receive methods work.
  prefs: []
  type: TYPE_NORMAL
- en: The HelperMethods class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `HelperMethods` class is defined next. It possesses the send and receive
    methods that were used previously. These methods are declared as static to allow
    them to be accessed easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The fixed length message methods are shown next. They perform essentially the
    same way as the approach that was used in the *Using channels with a time server*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Handling variable length messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The technique to handle variable length messages is discussed in this section.
    The problem with variable length messages is that we do not know their length.
    We cannot assume that when a buffer is not completely filled that the end of the
    message has been reached. While this may be true with most messages, if the message
    length is the same size as the message buffer, then we may miss the end of a message.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to determining when we have reached the end of a message is
    to either send the length of a message prefixed to the message or append a special
    termination character to the end of the message. We choose the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example works for ASCII characters. If Unicode characters are used instead,
    then a `BufferOverflowException` exception will be generated. The `CharBuffer`
    class is used for character data and provides similar capabilities as the `ByteBuffer`
    class. The `CharBuffer` class is detailed at [http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html](http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html).
  prefs: []
  type: TYPE_NORMAL
- en: The value of `0x00` was used to mark the end of a message. We choose this value
    because it is not easily entered accidently by the user because it is not printable
    and happens to correspond to how strings are often terminated internally in languages,
    such as C.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `sendMessage` method that follows, the `put` method adds this termination
    byte to the end of the message before it is sent. The buffer size is the length
    of the message plus one. Otherwise, the code is similar to that used to send a
    fixed length message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `receiveMessage` method, each byte received is checked to see if it
    is the termination byte. If it is, then the message is returned. The `clear` method
    is applied to the `byteBuffer` variable after we have extracted part of the message.
    This method is required; otherwise, the read method will return `0`. The method
    will set the buffer''s position back to `0` and the limit to capacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to demonstrate the application.
  prefs: []
  type: TYPE_NORMAL
- en: Running the chat server/client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server first. The output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client, which will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Chat Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for message from the server ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These users interchange between the server and the client is limited with the
    current implementation. When both applications have been started, the client will
    be waiting for a message from the server. This is reflected by a server window,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for request ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a message is entered, it is sent to the client. Enter the message **Hello**.
    The client window will now display the message, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Chat Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for message from the server ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message: Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, the following output will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for message from client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: We can now send a message from the client to the server. Messages can be interchanged
    in this manner until the `quit` message is sent from either application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling multiple clients can be achieved using threads. In this section, we
    will develop a simple parts server and client applications. The server will use
    a separate thread to handle each client. This technique is simple to implement,
    but it will not always be suitable for more demanding applications. We will introduce
    alternate techniques to multitask in [Chapter 7](ch07.html "Chapter 7. Network
    Scalability"), *Network Scalability*.
  prefs: []
  type: TYPE_NORMAL
- en: The parts server is implemented in the `PartsServer` class, and the client is
    implemented in the `PartsClient` class. A new instance of a `ClientHandler` class
    will be created for each client. This handler will accept requests for the price
    of a part. The client will send the name of the part to the handler. The handler
    will look up the price of the part using the `getPrice` method of `PartsServer`.
    It will then return the price to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The parts server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parts server uses a `HashMap` variable to hold information about parts.
    The name of the part is used as a key, and the value is stored as a `Float` object.
    The `PartsServer` class is declared here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server has started, the `initializeParts` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This method follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler will use the `getPrice` method to retrieve the price of a part,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `initializeParts` method has been called, a try block is used to
    open a connection to a client as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, an infinite loop will create a new handler for each client. While there
    are several ways of creating a thread in Java, the approach that is used next
    creates a new instance of the `ClientHandler` class, passing the client's socket
    to the class's constructor. This approach does not limit the number of threads
    created by the application, which makes it susceptible to a denial of service
    attack. In [Chapter 7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*,
    we will examine several alternate threading approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ClientHandler` instance is used as the argument of the `Thread` class.
    The class will create a new thread that will execute the `ClientHandler` class''s
    `run` method. However, the `run` method should not be called directly, but instead
    the `start` method is invoked. This method will create the program stack that
    is needed for the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is started, it will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine how the handler works.
  prefs: []
  type: TYPE_NORMAL
- en: The parts client handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ClientHandler` class is defined in the following code. The `socketChannel`
    instance variable is used to connect to the client. In the `run` method, a message
    indicating the start of the handler will be displayed. It is not required, but
    it will help us look at how the server, client, and handler interact.
  prefs: []
  type: TYPE_NORMAL
- en: 'An infinite loop is entered where the `receiveMessage` method, developed in
    the *The HelperMethods class* section, is used to get the name of the part. A
    `quit` message will terminate the handler. Otherwise, the `getPrice` method is
    called, which is returned back to the client using the `sendMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We will observe the output of the `run` method when we demonstrate the client.
  prefs: []
  type: TYPE_NORMAL
- en: The parts client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PartsClient` class is defined in the next code sequence. A connection
    to the server is established. Messages are displayed indicating when the client
    starts, and the server connection is made. The `Scanner` class is used in the
    while loop to get input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the loop will prompt the user for a part name. If the name is quit,
    then the client will terminate. Otherwise, the `sendMessage` method will send
    the name to the handler for processing. The client will block at the `receiveMessage`
    method invocation until the server responds. The price of this part will then
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how they all work together.
  prefs: []
  type: TYPE_NORMAL
- en: Running the parts client/server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server first. The server will produce the following output when it
    is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the client application. You will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PartsClient Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Parts Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a part name, such as `Hammer`. The client output will now appear as shown
    next. The **Sent: Hammer** output is an artifact of the `sendMessage` method and
    can be removed by modifying the `sendMessage` method if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PartsClient Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Parts Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name: Hammer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Hammer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The price is 12.55**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, you will get an output similar to the following one. A
    message displaying information about the handler is seen whenever a new client
    is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClientHandler Started for java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1:51132]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: 12.55**'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the client side, we can continue checking prices until we enter the `quit`
    command. This command will terminate the client. One possible sequence of requests
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PartsClient Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to Parts Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name: Hammer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Hammer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The price is 12.55**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name: Pliers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Pliers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The price is 4.65**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name: saw**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: saw**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The price is null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name: Saw**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Saw**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The price is 8.45**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter part name: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PartsClient Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will continue running as there may be other clients seeking price
    information. Output similar to the following one will be displayed by the server
    when a client handler terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClientHandler Terminated for java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1: 51132]**'
  prefs: []
  type: TYPE_NORMAL
- en: Start up two or more clients, and watch how they interact with the server. We
    will investigate more sophisticated ways of scaling an application in [Chapter
    7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous socket channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous communication involves making a request, and then proceeding with
    some other operation without having to wait for the request to be completed. This
    is referred to as non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three classes used to support asynchronous channel operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsynchronousSocketChannel`: This is a simple asynchronous channel to a socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousServerSocketChannel`: This is an asynchronous channel to a server
    socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousDatagramChannel`: This is a channel for a datagram-oriented socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The read/write methods of the `AsynchronousSocketChannel` class are asynchronous.
    The `AsynchronousServerSocketChannel` class possesses an `accept` method, which
    returns an `AsynchronousSocketChannel` instance. This method is also asynchronous.
    We will discuss the `AsynchronousDatagramChannel` class in [Chapter 6](ch06.html
    "Chapter 6. UDP and Multicasting"), *UDP and Multicasting*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of handling asynchronous I/O operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Future` interface found in the `java.util.concurrent` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `CompletionHandler` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Future` interface represents a pending result. This supports asynchronous
    operations by allowing the application to continue executing and not block. Using
    this object, you can use one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `isDone` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get` method, which blocks until completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get` method is overloaded with one version supporting a timeout. The `CompletionHandler`
    instance is invoked when the operation has completed. This is essentially a callback.
    We will not illustrate this approach here.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop an asynchronous server and client called `AsynchronousServerSocketChannelServer`
    and `AsynchronousSocketChannelClient`, respectively. The client/server application
    is limited and only allows messages to be sent from the client to the server.
    This will allow us to focus on the asynchronous aspects of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the asynchronous server socket channel server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AsynchronousServerSocketChannelServer` class is defined in the next code
    sequence. A message indicating that the server has started is displayed, and a
    try-with-resources block is entered where an instance of the `AsynchronousServerSocketChannel`
    class is created and the actual work occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bind` method is used to associate the `serverChannel` variable, representing
    the `AsynchronousServerSocketChannel` instance, with the localhost and port `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The server then waits for a client to connect. The `Future` instance is reference
    by the `acceptResult` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another try block is used to handle client requests. It creates an instance
    of the `AsynchronousSocketChannel` class, which connects to the client. The `get`
    method will block until the channel is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the try block will allocate a buffer and then read from the channel
    to populate the buffer. When the buffer has been populated, the `flip` method
    is applied to the buffer and the message is processed and displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three ways of determining whether the buffer is ready. The first
    technique polls the `Future` object, represented by the result variable, using
    the `isDone` method until the buffer is ready, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second technique uses the `get` method, which blocks until the buffer is
    ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The third technique also uses the `get` method but uses a timeout to determine
    how long to wait. In this example, it waits 10 seconds before timing out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When this version of the `get` method is used, a catch block needs to be added
    to the enclosing try block to handle a `TimeoutException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the server is started, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client to connect...**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine the client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the asynchronous socket channel client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client is implemented using the `AsynchronousSocketChannelClient` class
    in the next code snippet. A message indicating that the client has started is
    displayed, followed by a try block that creates a `AsynchronousSocketChannel`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An `InetSocketAddress` instance is created specifying the address and port
    number used by the server. A `Future` object representing the connection is then
    created. The `get` method will block until the connection is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the connection is made, a message is displayed. An infinite loop is entered
    where the user is prompted for a message. The `wrap` method will populate the
    buffer with the message. The `write` method will start writing the message to
    the `AsynchronousSocketChannel` instance and will return a `Future` object. The
    `isDone` method is used to wait for the write to complete. If the message is **quit**,
    the client application will terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the asynchronous client/server in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the server running, start the client application. This will produce the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client is started: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending messages to server:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the server now appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client to connect...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messages from client:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the client, we can enter the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**> Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**> This message is from the asynchronous client and is sent to the server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**> quit**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These will be sent to the server one at a time. From the server, we will get
    the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This message is from the asynchr**'
  prefs: []
  type: TYPE_NORMAL
- en: '**onous client and is sent to the**'
  prefs: []
  type: TYPE_NORMAL
- en: '**server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**quit**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the longer message has been split across multiple lines. This is the
    result of using a server buffer size of only 32 bytes. A larger buffer would have
    avoided this issue. However, unless we know the size of the largest message that
    will be sent, we need to develop a way of handling long messages. This is left
    as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Other buffer operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will wrap up by examining several other buffer operations that can be useful.
    These include bulk data transfers between a buffer and an array using a view,
    and read-only buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk data transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bulk transfer is a way of transferring data between a buffer and an array.
    There are several get and put type methods that support bulk data transfers. They
    usually have two versions. The first version uses a single argument, which is
    the transfer array. The second version also uses an array, but it has two additional
    arguments: the starting index in the array, and the number of elements to transfer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate these techniques, we will use an `IntBuffer` buffer. We will
    use the following `displayBuffer` method to help us understand how data transfers
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by declaring an array and transferring its contents to a buffer.
    The array is declared and initialized in the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A buffer is allocated, which is larger than the array, as shown next. The difference
    between the array size and the data available in the buffer is important. If not
    handled properly, exceptions will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use the bulk `put` method to transfer the contents of the array
    to the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer is then displayed using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows. The entire array has been transferred, and the position
    is set to the next available index:'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.nio.HeapIntBuffer[pos=4 lim=6 cap=6]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12 51 79 54**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As there is still room in the buffer, we can transfer more data into it. However,
    we have to be careful not to try to transfer too much, otherwise an exception
    will be thrown. The first step is to determine how much space is left in the buffer.
    As shown next, the `remaining` method does this. The bulk `put` statement then
    transfers the first two elements of the array to the last two positions of the
    buffer, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we display the buffer and its contents again, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.nio.HeapIntBuffer[pos=6 lim=6 cap=6]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12 51 79 54 12 51**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` method is overloaded to support bulk data transfer. We can modify
    the `displayBuffer` method to illustrate how this works, as shown next. An integer
    array is created that is the same size as the contents of the buffer. The `rewind`
    method will move the position of the buffer back to zero. The bulk `get` method
    then performs the transfer followed by a for-each loop to actually display its
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using a view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A view mirrors the data in another buffer. Modification to either buffer will
    affect the other buffer. However, the position and limit are independent. A view
    can be created with several methods, including the `duplicate` method. In the
    following example, a view is made of a buffer using the bulk `getBytes` method
    against a string. The view is then created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate that the modification of one buffer will affect the other buffer,
    the first character of the duplicate is changed to the letter ''L''. The first
    byte of each buffer is then displayed to confirm the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The output will show that the letter has been changed in both buffers. The `slice`
    method will also create a view, but it uses only a portion of the original buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Using read-only buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A buffer, by default, is read-write. However, it can be read-only or read-write.
    To create a read-only buffer, use the buffer class''s `asReadOnlyBuffer` method.
    In the next sequence, a read-only buffer is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isReadOnly` method will determine if a buffer is read-only as demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The read-only buffer is a different view of the original buffer. Any modifications
    to a buffer is reflected in the other buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling socket options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying socket implementation for the socket classes can be configured.
    The options available are dependent on the socket type. Frequently, the actual
    mechanism used to support an option is OS-specific. Also, sometimes the option
    is just a hint to the underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available for each socket class shown next is adapted from the
    Java API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Option name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SocketChannel` | `SO_SNDBUF` | This is the size of the socket send buffer
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_RCVBUF` | This is the size of the socket receive buffer |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_KEEPALIVE` | This keeps the connection alive |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_REUSEADDR` | This re-uses the address |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_LINGER` | This lingers on close if data is present (when configured in
    blocking mode only) |'
  prefs: []
  type: TYPE_TB
- en: '| `TCP_NODELAY` | This will disable the Nagle algorithm |'
  prefs: []
  type: TYPE_TB
- en: '| `ServerSocketChannel` | `SO_RCVBUF` | This is the size of the socket receive
    buffer |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_REUSEADDR` | This re-uses address |'
  prefs: []
  type: TYPE_TB
- en: '| `AsynchronousSocketChannel` | `SO_SNDBUF` | This is the size of the socket
    send buffer |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_RCVBUF` | This is the size of the socket receive buffer |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_KEEPALIVE` | This keeps the connection alive |'
  prefs: []
  type: TYPE_TB
- en: '| `SO_REUSEADDR` | This re-uses address |'
  prefs: []
  type: TYPE_TB
- en: '| `TCP_NODELAY` | This will disable the Nagle algorithm |'
  prefs: []
  type: TYPE_TB
- en: 'Socket options are configured using the `setOption` method. The following code
    illustrates this method using a server socket channel used in *The parts server*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is an instance of the `SocketOption<T>` interface. This
    interface defines the name and type methods for an option. The `StandardSocketOptions`
    class defines a series of options, which implement this interface. For example,
    the `SO_RCVBUF` instance is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There may be additional, implementation-specific options available.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the use of the NIO's channel and buffer classes.
    A channel connects to an external source and transfers data to and from a buffer.
    We illustrated channel sockets, which connect to another socket across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers are temporary repositories for data. Using a buffer allows data to be
    accessed either sequentially or randomly. There are many buffer operations, which
    makes this a good choice for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: We examined several types of channel sockets, including the `SocketChannel`,
    `ServerSocketChannel`, and `AsynchronousSocketChannel` classes. The `ServerSocketChannel`
    class supports a server and uses an `accept` method to block until a client requests
    a connection. The method will return a `SocketChannel` instance, which will be
    connected to the client's `SocketChannel`. The `AsynchronousSocketChannel` and
    `AsynchronousSocketChannel` classes support asynchronous communication enabling
    non-blocking communication between two applications. The `DatagramChannel` is
    also supported, which we will investigate in [Chapter 6](ch06.html "Chapter 6. UDP
    and Multicasting"), *UDP and Multicasting*.
  prefs: []
  type: TYPE_NORMAL
- en: We explained how the buffer and channel classes work together and illustrated
    their use in several client/server applications. We also examined a simple approach
    to handle multiple clients using threads.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated how bulk data transfers are performed between an array and a
    buffer. Views and the use of read-only buffers were also examined. We ended with
    an introduction to how the underlying OS socket support can be configured.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use many of these classes and techniques to support
    other client/server applications.
  prefs: []
  type: TYPE_NORMAL
