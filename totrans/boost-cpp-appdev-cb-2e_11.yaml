- en: Working with the System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing files in a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing and creating files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and using plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting backtrace â€“ current call sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data quickly from one process to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing interprocess communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pointers in shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fastest way to read files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines - saving the state and postponing the execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each operating system has many system calls. These calls differ from one operating
    system to another, while doing very close things. Boost provides portable and
    safe wrappers around those calls. Knowledge of wrappers is essential for writing
    good programs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to working with the operating system. We already saw
    how to deal with network communications and signals in [Chapter 6](part0324.html#9KVM80-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Manipulating Tasks*. In this chapter, we'll take a closer look at the filesystem,
    creating, and deleting files. We'll see how data can be passed between different
    system processes, how to read files at maximum speed, and how to perform other
    tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Listing files in a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are standard library functions and classes to read and write data to files.
    But before C++17, there were no functions to list files in a directory, get the
    type of a file, or get access rights for a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how such iniquities can be fixed using Boost. We'll be doing a program
    that lists names, write accesses, and types of files in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some basics of C++ would be more than enough for using this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe requires linking against the `boost_system` and `boost_filesystem`
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe and the next one are about portable wrappers for working with a
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the following two headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to specify a directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After specifying the directory, loop through its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is getting the file info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, output the file info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step would be to output the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it; now if we run the program, it will output something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and classes of `Boost.Filesystem` just wrap around system-specific
    functions to work with files.
  prefs: []
  type: TYPE_NORMAL
- en: Note the usage of `/` in *step 2*. POSIX systems use a slash to specify paths;
    Windows, by default, uses backslashes. However, Windows understands forward slashes
    too, so `./` will work on all the popular operating systems, and it means the
    current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at *step 3*, where we are default constructing the `boost::filesystem::directory_iterator`
    class. It works just like a `std::istream_iterator` class, which acts as an `end`
    iterator when default constructed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* is a tricky one, not because this function is hard to understand,
    but because lots of conversions are happening. Dereferencing the `begin` iterator
    returns `boost::filesystem::directory_entry`, which is implicitly converted to
    `boost::filesystem::path`, which is used as a parameter for the `boost::filesystem::status`
    function. Actually, we may do much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Read the reference documentation carefully to avoid unrequired implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* is obvious, so we are moving to *step 6* where implicit conversion
    to the path happens again. A better solution would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `begin->path()` returns a const reference to the `boost::filesystem::path`
    variable that is contained inside `boost::filesystem::directory_entry`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ;`Boost.Filesystem` is a part of C++17\. All the stuff in C++17 is located
    in a single header file `<filesystem>` in namespace `std::filesystem`. The standard
    library version of filesystem differs slightly from the Boost version, mostly
    by using scoped enumerations (`enum class`) where `Boost.Filesystem` was using
    just unscoped `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a class ; `directory_entry`. That class provides caching of filesystem
    information, so if you work a lot with filesystem and query different information,
    try using `directory_entry` for a better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the case of other Boost libraries, `Boost.Filesystem` works on
    pre-C++17 compilers and even on a pre-C++11 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Erasing and creating files and directories* recipe will show another example
    of the usage of `Boost.Filesystem`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read Boost''s official documentation of `Boost.Filesystem` to get more info
    about its abilities; it is available at the following link: [http://boost.org/libs/filesystem](http://boost.org/libs/filesystem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the C++17 draft at [http://www.open- std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing and creating files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In these lines, we attempt to write something to `file.txt` in the `dir/subdir`
    directory. This attempt will fail if there is no such directory. The ability to
    work with filesystems is necessary for writing a good working code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll construct a directory and a subdirectory, write some data
    to a file, and try to create `symlink`. If the symbolic link's creation fails,
    erase the created entities. We should also avoid using exceptions as a mechanism
    of error reporting, preferring some kind of return codes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how that can be done in an elegant way using Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and the `std::ofstream` class is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The ;`Boost.Filesystem` is not a header-only library, so code in this recipe
    requires linking against the `boost_system` and `boost_filesystem` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We continue to deal with portable wrappers for a filesystem, and, in this recipe,
    we''ll see how to modify the directory content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we need to include some headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a variable to store errors (if any):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create directories, if required, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will write data to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to attempt to create `symlink`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to check that the file is accessible through `symlink`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll remove the created file, if the `symlink` creation fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw `boost::system::error_code` in action in almost all the recipes in [Chapter
    6](part0324.html#9KVM80-712b4ba1126a4c7c89e1d44de61b4bdd), *Manipulating Tasks*.
    It can store information about errors and is widely used all around Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not provide an instance of `boost::system::error_code` to the `Boost.Filesystem`
    functions, the code will compile well. In that case, when an error occurs, a `boost::filesystem::filesystem_error`
    exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Take a careful look at *step 3*. We used the `boost::filesystem::create_directories`
    function, not `boost::filesystem::create_directory`, because the latter one cannot
    create sub-directories. It is the same story with `boost::filesystem::remove_all`
    and `boost::filesystem::remove`. The first can remove non empty directories, that
    contain files and sub-directories. The second one removes a single file.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining steps are simple to understand and should not cause any trouble.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::system::error_code` class is a part of C++11 and can be found in
    the `<system_error>` header in the `std::` namespace. The classes of `Boost.Filesystem`
    are part of C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, here is a small recommendation for those who are going to use `Boost.Filesystem`.
    When the errors occur during filesystem, operations are routine or application
    require high responsibility/performance, for this, use `boost::system::error_codes`.
    Otherwise, catching exceptions are more preferable and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Listing files in a directory* recipe also contains information about `Boost.Filesystem`.
    Read Boost's official documentation at [http://boost.org/libs/filesystem](http://boost.org/libs/filesystem)
    to get more information and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and using plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a tricky question: we want to allow users to write extensions to the
    functionality of our program, but we do not want to give them the source codes.
    In other words we''d like to say, "*Write a function X and pack it into a shared
    library. We may use your function along with functions of some other users!"*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You meet this technique in everyday life: your browser uses it to allow third-party
    plugins, your text editor may use it for syntax highlighting, games use **dynamic
    library loading** for **downloadable content** (**DLC**s) and for adding gamer''s
    content, web pages are returned by servers that use modules/plugins for encryption/authentication
    and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the requirements for a user's function and how can we use that function
    at some point without linking it to the shared library?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. Reading the *The portable
    way to export and import functions and classes* from [Chapter 10](part0525.html#FKLNA0-712b4ba1126a4c7c89e1d44de61b4bdd)
    is a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, you have to make an agreement with your users:'
  prefs: []
  type: TYPE_NORMAL
- en: Document the requirement for the plugin interface. For example, you may say
    that all the plugins must export a function with name `greet` and that the function
    must accept `const std::string&` and return `std::string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, users may start writing plugins/shared library in the following
    way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Your program code for loading a shared library must include the header from
    `Boost.DLL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for loading a library must be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the user''s function must look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Done. Now, you can use that function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the loaded plugin, you''ll have different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plugin_hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`plugin_do_not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a small trick in *step 2*. When you declare a function as `extern "C"`,
    it means that the compiler must not **mangle** (change) the function name. In
    other words, in *step 2* we just create a function that has a name `greet` and
    is exported with that exact name from the shared library.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4,* we create a `boost::dll::shared_library` variable with name `plugin`.
    The constructor of that variable loads the shared library by a specified path
    into the address space of the current executable. In *step 5,* we search for the
    function with name `greet` in the `plugin`. We also specify that the function
    has the signature `std::string(const std::string&)` and store a pointer to that
    function in the variable `greet`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! From now on, we can use the `greet` variable as a function, as long
    as the `plugin` variable and all its copies are not destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: You can export multiple functions from shared library; you can even export variables.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful! Always link C and C++ libraries dynamically to the plugin and your
    main executable, because otherwise your application will crash. Always use the
    same or ABI compatible versions of C and C++ libraries in your plugins and in
    your application. Otherwise your application will crash. Read the docs for typical
    missuses!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.DLL` is a new library; it appeared in Boost 1.61\. My favorite part
    of the library is an ability to add platform-specific decorations to the shared
    library name. For example, the following code, depending on the platform, will
    try to load `"./some/path/libplugin_name.so"`, `"./some/path/plugin_name.dll"`,
    or `"./some/path/libplugin_name.dll"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: C++17 has no `boost::dll::shared_library`-like classes. But, work is ongoing
    and some day we may see it in the C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation contains multiple examples and, what is more important,
    typical problems/missuses of the library [http://boost.org/libs/dll](http://boost.org/libs/dll)
    site.
  prefs: []
  type: TYPE_NORMAL
- en: Getting backtrace â€“ current call sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When reporting errors or failures, it is more important to report the steps
    that lead to the error rather than the error itself. Consider the naive trading
    simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All it reports is a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's a no go. We want to know how did it happened, what were the steps that
    led to bankruptcy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay. Let''s fix the following function and make it report the steps that led
    to bankruptcy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a Boost 1.65 or newer for this recipe. Basic knowledge of C++
    is also a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will need only to construct a single class and output it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Done. Now the `report_bankruptcy()` outputs something close to the following
    (read it from the bottom up):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the magic is within the `boost::stacktrace::stacktrace` class. On construction,
    it quickly stores the current call stack in itself. `boost::stacktrace::stacktrace`
    is copyable and movable, so a stored a call sequence can be passed to other functions,
    copied into the exception classes, and even stored in some file. Do whatever you
    like with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of `boost::stacktrace::stacktrace` on the output, decode the stored
    call sequence and attempt to get human readable function names. That''s what you''ve
    seen in the example from earlier: call sequence that leads to the `report_bankruptcy()`
    function call.'
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::stacktrace::stacktrace` you to iterate over stored addresses, decode
    individual addresses into human readable names. If you do not like the default
    output format of the trace, you can write your own function that does the output
    in a way you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that backtrace usefulness depends on multiple factors. Release builds
    of your program may contain inline functions, resulting in less readable traces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Building your executable without debug symbols may produce a trace without many
    function names.
  prefs: []
  type: TYPE_NORMAL
- en: Read the *Configuration and Build* section of the official documentation for
    more information about different compilation flags and macros that may affect
    trace readability.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Boost.Stacktrace` library has a very neat feature for big projects. You can
    disable all the tracing while linking your program. It means that you do not need
    to rebuild all your source files. Just define `BOOST_STACKTRACE_LINK` macro for
    a whole project. Now, if you link with the `boost_stacktrace_noop` library, empty
    traces will be collected. Link with `boost_stacktrace_windbg`/`boost_stacktrace_windbg_cached`/`boost_stacktrace_backtrace`/
    `... libraries` to get traces of different readability.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Stacktrace` is a new library; it appeared in Boost in 1.65.'
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::stacktrace::stacktrace` collects current call sequences pretty fast;
    it just dynamically allocates a chunk of memory and copies a bunch of addresses
    into it. Decoding addresses is much slower; it uses multiple platform-specific
    calls, may fork processes, and may initialize and use **COM**.'
  prefs: []
  type: TYPE_NORMAL
- en: C++17 does not have `Boost.Stacktrace` functionality. Work is going on to add
    it to one of the next C++ standards.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation at [http://boost.org/libs/stacktrace/](http://boost.org/libs/stacktrace/)
    has some examples on async signal safe stack tracing and detailed description
    of all the `Boost.Stacktrace` abilities[.](http://boost.org/libs/stacktrace)
  prefs: []
  type: TYPE_NORMAL
- en: Passing data quickly from one process to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we write programs that communicate with each other a lot. When programs
    are run on different machines, using sockets is the most common technique for
    communication. But if multiple processes run on a single machine, we can do much
    better!
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how to make a single memory fragment available from different
    processes using the `Boost.Interprocess` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. Knowledge of atomic variables
    is also required (take a look at the *See also* section for more information about
    atomics). Some platforms require linking against the runtime library `rt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will be sharing a single atomic variable between processes,
    making it increment when a new process starts and decrement when the process terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the following header for interprocess communications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the header, `typedef`, and a check will help us make sure that atomics
    are usable for this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create, or get, a shared segment of memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Get, or construct, an `atomic` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Work with the `atomic` variable in a usual way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Destroy the `atomic` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Now if we run multiple instances of this program simultaneously,
    we''ll see that each new instance increments its index value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea of this recipe is to get a segment of memory that is visible to
    all processes and place some data in it. Let's take a look at *step 3*, where
    we retrieve such a segment of memory. Here, `shm1- cache` is the name of the segment
    (different segments differ in names). You may give any names to the segments.
    The first parameter is `boost::interprocess::open_or_create`, which tells that
    `boost::interprocess::managed_shared_memory` must open an existing segment with
    the name `shm1- cache` or construct it. The last parameter is the size of the
    segment.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the segment must be big enough to fit the `Boost.Interprocess` library-specific
    data in it. That's why we used `1024` and not `sizeof(atomic_t)`. But actually,
    the operating system rounds this value to the nearest bigger supported value,
    which is usually equal to or bigger than 4 kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* is a tricky one, as we are performing multiple tasks at the same time
    here. In part `2` of this step, we find or construct a variable with the name
    `shm1-counter` in the segment. In part `3` of *step 4*, we provide a parameter,
    which is used for the initialization of a variable, if it has not been found in
    *step 2*. This parameter is used only if the variable is not found and must be
    constructed, otherwise it is ignored. Take a closer look at the second line (part
    `1`). See the call to the dereference operator `*`. We are doing it because `segment.find_or_construct<atomic_t>`
    returns a pointer to `atomic_t`, and working with bare pointers in C++ is a bad
    style.'
  prefs: []
  type: TYPE_NORMAL
- en: We are using atomic variables in shared memory! This is required, because two
    or more processes may simultaneously work with the same `shm1-counter` atomic
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: You must be very careful when working with objects in shared memory; do not
    forget to destroy them! In *step 6*, we are destroying the object and segment
    using their names.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a closer look at *step 2,* where we are checking for `BOOST_ATOMIC_INT_LOCK_FREE
    != 2`. We are checking that `atomic_t` does not use mutexes. This is very important,
    because the usual mutexes do not work in shared memory. So if `BOOST_ATOMIC_INT_LOCK_FREE`
    is not equal to `2`, we get an undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, C++11 has no interprocess classes, and, as far as I know, `Boost.Interprocess`
    is not proposed for inclusion in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: Once a managed segment is created, it cannot increase in size automatically!
    Make sure that you are creating segments big enough for your needs, or take a
    look at the *See also* section for information about increasing managed segments.
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory is the fastest way for processes to communicate, but works for
    processes that may share memory. That usually means that processes must run on
    the same host or on a **symmetric multiprocessing** (**SMP**) cluster.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Syncing interprocess communications* recipe will tell you more about shared
    memory, interprocess communications, and syncing access to resources in shred
    memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Quick access to a common resource using atomics* recipe for more information
    about atomics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost's official documentation of `Boost.Interprocess` may also help; it is
    available at [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to increase managed segments is described in *Growing managed segments*
    at [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing interprocess communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to create shared memory and how to place
    some objects in it. Now, it's time to do something useful. Let's take an example
    from the *Making a work_queue* recipe in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, and make it work for multiple processes. At the end of this
    example, we'll get a class that may store different tasks and pass them between
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses techniques from the previous one. You will also need to read
    the *Making a work_queue* recipe in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, and get its main idea. The example requires linking against
    the runtime library `rt` on some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is considered that spawning separate sub-processes instead of threads makes
    a program more reliable, because termination of a sub-process does not terminate
    the main process. We won't argue with that assumption here, and just see how data
    sharing between processes can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of headers are required for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define our structure, `task_structure`, which will be used
    to store tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start writing the `work_queue` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the members of `work_queue` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialization of members must look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to do some minor changes to the member functions of `work_queue`, such
    as using `scoped_lock_t`, instead of the original unique locks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget about the resources cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are doing almost exactly the same things as in the *Making
    a work_queue* *class* recipe in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, but we allocate the data in shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: Take additional care when storing the shared memory objects that have pointers
    or references as member fields. We'll see how to cope with pointers in the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at *step 2*. We did not use `boost::function` as a task type because
    it has pointers in it, so it does not work in shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* is interesting because of `allocator_t`. If memory is not allocated
    from the shared memory segment, it is available to other processes; that''s why
    a specific allocator for containers is required. An `allocator_t` is a stateful
    allocator, which means that it is copied along with the container. Also, it cannot
    be default constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* is pretty simple, except that we have only references to `tasks_`,
    `mutex_`, and `cond_`. This is done because objects themselves are constructed
    in the shared memory. So, `work_queue` may only store references in them.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5,* we are initializing members. This code must be familiar to you.
    We were doing exactly the same things in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We are providing an instance of the allocator to `tasks_` while constructing
    it. That's because `allocator_t` cannot be constructed by the container itself.
    Shared memory is not destructed at the exit event of a process, so we may run
    the program once, post the tasks to a work queue, stop the program, start some
    other program, and get tasks stored by the first instance of the program. Shared
    memory is destroyed only at restart, or if you explicitly call `segment.deallocate("work-queue");`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As was already mentioned in the previous recipe, C++17 has no classes from `Boost.Interprocess`.
    Moreover, you must not use C++17 or C++03 containers in shared memory segments.
    Some of those containers may work, but that behavior is not portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look inside some of the `<boost/interprocess/containers/*.hpp>` headers,
    you''ll find that they just use containers from the `Boost.Containers` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Containers of `Boost.Interprocess` have all the benefits of the `Boost.Containers`
    library, including rvalue references and their emulation on older compilers.
  prefs: []
  type: TYPE_NORMAL
- en: A `Boost.Interprocess` is the fastest solution for communication of processes
    that are running on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using pointers in shared memory* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*,* *Multithreading*,
    for more information about synchronization primitives and multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to Boost''s official documentation of the `Boost.Interprocess` library
    for more examples and information; it is available at the following link: [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pointers in a shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is hard to imagine writing some low-level C++ core classes without pointers.
    Pointers and references are everywhere in C++, and they do not work in shared
    memory! So, if we have a structure like this in shared memory and assign the address
    of some integer variable in shared memory to `pointer_`, the `pointer_` would
    be invalid in other process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How can we fix that?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe is required for understanding this one. The example requires
    linking against the runtime system library `rt` on some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fixing it is very simple; we need only to replace the pointer with `offset_ptr<>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are free to use it like a usual pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We cannot use pointers in shared memory because, when a piece of shared memory
    is mapped into the address space of a process, its address is valid only for that
    process. When we are getting the address of a variable, it is just a local address
    for that process. Other processes will map shared memory to a different base address,
    and as a result, the variable address differs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, how can we work with an address that is always changing? There is a trick!
    As the pointer and structure are in the same shared memory segment, the distance
    between them does not change. The idea behind `boost::interprocess::offset_ptr`
    is to remember that distance between `offset_ptr` and the pointed value. On deference,
    `offset_ptr` adds the distance value to the process-dependent address of the `offset_ptr`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The offset pointer imitates the behavior of pointers, so it is a drop-in replacement
    that can be applied quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Do not place the classes that may have pointers or references into shared memory!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An offset pointer works slightly slower than the usual pointer because, on each
    dereference, it is required to compute the address. But, this difference is not
    usually what should bother you.
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has no offset pointers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation contains many examples and more advanced `Boost.Interprocess`
    features; it is available at [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Fastest way to read files* recipe contains information about some nontraditional
    usage of the `Boost.Interprocess` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fastest way to read files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All around the Internet, people are asking *"What is the fastest way to read
    files?"*. Let''s make our task for this recipe even harder: what is the fastest
    and portable way to read binary files?'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and the `std::fstream` is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technique from this recipe is widely used by applications critical to input
    and output performance. It''s the fastest way to read files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include two headers from the `Boost.Interprocess` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to open a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The main part of this recipe is mapping all the files to memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a pointer to the data in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now, we may work with a file just like with a usual memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All popular operating systems have the ability to map a file to processes' address
    space. After such mapping is done, the process may work with those addresses just
    like with a usual memory. The operating system takes care of all the file operations,
    such as caching and read ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it faster than traditional read/writes? That's because in most cases
    read/write is implemented as memory mapping and copying data to a user-specified
    buffer. So, read usually does a little bit more than memory map.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the case of standard library's `std::fstream`, we must provide
    an open mode when opening a file. See *step 2* where we provided the `boost::interprocess::read_only`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: See *step 3* where we mapped a whole file at once. This operation is actually
    really fast, because OS does not read data from the disk, but waits for requests
    to a part of the mapped region. After a part of the mapped region was requested,
    the OS loads that part of the file from the disk into the memory. As we may see,
    memory mapping operations are lazy, and the size of the mapped region does not
    affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: However, a 32-bit OS cannot memory-map big files, so you have to map them by
    pieces. POSIX (Linux) operating systems require the `_FILE_OFFSET_BITS=64` macro
    to be defined for the whole project to work with big files on a 32-bit platform.
    Otherwise, the OS won't be able to map parts of the file that are beyond 4 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to measure the performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Just as it was expected, memory-mapped files are slightly faster than traditional
    reads. We may also see that pure C methods have the same performance as the C++
    `std::ifstream` class, so do not use functions related to `FILE*` in C++. They
    are just for C, not for C++!
  prefs: []
  type: TYPE_NORMAL
- en: 'For optimal performance of `std::ifstream`, do not forget to open files in
    binary mode and read data by blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, classes for memory mapping files are not a part of C++17 and
    looks like they won't be in C++20 either.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to memory-mapped regions is also a very fast operation. The OS caches
    the writes and does not flush modifications to the disc immediately. There is
    a difference between OS and the `std::ofstream` data caching. In case the `std::ofstream`
    data is cached by an application and if it terminates, the cached data can be
    lost. When data is cached by the OS, termination of the application does not lead
    to data loss. Power failures and OS crashes lead to data loss in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple processes map a single file, and one of the processes modifies the
    mapped region, changes are immediately visible to other processes (even without
    actually writing the data to disk! Modern OS are very clever!).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Interprocess` library contains a lot of useful features to work
    with the system; not all of them are covered in this book. You may read more about
    this great library at the official site: [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess).'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines - saving the state and postponing the execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, plenty of embedded devices still have only a single core. Developers
    write for those devices, trying to squeeze maximum performance out of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Boost.Threads` or some other thread library for such devices is not effective.
    The OS will be forced to schedule threads for execution, manage resources, and
    so on, as the hardware cannot run them in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we force a program to switch to the execution of a subprogram while
    waiting for some resource in the main part? Moreover, how can we control the time
    of the subprogram's execution?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and templates is required for this recipe. Reading some
    recipes about `Boost.Function` may also help.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is about **coroutines** or **subroutines** that allow multiple entry
    points. Multiple entry points give us an ability to suspend and resume the execution
    of a program at certain locations, switching to/from other subprograms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.Coroutine2` library takes care of almost everything. We just need
    to include its header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a coroutine type with the required input parameter type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a class, representing a subprogram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the coroutine itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may execute the subprogram while waiting for some event in the main
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The coroutine method may look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tick()` function could be implemented like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At *step 2*, we are describing the input parameter of our subprogram using the
    `std::size_t` as a template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* is pretty simple, except for the `corout_t::pull_type& yield` parameters.
    We''ll see it in action in a few seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: When we call `coroutine(10)` in *step 5*, we are making a coroutine program
    to execute. Execution jumps to `coroutine_task::operator()`, where a call to `yield.get()`
    returns the input parameter `10`. The execution continues and the `coroutine_task::tick`
    function measures elapsed ticks.
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the most interesting part!
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7,* if in function `coroutine_task::tick` the `ticks_to_work` variable
    becomes equal to `0`, the execution of the coroutine suspends at `yield()` and
    `main()` continues execution. On the next call to `coroutine(some_value)`, the
    execution of the coroutine continues from the middle of the `tick` function, right
    at the line next to `yield()`. In that line, `ticks_to_work = yield.get();` is
    executed and the `ticks_to_work` variable starts to hold a new input value `some_value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It means that we can suspend/continue the coroutine in multiple places of the
    function. All the function state and variables are restored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let me describe the main difference between coroutines and threads. When a coroutine
    is executed, the main task does nothing. When the main task is executed, the coroutine
    task does nothing. You have no such guarantee with threads. With coroutines, you
    explicitly specify when to start a subtask and when to suspend it. In a single
    core environment, threads may switch at any moment; you cannot control that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While switching threads, the OS does a lot of work, so it is not a very fast
    operation. However, with coroutines, you have full control over switching tasks;
    moreover, you do not need to do some OS-specific internal kernel work. Switching
    coroutines is much faster than switching threads, although, not as fast as calling
    `boost::function`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Coroutine2` library takes care about calling a destructor for variables
    in a coroutine task, so there's no need to worry about leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines use the `boost::coroutines2::detail::forced_unwind` exception to
    free resources that are not derived from `std::exception`. You must take care
    to not catch that exception in coroutine tasks.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot copy `Boost.Coroutine2` coroutines, but you can `std::move` them.
  prefs: []
  type: TYPE_NORMAL
- en: There is a `Boost.Coroutine` library (without `2` at the end!), that does not
    require a C++11 compatible compiler. But that library is deprecated and has some
    differences (for example it does not propagate exceptions from coroutines). Beware
    of the differences! `Boost.Coroutine` also changed its interface significantly
    in Boost 1.56.
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has no coroutines. But **Coroutines TS** is almost ready, so the chances
    are high that next C++ standard will have them out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines TS differs from `Boost.Coroutine2`! Boost provides **stackful** coroutines,
    which means that you do not need to specially decorate your code with macro/keywords
    to use them. But it also means that Boost coroutines are harder to optimize by
    the compiler and that they may allocate more memory. Coroutines TS provides **stackless**
    coroutines, which means that compiler could precisely compute the required memory
    for a coroutine and even optimize out the whole coroutine. However, this approach
    requires code changes and may be slightly harder to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation contains more examples, performance notes, restrictions,
    and use cases for the `Boost.Coroutines2` library; it is available at the following
    link [http://boost.org/libs/coroutine2](http://boost.org/libs/coroutine2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at recipes from [Chapter 2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Managing Resources*, and [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, to get the difference between the `Boost.Coroutine`, `Boost.Thread`,
    and `Boost.Function` libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interested in Coroutines TS? Here''s an interesting talk on their implementation
    from the author *CppCon 2016: Gor Nishanov. C++ Coroutines: Under the covers*
    at [https://www.youtube.com/watch?v=8C8NnE1Dg4A](https://www.youtube.com/watch?v=8C8NnE1Dg4A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
