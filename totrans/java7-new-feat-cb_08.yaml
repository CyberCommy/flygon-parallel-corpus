- en: Chapter 8. Handling Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing extra mouse buttons and high resolution mouse wheels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling focus when displaying a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using secondary loops to mimic modal dialog boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling spurious thread wakeups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling applet initialization status with event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have been several additions to Java 7 that address events or are related
    to events. This includes the handling of mouse events where enhanced support is
    provided for the detection of mouse buttons and for using high resolution mouse
    wheels, as we will see in the *Managing extra mouse buttons and high resolution
    mouse wheels* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: When a window is made visible with either the `setVisible` or `toFront` methods,
    we now have the ability to control whether they should gain focus or not. Some
    windows may be displayed for informational or status purposes and do not necessarily
    need or warrant focus. How to control this behavior is explained in the *Controlling
    AutoRequestFocus* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The reader should be familiar with the behavior of modal dialog boxes. Essentially,
    the modal dialog box will not return focus to the main window until it is closed.
    There are times when it is desirable to mimic this behavior without using a dialog
    box. For example, the selection of a button that performs a relatively long running
    calculation may benefit from this behavior. The *Using secondary loops to mimic
    modal dialog boxes* recipe examines how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: While not common, spurious interrupts can occur when using the `wait` method.
    The `java.awt.event.InvocationEvent` class' `isDispatched` method can be used
    to handle spurious interrupts as detailed in the *Handling spurious thread wakeups*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Applets have also been enhanced with regards to their ability to communicate
    with JavaScript code. The *Handling Applet initialization status with event handlers*
    recipe describes how JavaScript code can be made aware of and take advantage of
    knowing when an applet loads.
  prefs: []
  type: TYPE_NORMAL
- en: Other minor event-related improvements in Java 7 that don't warrant recipes
    include the availability of accessing extended key codes and the implementation
    of the `java.awt.iamg.ImageObserver` interface for the `JSlider` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `KeyEvent` class has been augmented with two new methods: `getExtendedKeyCode`
    and `getExtendedKeyCodeForChar`. The first method returns a unique integer for
    a key, but unlike the `getKeyCode` method, its value depends on how the keyboard
    is currently configured. The second method returns the extended key code for a
    given Unicode character.'
  prefs: []
  type: TYPE_NORMAL
- en: The `imageUpdate` method has been added to the `JSlider` class. This permits
    the class to monitor the status of an image being loaded, though this capability
    is probably best used with classes that are derived from `JSlider`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing extra mouse buttons and high resolution mouse wheels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 7 has provided more options for handling mouse events. The `java.awt.Toolkit`
    class' `areExtraMouseButtonsEnabled` method allows you to determine whether more
    than the standard set of buttons is supported by the system. The `java.awt.event.MouseWheelEvent`
    class' `getPreciseWheelRotation` method can be used to control action on high
    resolution mouse wheels. In this recipe we will write a simple application to
    determine the number of mouse buttons enabled and test the mouse wheel rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new application using the starter classes `ApplicationWindow`
    and `ApplicationDriver` found in the introduction of [Chapter 7](ch07.html "Chapter 7. Graphical
    User Interface Improvements"), *Graphical User Interface Improvements*.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `MouseListener` and `MouseWheelListener` interfaces to capture
    mouse events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `areExtraMouseButtonsEnabled` and `getPreciseWheelRotation` methods
    to determine specific information about the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will set up basic information about the `JFrame` we are creating,
    using the following code example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to gather some information about the mouse. We execute the `getNumberOfButtons`
    method to determine how many buttons are present on our mouse. Then we use the
    `areExtraMouseButtonsEnabled` method to determine how many buttons on our mouse
    are available to us. We print this information to the console as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we enable our listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `mousePressed` event method, simply print out the button number pressed
    using the `getButton` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the remainder of the `MouseListener` interface methods. In the `mouseWheelMoved`
    event method, use both the `getPreciseWheelRotation` and the `getWheelRotation`
    methods to print out specific information about the movement of the mouse wheel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. You should see a `JFrame` window similar to the following:![How
    to do it...](img/5627_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you click in the window, you will see varying output in your console depending
    upon your mouse, which button you click, and in which direction you move your
    mouse wheel. Here is one possible output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**You have 5 total buttons**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0.75 - 0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.0 - 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.0 - 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.1166666666666667 - 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-1.0 - 0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-1.0 - -1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-1.2916666666666667 - -1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-1.225 - -1**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `getNumberOfButtons` method returned the total number of buttons on our
    mouse. In the previous example, there were five buttons, but if the application
    was executed on a system with no mouse, it would have returned a `-1`. In our
    `mousePressed` method, we printed the name of the button clicked, as returned
    by the `getButton` method.
  prefs: []
  type: TYPE_NORMAL
- en: We executed the `areExtraMouseButtonsEnabled` method to determine that extra
    buttons are, in fact, supported and allowed to be added to an `EventQueue`. If
    you want to change the value of this, you must do so before the `Toolkit` class
    is initialized as explained in the *There's more..*. section.
  prefs: []
  type: TYPE_NORMAL
- en: Because multiple mouse buttons were enabled, our output displayed the number
    for all five mouse buttons. In most instances, the mouse wheel is also considered
    a button and is included in the count.
  prefs: []
  type: TYPE_NORMAL
- en: The last several lines of the previous console output are indications of movement
    of the mouse wheel. The first one, **0.75 - 0**, is an indication that the mouse
    wheel was moved backwards, or toward the user. This is evident by the return value
    of 0.75 from the `getPreciseWheelRotation` method and the 0 from the `getWheelRotation`
    method. The last line of output, **-1.225 - -1**, is conversely an indication
    of forward mouse wheel movement, or away from the user. This is indicated by a
    negative return value by both methods.
  prefs: []
  type: TYPE_NORMAL
- en: This application was executed using a high resolution mouse wheel. A lower resolution
    mouse wheel will only return integer values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways of controlling whether extra mouse buttons are enabled or
    not. The first technique is to start the application with the following command
    line and set the `sun.awt.enableExtraMouseButtons` property to either `true` or
    `false:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `D` option used a `false` value specifying that the extra mouse buttons
    were not to be enabled. The second approach is to set the same property before
    the `Toolkit` class is initialized. This can be accomplished with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Controlling a focus when displaying a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `setAutoRequestFocus` method has been added to the `java.awt.Window` class
    and is used to specify whether a window should receive focus when it is displayed
    using either the `setVisible` or `toFront` methods. There may be times when a
    window is made visible, but we don't want the window to have focus. For example,
    if the window being displayed contains status information, making it visible will
    be sufficient. Giving it focus may not make sense and may frustrate the user by
    forcing them to change focus back to the original window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To control the focus when a window is made visible, we will invoke the `setAutoRequestFocus`
    method with `true` if it should receive focus and a `false` value otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate this technique we will create two windows. One will be used to
    hide and then display a second window. By using the `setAutoRequestFocus` method
    in the second window, we can control whether it receives focus or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by creating a new project with the following driver. In the driver, we
    will create the first window as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `ApplicationWindow` class. In this class, we add two buttons
    to hide and reveal the second window and a third one to exit the application as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `SecondWindow` class next. This simple window does nothing but use
    the `setAutoRequestFocus` method to control how it behaves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. Both windows should appear with the focus on the first
    window, as shown in the following screenshot:![How to do it...](img/5627_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second window appears as follows:![How to do it...](img/5627_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Hide** button. The second window should disappear. Next, select
    the **Reveal** button. The second window should reappear and should not have focus.
    This is the effect of the `setAutoRequestFocus` method, when used with a value
    of `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the application and change the argument of the `setAutoRequestFocus` method
    to `true`. Re-execute the application and hide and then reveal the second window.
    When it is revealed, the second window should receive focus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application driver displayed the application window. In the `ApplicationWindow`
    class, the second window was created and displayed. Also, the three buttons were
    created and inner classes were created to affect each of their operations. The
    `setAutoRequestFocus` method was passed a value of `false` to specify that focus
    was not to be retained when the window was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach may be useful for applications that run from the system tray.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the `isAutoRequestFocus` method is available to determine the
    value of the `autoRequestFocus` value.
  prefs: []
  type: TYPE_NORMAL
- en: Using secondary loops to mimic modal dialog boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.awt.EventQueue` class' `SecondaryLoop` interface provides a convenient
    technique for mimicking the behavior of a modal dialog box. A modal dialog box
    has two behaviors. The first one is from the user's perspective. The user is not
    permitted to interact with the main window, until the dialog box is complete.
    The second perspective is from the program execution standpoint. The thread in
    which the dialog box is called is blocked until the dialog box is closed.
  prefs: []
  type: TYPE_NORMAL
- en: A `SecondaryLoop` permits the execution of some task while blocking the current
    thread, until the secondary loop is complete. It may not have a user interface
    associated with it. This can be useful when the user selects a button that, while
    it does not display a dialog box, does involve a long running calculation. In
    this recipe we will demonstrate how to use a secondary loop and examine its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create and use a secondary loop, the following steps need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an instance of the default `java.awt.Toolkit` for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this to obtain a reference to the system event queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `SecondaryLoop` object using the event queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SecondaryLoop` interface's `enter` method to start the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the desired behavior in the secondary loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SecondaryLoop` interface's `exit` method to terminate the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new application with the following `ApplicationDriver` class. It simply
    displays the application''s window as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `ApplicationWindow` class. It creates two buttons, which
    will be used to demonstrate the behavior of secondary loops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following `actionPerformed` method. A `SecondaryLoop` object
    is created and, depending on the button selected, `WorkerThread` objects are created
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `WorkerThread` class as an inner class. Its constructor saves
    the `SecondaryLoop` object and a message is passed to it. The message will be
    used to help us interpret the results. The `run` method displays the messages
    before and after it sleeps for two seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. The following window should appear. It has been resized
    here:![How to do it...](img/5627_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, select the **First** button. The following console output should illustrate
    the execution of the secondary loop. The number following **First-** will probably
    differ from your output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**First-433 Loop Sleeping ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-433 Secondary loop completed with a result of true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-433 Secondary loop returned**'
  prefs: []
  type: TYPE_NORMAL
- en: 'While a secondary loop blocks the current thread, it does not prevent the window
    from continuing to execute. The window''s UI thread is still active. To demonstrate
    this, restart the application and select the **First** button. Before two seconds
    have elapsed, select the **Second** button. The console output should be similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**First-360 Loop Sleeping ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second-416 Loop Sleeping ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-360 Secondary loop completed with a result of true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second-416 Secondary loop completed with a result of true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second-416 Secondary loop returned**'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-360 Secondary loop returned**'
  prefs: []
  type: TYPE_NORMAL
- en: This illustrates two aspects of secondary loops. The first is that the application
    can still interact with the user, and the second is the behavior of two secondary
    loops executing at the same time. Specifically, if a second secondary loop is
    started before the first one is complete, the first one will not resume until
    the nested (second) one is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the application still responds to user input. Also, notice that
    the **Second-416** loop started execution after the **First-360**. However, while
    the **First-360** completed before the **Second-416**, as you would expect, the
    **First-360** loop did not return and resume the execution of the blocked thread,
    until after the **Second-416** loop returned. We will witness the same behavior
    if the **First** button is selected twice within two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `ApplicationWindow`, we created two buttons. The buttons were added to
    the application and then associated with the application's implementation of the
    `ActionListener` interface. We used the **First** button to illustrate the execution
    of a secondary loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the `actionPerformed` method, we used the `Toolkit` class' `getSystemEventQueue`
    method to get an instance of the `EventQueue`. This queue was then used with the
    `createSecondaryLoop` method to create a secondary loop.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep track of potential multiple secondary loops, we created an
    instance of the `Calendar` class and created a unique name derived from either
    **First-** or **Second-** suffixed with the current time in milliseconds. While
    this technique would not guarantee unique names, it is unlikely that two loops
    will have the same name and this is sufficient for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which button was pressed, an instance of `WorkerThread` was created
    using `secondaryLoop` object and a unique name. The worker thread was then started
    and the `enter` method was executed against `secondaryLoop`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the secondary loop will execute and the current thread will be
    blocked. In the `WorkerThread` class, a message was displayed indicating which
    secondary loop was executed. It was then suspended for two seconds followed by
    a second message indicating that the secondary loop completed along with the `exit`
    method return value.
  prefs: []
  type: TYPE_NORMAL
- en: The `actionPerformed` method's thread was then unblocked and a last message
    was displayed indicating that the secondary loop completed Notice that this thread
    blocked until the secondary loop completed.
  prefs: []
  type: TYPE_NORMAL
- en: This mimicked the behavior of a modal dialog box from the application's perspective.
    The thread where the secondary loop was created is blocked until the loop is completed.
    While other threading approaches could have been used to achieve a similar result,
    this approach is convenient and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not possible to use the same `SecondaryLoop` object to start a new loop
    if one is already active. Any attempt to do so will result in the `enter` method
    returning a value of `false`. However, once the loop has completed, the loop can
    be reused for other loops. This means the `enter` method can subsequently be executed
    against the same `SecondaryLoop` object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using the new JLayer Decorator for a password field* recipe in [Chapter
    7](ch07.html "Chapter 7. Graphical User Interface Improvements"), *Graphical User
    Interface Improvements*. This recipe can be useful if you need to create a timer-hour
    hourglass type animation that could be displayed over the button indicating a
    long running process.
  prefs: []
  type: TYPE_NORMAL
- en: Handling spurious thread wakeups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When multiple threads are used, one thread may need to wait until the completion
    of one or more other threads. When this is necessary, one approach is to use the
    `Object` class' `wait` method to wait for the other threads to complete. These
    other threads need to use either the `Object` class' `notify` or `notifyAll` methods
    to permit the thread that is waiting to continue.
  prefs: []
  type: TYPE_NORMAL
- en: However, spurious wakeup calls can occur in some situations. In Java 7, the
    `java.awt.event.InvocationEvent` class' `isDispatched` method has been introduced
    to address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid spurious wakeup calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a synchronized block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `while` loop based on the results of an application-specific condition
    and the `isDispatched` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `wait` method in the body of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the nature of spurious interrupts, it is not feasible to create a demonstration
    application that will consistently demonstrate this behavior. The recommended
    way of handling a `wait` is illustrated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This approach will eliminate spurious interrupts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we used a synchronized block for the object we are working with. Next,
    we obtain an instance of the `EventQueue`. The `while` loop will test an application-specific
    condition to determine if it should be in a `wait` state. This could be simply
    a Boolean variable indicating that a queue is ready to be processed. The loop
    will continue executing while the condition is `true` and the `isDispatched` method
    returns `false`. This means if the method returns `true`, then the event was actually
    dispatched from the event queue. This will also occur with the `EventQueue.invokeAndWait`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: A thread may wake up from a `wait` method for no reason at all. The `notify`
    or `notifyAll` methods may not have been called. This can occur due to conditions
    external to the JVM that are usually low-level and subtle.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions of the **Java Language Specification**, this issue was not
    mentioned. However, in Java 5 the `wait` method documentation included a discussion
    of this issue. Clarification of this issue is found in the third edition of the
    Java Language Specification, **section 17.8.1 Wait**, found at [http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1](http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1).
  prefs: []
  type: TYPE_NORMAL
- en: Handling applet initialization status with event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript code is able to call applet methods. However, this is not possible
    until the applet has been initialized. Any attempt to communicate with the applet
    will be blocked until the applet is loaded. In order to determine when the applet
    has been loaded, Java 7 has introduced a load status variable, which is accessible
    from JavaScript code. We will explore how to set up an HTML file to detect and
    respond to these events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the loading status of an applet:'
  prefs: []
  type: TYPE_NORMAL
- en: Create JavaScript functions to handle applet load events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the applet, setting the parameter `java_status_events` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new application for the Java applet. In the `java.applet.Applet` class''
    `init` method, we will create a `Graphics` object to display a simple blue rectangle
    and then sleep for two seconds. This delay will simulate the loading of the applet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Package the applet in a `SampleApplet.jar` file. Next, create an HTML file
    as follows. The first part consists of declaring a title and creating the `determineAppletState`
    function to check on the load status of the applet as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow this with the body of the HTML file. It uses an `onload` event to call
    the `determineAppletState` function. This is followed by a header field and two
    division tags. The divisions will be used for display purposes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Complete the HTML file with a JavaScript sequence that configures and executes
    the applet as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the applet into a browser. Here, it is loaded into Chrome as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SampleApplet` possessed two methods: `init` and `paint`. The `init` method
    created a `BufferedImage` object, which it used to display a blue square whose
    size is determined by the area allocated to the applet. Initially, the load was
    delayed for two seconds using the `sleep` method to simulate a slow loading applet.
    The `paint` method simply displayed the image. When the status is loading, the
    `onLoadHandler` was specified as the function to invoke when the applet completes
    loading. When this function is executed, a message to that effect was displayed
    in the `loadeddiv` division element.'
  prefs: []
  type: TYPE_NORMAL
- en: In the body tag of the HTML file, the `determineAppletState` function was specified
    as the function to execute when the HTML was loaded into the browser. This ensured
    that the load status was checked when the HTML file was loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The variable and attributes associated the `sampleApplet` ID with the `SampleApplet`
    class. The archive file containing the class and the size of the applet were also
    specified. In order to take advantage of this capability, the applet needed to
    be deployed with the `java_status_events` parameter set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The function `determineAppletState` used the load status variable, status to
    display the status of the load process. Messages displayed in HTML division elements
    showed the sequence of operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `deployJava.js` is part of the **Java Deployment Toolkit** and is used to
    detect the presence of a JRE, install one if necessary, and then run an applet.
    It can also be used for other **Web Start** programs. In this case, it was used
    to execute the applet using the attributes and parameters along with the version
    of JRE to use, that is Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about executing Java applications deployment using `deployJava.js`
    is found at [http://download.oracle.com/javase/7/docs/technotes/guides/jweb/index.html.](http://download.oracle.com/javase/7/docs/technotes/guides/jweb/index.html.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three applet status values as detailed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status | Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LOADING` | *1* | The applet is loading |'
  prefs: []
  type: TYPE_TB
- en: '| `READY` | *2* | The applet has loaded |'
  prefs: []
  type: TYPE_TB
