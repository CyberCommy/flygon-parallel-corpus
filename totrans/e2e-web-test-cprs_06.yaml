- en: '*Chapter 5*: Debugging Cypress Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the ability to identify and remove bugs from software applications.
    Having knowledge of debugging in Cypress and learning how to interpret Cypress'
    debugging output is critical to working with the Cypress framework. Cypress prides
    itself on its ability to give immediate feedback about whether tests have passed
    or failed. For Cypress to achieve an instant feedback mechanism, it has to be
    effective in the way the debug messages are structured in order to provide the
    user ease of interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to excel in this chapter, you need to have read the previous chapters
    as they will help you gain knowledge of how tests run, how Cypress works, and
    the different ways in which we can run Cypress tests. In this chapter, we will
    focus on debugging Cypress tests while running them in headed mode through a test
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this chapter will explore debugging Cypress using the test runner, Cypress
    comes bundled with other debugging tools that we might not necessarily cover in
    this chapter, since they have either been covered in the previous chapters or
    are outside the scope of this book. In this chapter, we will learn how Cypress
    debugging works in the test runner. To do this, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding page events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding errors on a test runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding time travel on executed tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding test snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the console debug output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special debug commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've worked through each of these topics, you will be ready to start
    working on the second part of this book, which involves writing Cypress tests
    using a **test-driven development** (**TDD**) approach.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the `chapter-05` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding page events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress logs every main event that takes place when the tests are running. It
    can detect when a URL is changing, when a button is clicked, or even when an assertion
    is being made. Page events capture the important events that the DOM goes through
    when a test is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how page events work, we will use our Todo application, as we
    did in the previous chapter. Following the `chapter-05` directory in our GitHub
    repository, we will create our test file in the Cypress integration subdirectory
    and name it `debugging.spec.js`. We will then create our test in the newly created
    spec file, which will navigate to the Todo application, add a todo item, and check
    for the page events that pop up in our Cypress test runner. The following code
    block will handle adding the todo item to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we are adding a todo item and checking that the item we''ve added
    can be viewed from our list of todo items. The following screenshot shows an XHR
    page event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – XHR page event'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – XHR page event
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows part of the command log for the preceding test.
    The highlighted section, named `xhr`, is the page event for loading a new page
    in Cypress. The page event is automatically detected by the Cypress mechanism
    and is automatically logged – not as a command that needs to be executed, but
    as an event that has triggered a change in the application's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress logs page events for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Submitting forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading new pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHR requests for network calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash changes for test URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify Cypress page events, we need to look for logs in the Cypress command
    log that are gray and have no kind of numbering, such as the commands that are
    within a Cypress test being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding page events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we covered what page events are, when and how they are logged,
    and how to identify them in Cypress. We also learned that page events are useful
    in tracing the main events that took place when a test was being executed. In
    the next section, we will look at how to obtain further debugging information
    when a test throws an error. We will do this by understanding the error messages
    that can be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding errors on a test runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dissect Cypress errors on the test runner, thus unpacking
    the contents of the errors thrown by Cypress and how to interpret them. We will
    cover different types of information that are present in Cypress errors, including
    the error name, the error message, the code frame file, the stack trace, the print
    to console option, and learn more. Understanding errors in Cypress will not only
    help us write better tests but also guide us through the debugging process when
    our tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress excels when it comes to logging exceptions in a test failure event.
    Cypress not only logs information about which tests are failing but goes ahead
    and drills into specific information about the error that was encountered. Errors
    such as successful test executions are visible on the Cypress command log and
    provide descriptive pieces of information that could have led to the error being
    encountered. At times, Cypress even prints suggestions of what needs to be done
    to resolve the errors on the command log.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will add a test to `debugging.spec.js` that will throw
    an error when it is run in Cypress. In the following test, we will explore the
    information that Cypress provides when an error is encountered, and also try to
    understand why that information is relevant to the process of debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This test should intentionally throw an error as we are expecting the number
    of todo items to equal `2`, although we have only added a single todo item called
    `New Todo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every error that is thrown by Cypress will contain the following pieces of
    information. These will help you identify where the problem is coming from and
    what caused the error that Cypress is throwing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error message**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code frame file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code frame**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack trace**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print to console option**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn more (optional)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Error name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress throws different kinds of errors, depending on the error that it has
    encountered. Errors in Cypress are identified by their types and they can be categorized
    by types such as Cypress errors and assertion errors, among others. The type of
    error that Cypress throws helps with debugging. This is because we can fully understand
    whether the test is failing from the tests that are running or from an error that
    Cypress has internally encountered. This error is shown in *Figure 5.2* referenced
    as *1* with the Error name.
  prefs: []
  type: TYPE_NORMAL
- en: Error message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With every error comes a message. This message gives a detailed explanation
    of what went wrong when the test was running. Error messages differ from test
    to test. While some messages may be straightforward and tell you what went wrong,
    others will go a step further and even detail the steps that you can take to fix
    the errors. Some error messages contain a **Learn more** section, which will direct
    you to the Cypress documentation that is related to the error that has been encountered.
    This error message is shown in *Figure 5.2* referenced by *2*.
  prefs: []
  type: TYPE_NORMAL
- en: Code frame file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the file that contains the error that Cypress has encountered. The file
    is shown as the topmost item of the stack trace. The code frame file is displayed
    with the line number and the column number that is highlighted in the Cypress
    error frame. When the code frame file on the stack trace is clicked, it will open
    in the preferred editor and highlight the line and the column where the error
    occurred, if the editor that was used to open the file supports code highlighting.
    We can see Code Frame File in *Figure 5.2*, which is referenced as number *3*.
  prefs: []
  type: TYPE_NORMAL
- en: Code frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the code snippet that Cypress has flagged to be the cause of the error
    that occurred. It can be found in the code frame file mentioned previously. Cypress
    highlights the specific line that is problematic to executing the test in the
    code frame snippet, as well as the column. We can identify the code frame leading
    to the failure by checking the code snippet referenced as *4* in *Figure 5.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Stack trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stack trace shows the different methods that were being executed when an
    error occurred, leading to an exception. In Cypress errors, you can toggle the
    stack trace, which can be found below the code frame in the error. This should
    show you the functions that were being executed by the test when it encountered
    an error and failed. Number *5* in *Figure 5.2* shows the stack trace region.
  prefs: []
  type: TYPE_NORMAL
- en: Print to console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress errors also offer you the option to print the error that was encountered
    by the DevTools console. The option to print the encountered errors to Command
    Prompt allows us to select a line within the stack trace and print it to the console.
    We can see this in Figure 5.2 as *6*.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, some of the test failures print a **Learn more** link,
    which, when clicked, gives us directions to the relevant Cypress documentation
    for the error that occurred. Cypress failures provide the **Learn more** link
    when the error might require more than just the assertion being adjusted or an
    expectation that is under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Information that''s present for test errors'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Information that's present for test errors
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the chronological structure of the error information
    that is displayed when a test throws an exception. As we can see, the test only
    adds one todo item to the todo list but expects to find two. The error occurs
    on the test assertion as Cypress expects two items but only one has been found,
    leading to the error.
  prefs: []
  type: TYPE_NORMAL
- en: The information provided by a failing test is crucial to the process of debugging.
    This is because not only does it become easy to identify why the tests are failing,
    but it also helps us understand where changes need to be made for us to restore
    the tests from a failing state to a passing state.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding errors on a test runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how informative Cypress errors are. We got to investigate
    different pieces of information that are embedded inside the Cypress error messages
    and their purpose in the debugging process. Knowing how Cypress presents its errors
    when they occur allows us to know how to deal with Cypress errors and understand
    where these errors are coming from. In the next section, we will look at the time
    travel feature of Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding time travel on executed tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time travel, just like in sci-fi movies but now in the context of tests, is
    the ability to move back to a state that a test was in while being executed. As
    Cypress tests execute, they create DOM snapshots that we can use to travel back
    in time and check the state of our tests at different times and when different
    actions took place. With time travel, it is possible to check whether an expected
    action takes place and how it took place. Time travel also allows us to investigate
    and audit what actions were taken when the test was running and why errors occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'To investigate time travel in Cypress tests, we will navigate to our `chapter-05`
    folder in this book''s GitHub repository and create a new test in the `debugging.spec.js`
    file, which we created previously. The following code block is a test that will
    mark added todo items as completed. With time travel, we can identify the different
    states of the application as we add todo items, and then mark them as completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block adds two todo items to the todo list and then marks
    the todo items as completed. Using the Cypress time travel feature, we can refer
    to Cypress to check the states of when we were adding the first todo item and
    even when we were adding the second todo item. By using the time travel feature,
    as shown in the following screenshot, we can further validate that both items
    were in the correct state before they were marked as completed, and that proper
    navigation was done in the process of doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Time travel and DOM snapshotting in a test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Time travel and DOM snapshotting in a test
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that the test has already finished running
    and has already passed. We can also see that we can step back in time and investigate
    what was happening when the first todo item was clicked inside the todo list.
    Since Cypress can step back in time and show us the DOM at that particular point
    in time, we can actually verify the steps that were taken to reach the end result
    of the test – whether it was a test pass or a test failure. The numbers indicated
    show the main parts of the Cypress time travel mechanism and the order in which
    the events took place.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in time travelling is waiting for the test run to be complete,
    then selecting the step that you want to time travel back to. Cypress not only
    shows the test steps but also allows you to pin the DOM snapshot of the step to
    the Cypress preview window.
  prefs: []
  type: TYPE_NORMAL
- en: After selecting the time travel step, the step of interest that we have selected
    is pinned as a DOM snapshot. We can view the step in the state it was in and in
    the new state that it was transformed into after the action took place. This can
    be seen in the preview window of the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: The third step in the time travel inspection process is to choose between **after**
    and **before** for the DOM snapshot. Toggling between **after** and **before**
    shows changes within the DOM snapshots. This toggling helps us understand how
    the actions of the Cypress step that we are inspecting changed the DOM at that
    particular stage. When we are done with our inspection, we can move on to the
    next execution step and pin the state of the test at that particular step of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Cypress time travel does not work when the test is still executing and has not
    passed or failed. For proper results, you must wait for the execution to be completed
    before you see the end results of all the relevant steps.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding time travel on executed tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how Cypress provides us with a time travel feature
    so that we can go back to the different steps that Cypress took to execute our
    tests. Time traveling in Cypress allows us to check the steps that Cypress took
    to declare our tests either as failed or passed. We also got the chance to see
    how the time travel feature works with the snapshot feature, which we will cover
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding test snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly covered the concept of snapshots when we explained the time travel
    process in Cypress. However, this does not mean we have exhausted the advantages
    of the Snapshots feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snapshots are powerful as they give us a sneak peek into how the test executes
    and into the steps that it took, which either lead to a failure state or to a
    success state in the test. When we pin DOM snapshots, Cypress freezes the test
    and highlights all the actions that were taken. The pinned snapshots allow us
    to inspect the state of the DOM, while at the same time view all the events that
    took place in that particular step. In the preceding screenshot, for example,
    in *step 2*, there''s an **event hitbox** that shows that the first todo item
    was clicked. The following screenshot shows how Cypress interprets events that
    take place as a test is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – An event hitbox for a toggled todo item'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – An event hitbox for a toggled todo item
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the event hitbox in action. Here, we can see
    a click event took place that affects the application state of the todo application.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The event hitbox is a highlight that pops up on pinned Cypress snapshots to
    show that the test interacted with the element. The event hitbox can be triggered
    by Cypress events such as the `.click()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Snapshots** menu allows us to toggle between the states of the snapshot.
    If an event took place that changed the DOM, we can toggle to see the state before
    the change took place and toggle to see the state after the change took place.
    The **before** snapshot toggle will display the state before any event that the
    selected test step triggered. On the other hand, the **after** toggle will show
    the state of the application after an event has been triggered from the selected
    step. The following screenshot shows a toggle for the pinned DOM snapshot, which
    shows what the snapshot looked like before an event and what it will look like
    after an event takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – ADOM snapshot menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – ADOM snapshot menu
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see the **Snapshot** menu items. The first
    window-like icon will hide or show the **event hitbox** on the pinned DOM snapshot,
    while the **before** and **after** menus are used to show the transition of the
    DOM of the selected step. The **close** icon of the **Snapshot** menu, when clicked,
    unpins the DOM snapshot and reverts it back to the completed step of the tests
    without any pinned DOM snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'How the **before** and **after** events of the snapshot menu items are displayed
    depends on the event that took place. In events where the action has transformed
    the state of the DOM, then both the before and after snapshots will be different.
    When the action that was performed does not directly change the DOM: it is possible
    to have similar snapshots for both the before and after states of the test step.'
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding test snapshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how Cypress stores important debugging information
    in the DOM snapshots after every test run. We also learned how to utilize Cypress
    snapshots to check the before and after states of a test step, and then use this
    in the investigation process of debugging. In the next section, we will learn
    how to utilize the console's debug output for information.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the console debug output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand how to leverage Cypress' console debug output
    to understand application state changes. We will open and interact with the console
    output in the browser's console. Understanding the output in the browser's console
    will allow us to debug tests even better, since we can investigate issues that
    are thrown as errors by Cypress and resolve them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress is excellent at providing debugging information. Since all the information
    that's provided by the snapshots might not be enough, Cypress provides an additional
    step so that you can view the information of a specific step and its impact on
    elements. To view the console debug output, we will need to open our DevTools.
    To open the DevTools console of our Cypress test browsers, we need to follow certain
    steps, all of which will be discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To open the **DevTools** console of your Cypress test browser on macOS, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Hold the trackpad down with two fingers while on the Cypress test browser preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Inspect** option from the pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Console** tab from the **DevTools** console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also use the *Option* + *J* shortcut to open the **DevTools** menu on
    Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Windows/Linux OS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To open the **DevTools** console of your Cypress test browser on Windows and
    Linux OS, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the Cypress test browser while on the Cypress test preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Inspect** option from the browser pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Console** tab from the **DevTools** console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also open it using the *Shift* + *Ctrl* + *J* shortcut on either Windows
    operating systems or Linux to open the **DevTools** console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you can see the console output, select a test step, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The debug output on a browser console'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.6_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The debug output on a browser console
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the output of the selected Cypress command on
    Command Prompt. As we can see, when a specific command step is clicked, the DOM
    snapshot is pinned to the Cypress browser's preview screen. Pinning the DOM snapshot
    allows us to interact with the elements on the pinned snapshot uninterrupted.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we selected the `get` method and the first todo
    item, which can be identified by the `.todo-list>li:nth-child(1)` CSS selector.
    We can also see that the Cypress `get` method finds the CSS selector for the first
    todo item and toggles it to completed. Looking through the console debug information,
    we can see the additional information that Cypress printed on the console that
    is related to the action step and is now pinned to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Console** area, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: This is the command that we issued. In our case, it was a `cy.get()`
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yielded**: This prints the statement that was returned by the command that
    was invoked. In our case, it will print out the same as what the input was. This
    is because we are not changing the state of the element with our command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elements**: This prints the elements that were returned from our `get` command.
    In our case, we only have one element that was found by using our CSS selector.
    However, if we had more than one element, we would be able to see the elements
    that were found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selector**: This refers to the CSS selector that we used to identify our
    todo item in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The information that's displayed on the console can change due to the different
    commands that are issued and inspected. This is not standard for all the Cypress
    commands that are inspected on the console log.
  prefs: []
  type: TYPE_NORMAL
- en: Using this debugging information and combining it with debug information from
    the methods we covered earlier will give you an idea of which Cypress tests are
    failing and why. In most cases, you only need to learn how to read the common
    Cypress errors to understand how the errors are thrown and why those errors appear.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding the console debug output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how to utilize the console debug output in Cypress
    to understand application state changes. We also learned how to open and access
    the console information and interact with it. In the next section, we will learn
    how to utilize Cypress' special debugging commands.
  prefs: []
  type: TYPE_NORMAL
- en: Special debugging commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If jumping through commands is not your thing, or you are finding it difficult
    to understand how travelling back in time shows you the order of execution in
    a test, Cypress has got your back. Cypress includes commands that are helpful
    for debugging and even gives you the options that you would have when using normal
    code debuggers. The two commands that we will be exploring in this section are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cy.debug()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cy.pause()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these Cypress debug commands, we can understand how to debug Cypress from
    the tests themselves. These two special debugging commands will allow us to directly
    control the debug process as we execute our tests. Having the ability to stop
    execution within the tests themselves gives us the advantage of only having to
    debug the specific sections that are throwing errors in Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: cy.debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cy.debug()` command is, by default, the debugging command that Cypress
    offers out of the box. The command will log onto the console and will log the
    output of the command that it has chained off. To use the `cy.debug`() command,
    you need to chain it from any `cy` command or use it as a standalone Cypress command.
    In our context, we will be using the command by chaining it from the `cy.get()`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: This command pauses the execution of the test when it is called, and also displays
    the option of systematically stepping forward from a command and pausing the debugger
    from the current execution step. In reality, the debugger allows us to execute
    the test at our desired speed while inspecting what happens when a step is executed.
    In addition to the debugger interface, this Cypress command also displays verbose
    on the console output and displays information such as the command name, the type
    of command, and even the subject that we have chained our debugger from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added both of our todo items and inspected both the console
    log and the Cypress test runner preview pane, we can add the debugger. The following
    code block shows a test that marks a todo item as complete. However, instead of
    executing the whole test, we will open the debugger after adding the second todo
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we want to check the state of our application
    after the second todo item has been added. The following screenshot shows an open
    debugger after the second todo item was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The debugger of a running test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.7_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – The debugger of a running test
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the debugger pauses our running test after the second todo item
    is added. Here, we can observe that we can interact with the application and inspect
    elements at our own pace once the debugger has paused our running test. With the
    debugger in place, we can see the application state changes, along with additional
    debug information, displayed on the console output. Once we've finished inspecting
    the state, we can either remove the `.debug()` command or place it in another
    line that we wish to inspect.
  prefs: []
  type: TYPE_NORMAL
- en: cy.pause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Cypress `pause` command works very similar to the `cy.debug()` command
    but instead of being chained to other commands, it can be used independently,
    just like a debugger. When the `pause` command is used, Cypress slows its execution
    and only executes the next step when the forward button is clicked. Just like
    the debugger, the Cypress `pause` command gives control to the person executing
    the tests and allows them to investigate every test step. The following code block
    shows a test that marks a todo item as completed. However, before execution is
    complete, we pause the test after adding the first todo item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added a single todo item and then paused the execution before
    marking it as completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The pause menu of a running test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.8_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – The pause menu of a running test
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, immediately after adding our todo item, execution is halted until
    we press the **step-forward** button in the **pause** menu. This appears on the
    top part of the test commands section. When all the steps have been executed,
    the test will exit and either pass or fail, depending on the output of the steps
    that were executed. In our case, we have a passing test – hurray!
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Cypress special debugging commands should only be used when we are investigating
    the state of the tests that are running or for debugging purposes. They should
    not be used in tests that are running in **continuous integration** (**CI**) as
    they might lead to timeouts and, subsequently, test failures.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – special debugging commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about the Cypress special commands that can be used
    to provide additional debugging information. We learned that both the Cypress
    `debug` and `pause` commands come in handy when we want to slow down the execution
    of a test. We also learned that debug commands can be used as complementary tools
    for the Cypress tools that are provided by the test runner, such as DOM snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the role of debugging when it comes to executing
    tests. We identified aspects of the Cypress framework that make the debugging
    process in Cypress useful for anyone writing tests and implementing the Cypress
    framework. We also learned that Cypress is bundled with different tools that can
    be used either to achieve different purposes or the same ones. The main takeaway
    is that no matter what bug you encounter, Cypress will find a way for you to identify
    and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, you have learned what page events are in Cypress,
    how to interpret Cypress test runner errors, how time travel works in executed
    tests, and how to interpret test snapshots. You also learned how to interpret
    console output information from Cypress and how to use the two special debugging
    commands that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about debugging and its impact on our tests, we can comfortably
    dive into the second section of this book, which will involve using Cypress with
    a **test-driven development** (**TDD**) approach. In the next chapter, we will
    develop an application by using a test-first approach, where we will write our
    tests before we begin developing our application. We will use these tests later
    on to guide us through the process of application development.
  prefs: []
  type: TYPE_NORMAL
