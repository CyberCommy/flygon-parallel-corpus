- en: Object Collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in earlier chapters, OOP is all about objects, which are the main
    focus of this programming methodology. When we design our software using this
    methodology, we will keep the concepts of OOP in mind. We will also try to break
    our software components into smaller objects and create proper relationships between
    the objects so that all of them can work together to give us our desired output.
    This relationship between objects is called **object collaboration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is object collaboration?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is dependency collaboration?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is association?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is inheritance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of object collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object collaboration is one of the most important topics in OOP. If the objects
    don't collaborate with each other in a program, nothing can be achieved. For example,
    if we think about a simple web application, we can see how the relationship between
    different objects plays an important role in constructing the application. Twitter,
    for example, has many objects that are related to each other in order to make
    the application work. The `User` object consists of the username, password, first
    name, last name, picture, and other user-related information belonging to Twitter
    users. There could be another object called `Tweet` that consists of a message,
    date and time, the username of the user who posted the tweet, and some other properties.
    There may also be another object called `Message` that holds the content of the message,
    who it was from, who it was sent to, and the date and time. This is the simplest
    breakdown possible for a big application like Twitter; it almost certainly contains
    many other objects. But for now, let's just think about these three objects and
    try to find a relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will look at the `User` object. This is one of the most important
    objects in Twitter, as it holds the user information. Everything in Twitter is
    either made or performed *by* a user or *for* a user, so we can assume that there
    should be some other objects that will need to have a relationship with this `User`
    object. Now let's try to see whether the `Tweet` object has any relationship with
    the `User` object or not. A tweet is a message that should be available for all
    users to see if the `Tweet` object is public. If it is private, only that user's
    followers will see it. As we can see, a `Tweet` object has a very strong relationship
    with a `User` object. So, with the OOP approach, we can say that the `User` object
    has a collaboration with the `Tweet` object in the Twitter application.
  prefs: []
  type: TYPE_NORMAL
- en: If we also try to analyze the relationship between `User` and `Message` objects,
    we will see that the `Message` object also has a very strong relationship with
    the `User` object. A message is sent by a user to another user; therefore, without
    a user, the `Message` object has no proper implementation.
  prefs: []
  type: TYPE_NORMAL
- en: But is there any relationship between the `Tweet` and `Message` objects? From
    what has been said, we can say that there is no relationship between these two
    objects. It's not necessary for every object to be related to all other objects,
    but an object usually has a relationship with at least one other object. Now let's
    see what different types of object collaborations are available in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of object collaboration in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways an object can collaborate with other objects in programming.
    However, in this chapter, we will only talk about the three most important collaboration
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: We will first try to explain each of these types, looking at some examples to
    help us to understand them. If you can't relate these concepts to your work, it
    might be a little hard for you to understand the importance of object collaboration,
    but trust me, these concepts are very important on your path to becoming a good
    software developer.
  prefs: []
  type: TYPE_NORMAL
- en: All these concepts and terms will come in handy when you have discussions about software
    design with other people, or even when you design your own software. As a consequence,
    my suggestion would be to focus on understanding the concepts and relate them
    to your work in order to reap the benefits of this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the three collaboration types that we are going to be talking
    about in this chapter, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's think of an imaginary application and try to relate these collaboration
    concepts to the objects of this application. Learning is easier and more interesting
    when you can relate concepts to the real world, so this is the approach we will
    take in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the main goal of this chapter is to learn about the concepts involved
    in object collaboration rather than design a fully fledged, super-duper application,
    we will design our objects in a simple and minimal manner.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we are going to develop some restaurant management software.
    This could be for a luxury restaurant, or a small cafe where people come to drink
    coffee and relax. In our case, we are thinking of a restaurant with mid-range
    pricing. To begin building this application, let's think about what classes and
    objects we need. We will be needing a `Food` class, a `Chef` class, a `Waiter`
    class, and maybe a `Beverage` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done reading this chapter, don''t jump straight into the next
    chapter. Instead, spend some time thinking about some of the objects that aren''t
    mentioned in this chapter and try to analyze the relationships between the objects
    you have thought about. This will help you to develop your knowledge of the concept
    of object collaboration. Remember: software development is not a typing job, it
    requires heavy brain work. Consequently, the more you think about the concepts,
    the better at software developing you will become.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what objects I came up with when I did some thinking about
    the objects that should be included in our imaginary restaurant application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Food`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Beef Burger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pasta`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Beverage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cola`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Coffee`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Order`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Staff`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chef`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Waiter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FoodRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeverageRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StaffRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these objects might not make much sense to you right now. For example,
    the `FoodRepository`, `BeverageRepository`, and `StaffRepository` objects are
    not actually business objects, but are helper objects that help different modules
    to interact with each other in the application. The `FoodRepository` object, for
    example, will be used to save and retrieve `Food` objects from the database and
    the UI. Similarly, the `BeverageRepository` object will deal with beverages. We
    also have a class called `Food` that is a general type of class, as well as more
    specific food objects such as `Beef Burger` and `Pasta`. These objects are subcategories
    of the `Food` object. As software developers, we have identified the objects that
    are needed to develop this software. Now, it's time to use these objects in a
    way that solves the problem that the software will be used for; however, before
    we start writing code, we need to understand and figure out how the objects can
    relate to each other so that the application is the best that it can be. Let's
    start with the dependency relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object uses another unrelated object to carry out a task, the relationship
    between them is called a **dependency**. In the software world, we also refer
    to this relationship as **uses a** **relation**. Now, let's see if any kind of
    dependency relationship exists between the objects that we have thought about
    for our restaurant application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we analyze our `FoodRepository` object, which will be saving and retrieving
    `Food` objects from the database and passing them to the UI, we can say that the
    `FoodRepository` object has to use the `Food` object. This means that the relationship
    between the `Food` and `FoodRepository` object is a type of dependency relationship.
    If we think about the flow in the frontend when a new `Food` objects is created,
    that object will be passed to the `FoodRepository`. The `FoodRepository` will
    then serialize the `Food` object to database data in order to save it in the database.
    If the `FoodRepository` doesn''t use the `Food` object, then how would it know
    what to serialize and store in the database? Here, the `FoodRepository` must have a dependency
    relationship with the `Food` object. Let''s look at the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that the `FoodRepository` class has two methods.
    One method is `SaveFood` and the other is `GetFood`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SaveFood` method involves taking one `Food` object and saving it in the
    database. After saving the food item in the database, it returns the newly created
    `foodId` back to the `FoodRepository`. The `FoodRepository` then passes the newly
    created `FoodId` to the UI to inform the user that the food item creation was
    successful. On the other hand, the other `GetFood` method takes an ID as parameter
    from the UI and checks whether or not the ID is a valid input. If it is, the `FoodRepository` passes
    the `FoodId` to the `databasehandler` object, which searches the food in the database
    and maps it back as a `Food` object. After this, the `Food` object is returned
    to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the `FoodRepository` object needs to use the `Food` object
    to do its work. This type of relationship is called a **dependency relationship**.
    We can also use the *uses a* phrase to identify this relationship. The `FoodRepository`
    uses a `Food` object to save food in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `FoodRepository`, the `BeverageRepository` does the same thing for a `Beverage`
    object: it saves and retrieves beverage objects in the database and UI. Now let''s
    see what the `BeverageRepository` looks like as code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the preceding code, you will see that the `BeverageRepository`
    has two methods: `SaveBeverage` and `GetBeverage`. Both of these methods use the
    `Beverage` object. This means that the `BeverageRepository` has a dependency relationship
    with a `Beverage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the two classes we have created so far, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One object can be related to multiple objects using a dependency relationship.
    In OOP, this type of relationship is very common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example of dependency relationships. A relationship
    between a `Programmer` and a `Computer` could be a dependency relationship. How?
    Well, we know that a `Programmer` is most likely a human and a `Computer` is a
    machine. A `Programmer` uses a `Computer` to write computer programs, but the
    `Computer` is not a property of the `Programmer`. A `Programmer` *uses a* computer,
    and this doesn''t have to be one specific computer—it can be any computer. So
    can we say that a relationship between a `Programmer` and a `Computer` is a type
    of dependency relationship? Yes, we surely can. Let''s see how we can represent
    this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can clearly see how a `Programmer` and a `Computer` have
    a dependency relationship, however, this is not always the case: it depends on
    how you design your objects. If you have designed your `Programmer` class in such
    a way that each programmer has to have a dedicated computer, you could have used
    `Computer` as a property in the `Programmer` class, and then the relationship
    between the programmer and the computer would have changed. Consequently, the
    relationship depends on how the objects are designed.'
  prefs: []
  type: TYPE_NORMAL
- en: My main goal in this section was to clarify the dependency relationship. I hope
    the nature of dependency relationships is now clear to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how the dependency relationship is drawn in a **Unified Modeling
    Language** (**UML**) diagram, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ad50b5f-04ab-4fb3-829c-3e23eef738c8.png)'
  prefs: []
  type: TYPE_IMG
- en: A solid line is used to represent a dependency relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another type of relationship is the association relationship. This type of relationship
    is unlike the dependency relationship. In this type of relationship, one object
    knows another object and is associated with it. This relationship is achieved
    by having one object as a property of another object. In the software community,
    this relationship type is also referred to as a *has a* relationship. For example,
    a car has an engine. If you think of any objects that you can relate to each other
    using the phrase *has a*, then that relationship is an association relationship.
    In our car example, the engine is a part of the car. Without an engine, the car
    can't carry out any functions. While the engine itself is a separate object, it
    is part of the car, and therefore there is an association between the car and
    the engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This association relationship can be divided into the following two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see what these two types of relationship are and how they differ from
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When one object has another object in it as a property and this other object
    is independent, this is called an **aggregation relationship**. Let's take the
    example in the previous section and try to see whether this was an aggregation relationship
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example looked at the relationship between a car and an engine.
    We all know that a car must have an engine, and that is why an engine is the property
    of a car, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the question is, what is this type of relationship? The deciding factor
    is that an engine is a separate object that functions independently of a car. When
    the manufacturer creates an engine, they don''t make it when they are creating
    the other parts of the car: they can create it separately. Even without a car,
    an engine can be tested or even used for another purpose. Consequently, we can
    say that the type of relationship that the car has with the engine is an *aggregation
    relationship*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the example of our restaurant management software. If we
    analyze the relationship between the `Food` and `Chef` objects, it is clear that
    no food can exist without a chef. Someone has to cook, bake, and prepare the food,
    the food cannot do this itself. Consequently, we can say that the food has a chef.
    This means that the `Food` object should have a property named `Chef`, which will
    hold the `Chef` object of that `Food`. Let''s look at the code for this relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we think about the `Beverage` object, every beverage must have a company
    or maker. For example, commercial beverages are made by companies such as Pepsi
    Co., Coca Cola Company, and so on. The beverages that these companies produce
    are their legal property. Beverages can also be made locally, in which case the
    company name would be the name of the local shop. However, the main idea here
    is that a beverage must have a manufacturer company. Let''s see how the `Beverage`
    class would look in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In both of these examples, the `Chef` and `Manufacturer` objects are objects
    that are used as the property of `Food` and `Beverage` respectively. We also know
    that a `Chef` or a `Manufacturer` company is independent. Consequently, the relationship
    between `Food` and `Chef` is an aggregation relationship. This is also the case
    for `Beverage` and `Manufacturer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things clearer, let''s look at another example of aggregation. Our
    computer that we use for programming or for any other task is made up of different
    components. We have a motherboard, RAM, CPU, graphics card, screen, keyboard,
    mouse, and many other things. Some components have an aggregation relationship
    with the computer. For example, the motherboard, RAM, and CPU are internal components
    that are needed to build a computer. All of these components can exist independently
    of the computer, and consequently, all of these have aggregation relationships
    with the computer. Let''s look at how the `Computer` class is related to the `MotherBoard`
    class in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how the aggregation relationship is drawn in a UML diagram.
    If we try to display the preceding computer class aggregation relationship with
    the RAM, CPU, and motherboard, then it would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0467b14-4fd0-4131-a993-b34defc2694b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A solid line and a diamond are used to represent an aggregation relationship.
    The diamond is placed at the side of the class that holds the property, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1c0dbc5-417b-4e68-86b3-c2d464f80da0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A composition relationship is a type of association relationship. This means
    that one object will have another object as its property, but where it differs
    from aggregation is that, in composition, the object that is used as a property
    can't exist independently; it must have the help of another object in order to
    be functional. If we think about the `Chef` and `Manufacturer` classes, the existence
    of these classes is not fully dependent on the `Food` and `Beverage` classes.
    Instead, these classes can exist independently, and therefore have an aggregation
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we think about the relationship between the `Order` and `OrderItem`
    objects, we can see that the `OrderItem` object has no meaning without `Order`.
    Let''s look at the following code of the `Order` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `Order` object has a list of `OrderItems` in it. These
    `OrderItems` are the `Food` items that the customer has ordered. A customer can
    order one dish or multiple dishes, which is why the `OrderItems` is a list type.
    So now it's time to justify our thinking. Does an `OrderItem` really have a composition
    relationship with `Order`? Are we making any mistakes here? Are we thinking about
    an aggregation relationship as a composition relationship?
  prefs: []
  type: TYPE_NORMAL
- en: To identify which type of association relationship it is, we have to ask ourselves
    some questions. Can `OrderItem` exist without `Order`? If not, then why not? It's
    a separate object! However, if you think a little more deeply, you will realize
    that no `OrderItem` can exist without an `Order`, as a customer has to order an
    item, and without an `Order` object, the `OrderItem` object is not trackable.
    The `OrderItem` item cannot be served to any customer as there is no data for
    which customer the `OrderItem` is for. Consequently, we can say that the `OrderItem`
    has a composition relationship with the `Order` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example of composition. In our schooling system, we
    have students, teachers, subjects, and grades, right? Now, I would say that the
    relationship between a `Subject` object and a `Grade` object is a composition
    relationship. Let me justify my answer. Take a look at the following code of these
    two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `Grade` object holds the mark that a student has scored
    on a test for a particular subject. It also holds the `GradeSymbol`, such as `A`,
    `B`, or `F`, depending on the marking rules of that school. We can see in the
    `Subject` class that there is a property called `Grade`. This holds the grade
    for that particular `Subject` object. If we just think about `Grade` individually
    rather than in association with the `Subject` class, we will get a bit confused
    and wonder what subject the grade is for.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the relationship between `Grade` and `Subject` is a composition
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can show a composition relationship in a UML diagram using
    the preceding example of `Subject` and `Grade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21c4e007-c706-470e-9cb2-be5c87ffceae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A solid line and a black diamond are used to represent a composition relationship.
    The diamond is placed at the side of the class that holds the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44e0de3f-109f-439e-a5a6-c1b9c0288418.png)'
  prefs: []
  type: TYPE_IMG
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of the four pillars of OOP. **Inheritance** is when one object
    inherits or reuses another object''s properties or methods. The class that gets
    inherited is called the **base class** and the class that inherits the base class
    is normally called the **derived class**. The inheritance relationship can be
    treated as an *is a relationship*. For example, pasta is a `Food`. The `Pasta`
    object has a unique ID in the database, which has other properties such as name,
    price, and chef. So, as `Pasta` satisfies all the attributes of the `Food` class,
    it can inherit the `Food` class and use the properties of the `Food` class. Let''s
    look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The case is the same for beverages. For example, `Coffee` is a type of beverage
    that has all the attributes that the `Beverage` object has. A coffee has a name
    and price, and it might have sugar, milk, and coffee beans. Let''s write the `Coffee`
    class and see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So here, we can say that `Coffee` is inheriting the `Beverage` class. Here, `Coffee`
    is the derived class and `Beverage` is the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an earlier example, we used the `Programmer` object. In that case, do you
    think that the `Programmer` class can actually inherit the `Human` class? Yes,
    for sure. A programmer is nobody other than a human in this example. If we look
    at the properties of a `Programmer` and the properties of a `Human`, we will find
    that there are some common properties, such as the name, age, and so on. Consequently,
    we can modify the code of the `Programmer` class to resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how we can draw a UML diagram for our `Programmer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3db18b8b-3f8e-460b-bf50-c4bd42c833d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inheritance is represented by a solid line with a triangle sign attached to
    it. This triangle points in the direction of the super class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f549a7f4-2baa-4c24-865b-5fcfdc37d65d.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object collaboration types that we looked at in this chapter are the most
    commonly used types in C#. When designing an application or architecting some
    software, object collaboration is very important. It will define how flexible
    the software is, how many new functions can be added, and how easy it will be
    to maintain the code. Object collaboration is very important.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about exception handling. This is another
    very important part of programming.
  prefs: []
  type: TYPE_NORMAL
