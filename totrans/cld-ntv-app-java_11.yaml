- en: Platform Deployment – Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses application design and deployment for Azure—a Microsoft
    public cloud platform. The essence of cloud-native development is the ability
    to integrate your application with PaaS platforms provided by the cloud provider.
    You, as a developer, focus on creating value (solving customer problems), and
    allow the cloud provider to do the heavy lifting for your application's infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Different categories of PaaS services provided by Azure. We will delve a little
    deeper into services that will be used by our sample applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrate our sample application to Azure and understand the various options available.
    We will also evaluate all the options and understand the pros and cons for each
    option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are covering the Azure platform with the intention of showing how to build
    and deploy applications. We are not going to cover Azure in depth, and we expect
    the reader to use the Azure documentation ([https://docs.microsoft.com/en-us/azure/](https://docs.microsoft.com/en-us/azure/))
    to explore additional options.
  prefs: []
  type: TYPE_NORMAL
- en: Azure supports multiple programming languages, but for the purpose of this book
    we are looking at support for Java applications in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Azure platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure provides an ever-increasing set of PaaS and IaaS across a spectrum of
    technology areas. For our purpose, we will look at the subset of areas and services
    that are directly applicable and used by our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For ease of use, I have created this service categorization model across technology
    areas that are most relevant to typical business applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0be37779-2ac3-4fe6-b8b0-0177c19149f4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*This is just an indicative list and by no means an exhaustive list. Refer
    to the Azure portal for a complete list.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding categorization models, we have divided the services into the
    following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure**: This is an all-encompassing list of services provided by
    Azure to deploy and host our applications. We have combined services across compute,
    storage, and networking in this category. We will be looking at the following
    set of services for the purpose of our sample Java applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Services**: How can we take the existing Spring Boot applications and
    deploy them in our Azure platform? This is more of a lift and shift scenario.
    Here the application is not refactored, but the dependencies are deployed on App
    Services. Using one of the database services, the application can be deployed
    and hosted. Azure provides PostgreSQL and MySQL as hosted database models among
    a variety of other options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Services**: For applications packaged as Docker containers, we
    can explore how to deploy Docker containers to the platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: This is the serverless platform model, where you need not worry
    about application hosting and deployment. You create a function and let the platform
    do the heavy lifting for you. As of now, Java-based Azure cloud functions are
    in beta. We will explore how to create one in a development environment and test
    locally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Fabric**: Service Fabric is a distributed systems platform for deploying
    and managing microservices and container applications. We will explore how we
    can deploy our sample `product` API in Service Fabric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: This is a list of services that help build distributed applications.
    As we move to a distributed microservices model, we need to decouple our application
    component and services. Features such as Queue, EventHub, EventGrid, and API management
    help build a cohesive set of robust APIs and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: This is a list of data store options provided by the Azure platform.
    This includes relational, key value, redis cache, and data warehouse among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps**: For building and deploying applications in the cloud, we need the
    support of robust CI/CD toolsets. Visual Studio team services are provided for
    hosting code, issue tracking, and automated builds. Again, open source tools are
    still not first-class citizens in the Azure portal. You can always use hosted
    versions of the required software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Another key factor for cloud applications are security services.
    Active directory, rights management, key vault, and multi-factor authentication
    are some of the key services provided in this area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile**: If you are building mobile applications, the platform provides
    key services such as application services for mobile, media services, and mobile
    engagement services, among others in this area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**: In the area of analytics, the platform provides robust services
    in the areas of MapReduce, Storm, Spark through HDInsight and Data Lake services
    for analytics and a data repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there are multiple other technology areas where Azure provides
    services—**internet of things** (**IoT**), monitoring, management, **artificial
    intelligence** (**AI**), and cognitive and enterprise integration areas.
  prefs: []
  type: TYPE_NORMAL
- en: Azure platform deployment options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, Azure provides a number of options to build
    and deploy applications on the platform. We will use our example of the `product`
    API REST service to examine the various options provided by Azure to deploy and
    run our application.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, I am assuming you are familiar with the Azure platform and
    have already signed up in the portal.
  prefs: []
  type: TYPE_NORMAL
- en: Azure supports multiple programming languages and provides SDKs to support development
    in the respective areas. For our purpose, we are primarily exploring support for
    Java applications within the Azure platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore application hosting services in the following four areas:'
  prefs: []
  type: TYPE_NORMAL
- en: App Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service Fabric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the following link for more details and getting started: [https://azure.microsoft.com/en-in/downloads/](https://azure.microsoft.com/en-in/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Spring Boot API to Azure App Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are taking our `product` API service and migrating it to
    an Azure App Service. We will look at the additional changes made to the application
    to adhere to the requirements of the Azure App Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have taken the `product` API REST service that we built in [Chapter 3](dba50b25-08ed-48b1-9d28-6f0faff42ecb.xhtml),
    *Designing Your Cloud-Native Application*. In the service, we make the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file `web.config` in the root folder of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The file is added with the following change, `product-0.0.1-SNAPSHOT.jar`, which
    is the package name of our application. In case your application name differs,
    you will need to make that change.
  prefs: []
  type: TYPE_NORMAL
- en: We start with checking out the `product` API code here: [https://azure.microsoft.com/en-in/downloads/](https://azure.microsoft.com/en-in/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/698bfbdf-e24d-4703-83cb-1b21d38d35d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We run the `mvn clean package` command to package the project as a fat JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we log in to the Azure portal ([https://portal.azure.com/](https://portal.azure.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the App Services menu item in the left-hand column as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c64f4a0-c9ab-449a-b532-60689a27ebee.png)'
  prefs: []
  type: TYPE_IMG
- en: Select App Services in Azure portal
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Add link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e6202b0e-c4fd-4cfa-a12d-ee7ccaea74c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click on the Web App link as indicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57ceb8b3-0323-43aa-a803-952ff68d76b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Select Web App by navigating through Azure Portal | App Services | Add.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Create button link and you should see the following page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96ccf874-4146-47f3-a6ab-61dea5d877f9.png)'
  prefs: []
  type: TYPE_IMG
- en: We fill in the details for our `product` API. I have filled in App name as `ch10product`
    and left the other options at the default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click the Create button at the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/528a954f-768a-4c27-b9bf-621c7a73c88a.png)'
  prefs: []
  type: TYPE_IMG
- en: This leads to the creation of the App Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We click on the `ch10product` under App Services, which takes us to the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b09eccf-5511-4d37-afbc-0dccd115d72d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the URL and the FTP hostname where the application is deployed. We need
    to make changes in two places—Application settings and Deployment credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ee26222-3971-4748-9a66-eb98829c466e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We click on the Application settings link and select the following options
    in the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Java 8 for the Java version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Newest for the Java Minor version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Newest Tomcat 9.0 for the Web container(This container will not actually
    be used; Azure uses the container bundled as part of the Spring Boot application.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Save
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f3d3759-f319-4833-8895-7cb58e3e9f81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we click on the Deployment credentials link on the left-hand side. Here
    we capture the FTP/deployment username and Password in order to be able to push
    our application to the host and click on Save as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58881a11-bdbb-4016-af39-bc577133c1e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect to the FTP hostname we saw in *Step 8* and use your credentials saved
    in *Step 10* to log in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we change directory to `site/wwwroot` on the remote server and transfer
    the fat JAR and `web.config` to the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We go back to the overview section and restart the application. We should be
    able to start the application and see our REST API working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e713d0dd-11a7-45b5-8ed9-c05e45d445be.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we saw how to take an existing REST API application and deploy
    it in Azure. It is not the easiest and best way to deploy. This option is more
    of a lift and shift, where we take existing applications and try to move the workloads
    to the cloud. For deploying web applications, Azure provides a Maven plugin that
    can push your application directly to the cloud. Refer to the following link for
    more details: [https://docs.microsoft.com/en-in/java/azure/spring-framework/deploy-spring-boot-java-app-with-maven-plugin](https://docs.microsoft.com/en-in/java/azure/spring-framework/deploy-spring-boot-java-app-with-maven-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: The REST API is deployed on a Windows Server VM. Azure is adding support for
    Java applications, but their forte remains .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make use of Linux and deploy your REST API applications, you
    have the option of using Docker-based deployments. We will cover Docker-based
    deployment in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Docker containers to Azure Container Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s deploy our Docker container applications. I have created Docker images
    for the `product` API example used in the previous section. The Docker image can
    be pulled from the Docker hub through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started and log into the Azure portal. We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the App Services menu item in the left-hand column. We should see
    the following screen. Click on New as indicated in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddabfc10-2db1-410f-b43b-25921443cd22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under New search for `Web App for Containers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22d28f9f-ef11-48b2-864d-19bb66be4724.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the Web App for Containers is selected, click on Create as indicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72ab0c88-bdfe-4b2c-9cf0-f4f6a8e158ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Select Create by navigating through App Services | Add | Web App
  prefs: []
  type: TYPE_NORMAL
- en: 'We will fill in the details for our `product` API container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have filled in the App Name and Resource Group as `ch10productContainer` and
    left the other options at the default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Configure container section, we select the container repository. If there
    is already a Docker image in Docker hub, provide the image pull tag, `cloudnativejava/ch10productapi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK at the bottom of the page. It validates the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we click Create at the bottom of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6112a303-5635-4575-91b3-cad71f75e9b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Select Create by navigating through Azure portal | New | search for `Web App
    for Containers`
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the creation of the App Service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e41b4f7-c4cf-400e-ae94-2a12bdd29694.png)'
  prefs: []
  type: TYPE_IMG
- en: Select Newly created app container by navigating through Azure portal | App
    Services
  prefs: []
  type: TYPE_NORMAL
- en: We click on `ch10productcontainer` under App Services, which takes us to the
    menu where we can see the marked URL, `https://ch10productcontainer.azurewebsites.net`, where
    the container is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94c17e67-6c28-4522-be1d-2fd4c65f88d9.png)'
  prefs: []
  type: TYPE_IMG
- en: The URL where the host docker application can be accessed
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see our `product` API running in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b933045b-f5a6-4d37-8d26-f7c24d7e92e4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an easy way to deploy your application to the cloud platform. In both
    the previous scenarios we have not used any of the specialized applications or
    data store services. For a true cloud-native application, we need to make use
    of the platform services provided by the provider. The whole idea is that the
    heavy lifting in terms of application scalability and availability is handled
    by the native platform. We, as developers, focus on building the key business
    functionality and integration with other components.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Spring Boot API to Azure Service Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and deploying applications to the underlying IaaS platform is how most
    organizations start working with public cloud providers. As the level of comfort
    and maturity of cloud processes increases, the application starts getting built
    with PaaS features. So, applications start consisting of queuing, eventing, hosted
    data stores, security, and other features of the platform services.
  prefs: []
  type: TYPE_NORMAL
- en: But a key question remains with regards to non-functional requirements. Who
    will think of the abilities of the application?
  prefs: []
  type: TYPE_NORMAL
- en: How do I make sure there are enough application instances running?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when an instance goes down?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the application scale up/down depending on the incoming traffic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we monitor all the running instances?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we manage distributed stateful services?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we perform rolling upgrades to the deployed services?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In comes the orchestration engines. Products such as Kubernetes, Mesos, and
    the Docker swarm provide the ability to manage the application containers. Azure
    has released Service Fabric, which is application/container management software
    for your application. It can be run on-premises or in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service Fabric provides the following key functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to deploy applications that can scale massively and provide a self-healing
    platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to install/deploy both stateful and stateless microservice-based
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides dashboards to monitor and diagnose the health of applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines policies for automatic repair and upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the current version, Service Fabric supports two underlying operating systems—flavors
    of Windows Server and Ubuntu 16.04 only. Your best bet is a Windows Server cluster,
    as the support, tooling, and documentation is the best.
  prefs: []
  type: TYPE_NORMAL
- en: For demoing the features and usage of the Service Fabric, I will make use of
    an Ubuntu image for local testing, and Service Fabric party cluster for online
    deployment of our `product` API example in the Service Fabric cluster. We will
    also examine how to scale the application instances, and self-healing features
    of the Service Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Basic environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the environment, I am using a macOS machine. We need to set up the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Local Service Fabric cluster setup—pull a Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the Docker daemon configuration on your host with the following additional
    settings and restart the Docker daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Docker image pulled down from Docker hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following commands within the container shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After the last step is complete, a development Service Fabric cluster is started
    that can be accessed at `http://localhost:19080` from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to set up Yeoman generators for containers and guest executables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure Node.js and **Node Package Manager** (**NPM**)
    are installed. The software can be installed by using HomeBrew, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we install the Yeoman template generator from NPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we install the Yeoman generator that will be used to create Service Fabric
    applications by using Yeoman. Follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a Service Fabric Java application on macOS, JDK version 1.8, and Gradle,
    the software must be installed on the host machine. The software can be installed
    by using Homebrew, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That completes the environment setup. Next, we will package our `product` API
    application as a Service Fabric application to enable deployment in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the product API application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We log into the `product` API project (full code available at: [https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java))
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c73b090b-cac7-4dc8-97cf-82ac59cb3602.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We enter the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d4da0c7-148a-496c-b4c4-5ee8fa099559.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create an application package with a set of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we go to the `/ProductServiceFabric/ProductServiceFabric/ProductAPIPkg`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory `code` and in it, create a file called `entryPoint.sh` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also, make sure we copy our packaged JAR (`product-0.0.1-SNAPSHOT.jar`) in this
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `Number of instances of guest binary` should be `1` for local environment
    developments and can be a higher number for Service Fabric clusters in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will host our application in the Service Fabric cluster. We will make
    use of the Service Fabric party cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Service Fabric cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will log into [http://try.servicefabric.azure.com](https://try.servicefabric.azure.com/)
    using our Facebook or GitHub ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/762646ef-8399-4f28-bdfc-49974a7a83d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Join a Linux cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af50ebad-5369-40ef-8aa6-ff410a3c9442.png)'
  prefs: []
  type: TYPE_IMG
- en: We will be directed to the page with the cluster details. The cluster is available
    for one hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are certain ports that are open. When we deploy our `product`
    API application, we can access the same on port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35514f7b-5a6a-4802-9d95-b424e11c1b36.png)'
  prefs: []
  type: TYPE_IMG
- en: The Service Fabric cluster explorer is available at the previously mentioned
    URL. Since the cluster uses certificate-based authentication, you will need to
    import the PFX file to your keychain.
  prefs: []
  type: TYPE_NORMAL
- en: If you visit the URL, you can see the Service Fabric cluster explorer. The cluster,
    by default, comes up with three nodes. You can deploy multiple applications to
    the cluster. Based on the application settings, the cluster will manage your application
    availability.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f2fbfc-96ce-4174-8c61-ad8d59454d50.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure Party Cluster default view
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the product API application to the Service Fabric cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For deploying our application to the cluster, we need to log into the `ProductServiceFabric`
    folder for the Service Fabric scaffolding created for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the local cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can connect to the local cluster here by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will connect with the Service Fabric cluster running within the Docker
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Service Fabric party cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Service Fabric party cluster uses certificate-based authentication,
    we need to download the PFX file in our working folder in `/ProductServiceFabric`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we make use of the **Privacy Enhanced Mail** (**PEM**) file to connect
    to the Service Fabric party cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are connected to the Service Fabric cluster, we need to install our
    application by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see our application getting uploaded and deployed in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fbdad95-5b1d-4667-903d-c8739bc29670.png)'
  prefs: []
  type: TYPE_IMG
- en: Install and start the Service Fabric Cluster within Docker container
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application is uploaded, we can see the application in the Service
    Fabric explorer and the functionality of the application can be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c70ae23-b56c-4978-a32f-19a49107ff02.png)'
  prefs: []
  type: TYPE_IMG
- en: Observe the application deployed in the Azure Party Cluster
  prefs: []
  type: TYPE_NORMAL
- en: The API functionality is available at: `http://zlnxyngsvzoe.westus.cloudapp.azure.com:8080/product/2`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e6a7184-3987-4437-a48d-e06478a47f92.png)'
  prefs: []
  type: TYPE_IMG
- en: Verify if the API is working
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how the application is deployed on one node (`_lnxvm_2`) currently.
    If we bring down that node, the application instance is automatically deployed
    on another node instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75c02b81-c7ec-4d6d-b0e6-d8f13f672cf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Observe the application deployed on single node out of the available three hosts
  prefs: []
  type: TYPE_NORMAL
- en: 'Bring down the node (`_lnxvm_2`) by selecting the option in the node menu (highlighted
    in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a64c641-6097-46c4-9b4f-e070cbce95a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Observe the options available to disable application on the host in the Azure
    Party Cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately, we can see the application getting deployed on node `_lnxvm_0`
    as a self-healing model of the Cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89ca78f9-b18d-40fb-b61f-8d350178b27f.png)'
  prefs: []
  type: TYPE_IMG
- en: Application getting disabled on one mode is brought up on another node with
    Service Fabric Cluster
  prefs: []
  type: TYPE_NORMAL
- en: Again, I hope the reader is intrigued enough to go ahead and explore the capabilities
    of the cluster. The support for Java applications and multiple versions of Linux
    is limited. Azure is working toward adding additional support to the platform
    to support all kinds of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Azure cloud functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move applications to the cloud, we are using platform services to improve
    our focus on business functionality, and not worrying about application scalability.
    Serverless applications are the next frontier. The developer focus is on building
    applications, without worrying about server provisioning, availability, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Java functions are currently in beta and are not available on the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: We can download and try to create Java functions on our local machines. We will
    see a brief preview of the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Azure Functions Core Tools SDK provides a local development environment
    for writing, running, and debugging your Java Azure Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new Java functions project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a sample Java functions project. We will make use of the following
    Maven archetype to generate the dummy project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the `mvn` command to provide the requisite inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Building and running the Java function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and build the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can run the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the function getting started in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4fbf658-89f7-4ef1-91c7-c66006a45afa.png)'
  prefs: []
  type: TYPE_IMG
- en: Building your Java cloud function
  prefs: []
  type: TYPE_NORMAL
- en: 'The default function is available at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go to `http://localhost:7071/api/hello?name=cloudnative` we can see the
    output from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcabf483-0ca5-42dc-8ca1-0ad0a1bf313b.png)'
  prefs: []
  type: TYPE_IMG
- en: Diving into code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we delve into the code, we can see the main code file where the default
    function `hello` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bf8fd82-eea1-4f5f-915e-4dc7ccf22afd.png)'
  prefs: []
  type: TYPE_IMG
- en: The method is annotated with `@HttpTrigger`, where we have defined the name
    of the trigger, methods allowed, authorization model used, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the function is compiled, it results in a `function.json` where the function
    bindings are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see both input and output data bindings. Functions have exactly one
    trigger. Triggers are fired with some associated data, which is usually the payload
    that triggers the function.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output bindings are a declarative way to connect to data from within
    your code. Bindings are optional and a function can have multiple input and output
    bindings.
  prefs: []
  type: TYPE_NORMAL
- en: You can develop functions by using the Azure portal. Triggers and bindings are
    directly configured in a `function.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Java functions are still a preview feature. The feature set is still under beta
    and documentation is scant. We will need to wait for Java to become a first-class
    citizen in the world of Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of platform development using Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the various features and services provided by the Azure
    cloud platform. As we take our applications into a cloud-native model, we move
    from App Service | Container Service | Service Fabric | serverless model (Cloud
    Functions). When we build greenfield applications, we skip the initial steps and
    directly adopt platform services, allowing automatic application scalability and
    availability management.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the various types of XaaS APIs, which includes
    IaaS, PaaS, iPaaS, and DBaaS. We will cover the architecture and design concerns
    when building your own XaaS.
  prefs: []
  type: TYPE_NORMAL
