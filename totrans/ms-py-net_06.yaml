- en: Network Security with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, network security is a tricky topic to write about. The reason
    is not a technical one, but rather to do with setting up the right scope. The
    boundaries of network security are so wide that they touch all seven layers of
    the OSI model. From layer 1 of wiretapping to layer 4 of the transport protocol
    vulnerability, to layer 7 of man-in-the-middle spoofing, network security is everywhere.
    The issue is exacerbated by all the newly discovered vulnerabilities, which sometimes
    seem to be at a daily rate. This does not even include the human social engineering
    aspect of network security.
  prefs: []
  type: TYPE_NORMAL
- en: As such, in this chapter, I would like to set the scope for what we will discuss.
    As we have been doing up to this point, we will primarily focus on using Python
    for network device security at OSI layers 3 and 4\. We will look at Python tools
    that we can use to manage individual network devices for security purposes, as
    well as using Python as a glue to connect different components. Hopefully, we
    can treat network security with a holistic view by using Python in different OSI
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The lab setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Scapy for security testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forensic analysis with Syslog and UFW using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools, such as a MAC address filter list, private VLAN, and Python IP
    table binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The devices being used in this chapter are a bit different from the previous
    chapters. In the previous chapters, we were isolating a particular device by focusing
    on the topic at hand. For this chapter, we will use a few more devices in our
    lab in order to illustrate the function of the tools that we will be using. The
    connectivity and operating system information are important as they have ramifications
    regarding the security tools that we will show later in this chapter. For example,
    if we want to apply an access list to protect the server, we need to know what
    the topology looks like and which direction the client is making their connections
    from. The Ubuntu host connections are a bit different than what we have seen so
    far, so please make reference back to this lab section when you see the example
    later if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the same Cisco VIRL tool with four nodes: two hosts and two
    network devices. If you need a refresher on Cisco VIRL, feel free to go back to
    [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network Device
    Interactions,* where we first introduced the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/620c32a2-6ce0-471f-a165-264f14e09454.png)Lab topologyThe IP addresses
    listed will be different in your own lab. They are listed here for an easy reference
    for the rest of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As illustrated, we will rename the host on the top as the client and the bottom
    host as the server. This is analogous to an internet client trying to access a
    corporate server within our network. We will again use the Shared flat network
    option for the management network to access the devices for the out-of-band management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2365022c-82e9-4928-ab1e-620b2e95b72c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the two switches, I will choose **Open Shortest Path First** (**OSPF**)
    as `IGP` and put both the devices in area `0`. By default, `BGP` is turned on
    and both the devices are using AS 1\. From the configuration auto generation,
    the interfaces connected to the Ubuntu hosts are put into OSPF area `1`, so they
    will show up as inter-area routes. The NX-OSv configurations are shown here and
    the IOSv configuration and output are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The OSPF neighbor and the BGP output for NX-OSv are shown here, and the IOSv
    output is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The hosts in our network are running Ubuntu 14.04, similar to the Ubuntu VM
    16.04 that we have been using up to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On both of the Ubuntu hosts, there are two network interfaces, `eth0` and `eth1`.
    `eth0` connects to the management network (`172.16.1.0/24`) while `eth1` connects
    to the network devices (`10.0.0.x/30`). The routes to the device loopback are
    directly connected to the network block, and the remote host network is statically
    routed to `eth1` with the default route going toward the management network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the client-to-server path, let''s ping and trace the route to make
    sure that traffic between our hosts is going through the network devices instead
    of the default route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have our lab; we are now ready to look at some security tools and
    measures using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy ([https://scapy.net](https://scapy.net/)) is a powerful Python-based interactive
    packet crafting program. Outside of some expensive commercial programs, very few
    tools can do what Scapy can do, to my knowledge. It is one of my favorite tools
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of Scapy is that it allows you to craft your own packet
    from the very basic level. In the words of Scapy''s creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Scapy is a powerful interactive packet manipulation program. It is able to
    forge or decode packets of a wide number of protocols, send them on the wire,
    capture them, match requests and replies, and much more.... with most other tools,
    you won''t build something the author did not imagine. These tools have been built
    for a specific goal and can''t deviate much from it."'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the tool.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, Scapy 2.3.1 supported Python 2.7\. Unfortunately, there
    were a few misfires regarding Python 3 support for Scapy and it is still relatively
    new for Scapy 2.3.3\. For your environment, please feel free to try out Python
    3 with version 2.3.3 and later. In this chapter, we will use Scapy 2.3.1 with
    Python 2.7\. See the information sidebar if you would like to learn more about
    the reason behind the choice.
  prefs: []
  type: TYPE_NORMAL
- en: The long story for Python 3 support in Scapy is that there was an independent
    fork of Scapy from version 2.2.0 in 2015, aimed at supporting only Python 3\.
    The project was named `Scapy3k`. The fork diverged from the main Scapy code base.
    If you read the first edition of this book, that was the information provided
    at the time of writing. There were confusions surrounding `python3-scapy` on PyPI
    and the official support of the Scapy code base. Our main purpose was to learn
    about Scapy in this chapter, and so therefore I made the choice to use an older,
    Python 2-based Scapy version.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our lab, since we are crafting packet sources from the client to the destination
    server, Scapy needs to be installed on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a quick test to make sure that the packages have been installed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Interactive examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our first example, we will craft an **Internet Control Message Protocol**
    (**ICMP**) packet on the client and send it to the server. On the server side,
    we will use `tcpdump` with a host filter to see the packet coming in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very simple to craft a packet from Scapy. Scapy allows
    you to build the packet layer by layer using the slash (`/`) as the separator.
    The `send` function operates at the layer 3 level, which takes care of routing
    and layer 2 for you. There is also a `sendp()` alternative that operates at layer
    2, which means you will need to specify the interface and link layer protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at capturing the returned packet by using the send-request (`sr`)
    function. We are using a special variation of `sr`, called `sr1`, which only returns
    one packet that answers from the packet sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that the `sr()` function itself returns a tuple containing
    answered and unanswered lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to only take a look at the answered packet list, we can see it is
    another tuple containing the packet that we have sent as well as the returned
    packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Scapy also provides a layer 7 construct as well, such as a `DNS` query. In
    the following example, we are querying an open DNS server for the resolution of
    `www.google.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scapy can also be used to easily capture packets on the wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look at the packets in some more detail, including the raw format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have seen the basic workings of Scapy. Let's move on and see how we can use
    Scapy for some of the common security testings.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP port scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step for any potential hackers is almost always trying to learn which
    service is open on the network, so they can concentrate their effort on the attack.
    Of course, we need to open certain ports in order to service our customer; that
    is part of the risk we need to accept. But we should also close any other open
    port that needlessly expose a larger attack surface. We can use Scapy to do a
    simple TCP open port scan to scan our own host.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can send a `SYN` packet and see whether the server will return with `SYN-ACK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in the output here, the server is responding with a `RESET+ACK`
    for TCP port `23`. However, TCP port `22` (SSH) is open; therefore, a `SYN-ACK`
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also scan a range of destination ports from `20` to `22`; note that
    we are using `sr()` for send-receive instead of the `sr1()` send-receive-one-packet
    variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify a destination network instead of a single host. As you
    can see from the `10.0.0.8/29` block, hosts `10.0.0.9`, `10.0.0.13`, and `10.0.0.14`
    returned with `SA`, which corresponds to the two network devices and the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on what we have learned so far, we can make a simple script for reusability,
    `scapy_tcp_scan_1.py`. We start with the suggested importing of `scapy` and the
    `sys` module for taking in arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tcp_scan()` function is similar to what we have seen up to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then acquire the input from arguments, and then call the `tcp_scan()`
    function in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that access to the low-level network requires root access; therefore,
    our script needs to be executed as `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This was a relatively lengthy example of the TCP scan script, which demonstrated
    the power of crafting your own packet with Scapy. We tested out the steps in the
    interactive shell and finalized the usage with a simple script. Let's look at
    some more examples of Scapy's usage for security testing.
  prefs: []
  type: TYPE_NORMAL
- en: The ping collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say our network contains a mix of Windows, Unix, and Linux machines with
    users adding their own **Bring Your Own Device** (**BYOD**); they may or may not
    support an ICMP ping. We can now construct a file with three types of common pings
    for our network, the ICMP, TCP, and UDP pings, in `scapy_ping_collection.py`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will also use `summary()` and `sprintf()` for the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you were wondering why there is a lambda in the preceding `answer_summary()`
    function, it is a way to create a small anonymous function. Basically, it is a
    function without a name. More information on it can be found at [https://docs.python.org/3.5/tutorial/controlflow.html#lambda-expressions](https://docs.python.org/3.5/tutorial/controlflow.html#lambda-expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then execute all three types of pings on the network in one script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At this point, hopefully, you will agree with me that, by having the ability
    to construct your own packet, you can be in charge of the type of operations and
    tests that you would like to run.
  prefs: []
  type: TYPE_NORMAL
- en: Common attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, let's look at how we can construct our packet to conduct some
    of the classic attacks, such as *Ping of Death* ([https://en.wikipedia.org/wiki/Ping_of_death](https://en.wikipedia.org/wiki/Ping_of_death))
    and *Land Attack* ([https://en.wikipedia.org/wiki/Denial-of-service_attack](https://en.wikipedia.org/wiki/Denial-of-service_attack)).
    This is perhaps the network penetration tests that you previously had to pay for
    with a similar commercial software. With Scapy, you can conduct the test while
    maintaining full control as well as adding more tests in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first attack basically sends the destination host with a bogus IP header,
    such as the length of 2 and the IP version 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ping_of_death_attack` consists of the regular ICMP packet with a payload
    bigger than 65,535 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `land_attack` wants to redirect the client response back to the client
    itself and exhausts the host''s resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These are pretty old vulnerabilities or classic attacks that the modern operating
    system is no longer susceptible to. For our Ubuntu 14.04 host, none of the preceding
    attacks will bring it down. However, as more security issues are being discovered,
    Scapy is a great tool to start tests against our own network and host without
    having to wait for the impacted vendor to give you a validation tool. This is
    especially true for the zero-day (published without prior notification) attacks
    that seem to be more and more common on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have spent quite a bit of effort working with Scapy in this chapter. This
    is partially due to how highly I personally think of the tool. I hope you agree
    with me that Scapy is a great tool to keep in your toolset as a network engineer.
    The best part about Scapy is that it is constantly being developed with an engaged
    community of users.
  prefs: []
  type: TYPE_NORMAL
- en: I would highly recommend at least going through the Scapy tutorial at [http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial](http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial),
    as well as any of the documentation that is of interest to you.
  prefs: []
  type: TYPE_NORMAL
- en: Access lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network access lists are usually the first line of defense against outside
    intrusions and attacks. Generally speaking, routers and switches process packets
    at a much faster rate than servers, because they utilize hardware such as **Ternary
    Content-Addressable Memory** (**TCAM**). They do not need to see the application
    layer information, rather they just examine the layer 3 and layer 4 information,
    and decide whether the packets can be forwarded on or not. Therefore, we generally
    utilize network device access lists as the first step in safeguarding our network
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, we want to place access lists as close to the source (client)
    as possible. Inherently, we also trust the inside host and distrust the clients
    outside of our network boundary. The access list is therefore usually placed on
    the inbound direction on the external facing network interface(s). In our lab
    scenario, this means we will place an inbound access list at Ethernet2/2 that
    is directly connected to the client host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure of the direction and placement of the access list, a few
    points might help here:'
  prefs: []
  type: TYPE_NORMAL
- en: Think of the access list from the perspective of the network device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simplify the packets in terms of just source and destination IP and use one
    host as an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our lab, traffic from our server will have a source IP of `10.0.0.14` with
    the destination IP of `10.0.0.10`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The traffic from the client will have a source IP of `10.10.10.10` and the destination
    IP of `10.0.0.14`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, every network is different and how the access list should be constructed
    depends on the services provided by your server. But as an inbound border access
    list, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deny RFC 3030 special-use address sources, such as `127.0.0.0/8`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny RFC 1918 space, such as `10.0.0.0/8`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny our own space as the source IP; in this case, `10.0.0.12/30`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permit inbound TCP port `22` (SSH) and `80` (HTTP) to host `10.0.0.14`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny everything else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing access lists with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to implement this access list would be to use Ansible. We have
    already looked at Ansible in the last two chapters, but it is worth repeating
    the advantages of using Ansible in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier management**: For a long access list, we are able to utilize the `include`
    statement to break it into more manageable pieces. The smaller pieces can then
    be managed by other teams or service owners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Idempotency**: We can schedule the playbook at a regular interval and only
    the necessary changes will be made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Each task is explicit**: We can separate the construct of the entries as
    well as apply the access list to the proper interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: In the future, if we add additional external-facing interfaces,
    we just need to add the device to the list of devices for the access list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: You will notice that we can use the same playbook for constructing
    the access list and apply it to the right interface. We can start small and expand
    to separate playbooks in the future as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The host file is pretty standard. For simplicity, we are putting the host variables
    directly in the inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will declare the variables in the playbook for the time being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To save space, we will illustrate denying the RFC 1918 space only. Implementing
    the denial of RFC 3030 and our own space will be identical to the steps used for
    the RFC 1918 space. Note that we did not deny `10.0.0.0/8` in our playbook, because
    our configuration currently uses the `10.0.0.0` network for addressing. Of course,
    we could perform the single host permit first and deny `10.0.0.0/8` in a later
    entry, but in this example, we just choose to omit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are allowing the established connection sourcing from the server
    inside to be allowed back in. We use the final explicit `deny ip any any` statement
    as a high sequence number (`1000`), so we can insert any new entries later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then apply the access list to the right interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The access list on VIRL NX-OSv is only supported on the management interface.
    You will see this warning: Warning: ACL may not behave as expected since only
    management interface is supported if you configure this `ACL` via the CLI. This
    warning is okay, as our purpose is only to demonstrate the configuration automation
    of the access list.'
  prefs: []
  type: TYPE_NORMAL
- en: This might seem to be a lot of work for a single access list. For an experienced
    engineer, using Ansible to do this task will take longer than just logging in
    to the device and configuring the access list. However, remember that this playbook
    can be reused many times in the future, so it will save you time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: It is my experience that often, for a long access list, a few entries will be
    for one service, a few entries will be for another, and so on. The access lists
    tend to grow organically over time, and it becomes very hard to keep track of
    the origin and purpose of each entry. The fact that we can break them apart makes
    management of a long access list much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: MAC access lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case where you have an L2 environment or where you are using non-IP protocols
    on Ethernet interfaces, you can still use a MAC address access list to allow or
    deny hosts based on MAC addresses. The steps are similar to the IP access list
    but the match will be based on MAC addresses. Recall that for MAC addresses, or
    physical addresses, the first six hexadecimal symbols belong to an **Organizationally
    Unique Identifier** (**OUI**). So, we can use the same access list matching pattern
    to deny a certain group of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: We are testing this on IOSv with the `ios_config` module. For older Ansible
    versions, the change will be pushed out every single time the playbook is executed.
    For newer Ansible versions, the control node will check for change first and only
    make changes when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The host file and the top portion of the playbook are similar to the IP access
    list; the `tasks` portion is where the different modules and arguments are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As more virtual networks become popular, the L3 information sometimes becomes
    transparent to the underlying virtual links. In these scenarios, the MAC access
    list becomes a good option if you need to restrict access to those links.
  prefs: []
  type: TYPE_NORMAL
- en: The Syslog search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of documented network security breaches that took place over
    an extended period of time. In these slow breaches, quite often, we saw signs
    and traces in logs indicating that there were suspicious activities. These can
    be found in both server and network device logs. The activities were not detected,
    not because there was a lack of information, but rather because there was too
    much information. The critical information that we were looking for is usually
    buried deep in a mountain of information that is hard to sort out.
  prefs: []
  type: TYPE_NORMAL
- en: Besides Syslog, **Uncomplicated Firewall** (**UFW**) is another great source
    of log information for servers. It is a frontend to iptables, which is a server
    firewall. UFW makes managing firewall rules very simple and logs a good amount
    of information. See the *Other tools* section for more information on UFW.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will try to use Python to search through the Syslog text
    in order to detect the activities that we were looking for. Of course, the exact
    terms that we will search for depend on the device we are using. For example,
    Cisco provides a list of messages to look for in Syslog for any the access list
    violation logging. It is available at [http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html](http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html).
  prefs: []
  type: TYPE_NORMAL
- en: For more understanding of access control list logging, go to [http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html](http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our exercise, we will use a Nexus switch anonymized syslog file containing
    about 65,000 lines of log messages this file is included in the accommodated book
    GitHub repository for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have inserted some Syslog messages from the Cisco documentation ([http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html](http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html) )
    as the log message that we should be looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We will be using simple examples with regular expressions. If you are already
    familiar with the regular expression in Python, feel free to skip the rest of
    the section.
  prefs: []
  type: TYPE_NORMAL
- en: Searching with the RE module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our first search, we will simply use the regular expression module to look
    for the terms we are looking for. We will use a simple loop to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result took about 6/100 of a second to search through the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended to compile the search term for a more efficient search. It
    will not impact us much since the script is already pretty fast. In fact, the
    Python interpretative nature might actually make it slower. However, it will make
    a difference when we search through a larger text body, so let''s make the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The timing result is actually slower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s expand the example a bit. Assuming we have several files and multiple
    terms to search through, we will copy the original file to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also include searching for the `PAM: Authentication failure` term.
    We will add another loop to search both the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the difference in performance by expanding our search terms
    and the number of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Of course, when it comes to performance tuning, it is a never-ending, impossible
    race to zero, and the performance sometimes depends on the hardware you are using.
    But the important point is to regularly perform audits of your log files using
    Python, so you can catch the early signals of any potential breach.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other network security tools that we can use and automate with Python.
    Let's take a look at a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Private VLANs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Virtual Local Area Networks** (**VLANs**) have been around for a long time.
    They are essentially a broadcast domain where all hosts can be connected to a
    single switch, but are partitioned out to different domains, so we can separate
    the hosts out according to which host can see others via broadcasts. Let''s look
    at an mapped based on IP subnets. For example, in an enterprise building, I would
    likely see one IP subnet per physical floor: `192.168.1.0/24` for the first floor,
    `192.168.2.0/24` for the second floor, and so on. In this pattern, we use a 1/24
    block for each floor. This gives a clear delineation of my physical network as
    well as my logical network. A host wanting to communicate beyond its own subnet
    will need to traverse through its layer 3 gateway, where I can use an access list
    to enforce security.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when different departments reside on the same floor? Perhaps the
    finance and sales teams are both on the second floor, and I would not want the
    sales team's hosts in the same broadcast domain as the finance team's. I can break
    the subnet down further, but that might become tedious and break the standard
    subnet scheme that was previously set up. This is where a private VLAN can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private VLAN essentially breaks up the existing VLAN into sub-VLANs. There
    are three categories within a private VLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Promiscuous (P) port**: This port is allowed to send and receive layer
    2 frames from any other port on the VLAN; this usually belongs to the port connecting
    to the layer 3 router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Isolated (I) port**: This port is only allowed to communicate with P
    ports, and they are typically connected to hosts when you do not want it to communicate
    with other hosts in the same VLAN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Community (C) port**: This port is allowed to communicate with other
    C ports in the same community and P ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can again use Ansible or any of the other Python scripts introduced so far
    to accomplish this task. By now, we should have enough practice and confidence
    to implement this feature via automation, so I will not repeat the steps here.
    Being aware of the private VLAN feature would come in handy at times when you
    need to isolate ports even further in an L2 VLAN.
  prefs: []
  type: TYPE_NORMAL
- en: UFW with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We briefly mentioned UFW as the frontend for iptables on Ubuntu hosts. Here
    is a quick overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the status of UFW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the advantage of UFW is a simple interface to construct otherwise
    complicated IP table rules. There are several Python-related tools we can use
    with UFW to make things even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Ansible UFW module to streamline our operations. More information
    is available at [http://docs.ansible.com/ansible/ufw_module.html](http://docs.ansible.com/ansible/ufw_module.html).
    Because Ansible is written in Python, we can go further and examine what is inside
    the Python module source code. More information is available at [https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/system/ufw.py.](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/system/ufw.py)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are Python wrapper modules around UFW as an API (visit [https://gitlab.com/dhj/easyufw](https://gitlab.com/dhj/easyufw)).
    This can make integration easier if you need to dynamically modify UFW rules based
    on certain events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UFW itself is written in Python.Therefore, you can use the existing Python knowledge
    if you ever need to extend the current command sets. More information is available
    at [https://launchpad.net/ufw](https://launchpad.net/ufw).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UFW proves to be a good tool to safeguard your network server.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a very common language used in many of the security-related fields.
    A few of the books I would recommend are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Violent Python**: A cookbook for hackers, forensic analysts, penetration
    testers, and security engineers by T.J. O''Connor (ISBN-10: 1597499579)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black Hat Python**: Python programming for hackers and pentesters by Justin
    Seitz (ISBN-10: 1593275900)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have personally used Python extensively in our research work on **Distributed
    Denial of Service** (**DDoS**) at A10 Networks. If you are interested in learning
    more, the guide can be downloaded for free at [https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos](https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at network security with Python. We used the Cisco
    VIRL tool to set up our lab with both hosts and network devices, consisting of
    NX-OSv and IOSv types. We took a tour around Scapy, which allows us to construct
    packets from the ground up. Scapy can be used in the interactive mode for quick
    testing. Once completed in interactive mode, we can put the steps into a file
    for more scalable testing. It can be used to perform various network penetration
    testing for known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can use both an IP access list as well as a MAC access
    list to protect our network. They are usually the first line of defense in our
    network protection. Using Ansible, we are able to deploy access lists consistently
    and quickly to multiple devices.
  prefs: []
  type: TYPE_NORMAL
- en: Syslog and other log files contain useful information that we should regularly
    comb through to detect any early signs of a breach. Using Python regular expressions,
    we can systematically search for known log entries that can point us to security
    events that require our attention. Besides the tools we have discussed, private
    VLAN and UFW are among some other useful tools that we can use for more security
    protection.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml), *Network Monitoring
    with Python – Part 1*, we will look at how to use Python for network monitoring.
    Monitoring allows us to know what is happening in our network and the state of
    the network.
  prefs: []
  type: TYPE_NORMAL
