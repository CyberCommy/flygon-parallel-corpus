- en: Operators, Expressions, and Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the three core elements of Java programming—operators, expressions,
    and statements—will be defined and explained in detail. The discussion will be
    supported by specific examples that illustrate the key aspects of these elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the core elements of Java programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java operators, expressions, and statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator precedence and evaluation order of operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widening and narrowing the conversion of primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxing and unboxing between primitive and reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equals()` method of reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Naming the statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the core elements of Java programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language Basics*,
    we had an overview of many aspects of Java as a language, and even defined what
    statements are. Now, we will look closer into the core elements of Java more systematically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The word "elements" is quite overloaded (playing on the analogy with method
    overload). In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*, we introduced input elements, those that are identified by
    the Java specification: whitespace, comment, and token. That is how the Java compiler
    parses the source code and makes sense of it. The list of tokens includes identifiers,
    keywords, separators, literals, and operators. That is how the Java compiler adds
    more meaning to the tokens it encounters.'
  prefs: []
  type: TYPE_NORMAL
- en: While discussing the input elements, we explained that they are used to build
    more complex elements of language. In this chapter, we will start with the operator token and
    show how an expression—a more complex Java element—is constructed with it.
  prefs: []
  type: TYPE_NORMAL
- en: But, not all Java operators are tokens. The `instanceof` and `new` operators are
    keywords, while the `.` operator (field access or method invocation), the `::` method
    reference operator, and the `( type )` cast operator are separators.
  prefs: []
  type: TYPE_NORMAL
- en: As we said in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, a statement in Java plays a role similar to a sentence in the
    English language, which expresses a complete thought.  In a programming language,
    a statement is a complete line of code that performs some action.
  prefs: []
  type: TYPE_NORMAL
- en: An expression, on the other hand, is a part of a statement that evaluates to
    a value. Every expression can be a statement (if the resulting value is ignored),
    while most statements do not include expressions.
  prefs: []
  type: TYPE_NORMAL
- en: That is how the three core elements of Java—operator, expression, and statement—are
    related.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the list of all 44 operators in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operators** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `+`, `-`, `*`, `/`, `%` | Arithmetic unary and binary operators |'
  prefs: []
  type: TYPE_TB
- en: '| `++`, `--` | Increment and decrement unary operators |'
  prefs: []
  type: TYPE_TB
- en: '| `==`, `!=` | Equality operators |'
  prefs: []
  type: TYPE_TB
- en: '| `<`, `>`, `<=`, `>=` | Relational operators |'
  prefs: []
  type: TYPE_TB
- en: '| `!`, `&`, `&#124;` | Logical operators |'
  prefs: []
  type: TYPE_TB
- en: '| `&&`, `&#124;&#124;`, `?`, `:` | Conditional operators |'
  prefs: []
  type: TYPE_TB
- en: '| `=`, `+=`, `-=`, `*=`, `/=`, `%=` | Assignment operators |'
  prefs: []
  type: TYPE_TB
- en: '| `&=`, `&#124;=`, `^=`, `<<=`, `>>=`, `>>>=` | Assignment operators |'
  prefs: []
  type: TYPE_TB
- en: '| `&`, `&#124;`, `~`, `^`, `<<`, `>>`, `>>>` | Bitwise operators |'
  prefs: []
  type: TYPE_TB
- en: '| `->`, `::` | Arrow and method reference operators |'
  prefs: []
  type: TYPE_TB
- en: '| `new` | Instance creation operator |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Field access/method invocation operator |'
  prefs: []
  type: TYPE_TB
- en: '| `instanceof` | Type comparison operator |'
  prefs: []
  type: TYPE_TB
- en: '| `( target type )` | Cast operator |'
  prefs: []
  type: TYPE_TB
- en: Unary means used with a single operand, while binary means it requires two operands.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will define and demonstrate most of the operators,
    except the rarely used assignment operators `&=`,  `|=`,  `^=`,  `<<=`,  `>>=`,
    and  `>>>=`, and the bitwise operators.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please notice that the `&` and `|` operators behave differently if applied
    to integer (bitwise) and Boolean (logical) values. In this book, we will discuss
    these operators only as logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: The arrow operator `->` and the method reference operator `::` will be defined
    and discussed in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic unary (+  -) and binary operators:  +   -   *   /   %
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to understand operators is to see them in action. Here is our
    demo application code (with results captured in comments) that explains the unary
    operators `+` and `-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Ch09DemoApp {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2;   //unary "+" is assumed by default
  prefs: []
  type: TYPE_NORMAL
- en: int x = -i;  //unary "-" makes positive become negative
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);   //prints: -2'
  prefs: []
  type: TYPE_NORMAL
- en: int y = -x;  //unary "-" makes negative become positive
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y);   //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following code demonstrates the binary operators  `+`, `-`, `*`, `/`,
    and `%`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int z = x + y;              //binary "+" means "add"
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z);      //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: z = x - y;                  //binary "-" means "subtract"
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z);      //prints: -4'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y - x);  //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: z = x * y;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z);      //prints: -4'
  prefs: []
  type: TYPE_NORMAL
- en: z = x / y;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z);      //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: z = x * y;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z % 3);  //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z % 2);  //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(z % 4);  //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you have probably guessed, the `%` operator (called modulus) divides the
    left-hand operand by the right-hand operand and returns the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything looks logical and as expected. But, then we try to divide one integer
    by another integer with the remainder and do not get what was expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 11;
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 3;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 / i2); //prints: 3 instead of 3.66...'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 % i2); //prints remainder: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The result, `i1/i2`, should be bigger than `3`. It has to be `3.66...` or something
    similar. The problem is caused by the fact that all the numbers involved in the
    operation are integers. In such a case, Java assumes that the result should also
    be expressed as an integer and drops (without rounding) the fractional part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s declare one of the operands as the `double` type, with the same
    value of 11, and try the division again:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = 11;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1/i2);    //prints: 3.6666666666666665'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we got what was expected, and there are other ways to achieve the
    same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((float)i1 / i2);  //prints: 3.6666667'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 / (double)i2); //prints: 3.6666666666666665'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 * 1.0 / i2);   //prints: 3.6666666666666665'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 * 1f / i2);    //prints: 3.6666667'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 * 1d / i2);    //prints: 3.6666666666666665'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can cast any of the operands to the `float` or `double`
    types (depending on the precision you need), or you can include the `float` or
    `double` type number. You might remember from [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, that a value with a fractional part is `double`
    by default. Or, you can explicitly select a type of the value added, as we did
    in the last two lines of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever you do, just be careful while dividing two integers. If you do not
    want the fractional part to be dropped, cast at least one operand to `float` or
    `double` just in case (more about the cast operator in the *Cast operator: ( target
    type )* section later. Then, if you need, you can round up the result to any precision
    you prefer or cast it back to `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 11;
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 3;
  prefs: []
  type: TYPE_NORMAL
- en: float r = (float)i1 / i2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);                 //prints: 3.6666667'
  prefs: []
  type: TYPE_NORMAL
- en: float f = Math.round(r * 100f) / 100f;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(f);                 //prints: 3.67'
  prefs: []
  type: TYPE_NORMAL
- en: int i3 = (int)f;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i3);                //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java integer division: if in doubt, make one of the operands `double` or `float`,
    or simply add a `1.0` multiplier to one of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of `String`, the binary operator  `+` means concatenate and the operator
    is often called the concatenation operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "Nick";
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = "Samoylov";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1 + " " + s2);  //prints: Nick Samoylov'
  prefs: []
  type: TYPE_NORMAL
- en: String s3 = s1 + " " + s2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s3);             //prints: Nick Samoylov'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And just as a reminder, in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, we demonstrated that an arithmetic operation
    applied to the primitive type `char` uses the character''s code point – a numeric
    value of the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: char c1 = 'a';
  prefs: []
  type: TYPE_NORMAL
- en: char c2 = '$';
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 + c2);       //prints: 133'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1/c2);         //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((float)c1/c2);  //prints: 2.6944444'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: These results make sense only if you remember that the code point of the symbol
    `a` is 97, while the code point of the symbol `$` is 36.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, the arithmetic operations in Java are quite intuitive and
    cause no confusion, except in two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When all operands of the division are integral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `char` variables are used as the operands of an arithmetic operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incrementing and decrementing unary operators:  ++   --
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code shows how the `++` and `--` operators work, depending on
    their position, before the variable (prefix) or after the variable (postfix):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(++i);        //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("i=" + i);   //prints: i=3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(--i);        //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("i=" + i);   //prints: i=2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i++);        //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("i=" + i);   //prints: i=3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i--);        //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("i=" + i);   //prints: i=2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If placed as a prefix, it changes its value by 1 before the variable's value
    is returned. But when placed as a postfix, it changes its value by 1 after the
    variable's value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `++x` expression increments the `x` variable before returning the result,
    while the `x++` expression returns the result first and increments the `x` variable afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes time to get used to this. But once you do, it feels easy to write
    `++x;` or `x++`, instead of `x = x + 1;`. Using prefix or postfix increments,
    in this case, does not make a difference because each of them increases `x` eventually:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0;
  prefs: []
  type: TYPE_NORMAL
- en: ++x;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);   //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: x = 0;
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);   //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between prefix and postfix appears only when the returned value
    is used, not the value of the variable that will have after the postfix returns,
    for example. Here is the demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int y = x++ + x++;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y);   //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);   //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `y` is formed by the first `x++` returning 0 and then increasing `x` by
    1\. The second `x++` gets 1 as the current `x` value and returns it, so the `y` value
    becomes 1\. Meanwhile, the second `x++` increases the value of `x` by 1 again,
    so the value of `x` becomes 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality makes more sense if we include it in an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int n = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int m = 5*n++;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(m);   //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(n);   //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows us to use the current value of the variable first and then increase
    it by 1\. So, the postfix increment (decrement) operator has the side effect of
    incrementing (decrementing) the variable value. As we have mentioned already,
    it is especially beneficial for array element access:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int k = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {88, 5, 42};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[k++]);  //prints: 88'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[k++]);  //prints: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[k++]);  //prints: 42'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same result can be achieved by setting `k` to `-1` and moving `++` to the
    front:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int k = -1;
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {88, 5, 42};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[k++]);  //prints: 88'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[++k]);  //prints: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[++k]);  //prints: 42'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, using `k=0` and `k++` reads better and thus became a typical way to access
    the array components. However, it is only useful if you need to access the array
    elements by index. For example, if you need to access the array starting with
    index `2`, then you need to use the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {1,2,3,4};
  prefs: []
  type: TYPE_NORMAL
- en: int j = 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[j++]);  //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[j++]);  //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But if you are going to access the array sequentially, starting from index 0,
    then there are more economical ways to do it. See [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Equality operators:  ==   !=
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The equality operators `==` (means equals) and `!=` (means not equals) compare
    values of the same type and return the `Boolean` value `true` if the operand''s
    values are equal, or `false` otherwise. The integral and Boolean primitive type''s
    equality is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: char a = 'a';
  prefs: []
  type: TYPE_NORMAL
- en: char b = 'b';
  prefs: []
  type: TYPE_NORMAL
- en: char c = 'a';
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a == b);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a != b);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a == c);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a != c);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 2;
  prefs: []
  type: TYPE_NORMAL
- en: int i3 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 == i2);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 != i2);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 == i3);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 != i3);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: boolean b1 = true;
  prefs: []
  type: TYPE_NORMAL
- en: boolean b2 = false;
  prefs: []
  type: TYPE_NORMAL
- en: boolean b3 = true;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 == b2);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 != b2);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 == b3);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 != b3);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, the `char` type, as in the case of arithmetic operations, is
    treated as a numeric value that is equal to its code point. Otherwise, it is not
    easy to understand the results of the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((a + 1) == b); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the explanation for this line is obvious from the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b - a);        //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((int)a);       //prints: 97'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((int)b);       //prints: 98'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The code point of `a` is `97` and the code point of `b` is `98`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the primitive types `float` and `double`, the equality operator seems to
    work in the same way. Here is an example of `double` type equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = 0.42;
  prefs: []
  type: TYPE_NORMAL
- en: double d2 = 0.43;
  prefs: []
  type: TYPE_NORMAL
- en: double d3 = 0.42;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 == d2);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 != d2);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 == d3);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 != d3);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, that is because we compare numbers created as literals, with fixed fractional
    parts. If we compare the results of the following calculations, there is a good
    chance that the resulting value would never be equal to the expected result, because
    some numbers (such as `1/3`, for example) cannot be represented exactly. And what
    is it exactly in the case of `1/3`? Expressed as a decimal, it has a never-ending
    fractional part:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((double)1/3);    //prints: 0.3333333333333333'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is why when comparing values of types `float` and `double`, it is much
    more reliable to use the relational operators `<`,  `>`, `<=`, or `=>` (see the
    next subsection).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of object references, an equality operator compares the references
    themselves, not the objects and their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass c1 = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass c2 = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass c3 = c1;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 == c2);     //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 != c2);     //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 == c3);     //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 != c3);     //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(new SomeClass() == new SomeClass());  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Object equality based on the values they contain has to be performed using the `equals()` method.
    We talked about it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, and will discuss it more in the *Method equals() of reference
    types* section later.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators:  <  >  <=  >=
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Relational operators can only be used with primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 2;
  prefs: []
  type: TYPE_NORMAL
- en: int i3 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 > i2);    //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 >= i2);   //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 >= i3);   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 < i2);    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 <= i2);   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 <= i3);   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(''a'' >= ''b'');  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(''a'' <= ''b'');  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = 1/3;
  prefs: []
  type: TYPE_NORMAL
- en: double d2 = 0.34;
  prefs: []
  type: TYPE_NORMAL
- en: double d3 = 0.33;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 < d2);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 >= d3); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we see that `int` type values compare to each other as
    expected, and `char` type values compare to each other based on their numeric
    code point values.
  prefs: []
  type: TYPE_NORMAL
- en: Variables of the primitive type `char`, when used as operands with arithmetic,
    equality, or relational operators, assign numeric values equal to the code points
    of the characters they represent.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, nothing unexpected, except the last line. We have established that
    `1/3` expressed as a decimal should be `0.3333333333333333`, which is bigger than
    `0.33`. Why then does `d1 >= d3` return `false`? If you said that it is because
    of integer division, you are correct. Even when assigned to a variable of type
    `double`, the result is 0.0 because the integer division `1/3` happens first,
    before the result is assigned to `d1`. Here is the code that demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = 1/3;
  prefs: []
  type: TYPE_NORMAL
- en: double d2 = 0.34;
  prefs: []
  type: TYPE_NORMAL
- en: double d3 = 0.33;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 < d2);   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 >= d3);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1);        //prints: 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: double d4 = 1/3d;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d4);        //prints: 0.3333333333333333'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d4 >= d3);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But other than that, using `float` and `double` types with relational operators
    yields more predictable results than using them with equality operators.
  prefs: []
  type: TYPE_NORMAL
- en: While comparing values of types `float` and `double`, use the relational operators `<`,  `>`, `<=`,
    or `=>` instead of the equality operators `==` and `!=`.
  prefs: []
  type: TYPE_NORMAL
- en: Like in experimental physics, think about precision while comparing values of
    `float` and `double` types.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators:  !  &  |
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define each of the logical operators first:'
  prefs: []
  type: TYPE_NORMAL
- en: The unary operator `!` returns `true` if the operand is `false` and returns
    `false` otherwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary operator `&` returns `true` if both of the operands are `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary operator `|` returns true if at least one of the operands is true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean x = false;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(!x);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(!!x); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: boolean y = !x;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y & x); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y | x); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: boolean z = true;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y & z); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y | z); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `!` operator can be applied to the same value several times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional operators:  &&   ||    ? : (ternary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can reuse the previous code example, but with the `&&` and `||` operators instead
    of the `&` and `|` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean x = false;
  prefs: []
  type: TYPE_NORMAL
- en: boolean y = !x;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y && x); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y || x); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: boolean z = true;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y && z); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y || z); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are not different, but there is a difference in the execution.
    The operators `&` and `|` always check values of both operands. Meanwhile, in
    the case of `&&`, if the operand on the left returns `false`, the `&&` operator returns
    `false` without evaluating the operand on the right. And, in the case of `||`,
    if the operand on the left returns `true`, the `||` operator returns `true` without
    evaluating the operand on the right. Here is the code that demonstrates this difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i = 1, j = 3, k = 10;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i > j & i++ < k);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("i=" + i);         //prints: i=2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i > j && i++ < k); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("i=" + i);         //prints: i=2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Both operators—`&` and `&&`—return `false`. But in the case of `&&`, the second
    operand, `i++ < k`, is not checked and the value of the variable `i` does not
    change. Such optimization saves time if the second operand takes time to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: The `&&` and `||` operators do not evaluate the right-hand condition if the
    left-hand condition already failed the test (returned `false`) in the case of
    `&&`, or succeeded (returned `true`) in the case of `||`.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, the `&` operator is useful when it is necessary to always check the second
    operand. For example, the second operand might be a method that may throw an exception
    and change the flow of the logic under some rare condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third conditional operator is called a ternary operator. Here''s how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int n = 1, m = 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(n > m ? "n > m" : "n <= m"); //prints: n <= m'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(n > m ? true : false);       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'int max = n > m ? n : m;'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(max);                        //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It evaluates the condition and, if it is true, returns the first entry (after
    the question mark, `?`); otherwise, it returns the second entry (after the colon
    sign, `:`). It is a very convenient and compact way to select between two options
    instead of using the full `if-else` statement construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String result;
  prefs: []
  type: TYPE_NORMAL
- en: if(n > m){
  prefs: []
  type: TYPE_NORMAL
- en: result = "n > m";
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: result = "n <= m";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss such statements (called conditional statements) in [Chapter
    10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators (most popular):  =   +=   -=   *=   /=   %=
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we discuss them not the first, these are the most often used operators,
    especially the `=` simple assignment operator, which just assigns a value to a
    variable (also phrased as *assigns a variable a value*). We have seen examples
    of simple assignment usage many times already.
  prefs: []
  type: TYPE_NORMAL
- en: The only possible caveat in using simple assignment is when the type of the
    variable on the left is not the same as the value or variable type on the right.
    The difference in types can lead to the *narrowing* or *widening* of the value
    in the case of primitive types, or to *boxing* or *unboxing* when one type is
    a primitive type and another type is a reference type. We will discuss such assignments
    in the *Widening and narrowing conversion of primitive types* and *Boxing and
    unboxing between a primitive and reference types* sections later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the assignment operators (`+=`  `-=`  `*=`  `/=`  `%=`) are called
    compound assignment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x += 2;` assigns the result of this addition: `x = x + 2;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x -= 2;` assigns the result of this subtraction: `x = x - 2;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x *= 2;` assigns the result of this multiplication: `x = x * 2;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x /= 2;` assigns the result of this division: `x = x / 2;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x %= 2;` assigns the remainder of this division: `x = x + x % 2;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The operation `x = x + x % 2;` is based on the operator precedence rules, which
    we are going to discuss in the *Operator precedence and evaluation order of operands* section later.
    According to these rules, the `%` operator (modulus) is executed first, then the `+` operator (addition),
    and then the result is assigned to the left-hand operand variable `x`. Here is
    the demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 1;
  prefs: []
  type: TYPE_NORMAL
- en: x += 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: x -= 1;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: x *= 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: x /= 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: x %= 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, every time we encounter integer division, we had better convert it to
    a `float` or `double` division, then round it if necessary or just cast it to
    an integer. In our example, we do not have any loss of the fractional part. But
    if we do not know the value of `x`, the code may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: x = 11;
  prefs: []
  type: TYPE_NORMAL
- en: double y = x;
  prefs: []
  type: TYPE_NORMAL
- en: y /= 3;          //That's the operation we wanted to do on x
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y);        //prints: 3.6666666666666665'
  prefs: []
  type: TYPE_NORMAL
- en: x = (int)y;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);        //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '//or, if we need to round up the result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'double d = Math.round(y);     //prints: 4.0'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(d);
  prefs: []
  type: TYPE_NORMAL
- en: x = (int) d;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);        //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we have assumed that we do not know the value of `x`, so we switched
    to the `double` type to avoid the loss of the fractional part. After the result
    is calculated, we either cast it to `int` (and the fractional part is lost) or
    round it to the nearest integer.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple division, we could lose the fractional part and get `3`, even
    without converting to the `double` type. But in real-life calculations, the formula
    is usually not that simple, so one might never know exactly where the integer
    division might happen. That's why it is a good practice just to convert the values
    to `float` and `double` before starting the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance creation operator: new'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we have seen examples of the `new` operator being used many times. It
    instantiates (creates an object of) a class by allocating memory for the new object
    and returning a reference to that memory. This reference is then typically assigned
    to a variable of the same type as the class used to create the object or the type
    of its parent, although we have also seen a case when the reference was never
    assigned. In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, for example, we used this code to demonstrate
    how the constructors are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: new Child();
  prefs: []
  type: TYPE_NORMAL
- en: new Child("The Blows");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But such cases are very rare and most of the time we need a reference to the
    newly created object in order to invoke its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass obj = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: obj.someMethod();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: After the `new` operator is called and the memory is allocated, the corresponding
    (explicit or default) constructor initializes the state of the new object. We
    talked extensively about this [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since arrays are objects too, they can also be created using the `new` operator and
    any Java type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = new int[42];
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[]` notation allows us to set the array length (max number of components,
    also called elements) – `42` in the preceding code. One potential source of confusion
    may come from the fact that at compile time, Java allows assigning values to components
    with indexes bigger than the array length:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = new int[42];
  prefs: []
  type: TYPE_NORMAL
- en: arrInt[43] = 22;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But when the program is run, the line `arrInt[43] = 22` will throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fbc4c0a-5e3a-4788-a04c-fa205a28259a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to create an array without using the `new` operator and
    using the array initializer instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = {1,2,3,4};
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: A class instance can only be created using the `new` operator. An array can
    be created using the `new` operator or the `{}` initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed this extensively in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. If not initialized explicitly, the values
    of an array are set to default values that depend on the type (we described them
    in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*, too).  Here is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = new int[42];
  prefs: []
  type: TYPE_NORMAL
- en: //arrInt[43] = 22;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInt[2]);      //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInt.length);  //prints: 42'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInit = {1,2,3,4};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInit[2]);      //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInit.length);  //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: And, just to remind you, the index of the first element of an array is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Type comparison operator:  instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instanceof` operator requires two operands of a reference type. That is
    because it checks the parent-child relation of an object, including implementation
    of interfaces. It evaluates to `true` if the left-hand operand (an object reference)
    extends or implements the type on the right, and `false` otherwise. Obviously,
    every reference `instanceof Object` returns `true` because in Java, every class
    implicitly inherits the `Object` class. When `instanceof` is applied to an array
    of any type, it returns `true` for the right-hand operand `Object` only.  And,
    since `null` is not an instance of any type, `null instanceof` returns `false`
    for any type. Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface IntrfA{}
  prefs: []
  type: TYPE_NORMAL
- en: class ClassA implements IntrfA {}
  prefs: []
  type: TYPE_NORMAL
- en: class ClassB extends ClassA {}
  prefs: []
  type: TYPE_NORMAL
- en: class ClassX implements IntrfA {}
  prefs: []
  type: TYPE_NORMAL
- en: private void instanceofOperator() {
  prefs: []
  type: TYPE_NORMAL
- en: ClassA classA = new ClassA();
  prefs: []
  type: TYPE_NORMAL
- en: ClassB classB = new ClassB();
  prefs: []
  type: TYPE_NORMAL
- en: ClassX classX = new ClassX();
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrI = {1,2,3};
  prefs: []
  type: TYPE_NORMAL
- en: ClassA[] arrA = {new ClassA(), new ClassA()};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof Object); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrI instanceof Object);   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrA instanceof Object);   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(arrA instanceof ClassA);   //error
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof IntrfA); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classB instanceof IntrfA); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classX instanceof IntrfA); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof ClassA); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classB instanceof ClassA); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof ClassB); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(classX instanceof ClassA); //error
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(null instanceof ClassA);   //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(classA instanceof null);   //error
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA == null);           //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA != null);           //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the results are straightforward and were probably expected. The only
    one that might have been expected is `classX instanceof ClassA`. Both `ClassX`
    and `ClassA` implement the same interface, `IntrfA`, so there is some affinity
    between them – each can be cast to the `IntrfA` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: IntrfA intA = (IntrfA)classA;
  prefs: []
  type: TYPE_NORMAL
- en: intA = (IntrfA)classX;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But that relation is not of parent-child type, so the `instanceof` operator
    cannot even be applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: The `instanceof` operator allows us to check whether the class instance (object)
    has a certain class as a parent or a certain interface implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We see a similar problem with `classA instanceof null` because `null` does not
    refer to any object at all, although `null` is a literal of the reference type.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two statements in the preceding code, we showed how the object reference
    can be compared to `null`. Such a comparison is often used before calling a method
    on the reference to make sure that the reference is not `null`. It helps to avoid
    the dreaded `NullPointerException`, which breaks the execution flow. We will talk more
    about exceptions in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring polymorphism over the instanceof operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `instance of` operator is very helpful. We have used it several times in
    this book. But, there are situations that may require us to revisit the decision
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you think about using the `instanceof` operator, try to see if you
    can avoid it by using polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this tip, here is some code that can benefit from polymorphism
    instead of using the `intanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassBase {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassY extends ClassBase {
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassY.method() is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassZ extends ClassBase {
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassZ.method() is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  prefs: []
  type: TYPE_NORMAL
- en: public void doSomething(ClassBase object) {
  prefs: []
  type: TYPE_NORMAL
- en: if(object instanceof ClassY){
  prefs: []
  type: TYPE_NORMAL
- en: ((ClassY)object).method();
  prefs: []
  type: TYPE_NORMAL
- en: '} else if(object instanceof ClassZ){'
  prefs: []
  type: TYPE_NORMAL
- en: ((ClassZ)object).method();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //other code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass cl = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: cl.doSomething(new ClassY());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b39a48b-3c7e-4adf-81a8-ca3ddd69c988.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, we notice that the methods in `ClassY` and `ClassZ` have the same signature,
    so we may add the same method to the base class, `ClassBase:`
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassBase {
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassBase.method() is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And simplify the `SomeClass` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  prefs: []
  type: TYPE_NORMAL
- en: public void doSomething(ClassBase object) {
  prefs: []
  type: TYPE_NORMAL
- en: object.method();
  prefs: []
  type: TYPE_NORMAL
- en: //other code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling `new SomeClass().doSomething(new ClassY())`, we still get the
    same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6f5a08-0855-4ced-b30a-b4cf0c925523.png)'
  prefs: []
  type: TYPE_IMG
- en: That is because `method()` is overridden in the child. The method implemented
    in `ClassBase` can do something or nothing. It does not matter because it is never
    going to be executed (unless you specifically call it by casting it from the child
    class using the `super` keyword).
  prefs: []
  type: TYPE_NORMAL
- en: 'And, while overriding, do not forget to use the `@Override` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassZ extends ClassBase {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassY.method() is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The annotation will help you to verify that you are not mistaken and the method
    in each of the child classes has the same signature as the one in the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Field access or method invocation operator:  .
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the class or interface, a field or a method of this class or interface
    can be accessed just by the name. But from outside the class or interface, the
    non-private field or method can be accessed using the dot (`.`) operator and:'
  prefs: []
  type: TYPE_NORMAL
- en: If the field or method is non-static (instance member), the object name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the field or method is static, the interface or class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dot operator (`.`) can be used to access a non-private field or method. If
    the field or method is static, the dot operator is applied to the interface or
    class name. If the field or method is non-static, the dot operator is applied
    to the object reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen many such examples already. So, we just summarize all the cases
    in one interface and the class that implements it. Let''s assume that we have
    the following interface called `InterfaceM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface InterfaceM {
  prefs: []
  type: TYPE_NORMAL
- en: String INTERFACE_FIELD = "interface field";
  prefs: []
  type: TYPE_NORMAL
- en: static void staticMethod1(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface static method 1");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static void staticMethod2(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface static method 2");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: default void method1(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface default method 1");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: default void method2(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface default method 2");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method3();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a dot operator (`.`) with it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(InterfaceM.INTERFACE_FIELD);    //1: interface field'
  prefs: []
  type: TYPE_NORMAL
- en: 'InterfaceM.staticMethod1();               //2: interface static method'
  prefs: []
  type: TYPE_NORMAL
- en: 'InterfaceM.staticMethod2();               //3: interface static method'
  prefs: []
  type: TYPE_NORMAL
- en: '//InterfaceM.method1();                         //4: compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: '//InterfaceM.method2();                         //5: compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: '//InterfaceM.method3();                         //6: compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ClassM.INTERFACE_FIELD);       //7: interface field'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Cases 1, 2, and 3 are straightforward. Cases 4, 5, and 6 generate a compilation
    error because non-static methods can be accessed only via an instance (object)
    of a class that implements the interface. Case 7 is possible, but is not a recommended
    way to access interface fields (also called constants). Accessing them using the
    interface name (as in case 1) makes the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a `ClassM` class that implements the `InterfaceM` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassM implements InterfaceM {
  prefs: []
  type: TYPE_NORMAL
- en: public static String CLASS_STATIC_FIELD = "class static field";
  prefs: []
  type: TYPE_NORMAL
- en: public static void staticMethod2(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class static method 2");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void staticMethod3(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class static method 3");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String instanceField = "instance field";
  prefs: []
  type: TYPE_NORMAL
- en: public void method2(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class instance method 2");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void method3(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class instance method 3");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are all possible cases of using the dot operator (`.`) for the class
    field and method access:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '//ClassM.staticMethod1();                       //8: compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: 'ClassM.staticMethod2();                     //9: class static method 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'ClassM.staticMethod3();                    //10: class static method 3'
  prefs: []
  type: TYPE_NORMAL
- en: ClassM classM = new ClassM();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ClassM.CLASS_STATIC_FIELD);//11: class static field'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classM.CLASS_STATIC_FIELD);//12: class static field'
  prefs: []
  type: TYPE_NORMAL
- en: '//System.out.println(ClassM.instanceField);    //13: compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classM.instanceField);         //14: instance field'
  prefs: []
  type: TYPE_NORMAL
- en: '//classM.staticMethod1();                      //15: compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.staticMethod2();                   //16: class static method  2'
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.staticMethod3();                    //17: class static method 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.method1();                     //18: interface default method 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.method2();                        //19: class instance method 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.method3();                        //20: class instance method 3'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Case 8 generates a compilation error because a static method belongs to the
    class or interface (in this case) where it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Case 9 is an example of a static method hiding. A method with the same signature
    is implemented in the interface but hidden by the class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Cases 10 and 11 are straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Case 12 is possible but not recommended. Accessing a static class field using
    the class name makes the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Class 13 is an obvious error because an instance field can be accessed only
    via an instance (object).
  prefs: []
  type: TYPE_NORMAL
- en: Class 14 is a correct version of case 13.
  prefs: []
  type: TYPE_NORMAL
- en: Class 15 is an error because a static method belongs to the class or interface
    (in this case) where it is implemented, not to the class instance.
  prefs: []
  type: TYPE_NORMAL
- en: Cases 16 and 17 are possible but are not recommended ways to access a static
    method. Using the class name (instead of the instance identifier) to access static
    method makes code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Case 18 demonstrates how an interface can provide a default implementation to
    a class. That is possible because `ClassM implements InterfaceM` effectively inherits
    all the methods and fields of the interface. We say effectively because the legally
    correct terminology is class *implements* interface. But in fact, a class that
    implements an interface acquires all the fields and methods of the interface in
    the same manner a child class inherits them.
  prefs: []
  type: TYPE_NORMAL
- en: Case 19 is an example of the class overriding the default implementation of
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 20 is an example of the classic interface implementation. That was the
    original idea of an interface: to provide an abstraction of the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Cast operator:  (target type)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cast operator is used for type casting, assigning a value of one type to
    a variable of another type. Usually, it is used to enable conversions that would
    otherwise not be allowed by the compiler. We used type casting, for example, when
    we discussed integer division, the `char` type as a numeric type, and assigning
    a class reference to a variable that has a type of one of the implemented interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 11;
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 3;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((float)i1 / i2);  //prints: 3.6666667'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((int)a);          //prints: 97'
  prefs: []
  type: TYPE_NORMAL
- en: IntrfA intA = (IntrfA)classA;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two potential issues to watch while casting:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of primitive types, the value should be smaller than the maximum
    value the target type can hold (we will talk about this in detail in the *Widening
    and narrowing conversion of  primitive types* section later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of reference types, the left-hand operand should be a parent (even
    if indirect) of the right-hand operand, or the left-hand operand should be an
    interface implemented (even if indirectly) by the class represented by the right-hand
    operand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface I1{}
  prefs: []
  type: TYPE_NORMAL
- en: interface I2{}
  prefs: []
  type: TYPE_NORMAL
- en: interface I3{}
  prefs: []
  type: TYPE_NORMAL
- en: class A implements I1, I2 {}
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A implements I3{}
  prefs: []
  type: TYPE_NORMAL
- en: class C extends B {}
  prefs: []
  type: TYPE_NORMAL
- en: class D {}
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: C c = new C();    //1
  prefs: []
  type: TYPE_NORMAL
- en: A a = (A)c;       //2
  prefs: []
  type: TYPE_NORMAL
- en: I1 i1 = (I1)c;    //3
  prefs: []
  type: TYPE_NORMAL
- en: I2 i2 = (I2)c;    //4
  prefs: []
  type: TYPE_NORMAL
- en: I3 i3 = (I3)c;    //5
  prefs: []
  type: TYPE_NORMAL
- en: c = (C)a;         //6
  prefs: []
  type: TYPE_NORMAL
- en: D d = new D();    //7
  prefs: []
  type: TYPE_NORMAL
- en: //a = (A)d;       //8 compilation error
  prefs: []
  type: TYPE_NORMAL
- en: i1 = (I1)d;       //9 run-time error
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, case 6 is possible because we know that object `a` was originally
    cast based on object `c`, so we can cast it back to type `C` and expect it to
    be fully functional as an object of class `C`.
  prefs: []
  type: TYPE_NORMAL
- en: Case 8 does not compile because its parent-child relations can be verified by
    the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 9 is not so easy for the compiler for reasons that are outside the scope
    of this book. So, while writing code, the IDE will not give you a hint and you
    may think everything will work as you expect. But then at run-time, you can get
    `ClassCastException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7514f1c-0e5b-4e2e-8520-35b894fdcf81.png)'
  prefs: []
  type: TYPE_IMG
- en: Programmers are as happy to see it as much as they like to see the `NullPointerException` or
    `ArrayOutOfBoundException` we demonstrated before. That's why casting to an interface
    has to be done with more care than to a class.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting is assigning a value of one type to a variable of another type.
    While doing it, make sure that the target type can hold the value and check it
    against the maximum target type value if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to cast a primitive type to a matching reference type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer1 = 3;                  //line 1
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer1);          //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer2 = Integer.valueOf(4);
  prefs: []
  type: TYPE_NORMAL
- en: int i = integer2;                      //line 4
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i);                 //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In line 1 and line 4, casting is done implicitly. We will discuss such a casting
    (also called conversion, or boxing and unboxing) in more detail in the *Boxing
    and unboxing between a primitive and reference types* section later.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said at the beginning of this section, an expression exists only as a
    part of a statement, the latter being the complete action (we will discuss it
    in the next subsection). This means that an expression can be a building block
    of an action. Some expressions can even become a full action (an expression statement)
    after adding a semicolon to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinguishing feature of an expression is that it can be evaluated, which
    means it can produce something as the result of its execution. This something
    can be one of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable, such as `i = 2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value, such as `2*2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing, when the expression is an invocation of a method that returns nothing
    (void). Such an expression can only be the full action—an expression statement—with
    a semicolon at the end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression typically includes one or more operators and is evaluated. It
    can produce a variable, a value (that is included in further evaluation), or can
    invoke a method that returns nothing (void).
  prefs: []
  type: TYPE_NORMAL
- en: 'An evaluation of an expression can also produce a side effect. That is, in
    addition to the variable assignment or returning a value, it can do something
    else, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0, y;
  prefs: []
  type: TYPE_NORMAL
- en: y = x++;                  //line 2
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y);    //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The expression in line 2 assigns a value to variable `y`, but also has the side
    effect of adding `1` to the value of variable `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By its form, the expression can be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A primary expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal (some value)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object creation (with the `new` operator or with the `{}` array initializer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field access (with the dot operator for an external class or without it for
    this instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method invocation (with the dot operator for an external class or without
    it for this instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method reference (with the `::` operator, in lambda expressions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array access (with the `[]` notation, which carries an index of the element
    to be accessed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary operator expression (`x++` or `-y`, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary operator expression (`x+y` or `x*y`, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A ternary operator expression (`x > y ? "x>y" : "x<=y"`, for example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lambda expression `i -> i + 1` (see [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expressions are named according to the action they produce: an object creation
    expression, a cast expression, a method invocation expression, an array access
    expression, an assignment expression, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: An expression that consists of other expressions is called a complex expression.
    Parentheses are often used to clearly identify each of the sub-expressions, instead
    of relying on the operator precedence (see the *Operators precedence and evaluation
    order of operands* section later).
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We actually defined a statement once in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics.* It is a complete action that can be executed. It can include
    one or more expressions and ends with a semicolon `;`.
  prefs: []
  type: TYPE_NORMAL
- en: A Java statement describes an action. It is a minimal construct that can be
    executed. It may or may not include one or more expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible kinds of Java statements are:'
  prefs: []
  type: TYPE_NORMAL
- en: A class or interface declaration statement, such as `class A {...}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty statement that consists of only one symbol, `;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local variable declaration statement, `int x;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A synchronized statement – outside the scope of this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An expression statement, which can be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method invocation statement, such as `method();`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment statement, such as `x = 3;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object creation statement, such as `new SomeClass();`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary increment or decrement statement, such as `++x ;`  `--x;`  `x++;`  `x--;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A control flow statement (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A selection statement: `if-else` or `switch-case`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iteration statement: `for`, `while`, or `do-while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception handling statement, such as `try-catch-finally` or `throw`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A branching statement, such as `break`, `continue`, `label:`, `return`, `assert`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A statement can be *labeled *by placing an identifier and colon `:` in front
    of it. This label can be used by the branching statements `break` and `continue`
    to redirect the control flow. In [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*, we will show you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Most often, statements compose a method body, and that is how programs are written.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence and evaluation order of operands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When several operators are used in the same expression, it might not be obvious
    how to execute them without established rules. For example, what is the value
    that is going to be assigned to variable `x` after the following right-hand expression
    is evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 2 + 4 * 5 / 6 + 3 + 7 / 3 * 11 - 4;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know how to do it because we have learned operator precedence in school—just
    apply the multiplication and division operators first from left to right, then
    addition and subtraction from left to right too. But, it turned out that the author
    actually wanted this sequence of operator execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 2 + 4 * 5 / 6 + ( 3 + 7 / 3 * (11 - 4));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It yields a different result.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence and parentheses determines the sequence in which parts of
    an expression are evaluated. The evaluation order of operands defines for each
    operation the sequence in which its operands are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses help to identify the structure of a complex expression and establish
    the sequence of evaluation, which overrides the operator precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java specification does not provide operator precedence in one place. One
    has to pull it together from various sections. That's why different sources on
    the internet sometimes have a bit of a different sequence of operator execution,
    so do not be surprised, and if in doubt, experiment or just set the parentheses
    to guide the calculations in the sequence you need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the operator precedence from the highest (the first
    executed) as the first in the list, to the lowest precedence at the end. Operators
    of the same level of precedence are executed by their position in the expression
    while moving from left to right (provided no parentheses are used):'
  prefs: []
  type: TYPE_NORMAL
- en: An expression that calculates the index of an array element inside the `[]` notation,
    such as `x = 4* arr[i+1]`; the field access and method invocation dot operator `.`,
    such as in `x = 3*someClass.COUNT` or `x = 2*someClass.method(2, "b")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unary postfix increment `++` and decrement `--` operators, such as `x++` or
    `x--`, as in `int m = 5*n++`; notice that such an operator returns the old value
    of the variable before it increments/decrements its value, thus having the side
    effect of incrementing the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary prefix with the `++` and `--` operators, such as `++x` or `--x`; unary
    `+` and `-` operators, such as in `+x` or `-x`; the logical operator NOT, such
    as in `!b`, where b is a Boolean variable; unary bitwise NOT `~` (outside the
    scope of this book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cast operator `()`, such as `double x = (double)11/3`, where 11 is cast to
    `double` first, thus avoiding the integer division problem of losing the fractional
    part; the instance creation operator `new`, such as in `new SomeClass()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplicative operators `*`, `/`, `%`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additive operators `+`, `-`, string concatention `+`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise shift operators `<<`, `>>`, `>>>`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators `<`, `>`, `>=`, `<=`, `instanceof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equality operators `==`, `!=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical and bitwise operator `&`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bitwise operator `^`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical and bitwise operator `|`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operator `&&`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operator `||`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operator `?:` (ternary)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrow operator `->`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment operators `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `>>=`, `<<=`, `>>>=`,
    `&=`, `^=`, `|=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If parentheses are present, then the expression inside the innermost parentheses
    is calculated first. For example, look at this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int p1 = 10, p2 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: int q = (p1 += 3)  +  (p2 += 3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(q);         //prints: 17'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p1);        //prints: 13'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p2);        //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The assignment operators have the lowest precedence, but they are executed
    first if inside the parentheses, as in the preceding code. To prove this point,
    we can remove the first set of parentheses and run the same code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: p1 = 10;
  prefs: []
  type: TYPE_NORMAL
- en: p2 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: q = p1 += 3  +  (p2 += 3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(q);         //prints: 17'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p1);        //prints: 17'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p2);        //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, now the first operator assignment `+=` was executed last in
    the right-hand expression.
  prefs: []
  type: TYPE_NORMAL
- en: Using parentheses increases the readability of a complex expression.
  prefs: []
  type: TYPE_NORMAL
- en: You can take advantage of operator precedence and write an expression with very
    few parentheses, if any at all. But the quality of code is defined not only by
    its correctness. Being easy to understand, so that other programmers—maybe not
    so well versed in operator precedence—can maintain it is also one of the criteria
    for well-written code. Besides, even the code's author, after some time, may have
    difficulty trying to understand not-clearly-structured expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation order of operands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While evaluating an expression, parentheses and operator precedence are taken
    into account first. Then, those parts of the expression that have the same level
    of execution priority are evaluated as they appear when moving from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Using parentheses improves the understanding of a complex expression, but too
    many nested parentheses can obscure it. If in doubt, consider breaking the complex
    expression into several statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the evaluation comes down to each operator and its operands. Operands
    of a binary operator are evaluated from left to right so that left-hand operand
    is fully evaluated before the evaluation of the right-hand operator starts. As
    we have seen, the left-hand operand can have a side effect that affects the right-hand
    operator''s behavior. Here is a simplistic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int a = 0, b = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'int c = a++ + (a * ++b);       //evaluates to: 0 + (1 * 1);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In real-life examples, the expression can include methods with complex functionality
    behind and wide-reaching side effects. The left-hand operand can even throw an
    exception, so the right-hand operand will never be evaluated. But if the left-hand
    evaluation completes without exceptions, Java guarantees that both operands are
    fully evaluated before the operator is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule does not apply though to conditional operators `&&`, `||`, and `?:` (see
    the *Conditional operators: && || ? : (ternary)* section).'
  prefs: []
  type: TYPE_NORMAL
- en: Widening and narrowing reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of reference types, assigning a child object reference to the variable
    of the parent class type is called widening reference conversion or upcasting.
    The assigning of a parent class type reference to the variable of a child class
    type is called narrowing reference conversion or downcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Widening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For example, if a class, `SomeClass`, extends `SomeBaseClass`, the following
    declaration and initialization are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, since every class extends the `java.lang.Object` class by default, the
    following declarations and initializations are possible too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Object someBaseClass = new SomeBaseClass();
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();             //line 2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In line 2, we assigned a subclass instance reference to a variable of a superclass
    type. Methods present in a subclass but not in the superclass are not accessible
    via the reference of the superclass type. The assignment in line 2 is called a
    widening of the reference because it becomes less specialized.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assigning a parent object reference to the variable of the child class type
    is called narrowing reference conversion or downcasting. It is possible only after
    widening reference conversion has been applied first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeBaseClass{
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass extends SomeBaseClass{
  prefs: []
  type: TYPE_NORMAL
- en: void someOtherMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass.someMethod();                  //works just fine
  prefs: []
  type: TYPE_NORMAL
- en: //someBaseClass.someOtherMethod();           //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: ((SomeClass)someBaseClass).someOtherMethod(); //works just fine
  prefs: []
  type: TYPE_NORMAL
- en: '//The following methods are available as they come from Object:'
  prefs: []
  type: TYPE_NORMAL
- en: int h = someBaseClass.hashCode();
  prefs: []
  type: TYPE_NORMAL
- en: Object o = someBaseClass.clone();
  prefs: []
  type: TYPE_NORMAL
- en: //All other public Object's methods are accessible too
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The narrowing conversion requires casting, and we discussed this in great detail
    when we talked about the cast operator (see the *Cast operator* section), including
    casting to an interface, which is another form of upcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Widening and narrowing conversion of primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a value (or variable) of one numeric type is assigned to a variable of
    another numeric type, the new type may hold a bigger number or smaller maximum
    number. If the target type can hold a bigger number, the conversion is widening.
    If otherwise, it is a narrowing conversion, which usually requires a typecasting
    using a cast operator.
  prefs: []
  type: TYPE_NORMAL
- en: Widening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maximum number a numeric type can hold is determined by the number of bits
    allocated to this type. To remind you, here is the number of bits for each numeric
    type representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: 8 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: 16 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: 16 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: 32 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: 64 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: 32 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: 64 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Java Specification defines 19 widening primitive conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte` to `short`, `int`, `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short` to `int`, `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` to `int`, `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to `long`, `float`, or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` to `float` or `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In widening conversions between integral types and some conversions from integral
    types to floating-point values, the resulting value remains the same as the original
    one. But conversion from `int` to `float`, or from `long` to `float`, or from
    `long` to `double`, may result, according to the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '"in loss of precision - that is, the result may lose some of the least significant
    bits of the value. In this case, the resulting floating-point value will be a
    correctly rounded version of the integer value, using IEEE 754 round-to-nearest
    mode."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this effect through code examples and start with `int` type
    conversion to `float` and `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int n = 1234567899;
  prefs: []
  type: TYPE_NORMAL
- en: float f = (float)n;
  prefs: []
  type: TYPE_NORMAL
- en: int r = n - (int)f;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);    //prints: -46'
  prefs: []
  type: TYPE_NORMAL
- en: double d = (double)n;
  prefs: []
  type: TYPE_NORMAL
- en: r = n - (int)d;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);    //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the specification stated, only the conversion from `int` to `float` has
    lost precision. Conversion from `int` to `double` was just fine. Now, let''s convert `long` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long l = 1234567899123456L;
  prefs: []
  type: TYPE_NORMAL
- en: float f = (float)l;
  prefs: []
  type: TYPE_NORMAL
- en: long rl = l - (long)f;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(rl);    //prints: -49017088'
  prefs: []
  type: TYPE_NORMAL
- en: double d = (double)l;
  prefs: []
  type: TYPE_NORMAL
- en: rl = l - (long)d;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(rl);    //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: l = 12345678991234567L;
  prefs: []
  type: TYPE_NORMAL
- en: d = (double)l;
  prefs: []
  type: TYPE_NORMAL
- en: rl = l - (long)d;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(rl);    //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Conversion from `long` to `float` lost precision big time. Well, the specification
    warned us about it. But conversion from `long` to `double` looked fine at first.
    Then, we increased the `long` value approximately ten times and got a precision
    loss of `-1`. So, it depends on how big the value is too.
  prefs: []
  type: TYPE_NORMAL
- en: Despite that, the Java specification does not allow any runtime exceptions caused
    by widening conversion. In our examples, we did not encounter an exception either.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The narrowing conversion of numeric primitive types occurs in the opposite
    direction—from the wider type to the narrower one—and typically requires casting.
    The Java specification identifies 22 narrowing primitive conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`short` to `byte` or `char`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` to `byte` or `short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to `byte`, `short`, or `char`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` to `byte`, `short`, `char`, or `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `byte`, `short`, `char`, `int`, or `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` to `byte`, `short`, `char`, `int`, `long`, or `float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can result in a loss of magnitude of the value and possibly in loss of precision
    too. The narrowing procedure is more complicated than the widening one and discussion
    of it is beyond the scope of an introductory course. The least one can do is to
    make sure that the original value is smaller than the maximum value of the target
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double dd = 1234567890.0;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Integer.MAX_VALUE); //prints: 2147483647'
  prefs: []
  type: TYPE_NORMAL
- en: if(dd < Integer.MAX_VALUE){
  prefs: []
  type: TYPE_NORMAL
- en: int nn = (int)dd;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(nn);              //prints: 1234567890'
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(dd - Integer.MAX_VALUE);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: dd = 2234567890.0;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Integer.MAX_VALUE); //prints: 2147483647'
  prefs: []
  type: TYPE_NORMAL
- en: if(dd < Integer.MAX_VALUE){
  prefs: []
  type: TYPE_NORMAL
- en: int nn = (int)dd;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(nn);
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(dd - Integer.MAX_VALUE); //prints: 8.7084243E7'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these examples, the narrowing conversion happens just fine
    when the number fits the target type, but we even do not try to convert if the
    original value is bigger than the maximum value of the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Before casting, think about the maximum value the target type can hold, especially
    while narrowing the value type.
  prefs: []
  type: TYPE_NORMAL
- en: But there is more to it than just avoiding complete loss of value. Things get
    especially complicated with the conversion between type `char` and types `byte`
    or `short`. The reason for this is that type `char` is an unsigned numeric type,
    while types byte and short are signed numeric types, so some loss of information
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of primitive type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting is not the only way to convert one primitive type to another. Each of
    the primitive types has a corresponding reference type – a class called a wrapper
    class of a primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'All wrapper classes are located in the `java.lang` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Character`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Integer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of them—except the `Boolean` and `Character` classes—extend the `java.lang.Number` class, which
    has the following abstract method declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byteValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shortValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`floatValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doubleValue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that every `Number` class child has to implement all of them. Such
    methods are implemented in the `Character` class too, while the `Boolean` class
    has the `booleanValue()` method. These methods can be used to widen and narrow primitive
    types too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each of the wrapper classes has methods that allow the conversion
    of `String` representation of a numeric value to the corresponding primitive numeric
    type or reference type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: byte b = Byte.parseByte("3");
  prefs: []
  type: TYPE_NORMAL
- en: Byte bt = Byte.decode("3");
  prefs: []
  type: TYPE_NORMAL
- en: boolean boo = Boolean.getBoolean("true");
  prefs: []
  type: TYPE_NORMAL
- en: Boolean bool = Boolean.valueOf("false");
  prefs: []
  type: TYPE_NORMAL
- en: int n = Integer.parseInt("42");
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer = Integer.getInteger("42");
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = Double.parseDouble("3.14");
  prefs: []
  type: TYPE_NORMAL
- en: Double d2 = Double.valueOf("3.14");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: After that, the previously listed methods (`byteValue()`, `shortValue()`, and
    so on) can be used to convert the value to another primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'And each of the wrapper classes has the static method `toString(primitive value)`
    to convert the primitive type value to its `String` representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = Integer.toString(42);
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = Double.toString(3.14);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper classes have many other useful methods of conversion from one primitive
    type to another, and to different formats and representations. So, if you need
    to something like that, look in the `java.lang` package at its numeric type class
    wrappers first.
  prefs: []
  type: TYPE_NORMAL
- en: One of the type conversions allows for creating a wrapper class object from
    the corresponding primitive type and vice versa. We will discuss such conversions
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and unboxing between primitive and reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boxing converts the value of a primitive type to an object of a corresponding
    wrapper class. Unboxing converts the object of a wrapper class to a value of the
    corresponding primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boxing a primitive type can be done either automatically (called autoboxing)
    or explicitly using the `valueOf()` method available in each wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int n = 12;
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer = n; //an example of autoboxing
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer);      //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: integer = Integer.valueOf(n);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer);      //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: Byte b = Byte.valueOf((byte)n);
  prefs: []
  type: TYPE_NORMAL
- en: Short s = Short.valueOf((short)n);
  prefs: []
  type: TYPE_NORMAL
- en: Long l = Long.valueOf(n);
  prefs: []
  type: TYPE_NORMAL
- en: Float f = Float.valueOf(n);
  prefs: []
  type: TYPE_NORMAL
- en: Double d = Double.valueOf(n);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the input value of the `valueOf()` method of the `Byte` and `Short`
    wrappers required casting because it was a narrowing of a primitive type, which
    we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Unboxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unboxing can be accomplished using the methods of the `Number` class implemented
    in each wrapper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer = Integer.valueOf(12);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.intValue());    //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.byteValue());   //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.shortValue());  //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.longValue());   //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.floatValue());  //prints: 12.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.doubleValue()); //prints: 12.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to autoboxing, automatic unboxing is possible too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Long longWrapper = Long.valueOf(12L);
  prefs: []
  type: TYPE_NORMAL
- en: long lng = longWrapper;    //implicit unboxing
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lng);   //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But, it is not called autounboxing. The term implicit unboxing is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Method equals() of reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The equality operator, when applied to reference types, compares the reference
    values, not the content of the objects. It returns `true` only when both references
    (variable values) point to the same object. We have demonstrated it several times
    already:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass o1 = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass o2 = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(o1 == o2);  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(o1 == o1);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: o2 = o1;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(o1 == o2);  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the equality operator returns `false` even when two objects
    of the same class with the same field values are compared. That is often not what
    programmers need. Instead, we usually need to consider two objects to be equal
    when they have the same type and the same field values. Sometimes, we even do
    not want to consider all the fields, but only those that identify the object as
    unique in our program logic. For example, if a person changes their hairstyle
    or dress, we still identify him or her as the same person, even if an object that
    describes the person has the field `hairstyle` or `dress`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the implementation of the base class Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For such a comparison of objects—by the value of their fields—the `equals()` method is
    to be used. In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, we already established that all reference types extend (implicitly)
    the `java.lang.Object` class, which has the `equals()` method implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object obj) {
  prefs: []
  type: TYPE_NORMAL
- en: return (this == obj);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it compares only references using the equality operator, which
    means that if a class or one of its parents does not implement the `equals()` method (which
    overrides the implementation of the `Object` class), the result of using the `equals()` method will
    be the same as using the equality operator `==`. Let''s demonstrate this. The
    following class does not implement the `equals()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class PersonNoEquals {
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: public PersonNoEquals(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use it and compare the results of the `equals()` method and the `==` operator,
    we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: PersonNoEquals p1 = new PersonNoEquals(42, "Nick");
  prefs: []
  type: TYPE_NORMAL
- en: PersonNoEquals p2 = new PersonNoEquals(42, "Nick");
  prefs: []
  type: TYPE_NORMAL
- en: PersonNoEquals p3 = new PersonNoEquals(25, "Nick");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1.equals(p2));     //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1.equals(p3));     //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1 == p2);          //false
  prefs: []
  type: TYPE_NORMAL
- en: p1 = p2;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1.equals(p2));     //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1 == p2);          //true
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As we expected, the results are the same, whether we use the `equals()` method or
    the `==` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the equals() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `equals()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class PersonWithEquals{
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: private String hairstyle;
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithEquals(int age, String name, String hairstyle) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.hairstyle = hairstyle;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals person = (PersonWithEquals) o;
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.age && Objects.equals(name, person.name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, while establishing the objects'' equality, we ignore the `hairstyle` field.
    Another aspect that requires comments is the use of the `equals()` method of the `java.utils.Objects` class.
    Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static boolean equals(Object a, Object b) {
  prefs: []
  type: TYPE_NORMAL
- en: return (a == b) || (a != null && a.equals(b));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it compares references first, then makes sure that one is not
    `null` (to avoid `NullPointerException`), then uses the `equals()` method of the `java.lang.Object` base
    class or the overriding implementation that might be present in a child passed
    in as a parameter value.  In our case, we pass in parameter objects of type `String`
    that do have the `equals()` method implemented, which compares `String` type values,
    not just references (we will talk about it shortly). So, any difference in any
    field of objects, `PersonWithEquals`, will cause the method to return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the test again, we will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals p11 = new PersonWithEquals(42, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals p12 = new PersonWithEquals(42, "Kelly", "Pompadour");
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals p13 = new PersonWithEquals(25, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11.equals(p12));    //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11.equals(p13));    //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11 == p12);         //false
  prefs: []
  type: TYPE_NORMAL
- en: p11 = p12;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11.equals(p12));    //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11 == p12);         //true
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `equals()` method returns `true` not only when references are equal
    (so they point to the same object), but also when the references are different
    but the objects they refer to have the same type and the same values of certain
    fields that are included in the object identification.
  prefs: []
  type: TYPE_NORMAL
- en: Using the identification implemented in the parent class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could create a base class, `Person`, that has only the two fields `age`
    and `name` and the `equals()` method, as implemented previously. Then, we could
    extend it with the `PersonWithHair` class (which has the additional field `hairstyle`):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person{
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person) o;
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.age && Objects.equals(name, person.name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class PersonWithHair extends Person{
  prefs: []
  type: TYPE_NORMAL
- en: private String hairstyle;
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithHair(int age, String name, String hairstyle) {
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name);
  prefs: []
  type: TYPE_NORMAL
- en: this.hairstyle = hairstyle;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects of the `PersonWithHair` class would compare the same way as in
    the previous test of `PersonWithEquals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHair p21 = new PersonWithHair(42, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHair p22 = new PersonWithHair(42, "Kelly", "Pompadour");
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHair p23 = new PersonWithHair(25, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21.equals(p22));    //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21.equals(p23));    //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21 == p22);         //false
  prefs: []
  type: TYPE_NORMAL
- en: p21 = p22;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21.equals(p22));    //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21 == p22);         //true
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is possible because an object of `PersonWithHair` is of a type `Person`
    too, so take this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person) o;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding line in the `equals()` method does not throw `ClassCastException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create the `PersonWithHairDresssed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHairDressed extends PersonWithHair{
  prefs: []
  type: TYPE_NORMAL
- en: private String dress;
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithHairDressed(int age, String name,
  prefs: []
  type: TYPE_NORMAL
- en: String hairstyle, String dress) {
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name, hairstyle);
  prefs: []
  type: TYPE_NORMAL
- en: this.dress = dress;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the same test again, it will yield the same results. But we think
    that dress and hairstyle are not part of the identification, so we can run the
    test to compare the children of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
  prefs: []
  type: TYPE_NORMAL
- en: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p32));    //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p33));    //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31 == p32);         //false
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That was not what we expected! The children were considered not equal because
    of this line in the `equals()` method of the `Person` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding line failed because the `getClass()` and `o.getClass()` methods return
    the child class name – the one that was instantiated with the `new` operator.
    To get out of this jam, we use the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of the `equals()` method is located in the `Person` class,
    so we know that the current object is of type `Person`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare classes, all we need to do is to make sure that the other object
    is of type `Person` too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we replace this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: if(!(o instanceof Person)) return false;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
  prefs: []
  type: TYPE_NORMAL
- en: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p32));    //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p33));    //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31 == p32);         //false
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is what we wanted, didn't we? This way, we have achieved the original idea
    of not including hairstyle and dress in the person's identification.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of object references, the equality operators `==` and `!=` compare
    the references themselves - not the values of the objects' fields (states). If
    you need to compare object states, use the `equals()` method that has overridden
    the one in the `Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `String` class and the wrapper classes of primitive types override the `equals()` method too.
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method of the String class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*, we have already discussed this and even reviewed the source
    code. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object anObject) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == anObject) {
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (anObject instanceof String) {
  prefs: []
  type: TYPE_NORMAL
- en: String aString = (String)anObject;
  prefs: []
  type: TYPE_NORMAL
- en: if (coder() == aString.coder()) {
  prefs: []
  type: TYPE_NORMAL
- en: return isLatin1() ?
  prefs: []
  type: TYPE_NORMAL
- en: StringLatin1.equals(value, aString.value)
  prefs: []
  type: TYPE_NORMAL
- en: ': StringUTF16.equals(value, aString.value);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it overrides the `Object` class implementation in order to
    compare values, not just references. This code proves it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String sl1 = "test1";
  prefs: []
  type: TYPE_NORMAL
- en: String sl2 = "test2";
  prefs: []
  type: TYPE_NORMAL
- en: String sl3 = "test1";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1 == sl2);              //1: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1.equals(sl2));         //2: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1 == sl3);              //3: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1.equals(sl3));         //4: true'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = new String("test1");
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = new String("test2");
  prefs: []
  type: TYPE_NORMAL
- en: String s3 = new String("test1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1 == s2);                //5: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1.equals(s2));           //6: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1 == s3);                //7: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1.equals(s3));           //8: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1 == s1);               //9: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1.equals(s1));          //10: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the equality operator `==` sometimes compares the `String`
    object values correctly and sometimes doesn't. The `equal()` method, though, always compares
    the values correctly, even if they are wrapped in different objects, not just
    refer literals.
  prefs: []
  type: TYPE_NORMAL
- en: We included the equality operator in the test in order to clarify the cases
    of incorrect explanation of `String` values one can read on the internet more
    often than one might expect. The incorrect explanation is based on the JVM implementation
    that supports `String` instance immutability (read about `String` immutability
    and the motivation for it in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*). The JVM does not store the same `String` value
    twice and reuses the value already stored in the area called the **string pool** in
    the process called **strings interning**.  After learning about that, some people
    assume that using the `equals()` method with `String` values is unnecessary because
    the same value will have the same reference value anyway. Our test proves that,
    in the case of a `String` value wrapped in the class `String`, its value cannot
    be compared correctly by the equality operator and one must use the `equals()` method instead.
    There are also other cases when a `String` value is not stored in the string pool.
  prefs: []
  type: TYPE_NORMAL
- en: To compare two `String` objects by value, always use the `equals()` method,
    not the equality operator `==`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the `equals()`method is not as fast as the  `== `operator. But,
    as we already pointed out in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types,* the `equals()` method of class String compares
    references first, which means there is no need to try to save performance time and
    compare references in the code before calling the `equals()` method. Just call
    the `equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The ambiguity of `String` type behavior—sometimes like a primitive type, other
    times like a reference type—reminds me of the double nature of elementary particles
    in physics. Particles sometimes behave like small concentrated objects, but other
    times like waves. What is really going on behind the scenes, deep in the guts
    of the matter? Is something is immutable there too?
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method in wrapper classes of primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run the test for a wrapper class, the results will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long ln = 42;
  prefs: []
  type: TYPE_NORMAL
- en: Integer n = 42;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(42));      //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(ln));      //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(43));      //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(Integer.valueOf(42)));  //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(Long.valueOf(42)));     //false
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our experience with the children of `Person`, we can quite confidently
    assume that the `equals()` methods of the wrapper classes include the comparison
    of class names. Let''s look at the source code. Here is the `equals()` method
    of the `Integer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object obj) {
  prefs: []
  type: TYPE_NORMAL
- en: if (obj instanceof Integer) {
  prefs: []
  type: TYPE_NORMAL
- en: return value == ((Integer)obj).intValue();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is exactly what we expected. If an object is not an instance of the `Integer` class,
    it can never be considered equal to an object of another class, even if it carries
    exactly the same numeric value. It looks like the system of social classes in
    the olden days, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Naming the statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the following statements called?
  prefs: []
  type: TYPE_NORMAL
- en: '`i++;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String s;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s = "I am a string";`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doSomething(1, "23");`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following statements are called:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Increment statement: `i++;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable declaration statement: `String s;  `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assignment statement: `s = "I am a string";`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method invocation statement: `doSomething(1, "23");`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned what the three core elements of Java programming
    are—operators, expressions, and statements—and how they are related to each other.
    We walked you through all the Java operators, discussed the most popular ones
    with examples, and explained the potential issues with using them. A substantial
    part of this chapter was dedicated to data type conversion: widening and narrowing,
    boxing, and unboxing. The `equals()` method of reference types was also demonstrated
    and tested on specific examples for a variety of classes and implementations.
    The `String` class was used prominently and the popular incorrect explanation
    of its behavior was resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will start writing the program logic—the backbone of
    any execution flow—using control flow statements, which are going to be defined,
    explained, and demonstrated in many examples: conditional statements, iterative
    statements, branching statements, and exceptions.'
  prefs: []
  type: TYPE_NORMAL
