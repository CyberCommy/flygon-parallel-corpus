- en: Operators, Expressions, and Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符、表达式和语句
- en: In this chapter, the three core elements of Java programming—operators, expressions,
    and statements—will be defined and explained in detail. The discussion will be
    supported by specific examples that illustrate the key aspects of these elements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将详细定义和解释Java编程的三个核心元素-运算符、表达式和语句。讨论将通过具体示例来支持，以说明这些元素的关键方面。
- en: 'The following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: What are the core elements of Java programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java编程的核心元素是什么？
- en: Java operators, expressions, and statements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java运算符、表达式和语句
- en: Operator precedence and evaluation order of operands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符优先级和操作数的求值顺序
- en: Widening and narrowing the conversion of primitive types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型的扩展和缩小转换
- en: Boxing and unboxing between primitive and reference types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型和引用类型之间的装箱和拆箱
- en: The `equals()` method of reference types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型的equals()方法
- en: Exercise – Naming the statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-命名语句
- en: What are the core elements of Java programming?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java编程的核心元素是什么？
- en: In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language Basics*,
    we had an overview of many aspects of Java as a language, and even defined what
    statements are. Now, we will look closer into the core elements of Java more systematically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中，*Java语言基础*，我们概述了Java作为一种语言的许多方面，甚至定义了语句是什么。现在，我们将更系统地研究Java的核心元素。
- en: 'The word "elements" is quite overloaded (playing on the analogy with method
    overload). In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*, we introduced input elements, those that are identified by
    the Java specification: whitespace, comment, and token. That is how the Java compiler
    parses the source code and makes sense of it. The list of tokens includes identifiers,
    keywords, separators, literals, and operators. That is how the Java compiler adds
    more meaning to the tokens it encounters.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “元素”这个词有点过载（玩弄方法重载的类比）。在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们介绍了输入元素，这些元素是由Java规范标识的：空格、注释和标记。这就是Java编译器解析源代码并理解其含义的方式。标记列表包括标识符、关键字、分隔符、文字和运算符。这就是Java编译器如何为其遇到的标记添加更多含义。
- en: While discussing the input elements, we explained that they are used to build
    more complex elements of language. In this chapter, we will start with the operator token and
    show how an expression—a more complex Java element—is constructed with it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论输入元素时，我们解释了它们用于构建语言的更复杂元素。在本章中，我们将从运算符标记开始，展示如何使用表达式-更复杂的Java元素来构建它。
- en: But, not all Java operators are tokens. The `instanceof` and `new` operators are
    keywords, while the `.` operator (field access or method invocation), the `::` method
    reference operator, and the `( type )` cast operator are separators.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有Java运算符都是标记。`instanceof`和`new`运算符是关键字，而`.`运算符（字段访问或方法调用）、`::`方法引用运算符和`(
    type )`强制转换运算符是分隔符。
- en: As we said in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, a statement in Java plays a role similar to a sentence in the
    English language, which expresses a complete thought.  In a programming language,
    a statement is a complete line of code that performs some action.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中所说的，*Java语言基础*，在Java中，语句的作用类似于英语中的句子，它表达了一个完整的思想。在编程语言中，语句是一行完整的代码，执行某些操作。
- en: An expression, on the other hand, is a part of a statement that evaluates to
    a value. Every expression can be a statement (if the resulting value is ignored),
    while most statements do not include expressions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，表达式是语句的一部分，它求值为一个值。每个表达式都可以是一个语句（如果结果值被忽略），而大多数语句不包括表达式。
- en: That is how the three core elements of Java—operator, expression, and statement—are
    related.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java的三个核心元素-运算符、表达式和语句的关系。
- en: Operators
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Here is the list of all 44 operators in Java:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java中所有44个运算符的列表：
- en: '| **Operators** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '**运算符** **描述**'
- en: '| `+`, `-`, `*`, `/`, `%` | Arithmetic unary and binary operators |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: 算术一元和二元运算符
- en: '| `++`, `--` | Increment and decrement unary operators |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: 递增和递减一元运算符
- en: '| `==`, `!=` | Equality operators |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: 相等运算符
- en: '| `<`, `>`, `<=`, `>=` | Relational operators |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: 关系运算符
- en: '| `!`, `&`, `&#124;` | Logical operators |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: 逻辑运算符
- en: '| `&&`, `&#124;&#124;`, `?`, `:` | Conditional operators |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: 条件运算符
- en: '| `=`, `+=`, `-=`, `*=`, `/=`, `%=` | Assignment operators |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: 赋值运算符
- en: '| `&=`, `&#124;=`, `^=`, `<<=`, `>>=`, `>>>=` | Assignment operators |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: 赋值运算符
- en: '| `&`, `&#124;`, `~`, `^`, `<<`, `>>`, `>>>` | Bitwise operators |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: 按位运算符
- en: '| `->`, `::` | Arrow and method reference operators |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: 箭头和方法引用运算符
- en: '| `new` | Instance creation operator |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: 实例创建运算符
- en: '| `.` | Field access/method invocation operator |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: 字段访问/方法调用运算符
- en: '| `instanceof` | Type comparison operator |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: 类型比较运算符
- en: '| `( target type )` | Cast operator |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: （目标类型）强制转换运算符
- en: Unary means used with a single operand, while binary means it requires two operands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一元意味着与单个操作数一起使用，而二元意味着它需要两个操作数。
- en: In the following subsections, we will define and demonstrate most of the operators,
    except the rarely used assignment operators `&=`,  `|=`,  `^=`,  `<<=`,  `>>=`,
    and  `>>>=`, and the bitwise operators.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将定义并演示大多数运算符，除了很少使用的赋值运算符`&=`、`|=`、`^=`、`<<=`、`>>=`和`>>>=`，以及按位运算符。
- en: Also, please notice that the `&` and `|` operators behave differently if applied
    to integer (bitwise) and Boolean (logical) values. In this book, we will discuss
    these operators only as logical operators.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，如果应用于整数（按位）和布尔值（逻辑），`&`和`|`运算符的行为是不同的。在本书中，我们将仅讨论这些运算符作为逻辑运算符。
- en: The arrow operator `->` and the method reference operator `::` will be defined
    and discussed in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头运算符`->`和方法引用运算符`::`将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中定义和讨论，*Lambda表达式和函数式编程*。
- en: Arithmetic unary (+  -) and binary operators:  +   -   *   /   %
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术一元（+ -）和二进制运算符：+  -  *  /  %
- en: 'The best way to understand operators is to see them in action. Here is our
    demo application code (with results captured in comments) that explains the unary
    operators `+` and `-`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理解运算符的最佳方法是看它们的实际应用。以下是我们的演示应用程序代码（其中包含在注释中捕获的结果），解释了一元运算符`+`和`-`：
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Ch09DemoApp {
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: public class Ch09DemoApp {
- en: public static void main(String[] args) {
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: int i = 2;   //unary "+" is assumed by default
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;   //默认情况下假定为一元“+”
- en: int x = -i;  //unary "-" makes positive become negative
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: int x = -i;  //一元“-”使正数变为负数
- en: 'System.out.println(x);   //prints: -2'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);   //输出：-2
- en: int y = -x;  //unary "-" makes negative become positive
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: int y = -x;  //一元“-”使负数变为正数
- en: 'System.out.println(y);   //prints: 2'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(y);   //输出：2
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the following code demonstrates the binary operators  `+`, `-`, `*`, `/`,
    and `%`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了二进制运算符`+`、`-`、`*`、`/`和`%`：
- en: '```java'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int z = x + y;              //binary "+" means "add"
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: int z = x + y;              //二进制“+”表示“相加”
- en: 'System.out.println(z);      //prints: 0'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：0
- en: z = x - y;                  //binary "-" means "subtract"
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: z = x - y;                  //二进制“-”表示“减去”
- en: 'System.out.println(z);      //prints: -4'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：-4
- en: 'System.out.println(y - x);  //prints: 4'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(y - x);  //输出：4
- en: z = x * y;
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: z = x * y;
- en: 'System.out.println(z);      //prints: -4'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：-4
- en: z = x / y;
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: z = x / y;
- en: 'System.out.println(z);      //prints: -1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：-1
- en: z = x * y;
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: z = x * y;
- en: 'System.out.println(z % 3);  //prints: -1'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z % 3);  //输出：-1
- en: 'System.out.println(z % 2);  //prints: 0'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z % 2);  //输出：0
- en: 'System.out.println(z % 4);  //prints: 0'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z % 4);  //输出：0
- en: '```'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you have probably guessed, the `%` operator (called modulus) divides the
    left-hand operand by the right-hand operand and returns the remainder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，`%`运算符（称为模数）将左操作数除以右操作数，并返回余数。
- en: 'Everything looks logical and as expected. But, then we try to divide one integer
    by another integer with the remainder and do not get what was expected:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很合乎逻辑和预期。但是，当我们尝试用余数除以另一个整数时，却没有得到预期的结果：
- en: '```java'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 11;
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 11;
- en: int i2 = 3;
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 3;
- en: 'System.out.println(i1 / i2); //prints: 3 instead of 3.66...'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 / i2); //输出：3 而不是3.66...
- en: 'System.out.println(i1 % i2); //prints remainder: 2'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 % i2); //输出余数：2
- en: '```'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The result, `i1/i2`, should be bigger than `3`. It has to be `3.66...` or something
    similar. The problem is caused by the fact that all the numbers involved in the
    operation are integers. In such a case, Java assumes that the result should also
    be expressed as an integer and drops (without rounding) the fractional part.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果`i1/i2`应该大于`3`。它必须是`3.66...`或类似的值。问题是由于操作中涉及的所有数字都是整数引起的。在这种情况下，Java假设结果也应该表示为整数，并丢弃（不四舍五入）小数部分。
- en: 'Now, let''s declare one of the operands as the `double` type, with the same
    value of 11, and try the division again:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将操作数之一声明为`double`类型，值为11，并再次尝试除法：
- en: '```java'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double d1 = 11;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 11;
- en: 'System.out.println(d1/i2);    //prints: 3.6666666666666665'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(d1/i2);    //输出：3.6666666666666665
- en: '```'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This time, we got what was expected, and there are other ways to achieve the
    same result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们得到了预期的结果，还有其他方法可以实现相同的结果：
- en: '```java'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println((float)i1 / i2);  //prints: 3.6666667'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((float)i1 / i2);  //输出：3.6666667
- en: 'System.out.println(i1 / (double)i2); //prints: 3.6666666666666665'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 / (double)i2); //输出：3.6666666666666665
- en: 'System.out.println(i1 * 1.0 / i2);   //prints: 3.6666666666666665'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 * 1.0 / i2);   //输出：3.6666666666666665
- en: 'System.out.println(i1 * 1f / i2);    //prints: 3.6666667'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 * 1f / i2);    //输出：3.6666667
- en: 'System.out.println(i1 * 1d / i2);    //prints: 3.6666666666666665'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 * 1d / i2);    //输出：3.6666666666666665
- en: '```'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, you can cast any of the operands to the `float` or `double`
    types (depending on the precision you need), or you can include the `float` or
    `double` type number. You might remember from [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, that a value with a fractional part is `double`
    by default. Or, you can explicitly select a type of the value added, as we did
    in the last two lines of the preceding code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以将任何操作数转换为`float`或`double`类型（取决于你需要的精度），或者你可以包含`float`或`double`类型的数字。你可能还记得[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中所述，带有小数部分的值默认为`double`。或者，你可以明确选择要添加的值的类型，就像我们在前面代码的最后两行中所做的那样。
- en: 'Whatever you do, just be careful while dividing two integers. If you do not
    want the fractional part to be dropped, cast at least one operand to `float` or
    `double` just in case (more about the cast operator in the *Cast operator: ( target
    type )* section later. Then, if you need, you can round up the result to any precision
    you prefer or cast it back to `int`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '无论你做什么，只要小心两个整数相除。如果你不希望小数部分被丢弃，至少将一个操作数转换为`float`或`double`（稍后在*Cast operator:
    ( target type )*部分详细了解转换运算符）。然后，如果需要，你可以将结果四舍五入到任何你喜欢的精度，或者将其转换回`int`：'
- en: '```java'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 11;
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 11;
- en: int i2 = 3;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 3;
- en: float r = (float)i1 / i2;
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: float r = (float)i1 / i2;
- en: 'System.out.println(r);                 //prints: 3.6666667'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);                 //输出：3.6666667
- en: float f = Math.round(r * 100f) / 100f;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: float f = Math.round(r * 100f) / 100f;
- en: 'System.out.println(f);                 //prints: 3.67'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(f);                 //输出：3.67
- en: int i3 = (int)f;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = (int)f;
- en: 'System.out.println(i3);                //prints: 3'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i3);                //输出：3
- en: '```'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Java integer division: if in doubt, make one of the operands `double` or `float`,
    or simply add a `1.0` multiplier to one of them.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java整数除法：如果不确定，将其中一个操作数设为`double`或`float`，或者简单地给其中一个添加`1.0`的乘数。
- en: 'In case of `String`, the binary operator  `+` means concatenate and the operator
    is often called the concatenation operator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`String`的情况下，二进制运算符`+`表示连接，这个运算符通常被称为连接运算符：
- en: '```java'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String s1 = "Nick";
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = "Nick";
- en: String s2 = "Samoylov";
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = "Samoylov";
- en: 'System.out.println(s1 + " " + s2);  //prints: Nick Samoylov'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s1 + " " + s2);  //prints: Nick Samoylov'
- en: String s3 = s1 + " " + s2;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: String s3 = s1 + " " + s2;
- en: 'System.out.println(s3);             //prints: Nick Samoylov'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s3);             //prints: Nick Samoylov'
- en: '```'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And just as a reminder, in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, we demonstrated that an arithmetic operation
    applied to the primitive type `char` uses the character''s code point – a numeric
    value of the character:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并且只是作为提醒，在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们演示了应用于原始类型`char`的算术运算使用字符的代码点-字符的数值：
- en: '```java'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: char c1 = 'a';
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: char c1 = 'a';
- en: char c2 = '$';
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: char c2 = '$';
- en: 'System.out.println(c1 + c2);       //prints: 133'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1 + c2);       //prints: 133'
- en: 'System.out.println(c1/c2);         //prints: 2'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1/c2);         //prints: 2'
- en: 'System.out.println((float)c1/c2);  //prints: 2.6944444'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println((float)c1/c2);  //prints: 2.6944444'
- en: '```'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: These results make sense only if you remember that the code point of the symbol
    `a` is 97, while the code point of the symbol `$` is 36.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在记住符号`a`的代码点是97，而符号`$`的代码点是36时，这些结果才有意义。
- en: 'Most of the time, the arithmetic operations in Java are quite intuitive and
    cause no confusion, except in two cases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Java中的算术运算都相当直观，不会引起混淆，除了两种情况：
- en: When all operands of the division are integral
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当除法的所有操作数都是整数时
- en: When `char` variables are used as the operands of an arithmetic operator
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`char`变量用作算术运算符的操作数时
- en: Incrementing and decrementing unary operators:  ++   --
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递增和递减一元运算符：++ --
- en: 'The following code shows how the `++` and `--` operators work, depending on
    their position, before the variable (prefix) or after the variable (postfix):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`++`和`--`运算符的工作原理，取决于它们的位置，变量之前（前缀）还是变量之后（后缀）：
- en: '```java'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = 2;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;
- en: 'System.out.println(++i);        //prints: 3'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(++i);        //prints: 3'
- en: 'System.out.println("i=" + i);   //prints: i=3'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=3'
- en: 'System.out.println(--i);        //prints: 2'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(--i);        //prints: 2'
- en: 'System.out.println("i=" + i);   //prints: i=2'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=2'
- en: 'System.out.println(i++);        //prints: 2'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i++);        //prints: 2'
- en: 'System.out.println("i=" + i);   //prints: i=3'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=3'
- en: 'System.out.println(i--);        //prints: 3'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i--);        //prints: 3'
- en: 'System.out.println("i=" + i);   //prints: i=2'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=2'
- en: '```'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If placed as a prefix, it changes its value by 1 before the variable's value
    is returned. But when placed as a postfix, it changes its value by 1 after the
    variable's value is returned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果放在前缀位置，它会在返回变量的值之前将其值减1。但是当放在后缀位置时，它会在返回变量的值之后将其值减1。
- en: The `++x` expression increments the `x` variable before returning the result,
    while the `x++` expression returns the result first and increments the `x` variable afterward.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`++x`表达式在返回结果之前增加`x`变量的值，而`x++`表达式在返回结果后增加`x`变量的值。'
- en: 'It takes time to get used to this. But once you do, it feels easy to write
    `++x;` or `x++`, instead of `x = x + 1;`. Using prefix or postfix increments,
    in this case, does not make a difference because each of them increases `x` eventually:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯这需要时间。但一旦你习惯了，写`++x;`或`x++`会感觉很容易，而不是`x = x + 1;`。在这种情况下使用前缀或后缀递增没有区别，因为它们都最终会增加`x`：
- en: '```java'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 0;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0;
- en: ++x;
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ++x;
- en: 'System.out.println(x);   //prints: 1'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(x);   //prints: 1'
- en: x = 0;
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: x = 0;
- en: x++;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: 'System.out.println(x);   //prints: 1'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(x);   //prints: 1'
- en: '```'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The difference between prefix and postfix appears only when the returned value
    is used, not the value of the variable that will have after the postfix returns,
    for example. Here is the demonstration code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀和后缀之间的区别只有在使用返回值而不是后缀返回后变量的值时才会出现。例如，这是演示代码：
- en: '```java'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 0;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0;
- en: int y = x++ + x++;
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: int y = x++ + x++;
- en: 'System.out.println(y);   //prints: 1'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y);   //prints: 1'
- en: 'System.out.println(x);   //prints: 2'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(x);   //prints: 2'
- en: '```'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The value of `y` is formed by the first `x++` returning 0 and then increasing `x` by
    1\. The second `x++` gets 1 as the current `x` value and returns it, so the `y` value
    becomes 1\. Meanwhile, the second `x++` increases the value of `x` by 1 again,
    so the value of `x` becomes 2.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`的值由第一个`x++`返回0形成，然后将`x`增加1。第二个`x++`得到1作为当前的`x`值并返回它，所以`y`的值变为1。同时，第二个`x++`再次增加`x`的值1，所以`x`的值变为2。'
- en: 'This functionality makes more sense if we include it in an expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能在表达式中更有意义：
- en: '```java'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int n = 0;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 0;
- en: int m = 5*n++;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: int m = 5*n++;
- en: 'System.out.println(m);   //prints: 0'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(m);   //prints: 0'
- en: 'System.out.println(n);   //prints: 1'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(n);   //prints: 1'
- en: '```'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It allows us to use the current value of the variable first and then increase
    it by 1\. So, the postfix increment (decrement) operator has the side effect of
    incrementing (decrementing) the variable value. As we have mentioned already,
    it is especially beneficial for array element access:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们首先使用变量的当前值，然后将其增加1。因此，后缀递增（递减）运算符具有增加（递减）变量值的副作用。正如我们已经提到的，这对于数组元素访问特别有益：
- en: '```java'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int k = 0;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: int k = 0;
- en: int[] arr = {88, 5, 42};
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {88, 5, 42};
- en: 'System.out.println(arr[k++]);  //prints: 88'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 88'
- en: 'System.out.println(k);         //prints: 1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 1'
- en: 'System.out.println(arr[k++]);  //prints: 5'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 5'
- en: 'System.out.println(k);         //prints: 2'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 2'
- en: 'System.out.println(arr[k++]);  //prints: 42'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 42'
- en: 'System.out.println(k);         //prints: 3'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 3'
- en: '```'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The same result can be achieved by setting `k` to `-1` and moving `++` to the
    front:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`k`设置为`-1`并将`++`移到前面也可以实现相同的结果：
- en: '```java'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int k = -1;
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: int k = -1;
- en: int[] arr = {88, 5, 42};
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {88, 5, 42};
- en: 'System.out.println(arr[k++]);  //prints: 88'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[++k]);  //prints: 5'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 2'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[++k]);  //prints: 42'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(k);         //prints: 3'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'But, using `k=0` and `k++` reads better and thus became a typical way to access
    the array components. However, it is only useful if you need to access the array
    elements by index. For example, if you need to access the array starting with
    index `2`, then you need to use the index:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {1,2,3,4};
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: int j = 2;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[j++]);  //prints: 3'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arr[j++]);  //prints: 4'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: But if you are going to access the array sequentially, starting from index 0,
    then there are more economical ways to do it. See [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Equality operators:  ==   !=
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The equality operators `==` (means equals) and `!=` (means not equals) compare
    values of the same type and return the `Boolean` value `true` if the operand''s
    values are equal, or `false` otherwise. The integral and Boolean primitive type''s
    equality is straightforward:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: char a = 'a';
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: char b = 'b';
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: char c = 'a';
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a == b);  //prints: false'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a != b);  //prints: true'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a == c);  //prints: true'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(a != c);  //prints: false'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 1;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 2;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: int i3 = 1;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 == i2);  //prints: false'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 != i2);  //prints: true'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 == i3);  //prints: true'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i1 != i3);  //prints: false'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: boolean b1 = true;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: boolean b2 = false;
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: boolean b3 = true;
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 == b2);  //prints: false'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 != b2);  //prints: true'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 == b3);  //prints: true'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b1 != b3);  //prints: false'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, the `char` type, as in the case of arithmetic operations, is
    treated as a numeric value that is equal to its code point. Otherwise, it is not
    easy to understand the results of the following line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((a + 1) == b); //prints: true'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'But the explanation for this line is obvious from the following results:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b - a);        //prints: 1'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((int)a);       //prints: 97'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((int)b);       //prints: 98'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The code point of `a` is `97` and the code point of `b` is `98`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'For the primitive types `float` and `double`, the equality operator seems to
    work in the same way. Here is an example of `double` type equality:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = 0.42;
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: double d2 = 0.43;
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: double d3 = 0.42;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 == d2);  //prints: false'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 != d2);  //prints: true'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 == d3);  //prints: true'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(d1 != d3);  //prints: false'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'But, that is because we compare numbers created as literals, with fixed fractional
    parts. If we compare the results of the following calculations, there is a good
    chance that the resulting value would never be equal to the expected result, because
    some numbers (such as `1/3`, for example) cannot be represented exactly. And what
    is it exactly in the case of `1/3`? Expressed as a decimal, it has a never-ending
    fractional part:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((double)1/3);    //prints: 0.3333333333333333'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: That is why when comparing values of types `float` and `double`, it is much
    more reliable to use the relational operators `<`,  `>`, `<=`, or `=>` (see the
    next subsection).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of object references, an equality operator compares the references
    themselves, not the objects and their values:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass c1 = new SomeClass();
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass c2 = new SomeClass();
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass c3 = c1;
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 == c2);     //prints: false'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 != c2);     //prints: true'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 == c3);     //prints: true'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c1 != c3);     //prints: false'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(new SomeClass() == new SomeClass());  //prints: false'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(new SomeClass() == new SomeClass());  //prints: false'
- en: '```'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Object equality based on the values they contain has to be performed using the `equals()` method.
    We talked about it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, and will discuss it more in the *Method equals() of reference
    types* section later.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Object equality based on the values they contain has to be performed using the `equals()` method.
    We talked about it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, and will discuss it more in the *Method equals() of reference
    types* section later.
- en: Relational operators:  <  >  <=  >=
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Relational operators:  <  >  <=  >=
- en: 'Relational operators can only be used with primitive types:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'Relational operators can only be used with primitive types:'
- en: '```java'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 1;
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 1;
- en: int i2 = 2;
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 2;
- en: int i3 = 1;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = 1;
- en: 'System.out.println(i1 > i2);    //prints: false'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 > i2);    //prints: false'
- en: 'System.out.println(i1 >= i2);   //prints: false'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 >= i2);   //prints: false'
- en: 'System.out.println(i1 >= i3);   //prints: true'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 >= i3);   //prints: true'
- en: 'System.out.println(i1 < i2);    //prints: true'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 < i2);    //prints: true'
- en: 'System.out.println(i1 <= i2);   //prints: true'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 <= i2);   //prints: true'
- en: 'System.out.println(i1 <= i3);   //prints: true'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 <= i3);   //prints: true'
- en: 'System.out.println(''a'' >= ''b'');  //prints: false'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(''a'' >= ''b'');  //prints: false'
- en: 'System.out.println(''a'' <= ''b'');  //prints: true'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(''a'' <= ''b'');  //prints: true'
- en: double d1 = 1/3;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 1/3;
- en: double d2 = 0.34;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: double d2 = 0.34;
- en: double d3 = 0.33;
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: double d3 = 0.33;
- en: 'System.out.println(d1 < d2);  //prints: true'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 < d2);  //prints: true'
- en: 'System.out.println(d1 >= d3); //prints: false'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 >= d3); //prints: false'
- en: '```'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, we see that `int` type values compare to each other as
    expected, and `char` type values compare to each other based on their numeric
    code point values.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: In the preceding code, we see that `int` type values compare to each other as
    expected, and `char` type values compare to each other based on their numeric
    code point values.
- en: Variables of the primitive type `char`, when used as operands with arithmetic,
    equality, or relational operators, assign numeric values equal to the code points
    of the characters they represent.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当将原始类型`char`的变量用作算术、相等或关系运算符的操作数时，它们分配的数值等于它们表示的字符的代码点。
- en: 'So far, nothing unexpected, except the last line. We have established that
    `1/3` expressed as a decimal should be `0.3333333333333333`, which is bigger than
    `0.33`. Why then does `d1 >= d3` return `false`? If you said that it is because
    of integer division, you are correct. Even when assigned to a variable of type
    `double`, the result is 0.0 because the integer division `1/3` happens first,
    before the result is assigned to `d1`. Here is the code that demonstrates it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，除了最后一行之外，没有什么意外。我们已经确定，作为小数表示的`1/3`应该是`0.3333333333333333`，这比`0.33`大。为什么`d1
    >= d3`返回`false`？如果你说这是因为整数除法，那么你是正确的。即使赋值给`double`类型的变量，结果也是0.0，因为整数除法`1/3`先发生，然后才将结果赋给`d1`。以下是演示它的代码：
- en: '```java'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double d1 = 1/3;
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 1/3;
- en: double d2 = 0.34;
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: double d2 = 0.34;
- en: double d3 = 0.33;
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: double d3 = 0.33;
- en: 'System.out.println(d1 < d2);   //prints: true'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 < d2);   //prints: true'
- en: 'System.out.println(d1 >= d3);  //prints: false'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 >= d3);  //prints: false'
- en: 'System.out.println(d1);        //prints: 0.0'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1);        //prints: 0.0'
- en: double d4 = 1/3d;
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: double d4 = 1/3d;
- en: 'System.out.println(d4);        //prints: 0.3333333333333333'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d4);        //prints: 0.3333333333333333'
- en: 'System.out.println(d4 >= d3);  //prints: true'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d4 >= d3);  //prints: true'
- en: '```'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But other than that, using `float` and `double` types with relational operators
    yields more predictable results than using them with equality operators.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但除此之外，使用关系运算符与等式运算符相比，使用`float`和`double`类型的值会产生更可预测的结果。
- en: While comparing values of types `float` and `double`, use the relational operators `<`,  `>`, `<=`,
    or `=>` instead of the equality operators `==` and `!=`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较`float`和`double`类型的值时，请使用关系运算符`<`、`>`、`<=`或`=>`，而不是等式运算符`==`和`!=`。
- en: Like in experimental physics, think about precision while comparing values of
    `float` and `double` types.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在实验物理学中一样，在比较`float`和`double`类型的值时，请考虑精度。
- en: Logical operators:  !  &  |
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logical operators:  !  &  |
- en: 'Let''s define each of the logical operators first:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义每个逻辑运算符：
- en: The unary operator `!` returns `true` if the operand is `false` and returns
    `false` otherwise
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符`!`如果操作数为`false`则返回`true`，否则返回`false`
- en: The binary operator `&` returns `true` if both of the operands are `true`
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制运算符`&`如果两个操作数都为`true`，则返回`true`
- en: The binary operator `|` returns true if at least one of the operands is true
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制运算符`|`如果两个操作数中至少有一个为`true`，则返回`true`
- en: 'Here is the demo code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示代码：
- en: '```java'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: boolean x = false;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: boolean x = false;
- en: 'System.out.println(!x);  //prints: true'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(!x);  //prints: true'
- en: 'System.out.println(!!x); //prints: false'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(!!x); //prints: false'
- en: boolean y = !x;
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: boolean y = !x;
- en: 'System.out.println(y & x); //prints: false'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y & x); //prints: false'
- en: 'System.out.println(y | x); //prints: true'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y | x); //prints: true'
- en: boolean z = true;
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: boolean z = true;
- en: 'System.out.println(y & z); //prints: true'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y & z); //prints: true'
- en: 'System.out.println(y | z); //prints: true'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y | z); //prints: true'
- en: '```'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the `!` operator can be applied to the same value several times.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`!`运算符可以多次应用于同一个值。
- en: 'Conditional operators:  &&   ||    ? : (ternary)'
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '条件运算符：  &&   ||    ? : (三元)'
- en: 'We can reuse the previous code example, but with the `&&` and `||` operators instead
    of the `&` and `|` operators:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用先前的代码示例，但使用`&&`和`||`运算符，而不是`&`和`|`运算符：
- en: '```java'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: boolean x = false;
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: boolean x = false;
- en: boolean y = !x;
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: boolean y = !x;
- en: 'System.out.println(y && x); //prints: false'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y && x); //prints: false'
- en: 'System.out.println(y || x); //prints: true'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y || x); //prints: true'
- en: boolean z = true;
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: boolean z = true;
- en: 'System.out.println(y && z); //prints: true'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y && z); //prints: true'
- en: 'System.out.println(y || z); //prints: true'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y || z); //prints: true'
- en: '```'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The results are not different, but there is a difference in the execution.
    The operators `&` and `|` always check values of both operands. Meanwhile, in
    the case of `&&`, if the operand on the left returns `false`, the `&&` operator returns
    `false` without evaluating the operand on the right. And, in the case of `||`,
    if the operand on the left returns `true`, the `||` operator returns `true` without
    evaluating the operand on the right. Here is the code that demonstrates this difference:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并没有不同，但执行上有区别。运算符`&`和`|`总是检查两个操作数的值。与此同时，在`&&`的情况下，如果左操作数返回`false`，`&&`运算符会在不评估右操作数的情况下返回`false`。而在`||`的情况下，如果左操作数返回`true`，`||`运算符会在不评估右操作数的情况下返回`true`。以下是演示这种差异的代码：
- en: '```java'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = 1, j = 3, k = 10;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 1, j = 3, k = 10;
- en: 'System.out.println(i > j & i++ < k);  //prints: false'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i > j & i++ < k);  //prints: false'
- en: 'System.out.println("i=" + i);         //prints: i=2'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);         //prints: i=2'
- en: 'System.out.println(i > j && i++ < k); //prints: false'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i > j && i++ < k); //prints: false'
- en: 'System.out.println("i=" + i);         //prints: i=2'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);         //prints: i=2'
- en: '```'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Both operators—`&` and `&&`—return `false`. But in the case of `&&`, the second
    operand, `i++ < k`, is not checked and the value of the variable `i` does not
    change. Such optimization saves time if the second operand takes time to evaluate.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`和`&&`两个运算符都返回`false`。但是在`&&`的情况下，第二个操作数`i++ < k`不会被检查，变量`i`的值也不会改变。如果第二个操作数需要花费时间来评估，这样的优化可以节省时间。'
- en: The `&&` and `||` operators do not evaluate the right-hand condition if the
    left-hand condition already failed the test (returned `false`) in the case of
    `&&`, or succeeded (returned `true`) in the case of `||`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`运算符在`&&`的情况下，如果左操作数返回`false`，则不评估右操作数；在`||`的情况下，如果左操作数返回`true`，则不评估右操作数。'
- en: Yet, the `&` operator is useful when it is necessary to always check the second
    operand. For example, the second operand might be a method that may throw an exception
    and change the flow of the logic under some rare condition.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`&`运算符在需要始终检查第二个操作数时是有用的。例如，第二个操作数可能是一个可能抛出异常并在某些罕见条件下改变逻辑流程的方法。
- en: 'The third conditional operator is called a ternary operator. Here''s how it
    works:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个条件运算符称为三元运算符。它的工作原理如下：
- en: '```java'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int n = 1, m = 2;
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 1, m = 2;
- en: 'System.out.println(n > m ? "n > m" : "n <= m"); //prints: n <= m'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(n > m ? "n > m" : "n <= m"); //prints: n <= m'
- en: 'System.out.println(n > m ? true : false);       //prints: false'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(n > m ? true : false);       //prints: false'
- en: 'int max = n > m ? n : m;'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'int max = n > m ? n : m;'
- en: 'System.out.println(max);                        //prints: 2'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(max);                        //prints: 2'
- en: '```'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It evaluates the condition and, if it is true, returns the first entry (after
    the question mark, `?`); otherwise, it returns the second entry (after the colon
    sign, `:`). It is a very convenient and compact way to select between two options
    instead of using the full `if-else` statement construct:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 它评估条件，如果条件为真，则返回第一个条目（问号后面的内容，`?`）；否则，返回第二个条目（冒号后面的内容，`:`）。这是一种非常方便和紧凑的方式，可以选择两个选项，而不是使用完整的`if-else`语句结构：
- en: '```java'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String result;
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: String result;
- en: if(n > m){
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: if(n > m){
- en: result = "n > m";
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: result = "n > m";
- en: '} else {'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: result = "n <= m";
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: result = "n <= m";
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will discuss such statements (called conditional statements) in [Chapter
    10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中讨论这样的语句（称为条件语句），*控制流语句*。
- en: Assignment operators (most popular):  =   +=   -=   *=   /=   %=
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符（最受欢迎的）： =  +=  -=  *=  /=  %=
- en: Although we discuss them not the first, these are the most often used operators,
    especially the `=` simple assignment operator, which just assigns a value to a
    variable (also phrased as *assigns a variable a value*). We have seen examples
    of simple assignment usage many times already.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不是第一次讨论它们，但这些是最常用的运算符，特别是`=`简单赋值运算符，它只是将一个值赋给一个变量（也可以说是*给变量赋值*）。我们已经多次看到了简单赋值的用法示例。
- en: The only possible caveat in using simple assignment is when the type of the
    variable on the left is not the same as the value or variable type on the right.
    The difference in types can lead to the *narrowing* or *widening* of the value
    in the case of primitive types, or to *boxing* or *unboxing* when one type is
    a primitive type and another type is a reference type. We will discuss such assignments
    in the *Widening and narrowing conversion of primitive types* and *Boxing and
    unboxing between a primitive and reference types* sections later.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用简单赋值时唯一可能的注意事项是，当左侧的变量类型与右侧的值或变量类型不同时。类型的差异可能导致原始类型的值*变窄*或*变宽*，或者在一个类型是原始类型而另一个类型是引用类型时导致*装箱*或*拆箱*。我们将在稍后的*原始类型的扩宽和变窄转换*和*原始类型和引用类型之间的装箱和拆箱*部分讨论这样的赋值。
- en: 'The rest of the assignment operators (`+=`  `-=`  `*=`  `/=`  `%=`) are called
    compound assignment operators:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的赋值运算符（`+=` `-=` `*=` `/=` `%=`）称为复合赋值运算符：
- en: '`x += 2;` assigns the result of this addition: `x = x + 2;`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x += 2;` 分配这个加法的结果：`x = x + 2;`'
- en: '`x -= 2;` assigns the result of this subtraction: `x = x - 2;`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x -= 2;` 分配这个减法的结果：`x = x - 2;`'
- en: '`x *= 2;` assigns the result of this multiplication: `x = x * 2;`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x *= 2;` 分配这个乘法的结果：`x = x * 2;`'
- en: '`x /= 2;` assigns the result of this division: `x = x / 2;`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x /= 2;` 分配这个除法的结果：`x = x / 2;`'
- en: '`x %= 2;` assigns the remainder of this division: `x = x + x % 2;`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x %= 2;` 分配这个除法的余数：`x = x + x % 2;`'
- en: 'The operation `x = x + x % 2;` is based on the operator precedence rules, which
    we are going to discuss in the *Operator precedence and evaluation order of operands* section later.
    According to these rules, the `%` operator (modulus) is executed first, then the `+` operator (addition),
    and then the result is assigned to the left-hand operand variable `x`. Here is
    the demonstration code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 操作`x = x + x % 2;`是基于运算符优先级规则的，我们将在稍后的*运算符优先级和操作数的评估顺序*部分讨论这些规则。根据这些规则，`%`运算符（取模）首先执行，然后是`+`运算符（加法），然后将结果分配给左操作数变量`x`。这是演示代码：
- en: '```java'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: int x = 1;
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: x += 2;
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 3'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: x -= 1;
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 2'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: x *= 2;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 4'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: x /= 2;
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 2'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: x %= 2;
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 0'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, every time we encounter integer division, we had better convert it to
    a `float` or `double` division, then round it if necessary or just cast it to
    an integer. In our example, we do not have any loss of the fractional part. But
    if we do not know the value of `x`, the code may look as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: x = 11;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: double y = x;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: y /= 3;          //That's the operation we wanted to do on x
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y);        //prints: 3.6666666666666665'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: x = (int)y;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);        //prints: 3'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '//or, if we need to round up the result:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'double d = Math.round(y);     //prints: 4.0'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(d);
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: x = (int) d;
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);        //prints: 4'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we have assumed that we do not know the value of `x`, so we switched
    to the `double` type to avoid the loss of the fractional part. After the result
    is calculated, we either cast it to `int` (and the fractional part is lost) or
    round it to the nearest integer.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: In this simple division, we could lose the fractional part and get `3`, even
    without converting to the `double` type. But in real-life calculations, the formula
    is usually not that simple, so one might never know exactly where the integer
    division might happen. That's why it is a good practice just to convert the values
    to `float` and `double` before starting the calculations.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance creation operator: new'
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we have seen examples of the `new` operator being used many times. It
    instantiates (creates an object of) a class by allocating memory for the new object
    and returning a reference to that memory. This reference is then typically assigned
    to a variable of the same type as the class used to create the object or the type
    of its parent, although we have also seen a case when the reference was never
    assigned. In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, for example, we used this code to demonstrate
    how the constructors are called:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: new Child();
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: new Child("The Blows");
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'But such cases are very rare and most of the time we need a reference to the
    newly created object in order to invoke its methods:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass obj = new SomeClass();
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: obj.someMethod();
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: After the `new` operator is called and the memory is allocated, the corresponding
    (explicit or default) constructor initializes the state of the new object. We
    talked extensively about this [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Since arrays are objects too, they can also be created using the `new` operator and
    any Java type:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = new int[42];
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[]` notation allows us to set the array length (max number of components,
    also called elements) – `42` in the preceding code. One potential source of confusion
    may come from the fact that at compile time, Java allows assigning values to components
    with indexes bigger than the array length:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = new int[42];
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: arrInt[43] = 22;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'But when the program is run, the line `arrInt[43] = 22` will throw an exception:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fbc4c0a-5e3a-4788-a04c-fa205a28259a.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to create an array without using the `new` operator and
    using the array initializer instead:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = {1,2,3,4};
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: A class instance can only be created using the `new` operator. An array can
    be created using the `new` operator or the `{}` initializer.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed this extensively in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. If not initialized explicitly, the values
    of an array are set to default values that depend on the type (we described them
    in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*, too).  Here is a code example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInt = new int[42];
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: //arrInt[43] = 22;
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInt[2]);      //prints: 0'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInt.length);  //prints: 42'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrInit = {1,2,3,4};
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInit[2]);      //prints: 3'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrInit.length);  //prints: 4'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: And, just to remind you, the index of the first element of an array is 0.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Type comparison operator:  instanceof
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instanceof` operator requires two operands of a reference type. That is
    because it checks the parent-child relation of an object, including implementation
    of interfaces. It evaluates to `true` if the left-hand operand (an object reference)
    extends or implements the type on the right, and `false` otherwise. Obviously,
    every reference `instanceof Object` returns `true` because in Java, every class
    implicitly inherits the `Object` class. When `instanceof` is applied to an array
    of any type, it returns `true` for the right-hand operand `Object` only.  And,
    since `null` is not an instance of any type, `null instanceof` returns `false`
    for any type. Here is the demo code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: interface IntrfA{}
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: class ClassA implements IntrfA {}
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: class ClassB extends ClassA {}
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: class ClassX implements IntrfA {}
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: private void instanceofOperator() {
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: ClassA classA = new ClassA();
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: ClassB classB = new ClassB();
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: ClassX classX = new ClassX();
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: int[] arrI = {1,2,3};
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: ClassA[] arrA = {new ClassA(), new ClassA()};
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof Object); //prints: true'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrI instanceof Object);   //prints: true'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(arrA instanceof Object);   //prints: true'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(arrA instanceof ClassA);   //error
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof IntrfA); //prints: true'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classB instanceof IntrfA); //prints: true'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classX instanceof IntrfA); //prints: true'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof ClassA); //prints: true'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classB instanceof ClassA); //prints: true'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA instanceof ClassB); //prints: false'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(classX instanceof ClassA); //error
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(null instanceof ClassA);   //prints: false'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(classA instanceof null);   //error
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA == null);           //prints: false'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classA != null);           //prints: true'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the results are straightforward and were probably expected. The only
    one that might have been expected is `classX instanceof ClassA`. Both `ClassX`
    and `ClassA` implement the same interface, `IntrfA`, so there is some affinity
    between them – each can be cast to the `IntrfA` interface:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: IntrfA intA = (IntrfA)classA;
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: intA = (IntrfA)classX;
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: But that relation is not of parent-child type, so the `instanceof` operator
    cannot even be applied to them.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: The `instanceof` operator allows us to check whether the class instance (object)
    has a certain class as a parent or a certain interface implemented.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: We see a similar problem with `classA instanceof null` because `null` does not
    refer to any object at all, although `null` is a literal of the reference type.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: In the last two statements in the preceding code, we showed how the object reference
    can be compared to `null`. Such a comparison is often used before calling a method
    on the reference to make sure that the reference is not `null`. It helps to avoid
    the dreaded `NullPointerException`, which breaks the execution flow. We will talk more
    about exceptions in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Preferring polymorphism over the instanceof operator
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `instance of` operator is very helpful. We have used it several times in
    this book. But, there are situations that may require us to revisit the decision
    to use it.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Every time you think about using the `instanceof` operator, try to see if you
    can avoid it by using polymorphism.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this tip, here is some code that can benefit from polymorphism
    instead of using the `intanceof` operator:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: class ClassBase {
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: class ClassY extends ClassBase {
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassY.method() is called");
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: class ClassZ extends ClassBase {
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassZ.method() is called");
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: public void doSomething(ClassBase object) {
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: if(object instanceof ClassY){
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: ((ClassY)object).method();
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '} else if(object instanceof ClassZ){'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: ((ClassZ)object).method();
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: //other code
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the following code snippet:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass cl = new SomeClass();
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: cl.doSomething(new ClassY());
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see this:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b39a48b-3c7e-4adf-81a8-ca3ddd69c988.png)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
- en: Then, we notice that the methods in `ClassY` and `ClassZ` have the same signature,
    so we may add the same method to the base class, `ClassBase:`
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: class ClassBase {
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassBase.method() is called");
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'And simplify the `SomeClass` implementation:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: public void doSomething(ClassBase object) {
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: object.method();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: //other code
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling `new SomeClass().doSomething(new ClassY())`, we still get the
    same result:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6f5a08-0855-4ced-b30a-b4cf0c925523.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
- en: That is because `method()` is overridden in the child. The method implemented
    in `ClassBase` can do something or nothing. It does not matter because it is never
    going to be executed (unless you specifically call it by casting it from the child
    class using the `super` keyword).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'And, while overriding, do not forget to use the `@Override` annotation:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: class ClassZ extends ClassBase {
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: void method(){
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("ClassY.method() is called");
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The annotation will help you to verify that you are not mistaken and the method
    in each of the child classes has the same signature as the one in the parent class.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Field access or method invocation operator:  .
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the class or interface, a field or a method of this class or interface
    can be accessed just by the name. But from outside the class or interface, the
    non-private field or method can be accessed using the dot (`.`) operator and:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: If the field or method is non-static (instance member), the object name
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the field or method is static, the interface or class name
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dot operator (`.`) can be used to access a non-private field or method. If
    the field or method is static, the dot operator is applied to the interface or
    class name. If the field or method is non-static, the dot operator is applied
    to the object reference.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen many such examples already. So, we just summarize all the cases
    in one interface and the class that implements it. Let''s assume that we have
    the following interface called `InterfaceM`:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: interface InterfaceM {
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: String INTERFACE_FIELD = "interface field";
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: static void staticMethod1(){
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface static method 1");
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: static void staticMethod2(){
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface static method 2");
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: default void method1(){
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface default method 1");
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: default void method2(){
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("interface default method 2");
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: void method3();
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a dot operator (`.`) with it as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(InterfaceM.INTERFACE_FIELD);    //1: interface field'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'InterfaceM.staticMethod1();               //2: interface static method'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'InterfaceM.staticMethod2();               //3: interface static method'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '//InterfaceM.method1();                         //4: compilation error'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '//InterfaceM.method2();                         //5: compilation error'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '//InterfaceM.method3();                         //6: compilation error'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ClassM.INTERFACE_FIELD);       //7: interface field'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Cases 1, 2, and 3 are straightforward. Cases 4, 5, and 6 generate a compilation
    error because non-static methods can be accessed only via an instance (object)
    of a class that implements the interface. Case 7 is possible, but is not a recommended
    way to access interface fields (also called constants). Accessing them using the
    interface name (as in case 1) makes the code easier to understand.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a `ClassM` class that implements the `InterfaceM` interface:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: class ClassM implements InterfaceM {
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: public static String CLASS_STATIC_FIELD = "class static field";
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: public static void staticMethod2(){
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class static method 2");
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: public static void staticMethod3(){
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class static method 3");
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: public String instanceField = "instance field";
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: public void method2(){
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class instance method 2");
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: public void method3(){
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("class instance method 3");
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are all possible cases of using the dot operator (`.`) for the class
    field and method access:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '//ClassM.staticMethod1();                       //8: compilation error'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'ClassM.staticMethod2();                     //9: class static method 2'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'ClassM.staticMethod3();                    //10: class static method 3'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: ClassM classM = new ClassM();
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ClassM.CLASS_STATIC_FIELD);//11: class static field'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classM.CLASS_STATIC_FIELD);//12: class static field'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '//System.out.println(ClassM.instanceField);    //13: compilation error'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(classM.instanceField);         //14: instance field'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '//classM.staticMethod1();                      //15: compilation error'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.staticMethod2();                   //16: class static method  2'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.staticMethod3();                    //17: class static method 3'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.method1();                     //18: interface default method 1'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.method2();                        //19: class instance method 2'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'classM.method3();                        //20: class instance method 3'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Case 8 generates a compilation error because a static method belongs to the
    class or interface (in this case) where it is implemented.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Case 9 is an example of a static method hiding. A method with the same signature
    is implemented in the interface but hidden by the class implementation.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Cases 10 and 11 are straightforward.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Case 12 is possible but not recommended. Accessing a static class field using
    the class name makes the code easier to understand.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Class 13 is an obvious error because an instance field can be accessed only
    via an instance (object).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Class 14 is a correct version of case 13.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Class 15 is an error because a static method belongs to the class or interface
    (in this case) where it is implemented, not to the class instance.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Cases 16 and 17 are possible but are not recommended ways to access a static
    method. Using the class name (instead of the instance identifier) to access static
    method makes code easier to understand.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Case 18 demonstrates how an interface can provide a default implementation to
    a class. That is possible because `ClassM implements InterfaceM` effectively inherits
    all the methods and fields of the interface. We say effectively because the legally
    correct terminology is class *implements* interface. But in fact, a class that
    implements an interface acquires all the fields and methods of the interface in
    the same manner a child class inherits them.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: Case 19 is an example of the class overriding the default implementation of
    the interface.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 20 is an example of the classic interface implementation. That was the
    original idea of an interface: to provide an abstraction of the API.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Cast operator:  (target type)
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cast operator is used for type casting, assigning a value of one type to
    a variable of another type. Usually, it is used to enable conversions that would
    otherwise not be allowed by the compiler. We used type casting, for example, when
    we discussed integer division, the `char` type as a numeric type, and assigning
    a class reference to a variable that has a type of one of the implemented interfaces:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = 11;
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = 3;
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((float)i1 / i2);  //prints: 3.6666667'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println((int)a);          //prints: 97'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: IntrfA intA = (IntrfA)classA;
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two potential issues to watch while casting:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: In the case of primitive types, the value should be smaller than the maximum
    value the target type can hold (we will talk about this in detail in the *Widening
    and narrowing conversion of  primitive types* section later)
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of reference types, the left-hand operand should be a parent (even
    if indirect) of the right-hand operand, or the left-hand operand should be an
    interface implemented (even if indirectly) by the class represented by the right-hand
    operand:'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: interface I1{}
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: interface I2{}
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: interface I3{}
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: class A implements I1, I2 {}
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A implements I3{}
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: class C extends B {}
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: class D {}
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: C c = new C();    //1
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: A a = (A)c;       //2
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: I1 i1 = (I1)c;    //3
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: I2 i2 = (I2)c;    //4
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: I3 i3 = (I3)c;    //5
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: c = (C)a;         //6
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: D d = new D();    //7
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: //a = (A)d;       //8 compilation error
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: i1 = (I1)d;       //9 run-time error
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: In this code, case 6 is possible because we know that object `a` was originally
    cast based on object `c`, so we can cast it back to type `C` and expect it to
    be fully functional as an object of class `C`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Case 8 does not compile because its parent-child relations can be verified by
    the compiler.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 9 is not so easy for the compiler for reasons that are outside the scope
    of this book. So, while writing code, the IDE will not give you a hint and you
    may think everything will work as you expect. But then at run-time, you can get
    `ClassCastException`:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7514f1c-0e5b-4e2e-8520-35b894fdcf81.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
- en: Programmers are as happy to see it as much as they like to see the `NullPointerException` or
    `ArrayOutOfBoundException` we demonstrated before. That's why casting to an interface
    has to be done with more care than to a class.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting is assigning a value of one type to a variable of another type.
    While doing it, make sure that the target type can hold the value and check it
    against the maximum target type value if necessary.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to cast a primitive type to a matching reference type:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer1 = 3;                  //line 1
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer1);          //prints: 3'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer2 = Integer.valueOf(4);
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: int i = integer2;                      //line 4
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(i);                 //prints: 4'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: In line 1 and line 4, casting is done implicitly. We will discuss such a casting
    (also called conversion, or boxing and unboxing) in more detail in the *Boxing
    and unboxing between a primitive and reference types* section later.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  id: totrans-661
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said at the beginning of this section, an expression exists only as a
    part of a statement, the latter being the complete action (we will discuss it
    in the next subsection). This means that an expression can be a building block
    of an action. Some expressions can even become a full action (an expression statement)
    after adding a semicolon to them.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinguishing feature of an expression is that it can be evaluated, which
    means it can produce something as the result of its execution. This something
    can be one of three things:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: A variable, such as `i = 2`
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value, such as `2*2`
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing, when the expression is an invocation of a method that returns nothing
    (void). Such an expression can only be the full action—an expression statement—with
    a semicolon at the end.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression typically includes one or more operators and is evaluated. It
    can produce a variable, a value (that is included in further evaluation), or can
    invoke a method that returns nothing (void).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'An evaluation of an expression can also produce a side effect. That is, in
    addition to the variable assignment or returning a value, it can do something
    else, for example:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0, y;
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: y = x++;                  //line 2
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(y);    //prints: 0'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(x);    //prints: 1'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: The expression in line 2 assigns a value to variable `y`, but also has the side
    effect of adding `1` to the value of variable `x`.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: 'By its form, the expression can be:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'A primary expression:'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal (some value)
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object creation (with the `new` operator or with the `{}` array initializer)
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field access (with the dot operator for an external class or without it for
    this instance)
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method invocation (with the dot operator for an external class or without
    it for this instance)
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method reference (with the `::` operator, in lambda expressions)
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array access (with the `[]` notation, which carries an index of the element
    to be accessed)
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary operator expression (`x++` or `-y`, for example)
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary operator expression (`x+y` or `x*y`, for example)
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A ternary operator expression (`x > y ? "x>y" : "x<=y"`, for example)'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lambda expression `i -> i + 1` (see [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*)
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expressions are named according to the action they produce: an object creation
    expression, a cast expression, a method invocation expression, an array access
    expression, an assignment expression, and so on.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: An expression that consists of other expressions is called a complex expression.
    Parentheses are often used to clearly identify each of the sub-expressions, instead
    of relying on the operator precedence (see the *Operators precedence and evaluation
    order of operands* section later).
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We actually defined a statement once in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics.* It is a complete action that can be executed. It can include
    one or more expressions and ends with a semicolon `;`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: A Java statement describes an action. It is a minimal construct that can be
    executed. It may or may not include one or more expressions.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible kinds of Java statements are:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: A class or interface declaration statement, such as `class A {...}`
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty statement that consists of only one symbol, `;`
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local variable declaration statement, `int x;`
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A synchronized statement – outside the scope of this book
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An expression statement, which can be one of the following:'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method invocation statement, such as `method();`
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment statement, such as `x = 3;`
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object creation statement, such as `new SomeClass();`
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary increment or decrement statement, such as `++x ;`  `--x;`  `x++;`  `x--;`
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A control flow statement (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*):'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A selection statement: `if-else` or `switch-case`
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iteration statement: `for`, `while`, or `do-while`'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception handling statement, such as `try-catch-finally` or `throw`
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A branching statement, such as `break`, `continue`, `label:`, `return`, `assert`
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A statement can be *labeled *by placing an identifier and colon `:` in front
    of it. This label can be used by the branching statements `break` and `continue`
    to redirect the control flow. In [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*, we will show you how to do it.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Most often, statements compose a method body, and that is how programs are written.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence and evaluation order of operands
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When several operators are used in the same expression, it might not be obvious
    how to execute them without established rules. For example, what is the value
    that is going to be assigned to variable `x` after the following right-hand expression
    is evaluated:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: int x = 2 + 4 * 5 / 6 + 3 + 7 / 3 * 11 - 4;
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'We know how to do it because we have learned operator precedence in school—just
    apply the multiplication and division operators first from left to right, then
    addition and subtraction from left to right too. But, it turned out that the author
    actually wanted this sequence of operator execution:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: int x = 2 + 4 * 5 / 6 + ( 3 + 7 / 3 * (11 - 4));
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: It yields a different result.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence and parentheses determines the sequence in which parts of
    an expression are evaluated. The evaluation order of operands defines for each
    operation the sequence in which its operands are evaluated.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses help to identify the structure of a complex expression and establish
    the sequence of evaluation, which overrides the operator precedence.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java specification does not provide operator precedence in one place. One
    has to pull it together from various sections. That's why different sources on
    the internet sometimes have a bit of a different sequence of operator execution,
    so do not be surprised, and if in doubt, experiment or just set the parentheses
    to guide the calculations in the sequence you need to.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the operator precedence from the highest (the first
    executed) as the first in the list, to the lowest precedence at the end. Operators
    of the same level of precedence are executed by their position in the expression
    while moving from left to right (provided no parentheses are used):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: An expression that calculates the index of an array element inside the `[]` notation,
    such as `x = 4* arr[i+1]`; the field access and method invocation dot operator `.`,
    such as in `x = 3*someClass.COUNT` or `x = 2*someClass.method(2, "b")`
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unary postfix increment `++` and decrement `--` operators, such as `x++` or
    `x--`, as in `int m = 5*n++`; notice that such an operator returns the old value
    of the variable before it increments/decrements its value, thus having the side
    effect of incrementing the value
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary prefix with the `++` and `--` operators, such as `++x` or `--x`; unary
    `+` and `-` operators, such as in `+x` or `-x`; the logical operator NOT, such
    as in `!b`, where b is a Boolean variable; unary bitwise NOT `~` (outside the
    scope of this book)
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cast operator `()`, such as `double x = (double)11/3`, where 11 is cast to
    `double` first, thus avoiding the integer division problem of losing the fractional
    part; the instance creation operator `new`, such as in `new SomeClass()`
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplicative operators `*`, `/`, `%`
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additive operators `+`, `-`, string concatention `+`
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise shift operators `<<`, `>>`, `>>>`;
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators `<`, `>`, `>=`, `<=`, `instanceof`
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equality operators `==`, `!=`
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical and bitwise operator `&`
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bitwise operator `^`
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical and bitwise operator `|`
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operator `&&`
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operator `||`
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operator `?:` (ternary)
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrow operator `->`
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment operators `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `>>=`, `<<=`, `>>>=`,
    `&=`, `^=`, `|=`
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If parentheses are present, then the expression inside the innermost parentheses
    is calculated first. For example, look at this code snippet:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: int p1 = 10, p2 = 1;
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: int q = (p1 += 3)  +  (p2 += 3);
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(q);         //prints: 17'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p1);        //prints: 13'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p2);        //prints: 4'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 'The assignment operators have the lowest precedence, but they are executed
    first if inside the parentheses, as in the preceding code. To prove this point,
    we can remove the first set of parentheses and run the same code again:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: p1 = 10;
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: p2 = 1;
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: q = p1 += 3  +  (p2 += 3);
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(q);         //prints: 17'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p1);        //prints: 17'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(p2);        //prints: 4'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, now the first operator assignment `+=` was executed last in
    the right-hand expression.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: Using parentheses increases the readability of a complex expression.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: You can take advantage of operator precedence and write an expression with very
    few parentheses, if any at all. But the quality of code is defined not only by
    its correctness. Being easy to understand, so that other programmers—maybe not
    so well versed in operator precedence—can maintain it is also one of the criteria
    for well-written code. Besides, even the code's author, after some time, may have
    difficulty trying to understand not-clearly-structured expressions.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation order of operands
  id: totrans-762
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While evaluating an expression, parentheses and operator precedence are taken
    into account first. Then, those parts of the expression that have the same level
    of execution priority are evaluated as they appear when moving from left to right.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Using parentheses improves the understanding of a complex expression, but too
    many nested parentheses can obscure it. If in doubt, consider breaking the complex
    expression into several statements.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the evaluation comes down to each operator and its operands. Operands
    of a binary operator are evaluated from left to right so that left-hand operand
    is fully evaluated before the evaluation of the right-hand operator starts. As
    we have seen, the left-hand operand can have a side effect that affects the right-hand
    operator''s behavior. Here is a simplistic example:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: int a = 0, b = 0;
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 'int c = a++ + (a * ++b);       //evaluates to: 0 + (1 * 1);'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(c);         //prints: 1'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: In real-life examples, the expression can include methods with complex functionality
    behind and wide-reaching side effects. The left-hand operand can even throw an
    exception, so the right-hand operand will never be evaluated. But if the left-hand
    evaluation completes without exceptions, Java guarantees that both operands are
    fully evaluated before the operator is executed.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule does not apply though to conditional operators `&&`, `||`, and `?:` (see
    the *Conditional operators: && || ? : (ternary)* section).'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Widening and narrowing reference types
  id: totrans-773
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of reference types, assigning a child object reference to the variable
    of the parent class type is called widening reference conversion or upcasting.
    The assigning of a parent class type reference to the variable of a child class
    type is called narrowing reference conversion or downcasting.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: Widening
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For example, if a class, `SomeClass`, extends `SomeBaseClass`, the following
    declaration and initialization are possible:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: 'And, since every class extends the `java.lang.Object` class by default, the
    following declarations and initializations are possible too:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: Object someBaseClass = new SomeBaseClass();
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();             //line 2
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: In line 2, we assigned a subclass instance reference to a variable of a superclass
    type. Methods present in a subclass but not in the superclass are not accessible
    via the reference of the superclass type. The assignment in line 2 is called a
    widening of the reference because it becomes less specialized.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  id: totrans-787
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assigning a parent object reference to the variable of the child class type
    is called narrowing reference conversion or downcasting. It is possible only after
    widening reference conversion has been applied first.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates the case:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: class SomeBaseClass{
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(){
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass extends SomeBaseClass{
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: void someOtherMethod(){
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass = new SomeClass();
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: someBaseClass.someMethod();                  //works just fine
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: //someBaseClass.someOtherMethod();           //compilation error
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: ((SomeClass)someBaseClass).someOtherMethod(); //works just fine
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '//The following methods are available as they come from Object:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: int h = someBaseClass.hashCode();
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: Object o = someBaseClass.clone();
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: //All other public Object's methods are accessible too
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: The narrowing conversion requires casting, and we discussed this in great detail
    when we talked about the cast operator (see the *Cast operator* section), including
    casting to an interface, which is another form of upcasting.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Widening and narrowing conversion of primitive types
  id: totrans-812
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a value (or variable) of one numeric type is assigned to a variable of
    another numeric type, the new type may hold a bigger number or smaller maximum
    number. If the target type can hold a bigger number, the conversion is widening.
    If otherwise, it is a narrowing conversion, which usually requires a typecasting
    using a cast operator.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: Widening
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maximum number a numeric type can hold is determined by the number of bits
    allocated to this type. To remind you, here is the number of bits for each numeric
    type representation:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: 8 bit'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: 16 bit'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: 16 bit'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: 32 bit'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: 64 bit'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: 32 bit'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: 64 bit'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Java Specification defines 19 widening primitive conversions:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '`byte` to `short`, `int`, `long`, `float`, or `double`'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short` to `int`, `long`, `float`, or `double`'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` to `int`, `long`, `float`, or `double`'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to `long`, `float`, or `double`'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` to `float` or `double`'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `double`'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In widening conversions between integral types and some conversions from integral
    types to floating-point values, the resulting value remains the same as the original
    one. But conversion from `int` to `float`, or from `long` to `float`, or from
    `long` to `double`, may result, according to the specification:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '"in loss of precision - that is, the result may lose some of the least significant
    bits of the value. In this case, the resulting floating-point value will be a
    correctly rounded version of the integer value, using IEEE 754 round-to-nearest
    mode."'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this effect through code examples and start with `int` type
    conversion to `float` and `double`:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: int n = 1234567899;
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: float f = (float)n;
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: int r = n - (int)f;
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);    //prints: -46'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: double d = (double)n;
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: r = n - (int)d;
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);    //prints: 0'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'As the specification stated, only the conversion from `int` to `float` has
    lost precision. Conversion from `int` to `double` was just fine. Now, let''s convert `long` type:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: long l = 1234567899123456L;
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: float f = (float)l;
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: long rl = l - (long)f;
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(rl);    //prints: -49017088'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: double d = (double)l;
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: rl = l - (long)d;
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(rl);    //prints: 0'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: l = 12345678991234567L;
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: d = (double)l;
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: rl = l - (long)d;
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(rl);    //prints: -1'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: Conversion from `long` to `float` lost precision big time. Well, the specification
    warned us about it. But conversion from `long` to `double` looked fine at first.
    Then, we increased the `long` value approximately ten times and got a precision
    loss of `-1`. So, it depends on how big the value is too.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: Despite that, the Java specification does not allow any runtime exceptions caused
    by widening conversion. In our examples, we did not encounter an exception either.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The narrowing conversion of numeric primitive types occurs in the opposite
    direction—from the wider type to the narrower one—and typically requires casting.
    The Java specification identifies 22 narrowing primitive conversions:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '`short` to `byte` or `char`'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` to `byte` or `short`'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to `byte`, `short`, or `char`'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` to `byte`, `short`, `char`, or `int`'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` to `byte`, `short`, `char`, `int`, or `long`'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` to `byte`, `short`, `char`, `int`, `long`, or `float`'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can result in a loss of magnitude of the value and possibly in loss of precision
    too. The narrowing procedure is more complicated than the widening one and discussion
    of it is beyond the scope of an introductory course. The least one can do is to
    make sure that the original value is smaller than the maximum value of the target
    type:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: double dd = 1234567890.0;
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Integer.MAX_VALUE); //prints: 2147483647'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: if(dd < Integer.MAX_VALUE){
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: int nn = (int)dd;
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(nn);              //prints: 1234567890'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(dd - Integer.MAX_VALUE);
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: dd = 2234567890.0;
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Integer.MAX_VALUE); //prints: 2147483647'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: if(dd < Integer.MAX_VALUE){
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: int nn = (int)dd;
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(nn);
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(dd - Integer.MAX_VALUE); //prints: 8.7084243E7'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these examples, the narrowing conversion happens just fine
    when the number fits the target type, but we even do not try to convert if the
    original value is bigger than the maximum value of the target type.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: Before casting, think about the maximum value the target type can hold, especially
    while narrowing the value type.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: But there is more to it than just avoiding complete loss of value. Things get
    especially complicated with the conversion between type `char` and types `byte`
    or `short`. The reason for this is that type `char` is an unsigned numeric type,
    while types byte and short are signed numeric types, so some loss of information
    is possible.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: Methods of primitive type conversion
  id: totrans-888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting is not the only way to convert one primitive type to another. Each of
    the primitive types has a corresponding reference type – a class called a wrapper
    class of a primitive type.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 'All wrapper classes are located in the `java.lang` package:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.Boolean`'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Byte`'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Character`'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Short`'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Integer`'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Long`'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Float`'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Double`'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of them—except the `Boolean` and `Character` classes—extend the `java.lang.Number` class, which
    has the following abstract method declarations:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '`byteValue()`'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shortValue()`'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intValue()`'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longValue()`'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`floatValue()`'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doubleValue()`'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that every `Number` class child has to implement all of them. Such
    methods are implemented in the `Character` class too, while the `Boolean` class
    has the `booleanValue()` method. These methods can be used to widen and narrow primitive
    types too.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each of the wrapper classes has methods that allow the conversion
    of `String` representation of a numeric value to the corresponding primitive numeric
    type or reference type, for example:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: byte b = Byte.parseByte("3");
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: Byte bt = Byte.decode("3");
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: boolean boo = Boolean.getBoolean("true");
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: Boolean bool = Boolean.valueOf("false");
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: int n = Integer.parseInt("42");
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer = Integer.getInteger("42");
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: double d1 = Double.parseDouble("3.14");
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: Double d2 = Double.valueOf("3.14");
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: After that, the previously listed methods (`byteValue()`, `shortValue()`, and
    so on) can be used to convert the value to another primitive type.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 'And each of the wrapper classes has the static method `toString(primitive value)`
    to convert the primitive type value to its `String` representation:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = Integer.toString(42);
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = Double.toString(3.14);
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper classes have many other useful methods of conversion from one primitive
    type to another, and to different formats and representations. So, if you need
    to something like that, look in the `java.lang` package at its numeric type class
    wrappers first.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: One of the type conversions allows for creating a wrapper class object from
    the corresponding primitive type and vice versa. We will discuss such conversions
    in the next section.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and unboxing between primitive and reference types
  id: totrans-926
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boxing converts the value of a primitive type to an object of a corresponding
    wrapper class. Unboxing converts the object of a wrapper class to a value of the
    corresponding primitive type.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: Boxing
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boxing a primitive type can be done either automatically (called autoboxing)
    or explicitly using the `valueOf()` method available in each wrapper type:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: int n = 12;
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer = n; //an example of autoboxing
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer);      //prints: 12'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: integer = Integer.valueOf(n);
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer);      //prints: 12'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Byte b = Byte.valueOf((byte)n);
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: Short s = Short.valueOf((short)n);
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: Long l = Long.valueOf(n);
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: Float f = Float.valueOf(n);
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: Double d = Double.valueOf(n);
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the input value of the `valueOf()` method of the `Byte` and `Short`
    wrappers required casting because it was a narrowing of a primitive type, which
    we discussed in the previous section.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: Unboxing
  id: totrans-943
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unboxing can be accomplished using the methods of the `Number` class implemented
    in each wrapper class:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: Integer integer = Integer.valueOf(12);
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.intValue());    //prints: 12'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.byteValue());   //prints: 12'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.shortValue());  //prints: 12'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.longValue());   //prints: 12'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.floatValue());  //prints: 12.0'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(integer.doubleValue()); //prints: 12.0'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to autoboxing, automatic unboxing is possible too:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Long longWrapper = Long.valueOf(12L);
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: long lng = longWrapper;    //implicit unboxing
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lng);   //prints: 12'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: But, it is not called autounboxing. The term implicit unboxing is used instead.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: Method equals() of reference types
  id: totrans-961
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The equality operator, when applied to reference types, compares the reference
    values, not the content of the objects. It returns `true` only when both references
    (variable values) point to the same object. We have demonstrated it several times
    already:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass o1 = new SomeClass();
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass o2 = new SomeClass();
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(o1 == o2);  //prints: false'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(o1 == o1);  //prints: true'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: o2 = o1;
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(o1 == o2);  //prints: true'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: This means that the equality operator returns `false` even when two objects
    of the same class with the same field values are compared. That is often not what
    programmers need. Instead, we usually need to consider two objects to be equal
    when they have the same type and the same field values. Sometimes, we even do
    not want to consider all the fields, but only those that identify the object as
    unique in our program logic. For example, if a person changes their hairstyle
    or dress, we still identify him or her as the same person, even if an object that
    describes the person has the field `hairstyle` or `dress`.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Using the implementation of the base class Object
  id: totrans-972
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For such a comparison of objects—by the value of their fields—the `equals()` method is
    to be used. In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, we already established that all reference types extend (implicitly)
    the `java.lang.Object` class, which has the `equals()` method implemented:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object obj) {
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: return (this == obj);
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it compares only references using the equality operator, which
    means that if a class or one of its parents does not implement the `equals()` method (which
    overrides the implementation of the `Object` class), the result of using the `equals()` method will
    be the same as using the equality operator `==`. Let''s demonstrate this. The
    following class does not implement the `equals()` method:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: class PersonNoEquals {
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: public PersonNoEquals(int age, String name) {
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use it and compare the results of the `equals()` method and the `==` operator,
    we will see the following:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: PersonNoEquals p1 = new PersonNoEquals(42, "Nick");
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: PersonNoEquals p2 = new PersonNoEquals(42, "Nick");
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: PersonNoEquals p3 = new PersonNoEquals(25, "Nick");
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1.equals(p2));     //false
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1.equals(p3));     //false
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1 == p2);          //false
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: p1 = p2;
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1.equals(p2));     //true
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p1 == p2);          //true
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: As we expected, the results are the same, whether we use the `equals()` method or
    the `==` operator.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the equals() method
  id: totrans-1003
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `equals()` method:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: class PersonWithEquals{
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: private String hairstyle;
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithEquals(int age, String name, String hairstyle) {
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: this.hairstyle = hairstyle;
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals person = (PersonWithEquals) o;
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.age && Objects.equals(name, person.name);
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, while establishing the objects'' equality, we ignore the `hairstyle` field.
    Another aspect that requires comments is the use of the `equals()` method of the `java.utils.Objects` class.
    Here is its implementation:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: public static boolean equals(Object a, Object b) {
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: return (a == b) || (a != null && a.equals(b));
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it compares references first, then makes sure that one is not
    `null` (to avoid `NullPointerException`), then uses the `equals()` method of the `java.lang.Object` base
    class or the overriding implementation that might be present in a child passed
    in as a parameter value.  In our case, we pass in parameter objects of type `String`
    that do have the `equals()` method implemented, which compares `String` type values,
    not just references (we will talk about it shortly). So, any difference in any
    field of objects, `PersonWithEquals`, will cause the method to return `false`.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the test again, we will see this:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals p11 = new PersonWithEquals(42, "Kelly", "Ponytail");
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals p12 = new PersonWithEquals(42, "Kelly", "Pompadour");
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithEquals p13 = new PersonWithEquals(25, "Kelly", "Ponytail");
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11.equals(p12));    //true
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11.equals(p13));    //false
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11 == p12);         //false
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: p11 = p12;
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11.equals(p12));    //true
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p11 == p12);         //true
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `equals()` method returns `true` not only when references are equal
    (so they point to the same object), but also when the references are different
    but the objects they refer to have the same type and the same values of certain
    fields that are included in the object identification.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: Using the identification implemented in the parent class
  id: totrans-1044
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could create a base class, `Person`, that has only the two fields `age`
    and `name` and the `equals()` method, as implemented previously. Then, we could
    extend it with the `PersonWithHair` class (which has the additional field `hairstyle`):'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: class Person{
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person) o;
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.age && Objects.equals(name, person.name);
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: class PersonWithHair extends Person{
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: private String hairstyle;
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithHair(int age, String name, String hairstyle) {
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name);
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: this.hairstyle = hairstyle;
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects of the `PersonWithHair` class would compare the same way as in
    the previous test of `PersonWithEquals`:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHair p21 = new PersonWithHair(42, "Kelly", "Ponytail");
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHair p22 = new PersonWithHair(42, "Kelly", "Pompadour");
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHair p23 = new PersonWithHair(25, "Kelly", "Ponytail");
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21.equals(p22));    //true
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21.equals(p23));    //false
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21 == p22);         //false
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: p21 = p22;
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21.equals(p22));    //true
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p21 == p22);         //true
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: 'That is possible because an object of `PersonWithHair` is of a type `Person`
    too, so take this line:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person) o;
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: The preceding line in the `equals()` method does not throw `ClassCastException`.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create the `PersonWithHairDresssed` class:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: PersonWithHairDressed extends PersonWithHair{
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: private String dress;
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithHairDressed(int age, String name,
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: String hairstyle, String dress) {
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name, hairstyle);
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: this.dress = dress;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the same test again, it will yield the same results. But we think
    that dress and hairstyle are not part of the identification, so we can run the
    test to compare the children of `Person`:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p32));    //false
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p33));    //false
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31 == p32);         //false
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: 'That was not what we expected! The children were considered not equal because
    of this line in the `equals()` method of the `Person` base class:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding line failed because the `getClass()` and `o.getClass()` methods return
    the child class name – the one that was instantiated with the `new` operator.
    To get out of this jam, we use the following logic:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of the `equals()` method is located in the `Person` class,
    so we know that the current object is of type `Person`
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare classes, all we need to do is to make sure that the other object
    is of type `Person` too
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we replace this line:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following code:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: if(!(o instanceof Person)) return false;
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be this:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p32));    //true
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31.equals(p33));    //false
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p31 == p32);         //false
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: That is what we wanted, didn't we? This way, we have achieved the original idea
    of not including hairstyle and dress in the person's identification.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: In the case of object references, the equality operators `==` and `!=` compare
    the references themselves - not the values of the objects' fields (states). If
    you need to compare object states, use the `equals()` method that has overridden
    the one in the `Object` class.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: The `String` class and the wrapper classes of primitive types override the `equals()` method too.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method of the String class
  id: totrans-1135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*, we have already discussed this and even reviewed the source
    code. Here it is:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object anObject) {
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: if (this == anObject) {
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: if (anObject instanceof String) {
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: String aString = (String)anObject;
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: if (coder() == aString.coder()) {
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: return isLatin1() ?
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: StringLatin1.equals(value, aString.value)
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: ': StringUTF16.equals(value, aString.value);'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it overrides the `Object` class implementation in order to
    compare values, not just references. This code proves it:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: String sl1 = "test1";
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: String sl2 = "test2";
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: String sl3 = "test1";
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1 == sl2);              //1: false'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1.equals(sl2));         //2: false'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1 == sl3);              //3: true'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1.equals(sl3));         //4: true'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = new String("test1");
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = new String("test2");
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: String s3 = new String("test1");
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1 == s2);                //5: false'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1.equals(s2));           //6: false'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1 == s3);                //7: false'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s1.equals(s3));           //8: true'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1 == s1);               //9: false'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sl1.equals(s1));          //10: true'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the equality operator `==` sometimes compares the `String`
    object values correctly and sometimes doesn't. The `equal()` method, though, always compares
    the values correctly, even if they are wrapped in different objects, not just
    refer literals.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: We included the equality operator in the test in order to clarify the cases
    of incorrect explanation of `String` values one can read on the internet more
    often than one might expect. The incorrect explanation is based on the JVM implementation
    that supports `String` instance immutability (read about `String` immutability
    and the motivation for it in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*). The JVM does not store the same `String` value
    twice and reuses the value already stored in the area called the **string pool** in
    the process called **strings interning**.  After learning about that, some people
    assume that using the `equals()` method with `String` values is unnecessary because
    the same value will have the same reference value anyway. Our test proves that,
    in the case of a `String` value wrapped in the class `String`, its value cannot
    be compared correctly by the equality operator and one must use the `equals()` method instead.
    There are also other cases when a `String` value is not stored in the string pool.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: To compare two `String` objects by value, always use the `equals()` method,
    not the equality operator `==`.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: In general, the `equals()`method is not as fast as the  `== `operator. But,
    as we already pointed out in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types,* the `equals()` method of class String compares
    references first, which means there is no need to try to save performance time and
    compare references in the code before calling the `equals()` method. Just call
    the `equals()` method.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: The ambiguity of `String` type behavior—sometimes like a primitive type, other
    times like a reference type—reminds me of the double nature of elementary particles
    in physics. Particles sometimes behave like small concentrated objects, but other
    times like waves. What is really going on behind the scenes, deep in the guts
    of the matter? Is something is immutable there too?
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method in wrapper classes of primitive types
  id: totrans-1177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run the test for a wrapper class, the results will be:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: long ln = 42;
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Integer n = 42;
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(42));      //true
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(ln));      //false
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(43));      //false
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(Integer.valueOf(42)));  //true
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(n.equals(Long.valueOf(42)));     //false
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our experience with the children of `Person`, we can quite confidently
    assume that the `equals()` methods of the wrapper classes include the comparison
    of class names. Let''s look at the source code. Here is the `equals()` method
    of the `Integer` class:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object obj) {
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: if (obj instanceof Integer) {
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: return value == ((Integer)obj).intValue();
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: That is exactly what we expected. If an object is not an instance of the `Integer` class,
    it can never be considered equal to an object of another class, even if it carries
    exactly the same numeric value. It looks like the system of social classes in
    the olden days, doesn't it?
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Naming the statements
  id: totrans-1198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the following statements called?
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '`i++;`'
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String s;`'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s = "I am a string";`'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doSomething(1, "23");`'
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer
  id: totrans-1204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following statements are called:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: 'Increment statement: `i++;`'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable declaration statement: `String s;  `'
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assignment statement: `s = "I am a string";`'
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method invocation statement: `doSomething(1, "23");`'
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned what the three core elements of Java programming
    are—operators, expressions, and statements—and how they are related to each other.
    We walked you through all the Java operators, discussed the most popular ones
    with examples, and explained the potential issues with using them. A substantial
    part of this chapter was dedicated to data type conversion: widening and narrowing,
    boxing, and unboxing. The `equals()` method of reference types was also demonstrated
    and tested on specific examples for a variety of classes and implementations.
    The `String` class was used prominently and the popular incorrect explanation
    of its behavior was resolved.'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will start writing the program logic—the backbone of
    any execution flow—using control flow statements, which are going to be defined,
    explained, and demonstrated in many examples: conditional statements, iterative
    statements, branching statements, and exceptions.'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
