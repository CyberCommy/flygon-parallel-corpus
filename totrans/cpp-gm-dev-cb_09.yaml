- en: Chapter 9. Physics in Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using physics rules in your game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making things collide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and integrating Box2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a basic 2D game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a 3D game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ragdoll in your game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern games, and games of the past, some type of physics has always been
    added to increase the sense of realism. Although most physics in games is an approximation
    or optimization of actual physics rules, it does a good job of achieving the desired
    results. Physics in games is basically a rough implementation of the Newtonian
    laws of motion, mixed with the basic fundamentals of collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: The trick for a games developer is to write the code in such a way that it does
    not bottleneck the CPU and the game still runs at a desired framework. We will
    discuss some basic concepts that we require to introduce physics into our game.
    For the sake of simplicity, we have integrated **Box2D** into our engine and,
    along with a renderer (**OpenGL**), we will output some physics interaction between
    objects. For 3D physics, we will get help from the **Bullet Physics** SDK and
    display the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Using physics rules in your game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to have physics in the game is to have the environment ready
    so that proper calculations can be applied to the bodies, and the physics simulation
    can work on them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to add physics rules to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: First, set up all the objects in the game scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give them properties so that they have vector points and velocities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign bounding boxes or bounding circles, depending on the shape of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply forces on each of the bodies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detect collisions between them based on the shape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve for the constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step for a body to exhibit physics properties is for it to be a rigid
    body. This is however not true if your body is supposed to have some kind of fluid
    physics, as is the case for a plastic or any other soft body. In that case, we
    will have to set up the world differently, as it is a far more complex problem.
    A rigid body, in short, is any object in world space that will not deform, even
    if external sources are applied to it. Even in game engines such as Unity or UE4,
    if you assign a body as a rigid body, it will automatically react, based on the
    physics simulation property of the engine. After the rigid body is set up, we
    need to determine if the body is static or dynamic. This step is important as
    we can greatly reduce the number of calculations if we know that the body is static.
    A dynamic body must be assigned velocities as well as vector positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the previous step is complete, the next step is to add colliders or bounding
    objects. These will actually be used for the calculation of collision points.
    For example, if we have a 3D model of a human, it is sometimes not very wise to
    use the exact body mesh for collisions. Instead, we could use a capsule, which
    is a cylinder with two half spheres on either end for the body and a similar structure
    for the hands. In the case of a 2D object, we make a choice between a circular
    bounding object or a box bounding object. The following diagram shows the object
    in black and the bounding box in red. We can now apply force or impulse to the
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next step in the pipeline is to actually detect when two objects have collided.
    We will discuss this further in the next recipe. But let's say we have to detect
    whether `circle A` has collided with `circle B`; in most cases we just need information
    on whether they have collided, rather than the exact point of contact. In this
    case, we need to write some mathematical functions to detect that. We then return
    the output and, based on that, we write our logic for collision and finally display
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, there is a function called `b2CollidePolygonAndCircle`
    which is used to calculate the collision between a polygon and a circle. We define
    the two shapes and then try to calculate various details that determine whether
    the points of the polygon and the circle intersect. We need to find the edge list
    point and then calculate whether the points lie inside the other shape, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Making things collide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A huge part of the physics system is making things collide. We need to figure
    out whether the objects have collided and pass on the relevant information. In
    this recipe, we will look at different techniques to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a Windows machine and a working copy of Visual Studio. No other prerequisites
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to detect collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming the objects in the scene are already set up as rigid body, and the
    proper impulses are added to each, the next step is to detect collisions. An impulse
    is a force that acts on a body. The force acts briefly on the body and results
    in some change of momentum.
  prefs: []
  type: TYPE_NORMAL
- en: In games, collision detection usually happens in two phases. The first phase
    is called the **broad-phase** **collision** and the next phase is called the **narrow-phase
    collision**. The broad phase is less expensive, as it deals with the concept of
    which bodies are most likely to collide. The narrow phase is more expensive because
    it actually compares each body for collisions. In a games environment, it is not
    feasible to have everything in the narrow phase. Hence, most of the work is done
    in the broad phase. Broad phase algorithms work with sweep and prune (sort and
    prune) or Space partition trees. In the sweep and prune technique, all the lower
    ends and upper ends of the bounding boxes of a solid are sorted and checked for
    intersections. After that, it is sent to a more detailed check in the narrow phase.
    So in this method, we need to update the bounding box of the solid every time
    it changes its orientation. The other technique used is **BSP**. We have already
    discussed BSP in previous chapters. We need to partition the scene in such a way
    that in each subdivision, only a certain number of objects can collide. In the
    narrow phase collision, a more pixel-perfect collision detection algorithm is
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways to check for collisions. It entirely depends on the
    shape that is acting as the bounding box. Also, it is important to understand
    how the bounding box is aligned. In a normal scenario, a bounding box would be
    axes-aligned and would be referred to as `AABB`. To detect whether two Box2D bounding
    boxes have collided, we would have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can then extend this to detect more complex shapes for rectangles, circles,
    lines, and other polygons. If we are writing our own 2D physics engine, then we
    would have to write a function for each combination of shapes intersecting with
    one another. If we use a physics engine such as Box2D or PhysX, these functions
    would already be written for us and we would have to just use them properly and
    consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and integrating Box2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to work with 2D physics, one great open source physics engine is
    Box2D. This comes with lots of functions that are common for any 2D game built
    in, so we do not have to reinvent the wheel and write them again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://box2d.org/](http://box2d.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to [http://box2d.org/downloads/](http://box2d.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download or clone the latest copy from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the solution in your version of Visual Studio. Some projects may not work,
    as they were built in different versions of Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this throws an error, clean the solution, delete the `bin` folder, and rebuild
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the solution rebuilds successfully, run the `TestBed` projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you can run the application successfully, Box2D has been integrated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Box2D is a physics engine built entirely in C++. As it has given us access to
    the source code, it means we can build it from scratch as well, and check for
    ourselves how each function is written. As the project is hosted on GitHub, every
    time a new development is made, we can clone it and be updated with all the latest
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, Box2D already has a project called `TestBed`, which has loads
    of sample applications that can be run. It is actually a collection of loads of
    different types of application. `Test Entries` is the entry point of all the applications.
    It is a long array of the different applications that we want rendered in the
    `TestBed` project. The array contains the name of the application and the static
    function to initialize the world.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the output of the physics simulation is fed to the renderer, which
    in this case is OpenGL, and it draws the scene for us.
  prefs: []
  type: TYPE_NORMAL
- en: Making a basic 2D game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every 2D game is different. However, we can generalize the physics functions
    that are going to be used in most 2D games. In this recipe, we will create a basic
    scene using Box2D's built-in functions and the `TestBed` project. The scene will
    mimic one of the most popular 2D games of our times, *Angry Birds*TM.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to add a barebones architecture
    for a 2D game using Box2D:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are using the Box2D engine to calculate the physics. The
    main class of `Test Entries`, as described previously, is used to store the name
    of the application and the static create method. In this case, the name of the
    application is `Tiles`. In the tiles application, we have created a physics world
    using Box2D shapes and functions. The pyramid of tiles is created with the help
    of boxes. These boxes are dynamic in nature, which means they will react and move
    based on the forces applied to them. The base or the ground is also made of tiles.
    However, those tiles are stationary and do not move. We assign a position and
    velocity for all the tiles that make up the ground and the pyramid. It is not
    practical to individually assign a position and velocity to each tile, so we do
    this with an iteration loop.
  prefs: []
  type: TYPE_NORMAL
- en: After the scene is built, we can interact with the pyramid using a mouse click.
    From the GUI, other properties can also be switched on or off. Pressing the Space
    bar also triggers a ball at a random position which will destroy the formation
    of the tiles, much like *Angry Birds*. We can also write logic to make all the
    tiles that collide with the ground disappear and add points to the score every
    time that happens, and then we have ourselves a small 2D *Angry Birds* clone.
  prefs: []
  type: TYPE_NORMAL
- en: Making a 3D game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not much changes when we shift our focus from physics in 2D to physics in 3D.
    We now need to worry about another dimension. As mentioned in the previous recipes,
    we still need to maintain the environment so that it follows Newtonian rules and
    solves constraints. There are a lot of things that can go wrong while rotating
    the body in 3D space. In this recipe, we will look at a very basic implementation
    of 3D physics using the Bullet Engine SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will see how easy it is to write a physics world in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: 'For broad-phase collision take a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For narrow-phase collision, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see from the example above, even in 3D the physics collision system
    has to be divided into phases: the broad phase and the narrow phase. In a broad-phase
    collision, we now take into account Vector3, instead of just two float points,
    as we now have three axes (*x*, *y*, and *z*). We need to enter the object ID
    and then check within the bounds of the bounding boxes. Similarly, for a narrow-phase
    collision, our problem domain and calculations remain the same. We now change
    it to support 3D. The previous example shows a part of a problem that would arise
    if we need to find the contact points in a narrow phase collision. We create an
    array and, based on the collision callbacks, we save out all the points that are
    in contact. Later on, we can write other methods to check whether the points are
    overlapping or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a particle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle systems are quite important in games in order to add to the visual
    representation of the whole feel of the game. Particle systems are quite easy
    to write and are merely a collection of one or more particles. So we need to create
    a single particle with some properties and then let the particle system decide
    how many particles it wants.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a source file called `Source.cpp`. Then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see in the example, our first task is to create a `particle` class.
    The `particle` class will have properties such as `velocity`, `acceleration`,
    `position`, and `lifespan`. Because we are making the particle in 3D space, we
    are using Vector3 to denote the particle''s properties. If we were to create the
    particle in 2D space, we would have used Vector2 to do this. In the constructor,
    we assign the starting values of the attributes. We then have two main functions,
    `update` and `display`. The `update` function updates the `velocity` and `position`
    every frame, and also reduces the lifespan so that it disappears when its lifespan
    is over. In the `display` function, we need to specify how we want the particle
    to be viewed: whether it should have stroke or fill, and so on. Here we also have
    to specify the shape of the particle. The most common shape is a sphere or a cone.
    We have used a trapezoid just to denote that we can specify any shape. Finally,
    from the client program, we need to call this object and then access the various
    functions to display the particle.'
  prefs: []
  type: TYPE_NORMAL
- en: However, all this will do is display just one particle on the screen. Of course,
    we can create an array of 100 objects and that would display 100 particles on
    the screen. A better approach is to create a particle system, which creates an
    array of particles. The number of particles that will be drawn is specified by
    the client program. Based on the request, the particle system draws the required
    number of particles. Also, there must be a function to determine which particles
    are to be removed from the screen. This is dependent on the lifespan of each particle.
  prefs: []
  type: TYPE_NORMAL
- en: Using ragdoll in your game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ragdoll physics** is a special kind of procedural animation that is often
    used as a replacement for traditional static death animations in games. The whole
    idea of ragdoll animation is that after death a character falls as if the bones
    of the body are behaving like a ragdoll. Hence the name. It has nothing to do
    with realism, but adds a special fun element to the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio. The DirectX SDK is also required; preferably use the DirectX June
    2010 edition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from the example above, for this example you require a skinned
    mesh model. The mesh model can either be downloaded from some royalty-free website,
    or made via Blender or any other 3D software package, such as Maya or Max. As
    the whole concept of a ragdoll is based on the bones of the mesh, we have to make
    sure that the 3D model has the bones set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: After that, there are lots of small parts in the code. The first part of the
    problem is to write a bone container class, which stores all the bone information.
    Next, we need to use the bone container class and by using the Bullet physics
    SDK, assign a rigid body to each of the bones. After the rigid body has been set
    up, we need to traverse through the bones once again and create a relationship
    between each bone, so that when one bone moves, the neighboring bones move as
    well. Finally, we also need to add constraints so that when the physics engine
    simulates the ragdoll, it can solve the constraints properly and output the result
    to the bones.
  prefs: []
  type: TYPE_NORMAL
