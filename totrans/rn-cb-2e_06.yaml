- en: Adding Basic Animations to Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animated notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding and collapsing containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a button with a loading animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provide a good user experience, we'll likely want to add some animations
    to direct the user's attention, to highlight specific actions, or just to add
    a distinctive touch to our app.
  prefs: []
  type: TYPE_NORMAL
- en: There's an initiative in progress to move all the processing from JavaScript
    to the native side. At the time of writing (React Native Version 0.58), we can
    choose to use the native driver to run all these calculations in the native world.
    Unfortunately, this cannot be used with all animations, particularly those related
    to layout, such as flexbox properties. Read more about caveats when using native
    animation in the documentation at [http://facebook.github.io/react-native/docs/animations#caveats](http://facebook.github.io/react-native/docs/animations#caveats).
  prefs: []
  type: TYPE_NORMAL
- en: All of the recipes in this chapter use the JavaScript implementation. The React
    Native team has promised to use the same API when moving all of the processing
    to the native side, so we don't need to worry about breaking changes to the existing
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn the basics of animations. We will use an image
    to create a simple linear movement from the right to the left of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to go through this recipe, we need to create an empty app. Let's call
    it `simple-animation`.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a PNG image of a cloud for this recipe. You can find the
    image in the recipe's repository hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/simple-animation/assets/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/simple-animation/assets/images).
    Place the image in the `/assets/images` folder for use in the app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by opening `App.js` and importing the dependencies for the `App`
    class. The `Animated` class will be responsible for creating the values for the
    animation. It provides a few components that are ready to be animated, and it
    also provides several methods and helpers to run smooth animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Easing` class provides several helper methods for both calculating movements
    (such as `linear` and `quadratic`) and predefined animations (such as `bounce`, `ease`,
    and `elastic`).   We are going to use the `Dimensions` class to get the current
    device size so that we know where to place the element in the initialization of
    the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also initialize some constants that we are going to need in our app.
    In this case, we are going to get the device dimensions, set the size of the image,
    and `require` our image that will be animated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `App` component. We are going to use two methods from
    the component''s life cycle system. If you are not familiar with this concept,
    please review the related React docs ([http://reactjs.cn/react/docs/component-specs.html](http://reactjs.cn/react/docs/component-specs.html)).
    This page also has a really nice tutorial on how life cycle hooks work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create an animation, we need to define a standard value to drive
    the animation. `Animated.Value` is a class that handles the animation values for
    each frame over time. The first thing we need to do is to create an instance of
    this class when the component is created. In this case, we are using the `componentWillMount` method,
    but we can also use the `constructor` or even the default values of a property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the animated value, we can define the animation. We are
    also creating a loop by passing the `start` method of `Animated.timing` an arrow
    function that executes this `startAnimation` function again. Now, when the image
    reaches the end of the animation, we will start the same animation again to create
    an infinitely looping animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our animation in place, but we are currently only calculating the values
    for each frame over time, not doing anything with those values. The next step
    is to render the image on the screen and set the property on the styles that we
    want to animate. In this case, we want to move the element on the *x*-axis; therefore,
    we should update the `left` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the simulator, we will see the image on the screen, but it''s
    not being animated yet. In order to fix this, we need to call the `startAnimation`
    method. We will start the animation once the component is fully rendered, using
    the `componentDidMount` lifecycle hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the app again, we will see how the image is moving at the top of
    the screen, just like we wanted! As a final step, let''s add some basic styles
    to the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1dda7b4d-ccd4-4a02-851a-feddfc257ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 5*, we set the animation values. The first line resets the initial
    value every time we call this method. For this example, the initial value will
    be the `width` of the device, which will move the image to the right-hand side
    of the screen, where we want to start our animation.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `Animated.timing` function to create an animation based on
    time and take two parameters. For the first parameter, we pass in `animatedValue`,
    which we created in the `componentWillMount` lifecycle hook in *step 4*. The second
    parameter is an object with configurations for the animation. In this case, we
    are going to set the end value to minus the width of the image, which will place
    the image on the left-hand side of the screen. We complete the animation there.
  prefs: []
  type: TYPE_NORMAL
- en: With the entire configuration in place, the `Animated` class will calculate
    all the frames required in the 6 seconds allotted to perform a linear animation
    from right to left (via the `duration` property being set to `6000` milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: We have another helper provided by React Native that can be paired with `Animated`,
    called `Easing`. In this case, we are using the `linear` property of the `Easing`
    helper class. `Easing` provides other common easing methods, such as `elastic` and `bounce`.
    Take a look at the `Easing` class documentation and try setting different values
    for the `easing` property to see how each works. You can find the documentation
    at [https://facebook.github.io/react-native/docs/easing.html](https://facebook.github.io/react-native/docs/easing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once the animation is configured correctly, we need to run it. We do this by
    calling the `start` method. This method receives an optional `callback` function
    parameter that will be executed when the animation is completed. In this case,
    we are running the same `startAnimation` function recursively. This will create
    an infinite loop, which is what we want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we are rendering the image. If we want to animate an image, we
    should always use the `Animate.Image` component. Internally, this component will
    handle the values of the animation and will set each value for every frame on
    the native component. This avoids running the render method in the JavaScript
    layer on every frame, allowing for smoother animations.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the `Image`, we can also animate the `View`, `Text`, and `ScrollView`
    components. There's support for all four of these components out of the box, but
    we could also create a new component and add support for animations via `Animated.createAnimatedComponent()`.
    All four of these components are able to handle style changes. All we have to
    do is pass `animatedValue` to the property that we want to animate, in this case
    the `left` property, but we could use any of the available styles on each component.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the same animation values in several
    elements. This way, we can reuse the same values, along with interpolation, to
    get different values for the remaining elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This animation will be similar to the previous recipe. This time, we will have
    two clouds: one will be smaller with slower movement, the other larger and faster
    moving. At the center of the screen, we will have a static airplane. We won''t
    add any animation to the airplane, but the moving clouds will make it appear as
    though the plane is moving.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start this recipe by creating an empty app called `multiple-animations`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use three different images: two clouds and an airplane. You
    can download the images from the recipe''s repository, hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/multiple-animations/assets/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-6/multiple-animations/assets/images).
    Make sure to place the images in the `/assets/images` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening `App.js` and adding our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we need to define some constants and require the images that
    we are going to use for the animations. Note that we''re using the same cloud
    image as `cloudImage1` and `cloudImage2`, but we will treat them as separate entities
    in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we are going to create the `animatedValue` instance when
    the component gets created, then we will start the animation when the component
    is fully rendered. We are creating an animation that runs in an infinite loop.
    The initial value will be `1` and the final value will be `0`. If you are not
    clear about this code, make sure to read the first recipe in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method in this recipe is going to be quite different from the last.
    In this recipe, we are going to animate two images using the same `animatedValue`.
    The animated value will return values from `1` to `0`; however, we want to move
    the clouds from right to left, so we need to set the `left` value on each element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to set the correct values, we need to interpolate `animatedValue`.
    For the smaller cloud, we will set the initial `left` value to the width of the
    device, but for the bigger cloud, we will set the initial `left` value far away
    from the right-hand edge of the device. This will make the movement distance bigger,
    and therefore it will move faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the correct `left` values, we need to define the elements we want
    to animate. Here, we will set the interpolated value to the `left` styles property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the last step, we need to define some styles, just to set the `width`
    and `height` of each cloud as well as assign styles to the `top`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh our app, we should see the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e752f224-3437-4c01-8bd1-89c74f625a1f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we defined the interpolations to get the `left` value for each
    cloud. The `interpolate` method receives an object with two required configurations,
    `inputRange` and `outputRange`.
  prefs: []
  type: TYPE_NORMAL
- en: The `inputRange` configuration receives an array of values. These values should
    always be ascending values; you could use negative values too, as long as the
    values are ascending.
  prefs: []
  type: TYPE_NORMAL
- en: '`outputRange` should match the number of values defined on `inputRange`. These
    are the values that we need as a result of the interpolation.'
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, `inputRange` goes from `0` to `1`, which are the values of
    our `animatedValue`. In `outputRange`, we defined the limits of the movement that
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animated notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a notification component from scratch. When showing
    the notification, the component will slide in from the top of the screen. After
    a few seconds, we will automatically hide it by sliding it out.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create an app. Let's call it `notification-animation`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by working on the `App` component. First, let''s import all the
    required dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have all the dependencies imported, we can define the `App` class.
    In this case, we are going to initialize the `state` with a `notify` property
    equal to `false`. We are going to use this property to show or hide the notification.
    By default, the notification will not be shown onscreen. To make things simple,
    we will define the `message` property in the `state` with the text we want to
    display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `render` method, we need to show the notification only if the `notify`
    property is `true`. We can achieve this by using an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous step, we only defined the reference to the `Notification` component,
    but we are not using it yet. Let''s define a `return` with all of the JSX needed
    for this app. To keep things simple, we are only going to define a toolbar, some
    text, and a button to toggle the state of the notification when pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define the method that toggles the `notify` property on the
    `state`, which is very simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost done with this class. The only things left are the styles. In
    this case, we will only add basic styles such as `color`, `padding`, `fontSize`,
    `backgroundColor`, and `margin`, nothing really special:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run the app, we will see an error that the `./Notification` module
    couldn''t be resolved. Let''s fix that by defining the `Notification` component.
    Let''s create a `Notifications` folder, with an `index.js` file inside of it.
    Then, we can import our dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the dependencies imported, let''s define the props and the initial
    state of our new component. We are going to define something very simple, just
    a property to receive the message to display, and two `callback` functions to
    allow the running of some actions when the notification appears on the screen
    and when it gets closed. We''ll also add a property to set the number of milliseconds
    to display the notification before it autohides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s finally time to work on the animation! We need to start the animation
    as soon as the component gets rendered. If there''s something not clear in the
    following code, I recommend you take a look at the first and second recipes in
    this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we''ve defined a method to get the animation. For the slide-in movement,
    we need to calculate the values from `0` to `1`. Once the animation is complete,
    we need to run the `onOpen` callback. If the `autoHide` property is set to `true` when
    the `onOpen` method is called, we will automatically run the slide-out animation
    to remove the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding step, we need a method for the slide-out movement.
    Here, we need to calculate the values from `1` to `0`. We are sending the `autoHide` value
    as a parameter to the `getAnimation` method. This will automatically delay the
    animation by the amount of milliseconds defined by the `delay` property (in our
    case, 5 seconds). After the animation has completed, we need to run the `onClose`
    callback function, which will remove the component from the `App` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add the `render` method. Here, we will get the `message` value
    provided by `props`. We also need the `height` of the component to move the component
    to the initial position of the animation; by default, it''s `-1000` but we will
    set the correct value at runtime in the next steps. The `animatedValue` goes from
    `0` to `1` or `1` to `0`, depending on whether the notification is opening or
    closing; therefore, we need to interpolate it to get the actual values. The animation
    will go from minus the height of the component to `0`; this will result in a nice
    slide in/out animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep things as simple as possible, we will return an `Animated.View` with
    some text. Here, we are setting the `top` style with the interpolation result,
    meaning we will animate the top style. As mentioned before, we need to calculate
    the height of the component at runtime. In order to achieve that, we need to use
    the `onLayout` property of the view. This function will be called every time the
    layout updates and will send the new dimensions of this component as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onLayoutChange` method will be very simple. We just need to get the new
    `height` and update the `state`. This method receives an `event`. From this object,
    we can grab useful information. For our purposes, we will access the data at `nativeEvent.layout` in
    the `event` object. The `layout` object contains the screen''s `width` and `height`,
    and the *x* and *y* positions on the screen where the `Animated.View` called this
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last step, we will add some styles to the notification component. Since
    we want this component to animate on top of anything else, we need to set the
    `position` to `absolute`, and set the `left` and `right` properties to `0`. We''ll
    also add some color and padding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look something like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/425fcaa8-645a-4ae2-8d6d-8a97778cdde7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 3*, we defined the `Notification` component. This component receives
    three parameters: a flag to automatically hide the component after a few seconds,
    the message that we want to display, and a `callback` function that will be executed
    when the notification gets closed.'
  prefs: []
  type: TYPE_NORMAL
- en: When the `onClose` callback gets executed, we will toggle the `notify` property
    to remove the `Notification` instance and clear the memory.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we defined the JSX to render the components of our app. It's important
    to render the `Notification` component after the others so that the component
    will appear on top of all other components.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we defined the `state` of our component. The `defaultProps` object
    sets the default values for each property. These values will be applied if no
    value is assigned to the given property.
  prefs: []
  type: TYPE_NORMAL
- en: We defined the default for each `callback` as an empty function. This way, we
    don't have to check whether those props have a value before trying to execute
    them.
  prefs: []
  type: TYPE_NORMAL
- en: For the initial `state`, we defined the `height` property. The actual `height`
    value will be calculated at runtime based on the content received in the `message`
    property. This means we need to initially render the component far away from the
    original position. Since there's a short delay when the layout is calculated,
    we don't want to display the notification at all before it moves to the correct
    position.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 9*, we created the animation. The `getAnimation` method receives two
    parameters: the `delay` to be applied and the `autoHide` Boolean, which determines
    whether the notification automatically closes. We used this method in *step 10*
    and *step 11*.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 13*, we defined the JSX for this component. The `onLayout` function
    is very useful for getting the dimensions of the component when there are updates
    to the layout. For example, if the device orientation changes, the dimensions
    will change, in which case we would like to update the initial and final coordinates
    for the animation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current implementation works pretty well, but there's a performance problem
    we should address. Currently, the `onLayout` method gets executed on every frame
    of the animation, which means we are updating the state on every frame, which
    leads to the component re-rendering on every frame! We should avoid this, and
    only update it once to get the actual height.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we could add a simple validation just to update the state if the
    current value is different than the initial value. This will avoid updating the
    `state` on every frame and we won''t force the render over and over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While this works for our purposes, we could also go further and make sure the
    `height` also gets updated when the orientation changes. However, we'll stop here,
    as this recipe is quite long already.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding and collapsing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a custom container element with a `title` and
    `content`. When a user presses the title, the content will collapse or expand.
    This recipe will allow us to explore the `LayoutAnimation` API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating a new app. We'll call it `collapsable-containers`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the app, let's also create a `Panel` folder with an `index.js`
    file in it for housing our `Panel` component.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by focusing on the `Panel` component. First, we need to import
    all the dependencies that we are going to use for this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the dependencies, let''s declare the `defaultProps` for initializing
    this component. In this recipe, we only need to initialize the `expanded` property
    to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `height` property on the `state` object to expand or
    collapse the container. The first time this component gets created, we need to
    check the `expanded` property in order to set the correct initial `height`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s render the required JSX elements for this component. We need to get
    the `height` value from `state` and set it to the content''s style view. When
    pressing the `title` element, we will execute the `toggle` method (defined later)
    to change the `height` value of the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, the `toggle` method will be executed when the `title`
    element is pressed. Here, we will toggle the `height` on the `state` and call
    the animation we want to use when updating the styles on the next render cycle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete this component, let''s add some simple styles. We need to set the
    `overflow` to `hidden`, otherwise the content will be shown when the component
    is collapsed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our `Panel` component defined, let''s use it on the `App` class.
    First, we need to require all the dependencies in `App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous step, we imported the `Panel` component. We are going to declare
    three instances of this class in the JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the React Native `LayoutAnimation` API in this recipe. This API
    is disabled on Android by default in the current version of React Native. Before
    the `App` component mounts, we''ll use the `Platform` helper with the `UIManager`
    to enable this feature on Android devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add some styles to the toolbar and the main container. We just
    need some simple styles you''re likely used to by now: `padding`, `margin`, and
    `color`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6896c6bd-b770-4a25-8423-6aad90ac4964.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 3*, we set the initial `height` of the content. If the `expanded` property
    was set to `true`, then we should show the content. By setting the `height` value
    to `null`, the layout system will calculate the `height` based on the content;
    otherwise, we need to set the value to `0`, which will hide the content when the
    component is collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we defined all the JSX for the `Panel` component. There are a few
    concepts in this step worth covering. First, the `children` property is passed
    in from the `props` object, which will contain any elements defined between `<Panel>`
    and `</Panel>` when this component is used in the `App` class. This is very helpful
    because, by using this property, we are allowing this component to receive any
    other components as children.
  prefs: []
  type: TYPE_NORMAL
- en: In this same step, we're also getting the `height` from the `state` object and
    setting it as the `style` applied to the `View` with the collapsible content.
    This will update the `height`, causing the component to correspondingly expand
    or collapse. We also declared the `onPress` callback, which toggles the `height`
    on the `state` when the title element is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7,* we defined the `toggle` method, which toggles the `height` value.
    Here, we used the `LayoutAnimation` class. By calling the `spring` method, the
    layout system will animate every change that happens to the layout on the next
    render. In this case, we are only changing `height`, but we can change any other
    property we want, such as `opacity`, `position`, or `color`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LayoutAnimation` class contains a couple of predefined animations. In this
    recipe, we used `spring`, but we could also use `linear` or `easeInEaseOut`, or
    you could create your own using the `configureNext` method.
  prefs: []
  type: TYPE_NORMAL
- en: If we remove the `LayoutAnimation`, we won't see an animation; the component
    will expand and collapse by jumping from `0` to total height. But by adding that
    single line, we're able to easily add a nice, smooth animation. If you need more
    control over the animation, you'll probably want to use the Animation API instead.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9*, we checked the OS property on the `Platform` helper, which returned
    the `'android'` or `'ios'` strings, depending on which device the app is running
    on. If the app is running on Andriod, we use the `UIManager` helper's `setLayoutAnimationEnabledExperimental` method
    to enable the `LayoutAnimation` API.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LayoutAnimation` API documentation at [https://facebook.github.io/react-native/docs/layoutanimation.html](https://facebook.github.io/react-native/docs/layoutanimation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick intro to React's `props.children` at [https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891](https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891)[ ](https://facebook.github.io/react-native/docs/layoutanimation.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a button with a loading animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll continue working with the `LayoutAnimation` class. Here,
    we will create a button, and when the user presses the button, we will show a
    loading indicator and animate the styles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we'll need to create an empty app. Let's call it `button-loading-animation`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also create a `Button` folder with an `index.js` file in it for our `Button`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the `Button/index.js` file. First, we''ll import all the
    dependencies for this component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use only four props for this component: a `label`, a `loading`
    Boolean to toggle displaying either the loading indicator or the label inside
    the button, a callback function to be executed when the button is pressed, and
    custom styles. Here, we''ll `init` the `defaultProps` for loading to `false`,
    and the `handleButtonPress` to an empty function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll keep the `render` method of this component as simple as possible. We''ll
    render the label and the activity indicator based on the value of the `loading`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to render the `label`, we need to check whether the `loading` property
    is `false`. If it is, then we return only a `Text` element with the `label` we
    received from `props`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `renderActivityIndicator` indicator should only apply if the
    value of the `loading` property is `true`. If so, we will return the `ActivityIndicator`
    component. We''ll use the props of `ActivityIndicator` to define a `size` of small
    and a `color` of white (`#fff`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'One method is still missing from our class: `handleButtonPress`. We need to
    inform the parent of this component when the button has been pressed, which can
    be done by calling the `onPress` callback passed to this component via `props`.
    We''ll also use the `LayoutAnimation` to queue an animation on the next render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete this component, we need to add some styles. We''ll define some
    colors, rounded corners, alignment, padding, and so on. For the `loading` styles,
    which will be applied when the loading indicator is displayed, we''ll update the
    padding to create a circle around the loading indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done with the `Button` component. Now, lets''s work on the `App` class.
    Let''s start by importing all the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` class is relatively simple. We will only need to define a `loading`
    property on the `state` object, which will toggle the `Button`''s animation. We''ll
    also render a `toolbar` and a `Button`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the last recipe, we''ll need to manually enable the `LayoutAnimation`
    API on Android devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add some `styles`, just some colors, padding, and alignment
    for centering the button on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4be877c5-963e-4b57-9685-a03b35244a4c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 3*, we added the `render` method for the `Button` component. Here,
    we received the `loading` property and, based on that value, we applied the corresponding
    styles to the `TouchableOpacity` button element. We also used two methods: one
    for rendering the label and the other for rendering the activity indicator.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we executed the `onPress` callback. By default, we declared an
    empty function, so we don't have to check whether the value is present or not.
  prefs: []
  type: TYPE_NORMAL
- en: The parent of this button should be responsible for updating the loading property
    when the `onPress` callback is called. From this component, we are only responsible
    for informing the parent when this button has been pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The `LayoutAnimation.eadeInEaseOut` method only queues an animation for the
    next render phase, which means the animation isn't executed right away. We are
    responsible for changing the styles that we want to animate. If we don't change
    any styles, then we won't see any animations.
  prefs: []
  type: TYPE_NORMAL
- en: The `Button` component doesn't know how the `loading` property gets updated.
    It might be because of a fetch request, a timeout, or any other action. The parent
    component is responsible for updating the `loading` property. Whenever any changes
    happen, we apply the new styles to the button and a smooth animation will occur.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9*, we defined the content of the `App` class. Here, we make use of
    our `Button` component. When the button is pressed, the `state` of the `loading`
    property is updated, which will cause the animation to run every time the button
    is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered the fundamentals of animating your React Native
    app. These recipes have been aimed at both providing useful practical code solutions,
    and also establishing how to use the basic building blocks so that you are better
    equipped to create animations that fit your app. Hopefully, by now, you should
    be getting comfortable with the `Animated` and `LayoutAnimation` animation helpers.
    In [Chapter 7](84fe882a-ef68-470e-8c13-d220b128d4e0.xhtml), *Adding Advanced Animations
    to Your App*, we will combine the things we've learned here to build out more
    complex and interesting app-centric UI animations.
  prefs: []
  type: TYPE_NORMAL
