- en: Chapter 3. Interfaces, Classes and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how TypeScript uses basic types, inferred types, and function
    signatures to bring a strongly typed development experience to JavaScript. TypeScript
    also introduces three concepts borrowed from other object-oriented languages:
    interfaces, classes and generics. In this chapter, we will look at these object-oriented
    concepts, how they are used in TypeScript, and what benefits they bring to JavaScript
    programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: The first section of this chapter is intended for readers that are using TypeScript
    for the first time, and covers interfaces, classes and inheritance from the ground
    up. The second section of this chapter builds on this knowledge, and shows how
    to create and use the Factory Design Pattern. The third section of this chapter
    deals with generics.
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience with TypeScript, are actively using interfaces and classes,
    understand inheritance, and are comfortable with the lexical scoping rules as
    applied to the `this` parameter, then you may be more interested in the later
    sections on the Factory Design Pattern, or generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory Design Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class modifiers, static functions and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime type checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface provides us with a mechanism to define what properties and methods
    an object must implement. If an object adheres to an interface, it is said that
    the object implements the interface. TypeScript will generate compile errors earlier
    in our code if an object does not implement an interface properly. The interface
    is also another way of defining a custom type, and gives us, among other things,
    an early indication—at the time we are constructing an object—that the object
    does not have the properties and methods that we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an interface named `IComplexType` that has an `id` and a `name`
    property. The `id` property is strongly typed to be of type `number`, and the
    `name` property is of type `string`. We then create a variable named `complexType`,
    and use the `:` type syntax to indicate that this variable is of type `IComplexType`.
    The next variable, named `complexType_2`, also strongly types this variable to
    be of type `IComplexType`. We then compare the `complexType` and `complexType_2`
    variables, and log a message to the console if these objects are the same. This
    code, however, will generate a compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This compile error tells us that the `complexType_2` variable must conform
    to the `IComplexType` interface. The `complexType_2` variable has an `id` property,
    but it does not have a `name` property. To fix this error, and to ensure that
    the variable implements the `IComplexType` interface, we simply need to add a
    `name` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have an extra `description` property, the `IComplexType` interface
    only mentions the `id` and `name` properties—so as long as we have those, the
    object is said to be implementing the `IComplexType` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are a compile-time language feature of TypeScript, and the compiler
    does not generate any JavaScript code from interfaces that you include in your
    TypeScript projects. Interfaces are only used by the compiler for type checking
    during the compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we will be sticking to a simple naming convention for interfaces,
    and that is to prefix the interface name with the letter `I`. Using this naming
    scheme helps when dealing with large projects where code is spread across multiple
    files. Seeing anything prefixed with `I` in your code helps you distinguish it
    as an interface immediately. You can, however, call your interfaces anything.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a definition of an object, what data it holds, and what operations
    it can perform. Classes and interfaces form a cornerstone of the principles of
    object-oriented programming, and often work together in design patterns. A design
    pattern is a simple programming structure that has been proven to be the best
    way of tackling a specific programming task. More on design patterns later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recreate our previous code sample using classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we have our interface definition (`IComplexType`), which has an `id`
    and a `name` property, as well as a `print` function. We then define a class named
    `ComplexType` that implements the `IComplexType` interface. In other words, the
    class definition for `ComplexType` must match the `IComplexType` interface definition.
    Note that the class definition does not create a variable—it simply defines the
    structure of the class. We then create a variable named `complexType`, and then
    assign to this variable a new instance of the `ComplexType` class. This line is
    said to be creating an instance of the class. Once we have an instance of the
    class, we can set the values of the class properties. The last section of the
    code simply calls the `print` function of each class inside a `window.onload`
    function. The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Class constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes can accept parameters during their initial construction. If we look
    at the previous code sample, our calls to create an instance of a `ComplexType`
    class, and then set its properties, can be streamlined into a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the code is passing the `id` and `name` properties as parts
    of the class constructor. Our class definition, however, will need to include
    a new function, named `constructor`, in order to accept this syntax. Our updated
    class definition would then become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `constructor` function. It is a normal function definition, but uses
    the `constructor` keyword and accepts an `idArg`, and `nameArg` as parameters.
    These arguments are strongly typed to be of type `number` and `string` respectively.
    The internal `id` property of the `ComplexType` class is then assigned the `idArg`
    parameter value. Note the syntax used to reference the `id` property: `this.id`.
    Classes use the same `this` syntax that objects do to access internal properties.
    If we attempt to use an internal class property without using the `this` keyword,
    TypeScript will generate compile errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Class functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All functions within a class adhere to the syntax and rules that we covered
    in the previous chapter on functions. As a refresher of these rules, all class
    functions can:'
  prefs: []
  type: TYPE_NORMAL
- en: Be strongly typed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `any` keyword to relax strong typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have optional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have default parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use argument arrays, or the rest parameter syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow function callbacks and specify the function callback signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow function overloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s modify our `ComplexType` class definition, and include an example of
    each of these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is the `constructor` function. Our class definition
    is using function overloading for the `constructor` function, allowing the class
    to be constructed using either a `number` and a `string`, or two strings. The
    following code shows how we would use each of these `constructor` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `complexType` variable uses the `number,` `string` variant of the constructor
    function, and the `complexType_2` variable uses the `string,string` variant. The
    `complexType_3` variable will generate a compile error, as we are not allowing
    a constructor to use a `boolean,boolean` variant. You may argue, however, that
    the last constructor function specifies an `any,any` variant, and this should
    allow for our `boolean,boolean` usage. Just remember that when using constructor
    overloads, the actual constructor implementation must use types that are compatible
    with any variant of the constructor overloads. Our constructor implementation,
    then, must use an `any,any` variant. Because we are using constructor overloads,
    however, this `any,any` variant is hidden by the compiler in favor of our overloaded
    signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code samples show how we would use the rest of the functions
    that we have defined for this class. Let''s start with the `usingTheAnyKeyword`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call in this sample is using a boolean value to call the `usingTheAnyKeyword`
    function, and the second is using an arbitrary object. Both of these function
    calls are valid, as the parameter `arg1` is defined with the `any` type. Next,
    the `usingOptionalParameters` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are calling the `usingOptionalParameters` function firstly with a
    single argument, and then without any arguments. Again, these calls are valid,
    as the `optionalArg1` argument is marked as optional. Now for the `usingDefaultParameters`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these calls to the `usingDefaultParameters` function are valid. The
    first call will override the default value of 0, and the second call—without an
    argument—will use the default value of 0\. Next up is the `usingRestSyntax` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our rest function, `usingRestSyntax`, can be called with any number of arguments,
    as we are using the rest parameter syntax to hold these arguments in an array.
    Both of these calls are valid. Finally, let''s look at the `usingFunctionCallbacks`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows the definition of a function named `myCallbackFunction`.
    It matches the callback signature required by the `usingFunctionCallbacks` function,
    allowing us to pass in the `myCallbackFunction` as a parameter to the `usingFunctionCallbacks`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you face any difficulty understanding these various function signatures,
    then please re-view the relevant sections in [Chapter 2](ch02.html "Chapter 2. Types,
    Variables and Function Techniques"), *Types, Variables, and Function Techniques*,
    regarding functions, where each of these concepts is explained in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Interface function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces, like classes, follow the same rules when dealing with functions.
    To update our `IComplexType` interface definition to match the `ComplexType` class
    definition, we need to write a function definition for each of the new functions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Lines 1 to 4 form our existing interface definition, and include the `id` and
    `name` properties and the `print` function we have been using until now. Line
    5 shows how to define a function signature for the `usingTheAnyKeyword` function.
    It looks surprisingly like our actual class function, but does not have a function
    body. Line 6 shows how to use an optional parameter for the `usingOptionalParameters`
    function. Line 7, however, is slightly different from our class definition of
    the `usingDefaultParameters` function. Remember that an interface defines the
    shape of our class or object, and therefore cannot contain variables or values.
    We have therefore defined the `defaultArg1` parameter as optional, and left the
    assignment of the default value up to the class implementation itself. Line 8
    shows the definition of the `usingRestSyntax` function that contains the rest
    parameter syntax, and line 9 shows the definition of the `usingFunctionCallbacks`
    function, with a callback function signature. They are pretty much identical to
    the class function signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing missing from this interface is the signature for the `constructor`
    function. TypeScript will generate an error if we include a `constructor` signature
    in an interface. Suppose we were to include a definition for the `constructor`
    function in the `IComplexType` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler would then generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This error show us that when we use a `constructor` function, the return type
    of the constructor is implicitly typed by the TypeScript compiler. Therefore,
    the return type of the `IComplexType` constructor would be `IComplexType`, and
    the return type of the `ComplexType` constructor would be `ComplexType`. Even
    though the `ComplexType` function implements the `IComplexType` interface, they
    are actually two different types—and therefore the `constructor` signatures will
    always be incompatible—hence the compile error.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is another paradigm that is one of the cornerstones of object-oriented
    programming. Inheritance means that an object uses another object as its base
    type, thereby "inheriting" all of the base object's characteristics, including
    both properties and functions. Both interfaces and classes can use inheritance.
    An interface or class that is "inherited" from is known as the base interface,
    or base class, and the interface or class that does the inheritance is known as
    the derived interface, or derived class. TypeScript implements inheritance using
    the `extends` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Interface inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of interface inheritance, consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an interface called `IBase` that defines an `id` property, of
    type number. Our second interface definition, `IDerivedFromBase`, extends (or
    inherits) from `IBase`, and therefore automatically includes the `id` property.
    The `IDerivedFromBase` interface then defines a `name` property, of type string.
    As the `IDerivedFromBase` interface inherits from `IBase`, it therefore actually
    has two properties: `id` and `name`. The class definition for `DerivedClass` implements
    this `IDerivedFromBase` interface, and therefore must include both the `id` and
    `name` properties—in order to successfully implement all of the properties of
    the `IDerivedFromBase` interface. Although we have only shown properties in this
    example, the same rules apply for functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes can also use inheritance in the same manner as interfaces. Using our
    definitions of the `IBase` and `IDerivedFromBase` interfaces, the following code
    shows an example of class inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first class, named `BaseClass`, implements the `IBase` interface, and as
    such, is only required to define a property of `id`, of type `number`. The second
    class, `DerivedFromBaseClass`, inherits from the `BaseClass` class (using the
    `extends` keyword), but also implements the `IDerivedFromBase` interface. As `BaseClass`
    already defines the `id` property required in the `IDerivedFromBase` interface,
    the only other property that the `DerivedFromBaseClass` class needs to implement
    is the `name` property. We therefore only need to include the definition of the
    `name` property in the `DerivedFromBaseClass` class.
  prefs: []
  type: TYPE_NORMAL
- en: Function and constructor overloading with super
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using inheritance, it is often necessary to create a base class with a
    defined constructor. Then, in the constructor for any derived class, we will need
    to call through to the base class constructor and pass through these parameters.
    This is called constructor overloading. In other words, the constructor of a derived
    class overloads, or "supersedes", the constructor of the base class. TypeScript
    includes the `super` keyword to enable calling a base class''s function with the
    same name. This is best explained with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we define a class named `BaseClassWithConstructor` that
    holds a private `_id` property. This class has a `constructor` function that requires
    an `id` argument. Our second class, named `DerivedClassWithConstructor`, inherits
    from, or extends, the `BaseClassWithConstructor` class. The constructor of `DerivedClassWithConstructor`
    takes an `id` argument and a `name` argument, but it needs to pass the `id` argument
    through to the base class. This is where the `super` call comes in. The `super`
    keyword calls the function in the base class that has the same name as the function
    in the derived class. The last line of the constructor function for `DerivedClassWithConstructor`
    shows the call using the `super` keyword, passing the `id` argument it received
    through to the base class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is called function overloading. In other words, the derived
    class has a function name that is the same name as that of a base class function,
    and it "overloads" this function definition. We can use this technique on any
    function in a class—not only on constructors. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseClassWithConstructor` class now has a function named `getProperties`,
    which just returns a string representation of the properties of the class. Our
    `DerivedClassWithConstructor` class, however, also includes a function called
    `getProperties`. This function is a function override of the `getProperties` base
    class function. In order to call through to the base class function, we need to
    include the `super` keyword, as shown in the call to `super`.`getProperties()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example usage of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a variable named `myDerivedClass` and passes in the required
    arguments of `id` and `name`. We then simply log the result of the call to the
    `getProperties` function to the console. This code snippet will result in the
    following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The results show that the `getProperties` function of the `myDerivedClass` variable
    will call through to the base class `getProperties` function, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we continue with this chapter, let''s take a quick look at how TypeScript
    implements classes in the generated JavaScript through a technique called closures.
    As we mentioned in [Chapter 1](ch01.html "Chapter 1. TypeScript – Tools and Framework
    Options"), *TypeScript – Tools and Framework Options*, a closure is a function
    that refers to independent variables. These variables essentially remember the
    environment in which they were created. Consider the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a function named `TestClosure` that takes a single parameter,
    named `value`. The body of the function first assigns the `value` argument to
    an internal property named `this._value`, and then defines an inner function named
    `printValue`, that logs the value of the `this._value` property to the console.
    The interesting bit is the last line in the `TestClosure` function—we are returning
    the `printValue` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now take a look at the last two lines of the code snippet. We create a variable
    named `myClosure` and assign to it the result of calling the `TestClosure` function.
    Note that because we are returning the `printValue` function from inside the `TestClosure`
    function, this essentially also makes the `myClosure` variable a function. When
    we execute this function on the last line of the snippet, it will execute the
    inner `printValue` function, but remember the initial value of `12` that was used
    when creating the `myClosure` variable. The output of the last line of the code
    will log the value of `12` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: This is the essential nature of closures. A closure is a special kind of object
    that combines a function with the initial environment in which it was created.
    In our preceding sample, since we stored whatever was passed in via the `value`
    argument into a local variable named `this._value`, JavaScript remembers the environment
    in which the closure was created, in other words, whatever was assigned to the
    `this._value` property at the time of creation will be remembered, and can be
    reused later.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s take a look at the JavaScript that is generated by
    the TypeScript compiler for the `BaseClassWithConstructor` class we were just
    working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our closure starts with `function () {` on the first line, and ends with `}`
    on the last line. This closure first defines a function to be used as a constructor
    : `BaseClassWithConstructor(id)`. Bear in mind that when a JavaScript object is
    constructed, it inherits, or copies the `prototype` property of the original object
    into the new instance. In our sample, then, any object that is created using the
    `BaseClassWithConstructor` function will inherit the `getProperties` function
    as well – as it is part of the `prototype` property. Also, because the functions
    that are defined on the `prototype` property are also within the closure, they
    will remember the original execution environment, and variable values.'
  prefs: []
  type: TYPE_NORMAL
- en: This closure is then surrounded with an opening bracket, `(`, on the first line,
    and a closing bracket, `)`, on the last line—defining what is known as a JavaScript
    function expression. This function expression is then immediately executed by
    the last two braces, `();`. This technique of immediately executing a function
    is known as an **Immediately Invoked Function Expression** (**IIFE**). Our IIFE
    above is then assigned to a variable named `BaseClassWithConstructor`, making
    it a first-class JavaScript object, and one that can be created with the `new`
    keyword. This is how TypeScript implements classes in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the underlying JavaScript code that TypeScript uses for
    class definitions is actually a well-known JavaScript pattern—known as the **module**
    pattern. It uses closures to capture an execution environment, and also provides
    a way to expose a public API for classes, as seen by the use of the `prototype`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that an in-depth knowledge of closures, how to write them,
    and how to use the module pattern for defining classes—will all be taken care
    of by the TypeScript compiler—allowing us to focus on object-oriented principles
    without having to write JavaScript closures using this sort of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how we can use interfaces and classes in a large TypeScript project,
    we will have a quick look at a very well-known object-oriented design pattern—the
    Factory Design Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Business requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, let''s assume that our business analyst gives us the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: You are required to categorize people, given their date of birth, and indicate
    with a `true` or `false` flag whether they are of a legal age to sign a contract.
    A person is deemed to be an infant if they are less than 2 years old. Infants
    cannot sign contracts. A person is deemed to be a child if they are less than
    18 years old. Children cannot sign contracts either. A person is deemed to be
    an adult if they are more than 18 years of age, and only adults can sign contracts.
  prefs: []
  type: TYPE_NORMAL
- en: What the Factory Design Pattern does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Factory Design Pattern uses a Factory class to return an instance of one
    of several possible classes based on the information provided to it.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of this pattern is to place the decision-making logic for what type
    of class to create, in a separate class—the Factory class. The Factory class will
    then return one of several classes that are all subtle variations of each other,
    and which will do slightly different things based on their specialty. In order
    for our logic to work, any code that consumes one of these classes must have a
    common contract (or list of properties and methods) that all the variations of
    a class implement. This is the perfect scenario for an interface.
  prefs: []
  type: TYPE_NORMAL
- en: To implement our required business functionality, we will create an `Infant`
    class, a `Child` class, and an `Adult` class. The `Infant` and `Child` classes
    will return `false` when asked whether they can sign contracts, and the `Adult`
    class will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The IPerson interface and the Person base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to our requirements, the class instance that is returned by the Factory
    must be able to do two things: print the category of the person in the required
    format, and tell us whether they can sign contracts or not. For completeness,
    we will include a third function that prints the date of birth. Let''s define
    an interface to satisfy this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `IPerson` interface has a `getPersonCategory` method that will return a
    string representation of their category: either "Infant", "Child", or "Adult".
    The `canSignContracts` method will return either `true` or `false`, and the `getDateOfBirth`
    method will simply return a printable version of their date of birth. To simplify
    our code, we will create a base class called `Person` that implements this interface,
    and will handle the common data and functions of all types of `Person`: storing
    and returning the date of birth. Our base class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This `Person` class definition is the base class for each of our specialist
    types of person. As each one of our specialist classes will require a `getDateOfBirth`
    function, we can extract this common code into a base class. The constructor function
    requires a date, which is stored in the internal variable `_dateOfBirth`, and
    the `getDateOfBirth` function returns this `_dateOfBirth` converted into a string.
  prefs: []
  type: TYPE_NORMAL
- en: Specialist classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now for the three types of specialist classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All of the classes in this snippet use inheritance to extend the `Person` class.
    Our `Infant`, `Child`, and `Adult` classes do not specify a `constructor` method,
    but instead inherit this `constructor` from their base class, `Person`. Each class
    implements the `IPerson` interface, and must therefore provide implementations
    of all three functions required by the `IPerson` interface definition. The `getDateOfBirth`
    function is defined in the `Person` base class, however, so each of these derived
    classes only needs to implement the `getPersonCategory` and `canSignContracts`
    functions to be valid. We can see that our `Infant` and `Child` classes return
    `false` for `canSignContracts`, and our `Adult` class returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the Factory class itself. This class is responsible
    for holding all of the logic required to make decisions, and returns an instance
    of either an `Infant`, `Child`, or `Adult` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `PersonFactory` class has only one function, `getPerson`, which returns
    an object of type `IPerson`. This function creates a variable named `dateNow`,
    that is set to the current date. This `dateNow` variable is then used to calculate
    two more variables, `dateTwoYearsAgo`, and `dateEighteenYearsAgo`. The decision
    logic then takes over, comparing the incoming `dateOfBirth` variable against these
    dates. This logic satisfies our requirements, and returns a new instance of either
    a new `Infant`, `Child`, or `Adult` class based on their date of birth.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Factory class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate how to use this `PersonFactory` class, we will use the following
    code, wrapped in a `window.onload` function so that we can run it inside a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In line 2, we start with the creation of a variable, `personFactory`, to hold
    a new instance of the `PersonFactory` class. Line 4 creates a new array, named
    `personArray`, that is strongly typed to only hold objects that implement the
    `IPerson` interface. Lines 5 to 7 then add values to this array, by using the
    `getPerson` function of the `PersonFactory` class, passing in the date of birth.
    Note that the `PersonFactory` class will make all the decisions regarding which
    type of object to return, based on the date of birth we are passing in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 8 starts a `for` loop to loop through the `personArray` array, and lines
    9 to 14 use the interface definition of `IPerson` to call the relevant functions
    for printing. The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Factory class](img/9665OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have satisfied our business requirements, and implemented a very common design
    pattern at the same time. If you find yourself repeating the same sort of logic
    in many places, trying to figure out whether an object falls under one or more
    categories, then chances are that you can refactor your code to use the Factory
    Design Pattern - and avoid repeating the same decision-making logic all over your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Class modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed briefly in the opening chapter, TypeScript introduces the `public`
    and `private` access modifiers to mark variables and functions as either public
    or private. Traditionally, JavaScript programmers have used a simple naming convention
    of prefixing variables with an underscore (`_`) to indicate that they are private
    variables. This naming convention, however, does not stop anyone from actually
    modifying such variables inadvertently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a TypeScript code sample to illustrate this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We start with a class named `ClassWithModifiers`, which has two properties,
    `_id` and `_name`. We have marked these properties with the `private` keyword
    to protect them from being modified by mistake. Our `constructor` takes an incoming
    `id` and `name` parameter, and assigns the values to the internal, private properties
    of `_id` and `_name` respectively. The next function that we define is called
    `modifyId`, which will allow us to update the internal `_id` variable with a new
    value. The `modifyId` function then calls an internal function named `updateNameFromId`.
    This function has been marked as `private`, and therefore calls to it are only
    allowed within the body of the class definition. The `updateNameFromId` function
    simply uses the new `_id` value to set the private `_name` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last four lines of code show us how we would use this class. The first
    line creates a variable named `myClass`, and assigns it to a new instance of the
    `ClassWithModifiers` class. The second line is legal, and calls the `modifyId`
    function. The third and fourth lines, however, will generate compile time errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler warns us that both the `_id` property and `updateNameFromId`
    function are inaccessible—in other words, `private`—and are not designed to be
    used outside the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class functions are `public` by default. Not specifying an access modifier of
    `private` for either properties or functions will cause their access level to
    default to `public`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript also introduces a shorthand version of the previous constructor
    function, allowing you to specify parameters with access modifiers directly in
    the constructor. This is best described in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet defines a class named `ClassWithAutomaticProperties`. The
    `constructor` function uses two arguments - an `id` of type `number`, and a `name`
    of type `string`. Notice, however, the access modifiers of `public` for `id` and
    `private` for `name`. This shorthand automatically creates a public `id` property
    on the `ClassWithAutomaticProperties` class, and a private `name` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `print` function on line 4 uses these automatic properties in the `console.log`
    function. We are referring to `this.id` and `this.name` in the `console.log` function,
    just as in our previous code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This shorthand syntax is available only within the `constructor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see on line 9 that we have created a variable named `myAutoClass` and
    assigned a new instance of the `ClassWithAutomaticProperties` class to it. Once
    this class is instantiated, it automatically has two properties: an `id` property
    of type number, which is `public`; and a `name` property of type string, which
    is `private`. Compiling the previous code, however, will produce a TypeScript
    compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This error is telling us that the automatic property `name` is declared as `private`,
    and it is therefore unavailable to code outside the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this shorthand technique of creating automatic member variables is available,
    I believe that it makes the code more difficult to read. Personally, I prefer
    the more verbose class definitions that do not use this shorthand technique. With
    a list of properties at the top of the class, it becomes immediately visible to
    someone reading the code what variables this class uses, and whether they are
    `public` or `private`. Using the constructor's automatic property syntax hides
    these parameters somewhat, forcing developers to sometimes reread the code to
    understand it. Whichever syntax you choose, however, try to make it a coding standard,
    and use the same syntax throughout your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Class property accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript 5 introduces the concept of property accessors. This allows a pair
    of `get` and `set` functions (with the same function name) to be seen by the calling
    code as simple properties. This concept is best understood with some simple code
    samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a class named `SimpleClass`, and it has a single public `id`
    property. When we create an instance of this class, we can directly modify this
    `id` property. Now let''s use the ECMAScript 5 `get` and `set` functions to accomplish
    the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This class has a private `_id` property and two functions, both called `id`.
    The first of these functions is prefixed by the `get` keyword and simply returns
    the value of the internal `_id` property. The second of these functions is prefixed
    with the `set` keyword and accepts a `value` parameter. The internal `_id` property
    is then set to this `value` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the class definition, we create a variable, named `mySimpleAccClass`,
    which is an instance of the `SimpleClassWithAccessors` class. Anyone using an
    instance of this class will not see two separate functions named `get` and `set`.
    They will simply see an `id` property. When we assign a value to this property,
    the ECMAScript 5 runtime will call the `set id(value)` function, and when we retrieve
    this property, the runtime will call the `get id()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some browsers do not support ECMAScript 5 (such as Internet Explorer 8), and
    will cause a JavaScript runtime error when this code is run.
  prefs: []
  type: TYPE_NORMAL
- en: Static functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static functions are functions that can be called on a class without having
    to create an instance of the class first. These functions are almost global in
    their nature, but must be called by prefixing the function name with the class
    name. Consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start with a simple class, named `ClassWithFunction`, which has a single
    function, `printOne`. The `printOne` function does not really do anything useful,
    other than logging the string `"1"` to the console. In order to use this function,
    though, we need to first create an instance of the class, assign it to a variable,
    and then call the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With static functions, however, we can call functions or properties directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The class definition of `StaticClass` includes a single function, named `printTwo`,
    that is marked as `static`. As we can see from the last line of the code, we can
    call this function without "newing" up an instance of the `StaticClass` class.
    We can just call the function directly, as long as we prefix it with the class
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both functions and properties of a class can be marked as static.
  prefs: []
  type: TYPE_NORMAL
- en: Static properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static properties come in handy when dealing with so-called "magic strings"
    throughout your code base. If you are relying on a string to contain a particular
    value in various parts of your code, then the time has come to replace this "magic
    string" with a static property. In the Factory Design Pattern that we discussed
    earlier, we created specialist `Person` objects that returned either "Infant",
    "Child" or "Adult" as a string value. If we were writing code later on that checked
    whether the string returned was equal to "Infant" or "Child", we could inadvertently
    break our logic if we misspelled "Infant" as "Infent":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of static properties that we could use instead
    of those "magic strings":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our code base, instead of checking values against the string "Infant",
    we compare them against the static property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code is not relying on a "magic string" anymore. The string "Infant" is
    now recorded in a single place. As long as all code uses the static property `PersonType.Infant`,
    it will be more stable and resistant to change.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are a way of writing code that will deal with any type of object but
    still maintain the object type integrity. So far, we have used interfaces, classes
    and TypeScript's basic types to ensure strongly typed (and less error-prone) code
    in our samples. But what happens if a block of code needs to work with any type
    of object?
  prefs: []
  type: TYPE_NORMAL
- en: As an example, suppose we wanted to write some code that could iterate over
    an array of objects and return a concatenation of their values. So, given a list
    of numbers, say `[1,2,3]`, it should return the string `"1,2,3"`. Or, given a
    list of strings, say `["first","second","third"]`, return a string `"first,second,third"`.
    We could write some code that accepted values of type `any`, but this might introduce
    bugs in our code – remember S.F.I.A.T.? We want to ensure that all elements of
    the array are of the same type. This is where generics come in to play.
  prefs: []
  type: TYPE_NORMAL
- en: Generic syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write a class called `Concatenator` that will work with any type of object,
    but still ensure that type integrity is kept in place. All JavaScript objects
    have a `toString` function, which is called whenever a string is needed by the
    runtime, so let's use this `toString` function to create a generic class that
    outputs all values held within an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic implementation of this `Concatenator` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we notice is the syntax of the class declaration, `Concatenator
    < T >`. This `< T >` syntax is the syntax used to indicate a generic type, and
    the name used for this generic type in the rest of our code is `T`. The `concatenateArray`
    function also uses this generic type syntax, `Array < T >`. This indicates that
    the `inputArray` argument must be an array of the type that was originally used
    to construct an instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating generic classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use an instance of this generic class, we need to construct the class and
    tell the compiler via the `< >` syntax what the actual type of `T` is. We can
    use any type for the type of `T` in this generic syntax, including base JavaScript
    types, TypeScript classes, or even TypeScript interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice the syntax that we have used to instantiate the `Concatenator` class.
    In our first sample, we create an instance of the `Concatenator` generic class,
    and specify that it should substitute the generic type, `T`, with the type `string`
    in every place where `T` is being used within the code. Similarly, the second
    example creates an instance of the `Concatenator` class, and specifies that the
    type `number` should be used wherever the code encounters the generic type `T`.
    Our last sample shows the use of the `IPerson` interface for the generic type
    `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use this simple substitution principle, then for the `stringConcatenator`
    instance (which uses strings), the `inputArray` argument must be of type `Array<string>`.
    Similarly, the `numberConcatenator` instance of this generic class uses numbers,
    and so the `inputArray` argument must be an array of numbers. To test this theory,
    let''s generate an array of strings and an array of numbers, and see what the
    compiler says if we try to break this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Our first two lines define our `stringArray` and `numberArray` variables to
    hold the relevant arrays. We then pass in the `stringArray` variable to the `stringConcatenator`
    function—no problems there. On our next line, we pass the `numberArray` to the
    `numberConcatenator`—still okay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our problems, however, start when we attempt to pass an array of numbers to
    the `stringConcatenator`, which has been configured to only use strings. Again,
    if we attempt to pass an array of strings to the `numberConcatenator`, which has
    been configured to allow only numbers, TypeScript will generate errors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `pop` property is the first nonmatching property between a `string[]` and
    a `number[]`, so clearly, we are attempting to pass an array of numbers where
    we should have used strings, and vice versa. Again, the compiler warns us that
    we are not using the code correctly, and forces us to resolve these issues before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These constraints on generics are a compile-time-only feature of TypeScript.
    If we look at the generated JavaScript, we will not see any reams of code that
    jumps through hoops to ensure that these rules are carried through into the resultant
    JavaScript. All of these type constraints and generic syntax are simply compiled
    away. In the case of generics, the generated JavaScript is actually a very simplified
    version of our code, with no type constraints in sight.
  prefs: []
  type: TYPE_NORMAL
- en: Using the type T
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use generics, it is important to note that all of the code within the
    definition of a generic class or a generic function must respect the properties
    of `T` as if it were any type of object. Let''s take a closer look at the implementation
    of the `concatenateArray` function in this light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `concatenateArray` function strongly types the `inputArray` argument so
    that it should be of type `Array <T>` . This means that any code that uses the
    `inputArray` argument can use only those functions and properties that are common
    to all arrays, no matter what type the array holds. In this code sample, we used
    `inputArray` in two places.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, in our for loop, note where we have used the `inputArray.length` property.
    All arrays have a `length` property to indicate how many items the array has,
    so using `inputArray.length` will work on any array, no matter what type of object
    the array holds. Secondly, we reference an object within the array when we use
    the `inputArray[i]` syntax. This reference actually returns a single object of
    type `T`. Remember that whenever we use `T` in our code, we must use only those
    functions and properties that are common to any object of type `T`. Luckily for
    us, we are using only the `toString` function, and all JavaScript objects, no
    matter what type they are, have a valid `toString` function. So this generic code
    block will compile cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets test this type `T` theory by creating a class of our own to pass into
    the `Concatenator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This sample starts with a class, named `MyClass`, that has a `constructor`
    accepting a number. It then assigns an internal variable called `_name` to a value
    of `arg1` , concatenated with the `"_MyClass"` string. Next, we create an array
    called `myArray`, and construct some instances of `MyClass` within this array.
    We then create an instance of the `Concatenator` class, specifying that this generic
    instance will only work with objects that are of type `MyClass`. We then call
    the `concatenateArray` function and store the result in a variable named `myArrayResult`.
    Finally, we print the result on the console. Running this code in the browser
    will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmmm, not quite what we were expecting! This strange output is because the
    string representation of an object - that is not one of the basic JavaScript types
    - resolves to `[object type]`. Any custom object that you write may need to override
    the `toString` function to provide human-readable output. We can fix this code
    quite easily by providing an override of the `toString` function within our class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code above, we have replaced the default `toString` function that all
    JavaScript objects inherit, with our own implementation. Within this function,
    we simply returned the value of the `_name` private variable. Running this sample
    now produces the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Constraining the type of T
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using generics, it is sometimes desirable to constrain the type of `T`
    to be only a specific type, or subset of types. In these cases, we don''t want
    our generic code to be available for any type of object, we only want it to be
    available for a specific subset of objects. TypeScript uses inheritance to accomplish
    this with generics. As an example, let''s refactor our earlier Factory Design
    Pattern code to use a generic `PersonPrinter` class, that is specifically designed
    to work with classes that implement the `IPerson` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we define a class called `PersonPrinter`, that uses the
    generic syntax. Note that the `T` generic type has been derived from the `IPerson`
    interface, as indicated by the `extends` keyword in `< T extents IPerson >`. This
    indicates that any usage of the type `T` will substitute the interface `IPerson`,
    and can therefore, only allow functions or properties that are defined in the
    `IPerson` interface to be used wherever `T` is used. The `print` function accepts
    an argument named `arg`, which is of type `T`. Using our rules of generics, we
    know that any usage of the variable `arg` is only allowed to use available functions
    from the `IPerson` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `print` function builds up a string to log to the console, and only uses
    functions that are defined in the `IPerson` interface. These include the functions
    `getDateOfBirth` and `getPersonCategory`. In order to generate a grammatically
    correct sentence, we have introduced another function called `getPermissionString`
    that accepts an argument of type `T`, or the `IPerson` interface. This function
    simply uses the `canSignContracts()` function of the `IPerson` interface to return
    either a blank string or the string `"NOT "`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the usage of this class, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new instance of the `PersonFactory` class. We then create
    an instance of the generic `PersonPrinter` class, and set the type of the argument
    `T` to be of type `IPerson`. This means that any class that is passed into the
    instance of `PersonPrinter` must implement the `IPerson` interface. We know from
    our previous examples that the `PersonFactory` will return an instance of either
    an `Infant`, `Child`, or `Adult` class, and each of these classes implement the
    `IPerson` interface. We know therefore, that any class returned by the `PersonFactory`
    will be accepted by the `personPrinter` generic class instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate variables named `child`, `adult`, and `infant`, and rely
    on the `PersonFactory` to return us the correct class based on their date of birth.
    The last three lines of this sample simply log to the console the sentence that
    is generated by the `personPrinter` generic class instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code is as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constraining the type of T](img/9665OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generics PersonFactory output
  prefs: []
  type: TYPE_NORMAL
- en: Generic interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use interfaces with the generic type syntax. For our `PersonPrinter`
    class, the matching interface definition would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface looks identical to our class definition, the only difference
    being that the `print` and the `getPermissionString` functions do not have an
    implementation. We have kept the generic type syntax using `< T >`, and further
    specified that the type `T` must implement the `IPerson` interface. To use this
    interface with the `PersonPrinter` class, we modify the class definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This syntax seems pretty straightforward. As we have seen before, we use the
    `implements` keyword following the class definition, and then use the interface
    name. Note, however, that we pass the type `T` into the interface definition of
    `IPersonPrinter` as a generic type `IPersonPrinter<T>`. This satisfies the `IPersonPrinter`
    generic interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface that defines our generic classes further protects our code from
    being modified inadvertently. As an example of this, suppose that we tried to
    redefine the class definition of `PersonPrinter` so that `T` is not constrained
    to be of type `IPerson`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have removed the constraint on the type `T` for the `PersonPrinter`
    class. TypeScript will automatically generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This error points us to our erroneous class definition; the type `T`, as used
    in the code (`PersonPrinter<T>`), must use a type `T` that extends from `IPerson`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new objects within generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From time to time, generic classes may need to create an object of the type
    that is passed in as the generic type `T`. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two class definitions, `FirstClass` and `SecondClass`. `FirstClass`
    just has a public `id` property, and `SecondClass` has a public `name` property.
    We then have a generic class that accepts a type `T` and has a single function,
    named `create`. This `create` function attempts to create a new instance of the
    type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last four lines of the sample show us how we would like to use this generic
    class. The `creator1` variable creates a new instance of the `GenericCreator`
    class using the correct syntax for creating variables of type `FirstClass`. The
    `creator2` variable is a new instance of the `GenericCreator` class, but this
    time is using `SecondClass`. Unfortunately, the preceding code will generate a
    TypeScript compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the TypeScript documentation, in order to enable a generic class
    to create objects of type `T`, we need to refer to type `T` by its `constructor`
    function. We also need to pass in the class definition as an argument. The `create`
    function will need to be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this `create` function down into its component parts. First, we
    pass an argument, named `arg1`. This argument is then defined to be of type `{
    new(): T }`. This is the little trick that allows us to refer to `T` by its `constructor`
    function. We are defining a new anonymous type that overloads the `new()` function
    and returns a type `T`. This means that the `arg1` argument is a function that
    is strongly typed to have a single `constructor` that returns a type `T`. The
    implementation of this function simply returns a new instance of the `arg1` variable.
    Using this syntax removes the compile error that we encountered before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This change, however, means that we must pass the class definition to the create
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the change in usage of the `create` function on lines 2 and 5\. We are
    now required to pass in the class definition for our type of `T`: `create(FirstClass)`
    and `create(SecondClass)` as our first argument. Try running this code in your
    browser and see what happens. The generic class will, in fact, create new objects
    of types `FirstClass` and `SecondClass`, as we expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the TypeScript compiler generates compilation errors for incorrectly
    typed code, this type checking is compiled away in the generated JavaScript. This
    means that the JavaScript runtime engine knows nothing about TypeScript interfaces
    or generics. So how can we tell at runtime whether a class implements an interface?
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has some functions that we can use when dealing with objects, that
    will tell us what type an object is, or if one object is an instance of another.
    For type information, we can use the JavaScript `typeof` keyword, and for instance
    information, we can use `instanceof`. Let's have a look at what these functions
    return, given some simple TypeScript classes, and see if we can use these to tell
    whether a class implements an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a simple base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This `TcBaseClass` class has an `id` property, and a `constructor` that sets
    this property based on the argument passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, a class that is derived from `TcBaseClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This `TcDerivedClass` class derives (or extends) from the `TcBase` class, and
    adds a `name` property and a `print` function. The constructor of this derived
    class must call the constructor of the base class, passing in the `idArg` argument
    via the `super` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s construct a variable named `base` that is a new instance of `TcBaseClass`,
    and then construct a variable named `derived` that is a new instance of `TcDerivedClass`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for some tests; let''s see what the `typeof` function returns for each
    of these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that the JavaScript runtime engine sees an instance of a class
    as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now switch over to the `instanceof` keyword, and use it to check whether
    an object is derived from another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Now let''s have a look at what the `typeof` keyword returns
    when we use it on a class''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the JavaScript runtime correctly identifies the `id` property
    of our base type as a number, the `name` property as a string, and the `print`
    property as a function.
  prefs: []
  type: TYPE_NORMAL
- en: So how can we tell at runtime what the type of an object is? The simple answer
    is that we can't easily tell. We can only tell whether an object is an instance
    of another object, or if a property is one of the basic JavaScript types. If we
    were trying to us the `instanceof` function to implement a type checking algorithm,
    we would need to check the incoming object against every known type in our object
    tree, which is certainly not ideal. We also can't use `instanceof` to check whether
    a class implements an interface, as TypeScript interfaces are compiled away.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other statically typed languages allow the runtime engine to query an object,
    determine what type the object is, and also query what interfaces an object implements.
    This process is called reflection.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, using the `typeof` or `instanceof` JavaScript functions, we
    can glean some information from the runtime about an object. On top of these abilities,
    we could also use the `getPrototypeOf` function to return some information about
    the class constructor. The `getPrototypeOf` function returns a string, so we could
    then parse this string to determine the class name. Unfortunately, the implementation
    of the `getPrototypeOf` function returns slightly different strings, depending
    on what browser is being used. It is also only implemented in ECMAScript 5.1 and
    above, which again, may introduce problems when running on older browsers or mobile
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Another JavaScript function we could use to find runtime information about an
    object is the `hasOwnProperty` function. This has been a part of JavaScript since
    ECMAScript 3, and so is compatible with just about every browser, both desktop
    and mobile. The `hasOwnProperty` function will return `true` or `false`, indicating
    whether an object has the property that you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript compiler helps us program JavaScript in an object-oriented way
    using interfaces, but these interfaces are "compiled away", and do not appear
    in the generated JavaScript. As an example of this, let''s have a look at the
    following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple example of defining an interface and implementing it in a
    class. The `IBasicObject` interface has an `id` of type `number`, a `name` of
    type `string`, and a `print` function. The class definition `BasicObject` implements
    all the required properties and parameters. Now let''s have a look at the compiled
    JavaScript that TypeScript generates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler has not included any JavaScript for the `IBasicObject`
    interface. All we have here is a closure pattern for the `BasicObject` class definition.
    The `IBasicObject` interface, although used by the TypeScript compiler, does not
    exist in the generated JavaScript. Hence, we say that it has been "compiled away".
  prefs: []
  type: TYPE_NORMAL
- en: 'This therefore presents us with a few problems when implementing reflection-like
    capabilities within JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot tell at runtime whether an object implements a TypeScript interface
    because TypeScript interfaces are compiled away
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot loop through an object's properties using the `getOwnPropertyNames`
    function on older ECMAScript 3 browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot use the `getPrototypeOf` function on older ECMAScript 3 browsers to
    determine a class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the `getPrototypeOf` function is not consistent across
    browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot use the `instanceof` keyword to determine a class type without comparing
    it with known types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking an object for a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So how do we tell at runtime whether an object implements an interface?
  prefs: []
  type: TYPE_NORMAL
- en: In their book, *Pro JavaScript Design Patterns* ([http://jsdesignpatterns.com/](http://jsdesignpatterns.com/)),
    Ross Harmes and Dustin Diaz discuss this quandary, and come up with a rather simple
    solution. We can invoke a function on an object using a string which contains
    the function name, and then check whether the result is valid, or `undefined`.
    In their book, they build a utility function using this principle, to check at
    runtime whether an object has a set of defined properties and methods. These defined
    properties and methods are kept within the JavaScript code as simple string arrays.
    These string arrays therefore act as object "metadata" for our code that we can
    then pass through to a function checking utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their `FunctionChecker` utility class can be written in TypeScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This `FunctionChecker` class has a single static function, named `implementsFunction`,
    that will return either `true` or `false`. The `implementsFunction` function takes
    an argument named `objectToCheck` and a string named `functionName`. Note that
    the type of `objectToCheck` is specifically set to `any`. This is one of the rare
    circumstances where the use of the `any` type is actually the correct TypeScript
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `implementsFunction` function, we use a special kind of JavaScript
    syntax that reads the function itself from the object, using the `[ ]` syntax
    on an instance of the object, and referencing it by name : `objectToCheck[functionName]`.
    If the object we are interrogating has this attribute, then invoking it will return
    something other than `undefined`. We can then use the `typeof` keyword to check
    the type of the attribute. If the `typeof` instance returns "function", then we
    know that this object implements this function. Let''s have a look at some quick
    usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Line 1, simply creates an instance of the `BasicObject` class, and assigns
    it to the `myClass` variable. Line 2 then invokes our `implementsFunction` function,
    passing in the instance of the class and the string "print". Line 3 logs the result
    to the console. Line 4 and 5 repeat the process, but check whether the `myClass`
    instance implements the function "alert". The results of this code would be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This `implementsFunction` function allows us to interrogate an object and check
    whether it has a specific function by name. Extending this concept slightly, brings
    us to a simple way of carrying out runtime type checking. All we need is a list
    of functions (or properties) that a JavaScript object should implement. This list
    of functions (or properties) can be described as class "metadata".
  prefs: []
  type: TYPE_NORMAL
- en: Interface checking with generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique that Ross and Dustin describe, of holding "metadata" information
    about interfaces, is easily implemented in TypeScript. If we define classes that
    hold this "metadata" for each of our interfaces, we can then use them to check
    objects at runtime. Let's put together an interface that holds an array of method
    names to check an object against, as well as a list of property names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This `IInterfaceChecker` interface is very simple—an optional array of `methodNames`,
    and an optional array of `propertyNames`. Now let''s implement this interface
    to describe the necessary properties and methods of the TypeScript `IBasicObject`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We start off with a class definition that implements the `IInterfaceChecker`
    interface. This class has been named `IIBasicObject`, with a double `I` prefix
    in the class name. This is a simple naming convention that indicates that the
    `IIBasicObject` class holds "metadata" for the `IBasicObject` interface that we
    defined earlier. The `methodNames` array specifies that this interface must implement
    the `print` method, and the `propertyNames` array specifies that this interface
    also includes an `id` and a `name` property.
  prefs: []
  type: TYPE_NORMAL
- en: This method of defining metadata for an object is a very simple solution to
    our problem, and is both browser agnostic and ECMAScript version agnostic. While
    this may require us to keep "metadata" objects in sync with TypeScript interfaces,
    we now have what we need in order to check whether an object implements a defined
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use what we know about generics to implement an `InterfaceChecker`
    class that uses these object "metadata" classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We start off with a generic class, named `InterfaceChecker`, that accepts any
    object `T` that implements the `IInterfaceChecker` class. Again, the definition
    of the `IInterface` class is just an array of `methodNames` and an array of `propertyNames`.
    This class only has a single function named `implementsInterface` that returns
    a boolean—true if the class implements all properties and methods, and false if
    it does not. The first parameter, `classToCheck`, is the class instance that we
    are interrogating against the interface "metadata". Our second parameter uses
    the generic syntax that we discussed earlier to be able to create a new instance
    of the type `T`— which in this case is any type that implements the `IInterfaceChecker`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the code is an extension of the `FunctionChecker` class that we
    discussed earlier. We first need to create an instance of the type `T`, which
    is assigned to the variable `targetInterface`. We then simply loop through all
    the strings in the `methodNames` array, and check whether our `classToCheck` object
    implements these functions.
  prefs: []
  type: TYPE_NORMAL
- en: We then repeat this process, checking the given strings in the `propertyNames`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: The last lines of this code sample show us how we would use this `InterfaceChecker`
    class. First, we create an instance of `BasicObject` and assign it to the variable
    `myClass`. We then create an instance of the `InterfaceChecker` class and assign
    it to the variable `interfaceChecker`.
  prefs: []
  type: TYPE_NORMAL
- en: The second last line of this snippet calls the `implementsInterface` function,
    passing in the `myClass` instance, and `IIBasicObject`. Note that we are not passing
    in an instance of the `IIBasicObject` class, we are just passing in the class
    definition. Our generic code will create an internal instance of the `IIBasicObject`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of this code simply logs a `true` or `false` message to the console.
    The output of this line would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run the code with an invalid object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `noPrintFunction` has both an `id` and a `name` property, but
    it does not implement a `print` function. The output of this code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We now have a way of determining at runtime whether or not an object implements
    a defined interface. This technique can be used on external JavaScript libraries
    that you do not control—or even in larger teams where the API for a particular
    library is agreed in principle, before the libraries are written. In these cases,
    once a new version of the library is delivered, the consumers can quickly and
    easily ensure that the API conforms to the design specification.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are used in a number of design patterns, and even though we can implement
    these patterns using TypeScript, we may want to further solidify our code by doing
    runtime checking of an object's interface. This technique also opens up the possibility
    of writing an **Inversion of Control** (**IOC**) container in TypeScript, or an
    implementation of the Domain Events Pattern. We will explore these two design
    patterns in more detail in [Chapter 8](ch08.html "Chapter 8. Object-oriented Programming
    with TypeScript"), *Object-oriented Programming with TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the object-oriented concepts of interfaces, classes
    and generics. We discussed both interface inheritance and class inheritance, and
    used our knowledge on interfaces, classes and inheritance to create a Factory
    Design Pattern implementation in TypeScript. We then moved on to generics and
    their syntax, generic interfaces and generic constructor functions. We finished
    the chapter off with a discussion on reflection, and implemented a TypeScript
    version of an `InterfaceChecker` pattern using generics. In the next chapter,
    we will look at the mechanism that TypeScript uses to integrate with existing
    JavaScript libraries—definition files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
