- en: Chapter 4. Forms and Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use forms to modify the content on our
    blog directly through the site. This will be a fun chapter because we will be
    adding all sorts of new ways to interact with our site. We will create forms for
    working with the Entry model, learn how to receive and validate user data, and
    finally update the values in the database. Form processing and validation will
    be handled by the popular **WTForms** library. We will continue building out views
    and templates to support these new forms, learning a few new Jinja2 tricks along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Install WTForms and create a form for working with the Entry model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write views to validate and process form data, and persist changes to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create templates to display forms and validation errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Jinja2 macros to encapsulate complex template logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display flash messages to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an image uploader and learn how to securely handle file uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to store and serve static assets, such as JavaScript, stylesheets
    and image uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with WTForms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WTForms** is a popular choice for form processing and validation in the Flask
    community. It uses a declarative approach to building forms (similar to how we
    defined our SQLAlchemy models), and supports a variety of different field types
    and validators.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, WTForms 2.0 is still a development release,
    but should be the official release shortly. For that reason we will be using version
    2.0 in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by installing WTForms into our blog project `virtualenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the installation succeeded by opening up a shell and checking
    the project version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: My version shows the development release since 2.0 has not been officially released
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a form for the Entry model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal is to be able to create and edit blog entries directly through our
    site, so the first question we need to answer is—How will we input the data for
    our new entries? The answer, of course, is by using forms. Forms are a part of
    the HTML standard, which allows us to use free-form text inputs, large multi-line
    text boxes, drop-down selects, checkboxes, radio buttons, and more. When a user
    submits a form, the form specifies a URL that will receive the form data. That
    URL can then process the data and then respond in any way it likes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For blog entries, let''s keep it simple with three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Title`, displayed as a simple text input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Body`, displayed as a large free-form textbox'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Status`, which will be displayed as drop-down select'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `entries` directory, create a new Python file named `forms.py`.
    We will be defining a simple form class that will contain these fields. Open `forms.py`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should look pretty similar to our model definition. Note that we''re using
    the names of the columns in our model as the names for the fields in our form:
    this will allow WTForms to automatically copy data between the Entry model fields
    and the form fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two fields, `title` and `body`, both specify a single argument: the
    label that will be displayed when the form is rendered. The `status` field contains
    a label as well as two additional parameters: `choices` and `coerce`. The `choices`
    parameter consists of a list of 2-tuples where the first value is the actual value
    we are interested in storing and the second value is a user-friendly representation.
    The second parameter, `coerce,` will convert the value from the form to an integer
    (by default, it would be treated as a string, which we do not want).'
  prefs: []
  type: TYPE_NORMAL
- en: A form with a view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to start using this form, we need to create a view that will display
    the form and accept data when it is submitted. To do this, let''s open the entries
    blueprint module and define a new URL route to handle entry creation. At the top
    of the `blueprint.py` file, we need to import the `EntryForm` class from the `forms`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, above the definition for the `detail` view, we will add a new view named
    `create` that will be accessed by navigating to `/entries/create/`. The reason
    we must put it above the `detail` view is because Flask will search your URL routes
    in the order in which they are defined. Since `/entries/create/` looks very much
    like an entry detail URL (imagine the title of the entry was `create`), if the
    detail route is defined first, Flask will stop there and never reach the create
    route.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our create view, we will simply instantiate the form and pass it into the
    template context. Add the following view definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before we add code to save the new entries to the database, let's build a template
    and see what our form looks like. We will then circle back and add the code to
    validate the form data and create the new entry.
  prefs: []
  type: TYPE_NORMAL
- en: The create.html template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build a basic template for our new form. Create a new template named
    `create.html` alongside the other entry templates. The path to this file, relative
    to the app directory, should be `entries/templates/entries/create.html`. We will
    extend the base template and override the content block to display our form. Since
    we are using bootstrap, we will use special CSS classes to make our form look
    nice. Add the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By iterating over the form, which we passed into the context, we can render
    each individual field. To render the field, we first render the field's label
    by simply calling `field.label()` and passing in the desired CSS class. Similarly,
    to render the field, we call `field()`, again passing in the CSS class. Also note
    that, in addition to a `submit` button, we've added a `Cancel` link that will
    return the user to the entries list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server and navigate to `http://127.0.0.1:5000/entries/create/`
    to view the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The create.html template](img/1709_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try submitting the form. When you click the **Create** button, you should see
    the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The create.html template](img/1709_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason you are seeing this message is because, by default, Flask views will
    only respond to HTTP `GET` requests. When we submit our form, the browser sends
    a `POST` request, which our view does not currently accept. Let's return to the
    `create` view and add the code to correctly handle the `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever a form makes changes to the data (creates, edits, or deletes something),
    that form should specify the `POST` method. Other forms, such as our search form,
    which do not make any changes, should use the `GET` method. Additionally, when
    a form is submitted using the `GET` method, the form data is submitted as part
    of the query-string.
  prefs: []
  type: TYPE_NORMAL
- en: Handling form submissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we modify our view, let''s add a helper method to our `EntryForm` that
    we will use to copy data from the form into our `Entry` object. Open `forms.py`
    and make the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This helper method will populate the `entry` we pass in with the form data,
    re-generate the entry's slug based on the title, and then return the `entry` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the form is configured to populate our `Entry` models, we can modify
    the view to accept and handle the `POST` requests. We will be using two new Flask
    helpers, so modify the imports at the top of `blueprint.py`, adding `redirect`
    and `url_for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve added the imports, update the following changes to the `create`
    view in `blueprint.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a bit of new code, so let's take a closer look at what's happening.
    To begin with, we've added a parameter to the route decorator indicating that
    this view accepts both `GET` and `POST` requests. This will get rid of the **Method
    Not Allowed** error when we submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the view, we are now checking the `request` method and based
    on that we do one of two things. Let's look at the 'else' clause first. This branch
    of code will execute when we receive a `GET` request, such as when someone opens
    their browser and navigates to the `/entries/create/` page. When this happens,
    we simply want to display an HTML page containing the form, so we will instantiate
    a form and pass it into the template context.
  prefs: []
  type: TYPE_NORMAL
- en: In the event this is a `POST` request, which will happen when someone submits
    the form, we want to instantiate the `EntryForm` and pass in the raw form data.
    Flask stores the raw POST data in the special attribute `request.form`, which
    is a dictionary-like object. WTForms knows how to interpret the raw form data
    and map it to the fields we defined.
  prefs: []
  type: TYPE_NORMAL
- en: After instantiating our form with the raw form data, we then need to check and
    ensure that the form is valid by calling `form.validate()`. If the form fails
    to validate for some reason, we will simply pass the invalid form into the context
    and render the template. A bit later you will see how we can display error messages
    to the user when there is a problem with their form submission.
  prefs: []
  type: TYPE_NORMAL
- en: If the form validates, we can finally proceed with saving the entry. To do this,
    we will call our `save_entry` helper method, passing in a fresh `entry` instance.
    WTForms will populate the `Entry` object with form data, then return it back to
    us, where we add it to the database session, commit, and redirect. The redirect
    helper will issue an HTTP 302 redirect, sending the user's browser from `/entries/create/`
    to the detail page of the newly-created blog post.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your browser and give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling form submissions](img/1709_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Validating input and displaying error messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one glaring problem with our form: right now there is nothing to prevent
    us from accidentally submitting an empty blog entry. To ensure that we have a
    title and content when saving, we need to use a WTForm object called a validator.
    Validators are rules that are applied to the form data, and WTForms ships with
    a number of useful validators. Some of the more commonly-used validators are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataRequired`: this field cannot be blank'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Length(min=?, max=?)`: verify that the length of the data entered either exceeds
    the minimum, or does not exceed the maximum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberRange(min=?, max=?)`: verify that the number entered is within the given
    range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email`: verify that the data is a valid email address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URL`: verify that the data entered is a valid URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnyOf(values=?)`: verify that the data entered is equal to one of the provided
    values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoneOf(values=?)`: verify that the data entered is not equal to any of the
    provided values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the blog entry form, we will just be using the `DataRequired` validator
    to ensure that Entries cannot be created without a title or body content. Let''s
    open `forms.py` and add the validators to our form definition. Altogether, our
    forms module should look a follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Start the development server and now try to submit an empty form. As you might
    expect, it will fail to save since the call to `form.validate()` returns `False`.
    Unfortunately, there is no indication on the front-end why our form is not getting
    saved. Luckily, WTForms will make the validation errors available to us in the
    template, and all we need to do is modify our template to display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display validation errors we will be using several bootstrap CSS classes
    and constructions, but the end result will look very nice, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating input and displaying error messages](img/1709_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Make the following changes to the field display code in the `create.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are checking whether the field has any errors by looking at the `field.errors`
    attribute. If there are any errors, then we do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a CSS class to the `form-group` div
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a special icon indicating there is an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display each error in a `<span>` beneath the form field. Since `field.errors`
    is a list and may contain multiple validation errors, we will iterate through
    these using a for loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are now able to create valid blog entries using a form, which also performs
    a little validation to ensure that you do not submit blank forms. In the next
    section, we will describe how to re-use this same form for editing existing entries.
  prefs: []
  type: TYPE_NORMAL
- en: Editing existing entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Believe it or not, we can actually use the same form we used for creating entries
    to edit existing ones. We will only need to make some slight changes to the view
    and template logic, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to edit entries, we will need a view, so we will need a URL. Because
    the view needs to know which entry we are editing, it will be important to convey
    that as part of the URL structure, and for that reason we will set up the `edit`
    view at `/entries/<slug>/edit/`. Open `entries/blueprint.py` and, below the detail
    view, add the following code for the `edit` view. Note the similarities to the
    `create` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the `create` view, we check the `request` method and, based
    on that, we will either validate and process the form, or simply instantiate it
    and pass it to the template.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference is in how we are instantiating the `EntryForm`. We pass
    it an additional parameter, `obj=entry`. When WTForms receives an `obj` parameter,
    it will attempt to pre-populate the form fields with values taken from `obj` (in
    this case, our blog entry).
  prefs: []
  type: TYPE_NORMAL
- en: We are also passing an additional value into the template context, the entry
    that we are editing. We will do this so we can display the title of the entry
    to the user; in this way, we can make the **Cancel** button of the form link back
    to the entry detail view.
  prefs: []
  type: TYPE_NORMAL
- en: The edit.html template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might guess, the `edit.html` template will be almost identical to `create.html`.
    Due to the complexity of the field rendering logic, it seems like a bad idea to
    copy-and-paste all that code. If we ever decided to change the display of the
    form fields, we would find ourselves touching multiple files, which should always
    be a big red flag.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, we will be using a powerful Jinja2 feature called macros to render
    our fields. The field rendering code will be defined in a macro and then, wherever
    we wish to render a field, we will just call our macro instead. This makes it
    really easy to make changes to the way our fields are styled.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Macros are a feature of Jinja2 that allow you to treat a section of a template
    like a function so it can be called multiple times with different arguments and
    produce largely similar HTML. You can view more on the Jinja documentation site:
    [http://jinja.pocoo.org/docs/dev/templates/](http://jinja.pocoo.org/docs/dev/templates/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this macro is going to be useful for any form field we might wish to
    display, we will put it in our app''s template directory. Inside the app''s template
    directory, create a new directory named `macros` and add a field `form_field.html`.
    Relative to the app directory, the path to this file is `templates/macros/form_field.html`.
    Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For the most part, we have simply copied and pasted the field rendering code
    from our `create` template but there are a couple of differences I''d like to
    point out:'
  prefs: []
  type: TYPE_NORMAL
- en: The template begins with a `macro` template tag that defines the name of the
    `macro` and any arguments that it accepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we render the field, we are passing in `**kwargs`. WTForms fields can accept
    arbitrary keyword arguments, which are then translated into attributes on the
    HTML tag. While we are not currently going to make use of this, we will be using
    it in later chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We indicate the end of a macro with the `endmacro` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s update `create.html` to make use of the new macro. In order to use
    the macro, we must first `import` it. Then we can replace all the field markup
    with a simple call to the macro. With the changes, the `create.html` template
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, we can proceed to creating our `edit.html` template.
    It will look almost identical to the `create` template, except we will display
    text in the `app/entries/templates/entries` directory to indicate to the user
    that they are editing an existing entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To wrap things up, on the entry detail page let''s add a link in the sidebar
    that will take us to the `Edit` page. Add the following link to the sidebar in
    `detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Deleting entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To round out this section, we will add a view for deleting entries. We will
    design this view so that, when the user goes to delete an entry, they are taken
    to a confirmation page. Only by submitting the confirmation form (a `POST` request)
    will they actually be able to delete the entry. Because this form does not require
    any fields, we do not need a special WTForms class and can just create it using
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a template named `delete.html` alongside the `create.html` and `edit.html`
    templates, and add the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to define the `entries.delete` view. Like the `edit` view, the URL
    for deleting an entry needs the entry slug as part of the URL structure. For that
    reason, we will be using `/entries/<slug>/delete/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the form is submitted, we could simply remove the entry from the database
    but in my experience I have usually come to regret deleting content permanently.
    Instead of actually deleting the entry from the database, we will be giving it
    a `_DELETED` status; we will change its status to `STATUS_DELETED`. We will then
    modify our views so that entries with this status never appear on any part of
    the site. For all intents and purposes, the entry is gone but, should we ever
    need it again, we can retrieve it from the database. Add the following view code
    below the `edit` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to add STATUS_DELETED to the Entries model in model.py:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the Edit link, take a moment and add a `delete` link to the detail
    view sidebar as well.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a moment to refactor our blueprint. Since we do not want to display
    deleted entries on the site, we will need to make sure we filter our Entries by
    status. Additionally, looking at the `detail`, `edit` and `delete` views, I see
    three instances where we have copied and pasted the code to query an entry by
    slug. Let's move that into a helper function as well.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, let's update the `entry_list` helper to filter for Entries that
    are either public or drafts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we will be adding log-in functionality to the site. Once
    we have that, we will add logic to display draft entries only to the users who
    created them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can now be confident that anywhere we display lists of entries, no deleted
    entries will show up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a new helper to retrieve an `Entry` by its slug. If the entry
    cannot be found, we will return a 404\. Add the following code below `entry_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the call to `Entry.query.filter()` in the `detail`, `edit`, and `delete`
    views with a call to `get_entry_or_404`. The following is the updated detail view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using flash messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user performs an action on a site, it is common to display a one-time
    message on the subsequent page-load indicating that their action has succeeded.
    These are called flash messages and Flask comes with a helper for displaying them.
    In order to get started using flash messages, we need to take a brief detour to
    our `config` module where we will be adding a secret key. The secret key is necessary
    because flash messages are stored in the session, which in turn is stored as an
    encrypted cookie. To securely encrypt this data, Flask needs a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `config.py` and add a secret key. It can be a phrase, random characters,
    whatever you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, wherever we have the user performing an action, we want to flash them
    a message indicating that their action succeeded. This means we will be adding
    a message to the `create`, `edit,` and `delete` views. Open up the entries blueprint
    and add the flash function to the list of flask imports at the top of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in each of the appropriate views, let''s call `flash` with a helpful
    message. The call should occur right before we redirect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Displaying flash messages in the template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we do not always know which page we will be on when we need to display
    a flash message, it is a standard practice to add the display logic to the base
    template. Flask provides a Jinja2 function `get_flashed_messages` that will return
    us a list of any pending messages to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `base.html` and add the following code. I have placed mine between the
    `content_title` block and the `content` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give it a try! Start the development server and try adding a new entry.
    Upon saving, you should be redirected to your new entry and see a helpful message
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying flash messages in the template](img/1709_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Saving and modifying tags on posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered how to save and modify tags on our entries. One of the most
    common approaches to managing tags is to use a comma-separated text input, so
    we might list the tags as *Python*, *Flask*, *Web-development*. With WTForms this
    seems pretty straightforward, since we would just use a `StringField`. The fact
    that we are dealing with a database relationship, though, means that at some point
    we need to do some processing to convert between `Tag` models and a comma-separated
    string.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many ways we could accomplish this, we will implement a custom
    field class `TagField`, which will encapsulate all the logic for translating between
    comma-separated tag names and `Tag` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option would be to create a *property* on the `Entry` model. A property
    looks like a normal object attribute, but it is actually a combination of getter
    and (sometimes) setter methods. Since WTForms can automatically work with our
    model attributes, this means that, if we implement our translation logic in the
    getter and setter, WTForms will just work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining our tag field class. There are two important methods
    we need to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_value()`: converts the list of `Tag` instances into a comma-separated list
    of tag names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process_formdata(valuelist)`: accepts the comma-separated tag list and converts
    it into a list of `Tag` instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the implementation for the `TagField`. Note how we take special
    care when processing user input to not create duplicate rows in the `Tag` table.
    We are also using Python''s `set()` data-type to eliminate possible duplicates
    in the user input. Add the following class to `forms.py` above the `EntryForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that is left is to add the field to the `EntryForm`. Add the following
    field below the `status` field. Note the use of the `description` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to display this helpful `description` text, let''s make a quick modification
    to the `form_field` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the development server and experiment by saving a few tags. Your form
    should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and modifying tags on posts](img/1709_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll round out the chapter on form processing by adding an image-uploading
    feature to the site. This feature will be a simple view that accepts an image
    file and stores it on the server in an uploads directory. This will make it easy
    to display images on our blog entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be to create a form for handling our image uploads. Alongside
    `EntryForm`, let''s add a new form called `ImageForm`. This form will be very
    simple and contain a single file input. We will use a custom validator to ensure
    that the uploaded file is a valid image. Add the following code to `forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we add a view to save the form, we need to know where we are going to
    save the file. Typically, resources for an app—such as images, JavaScript, and
    stylesheets—are served out of a single directory called `static`. Common practice
    is to then over-ride the path to this directory in your web server so it can transfer
    this file without having to go through a Python intermediary, making access much
    faster. We make use of this usage of the `static` directory to store our image
    uploads. In the blog project''s `app` directory, let''s create a new directory
    named `static` and a subdirectory `images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a new value to our configuration file so we can easily reference
    the path to our images on-disk. This simplifies our code in the long run should
    we ever choose to change this location. Open `config.py` and add the following
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Processing file uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to create a view for processing the image upload. The logic
    will be very similar to our other form processing views with the exception that,
    after validating the form, we will save the uploaded file to disk. Since these
    images are intended for use in our blog entries, I am adding the view to the entries
    blueprint, accessible at `/entries/image-upload/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to import our new form along with other helpers. Open `blueprint.py`
    and add the following imports to the top of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the list of views, let''s add the new `image-upload` view. It
    is important that it appears before the `detail` view, otherwise Flask will incorrectly
    treat `/image-upload/` as the slug of a blog entry. Add the following view definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code here probably looks familiar to you, the notable exception
    being the use of `request.files` and `secure_filename`. When a file is uploaded,
    Flask will store it in `request.files`, which is a special dictionary keyed by
    the name of the form field. We do some path joining using `secure_filename` to
    prevent malicious filenames and to generate the correct path to the `static/images`
    directory, and then save the uploaded file to disk. It is that easy.
  prefs: []
  type: TYPE_NORMAL
- en: The image upload template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a simple template for our image upload form. Create a file in
    the entries template directory named `image_upload.html` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for Flask to process our uploaded file, we must specify `enctype="multipart/form-data"`
    when defining our `<form>` element. This is a very common mistake, so I will repeat
    again: whenever you are accepting file uploads, your form element must specify
    `enctype="multipart/form-data"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try out the image uploader. You should see your uploaded files
    appear in the `static/images/directory` in your app. You can also view the image
    in your browser by navigating to `http://127.0.0.1:5000/static/images/the-file-name.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask will automatically serve up files from our `/static/` directory. When
    we deploy our site in [Chapter 10](ch10.html "Chapter 10. Deploying Your Application"),
    *Deploying Your Application*, we will use the **Nginx** web server to serve static
    assets but, for local development, Flask makes things really easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to our image uploads, let''s also serve our site''s JavaScript
    and stylesheets from `/static/`. Download jQuery and Bootstrap and place the JavaScript
    files (`jquery-<version>.min.js` and `boostrap.min.js`) in `static/js`. Place
    the minified bootstrap CSS file (`bootstrap.min.css`) in `static/css`. Bootstrap
    also comes with some special fonts that are used for icons. Copy the bootstrap
    fonts directory into the static directory as well. You should now have four directories
    inside your application''s static directory: `css`, `fonts`, `images` and `js`,
    each containing the relevant files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to point our base template at the local versions of these files, we
    will use the `url_for` helper to generate the correct URL. Open `base.html` and
    remove the old stylesheet and JavaScript tags, replacing them with the local version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you like, you can create a `site.css` file in the `static/css` directory
    and replace the `<style>` tag with a link to `site.css`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a variety of new ways to interact with the site. It
    is now possible to create and modify content directly through the site. We discussed
    how to create object-oriented forms with WTForms, including processing and validating
    the form data from the view, as well as writing that form data to the database.
    We also created templates to display forms and validation errors and used Jinja2
    macros to remove repetitive code to make the code more modular. We were then able
    to display single-use flash messages to the user when they perform an action.
    Finally we also explained how to handle file uploads using WTForms and Flask,
    and to serve static assets, such as JavaScript, stylesheets, and image uploads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before jumping into the next chapter, take some time to experiment with the
    new features we added to the site. Here are some ideas for ways you can improve
    on what we''ve built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a header link to the image upload form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the image upload view, validate that the file's extension is a recognized
    image extension (.png, .jpg, .gif).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a read-only StringField to display the Entry's slug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our tag index view will show tags that have zero entries associated with them
    (which might be the case if we added a tag, then removed it from an entry). Improve
    the query to only list tags with one or more associated entries. Hint: `Tag.query.join(entry_tags).distinct()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Display the number of entries associated with a tag in the tag index. Advanced:
    do it in a single query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced: Create an Image model and views for creating, editing, and deleting
    images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will add authentication to our site so that only trusted
    users can create and modify content. We will build a model to represent blog authors,
    add log-in/log-out forms, and prevent unauthenticated users from accessing certain
    areas of the site.
  prefs: []
  type: TYPE_NORMAL
