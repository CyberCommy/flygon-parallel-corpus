- en: Chapter 11. Designing a Functional Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a whole application respecting the precepts of functional programming
    might seem like an impossible task. How can you write any meaningful software
    if you cannot have any side-effects? In order to perform any kind of computation,
    you will need at least some inputs and display results.
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages have various mechanisms to circumvent those limitations.
    We will quickly present some of them so that you can have a better idea about
    how an application can be written in a purely functional way.
  prefs: []
  type: TYPE_NORMAL
- en: We will then learn more in depth about a paradigm called **Functional Reactive
    Programming** (**FRP**), as a way to design an application having a user interface.
    We will lay the foundation for using this technique in PHP to see if it is possible
    to use it to write a complete application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a complete application in a purely functional language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a PHP application using FRP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture of a purely functional application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications are like functions. If you have an application without any input,
    its outcome will always be the same. You have the possibility of modifying some
    values in the source code and recompiling your software to change its result,
    but this is contrary to the main reason we write applications in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why you need a way to feed data to an application in order for it to
    perform any kind of meaningful computation. Those inputs can be of multiple types:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields in a graphical interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of all those, only the first one could be considered as not breaking the
    referential transparency of our whole application. If you consider your application
    as one big function, feeding data on the command line could be considered as its
    parameters, thus keeping everything pure. All other kinds of input are de facto
    impure, since two subsequent retrievals of the data could lead to different values.
  prefs: []
  type: TYPE_NORMAL
- en: The canonical Haskell way to solve this issue is to use the **IO monad**. Instead
    of performing its operations immediately, the IO monad stores all steps in a queue.
    If you name this IO operation `main`, Haskell will know it has to run it when
    the compiled program is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the application itself is not pure anymore if you perform any kind
    of IO operation inside the monad. However, the code itself can be written in a
    referentially transparent way. It's the Haskell runtime that will perform all
    impure operations when the IO monad is run and will then pass the various obtained
    values around. Using this trick, you can write pure functional code with all the
    benefits it brings and still perform IO operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is usable in Haskell because you can use monad transformers to
    combine multiple monads. The do notation also helps a lot by writing code encapsulated
    in the IO monad without all the overhead associated with it. For example, here
    is a small program reading lines in the Terminal and printing them with the words
    in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It reads mostly like any imperative source code performing the same task. PHP
    lacks the syntactic sugar and there exists no implementation of monad transformers,
    so it is quite hard to do this. This is why we make compromises as discussed in
    the previous chapter, or we need some other approach, as we will see in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The idea at play can be generalized. Any impure function can be split into two
    functions, one pure and one encapsulating the side causes and side effects. This
    is exactly what we were referring to in the previous chapter when we stated that
    most impure functions should be contained in the MVC application's controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an impure function `f` taking `A` as a parameter and returning
    `B`, you can create the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A pure function `g`, which takes `A` and returns `D` parameter. The parameter `D` is
    being a description of the IO operations that need to be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An impure function `h` taking `D` and performing the described operations like
    an interpreter would do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we take the example of a Haskell application, the Haskell runtime itself
    would be our impure `h` function. If our source were to return an instance of
    the IO monad, as our example on just above is doing, it would be used as the `D`
    parameter and the side-effects would be interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: If you are writing a web application using the **Symfony** framework, we could
    consider the framework as the the impure `h` function and the `D` parameter would
    be the result of executing your controller for example. Another possibility would
    be to add our custom impure wrapper around our functional code.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea is to reduce the number of functions like `h` to the minimum.
    Haskell forces you to have only one such function and it's even hidden inside
    the runtime. If you are using PHP, it's up to you to enforce this rule as effectively as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of having a description of the computations and an interpreter
    to perform them is central to a lot of the more advanced techniques in the functional
    world. It is also quite important in computer programming as a whole. If we take
    a bit of distance, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The description is like an Abstract Syntax Tree (**AST**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter takes the AST and runs it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how most modern compilers work, first they parse the source code to
    transform it in an AST and then interpret it to create the binary file. You will
    also find the same pattern again and again in most complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: An advanced construct using this structure is the *free monad*. This monad is
    currently a hot topic in the functional world and its usage is growing fast. We
    are missing quite a bit of theory to approach the topic here, but if you are interested
    you will surely find a lot of information on the Internet, for example, [http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html](http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html).
  prefs: []
  type: TYPE_NORMAL
- en: However, this pattern is problematic when you accept user interaction during
    the lifecycle of the application. Since the main idea is to delay the execution
    of effective computations by describing them instead, you cannot perform part
    of the computation to display a user interface and then react to user input. This
    is one of the issues that FRP tries to solve.
  prefs: []
  type: TYPE_NORMAL
- en: From Functional Reactive Animation to Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is often the case when it comes to functional programming, the foundations
    behind the subject at hand date back a bit. In 1997, Conal Elliott and Paul Hudak
    published a paper called *Functional Reactive Animation, or Fran*.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of Fran is to allow the modeling of animations with two concepts
    called **behaviors** and **events**. Behaviors are values based on the current
    time, and events are conditions based on external or internal stimuli. Those two
    notions allow us to represent any kind of animation at any point in time although
    the animation itself is continuous.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of directly creating the representation of your animation as it is usually
    the case, you describe it using behaviors and events. The interpretation, and
    thus representation, is then left to the underlying implementation. This is similar
    to what we just described. As events such as keyboard inputs or mouse clicks can
    be encoded inside Fran, the model you are creating allows for a pure functional
    application to respond to external inputs like those.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go any further, let's speak a bit about what *reactive* means in the
    programming world. It's an idea that has gotten quite a lot of traction in the
    last few years.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, there is the *Reactive Manifesto* ([http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)),
    which presents a list of properties that are really interesting to have for any
    software. Those properties are: responsiveness, resilience, elasticity, and being
    message-driven.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Wikipedia ([https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming))
    definition states something quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In computing, reactive programming is a programming paradigm oriented around
    data flows and the propagation of change. This means that it should be possible
    to express static or dynamic data flows with ease in the programming languages
    used, and that the underlying execution model will automatically propagate changes
    through the data flow.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An example is then given of the expression *a = b + c*, where the value of `a`
    is automatically updated when any of `b` or `c` changes.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript world is in effervescence about the idea, with libraries such
    as `Bacon.js` or `RxJS`. The core idea shared by all of those libraries revolves
    around events or event-streams.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are multiple definitions of what reactive programming is.
    Sadly, none of them really quite match what we just learned about Fran. As it
    has been floating around at least since the seventies, the definition that we
    will keep for the remainder of this chapter is the academic one, which can be
    found on Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: I am not saying the other ones are invalid, just that we need to have a common
    ground here. Also, next time you speak of reactive programming with someone, first
    make sure you are on the same page concerning what the topic is.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final example of reactive programming, let''s consider the following piece
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a traditional imperative language, the last line will still display 15\.
    However, if our application were to follow the rules set by reactive programming,
    the new value of `$a` would also affect the value of `$c` and the program would
    display 28.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can probably guess, values changing over time when other changes are
    made are far from being referentially transparent. Also, the concept of variables
    is completely missing from some functional languages. How can we reconcile reactive
    and functional programming?
  prefs: []
  type: TYPE_NORMAL
- en: The core idea is to make the time component and the previous events parameters
    of your functions when they need them. This is exactly what Fran proposed with
    behaviors and events. Both time and events are usually proposed for consumption
    as a stream. Using functional mapping and filtering, you are able to decide which
    events on the stream interest you.
  prefs: []
  type: TYPE_NORMAL
- en: Your functions take one or multiple inputs from this stream alongside the current
    state of the application. They must then return the new state of the application.
    The runtime will take care of calling the various registered functions when the
    events happen.
  prefs: []
  type: TYPE_NORMAL
- en: You might have the impression that it is similar to event-driven programming.
    In a way it is, but there is a big difference. In a traditional event-driven application,
    events are triggered, but the return value of the handlers is often of no importance;
    they need to have side-effects to perform something.
  prefs: []
  type: TYPE_NORMAL
- en: When doing FRP, the runtime takes care of orchestrating all registered handlers.
    Keeping the current state of the application, passing it to each handler, and
    updating it with their results. This allows for the functions to be pure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another programming paradigm that might be a bit closer than event-driven programming
    is the actor model. I won''t describe it here as it will be out of scope for this
    book, but for people aware of it, I will just say that there are two main differences:'
  prefs: []
  type: TYPE_NORMAL
- en: As you have pure functions instead of actors, you cannot have a private state
    influencing the way you respond to a given message, or event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime manages the event stream; there is no way for the handlers to send
    new messages to other parts of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time traveling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FRP also has another benefit. If you record the sequence of events leading to
    a particular application state, you can replay them. Where it gets better is that
    you can implement what is called a **time traveling debugger**. Since your application
    is using pure functions, you can go back to any point in time and get the exact
    same state as you've had before.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of debugger also allows you to replay any number of steps back and
    forth until you can pinpoint exactly what is happening. Also, you can make changes
    to your code and play the same events to see how your modification affected your
    software.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see such a debugger in action, you can head over to the one proposed
    by the **Elm** language, specifically their online version with a naive implementation
    of the Mario platform game ([http://debug.elm-lang.org/edit/Mario.elm](http://debug.elm-lang.org/edit/Mario.elm)).
  prefs: []
  type: TYPE_NORMAL
- en: The Elm debugger is probably one of the first of its kind. Although similar
    ideas have been implemented in traditional languages, the very nature of imperative
    programming requires us to record a lot more than just the stream of events. This
    is why it is a really costly operation, slowing down the execution of the program
    a lot.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to restart the program from the beginning in order to be sure
    to attain the same state. However, in a pure application, you can do this in a
    more straightforward way. Implementations more akin to the one found in Elm are
    now being created, for example, for the **React** JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: Disclaimer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are FRP and FRP, but instead of paraphrasing the creator of the idea,
    let me instead quote him:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Over the last few years, something about FRP has generated a lot of interest
    among programmers, inspiring several so-called "FRP" systems implemented in various
    programming languages. Most of these systems, however, lack both of FRP''s fundamental
    properties.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can see the full text alongside related slides and video on GitHub ([https://github.com/conal/talk-2015-essence-and-origins-of-frp](https://github.com/conal/talk-2015-essence-and-origins-of-frp)).
  prefs: []
  type: TYPE_NORMAL
- en: As often, there is some kind of divergence between the academical world and
    the usage people make of the research results. I won't dwell on the details as
    this is supposed to be only an introductory chapter. However, it is important
    that you are aware of this fact.
  prefs: []
  type: TYPE_NORMAL
- en: The main point of contention is the fact that FRP is about *continuous time*,
    whereas most implementations consider only *discrete events or values*. If you
    want to know more about those differences, I strongly suggest you watch the previously
    linked video, available on the GitHub repository of Elliot Conal, the creator
    of Fran and FRP.
  prefs: []
  type: TYPE_NORMAL
- en: Going further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of other things to say about Functional Reactive Programming.
    In fact, whole books are dedicated to the subject. This is, however, just an introduction
    so we will stop there. If you want a general approach to the topic not tied to
    a specific language, I can recommend the newly published *Functional Reactive
    Programming* by Stephen Blackheath and Anthony Jones.
  prefs: []
  type: TYPE_NORMAL
- en: On the implementation side, the **ReactiveX** project tries to federate libraries
    available on multiple projects. You can find more information on the official
    website at [http://reactivex.io/](http://reactivex.io/). At the time of writing,
    the following languages are covered; Java, Swift, Python, PHP, Scala, JavaScript,
    Ruby, Clojure, Rust, Go, C#, C++, and Lua.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the previous disclaimer, and the introduction on the ReactiveX
    website, there is currently a conflation of the academic concept of FRP as extended
    from the original Fran paper and what today's programmer means by the term. Both
    the aforementioned book and the ReactiveX libraries speak about the latter rather
    than the original meaning. It does not mean those are bad ideas, quite the contrary;
    it is just that it is not real FRP.
  prefs: []
  type: TYPE_NORMAL
- en: ReactiveX primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Rx*` libraries made the choice of implementing the functional reactive
    paradigm by extending the classical Observer pattern into the `Observable` model.
    For a given stream of values, represented by an instance of the `Observable` model,
    you can define up to three different handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `onNext` handler will be called each time there is a new value available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onError` handler will be called when an exception arises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onCompleted` handler will be called when the stream is closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach makes it easy to work with multiple asynchronous events without
    having to write complex boilerplate code to manage dependencies between them.
    Contrary to the traditional Observer pattern, the ability to signal the end of
    the stream and errors is added to reconcile the interface with iterables.
  prefs: []
  type: TYPE_NORMAL
- en: ReactiveX also defines a bunch of operators to both manipulate observables and
    their values. There are helper methods to create various kinds of streams, from
    ranges to arrays, passing by infinitively repeating values and timed release events.
  prefs: []
  type: TYPE_NORMAL
- en: You can also manipulate the stream itself by mapping functions to each emitted
    value, grouping them into new observables or into arrays of values. You can also
    filter the values, skip or take a certain number of them, limit the number of
    emissions for a certain amount of time, and suppress duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html))
    has a complete list of what manipulations are available, along with a nice decision
    tree to decide which one to use based on the context.
  prefs: []
  type: TYPE_NORMAL
- en: RxPHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start having a look at some examples of RxPHP, I would like to point
    out that Packt Publishing also published a complete book, *PHP Reactive Programming*,
    about the topic. You can find more information on their website at [https://www.packtpub.com/web-development/php-reactive-programming](https://www.packtpub.com/web-development/php-reactive-programming).
    This is why we will only explore some basic examples to give you a feel for how
    using the library might look. If the subject is of interest to you, I strongly
    suggest you read the dedicated book.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this very brief introduction to ReactiveX, let''s see how it can be used.
    First we will need to install the required library. We will use a small wrapper
    around ReachPHP''s stream library to make it usable with RxPHP so we can demonstrate
    accessing files on disk. The following `composer` invocation should install all
    needed dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the library is installed, you can parse data from any PHP stream.
    For example, a CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create a stream Observable for the file we want to read, then we apply
    some transformation: separating the input by line, parsing the CSV string in an
    array, and applying any other data processing you might want. As you can infer
    from the fact that we reassign the result to `$data` variable, the operation is
    not made in place, but a new instance is returned each time.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can subscribe handlers to our stream. In our case, we simply print
    the first row of each element. Not really functional, but effective enough for
    a small example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using **PostgreSQL**, a package allowing you to use Rx to access
    your database exists. You can use it to retrieve data using a stream. You can
    install it using the `composer` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating queries is fairly easy. It is a matter of creating a client with the
    connection credentials and then calling one of the methods on it to create an
    Observable instance on which you can subscribe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a final example demonstrating some of the more advanced filtering and
    transformation possibilities offered by Rx on the streams themselves. Try to guess
    what the output will be before running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run this last piece of code, you need to have the development
    version of RxPHP, as `throttle` was only recently implemented. If your minimum
    stability parameter is set to the `dev` edition, you can install it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Achieving referential transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the examples demonstrated, creating streams and subscribing to them is fairly
    trivial. It is also quite easy to imagine how we can factorize handlers in a way
    that will allow reuse between multiple observable instances.
  prefs: []
  type: TYPE_NORMAL
- en: The issue that Rx does not solve for us, however, is the application architecture
    needed to achieve referential transparency as much as possible. It does not suffice
    creating a new database query as an Observable to be pure.
  prefs: []
  type: TYPE_NORMAL
- en: The advice I can give you is the same you already heard in the last chapter
    that is to try to segregate all impure code in one place. In our case, this can
    be achieved by creating all streams in a unique file, like your `index.php` file,
    for example, and declaring the handlers somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: The various handlers can be tested in isolation and you can quickly build up
    confidence about them as they will be referentially transparent. The integration
    and functional tests will then take care of testing the streams themselves and
    the application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to use Rx in an existing framework, you can declare streams in your
    controllers and keep the handlers separated the same way as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional reactive programming allows us to reconcile pure functions with event
    management. This means it is possible to create applications requiring inputs
    from the user or access to third-party services and external data sources. This
    is especially important as more and more websites make use of web sockets and
    other such technologies to continually push data to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Besides access to data sources, FRP is great when doing user interface work.
    A task is usually done with JavaScript on the Web, as PHP is mostly used to treat
    the request itself and serves an HTML response. PHP might, however, be used more
    on the desktop with initiative, such as the wrapper around **libui** available
    in beta for PHP 7 ([https://github.com/krakjoe/ui](https://github.com/krakjoe/ui)).
  prefs: []
  type: TYPE_NORMAL
- en: Desktop applications in PHP, being a fairly new topic in the community, now
    might be a great time to create some best practices around it based on state-of-the-art
    that is functional reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: We just brushed the surface of this new way of designing applications as it
    would require a lot more than a chapter to do so fully. Both books mentioned previously
    are a great starting point if you want to learn more about the topic.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we've learned a bit about the history of FRP. We also tried
    to discover the differences between traditional reactive programming and its functional
    counterpart. We quickly spoke about time-traveling debugging and then showed a
    few examples in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: You have just finished the last chapter of this book. I hope you've had as much
    fun reading it as it was for me writing it. I also hope I was able to interest
    you in the topic of functional programming and that you will try to implement
    the various techniques we've seen in this book in your future projects. There
    would be no better reward for me than knowing I was able to get a fellow developer
    interested in this wonderful topic.
  prefs: []
  type: TYPE_NORMAL
- en: Before we part, may I suggest you read the `Appendix`, *What are we Talking
    About When we Talk About Functional Programming*. It contains a more thorough
    definition of what functional programming is, its benefits, and its history. You
    will also find a glossary at the end explaining various terms, some of them seen
    in this book and others new.
  prefs: []
  type: TYPE_NORMAL
- en: So long, and thanks for all the fish.
  prefs: []
  type: TYPE_NORMAL
