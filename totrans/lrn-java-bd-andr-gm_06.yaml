- en: Chapter 6. OOP – Using Other People's Hard Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP stands for **object-oriented programming**. In this chapter, you don't need
    to even try and remember everything. Why do I say this? Surely, that's what learning
    is. The more important thing is to grasp the concepts and begin to understand
    the *why* of OOP rather than memorize rules, syntax, and jargon.
  prefs: []
  type: TYPE_NORMAL
- en: The more important thing is to actually start to use some of the concepts, even
    though you might have to keep referring back and your code might not properly
    adhere to every OOP principal that we discuss. Neither does the code in this book.
    The code in this chapter is here to help you explore and grasp the concepts of
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to memorize this chapter, you will have to make a lot of room in
    your brain, and you will probably forget something really important in its place
    such as going to work or thanking the author for telling you not to try and memorize
    this stuff.
  prefs: []
  type: TYPE_NORMAL
- en: A good goal will be to try and almost get it. Then we will start to recognize
    examples of OOP in action so that our understanding becomes more rounded. You
    can then often refer back to this chapter for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: So what is all this OOP stuff we will learn about? Actually, we have already
    learned loads about OOP. Until now, we have been using classes such as `Button`,
    `Random`, and `Activity`, overriding methods of classes (mainly `onCreate`) and
    using an **interface** as well; remember implementing `onClickListener` a few
    times in the first five chapters?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter just helps to make sense of OOP and expands our understanding,
    and finally, we will make our own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will be in a good position in the next two chapters to make two cool
    retro arcade games using lots of other people's hard work. This chapter will be
    mainly theory, but with a few practical console examples using LogCat so that
    we can see OOP in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at what OOP is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our first class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at what encapsulation is and how we achieve it as well as look more deeply
    at variables and the different types. We will also take a short break to throw
    out the garbage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about inheritance and how we can extend and even improve upon a class
    before we use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at polymorphism, which is a way of being more than one thing at
    a time and is really useful in programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is OOP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Each chunk is self-contained yet potentially reusable by other programs while
    working together as a whole with the other chunks.
  prefs: []
  type: TYPE_NORMAL
- en: These chunks are what we have been referring to as objects. When we plan an
    object, we do so with a class. A class can be thought of as the blueprint of an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint. You can''t live in it, but you can build a house
    from it, which means you build an instance of it. However, OOP is more than this.
    It is also a methodology that defines best practices such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: This means keeping the internal workings of your code safe
    from interference from the programs that use it, and allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still accessed in the same way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: Just like it sounds, inheritance means we can harness all
    the features and benefits of other people''s hard work, including encapsulation
    and polymorphism, while refining their code specifically for our situation. Actually,
    we have done this already every time we used the `extends` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: This allows us to write code that is less dependent on the
    types we are trying to manipulate, making our code clearer and more efficient.
    Some examples later in the chapter will make this clear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we talk about using other people's hard work, we are not talking about
    a magical way to abuse copyright and get away with it. Some code is plain and
    simple, someone else's property. What we are taking about is the vast array of
    free-to-use code, particularly in the context of this book, in the Java and Android
    APIs. If you want some code that does a certain thing, it has probably been done
    before. We just have to find it, then use it or modify it.
  prefs: []
  type: TYPE_NORMAL
- en: Java was designed from the start with all of this in mind, so we are fairly
    significantly constrained to using OOP. However, this is a good thing because
    we learn how to use the best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Why do it like this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When written properly, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained nature means less, or perhaps zero, consequences for
    other parts of the program. This is the encapsulation part.
  prefs: []
  type: TYPE_NORMAL
- en: You can use other people's code without knowing or perhaps even caring how it
    works. Think about the Android lifecycle, buttons, threads, and so on. The `Button`
    class is quite complicated, with nearly 50 methods—do we really want to write
    all that just for a button?
  prefs: []
  type: TYPE_NORMAL
- en: OOP allows you to write apps for highly complex situations without breaking
    a sweat. You can create multiple similar yet different versions of a class without
    starting the class from scratch using inheritance, and you can still use the methods
    intended for the original type of object with your new object because of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Makes sense, really! Let's write some classes and then make some objects out
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Our first class and first object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what exactly is a class? A class is a bunch of code that can contain methods,
    variables, loops, and all other types of Java syntax. A class is part of a package
    and most packages will normally have multiple classes. Usually, but not always,
    each new class will be defined in its own `.java` code file with the same name
    as the class.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have written a class, we can use it to make as many objects from it
    as we need. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the blueprint just as the object isn't the class;
    it is an object made from the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for a class. We call it a class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is also a method called `shootEnemy`. The method has no parameters and
    a `void return` type, but class methods can be of any shape or size that we discussed
    in [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"), *Gaming and
    Java Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare variables in a class, they are known as **fields**. When the
    class is instantiated into a real object, the fields become variables of the object
    itself, so we call them **instance** variables. Whichever fancy name they are
    referred to by, they are just variables of the class. However, the difference
    between fields and variables declared in methods (called the **local** variables)
    becomes more important as we progress. We will look at all types of variables
    again in the *Variables revisited* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, this is just a class, not an object. It is a blueprint for a soldier,
    not an actual `soldier` object. This is how we make an object of the `Soldier`
    type from our `Soldier` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first part of the code, `Soldier mySoldier` declares a new reference
    type variable of type `Soldier`, called `mySoldier`, and in the last part of the
    code, `new Soldier()` creates an actual `Soldier` object. Of course, the assignment
    operator, `=`, in the middle of the two parts assigns the result of the second
    part to that of the first. Just like regular variables, we could also have performed
    the preceding steps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we would assign and use the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a rough guide, a class's methods are what it can *do* and its instance variables
    are what it *knows* about itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also go ahead by making another `Soldier` object and accessing its methods
    and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is important to realize that `mySoldier2` is a totally separate object with
    totally separate instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that everything is done on the object itself. We must create objects
    of classes in order to make them useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, there are exceptions to this rule, but they are in the minority,
    and we will look at the exceptions later in the chapter. In fact, we have already
    seen an exception way back in [Chapter 3](ch03.xhtml "Chapter 3. Speaking Java
    – Your First Game"), *Speaking Java – Your First Game*. Think of `Toast`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore basic classes a little more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Basic classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when we want an army of `Soldier` objects? We will instantiate
    multiple objects. We will also demonstrate the use of the dot operator on variables
    and methods, and show that different objects have different instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the working project for this example in the code download. It is
    in the `chapter6` folder and is called simply `BasicClasses`. Or read on to create
    your own working example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Clean
    up the code by deleting the unnecessary parts, but this isn't essential. Call
    the application `BasicClasses`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we create a new class called `Soldier`. Right-click on the `com.packtpub.basicclasses`
    folder in the Project Explorer window. Click on **New**, then on **Java Class**.
    In the **Name** field, type `Soldier` and click on **OK**. The new class is created
    for us, with a code template ready to put our implementation within, just like
    what is shown in the following screenshot:![Basic classes](img/8859OS_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that Android Studio has put the class in the same package as the rest
    of our app. Now we can write its implementation. Write the following class implementation
    code within the opening and closing curly braces of the `Soldier` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a class, a blueprint for our future objects of the `Soldier`
    type, we can start to build our army. In the editor window, click on the tab of
    **MainActivity.java**. We will write this code, as so often, within the `onCreate`
    method just after the call to `setContentView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a really good time to start taking advantage of the autocomplete feature
    in Android Studio. Notice that after you have declared and created a new object,
    all you have to do is begin typing the object's name and all the autocomplete
    options will present themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our extremely varied and somewhat unlikely army, we can use
    it and also verify the identity of each object. Type the following code below
    the code in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our app on an emulator. Remember, all the output will be in the
    **LogCat** console window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how the preceding pieces of code work. In step 2, Android Studio created
    a template for our new `Soldier` class. In step 3, we implemented our class in
    quite the same way that we have before—two variables, an `int` and a `string`,
    called `health` and `soldierType`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a method in our class called `shootEnemy`. Let''s look at it again
    and examine what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the body of the method, we print the `soldierType` string to the console
    first, and then the arbitrary `" is shooting"` string. What's neat here is that
    the `soldierType` string will be different depending on which object we call the
    `shootEnemy` method on.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we declared, created, and assigned three new objects of type `Soldier`.
    They where `rambo`, `vassily`, and `wellington`. In step 5, we initialized each
    with a different value for `health` as well as `soldierType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each time we access the `health` variable of each `Soldier` object,
    it is printed to the value we assigned it, demonstrating that although the three
    objects are of the same type, they are completely separate individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps more interesting are the three calls to `shootEnemy`. One call by each
    of our `Soldier` objects' `shootEnemy` method is made, and we print the `soldierType`
    variable to the console. The method has the appropriate value for each individual
    object, further demonstrating that we have three distinct objects, albeit created
    from the same `Soldier` class.
  prefs: []
  type: TYPE_NORMAL
- en: More things we can do with our first class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can treat a class much like other variables. Assuming we have already implemented
    our `Soldier` class, we can make an array of `Soldier` objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use an object from an array using the same style of array notation
    as we did for regular variables, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use a class as an argument in a method call. Here is a hypothetical
    call to a `healSoldier` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, the preceding example might raise questions like should the `healSoldier`
    method be a method of a class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It could be or not (as shown in the previous example). It would depend upon
    what is the best solution for the situation. We will look at more OOP, and then
    the best solution for lots of similar conundrums should present themselves more
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have come to expect by now, we can use an object as the return
    value of a method. Here is what the hypothetical `healSoldier` method might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All of this information will likely raise a few questions. OOP is like that,
    so to try and consolidate all this class stuff with what we already know, let's
    take another look at variables and encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention, although we did discuss the wider goals of all this OOP stuff. Now
    we will take things further and begin to see how we actually manage to achieve
    encapsulation with OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Definition of encapsulation**'
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned encapsulation means keeping the internal workings of your
    code safe from interference from the programs that use it, allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still made available in the same way. It also allows the code
    that uses your encapsulated code to be much simpler and easier to maintain because
    much of the complexity of the task is encapsulated in your code.
  prefs: []
  type: TYPE_NORMAL
- en: But didn't I say that we don't have to know what is going on inside? So you
    might question what we have seen so far. If we are constantly setting the instance
    variables like this `rambo.health = 100;`, isn't it possible that eventually things
    could start to go wrong, perhaps like the following line of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Encapsulation protects your class from being used in a way that it wasn''t
    meant to be. By strictly controlling the way that your code is used, it can only
    ever do what you want it to do, with values you can control. It can''t be forced
    into errors or crashes. Also, you are then free to make changes to the way your
    code works internally, without breaking any programs that are using an older version
    of the code or the rest of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can encapsulate our classes to avoid this, and here is how.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the use of classes with access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an **access modifier** before the `class`
    keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two class access modifiers. Let''s briefly look at each in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: This is straightforward. A class declared as `public` can be seen
    by all other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package, and inaccessible
    to all others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can make a start with this encapsulation thing. However, even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package that fulfills a set of tasks. Then all the complex inner workings
    of the package, the stuff that shouldn't be messed with by anybody but our package,
    should have default access (only accessible to classes within the package). We
    can then provide a careful selection of public classes that can be used by others
    (or other distinct parts of our program).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the size and complexity of the games in this book, multiple packages are
    almost certainly overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Class access in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to class-level privacy controls, Java gives us very fine-grained
    controls, but to use these controls, we have to look at variables in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the use of variables with access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build on class visibility controls, we have variable access modifiers. Here
    is a variable with the private access modifier being declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class `a` is not visible to class `b`, say because class `a` has
    default access and class `b` is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class `a`; class `b` still can't
    see it.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it makes sense to show a class to another class when necessary, but you
    should only expose the variables that are needed—not everything.
  prefs: []
  type: TYPE_NORMAL
- en: We have a bit more to cover on access modifiers, and then we will look at a
    few examples to help clarify things. For now, here is an explanation of the different
    variable access modifiers. They are more numerous and fine-grained than the class
    access modifiers. Most of the explanations are straightforward, and the ones that
    might raise questions will become clearer when we look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The depth and complexity of access modification is not so much in the range
    of modifiers, but by using them in smart ways, we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: You guessed it! Any class or method from any package can see this
    variable. Use `public` only when you are sure that this is what you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: This is the next least restrictive modifier after `public`. `protected`
    Variables set as protected can be seen by any class and any method as long as
    they are in the same package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This doesn''t sound as restrictive as `protected`, but it is more
    so. A variable has default access when no access is specified. The fact that `default`
    is restrictive perhaps implies that we should be thinking on the side of hiding
    our variables rather than exposing them. At this point, we need to introduce a
    new concept. Do you remember that we briefly discussed inheritance, and how we
    can quickly take on the attributes of a class and yet refine it using the `extends`
    keyword? Just for the record, default access variables are not visible to subclasses.
    This means that when we extend a class like we did with `Activity`, we cannot
    see its default variables. We will look at inheritance in more detail later in
    the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: These variables can only be seen within the class they are declared.
    Like default access, they cannot be seen by subclasses (inherited classes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable access in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes. Within these classes, variables will
    have carefully chosen and most likely varied access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: There's one more twist in all this access modification stuff before we get practical
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Methods have access modifiers too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It makes sense that methods are the things that our classes can do. We will
    want to control what users of our class can and can't do. The general idea here
    is that some methods will do things internally only and are therefore not needed
    by users of the class, and some methods will be fundamental to how users use your
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The access modifiers for methods are the same as those for the class variables.
    This makes things easy to remember but suggests again that successful encapsulation
    is a matter of design rather than any specific set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the method in the following code snippet, provided in a public
    class, can be used by any other class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following method can only be used internally by the class that
    created it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method has default visibility with no access specified. It can be
    used only by other classes in the same package. If we extend the class containing
    this default access method, the class will not have access to this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a last example before we move on. It contains a `protected` method,
    only visible to the package, but usable by our classes that extend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Method access in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need, and preferably nothing more. Thereby, we achieve our encapsulation goals
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing private variables with the getter and setter methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So if it is best practice to hide our variables away as private, how do we allow
    access to them without spoiling our encapsulation? What if an object of the `Hospital`
    class wanted access to the `health` member variable from an object of type `Soldier`
    so that it could increase it? The `health` variable should be private, right?
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to make as many member variables as possible private and
    yet allow some kind of limited access to some of them, we use **getters** and
    **setters**. Getters and setters are methods that just get and set variable values.
  prefs: []
  type: TYPE_NORMAL
- en: This is not some special or new Java thing we have to learn. It is just a convention
    for the use of what we already know. Let's take a look at getters and setters
    using the example of our `Soldier` and `Hospital` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each of our two classes are created in their own file but
    the same package. First of all, here is our hypothetical `Hospital` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter, so this method will
    work on whichever `Soldier` object is passed in: `vassily`, `wellington`, `rambo`,
    or whoever.'
  prefs: []
  type: TYPE_NORMAL
- en: It also has a `health` variable. It uses this variable to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's `health` is private,
    so the public getter method is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Then `health` is increased by 10 and the `setHealth` setter method loads the
    new `health` value back to the `Soldier` object.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it does so within the bounds of the getter and setter methods. The getter
    and setter methods can be written to control and check for potentially erroneous
    or harmful values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes our hypothetical `Soldier` class, with the simplest implementation
    possible of it''s getter and setter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method, which unsurprisingly returns the value held in the private
    `health` variable of the `int` type. As this method is public, anyone with access
    to the `Soldier` class can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `setHealth` method is implemented. Again it is public, but this time,
    it takes `int` as a parameter and assigns whatever value is passed to the private
    `health` variable. In a more life-like example, we would write some more code
    here to ensure that the value passed is within the bounds we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will declare, create, and assign to make an object of each of our two
    new classes and see how our getters and setters work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can also call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which can use the public getters and setters to manipulate the private `health`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play around with this example, there is a working app in the
    code bundle in the `Chapter6` folder, called `Getters And Setters`. I have added
    a few lines of code to print to the console. We deliberately covered this the
    way we did to keep the key parts of the code as clear as possible. We will soon
    build some real working examples that explore class, variable, and method access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. Just thought you might
    like to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet again, our example and the explanation are probably raising more questions.
    That''s good! Previously, I said that:'
  prefs: []
  type: TYPE_NORMAL
- en: There are two access modifiers for a class, default and public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects of classes are a type of reference variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables (including objects) have even more access possibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to look more closely at reference and primitive variables as well as
    local and instance variables. We will do so in a moment in the *Variables revisited*
    section. In that section, we will consolidate our information further to get a
    tighter grip on this OOP stuff. First let's remind ourselves of a bit about encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Using encapsulation features (such as access control) is like signing a really
    important deal about how to use and access a class, its methods, and its variables.
    The contract is not just an agreement about the present but an implied guarantee
    for the future. We will see that as we proceed through this chapter, there are
    more ways that we refine and strengthen this contract.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is perfectly possible to rewrite every example in this book without thinking
    or caring about encapsulation. In fact, the projects in this book outside of this
    chapter are quite lax about encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as the games in this book, except when the topic you are learning is encapsulation
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our objects with constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of these private variables and their getters and setters, does it
    mean that we need a getter and a setter for every private variable? What about
    a class with lots of variables that need initializing at the start? Think about
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We could go on like this. Some of these variables might need getters and setters,
    but what if we just want to set things up when the object is first created to
    make the object function correctly? Do we need two methods (a getter and a setter)
    for each?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we have a special method called a constructor. Here, we create an
    object of type `Soldier` and assign it to an object called `mySoldier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing new here, but look at the last part of that line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This looks suspiciously like a method.
  prefs: []
  type: TYPE_NORMAL
- en: We have called a special method called a constructor that has been supplied
    automatically for us by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'However (and this is getting to the point now), like a method, we can override
    it, which means we can do really useful things to set up our new object *before*
    it is used and any of its methods are placed on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is a constructor. It has a lot of syntactical similarities to a method.
    It can only be run with the use of the `new` keyword. It is created for us automatically
    by the compiler unless we create our own like in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They have no return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the same name as the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can have parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be overloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will play with constructors in the next demo.
  prefs: []
  type: TYPE_NORMAL
- en: Variables revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably remember, back in the math game project, that we kept changing
    where we declared our variables. First, we declared some in `onCreate`, then we
    moved them to just below the class declaration, and then we were making them member
    or instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Because we didn't specify the access, they were of default access and visible
    to the whole class, and as everything took place in the one class, we could access
    them everywhere. For example, we could update our TextView type objects from `onClick`,
    but why couldn't we do that when they were declared in `onCreate`? Further explanation
    about when and how we can access different variables is probably going to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The stack and the heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The VM inside every Android device takes care of memory allocation to our games.
    In addition, it stores different types of variables in different places.
  prefs: []
  type: TYPE_NORMAL
- en: Variables that we declare and initialize in methods are stored on the area of
    memory known as the `stack`. We can stick to our warehouse analogy when talking
    about the stack—almost. We already know how we can manipulate the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about the heap and what is stored there. All reference type objects,
    which include objects (of classes) and arrays, are stored in the heap. Think of
    the heap as a separate area of the same warehouse. The heap has lots of floor
    space for odd-shaped objects, racks for smaller objects, lots of long rows with
    smaller sized cube-shaped holes for arrays, and so on. This is where our objects
    are stored. The problem is that we have no direct access to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look again at what exactly a reference variable is. It is a variable that
    we refer to and use via a reference. A reference can be loosely (but usefully)
    defined as an address or location. The reference (address or location) of the
    object is on the stack. When we use the dot operator, we are asking Dalvik to
    perform a task at a specific location as stored in the reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reference variables are just that—a reference. They are a way to access and
    manipulate the object (variables or methods), but they are not the actual variable.
    An analogy might be that primitives are right there (on the stack) but references
    are an address, and we say what to do at the address. In this analogy, all addresses
    are on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we ever want a system like this? Just give me my objects on the stack
    already!
  prefs: []
  type: TYPE_NORMAL
- en: A quick break to throw out the trash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember way back in the first chapter when I said Java was easier to learn
    than some languages because it helps us manage the memory? Well, this whole stack
    and heap thing does that for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the VM keeps track of all our objects for us and stores them in
    the heap—a special area of our warehouse. Periodically, the VM will scan the stack,
    or the regular racks of our warehouse, and match references to objects. If it
    finds any objects without a matching reference, it destroys them. In Java terminology,
    it performs garbage collection. Think of a very discriminating refuse vehicle
    driving through the middle of our heap, scanning objects to match to references.
    No reference? You're garbage now! After all, if an object has no reference variable,
    we can't possibly do anything with it anyway. This system of garbage collection
    helps our games run more efficiently by freeing unused memory.
  prefs: []
  type: TYPE_NORMAL
- en: So variables declared in a method are local, on the stack, and only visible
    within the method they were declared. A member variable is on the heap and can
    be referenced from any place where there is a reference to it, provided the access
    specification allows the referencing.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can take a closer look at the variable scope—what can be seen from where.
  prefs: []
  type: TYPE_NORMAL
- en: There are more twists and turns to be learned with regard to variables. In the
    next demo, we will explore all we have learned so far in this chapter and some
    new ideas too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Static variables that are consistent (the same) across every instance of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods of a class where you can use the methods of a class without an
    object of that class type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate the scope of class and local variables, and where they can
    and can't be seen by different parts of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at the `this` keyword, which allows us to write code that refers
    to variables that belong to a specific instance of a class, but without keeping
    track of which instance we are currently using
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is the demo.
  prefs: []
  type: TYPE_NORMAL
- en: Access, scope, this, static, and constructors demo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have looked at the intricate way by which access to variables and their
    scope is controlled, and it would probably serve us well to look at an example
    of them in action. These will not be very practical real-world examples of variable
    use, but more of a demonstration to help understand access modifiers for classes,
    methods, and variables, alongside the different types of variables such as reference
    (or primitive) and local (or instance). Then we will cover the new concepts of
    static and final variables and the `this` keyword. The completed project is in
    the `Chapter6` folder of the code download. It is called `AccessScopeThisAndStatic`.
    We will now perform the following steps to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank activity project and call it `AccessScopeThisAndStatic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the Project Explorer and navigating to **New** | **Class**. Name the new class
    `AlienShip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we declare our new class and some member variables. Note that `numShips`
    is private and static. We will soon see how this variable is the same across all
    instances of the class. The `shieldStrength` variable is `private` and `shipName`
    is `public`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class, as per the rules. In it, we increment
    the private static `numShips` variable. Remember that this will happen each time
    we create a new object of the `AlienShip` type. The constructor also sets a value
    for the `shieldStrength` private variable using the private `setShieldStrength`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the public static getter method that classes outside `AlienShip` can
    use to find out how many `AlienShip` objects are there. We will also see the unusual
    way in which we use static methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows our private `setShieldStrength` method. We could have
    just set `shieldStrength` directly from within the class, but this code shows
    how we can distinguish between the `shieldStrength` local variable/parameter and
    the `shieldStrength` member variable using the `this` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This next method is the getter, so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then checks whether that particular
    object''s `shieldStrength` is zero. If it is zero, it calls the `destroyShip`
    method, which we look at next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will look at the `destroyShip` method for our `AlienShip` class.
    We print a message that indicates which ship has been destroyed, based on its
    `shipName`, as well as increment the `numShips` static variable so that we can
    keep track of the number of objects of the `AlienShip` type we have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All of the code goes in the `onCreate` method after
    the call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Look how we get the value in `numShips`. We use the `getNumShips` method as
    we might expect. However, look closely at the syntax. We are using the class name
    and not an object. We can also access static variables with methods that are not
    static. We did it this way to see a static method in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we assign names to our public `shipName` string variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to assign a value directly to a private variable, it won''t work.
    Therefore, we use the public `getShieldStrength` getter method to print the value
    of `shieldStrength`, which was assigned to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the shield strength of our two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to check whether our static variable `numShips` was changed by the `destroyShip`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Run the demo and look at the console output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output of the preceding blocks of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name using the `this` keyword. We can also use the `this`
    keyword to write code that refers to the current object being acted upon.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a static variable, in this case `numShips`, is consistent across
    all instances. Moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we created.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can use static methods by writing the class name with the
    dot operator instead of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we demonstrated how we could hide and expose certain methods and variables
    using an access specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a quick review of the stack and the heap before we move
    on to something new.
  prefs: []
  type: TYPE_NORMAL
- en: A quick summary on stack and heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at what we learned about the stack and the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't delete objects but the VM sends the garbage collector when it thinks
    it is appropriate. This is usually done when there is no active reference to the
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables and methods are on the stack, and local variables are local
    to the specific method within which they were declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance or class variables are on the heap (with their objects) but the reference
    to the object (address) is a local variable on the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We control what goes inside the stack. We can use the objects on the heap but
    only by referencing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heap is maintained by the garbage collector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object is garbage collected when there is no longer a valid reference to
    it. Therefore, when a reference variable, local or instance, is removed from the
    stack, then its related object becomes viable for garbage collection, and when
    the virtual machine decides the time is right (usually very promptly), it will
    free the RAM memory to avoid running out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we try to reference an object that doesn't exist, we will get a **null pointer
    exception** and the game will crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use other people's hard work by instantiating/creating
    objects from the classes of an API such as that of Android, but this whole OOP
    thing goes even further than that.
  prefs: []
  type: TYPE_NORMAL
- en: What if there is a class that has loads of useful functionality in it but not
    quite what we want? We can inherit from the class and then further refine or add
    to how it works and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single game and demo we looked at. When we use the `extends`
    keyword, we are inheriting, for example, in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are inheriting the `Activity` class along with all its functionality,
    or more specifically, all of the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can override a method and still rely in part on the overridden method in
    the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `Activity` class, but we also called the default implementation
    provided by the class designers when we did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we will also be overriding some more methods of the `Activity`
    class. Specifically, we'll override the methods that handle the lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: If we or the designer of a class wants to force us to inherit before we use
    their class, they can declare a class as **abstract**. Then we cannot make an
    object from it. Therefore, we must extend it first and make an object from the
    subclass. We will do this in our inheritance example and discuss it further when
    we look at polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare a method abstract, and that method must be overridden in
    any class that extends the class with the abstract method. We will do this as
    well in our inheritance example.
  prefs: []
  type: TYPE_NORMAL
- en: In our game projects, we will not be designing any classes that we will be extending.
    We have no need of that in the context of learning about building simple games.
    However, we will be extending classes designed by others in every future game.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend. With this in mind, let's make some simple classes
    and see how we can extend them, just to play around with the syntax as a first
    step, and also to be able to say we have done it. When we look at the last major
    topic of this chapter, polymorphism, we will also dig a little deeper into inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: An example of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have looked at the way we can create hierarchies of classes to model the
    system that fits our game or software project, so let''s try out some simple code
    that uses inheritance. The completed project is in the `Chapter6` folder of the
    code download. It is called `InheritanceExample`. We will now perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create three new classes in the usual way. Call one `AlienShip`, another `Fighter`,
    and the last one `Bomber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for the `AlienShip` class. It is very similar to our previous
    `AlienShip` class demo. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength. The constructor also
    outputs a message to the console so that we can see when it is being used. The
    `AlienShip` class also has a new method, `fireWeapon`, that is declared `abstract`.
    This guarantees that any class that subclasses `AlienShip` must implement their
    own version of `fireWeapon`. Notice that the class has the `abstract` keyword
    as part of its declaration. We have to do this because one of its methods also
    uses the keyword `abstract`. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the superclass with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print the location so that we can see when the `Bomber` constructor
    is being executed. We also implement a `Bomber` class-specific version of the
    abstract `fireWeapon` method because we must do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the superclass with the value of `shieldStrength`.
    We could do further `Fighter` class-specific initialization in this constructor,
    but for now, we just print the location so that we can see when the `Fighter`
    constructor is being executed. We also implement a `Fighter` specific version
    of the abstract `fireWeapon` method because we must do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our code in the `onCreate` method of `MainActivity`. As usual, we enter
    this code after the call to `setContentView`. This is the code that uses our three
    new classes. It looks quite ordinary, but there''s nothing new; it is the output
    that is interesting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the preceding snippets of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the constructor of the subclass can call the constructor of the
    superclass. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As if OOP where not useful enough already! We can now model real-world objects
    and design them to interact with each other. We have also seen how we can make
    OOP even more useful by subclassing/extending/inheriting from other classes. The
    terminology we might like to learn here is that the class that is extended from
    is the **superclass** and the class that inherits from the superclass is the **subclass**.
    We can also call them parent and child classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, we might find ourselves asking this question about inheritance: Why?
    We can write common code once, in the parent class, and we can update that common
    code. All the classes that inherit from it are also updated. Furthermore, a subclass
    only inherits public instance variables and methods. When designed properly, this
    further enhances the goals of encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism roughly means different forms. But what does it mean to us?
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest words possible, any subclass can be used as a part of the code
    that uses the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have an array of animals, we could put any object that is
    of a type that is a subclass of `Animal` in the `Animal` array, perhaps cats and
    dogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can write code that is simpler and easier to understand
    and modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write code for the superclass and rely on the fact that no matter
    how many times it is subclassed, within certain parameters, the code will still
    work. Let''s continue our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also write methods with polymorphic return types and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: So you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we can enforce on our subclasses a set of rules as to what they can
    and cannot do, and also how they should do it. Thus, good design in one stage
    can influence our subclasses at other stages.
  prefs: []
  type: TYPE_NORMAL
- en: If you do suddenly find yourself with a flappy-bird-sized phenomenon, and you
    have a lot of OOP in your code, right from the start, it will be much easier to
    bring in hired help to move the project forward and still maintain control of
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: What if you have an idea for a game with lots of features but you want to get
    a simple version of the game out as soon as possible? Smart, object-oriented design
    would certainly be the solution. It could enable you to write the working bare
    bones of a game and then gradually extend it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, let''s look at another OOP concept: abstract classes. We can now
    get to the bottom of what was going on with that `AlienShip` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An abstract class is a class that cannot be instantiated, or cannot be made
    into an object. We mentioned that `AlienShip` was abstract in the previous example.
    So is it a blueprint that will never be used then? But that's like paying an architect
    to design your home and then never building it! I kind of got the idea of an abstract
    method but this is just silly!
  prefs: []
  type: TYPE_NORMAL
- en: 'It might seem like this at first. We make a class abstract by declaring it
    with the `abstract` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: But why?
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want a class that can be used as a polymorphic type but we need
    to ensure that it can never be used as an object. For example, `Animal` doesn't
    really make sense on its own.
  prefs: []
  type: TYPE_NORMAL
- en: We don't talk about animals; we talk about types of animals. We don't say, "Ooh,
    look at that lovely, fluffy, white animal", or "Yesterday, we went to the pet
    shop and got an animal and an animal bed." It's just too abstract.
  prefs: []
  type: TYPE_NORMAL
- en: So an abstract class is like a template to be used by any class that extends
    it (inherits from it).
  prefs: []
  type: TYPE_NORMAL
- en: We might want a `Worker` class and extend to make classes such as `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    class do? Why would we ever want to instantiate one?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we wouldn't want to instantiate it, but we might want to
    use it as a polymorphic type so that we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of workers.
  prefs: []
  type: TYPE_NORMAL
- en: We call this type of class an abstract class, and when a class has even one
    abstract method, like `AlienShip` did, it must be declared abstract itself. As
    we saw, all abstract methods must be overridden by any class that extends the
    abstract class. This means that the abstract class can provide some of the common
    functionality that would be available in all its subclasses. For example, the
    `Worker` class might have the `height`, `weight`, and `age` member variables.
  prefs: []
  type: TYPE_NORMAL
- en: It might have the `getPayCheck` method, which is the same in all the subclasses,
    and the `doWork` method, which is abstract and must be overridden because all
    the different types of worker do work very differently.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us neatly on to another area of polymorphism that deserves an honorable
    mention because we have been using it in every game so far.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface is like a class. Phew! Nothing complicated here then. However,
    it's like a class that is always abstract and with only abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract too. Okay, so you can just about wrap your head round an abstract class
    because it can at least pass on some functionality in its methods that are not
    abstract and serve as a polymorphic type.
  prefs: []
  type: TYPE_NORMAL
- en: But seriously, this interface seems a bit pointless. Bear with me.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an interface, we type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an interface, we use the `implements` keyword after the class declaration.
    Yes, we already did this for `onClickListener` a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. As long as it implements an
    interface, the whole thing can be passed along as if it is that thing, which it
    is. We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the `onClickListener` interface. Any thing might like to know
    when it is being clicked on; a Button, a TextView, and so on. We don't want different
    `onClick` methods for every type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Android, for games or for more regular GUI-based apps (a bit like
    ours so far), 9 times out of 10, you will be implementing interfaces rather than
    writing your own. However, knowing what is happening is quite important, not so
    much from a point of view of technical awareness, as we have just seen that the
    interface specifies a contract and the compiler enforces it, but more as a matter
    of sanity in knowing what is actually happening when you use the `implements`
    keyword and write a method (or methods) with a name that you didn't choose.
  prefs: []
  type: TYPE_NORMAL
- en: More about OOP and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to write a whole book on OOP, and many authors have already done
    so, but the best way to learn OOP is probably to practice it; practice it *before*
    we have learned all of the theory. Anyway, before we get on with some more practical
    examples, here is one more slightly theoretical OOP example that will leave us
    scratching our heads later if not mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Inner classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we looked at our basic classes demo app, we declared and implemented the
    class in a separate file to our `MainActivity` class. That file had the same name
    as the class.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare and implement a class within a class. The only question
    remaining, of course, is why would we do this? When we implement an inner class,
    the inner class can access the member variables of the enclosing class and the
    enclosing class can access the members of the inner class. We will see this in
    action in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not modeling deep or real-world systems, then inner classes are often
    the way to go. In fact, all the classes we will write ourselves in the rest of
    this book will be extended inner classes. This means that we will extend a type
    to make our own class within our `Activity` class. This makes our code nice and
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Q1) Find out what is wrong with this class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Q2) What is encapsulation?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) I don't get it all, and actually, I have more questions now than I had at
    the start of the chapter. What should I do?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything, then you have succeeded completely. If you just understand
    that OOP is about writing reusable, extendable, and efficient code through encapsulation,
    inheritance, and polymorphism, then you have the potential to be a Java master.
    Simply put, OOP enables us to use other people's hard work even when those people
    were not aware of exactly what we would be doing at the time they did the work.
    All you have to do is keep practicing, so let's make a retro game in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
