- en: Extracting Useful Data from Network Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen in the previous chapter how to access a network device
    using different methods and protocols, then execute commands on the remote device
    to get an output back to Python. Now, it's time to extract some useful data from
    this output.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to use different tools and libraries in Python
    to extract useful data from returned output and act on it using regular expressions.
    Also, we will use a special library called `CiscoConfParse` to audit the configuration,
    then we will learn how to visualize data to generate visually appealing graphs
    and reports using the `matplotlib` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration auditing using `Ciscoconfparse`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing returned data with `matplotlib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tools should be installed and available in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7.1x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm Community or Pro edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EVE-NG lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the full scripts developed in this chapter at the following GitHub
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored different ways to access network devices,
    execute commands, and return output to our terminal. We now need to work on the
    returned output and extract some useful information from it. Notice that, from
    Python's point of view, the output is just a multiline string and Python doesn't
    differentiate between IP address, interface name, or node hostname because they're
    all strings. So, the first step is to design and develop our own parser using
    Python to categorize and differentiate between items based on the important information
    in the returned output.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you can work on the parsed data and generate graphs that help to
    visualize or even store them to persistent and external storage or databases.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions are a language used to match specific occurrences of strings
    by following their pattern across the whole string. When a match is found, the
    resulting matched string will be returned back to user and will be held inside
    a structure in Python format, such as `tuple`, `list`, or `dictionary`. The following
    table summarizes the most common patterns in regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, one of the important rules in regular expressions is you can write your
    own regex and surround it with parentheses `()`, which is called the capturing
    group and helps you to hold important data to reference it later using the capturing
    group number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: PyCharm will automatically color strings written as regular expressions and
    can help you to check the validity of a regex before applying it to data. Make
    sure the Check RegExp intention is enabled in the settings, as shown here:![](../images/00091.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: Creating a regular expression in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can construct a regular expression in Python using the `re` module that
    is natively shipped with the Python installation. There are several methods inside
    this module, such as `search()`, `sub()`, `split()`, `compile()`, and `findall()`,
    which will return the result as a regex object. Here is a summary of the use of
    each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function Name** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `search()` | Search and match the first occurrence of the pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `findall()` | Search and match all occurrences of the pattern and return
    the result as a list. |'
  prefs: []
  type: TYPE_TB
- en: '| `Finditer()` | Search and match all occurrences of the pattern and return
    the result as an iterator. |'
  prefs: []
  type: TYPE_TB
- en: '| `compile()` | Compile the regex into a pattern object that has methods for
    various operations, such as searching for pattern matches or performing string
    substitutions. This is extremely useful if you use the same regex pattern multiple
    times inside your script. |'
  prefs: []
  type: TYPE_TB
- en: '| `sub()` | Used to replace matched pattern with another string. |'
  prefs: []
  type: TYPE_TB
- en: '| `split()` | Used to split on matched pattern and create a list. |'
  prefs: []
  type: TYPE_TB
- en: Regular expressions are hard to read; for that reason, let's start simple and
    look at some easy regular expressions at the most basic level.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of working with the `re` module is to import it inside your Python
    code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will start to explore the most common function in the `re` module, which
    is `search()`, and then we will explore `findall()`. The `search()` function is
    suitable when you need to find only one match in a string or when you write your
    regex pattern to match the entire output and need to get the result with a method
    called `groups()`, as we will see in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `re.search()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, `''regex pattern''`, is the regular expression developed
    in order to match a specific occurrence inside the `''string''`. When a match
    is found, the `search()` function returns a special match object, otherwise it
    will return `None`. Note that `search()` will return the first occurrence only
    of the pattern and will ignore the rest of them. Let''s see a few examples of
    using the `re` module in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1: Searching for a specific IP address**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `re` module is imported into our Python script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a string that corresponds to interface details and contains the name,
    IP address, and status. This string could be hardcoded in the script or generated
    from the network device using the Netmiko library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We passed this string to the `search()` function, along with our regular expression,
    which is just the IP address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the script checks whether there's a `match` object returned from the previous
    operation; if so, it will print it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most basic method of testing for a match is via the `re.match` function,
    as we did in the previous example. The `match` function takes a regular expression
    pattern and a string value.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we're only searching for a specific string inside the `intf_ip` parameter,
    not every IP address pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1 output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 2: Matching the IP address pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `re` module is imported into our Python script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a multi-line string that corresponds to the interface details and contains
    the name, IP address, and status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We passed this string to the `search()` function along with our regular expression,
    which is the IP address pattern constructed using both `\d+`, which matches one
    or more digits, and `\.`, which matches the occurrence of the dot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the script checks whether there's a `match` object returned from a previous
    operation; if so, it will print it. Otherwise, the `None` object is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example 2 output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the `search()` function returns only the first matched occurrence of
    the pattern, not all occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 3: Using** **groups() regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a long output and you need to extract multiple strings from it,
    then you could surround the extracted value with `()` and write your regex inside
    it. This is called a **capturing group** and is used to catch a specific pattern
    within a long string, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `re` module is imported into our Python script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a string that corresponds to an event that occurred in the router and
    is stored in logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We passed this string to the `search()` function along with our regular expression.
    Notice that we enclosed the timestamp, event type, interface name, and the new
    state of the capturing group and wrote our regex inside it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the script checks whether there's a match object returned from the previous
    operation; if so, it will print it, but this time we used `groups()` instead of
    `group()`, as we are capturing multiple strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example 3 output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the returned data is in a structured format called a **tuple**. We could
    use this output later to trigger an event and start, for example, a recovery procedure
    on a redundant interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could enhance our previous code and use a `Named` group to give each capture
    group a name that could be referenced later or used to create a dictionary. In
    this case, we prefixed our regex with `?P<"NAME">` as in the next example (**Example
    4** in the GitHub repository):**Example 4: Named group**![](../images/00095.jpeg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 5-1: Searching for multiple lines using re.search()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have multiple lines in the output and we need to check all of them
    against the regex pattern. Remember that the `search()` function exits when it
    finds the first pattern match. In that case, we have two solutions. The first
    one is to feed each line to the search function by splitting the whole string
    on `"\n"`, and the second solution is to use the `findall()` function. Let''s
    explore the two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script will split the `show ip interface brief` output and search
    for a specific pattern, which is the interface name and the IP address configured
    on it. Based on the matched data, the script will continue to check each IP address
    and validate it using `start with 57`, then the script will print the corresponding
    interface and the full IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 5-1 output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00096.jpeg)If you''re searching only for the first occurrence,
    you can optimize the script and only get the first result by breaking the outer
    `for` loop upon locating the first match, but note that the second match won''t
    be located or printed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 5-2: Searching for multiple lines using re.findall()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findall()` function searches for all non-overlapping matches in the provided
    string and returns a list of strings (unlike the `search` function, which returns
    the `match` object) that matched by regex pattern if there''s no capturing group.
    If you enclosed your regex with a capturing group, then `findall()` will return
    a list of tuples. In the following script, we have the same multi-line output
    and we will use the `findall()` method to get all interfaces that are configured
    with an IP address that starts with 57:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Example 5-2 output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice this time we didn't have to write a `for` loop to check each line against
    the regex pattern. This will be done automatically in the `findall()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration auditing using CiscoConfParse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying regular expressions on network configuration to get specific information
    from the output requires us to write some complex expressions to solve some complex
    use cases. In some cases, you just need to retrieve some configuration or modify
    an existing one without going deeply into writing regular expressions, and that
    was the reason for the birth of the `CiscoConfParse` library ([https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)).
  prefs: []
  type: TYPE_NORMAL
- en: CiscoConfParse library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the official GitHub page says, the library examines an iOS-style config
    and breaks it into a set of linked parent/child relationships. You can perform
    complex queries on these relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00098.jpeg)Source: [https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)'
  prefs: []
  type: TYPE_IMG
- en: So, the first line of the configuration is considered the parent, while the
    subsequent lines are considered the children of the parent. The `CiscoConfparse`
    library builds the relationship between parent and child into an object so the
    end user can easily retrieve the configuration of a specific parent without the
    need to write complex expressions.
  prefs: []
  type: TYPE_NORMAL
- en: It's extremely important that your configuration file is well-formatted in order
    to build the correct relationship between the parent and child.
  prefs: []
  type: TYPE_NORMAL
- en: The same concept also applies if you need to inject configuration into the file.
    The library will search for the given parent and will insert the configuration
    just under it and save it to the new file. This is helpful in case you need to
    run a config audit job on multiple files and make sure they all have a consistent
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Supported vendors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a rule of thumb, any file that has a tab-delimited configuration can be parsed
    by `CiscoConfParse` and it will build the parent and child relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of supported vendors:'
  prefs: []
  type: TYPE_NORMAL
- en: Cisco IOS, Cisco Nexus, Cisco IOS-XR, Cisco IOS-XE, Aironet OS, Cisco ASA, Cisco
    CatOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arista EOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brocade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HP switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force10 switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dell PowerConnect switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extreme Networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterasys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScreenOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, starting from version 1.2.4, `CiscoConfParse` can handle the curly braces
    delimited configuration, which means it can handle the following vendors:'
  prefs: []
  type: TYPE_NORMAL
- en: Juniper Network's Junos OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palo Alto Networks firewall configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F5 Networks configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CiscoConfParse installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CiscoConfParse` can be installed by using `pip` on the Windows command line
    or Linux shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that some additional dependencies are also installed, such as `ipaddr`,
    `dnsPython`, and `colorama`, which are used by `CiscoConfParse`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CiscoConfParse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first example that we will work on is extracting the shutdown interfaces
    from a sample Cisco configuration located in a file named `Cisco_Config.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `CiscoConfParse` module, we imported the `CiscoConfParse` class. Also,
    we imported the `pprint` module to print the output in readable format to fit
    the Python console output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we provided the `config` file full path to the `CiscoConfParse` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final step is to use one of the built-in functions such as `find_parents_w_child()`
    and provide two parameters. The first one is the parent specification, which is
    searching for anything starting with the `interface` keyword, while the child
    specification has the `shutdown` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, in three simple steps, we were able to get all interfaces that
    have the shutdown keyword inside and output as a structured list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1 output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 2: Checking the existing of a specific feature**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example will check whether the router keyword exists within the
    configuration file as an indication of whether a routing protocol, such as `ospf`
    or `bgp` is enabled or not. If the module finds it, then the result will be `True`.
    Otherwise, it will be `False`. This can be achieved by a built-in function within
    a module called `has_line_with()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This method can be used to design a condition inside an `if` statement, as we
    will see in the next and final example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2 output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 3: Printing specific children from a parent**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `CiscoConfParse` module, we imported the `CiscoConfParse` class. Also,
    we imported the `pprint` module to print the output in readable format to fit
    the Python console output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we provided the `config` file full path to the `CiscoConfParse` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used one of the built-in functions, such as `find_all_children()`, and provided
    only the parent. This will instruct the `CiscoConfParse` class to list all configuration
    lines under this parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we iterated over the returned output (remember, it's a list) and checked
    whether the network keyword exists within the string. If yes, then it will append
    it to the network list, which will be printed at the end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example 3 output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''re many other functions available inside the `CiscoConfParse` module
    that could be used to easily extract data from the configuration file and return
    the output in a structured format. Here is a list of other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find_lineage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_lines()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_all_children()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_blocks()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_parent_w_children()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_children_w_parent()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_parent_wo_children()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_children_wo_parent()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing returned data with matplotLib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an old saying goes, *a picture is worth a thousand words*. There's a lot
    of information that could be extracted from the network, such as interface status,
    interface counters, router updates, packets dropped, traffic volume, and more.
    Visualizing this data and putting it into a graph will help you to see the big
    picture of your network. Python has an excellent library called **matplotlib**
    ([https://matplotlib.org/](https://matplotlib.org/)) that is used to generate
    graphs and customize them.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib is capable of creating most kinds of charts, such as line graphs,
    scatter plots, bar charts, pie charts, stack plots, 3D graphs, and geographic
    map graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by first installing the library from PYpI using `pip`. Notice
    some additional packages will be installed along with matplotlib, such as `numpy`
    and `six`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, try to import `matplotlib` and, if no errors are printed, then the module
    is successfully imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hands-on with matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with simple examples to explore matplotlib''s functionality.
    The first thing we do usually is import `matplotlib` into our Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we imported `pyplot` as a short name, `plt`, to be used inside our script.
    Now, we will use the `plot()` method inside it to plot our data, which consists
    of two lists. The first list represents the values of the *x*-axis while the second
    list represents the values of the *y*-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, the values are dropped into the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to show that plot as a window using the `show()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00108.jpeg)You may need to install `Python-tk` in Ubuntu in order
    to view the graph. Use `apt install Python-tk`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulted graph will show a line representing the input values of the x
    and y axes. In the window, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the graph around with the cross icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize the graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom into a specific area with the zoom icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset to the original view with the home icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the figure with the save icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can customize the generated figure by adding a title to it and labels to
    both axes. Also, add a legend that explains the meaning of each line in case there
    are multiple lines on the same graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00109.jpeg)Notice that we usually don''t hardcode the plotted
    values inside the Python script, but we will get them externally from the network,
    as we will see in the next example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can plot multiple datasets on the same figure. You can add another
    list that represents data to the previous figure and `matplotlib` will draw it.
    Also, you can add labels to differentiate between the datasets on the graph. The
    legend for these labels will be printed on the graph using the `legend()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing SNMP using matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this use case, we will utilize the `pysnmp` module to send SNMP `GET` requests
    to our router, retrieve the input and output traffic rates for a specific interface,
    and visualize the output using the `matplotlib` library. The OIDs used are `.1.3.6.1.4.1.9.2.2.1.1.6`
    and `.1.3.6.1.4.1.9.2.2.1.1.8`, which represent the input and output rates respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported `cmdgen` from the `pysnmp` module, which was used to create SNMP
    `GET` commands for the router. We also imported the `matplotlib` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used `cmdgen` to define the transport channel properties between Python
    and the router and provide the SNMP community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pysnmp` will start to send the SNMP GET requests with the provided OIDs and
    return the output and errors (if any) to `errorIndication`, `errorStatus`, `errorIndex`,
    and `varBinds`. We are interested in `varBinds` as it holds the actual values
    for the input and output traffic rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `varBinds` will be in the form of `<oid> = <value>`, so we extracted
    only the value and added it to the corresponding list we created before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This operation will be repeated 100 times at 6-second intervals to collect useful
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we provided the collected data to the `plt` imported from `matplotlib`
    and customized the graph by providing the `xlabel`, `ylabel`, title, and `legends`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use different tools and techniques inside
    Python to extract useful data from returned output and act upon it. Also, we used
    a special library called `CiscoConfParse` to audit the configuration and learned
    how to visualize data to generate appealing graphs and reports.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to write a template and use it to generate
    configurations with a Jinja2 templating language.
  prefs: []
  type: TYPE_NORMAL
