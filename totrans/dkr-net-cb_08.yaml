- en: Chapter 8. Working with Flannel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Flannel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Flannel with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the VXLAN backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the host gateway backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying Flannel options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flannel is a third-party network solution for Docker that was developed by the
    team at **CoreOS**. Flannel was one of the earlier projects that aimed to give
    each container a uniquely routable IP address. This removes the requirement for
    inter-host container-to-container communication to use published ports. Much like
    some of the other solutions we've reviewed, Flannel uses a key-value store to
    keep track of allocations and various other configuration settings. However, unlike
    Weave, Flannel offers no direct integration with the Docker service offering no
    plugin. Rather, Flannel relies on you telling Docker to use the Flannel network
    to provision containers. In this chapter, we'll walk through how to install Flannel
    as well as walk through its various configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Flannel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll walk through the installation of Flannel. Flannel requires
    the installation of a key store and Flannel service. Due to the dependencies of
    each of these, they need to be configured as actual services on the Docker hosts.
    To do this, we'll leverage `systemd` unit files to define each respective service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll be using the same lab topology we used in [Chapter
    3](ch03.html "Chapter 3. User-Defined Networks"), *User-Defined Networks*, where
    we discussed user-defined overlay networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/B05453_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll need a couple of hosts, preferably with some of them being on different
    subnets. It is assumed that the Docker hosts used in this lab are in their default
    configuration. In some cases, the changes we make may require you to have root-level
    access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, Flannel relies on a key-value store to provide information to
    all the nodes participating in the Flannel network. In other examples, we've run
    a container-based key-value store such as Consul to provide this functionality.
    Since Flannel was built by CoreOS, we'll be leveraging their key-value store named
    `etcd`. And while `etcd` is offered in a container format, we can't easily use
    the container-based version due to some of the prerequisites required for Flannel
    to work. That being said, we'll be downloading the binaries for both `etcd` and
    Flannel and running them as services on our hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `etcd` since it''s a perquisite for Flannel. The first thing
    you need to do is download the code. In this example, we''ll be leveraging `etcd`
    version 3.0.12 and running the key-value store on the host `docker1`. To download
    the binary, we''ll run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded, we can extract the binaries from the archive using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can move the binaries we need into the correct location to make
    them executable. In this case, the location is `/usr/bin` and the binaries we
    want are the `etcd` service itself as well as its command-line tool named `etcdctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the pieces in place, the last thing we need to do is to
    create a service on the system that will take care of running `etcd`. Since our
    version of Ubuntu is using `systemd`, we''ll need to create a unit file for the
    `etcd` service. To create the service definition, you can create a service unit
    file in the `/lib/systemd/system/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create a service definition to run `etcd`. An example unit file
    for the `etcd` service is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that `systemd` can be configured in many different ways based on
    your requirements. The unit file given earlier demonstrates one way to configure
    `etcd` as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the unit file is in place, we can reload `systemd` and then enable and
    start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason the service doesn''t start or stay started, you can check
    the status of the service by using the `systemctl status etcd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Later on, if you're having issues with Flannel-enabled nodes being able to talk
    to `etcd`, check and make sure that `etcd` is allowing access on all interfaces
    (`0.0.0.0`) as shown in the preceding bolded output. This is defined in the sample
    unit file provided, but if not defined, `etcd` will default to only listen on
    the local loopback interface (`127.0.0.1`). This will prevent remote servers from
    accessing the service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the key-value store configuration is being done explicitly to demonstrate
    Flannel, we won't be covering the basics of key-value stores. These configuration
    options are enough to get you up and running on a single node and are not intended
    to be used in a production environment. Please make sure that you understand how
    `etcd` works before using it in a production setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `etcd` service is started, we can then use the `etcdctl` command-line
    tool to configure some of the base settings in Flannel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We'll discuss these configuration options in a later recipe, but for now, just
    know that the subnet we defined as the `Network` parameter defines the Flannel
    global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `etcd` configured, we can focus on configuring Flannel itself.
    The configuration of Flannel as a service on the system is very similar to what
    we just did for `etcd`. The major difference is that we''ll be doing this same
    configuration on all four lab hosts, whereas the key-value store was only configured
    on a single host. We''ll show the installation of Flannel on a single host, `docker4`,
    but you''ll need to repeat these steps on each host in your lab environment that
    you wish to be a member of the Flannel network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll download the Flannel binary. In this example, we''ll be using
    version 0.5.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to extract the files from the archive and move the `flanneld`
    binary to the correct location. Note that there is no command-line tool to interact
    with Flannel as there was with `etcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `etcd`, we want to define a `systemd` unit file so that we can run
    `flanneld` as a service on each host. To create the service definition, you can
    create another service unit file in the `/lib/systemd/system/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create a service definition to run `etcd`. An example unit file
    for the `etcd` service is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the unit file is in pace, we can reload `systemd` and then enable and
    start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If, for some reason, the service doesn''t start or stay started, you can check
    the status of the service using the `systemctl status flanneld` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see similar output in your log indicating that Flannel found a lease
    within the global scope allocation you configured in `etcd`. These leases are
    local to each host and I often refer to them as local scopes or networks. The
    next step is to complete this configuration on the remaining hosts. By checking
    the Flannel log on each host, I can tell what subnets were allocated to each host.
    In my case, this is what I ended up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker1`: `10.100.93.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker2`: `10.100.58.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker3`: `10.100.90.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker4`: `10.100.15.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, Flannel is fully configured. In the next recipe, we'll discuss
    how to configure Docker to consume the Flannel network.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Flannel with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, there is currently no direct integration between Flannel
    and Docker. That being said, we'll need to find a way to get the containers onto
    the Flannel network without Docker directly knowing that's what's happening. In
    this recipe, we'll show how this is done, discuss some of the perquisites that
    led to our current configuration, and see how Flannel handles host-to-host communication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is assumed that you're building off the lab described in the previous recipe.
    In some cases the changes we make may require you to have root-level access to
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous recipe, we configured Flannel, but we didn''t examine what
    the Flannel configuration actually did from a network perspective. Let''s take
    a quick look at the configuration of one of our Flannel-enabled hosts to see what''s
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note the addition of a new interface named `flannel0`. You''ll also
    note that it has an IP address within the `/24` local scope that was assigned
    to this host. If we dig a little deeper, we can use `ethtool` to determine that
    this interface is a virtual `tun` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Flannel creates this interface on each host where the Flannel service is running.
    Note that the subnet mask of the `flannel0` interface is a `/16`, which covers
    the entire global scope allocation we defined in `etcd`. Despite allocating the
    host a `/24` scope, the host believes that the entire `/16` is reachable through
    the `flannel0` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the interface present creates this route, which ensures that traffic
    headed to any of the assigned local scopes on other hosts goes through the `flannel0`
    interface. We can prove that this works by pinging the other `flannel0` interfaces
    on the other hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the physical network has no knowledge of the `10.100.0.0/16` network
    space, Flannel must encapsulate the traffic as it traverses the physical network.
    In order to do this, it needs to know what physical Docker host has a given scope
    assigned to it. Recall from the Flannel logs we examined in the previous recipe
    that Flannel chose an external interface for each host based on the host''s default
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This information, along with the scope assigned to each host, is registered
    in the key-value store. Using this information, Flannel can determine which host
    has which scope assigned and can use the external interface of that host as a
    destination to send the encapsulated traffic towards.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flannel supports multiple backends or transport mechanisms. By default, it encapsulates
    traffic in UDP on port `8285`. In the upcoming recipes, we'll discuss other backend
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how Flannel works, we need to sort out how to get the actual
    Docker containers onto the Flannel network. The easiest way to do this is to have
    Docker use the assigned scope as the subnet for the `docker0` bridge. Flannel
    writes the scope information out to a file saved in `/run/flannel/subnet.env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this information, we can configure Docker to use the correct subnet for
    its bridge interface. Flannel offers two ways to do this. The first involves generating
    a new Docker configuration file using a script that was included along with the
    Flannel binary. The script allows you to output a new Docker configuration file
    that uses the information from the `subnet.env` file. For example, we can use
    the script to generate a new configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In systems that don''t leverage `systemd` Docker will, in most cases, automatically
    check the file `/etc/default/docker` for service-level options. This means that
    we could simply have Flannel write the earlier-mentioned configuration file out
    to `/etc/default/docker`, which will allow Docker to consume the new settings
    when the service reloads. However, since our system uses `systemd`, this method
    would require updating our Docker drop-in file (`/etc/systemd/system/docker.service.d/docker.conf`)
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The bolded lines indicate that the service should check the file `etc/default/docker`
    and then load the variable `$DOCKER_OPTS` to be passed to the service at runtime.
    If you use this method, it might be wise to define all your service-level options
    in `etc/default/docker` for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be noted that this first approach relies on running the script to
    generate the configuration file. If you are running the script manually to generate
    the file, there's a chance that the configuration file will get out of date if
    the Flannel configuration changes. The second approach shown later is more dynamic
    since the `/run/flannel/subnet.env` file is updated by the Flannel service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the first approach certainly works, I prefer to use a slightly different
    method where I just load the variables from the `/run/flannel/subnet.env` file
    and consume them within the drop-in file. To do this, we change our Docker drop-in
    file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying `/run/flannel/subnet.env` as an `EnvironmentFile`, we make the
    variables defined in the file available for consumption within the service definition.
    Then, we just use them as options to pass to the service when it starts. If we
    make these changes on our Docker host, reload the `systemd` configuration, and
    restart the Docker service, we should see that our `docker0` interface now reflects
    the Flannel subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also manually update the Docker service-level parameters yourself based
    on the Flannel configuration. Just make sure that you use the information from
    the `/run/flannel/subnet.env` file. Regardless of which method you choose, make
    sure that the `docker0` bridge is using the configuration specified by Flannel
    on all four of the Docker hosts. Our topology should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/B05453_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since each Docker host only uses the Flannel-assigned scope for its subnet,
    each host believes the remaining subnets included in the global Flannel network
    are still reachable through the `flannel0` interface. Only the specific `/24`
    for the assigned local scope is reachable through the `docker0` bridge locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the operation of Flannel at this point by running two different
    containers on two different hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now reach the services running on each container directly by IP address.
    First, find the IP address of one of the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, access the service from the second container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Connectivity is working as expected. Now that we have the entire Flannel configuration
    working with Docker, it's important to call out the order in which we did things.
    Other solutions we've looked at were able to containerize certain pieces of their
    solution. For instance, Weave was able to offer their services in a container
    format rather than requiring local services as we did with Flannel. With Flannel,
    each component has a perquisite in order to work.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we need the `etcd` service running before Flannel will register.
    That by itself is not a huge concern and, if both `etcd` and Flannel ran in containers,
    you could solve that piece pretty easily. However, since the changes Docker needs
    to make to its bridge IP address are done at the service level, Docker needs to
    know about the Flannel scope before starting. This means that we can't run the
    `etcd` and Flannel services inside Docker containers because we can't start Docker
    without the information that Flannel generates based on reading keys from `etcd`.
    In this case, the prerequisites for each component are important to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When running Flannel in CoreOS, they are able to run these components in containers.
    The solution for this is detailed in their documentation at this line under the
    *under the hood* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://coreos.com/flannel/docs/latest/flannel-config.html](https://coreos.com/flannel/docs/latest/flannel-config.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the VXLAN backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, Flannel supports multiple different backend configurations.
    A backend is considered to be the means by which Flannel passes traffic between
    Flannel-enabled hosts. By default, this is done through UDP as we saw in the previous
    recipe. However, Flannel also supports VXLAN. The advantage to using VXLAN over
    UDP is that newer hosts support VXLAN in the kernel. In this recipe, we'll demonstrate
    how to change the Flannel backend type to VXLAN.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is assumed that you're building off the lab described in the previous recipes
    in this chapter. You'll need Flannel-enabled hosts that are integrated with Docker
    as described in the first two recipes of this chapter. In some cases, the changes
    we make may require you to have root-level access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type of backend you wish to use is defined when you first instantiate your
    network within `etcd`. Since we didn''t specify a type when we defined the network
    `10.100.0.0/16`, Flannel defaulted to using the UDP backend. This can be changed
    by updating the configuration we initially set in `etcd`. Recall that our Flannel
    network was first defined with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we used the `mk` command of `etcdctl` to make the key. If we wanted
    to change the backend type to VXLAN, we could run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, since we''re updating the object, we now use the `set` command in
    place of `mk`. While sometimes hard to see when in plain text form, the properly
    formatted JSON that we''re passing to `etcd` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines the type of this backend to be VXLAN. While the preceding configuration
    by itself would be sufficient to change the backend type, there are sometimes
    additional parameters that we can specify as part of the backend. For instance,
    when defining the type as VXLAN, we can also specify a **VXLAN Identifier** (**VNI**)
    and a UDP port. If not specified, the VNI defaults to `1` and the port defaults
    to the `8472`. For the sake of demonstration, we''ll apply the defaults as part
    of our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This in properly formatted JSON looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the command the local `etcd` instances configuration will be updated.
    We can verify that `etcd` has the proper configuration by querying `etcd` through
    the `etcdctl` command-line tool. To read the configuration, we can use the `etcdctl
    get` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we''ve successfully updated `etcd`, the Flannel services on each node
    will not act on this new configuration. This is because the Flannel service on
    each host only reads these variables when the service starts. In order for this
    change to take effect, we need to restart the Flannel service on each node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you restart the Flannel service on each host. Hosts will not
    be able to communicate if some are using the VXLAN backend and others are using
    the UDP backend. Once restarted, we can check our Docker host''s interfaces once
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the host now has a new interface named `flannel.1`. If
    we check the interface with `ethtool`, we can see that it is using the VXLAN driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should still be able to access the services using the Flannel IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you were to specify a different VNI, the Flannel interface would be defined
    as `flannel.<VNI number>`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that Flannel does not take care of cleaning up artifacts
    from older configurations. For instance, if you change the VXLAN ID in `etcd`
    and restart the Flannel service, you will end up with two interfaces on the same
    network. You'll want to manually delete the old interface that was named using
    the old VNI. In addition, if you change the subnet allocated to Flannel, you'll
    want to restart the Docker service after you restart the Flannel service. Recall
    that Docker reads configuration variables from Flannel when the Docker service
    loads. If those change you'll need to reload the configuration for them to take
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Using the host gateway backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen already, Flannel supports two types of overlay network. Using
    either UDP or VXLAN encapsulation, Flannel can build an overlay network between
    Docker hosts. The obvious advantage to this is that you can provision networks
    across disparate Docker nodes without having to touch the physical underlay network.
    However, some types of overlay networks also introduce a significant performance
    penalty, especially for processes that perform encapsulation in user space. Host
    gateway mode aims to solve that problem by not using an overlay network. This,
    however, comes with its own limitations. In this recipe, we'll review what host
    gateway mode can provide as well as show how to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be slightly modifying the lab we''ve been using up until
    this point. The lab topology will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/B05453_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the hosts `docker3` and `docker4` now have IP addresses on the
    same subnet as `docker1` and `docker2`. That is, all of the hosts are now layer
    2 adjacent to each other and can talk directly without the need to route through
    a gateway. Once you have your hosts reconfigured in this topology, we''ll want
    to wipe the Flannel configuration. To do that, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the host running the `etcd` service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'On all of the hosts running the Flannel service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll note that we passed the `systemctl` command with the `--no-block` parameter
    when we started `flanneld`. Since we deleted the Flannel configuration from `etcd`,
    the Flannel service is searching for configuration to use for initialization.
    Due to the way the service is defined (as type notify), passing this parameter
    is required to prevent the command from hanging on the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, your Flannel nodes will be searching for their configuration.
    Since we deleted the `etcd` data store, the key that tells the Flannel nodes how
    to configure the service is currently missing, and the Flannel service will continue
    to poll the `etcd` host until we make the appropriate configuration. We can verify
    this by checking the logs on one of the hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that at this point Flannel has already decided what
    its external endpoint IP address will be by seeing which interface supports the
    default route for the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since that happens to be `eth0`, Flannel picks that interface''s IP address
    as its external address. To configure host gateway mode, we can put the following
    configuration into `etcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen before, we still specify a network. The only difference is that
    we supply a `type` of `host-gw`. The command to insert this into `etcd` looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After we insert this configuration, the Flannel nodes should all pick up the
    new configuration. Let''s examine the service logs for Flannel on the host `docker4`
    to verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `journalctl` command is useful for seeing all the logs related to a service
    being managed by `systemd`. In the preceding example, we passed the `-r` parameter
    to show the logs in reverse order ( the most current on top). We also passed the
    `-u` parameter to specify which service we want to see the logs for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The oldest log entry we see is this host''s Flannel service picking and registering
    a scope within the `10.100.0.0/16` subnet. This works in the same manner as it
    did with both the UDP and the VXLAN backend. The next three log entries show Flannel
    detecting the registrations of the other three Flannel nodes scopes. Since `etcd`
    is tracking each Flannel node''s external IP address, as well as their registered
    scope, all of the Flannel hosts now know what external IP address can be used
    to reach each registered Flannel scope. In overlay mode (UDP or VXLAN), this external
    IP address was used as the destination for encapsulated traffic. In host gateway
    mode, this external IP address is used as route destination. If we inspect the
    routing table, we can see a route entry for each host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this configuration, Flannel simply relies on basic routing to provide reachability
    to all the Flannel registered scopes. In this case, the host `docker4` has routes
    to all the other Docker hosts in order to reach their Flannel network scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/B05453_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not only is this far less complex than dealing with overlay networks, but it
    can also be much more performant than requiring each host to do encapsulation
    for the overlay network. The downside of this approach is that each host needs
    to have an interface on the same network in order for this to work. If the hosts
    are not on the same network, Flannel cannot add these routes because it would
    require the upstream network device (the host's default gateway) to also have
    routing information about how to reach the remote host. And while the Flannel
    node can point a static route at its default gateway, the physical network has
    no knowledge of the `10.100.0.0/16` network and will fail to deliver the traffic.
    The net effect is that host gateway mode limits the location of where you can
    place Flannel-enabled Docker hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's important to point out that Flannel may have changed state after
    the Docker service was already running. If that's the case, you'll want to restart
    Docker to make sure that it picks up the new variables from Flannel. If you rebooted
    your hosts when you reconfigured their network interfaces, you probably just need
    to start the Docker service. The service likely failed to load when the system
    booted because of the lack of Flannel configuration information which should now
    be present.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flannel also has backends for various cloud providers such as GCE and AWS. You
    can view their documentation to find more specific information about those backend
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Flannel options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to configuring different backend types you can also specify other
    options both through `etcd` as well as through the Flannel client itself. These
    options allow you to limit the IP allocation scopes as well as specify a specific
    interface to use as a Flannel node's external IP endpoint. In this recipe, we'll
    review the additional configuration options available to you both locally and
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will keep building off the lab in the previous chapter where we configured
    the host gateway backend. However, the lab topology is going to revert to the
    previous configuration with Docker hosts `docker3` and `docker4` being in the
    `192.168.50.0/24` subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/B05453_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have your hosts configured in this topology, we''ll want to wipe out
    the Flannel configuration. To do that, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the host running the `etcd` service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On all the hosts running the Flannel service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, the changes we make may require you to have root-level access
    to the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous recipes showed several examples of how to specify an overall Flannel
    network or global scope as well change the backend network type. We also saw some
    backend network types allowed for additional configuration options. In addition
    to the options we''ve seen, we can also configure other parameters globally that
    dictate how Flannel works overall. There are three other main parameters that
    can influence the scopes assigned to the Flannel nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SubnetLen`: This parameter is specified in the form of an integer and dictates
    the size of the scope assigned to each node. As we''ve seen, this defaults to
    a `/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubnetMin`: This parameter is specified in the form of a string and dictates
    the beginning IP range in which the scope allocations should begin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubnetMax`: This parameter is specified in the form of a string and dictates
    the end of the IP range at which the subnet allocation should end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using these options in combination with the `Network` flag gives us quite a
    bit of flexibility when we assign networks. For instance, let''s use this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines that each Flannel node should get a scope allocation of a `/25`,
    the first subnet should start at `10.100.0.0`, and the last subnet should end
    at `10.100.1.0`. You might have noticed that, in this case, we only have space
    for three subnets within that allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.100.0.0/25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10.100.0.128./25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10.100.1.0/25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This was done intentionally to show what happens when Flannel runs out of space
    in the global scope. Let''s now put this configuration in `etcd` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once in place, you should see that the majority of the hosts receive local
    scope allocations. However, if we check our hosts, we''ll see that one has failed
    to receive an allocation. In my case, that''s the host `docker4`. We can see this
    within the Flannel services logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Since we only allowed space for three allocations in the global scope, the fourth
    host is unable to receive a local scope and will continue to request one until
    one becomes available. This could be remedied by updating the `SubnetMax` parameter
    to `10.100.1.128` and restarting the Flannel service on the host that failed to
    receive a local scope allocation.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned, there are also configuration parameters that we can pass to
    the Flannel service on each host.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Flannel client supports a variety of parameters, all of which can be viewed
    by running `flanneld --help`. These cover new and upcoming features as well as
    configurations related to SSL-based communication, which will be important to
    review when running these types of services on infrastructure you don't control.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a network perspective, perhaps the most valuable configuration option
    would be the `--iface` parameter, which allows you to specify which host interface
    you wish to use as Flannel''s external endpoint. To view the importance of this,
    let''s look at a quick example of our multihost lab topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/B05453_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you recall, in host gateway mode Flannel requires that all the Flannel nodes
    be layer 2 adjacent or on the same network. In this case, there are two hosts
    on the `10.10.10.0/24` network on the left and two hosts on the `192.168.50.0/24`
    network on the right. In order to talk to each other, they need to route through
    the multilayer switch. A scenario like this typically calls for an overlay backend
    mode that would tunnel the container traffic across the multilayer switch. However,
    if host gateway mode is a requirement for performance or other reasons, you might
    still be able to use it if you can provide additional interfaces to your hosts.
    For instance, imagine that these hosts were really virtual machines, and it was
    relatively easy for us to provision another interface on each host, call it `eth1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/B05453_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This interface could be dedicated to Flannel traffic allowing each host to
    still be layer 2 adjacent for the sake of Flannel traffic while still maintaining
    their existing default route through `eth0`. However, just provisioning the interface
    is not enough. Recall that Flannel by default picks its external endpoint interface
    by referencing the default route of the host. Since the default route is unchanged
    in this model, Flannel will be unable to add the appropriate routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since Flannel is still using the `eth0` interface as its external endpoint IP
    address, it knows that the hosts on the other subnet aren't directly reachable.
    We can fix this by telling Flannel to use the `eth1` interface by passing the
    `--iface` option to the Flannel service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can change the Flannel configuration by updating the Flannel
    service definition (`/lib/systemd/system/flanneld.service`) to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With this configuration, Flannel will use the `eth1` interface for its external
    endpoint, allowing all the hosts to communicate directly across the `10.11.12.0/24`
    network. You can then load the new configuration by reloading the `systemd` configuration
    and restarting the service on all hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that Flannel uses the external endpoint IP address to keep track
    of Flannel nodes. Changing this means that Flannel will allocate a new scope to
    each Flannel node. It''s best to configure these options before joining a Flannel
    node. In our case, since `etcd` is already configured, we''ll want to once again
    delete the existing `etcd` configuration and reconfigure it in order for the scope
    to become available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check a host, you should now see that it has three Flannel routes—one
    for each assigned scope of the other three hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In addition, if you'll be using Flannel through NAT, you might also want to
    look at the `--public-ip` option, which allows you to define a node's public IP
    address. This is particularly relevant in cloud environments where the server's
    real IP address may be hidden behind NAT.
  prefs: []
  type: TYPE_NORMAL
