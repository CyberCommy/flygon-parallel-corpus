- en: Chapter 2. Statements and Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing python script and module files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing long lines of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including descriptions and documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better RST markup in docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing complex if...elif chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a while statement which terminates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding a potential problem with break statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the exception matching rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoiding a potential problem with an except: clause'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining exceptions with the raise from statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a context using the with statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python syntax is designed to be very simple. There are a few rules; we'll look
    at some of the interesting statements in the language as a way to understand those
    rules. Just looking at the rules without concrete examples can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover some basics of creating script files first. Then we''ll move on
    to looking at some of the more commonly-used statements. Python only has about
    twenty or so different kinds of imperative statements in the language. We''ve
    already looked at two kinds of statements in [Chapter 1](text00014.html#page "Chapter 1. Numbers,
    Strings, and Tuples") , *Numbers, Strings, and Tuples* : the assignment statement
    and the expression statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're actually executing a statement that contains only the evaluation of a
    function, `print()` . This kind of statement—where we evaluate a function or a
    method of an object—is common.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other kind of statement we''ve already seen is the assignment statement.
    Python has many variations on this theme. Most of the time, we''re assigning a
    single value to a single variable. Sometimes, however, we might be assigning two
    variables at the same time, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These recipes will look at some of the more complex statements, including `if`
    , `while` , `for` , `try` , `with` , and `raise` . We'll touch on a few others
    as we explore the different recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing Python script and module files – syntax basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to write Python script files in order to do anything truly useful.
    We can experiment with the language at the interaction `>>>` prompt. For real
    work, however, we'll need to create files. The whole point of writing software
    is to create repeatable processing for our data.
  prefs: []
  type: TYPE_NORMAL
- en: How can we avoid syntax errors and be sure our code matches what's in common
    use? We need to look at some common aspects of *style* —how we use whitespace
    to clarify our programming.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at a number of more technical considerations. For example, we
    need to be sure to save our files in the UTF-8 encoding. While ASCII encoding
    is still supported by Python, it's a poor choice for modern programming. We'll
    also need to be sure to use spaces instead of tabs. If we use Unix newlines as
    much as possible, we'll also find things are slightly simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Most text editing tools will work properly with Unix (newline) line endings
    as well as Windows or DOS (return-newline) line endings. Any tool that can't work
    with both kinds of line endings should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To edit Python scripts, we'll need a good programming text editor. Python comes
    with a handy editor, IDLE. It works pretty well. It lets us jump back and forth
    between a file and an interactive `>>>` prompt, but it's not a great programming
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens and dozens of good programming editors. It's nearly impossible
    to suggest just one. So we'll suggest a few.
  prefs: []
  type: TYPE_NORMAL
- en: ActiveState has Komodo IDE, which is very sophisticated. The Komodo Edit version
    is free, and does some of the same things as the full Komodo IDE. This runs on
    all common OS's; it's a good first choice because it's consistent no matter where
    we're writing code.
  prefs: []
  type: TYPE_NORMAL
- en: See [http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/) .
  prefs: []
  type: TYPE_NORMAL
- en: Notepad++ is good for Windows developers. See [https://notepad-plus-plus.org](https://notepad-plus-plus.org)
    .
  prefs: []
  type: TYPE_NORMAL
- en: BBEdit is very nice for Mac OS X developers. See [http://www.barebones.com/products/bbedit/](http://www.barebones.com/products/bbedit/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: For Linux developers, there are several built-in editors, including VIM, gedit,
    or Kate. These are all good. Since Linux tends to be biased toward developers,
    the editors available are all suitable for writing Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s important is that we''ll often have two windows open while we''re working:'
  prefs: []
  type: TYPE_NORMAL
- en: The script or file that we're working on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's `>>>` prompt (perhaps from a shell or perhaps from IDLE) where we can
    try things out to see what works and what doesn't. We may be creating our script
    in Notepad++, but using IDLE to experiment with data structures and algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We actually have two recipes here. First, we need to set some defaults for our
    editor. Then, once the editor is set up properly, we can create a generic template
    for our script files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we'll look at the general setup that we need to do in our editor of choice.
    We'll use Komodo examples, but the basic principles apply to all editors. Once
    we've set the edit preferences, we can create our script file.
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor of choice. Look at the preferences page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the settings for preferred file encoding. With Komodo Edit Preferences,
    it's on the **Internationalization** tab. Set this to **UTF-8** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the settings for indentation. If there's a way to use spaces instead of
    tabs, check this option. With Komodo Edit, we actually do this backwards—we uncheck
    **prefer spaces over tabs** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rule is this: we want *spaces* ; we do not want *tabs* .'
  prefs: []
  type: TYPE_NORMAL
- en: Also, set the spaces per indent to be four. That's typical for Python code.
    It allows us to have several levels of indentation and still keep the code fairly
    narrow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''re sure that our files will be saved in UTF-8 encoding, and we''re
    also sure we''re using spaces instead of tabs, we can create an example script
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of most Python script files should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This sets an association between the file you're writing and Python.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows, the file name to program association is done through a setting
    in one of the Windows control panels. Within the **Default Programs** control
    panel, there's a panel to **Set Associations** . This control panel shows that
    `.py` files are bound to the Python program. This is normally set by the installer,
    and we rarely need to change it or set it manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows developers can include the preamble line anyway. It will make Mac OS
    X and Linux folks happy when they download the project from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: After the preamble, there should be a triple-quoted block of text. This is the
    documentation string (called a **docstring** ) for the file we're going to create.
    It's not technically mandatory, but it's essential for explaining what a file
    contains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because Python triple-quoted strings can be indefinitely long, feel free to
    write as much as necessary. This should be the primary vehicle for describing
    the script or library module. This can even include examples of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the interesting part of the script: the part that really does something.
    We can write all the statements we need to get the job done. For now, we''ll use
    this as a placeholder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this, our script does something. In other recipes we'll look at a number
    of other statements for doing things. It's common to create function and class
    definitions, as well as write statements to use the functions and classes to do
    things.
  prefs: []
  type: TYPE_NORMAL
- en: At the top level of our scripts, all of the statements must begin at the left
    margin and must be complete on a single line. There are some complex statements
    which will have blocks of statements nested inside them. These internal blocks
    of statements must be indented. Generally—because we set indentation to four spaces—we
    can hit the *Tab* key to indent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike other languages, there's very little *boilerplate* in Python. There's
    only one line of *overhead* and even the `#!/usr/bin/env python3` line is generally
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we set the encoding to UTF-8? The entire language is designed to work
    using just the original 128 ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: We often find that ASCII is limiting. It's easier to set our editor to use UTF-8
    encoding. With this setting, we can simply use any character that makes sense.
    We can use characters like `µ` as Python variables if we save our programs in
    UTF-8 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is legal Python if we save our file in UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to be consistent when choosing between spaces and tabs in Python.
    They are both more or less invisible, and mixing them can easily lead to confusion.
    Spaces are suggested.
  prefs: []
  type: TYPE_NORMAL
- en: When we set up our editor to use a four-space indent, we can then use the button
    labeled Tab on our keyboard to insert four spaces. Our code will align properly,
    and the indentation will show how our statements nest inside each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial `#!` line is a comment: everything between a `#` and the end of
    the line is ignored. OS shell programs like **bash** and **ksh** look at the first
    line of a file to see what the file contains. The first few bytes are sometimes
    called *magic* because the shell is peeking at them. Shell programs look for the
    two-character sequence of `#!` to identify the program responsible for this data.
    We prefer to use `/usr/bin/env` to start the Python program for us. We can leverage
    this to make Python-specific environment settings via the `env` program.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Python Standard Library* documents are derived, in part, from the documentation
    strings present in the module files. It's common practice to write sophisticated
    docstrings in modules. There are tools like Pydoc and Sphinx that can reformat
    the module docstrings into elegant documentation. We'll look at this in separate
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, unit test cases can be included in the docstrings. Tools like
    **doctest** can extract examples from the document string and execute the code
    to see if the answers in the documentation match the answers found by running
    the code. Most of this book is validated with doctest.
  prefs: []
  type: TYPE_NORMAL
- en: The triple-quoted documentation strings are preferred over the `#` comments.
    The text between `#` and the end of the line is ignored, and counts as a comment.
    Since this is limited to a single line, it is used sparingly. A docstring can
    be of indefinite size; they are used widely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 3.5, we''ll sometimes see this kind of thing in a script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `# type: float` comment can be used by a type inferencing system to establish
    that the various data types can occur when the program is actually executed. For
    more information on this, see **Python Enhancement Proposal 484** : [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: There's another bit of overhead that's sometimes included in a file. The VIM
    editor lets us keep edit preferences in the file. This is called a **modeline**
    . We often have to enable modelines by including the `set modeline` setting in
    our `~/.vimrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've enabled modelines, we can include a special `# vim` comment at the
    end of our file to configure VIM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical modeline that''s useful for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This sets the Unicode `u+0009` TAB characters to be transformed to eight spaces
    when we hit the *Tab* key, we'll shift four spaces. This setting is carried in
    the file; we don't have to do any VIM setup to apply these settings to our Python
    script files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at how to write useful document strings in the *Including descriptions
    and documentation* and the *Writing better RST markup in docstrings* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information in suggested style, see [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing long lines of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when we need to write lines of code that are so long that
    they're very hard to read. Many people like to limit the length of a line of code
    to 80 characters or fewer. It's a well-known principle of graphic design that
    a narrower line is easier to read; opinions vary, but 65 characters is often cited
    as ideal. See [http://webtypography.net/2.1.2](http://webtypography.net/2.1.2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: While shorter lines are easier on the eyes, our code can refuse to cooperate
    with this principle. Long statements are a common problem. How can we break long
    Python statements into more manageable pieces?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we''ll have a statement that''s awkwardly long and hard to work with.
    Let''s say we''ve got something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code includes a long formula, and a long format string into which we're
    injecting values. This looks bad when typeset in a book. It looks bad on our screen
    when trying to edit this script.
  prefs: []
  type: TYPE_NORMAL
- en: We can't simply break Python statements into chunks. The syntax rules are clear
    that a statement must be complete on a single *logical* line.
  prefs: []
  type: TYPE_NORMAL
- en: The term logical line is a hint as to how we can proceed. Python makes a distinction
    between logical lines and physical lines; we'll leverage these syntax rules to
    break up long statements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python gives us several ways to wrap long statements so they're more readable.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `\` at the end of a line to continue onto the next line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can leverage Python's rule that a statement can span multiple logical lines
    because the `()` , the `[]` , and the `{}` characters must balance. In addition
    to using `()` and `\` , we can also exploit the way Python automatically concatenates
    adjacent string literals to make a single, longer literal; `("a" "b")` is the
    same as `ab` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, we can decompose a statement by assigning intermediate results
    to separate variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at each one of these in separate parts of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using backslash to break a long statement into logical lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the context for this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Python allows us to use `\` and break the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the whole statement on one long line, even if it''s confusing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If there''s a *logical* break, insert the `\` there. Sometimes, there''s no
    really good break:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For this to work, the `\` must be the last character on the line. We can't even
    have a single space after the `\` . This is fairly hard to see; for this reason,
    we don't encourage it.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of this being a little hard to see, the `\` can always be used. Think
    of it as the last resort in making a line of code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the () characters to break a long statement into sensible pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write the whole statement on one line, even if it''s confusing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the extra `()` characters that don''t change the value, but allow breaking
    the expression into multiple lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Break the line inside the `()` characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The matching `()` character's technique is quite powerful and will work in a
    wide variety of cases. This is widely used and highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: We can almost always find a way to add extra `()` characters to a statement.
    In the rare cases when we can't add `()` characters, or adding `()` characters
    doesn't improve things, we can fall back on using `\` to break the statement into
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using string literal concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can combine the `()` characters with another rule that combines string literals.
    This is particularly effective for long, complex format strings:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap a long string value in the `()` characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Break the string into substrings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can always break a long string into adjacent pieces. Generally, this is most
    effective when the pieces are surrounded by `()` characters. We can then use as
    many physical line breaks as we need. This is limited to those situations where
    we have particularly long string values.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning intermediate results to separate variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the context for this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can break this into three intermediate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify sub-expressions in the overall expression. Assign these to variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is generally quite simple. It may require a little care to do the algebra
    to locate sensible sub-expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the sub-expressions with the variables which were created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is an essential textual replacement of the original complex sub-expression
    with a variable.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't give these variables descriptive names. In some cases, the sub-expressions
    have some semantics that we can capture with meaningful names. In this case, we
    didn't understand the expression well enough to provide deeply meaningful names.
    Instead, we chose short, arbitrary identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python Language Manual makes a distinction between logical lines and physical
    lines. A logical line contains a complete statement. It can span multiple physical
    lines through techniques called **line joining** . The manual calls the techniques
    **explicit line joining** and **implicit line joining** .
  prefs: []
  type: TYPE_NORMAL
- en: The use of `\` for explicit line joining is sometimes helpful. Because it's
    easy to overlook, it's not generally encouraged. It is the method of last resort.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `()` for implicit line joining can be used in many cases. It often
    fits semantically with the structure of the expressions, so it is encouraged.
    We may have the `()` characters as a required syntax. For example, we already
    have `()` characters as part of the syntax for the `print()` function. We might
    do this to break up a long statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expressions are used widely in a number of Python statements. Any expression
    can have `()` characters added. This gives us a lot of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a few places where we may have a long statement that does
    not specifically involve an expression. The most notable example of this is the
    `import` statement—it can become long, but doesn't use any expressions that can
    be parenthesized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The language designers, however, allow us to use `()` characters so that a
    long list of names can be broken up into multiple logical lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `()` characters are emphatically not part of an expression.
    The `()` characters are just extra syntax, included to make the statement consistent
    with other statements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit line joining also applies to the matching `[]` characters and `{}`
    characters. These apply to collection data structures that we'll look at in [Chapter
    4](text00048.html#page "Chapter 4. Built-in Data Structures – list, set, dict")
    , *Built-in Data Structures – list, set, dict* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including descriptions and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a useful script, we often need to leave notes for ourselves—and
    others—on what it does, how it solves some particular problem, and when it should
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Because clarity is important, there are some formatting recipes that can help
    make the documentation very clear. This recipe also contains a suggested outline
    so that the documentation will be reasonably complete.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we've used the *Writing python script and module files - syntax basics* recipe
    to build a script file, we'll have put a small documentation string in our script
    file. We'll expand on this documentation string.
  prefs: []
  type: TYPE_NORMAL
- en: There are other places where documentation strings should be used. We'll look
    that these additional locations in [Chapter 3](text00039.html#page "Chapter 3. Function
    Definitions") , *Function Definitions* , and [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two general kinds of modules for which we''ll be writing summary docstrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Library Modules** : These files will contain mostly function definitions
    as well as class definitions. In this case, the docstring summary can focus on
    what the module is more than what it does. The docstring can provide examples
    of using the functions and classes that are defined in the module. In [Chapter
    3](text00039.html#page "Chapter 3. Function Definitions") , *Function Definitions*
    , and [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we''ll look more closely at this idea of a
    package of functions or classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripts** : These are files that we generally expect will do some real work.
    In this case, we want to focus on doing rather than being. The docstring should
    describe what it does and how to use it. The options, environment variables, and
    configuration files are important parts of this docstring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will sometimes create files that contain a little of both. This requires
    some careful editing to strike a proper balance between doing and being. In most
    cases, we'll simply provide both kinds of documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in writing documentation is the same for both library modules
    and scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a brief summary of what the script or module is or does. The summary doesn't
    dig too deeply into how it works. Like a *lede* in a newspaper article, it introduces
    the who, what, when, where, how, and why of the module. Details will follow in
    the body of the docstring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The way the information is displayed by tools like sphinx and pydoc suggests
    a specific style hint. In the output from these tools, the context is pretty clear,
    therefore it's common to omit a subject in the summary sentence. The sentence
    often begins with the verb.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a summary like this: *This script downloads and decodes the current
    Special Marine Warning (SMW) for the area AKQ* has a needless *This script* .
    We can drop that and begin with the verb phrase *Downloads and decodes...* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We might start our module docstring like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We'll separate the other steps based on the general focus of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing docstrings for scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we document a script, we need to focus on the needs of a person who will
    use the script.
  prefs: []
  type: TYPE_NORMAL
- en: Start as shown earlier, creating a summary sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketch an outline for the rest of the docstring. We'll be using **ReStructuredText**
    ( **RST** ) markup. Write the topic on one line, then put a line of `=` under
    the topic to make them a proper section title. Remember to leave a blank line
    between each topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Topics may include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SYNOPSIS** : A summary of how to run this script. If the script uses the
    `argparse` module to process command-line arguments, the help text produced by
    `argparse` is the ideal summary text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DESCRIPTION** : A more complete explanation of what this script does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OPTIONS** : If `argparse` is used, this is a place to put the details of
    each argument. Often we''ll repeat the `argparse` help parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENVIRONMENT** :If `os.environ` is used, this is the place to describe the
    environment variables and what they mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FILES** : Names of files that are created or read by a script are very important
    pieces of information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXAMPLES** : Some examples of using the script are always helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SEE ALSO** : Any related scripts or background information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other topics that might be interesting include **EXIT STATUS** , **AUTHOR**
    , **BUGS** , **REPORTING BUGS** , **HISTORY** , or **COPYRIGHT** . In some cases,
    advice on reporting bugs, for instance, doesn't really belong in a module's docstring,
    but belongs elsewhere in the project's GitHub or SourceForge pages.
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the details under each topic. It's important to be accurate. Since we're
    embedding this documentation within the same file as the code, it's easy to check
    elsewhere in the module to be sure that the content is correct and complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For code samples, there's a cool bit of RST markup we can use. Recall that all
    elements are separated by blank lines. In one paragraph, use `::` by itself. In
    the next paragraph, provide the code example indented by four spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example of a docstring for a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the Synopsis section, we used `::` as a separate paragraph. In the Examples
    section, we used `::` at the end of a paragraph. Both versions are hints to the
    RST processing tools that the indented section that follows should be typeset
    as code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing docstrings for library modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we document a library module, we need to focus on the needs of a programmer
    who will import the module to use it in their code.
  prefs: []
  type: TYPE_NORMAL
- en: Sketch an outline for the rest of the docstring. We'll be using RST markup.
    Write the topic on one line. Include a line of `=` under each topic to make the
    topic into a proper heading. Remember to leave a blank line between each paragraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start as shown previously, creating a summary sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DESCRIPTION** : A summary of what the modules contains and why the module
    is useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MODULE CONTENTS** : The classes and functions defined in this module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXAMPLES** : Examples of using the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill in the details for each topic. The module contents may be a long list of
    class or function definitions. This should be a summary. Within each class or
    function, we'll have a separate docstring with the details for that item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For code examples, see the previous examples. Use `::` as a paragraph or the
    ending of a paragraph. Indent the code example by four spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the decades the *man page* outline has evolved to contain a useful summary
    of Linux commands. This general approach to writing documentation has proven useful
    and resilient. We can capitalize on this large body of experience, and structure
    our documentation to follow the man page model.
  prefs: []
  type: TYPE_NORMAL
- en: These two recipes for describing software are based on summaries of many individual
    pages of documentation. The goal is to leverage the well-known set of topics.
    This makes our module documentation mirror the common practice.
  prefs: []
  type: TYPE_NORMAL
- en: We want to prepare module docstrings that can be used by the Sphinx Python Documentation
    Generator (see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)
    ). This is the tool used to produce Python's documentation files. The `autodoc`
    extension in Sphinx will read the docstring headers on our modules, classes, and
    functions, to produce the final documentation that looks like other modules in
    the Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RST has a simple syntax rule that paragraphs are separated by blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: This rule makes it easy to write documents that can be examined by the various
    RST processing tools and reformatted to look extremely nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to include a block of code, we''ll have some special paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate the code from the text by blank lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indent the code by four spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide a prefix of `::` . We can either do this as its own separate paragraph,
    or as a special double-colon at the end of the lead-in paragraph:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `::` is used on the lead-in paragraph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are places for novelty and art in software development. Documentation
    is not really the place to push the envelope. Clever algorithms and sophisticated
    data structures can be novel and clever.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A unique voice, or quirky presentation isn't fun for users who simply want to
    use the software. An amusing style isn't helpful when debugging. Documentation
    should be commonplace and conventional.
  prefs: []
  type: TYPE_NORMAL
- en: It can be challenging to write good software documentation. There's a broad
    chasm between too little information and documentation which simply recapitulates
    the code. Somewhere, there's a good balance. What's important is to focus on the
    needs of a person who doesn't know too much about the software or how it works.
    Provide this *semi-knowledgeable* user the information they need to describe what
    the software does and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, we need to address two parts of the use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The intended use of the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to customize or extend the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These may be two distinct audiences. There may be users who are distinct from
    developers. Each has a distinct perspective, and different parts of the documentation
    need to respect these two perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We look at additional techniques in *Writing better RST markup in docstrings*
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we've used the *Writing python script and module files – syntax basics* recipe,
    we'll have put a documentation string in our script file. When we build functions
    in [Chapter 3](text00039.html#page "Chapter 3. Function Definitions") , *Function
    Definitions* , and classes in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we'll look at other
    places where documentation strings can be placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)
    for more information on Sphinx.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more background on the man page outline, see [https://en.wikipedia.org/wiki/Man_page](https://en.wikipedia.org/wiki/Man_page)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing better RST markup in docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a useful script, we often need to leave notes on what it does,
    how it works, and when it should be used. Many tools for producing documentation,
    including Docutils, work with RST markup. What RST features can we use to make
    documentation more readable?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Including descriptions and documentation* recipe, we looked at putting
    a basic set of documentation into a module. This is the starting point for writing
    our documentation. There are a large number of RST formatting rules. We'll look
    at a few which are important for creating readable documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure to write an outline of the key points. This may lead to creating RST
    section titles to organize the material. A section title is a two-line paragraph
    with the title followed by an underline using `=` , `-` , `^` , `~` , or one of
    the other Docutils characters for underlining.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A heading will look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The heading text is on one line, the underlining characters are on the next
    line. This must be surrounded by blank lines. There can be more underline characters
    than title characters, but not fewer.
  prefs: []
  type: TYPE_NORMAL
- en: The RST tools will deduce our pattern of using underlining characters. As long
    as the underline characters are used consistently, the algorithm for matching
    underline character to desired heading will detect the pattern. The keys to this
    are consistency and a clear understanding of section and subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting out, it can help to make an explicit reminder sticky note like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Level** |'
  prefs: []
  type: TYPE_TB
- en: '| = | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| - | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ^ | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| ~ | 4 |'
  prefs: []
  type: TYPE_TB
- en: Fill in the various paragraphs. Separate paragraphs (including the section titles)
    by blank lines. Extra blank lines don't hurt. Omitting blank lines will lead the
    RST parsers to see a single, long paragraph, which may not be what we intended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use inline markup for emphasis, strong emphasis, code, hyperlinks, and
    inline math, among other things. If we're planning on using Sphinx, then we have
    an even larger collection of text roles that we can use. We'll look at these techniques
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: If the programming editor has a spell checker, use that. This can be frustrating
    because we'll often have code samples that may include abbreviations that fail
    spell checking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The docutils conversion programs will examine the document, looking for sections
    and body elements. A section is identified by a title. The underlines are used
    to organize the sections into a properly nested hierarchy. The algorithm for deducing
    this is relatively simple and has these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the underline character has been seen before, the level is known
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the underline character has not been seen before, then it must be indented
    one level below the previous outline level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no previous level, this is level one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A properly nested document might have the following sequence of underline characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the first outline character, `=` , will be level one. The next,
    `-` , is unknown, but appears after a level one, so it must be level two. The
    third headline has, `^` , which is previously unknown, and must be level three.
    The next `^` is still level three. The next two, `-` and `^` , are level two and
    three respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter the new character, `~` , it's beneath a level three and must,
    therefore, be a level four heading.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From this overview, we can see that inconsistency will lead to confusion.
  prefs: []
  type: TYPE_NORMAL
- en: If we change our mind part-way through a document, this algorithm can't detect
    that. If—for inexplicable reasons—we decide to skip over a level and try to have
    a level four heading inside a level two section, that simply can't be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different kinds of body element that the RST parser can recognize.
    We''ve shown a few. The more complete list includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paragraphs of text** : These might use inline markup for different kinds
    of emphasis or highlighting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Literal blocks** : These are introduced with `::` and indented for spaces.
    They may also be introduced with the `.. parsed-literal::` directive. A doctest
    block is indented four spaces and includes the Python `>>>` prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists, tables and block quotes** : We''ll look at these later. These can
    contain other body elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Footnotes** : These are special paragraphs that can be put on the bottom
    of a page or at the end of a section. These can also contain other body elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyperlink targets, substitution definitions, and RST comments** : These are
    specialized text items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For completeness, we'll note here that RST paragraphs are separated by blank
    lines. There's quite a bit more to RST than this core rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Including descriptions and documentation* recipe we looked at several
    different kinds of body elements we might use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paragraphs of Text** : This is a block of text surrounded by blank lines.
    Within these, we can make use of inline markup to emphasize words, or to use a
    font to show that we''re referring to elements of our code. We''ll look at inline
    markup in the *Using Inline Markup* recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists** : These are paragraphs that begin with something that looks like
    a number or a bullet. For bullets, use a simple `-` or `*` . Other characters
    can be used, but these are common. We might have paragraphs like this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It helps to have bullets because:'
  prefs: []
  type: TYPE_NORMAL
- en: They can help clarify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can help organize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbered Lists** : There are a variety of patterns that are recognized. We
    might use something like this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Four common kinds of numbered paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers followed by punctuation like `.` or `)` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A letter followed by punctuation like `.` or `)` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A roman numeral followed by punctuation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A special case of `#` with the same punctuation used on the previous items.
    This continues the numbering from the previous paragraphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Literal Blocks** : A code sample must be presented literally. The text for
    this must be indented. We also need to prefix the code with `::` . The `::` character
    must either be a separate paragraph or the end of a lead-in to the code example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directives** : A directive is a paragraph that generally looks like `.. directive::`
    . It may have some content that''s indented so that it''s contained within the
    directive. It might look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `.. important::` paragraph is the directive. This is followed by a short
    paragraph of text indented within the directive. In this case, it creates a separate
    paragraph that includes the admonition of *important* .
  prefs: []
  type: TYPE_NORMAL
- en: Using directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docutils has many built-in directives. Sphinx adds a large number of directives
    with a variety of features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most commonly used directives are the admonition directives: *attention*
    , *caution* , *danger* , *error* , *hint* , *important* , *note* , *tip* , *warning*
    , and the generic *admonition* . These are compound body elements because they
    can have multiple paragraphs and nested directives within them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have things like this to provide appropriate emphasis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: One of the other common directives is the `parsed-literal` directive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This can be handy for providing examples of code where some portion of the code
    is highlighted. A literal like this is a simple body element, which can only have
    text inside. It can't have lists or other nested structures.
  prefs: []
  type: TYPE_NORMAL
- en: Using inline markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within a paragraph, we have several inline markup techniques we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: We can surround a word or phrase with `*` for `*emphasis*` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can surround a word or phrase with `**` for `**strong**` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We surround references with single back-tick ([PRE30]` ) to make them look like
    [PRE31] .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also a more general technique called a text role. A role is a little
    more complex-looking than simply wrapping a word or phrase in the `*` characters.
    We use `:word:` as the role name followed by the applicable word or phrase in
    single [PRE32]
  prefs: []
  type: TYPE_NORMAL
- en: dice = die_1 + die_2
  prefs: []
  type: TYPE_NORMAL
- en: 'if dice in (2, 3, 12):'
  prefs: []
  type: TYPE_NORMAL
- en: game.craps()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif dice in (7, 11):'
  prefs: []
  type: TYPE_NORMAL
- en: game.winner()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif dice in (4, 5, 6, 8, 9, 10):'
  prefs: []
  type: TYPE_NORMAL
- en: game.point(die)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'raise Exception(''Design Problem Here: not all conditions accounted for'')'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: do something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert (m = a or m = b) and m > a and m > b
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'if a >= b:'
  prefs: []
  type: TYPE_NORMAL
- en: m = a
  prefs: []
  type: TYPE_NORMAL
- en: 'elif b >= a:'
  prefs: []
  type: TYPE_NORMAL
- en: m = b
  prefs: []
  type: TYPE_NORMAL
- en: 'else:     raise Exception( ''Design Problem'')'
  prefs: []
  type: TYPE_NORMAL
- en: assert (m = a or m = b) and m > a and m > b
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: initialize something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while # not terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert password_text == confirming_password_text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: initialize something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert the invariant new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while # not terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert the invariant new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert password_text == confirming_password_text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: initialize something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert the invariant new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while password_text != confirming_password_text:'
  prefs: []
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert the invariant new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert password_text == confirming_password_text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: password_text= getpass()
  prefs: []
  type: TYPE_NORMAL
- en: 'confirming_password_text= getpass("Confirm: ")'
  prefs: []
  type: TYPE_NORMAL
- en: assert new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while password_text != confirming_password_text:'
  prefs: []
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert password_text == confirming_password_text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: password_text= getpass()
  prefs: []
  type: TYPE_NORMAL
- en: 'confirming_password_text= getpass("Confirm: ")'
  prefs: []
  type: TYPE_NORMAL
- en: assert new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while password_text != confirming_password_text:'
  prefs: []
  type: TYPE_NORMAL
- en: password_text= getpass()
  prefs: []
  type: TYPE_NORMAL
- en: 'confirming_password_text= getpass("Confirm: ")'
  prefs: []
  type: TYPE_NORMAL
- en: assert new-input(password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and new-input(confirming_password_text)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert password_text == confirming_password_text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: password_text= getpass()
  prefs: []
  type: TYPE_NORMAL
- en: 'confirming_password_text= getpass("Confirm: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'while password_text != confirming_password_text:'
  prefs: []
  type: TYPE_NORMAL
- en: password_text= getpass()
  prefs: []
  type: TYPE_NORMAL
- en: 'confirming_password_text= getpass("Confirm: ")'
  prefs: []
  type: TYPE_NORMAL
- en: assert password_text == confirming_password_text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: assert pre-condition
  prefs: []
  type: TYPE_NORMAL
- en: S
  prefs: []
  type: TYPE_NORMAL
- en: assert post-condition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> sample_1 = "some_name = the_value"'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for position in range(len(sample_1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '...    if sample_1[position] in ''=:'':'
  prefs: []
  type: TYPE_NORMAL
- en: '...        break'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(''name='', sample_1[:position],'
  prefs: []
  type: TYPE_NORMAL
- en: '...     ''value='', sample_1[position+1:])'
  prefs: []
  type: TYPE_NORMAL
- en: name= some_name  value=  the_value**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> sample_2 = "name_only"'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for position in range(len(sample_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '...    if sample_2[position] in ''=:'':'
  prefs: []
  type: TYPE_NORMAL
- en: '...        break'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(''name='', sample_2[:position],'
  prefs: []
  type: TYPE_NORMAL
- en: '...     ''value='', sample_2[position+1:])'
  prefs: []
  type: TYPE_NORMAL
- en: name= name_onl value=**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: text[position] in '=:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: (len(text) == 0
  prefs: []
  type: TYPE_NORMAL
- en: or not('=' in text or ':' in text)
  prefs: []
  type: TYPE_NORMAL
- en: or text[position] in '=:')
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> position = -1 # If it''s zero length'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for position in range(len(sample_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '...    if sample_2[position] in ''=:'':'
  prefs: []
  type: TYPE_NORMAL
- en: '...        break'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if position == -1:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print("name=", None, "value=", None)'
  prefs: []
  type: TYPE_NORMAL
- en: '... elif not(text[position] == '':'' or text[position] == ''=''):'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print("name=", sample_2, "value=", None)'
  prefs: []
  type: TYPE_NORMAL
- en: '... else:'
  prefs: []
  type: TYPE_NORMAL
- en: '...    print(''name='', sample_2[:position],'
  prefs: []
  type: TYPE_NORMAL
- en: '...     ''value='', sample_2[position+1:])'
  prefs: []
  type: TYPE_NORMAL
- en: name= name_only value= None**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'if len(sample_2) > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: name, value = sample_2, None
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: name, value = None, None
  prefs: []
  type: TYPE_NORMAL
- en: 'for position in range(len(sample_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if sample_2[position] in ''=:'':'
  prefs: []
  type: TYPE_NORMAL
- en: name, value = sample_2[:position], sample2[position:]
  prefs: []
  type: TYPE_NORMAL
- en: print('name=', name, 'value=', value)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'for position in range(len(sample_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if sample_2[position] in ''=:'':'
  prefs: []
  type: TYPE_NORMAL
- en: name, value = sample_2[:position], sample_2[position+1:]
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(sample_2) > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: name, value = sample_2, None
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: name, value = None, None
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: from pathlib import Path
  prefs: []
  type: TYPE_NORMAL
- en: import shutil
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: source_path = Path(os.path.expanduser(
  prefs: []
  type: TYPE_NORMAL
- en: '''~/Documents/Writing/Python Cookbook/source''))'
  prefs: []
  type: TYPE_NORMAL
- en: target_path = Path(os.path.expanduser(
  prefs: []
  type: TYPE_NORMAL
- en: '''~/Dropbox/B05442/demo/''))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for source_file_path in source_path.glob(''*/*.rst''):'
  prefs: []
  type: TYPE_NORMAL
- en: source_file_detail = source_file_path.relative_to(source_path)
  prefs: []
  type: TYPE_NORMAL
- en: target_file_path = target_path / source_file_detail
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'FileNotFoundError: [Errno 2]'
  prefs: []
  type: TYPE_NORMAL
- en: 'No such file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '''/Users/slott/Dropbox/B05442/demo/ch_01_numbers_strings_and_tuples/index.rst'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: os.makedir( target_file_path.parent )
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: os.makedirs( str(target_file_path.parent) )
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError as ex:'
  prefs: []
  type: TYPE_NORMAL
- en: print(ex)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: os.makedirs( str(target_file_path.parent) )
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.makedirs( str(target_file_path.parent) )
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError as ex:'
  prefs: []
  type: TYPE_NORMAL
- en: print(ex)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError as ex:'
  prefs: []
  type: TYPE_NORMAL
- en: print(ex)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: os.makedirs( str(target_file_path.parent) )
  prefs: []
  type: TYPE_NORMAL
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError as ex:'
  prefs: []
  type: TYPE_NORMAL
- en: print(ex)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'class Error(Exception):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: something
  prefs: []
  type: TYPE_NORMAL
- en: 'except (IndexError, NameError) as exception:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Expected", exception)
  prefs: []
  type: TYPE_NORMAL
- en: raise Error("something went wrong") from exception
  prefs: []
  type: TYPE_NORMAL
- en: 'except Exception as exception:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Unexpected", exception)
  prefs: []
  type: TYPE_NORMAL
- en: raise
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> class Error(Exception):'
  prefs: []
  type: TYPE_NORMAL
- en: '...     pass'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> try:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     ''hello world''[99]'
  prefs: []
  type: TYPE_NORMAL
- en: '... except (IndexError, NameError) as exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     raise Error("index problem") from exception'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<doctest default[0]>", line 2, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: '''hello world''[99]'
  prefs: []
  type: TYPE_NORMAL
- en: 'IndexError: string index out of range**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py",
    line 1318, in __run
  prefs: []
  type: TYPE_NORMAL
- en: compileflags, 1), test.globs)
  prefs: []
  type: TYPE_NORMAL
- en: File "<doctest default[0]>", line 4, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: raise Error("index problem") from exception
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: index problem**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: some_function()
  prefs: []
  type: TYPE_NORMAL
- en: 'except Error as exception:'
  prefs: []
  type: TYPE_NORMAL
- en: print(exception)
  prefs: []
  type: TYPE_NORMAL
- en: print(exception .__cause__)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: something
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError as exception:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Some message", exceotuib)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> import csv**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> import pathlib**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**>>> some_source = [[2,3,5], [7,11,13], [17,19,23]]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: target_path = pathlib.Path('code/test.csv')
  prefs: []
  type: TYPE_NORMAL
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: target_path = pathlib.Path('code/test.csv')
  prefs: []
  type: TYPE_NORMAL
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  prefs: []
  type: TYPE_NORMAL
- en: writer = csv.writer(target_file)
  prefs: []
  type: TYPE_NORMAL
- en: writer.writerow(['column', 'data', 'headings'])
  prefs: []
  type: TYPE_NORMAL
- en: 'for data in some_source:'
  prefs: []
  type: TYPE_NORMAL
- en: writer.writerow(data)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: target_path = pathlib.Path('code/test.csv')
  prefs: []
  type: TYPE_NORMAL
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  prefs: []
  type: TYPE_NORMAL
- en: writer = csv.writer(target_file)
  prefs: []
  type: TYPE_NORMAL
- en: writer.writerow(['column', 'headings'])
  prefs: []
  type: TYPE_NORMAL
- en: 'for data in some_source:'
  prefs: []
  type: TYPE_NORMAL
- en: writer.writerow(data)
  prefs: []
  type: TYPE_NORMAL
- en: print('finished writing', target_path)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: target_path = pathlib.Path('code/test.csv')
  prefs: []
  type: TYPE_NORMAL
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  prefs: []
  type: TYPE_NORMAL
- en: writer = csv.writer(target_file)
  prefs: []
  type: TYPE_NORMAL
- en: writer.writerow(['column', 'headings'])
  prefs: []
  type: TYPE_NORMAL
- en: 'for data in some_source:'
  prefs: []
  type: TYPE_NORMAL
- en: writer.writerow(data)
  prefs: []
  type: TYPE_NORMAL
- en: raise Exception("Just Testing")
  prefs: []
  type: TYPE_NORMAL
- en: 'except Exception as exc:'
  prefs: []
  type: TYPE_NORMAL
- en: print(target_file.closed)
  prefs: []
  type: TYPE_NORMAL
- en: print(exc)
  prefs: []
  type: TYPE_NORMAL
- en: print('finished writing', target_path)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: Just Testing
  prefs: []
  type: TYPE_NORMAL
- en: finished writing code/test.csv
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that the file was properly closed. It also shows us the message
    associated with the exception to confirm that it was the exception we raised manually.
    The output `test.csv` file will only have the first row of data from the `some_source`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python offers us a number of context managers. We noted that an open file is
    a context, as is an open network connect created by `urllib.request.urlopen()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: For all file operations, and all network connections, we should use a `with`
    statement as a context manager. It's very difficult to find an exception to this
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the `decimal` module makes use of a context manager to allow
    localized changes to the way decimal arithmetic is performed. We can use the `decimal.localcontext()`
    function as a context manager to change rounding rules or precision for calculations
    isolated by a `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We can define our own context managers, also. The `contextlib` module contains
    functions and decorators that can help us create context managers around resources
    that don't explicitly offer them.
  prefs: []
  type: TYPE_NORMAL
- en: When working with locks, the `with` context is the ideal way to acquire and
    release a lock. See [https://docs.python.org/3/library/threading.html#with-locks](https://docs.python.org/3/library/threading.html#with-locks)
    for the relationship between a lock object created by the `threading` module and
    a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/)
    for the origins of the with statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
