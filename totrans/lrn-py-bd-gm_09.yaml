- en: Data Model Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games are a medium that try to emulate, or at least simulate, real-world environments
    through the use of interplay, where players use motions and movements in order
    to control the game characters. As we know, there are a variety of ways in which
    players can interact with the game, mostly with input devices such as a keyboard,
    a mouse, or a joystick. In order to translate these input signals into meaningful
    information, we need to address the signals with corresponding actions. In most
    games, we use keyboard keys to make movements for the game character, but internally,
    the signals are handled by mathematical objects called vectors. This is extremely
    important for any game, regardless of how the graphics appear, as it causes players
    to create actions and address them with appropriate reactions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be introduced to 2D vectors—ways of manipulating the
    positions of game characters. The change in the coordinates of vectors (*x*, *y*)
    represents the movement that's specified by the game player. This chapter will
    be life-changing for any programming beginner as this will teach us how to use
    mathematical concepts such as addition, subtraction, multiplication, rotation,
    and reflection with a programming paradigm, which we know as data model implementation.
    The end goal of this chapter is to make you familiar with the concept of operator
    overloading using Python, the usage of Python built-in methods in order to manipulate
    vectored positions, and the implementation of data models or magic functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with 2D vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data model for vectored motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will give us a roller coaster ride of Python''s simple, yet powerful,
    concept of operator overloading. Therefore, you are expected to be equipped with
    the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.5 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python IDLE (Python's inbuilt IDE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files for this chapter can be found here: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter09](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter09)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2psS6pd](http://bit.ly/2psS6pd)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a new concept, and may be ambiguous to naive programmers, but it is
    obligatory to have this knowledge. In the programming nomenclature, everything
    that is defined with a programming language has a specific usage. For example,
    we cannot use the `sum()` method to find the difference between elements. We can
    extend the meaning of any operation beyond its normal usage or predefined operational
    usage. Take a simple example of an addition (+) operator; this operator can be
    used to add simple integers, concatenate two independent strings, and even merge
    the two lists. This is possible because the addition operator is overloaded in
    different classes, that is, it has different implementations defined in the string
    and integer classes. This is the power of operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another factor that must be kept in mind is that the same function or built-in
    operator depicts different behaviors for the objects of several classes, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Several methods support operator overloading; these are known as data models,
    or sometimes, magic methods. They are called so because these special methods
    extend the functionality of methods, which in turn adds magic to our classes.
    These data models should not be invoked by us; rather it happens internally from
    the classes. For example, when we perform an addition operation with the `+` operator,
    the Python parser internally invokes the `__add__()` method. Different built-in
    classes of Python such as `str`, `int`, `list`, and many more, have different
    internally defined magic functions. We can print the list of magic functions that
    are dedicated to a particular class using the `dir` function. For example, the
    following list indicates several methods and attributes that are defined in the
    `str` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding list of methods and attributes of the `str` class,
    we can observe several methods that start and end with a double underscore. For
    example, the `__add__()` method is used to concatenate two strings using the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that the `__add__()` function works in
    a similar way as `+`. These data models are meant to be used to extend the predefined
    meaning with overloaded behavior. Based on mathematical canonization, we normally
    use operators such as `+`, `-`, `/`, and `*` with numeric objects. However, with
    the overloading technique, we use the same operator for multiple objects, such
    as strings and lists. We can conclude that the addition operator (`+`) is overloaded.
    Similarly, different data models are defined by Python for different operators,
    that is, `__sub__()` for the `-` operator, `__mul__()` for the `*` operator, and
    `__div__()` for the `/` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to use data models in the most basic form of an
    add function, we will implement some examples of custom-made classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using data models in custom classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to implement the `__add__()` magic function with various
    data types such as integer and string, let''s observe how it can be used in custom-made
    (user-defined) Python classes. We will consider the following example to illustrate
    the usage of data models in our custom class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make the objects of the preceding class with the following code. This
    code is executed in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we get an error saying unsupported operands for different types,
    which implies that the `+` operator is not functional for adding the objects of
    custom classes. As mentioned previously, to solve such problems, we can use operator
    overloading. We can explicitly define such special methods inside our class in
    order to make objects compatible with built-in methods and operators. For example,
    in the case of the addition operation, we have to define the `__add__()` method
    explicitly inside the class, which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether this works by making different objects of the `Base` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the magic function, or the `__add__()` data model, is overridden, which
    successfully performs the addition operation between two integers and two strings.
    We can also check this for other data objects such as lists and tuples. Now, we
    can clearly predict the pattern; if we want to overload any mathematical operator
    and implement it differently in our custom-made classes, we have to define data
    models in our classes. I hope you get the idea! Now, we can predict the `__mul__()` pattern
    so that we can perform multiplication between different objects, `__sub__()` to
    perform subtraction, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's observe another powerful, yet less frequently used, magic method of Python,
    before actually learning about the importance of using these magic functions.
    Let's talk about the `__new__()` data model. You can easily observe the working
    of these methods; just remove the underscore and parentheses that surround the
    method name and you will come up with the `new` keyword. If you have a programming
    background from any high-level language such as Java and C#, you will already
    understand my point. For those who are new to the concept of the `new` keyword,
    this operator is used to create instances of the classes. For example, in Python,
    we have `object = class_name()`, while in Java, we have `object = new class_name()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the `__new__()` magic method is the first method to be called while creating
    objects of classes—even before the `__init__()` constructor is called—and it is
    called implicitly. The `__new__()` method is responsible for creating new objects,
    and it returns the object that''s initialized using the constructor''s `__init__()`
    method. Do you remember, in object-oriented chapter, we referred to the `__init__()`
    method as a special method, which is, in fact, a magic method. Let''s consider
    the following example to learn about the `__new__()` magic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is executed inside the Python shell. We are creating an
    object of the `Base` class, and observing that the `new` method is called before
    the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding code, we passed `cls` as an argument while defining
    the `new` magic method and the `self` variable as an argument while defining the
    `init` constructor. The distinction between these two variables—`cls` and `self`—is
    defined in PEP 8, which defines the style guide for Python code. This coding style
    is not mandatory, but according to PEP 8, we should always do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use `self` for the first argument to instance methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use `cls` for the first argument to class methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I think that we are now capable enough to predict the working internals of
    any built-in function. Let''s take the example of the `len()` method. If there
    is any built-in `fun()` function in Python, it corresponds to `__fun__()`. The
    Python parser makes an internal call as `object.__fun__()`, where the object is
    the instance of a class. Considering this analogy, for the `len()` function, the
    Python parser interprets its call as `object.__len__()`, and it returns the length
    of the object. We have seen how it works internally; however, since the main topic
    we want to cover is how to override it, let''s define this magic method inside
    our custom-made classes (in a similar way to the preceding example, where we used
    the `add` magic function to add objects of a class). In the case of `__len__()`,
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, when we define such magic methods or data models in our own class,
    we override the behavior of the functions that are originally defined by Python;
    thus, we are now no longer calling the original method. When you override the
    original method with your new one, we refer to this as method overriding. Up to
    this point, we have been learning about data models and ways of using them in
    our own classes. Now, let's learn about why they are essential in game programming.
    We will do this by exploring vectors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with two-dimensional vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before actually exploring vectors, let''s start with the basic overview of
    motion and how characters are moved in a straight line. To move any object or
    image, we have to make a slight change to the frames by a fixed amount. The movement
    must be fixed for each frame in order to make it symmetrical. To make an object
    move in a horizontal direction, we carry out an addition of a fixed amount to
    the *x* position, and to make it move in a vertical direction, we add the same
    amount to the y position. Thus, motion in 2D games can be represented as (*x*,
    *y*). Let''s consider the following example to illustrate the usage of these coordinates
    on order to draw any shape into the game environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `turtle` module, which we used in the previous chapter to draw
    a line using the `(a, b)` and `(x, y)` positions. The `goto()` method is used
    to move the pen to the passed positions. These coordinates—`(x, y)` or `(a, b)`—clearly
    show the importance of knowing the positions in order to create game characters
    (we use line as a metaphor for any game character).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can deem that the usage of a straight line motion is pretty useful, but
    looking at it from a different perspective, a game that only supports vertical
    or horizontal motions may seem dull and unexciting. For example, in the Pacman
    game, where a player would move either in a vertical or horizontal direction,
    this may be appropriate, but in the case of a car-racing game, where users can
    move in any direction, this motion doesn''t work properly. We must be able to
    move in any direction by adjusting the positions of *x* and *y* for each frame.
    We will use the same two positions, *x* and *y*, to generate both straight and
    diagonal motions: a rate that indicates speed for the *x* and *y* positions. The
    form that represents `(x, y)` is known as a vector, but more importantly, vectors
    signify direction, unlike scalar. We will explore vectors in more detail in the
    following subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the mathematical adage says:'
  prefs: []
  type: TYPE_NORMAL
- en: '" Vector refers to any quantity that has magnitude as well as direction, especially
    for determining the position of one point in space relative to another."'
  prefs: []
  type: TYPE_NORMAL
- en: 'We couldn''t agree more. This concept is taken from mathematics, and is the
    most well-known topic for any game programmer, naive to suave. Vectors are the
    proper representation of any position of an object, with the critical information
    of the direction attached to it. Vectors have similar representations as a straight
    line motion in the form of *x* and *y* coordinates (2D), but they are not restricted
    to only providing information about magnitude; they have a specific purpose. For
    example, vector (4, 5) represents the next position, where 4 is added to the *x*
    coordinate of the current position and 5 is added to the *y* coordinate of the
    current position; something like this—(0 + 4, 0 + 5)—where (0, 0) is the origin
    or center position. Let''s examine vectors figuratively with the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9d2fb736-745b-402b-9479-7af3f02d1681.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, vector (4,5) has magnitude and direction. The green
    line indicates magnitude and the orange line indicates direction. Thus, a vector
    is incomplete without the information of its previous direction. Let''s look at
    another simple example to clarify this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7047fb35-abc6-4eef-99f4-a175f1310dcc.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram says it all. The vector AB is the subtraction of the *x*
    and *y* positions from the target with the initial position. Suppose a Pacman
    is at position (30, 20), and he has to reach the target, that is, (50, 45). Vector
    AB is the critical information which indicates that Pacman has to move 20 units
    more in the *x* direction, and 25 more in the *y* direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is well-known that Python does not have a built-in *vector* data structure.
    If you think there is, perform a quick internet search on it; you will get the
    basic idea. However, we didn''t cover vectors as built-in data structures in the
    preceding chapters. Although we don''t have vectors as built-in data types, we
    can make one for ourselves. As we know, vectors constitute two different positions
    (*x*, *y*), and our main aim is to use other built-in data structures to make
    them. For example, we can use lists to make vectors, but indicating each point
    with indexes such as `[0]` and `[1]` adds unwanted overheads. The same goes for
    using tuples. Probably the best way of creating vectors would be by making our
    own vector class. In doing so, we can reference points as *x* and *y* instead
    of indexes. Furthermore, the best exploits can be made by using data models with
    vectors. We can use `__add__()`, `__mul__()`, and many more magic functions inside
    the vector class, which will introduce motion to the game characters. As an example,
    we will create a simple vector class and make use of the `__str__()` method, along
    with a constructor, which will provide a proper representation of positions with
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, we created a `Vector` class and defined two members
    in it: one being the constructor, and the other being the magic method. Now, when
    we create any object of this class, such as `> pos = Vector(10,40)`*,* the `init()`
    method will perform initialization so that we can reference each component of
    the vector as `>>> pos.x` and `>>> pos.y`. The `__str__()` method is the magic
    method that is used as the overriding method and it has a custom definition in
    our `Vector` class, which is used as a representation of the components of vector
    in the form of the *x* and *y* positions. Let''s see how it works by running the
    following code and creating a `Vector` class object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the `__str__()` method, we have a bunch of magic functions that are
    applicable for manipulating vectors. We can use `__add__()` to perform addition
    between vectors, `__sub__()` to perform subtraction, `__neg__()` to perform negation,
    and so on. We will learn about these data models and ways of using them to modify
    vectors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling for vectored motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, vectors are the quantity that constitute both magnitude and direction.
    These two pieces of information can be extremely critical when determining the
    next position for game characters, based on a user''s action. For example, a game
    character, Steve (a Minecraft character), can use vectors to determine the units
    he has to travel further using magnitude (AB) and direction (→AB) in order to
    track his goal. Although we can change both of these sources of information one
    by one, we are primarily concerned with magnitude because magnitude is responsible
    for providing motion in 2D games. In this section, we will uncover the techniques
    that will teach us how to add and subtract vectors, and even perform multiplication
    and division. These types of operations will be added as logic in the game, along
    with user events, so that whenever the user presses any keys on the keyboard,
    it is addressed by a particular event. The techniques that can be used while performing
    this operation mathematically are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing operations (subtracting/adding) on vectors with known components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing operations by finding components, or simply using head/tail methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn about the use of these techniques by hopping over to the next section,
    where we will perform vectored operations using magic functions or data models.
  prefs: []
  type: TYPE_NORMAL
- en: Vector addition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to numeric addition, we can overload the `+` operator using the `__add__()`
    data model, which will add two different vectors and combine its effect in order
    to produce a new single vector. Using this method, we can make diagonal motions
    with the game characters. We need two vectors to perform addition; the first one
    will be the current position of the game character, and next one will be a predefined
    fixed amount for each component of the vector that needs to be added when the
    user presses any key on the keyboard. The following diagram illustrates the addition
    of vectors in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/eadbff9a-5933-446d-9314-fa85759bc534.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Never perform addition operation of vectors with the `+` operator when you
    have a vector that''s represented by tuples or lists. [1,2] + [3,4] does not add
    individual digits like this: [4, 6]. Instead, it will concatenate two lists into
    one, like so: [1,2,3,4].'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `__iadd__()` magic function to add two vectors.
    The `iadd` and `add` methods work in a similar way, but the main difference between
    them is that `__iadd__()` stores its result into the memory location, unlike `__add__()`.
    You can use either of these to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the preceding code is included inside the previously made `Vector`
    class. The `__iadd__()` method takes the argument, *other,* which represents a
    second vector that needs to be added to the vector that it is called upon. Inside
    the magic function, we have made conditionals to check whether the passed *other* vector
    is a type of `Vector` class. If it is, we are adding matching components of the
    first vector with the second vector, which is `first.x` to `second.x`, and `first.y`
    to `second.y`, where first and second are vectors. Let''s make the instances of
    the `Vector` class and check the output of the vector addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have successfully used the magic method to implement vector addition,
    it's time to learn a few more of them in order to implement vector subtraction
    and vector negation.
  prefs: []
  type: TYPE_NORMAL
- en: Vector subtraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the addition of vectors implies the forward motion for game characters,
    vector subtraction suggests the opposite direction from where it is currently
    facing. We can use either `__sub__()` or `__isub__()` to implement vector subtraction.
    We normally prefer `isub` because it stores a result before returning it and it
    can be perfectly used in order to clone the vector objects so that we can perform
    different manipulation in the duplicate objects, without harming original one.
    Vector subtraction is quite similar to addition; instead of adding each components
    of a vector, we are simply going to subtract them. This motion is useful in games
    such as Pacman, where users have to reverse their direction spontaneously without
    disturbing the gameplay. Let''s write the following code inside the `Vector` class
    in order to perform vector subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the preceding code in the Python shell in order to observe the result
    of vector subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Vector multiplication and division
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operations such as multiplication and division will make vectors larger and
    smaller, respectively. The change of motion due to multiplication can be linear
    when a vector is multiplied by any scalar number. For example, when we multiply
    any vector by two, its magnitude will be twice than before, but the direction
    will remain unchanged. Similarly, when we multiply the same vector with a negative
    number, let''s say, -2, its direction will be opposite to the direction it was
    originally facing. Multiplication operations are normally used for scaling vectors.
    We can multiply and divide two vectors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to vector multiplication and division, we can perform a scaling process
    using scalar quantity. We will pass a number, instead of the second vector, as
    a parameter to the magic methods. It can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Vector negation and equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have covered the most important operations of vectors, such as addition,
    multiplication, and subtraction, we will now learn the easy, yet important, vector
    manipulation technique, which is known as vector negation and equality. Vector
    negation is important when a player wants to reach out to the preceding state
    from the current one (since AB = -BA), which implies that negating any vector
    creates another vector of the same magnitude but in the opposite direction. In
    order to negate a vector, we can simply add the `-` negative operator to each
    component of the vector. As an example, we can consider the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether two vectors are equal by checking each of the components
    of the vector. For example, `first.x` should be compared with `second.x`, and
    `first.y` should be compared with `second.y`. For example, the following method
    will return `True` if two vectors are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the Python official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*("*`NotImplemented` *signals to the runtime that it should ask someone else
    to satisfy the operation. In the expression `a == b`, if `a.__eq__(b)` returns*
    `NotImplemented`*, then Python tries `b.__eq__(a)`. If b knows enough to return*
    `True` *or* `False`*, then the expression can succeed. If it doesn''t, then the
    runtime will fall back to the built-in behavior (which is based on the identity
    of == and != )")*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a wide range of topics in this chapter, starting from data models
    to the creation and manipulation of vectors. Vectors are undoubtedly the most
    essential topic for any game developer; they help to create motion for the game
    characters and sprites so that the game will be more user interactive. We have
    learned about different operations, such as addition, subtraction, division, negation,
    and many more. We also manipulated our vector components using these operations
    and magic methods. Magic methods are a part of method overriding, which should
    have been covered in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml),
    *Object-Oriented Programming*. However, I reserved it until this chapter because
    it makes more sense to learn about it while exploring vectors.
  prefs: []
  type: TYPE_NORMAL
- en: As the mathematical logic concerning vectors is a primary building block for
    the expedition of character movements in the game, you have learned how to implement
    operator overloading using magic functions. The vector manipulation skills we've
    learned in this chapter are important because they specify the position of an
    object and help us perform manipulation with some algebraic operations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has introduced us to two-dimensional vectors—a mathematical concept
    that makes the motion of game characters possible in a game. To implement this,
    we had to use the concepts of data overloading using magic functions. To overload
    any operator— that is, change the implementation of any operator such as `+` or
    `-`—we extend the usage of such operators from primitive data types to complex
    data structures. The main goal of this chapter was to introduce you to the ways
    you can accomplish mathematical concepts such as 2D vectored operations using
    the Python programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a roller coaster ride of game programming
    using the turtle module by applying our knowledge from this chapter. We will make
    multiple games such as Snake, Pong, and Flappy Bird. Now, it's time for you to
    start experimenting with vectors; try to mix them together and develop various
    kinds of movements for the vector.
  prefs: []
  type: TYPE_NORMAL
