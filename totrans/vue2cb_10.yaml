- en: Large Application Patterns with Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex的大型应用程序模式
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Dynamically loading pages in your vue-router
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Building a simple storage for the application state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的应用程序状态存储
- en: Understanding Vuex mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vuex的mutations
- en: Listing your actions in Vuex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vuex中列出您的操作
- en: Separating concerns with modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块分离关注点
- en: Building getters to help retrieve your data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建getter以帮助检索数据
- en: Testing your store
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的存储
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you will learn how Vuex works and how to use it to support
    a scalable application. Vuex implements a pattern that is popular in frontend
    frameworks and consists of dividing the different concerns to manage a big global
    application state. The mutations are the only things that can change the state,
    so you have only one place to look for that. Much of the logic, along with all
    the asynchronous logic, is contained in the actions; finally, getters and modules
    further help to spread the cognitive load when it comes to computing the derived
    state and splitting your code into different files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Vuex的工作原理以及如何使用它来支持可扩展的应用程序。Vuex实现了一种在前端框架中流行的模式，它将不同的关注点分开管理一个大型全局应用程序状态。只有mutations可以改变状态，所以您只需要在一个地方查找。大部分逻辑以及所有异步逻辑都包含在actions中；最后，getters和modules进一步帮助在计算派生状态和将代码拆分为不同文件时分散认知负荷。
- en: Along with recipes, you will find grains of wisdom that I found useful when
    developing real large applications; some have to do with naming conventions and
    others with little tricks to avoid bugs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配方之外，您还会发现在开发实际的大型应用程序时我发现有用的一些智慧之粒；有些与命名约定有关，有些则是为了避免错误的小技巧。
- en: If you complete all the recipes, you will be ready to develop big frontend applications
    with fewer bugs and seamless collaboration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了所有的配方，您将准备好开发具有较少错误和无缝协作的大型前端应用程序。
- en: Dynamically loading pages in your vue-router
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Soon, you will build huge Vue websites with loads of components. Loading a lot
    of JavaScript may generate wasteful and useless upfront delay. In the *Loading
    your components asynchronously*  recipe in [Chapter 4](text00195.html) , *All
    About Components* , we already saw a hint of how to retrieve our components remotely.
    Here we will apply a similar technique to components loaded by a route in vue-router.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，您将构建具有大量组件的大型Vue网站。加载大量JavaScript可能会产生浪费和无用的前期延迟。在[第4章](text00195.html)的*关于组件的一切*中的*异步加载组件*配方中，我们已经看到了如何远程检索组件的提示。在这里，我们将使用类似的技术来加载由vue-router路由加载的组件。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires knowledge of vue-router. If you want, you can go through *Loading
    your components asynchronously*  in  [Chapter 4](text00195.html) , *All About
    Components* , to get a better idea of what is happening.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解vue-router。如果您愿意，您可以通过在[第4章](text00195.html)的*关于组件的一切*中的*异步加载组件*来更好地了解发生了什么。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new project with `vue-cli` by making a new directory and running the
    following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新目录并运行以下命令，使用`vue-cli`创建一个新项目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
- en: You can answer the question as you prefer, as long as you add the `vue-router`
    to the template when asked.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的喜好回答问题，只要在要求时将`vue-router`添加到模板中即可。
- en: 'We will create two components: one will be our home page and it will be small
    and light, the other component will be very big and very slow to load. What we
    want to achieve is to load the home page immediately, without having to wait for
    the huge component to be downloaded by the browser.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个组件：一个将是我们的主页，它将是小而轻巧的，另一个组件将非常大且加载速度非常慢。我们想要实现的是立即加载主页，而不必等待浏览器下载巨大的组件。
- en: 'Open the `Hello.vue` file in the `components` folder. Delete everything and
    only leave the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`文件夹中打开`Hello.vue`文件。删除所有内容，只留下以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
- en: 'In the same folder, create another file named `Massive.vue` and write the following
    inside it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹中，创建另一个名为`Massive.vue`的文件，并在其中写入以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
- en: Leave an open back tick at the last line because we have to bloat the file with
    a lot of useless data. Save and close `Massive.vue` .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行留下一个打开的反引号，因为我们必须用大量无用的数据膨胀文件。保存并关闭`Massive.vue`。
- en: 'In a console, go to the same directory where the file is stored and use the
    following file to put a lot of garbage into it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，进入与文件存储在同一目录的位置，并使用以下文件将大量垃圾数据放入其中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
- en: What this command does is append the `XXX`  line to the file repeatedly 10⁶
     times; this will add 4 million bytes to the file, making it too huge for a fast
    browsing experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的作用是将`XXX`行重复附加到文件中10⁶次；这将使文件增加400万字节，使其对于快速浏览体验来说太大了。
- en: 'Now we need to close the back tick we opened. Don''t try to open the file now,
    as your text editor may not be capable of opening such a big file; instead, use
    the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要关闭我们打开的反引号。现在不要尝试打开文件，因为你的文本编辑器可能无法打开这么大的文件；相反，使用以下命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
- en: Our `Massive` component is now complete.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Massive`组件现在已经完成。
- en: 'Open the `index.js` inside the `router` folder and add the component and its route:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`router`文件夹中的`index.js`文件，并添加组件及其路由：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
- en: After installing all the dependencies with `npm install` , we are now ready
    to launch our very large app with the `npm run dev`  command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm install`安装所有依赖项后，我们现在可以使用`npm run dev`命令启动我们非常大的应用程序了。
- en: 'The app will load quite fast, but that''s because it''s loading directly from
    your local storage; to simulate a more realistic scenario, open the developer
    tools at the Network tab and select network throttling. Pick something slow, such
    as GPRS or maybe good 3G, which most of us may have:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将加载得非常快，但这是因为它直接从本地存储加载；为了模拟更真实的情况，打开开发者工具的网络选项卡，并选择网络限制。选择一些慢速的网络，比如GPRS或者较好的3G，这是我们大多数人可能拥有的：
- en: '![](img/Image00170.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Now right-click on the refresh button and select Hard Reload to bypass the
    cache (or press *Shift* + *Cmd* + *R* ):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在右键单击刷新按钮，选择强制刷新以绕过缓存（或按*Shift* + *Cmd* + *R*）：
- en: '![](img/Image00171.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: You will notice that the page doesn't load for a few minutes. You can stop the
    loading of the page by clicking on the refresh button again when it becomes an
    X.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到页面在几分钟内不会加载。您可以通过在刷新按钮变成X时再次点击来停止页面的加载。
- en: 'To fix this, go back to the `index.js` file in the `router` folder. Delete
    the following line, where you import the `Massive` component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个问题，请返回到“router”文件夹中的“index.js”文件。删除以下行，其中导入“Massive”组件：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
- en: The preceding line is telling Webpack to include all the code contained in the
    `Massive` component in a single js bundle. Instead, we want to tell Webpack to
    keep the `Massive` component as a separate bundle and to load it only when necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行告诉Webpack将“Massive”组件中包含的所有代码包含在一个js包中。相反，我们希望告诉Webpack将“Massive”组件保持为一个单独的包，并且只在必要时加载它。
- en: 'Instead of directly importing the component, declare `Massive` with the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接导入组件，使用以下代码声明“Massive”：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
- en: Webpack will turn this special syntax into a separate file that will be loaded
    lazily. Save and do another hard refresh with the throttling still set to slow
    speed (like GPRS to good 3G). After a few seconds, you should be able to see the
    hello page. If you want to load the `Massive` component, just add `massive` to
    the URL, but you'll be in for some waiting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将把这个特殊的语法转换成一个单独的文件，它将被懒加载。保存并进行另一个硬刷新，同时将限制速度设置为较慢的速度（如GPRS到良好的3G）。几秒钟后，您应该能够看到hello页面。如果您想加载“Massive”组件，只需将“massive”添加到URL中，但您将需要等待一段时间。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now you obviously won't have such a big component in a real application, but
    you can easily see that if the `Massive` component represents all the other components
    of your app, they can quickly amount to such a big size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显然在真实应用程序中不会有这么大的组件，但您可以很容易地看到，如果“Massive”组件代表应用程序的所有其他组件，它们可能很快达到如此大的大小。
- en: The trick here is to load them asynchronously; Webpack will help you separate
    them into smaller bundles so that they will be loaded only if and when required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是异步加载它们；Webpack将帮助您将它们分成较小的包，以便只在需要时加载。
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is an alternative syntax to import components lazily. It may become an
    ECMA standard in the future, so you should be aware of it. Open `index.js` inside
    the `router` directory and completely remove the import of the `Massive` component
    or the `Massive` constant line we added in this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代的语法可以懒加载导入组件。它可能成为未来的ECMA标准，所以您应该知道它。打开“router”目录中的“index.js”文件，并完全删除对“Massive”组件的导入或我们在这个示例中添加的“Massive”常量行。
- en: 'Inside the routes, try the following when specifying the component for the
    `/massive` route:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由中，尝试在指定“/massive”路由的组件时使用以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
- en: This will be equivalent to what we have done before, because Webpack will take
    the line and instead of directly importing the code of the Massive component,
    it will create a different js file, loaded lazily.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于我们之前所做的，因为Webpack将获取该行，并且不会直接导入Massive组件的代码，而是创建一个不同的js文件，进行懒加载加载。
- en: Building a simple storage for the application state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序状态构建一个简单的存储
- en: In this recipe, you will understand the fundamentals of Vuex when building a
    big application. This recipe is a little unorthodox because to understand how
    Vuex's store work, we will manipulate it directly; you should never do that in
    a real application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将了解在构建大型应用程序时使用Vuex的基本原理。这个示例有点不正规，因为为了理解Vuex存储的工作原理，我们将直接操作它；在真实的应用程序中，您永远不应该这样做。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before trying this recipe, you should complete Making two components talk with
    Vuex  in [*Chapter 4*](text00195.html) ,  *All About Components* .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，您应该完成[*第4章*](text00195.html)中的“使用Vuex使两个组件通信”。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'Create a new project based on the Webpack template with the following command
    run in a new directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新目录中运行以下命令，基于Webpack模板创建一个新项目：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
- en: How you answer the question is not relevant. Run `npm intall`  and install Vuex
    with `npm install vuex --save` or `yarn add vuex` if you use yarn.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何回答这个问题并不重要。运行`npm intall`并使用`npm install vuex --save`或`yarn add vuex`（如果使用yarn）安装Vuex。
- en: 'Open the  `main.js`  file inside the `src` folder and add the following highlighted
    lines to finish installing Vuex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src`文件夹中的`main.js`文件，并添加以下突出显示的行以完成安装Vuex：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
- en: Of course, there is no `store` module right now, so you need to create one.
    To do this, create a folder just under the `src` folder and call it `store` .
    Inside it, create a file named `index.js` . In the `main.js`  file, we didn't
    specify to use the `index.js` file, but that's the default behavior when no file
    is specified but only the folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在没有`store`模块，所以您需要创建一个。为此，请在`src`文件夹下创建一个文件夹，并将其命名为`store`。在其中创建一个名为`index.js`的文件。在`main.js`文件中，我们没有指定使用`index.js`文件，但当没有指定文件而只有文件夹时，这是默认行为。
- en: 'What we will implement is a simplified stock market. We have three assets:
    stars (STAR), lamps (LAMP), and diamonds (DIAM). We will define two routes: one
    for the STAR/LAMP market and another for the LAMP/DIAM market.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个简化的股票市场。我们有三种资产：星星（STAR），灯（LAMP）和钻石（DIAM）。我们将定义两个路线：一个用于STAR/LAMP市场，另一个用于LAMP/DIAM市场。
- en: 'Inside the `index.js` file in the store folder, write the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在store文件夹中的`index.js`文件中编写以下内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
- en: We are creating a new `Vuex` store that will hold our balance. Initially, we
    have 100 of each asset; in the store, the exchange rate between stars and lamps
    and between lamps and diamonds is also fixed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的`Vuex`存储，用于保存我们的余额。最初，我们每种资产有100个；在存储中，星星和灯之间以及灯和钻石之间的汇率也是固定的。
- en: 'Create a new component under the `components` directory, named `Market.vue`
    . It will have the following template:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
- en: '`symbol1` and `symbol2` represent the two assets traded. In the JavaScript
    of this component, where we define the `sell` and `buy` methods, we operate directly
    on the global `Vuex` store:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
- en: You should never touch the state directly like I've done here. You should always
    use mutations. Here, we are skipping the middleman to keep the recipe minimalistic.
    There's more on mutations in the next recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to use this component in `index.js` , inside the `router` folder,
    in the following way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `Market` component for any route that
    contains a couple of trade symbols. As a home page, we are using the STAR/LAMP
    market.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'To display some navigation links to a different market and our current balance,
    we can edit the `App.vue` component with the following template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
- en: We don't need any JavaScript for this component, so you can delete the `<script>`
    tag.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app is now ready; launch it and start trading with it. The following image
    is our completed app without the styles contained in `App.vue` :'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00172.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The balance in the bottom is like a summary of the global state. With Vuex,
    we were able to affect other components by accessing the `$store` variable that
    gets injected in every component by the Vuex plugin. You can easily imagine how
    to use this strategy in a big application when you want to basically expand the
    scope of a variable beyond the component itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Some of the states may be local, for example if you need some animations or
    you need some variables to show modal dialogs for the component; it's perfectly
    okay to not put these values in the store. Otherwise, having a structured centralized
    state in one place helps a lot. In the subsequent recipes, you'll use more advanced
    techniques to exploit the power of Vuex better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vuex mutations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proper way to mutate the state in a Vuex application is with the help of
    mutations. Mutations are a very useful abstraction to decompose state changes
    in the atomic unit. In this recipe, we will explore just that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be completed without knowing too much about Vuex, but completing
    the previous recipe first is suggested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add Vuex as a dependency to your project (the CDN address is `https://unpkg.com/vuex`
    ). I will assume that you are using JSFiddle to follow along; otherwise, just
    remember to put `Vue.use(Vuex)` before the store code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The sample application we will build is to broadcast notifications to the users
    of the website.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML layout looks as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
- en: The idea is to have a textbox to write messages and the broadcasted messages
    will be displayed on the top with the most recent appearing first. The messages
    can be dismissed by clicking on the little x .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build a store that will hold the list of broadcasted messages
    and enumerate the possible mutations we can make to said list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
- en: So, we have a list of messages; we can push one to the top of the list or we
    can remove a message by knowing its index.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to write the logic of the application itself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
- en: 'You can now launch the app and start broadcasting messages to our imaginary
    users:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00173.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think it's important to note the names of the mutations; they are called `pushMessage`
    and `removeMessage` , but what they really do in this application is show the
    message in a stack on the screen and (fictionally) broadcast messages to users.
    Would it be better to call them `showMessage` , or `broadcastMessage` and `hideMessage`
    ? No, that's because there has to be a clear separation of intent between the
    mutation itself and the particular effects of that mutation. The problem becomes
    clear when, for example, we decide to give users the ability to ignore these notifications
    or we introduce a delay before actually broadcasting the notifications. Then we
    will have a `showMessage` mutation that does not actually show a message.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The computed syntax we have used is as illustrated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
- en: You don't have to explicitly use Vuex in your expression when you are importing
    Vuex as an ES6 module. You just need to write
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`import { mapState } from ''Vuex''` .'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `mapState` function will be available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The `mapState` method takes an array of strings as a parameter, looks for a
    `state` variable in the store with the same name as the string, and creates a
    computed property with the same name. You can do this with as many variables as
    you want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you followed along on a local npm project, open the Vue developer tools
    (unfortunately Vue developer tools is not available when using JSFiddle) and you
    will see that a new mutation is issued with each message. Consider that you click
    on the little clock:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00174.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'Y ou can actually undo the mutation with that, as shown in the following illustration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00175.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Note how the state didn't change when clicking the time travel option; that's
    because the purple ribbon is still at the last state. To examine a different state,
    just click on the name of the mutation itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: This debug mechanism is possible because mutations are always synchronous; this
    means that it's possible to take a snapshot of the state before and after the
    mutation and navigate through time. In the next recipe, you will learn how to
    use Vuex to perform asynchronous actions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Listing your actions in Vuex
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All your mutations must be synchronous, so how do you do things such as waiting
    for a timeout or using Axios for an AJAX request? Actions are the next level of
    abstraction that will help you with this. Inside an action, you can commit multiple
    mutations and make asynchronous operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutations are the building blocks of actions, so it's highly suggested you complete
    the preceding recipe before trying this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the setup from the *Building a simple storage for the application
    state*  recipe; you can use your own as well, but in any case this recipe is based
    on a slight modification of the official Webpack template.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will build a clone of the popular Xkcd website. Actually, it will be a wrapper
    more than a real clone, since we will reuse the panels from the website.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Vue project based on the Webpack template with `vue init webpack`
    . The first thing we will do is wire up the API to the Xkcd website in the `index.js`
    inside the `config` folder. Put the following lines inside the `proxyTable` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
- en: This will redirect all the requests we make to `/comic` to the Xkcd website.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src` , make a new `store` directory and an `index.js` inside it; here,
    start building the application store:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
- en: You should import this inside `main.js` like in previous recipes. We want to
    trace the current panel number, the link to the panel image, and the possible
    errors. The only way to modify the state is through mutations, while actions can
    perform asynchronous work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app is loaded, we plan to display the latest comic. For this, we create
    an action:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
- en: 'For this code to work, we need to declare the endpoint and install Axios:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
- en: 'It should be easy for you to write the corresponding mutations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
- en: 'We''ll recycle the `Hello.vue` component and put the following template inside
    it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
- en: 'To make the last panel appear on loading you can use the following JavaScript
    in the component:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can delete most of the `App.vue` template and leave only the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `proxyTable` object will configure the `http-proxy-middleware` . This is
    useful every time we are developing the UI of a bigger web application and we
    launch our developer server on `localhost` , but our API responds to another web
    server. This is especially relevant when we want to use CORS and we don't allow
    other websites to use our API. The Xkcd API doesn't allow `localhost` to consume
    the web service. This is why, even if we try to use the Xkcd API directly, our
    browser won't let us. The `changeOrigin` option will send the request with Xkcd
    as host, making CORS unnecessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: To call an action from a component, we used the `dispatch` function. It's also
    possible to pass the second argument, the first being the name of the action itself.
    The second argument is then passed when you define the action as the second parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: A last note on the naming--it being implicit that actions are asynchronous while
    mutations are synchronous, there is no need, in my opinion, to make the asynchronicity
    in the name of the actions explicit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Separating concerns with modules
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building big applications, the Vuex store can become crowded. Luckily,
    it's possible to divide the different concerns of the applications into separate
    compartments with modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be a reference if you want to use modules. You are expected
    to already know enough about Vuex.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, you will have to be a little familiar with Webpack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will model a fully functional human body in a slightly simplified
    manner. Every organ will have a separate module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Webpack template with `vue init webpack`  and `npm install vuex`
    . Create a new directory with the `src/store/index.js`  file in it. Inside, write
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
- en: 'The `heart` module is like this; put it before the store declaration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
- en: Note how the state passed inside the mutations is not the root state, but the
    local state of the module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes the brain, which is divided into the left and right lobes; write
    the following before the store:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
- en: 'You can implement them as simple Boolean states (write them before the brain
    on which they depend):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
- en: Setting `namespaced`  to true modifies the way you can call the mutator. Since
    they are both called `toggle` , now you can specify which lobe, for example, for
    the left lobe the mutation string becomes `left/toggle` , where `left`  says it
    is the key used in the brain to refer to the left lobe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To see your store in action, you can create a component that uses all the mutations.
    For the brain, we can have two pictures of the lobes, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
- en: 'This will create two drawings of brain lobes in red pencil; note the use of
    the name of the modules in a nested way. The following `off` CSS rule grays the
    lobes out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
- en: 'To call the mutations, we use the aforementioned strings in the right methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an input textbox and call the other two mutations, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
- en: 'This was very easy, but how do you retrieve the loved name? You can put these
    mustachios in your template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
- en: 'You obviously have to declare the `partner` variable on your Vue instance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00177.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use modules to split your application concerns into different
    units. This ability may become important as the project grows in size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The common pattern is that while inside a mutation, you have direct access
    to the local state:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
- en: 'In a mutation, it makes sense to have access only to the local state. The brain,
    for example, cannot change the heart and vice versa, but what about actions? If
    we declare an action inside a module, we are passed an object called context that
    looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
- en: 'So, if we want to declare an action in the left lobe and we want to affect
    the heart, we have to do something like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
- en: Building getters to help retrieve your data
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't want to keep too much data in your state. It can be especially dangerous
    to keep duplicate or derivative data because it can be brought out of sync very
    easily. Getters help you with this without shifting the burden onto the components
    by keeping all the logic in one place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is for you if you already have some Vuex knowledge and want to expand
    your horizons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are building a Bitcoin wallet. You want to give your users
    an overview of their balance, and you want them to see how many Euros it corresponds
    to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Webpack template with `vue init webpack`  and `npm install vuex`
    . Create a new `src/store/index.js`  file and write the following inside it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
- en: This code is prone to errors. The first error can be a miscalculation of the
    Euro amount if we don't get the multiplication right. The second kind of error
    can be that we tell the user the `bitcoin` and `euro` balance during a transaction,
    resulting in a stale and wrong amount for one of the two.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To tackle these issues, we use `getters` :'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
- en: This way the `euro` amount is never in the state but always computed. Moreover,
    it is centralized in the store, so we don't need to add anything to our components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s easy to retrieve the two amounts from a template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
- en: Here, `&#3647 ;`  is the HTML entity for the Bitcoin symbol.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a `getter` for derived data is always a good idea if we are not talking
    about input data. A notable feature of getters we have not yet discussed is their
    ability to interact with other getters and take an argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Accessing other getters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second argument passed to a getter when called is the object that contains
    the other `getters` :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
- en: 'In our recipe, we could call the `euro` getter to have some more derived data,
    like roughly how many houses we can buy with our Bitcoin given an average price
    of 150,000 euros:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
- en: Passing an argument
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a getter returns a function with an argument, that argument will be the
    argument of the getter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
- en: 'In our recipe, a practical example could specify the average cost of a house
    in the getter from the previous paragraph:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
- en: Testing your store
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know from [*Chapter 7*](text00346.html) , *Unit Testing and End-To-End
    Testing* , testing is the most important part of professional software. As the
    store often defines the business logic of your application, testing it may be
    vital for your application. In this recipe, you will write tests for a Vuex store.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires knowledge from [*Chapter 7*](text00346.html) , *Unit Testing
    and End-To-End Testing* and familiarity with Vuex; you can get it from the earlier recipes
    of this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, I'll define some features that our store must implement; then you will
    write tests that prove that the features are present and working.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Software requirements
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our store consists of items in a to-do list, like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
- en: 'We have two requirements:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We must have an `MARK_ITEM_AS_DONE` mutation that changes the `done` field from
    false to true
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a `downloadNew`  action that downloads the latest items from our
    server and adds them to the list
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing mutations
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to test your mutations, you have to make them available for your
    test files. To do this, you have to extract the mutation object from your store.
    Consider something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
- en: 'You have to extract it to something similar to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
- en: 'This way, you can import the mutations in your test files with the following
    line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
- en: 'The test for requirement number 1 can be written as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
- en: If you are using the official Webpack template, you can run your tests with
    `npm run unit` . This uses PhantomJS by default, which doesn't implement some
    features. You can either use Babel polyfills or simply go into `karma.conf.js`
    and write `Chrome`  instead of `PhantomJS`  in the `browsers` array. Remember
    to install the Chrome launcher with `npm install karma-chrome-launcher --save-dev`
    .
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Testing actions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing actions** means testing that the action commits the expected mutations.
    We are not interested in the mutations themselves (not in unit tests at least)
    because they are already tested separately. We might, though, need to mock some
    dependencies.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any dependencies from Vue or Vuex (since we don''t need them and they
    may pollute the tests), we create a new `actions.js` file inside the `store` directory.
    Install Axios with `npm install axios` . The  `actions.js` file can look like
    the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
- en: 'To test for requirement number 2, we start by mocking the call to the server
    that should download the new to-do items:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
- en: This will ensure that any call to the get method of `axios` will always return
    a new to-do item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we want to ensure that the `ADD_ITEMS` mutation is called upon dispatch:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the testing of the mutations is pretty straightforward, I think the testing
    of the actions deserves some more explaining.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Since we didn't want to depend on external services for actions, we had to mock
    the `axios` service. We used the `inject-loader` , which takes the original library
    and mocks the parts we specify with arbitrary code (the `@` symbol is a shorthand
    for `src` ); in our case, we mocked the `axios` library and, precisely, the `get`
    method. We had to use the CommonJS syntax (with the `require` ) because that's
    the only way to tell Webpack to use loaders in imports.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: What we have done in the test is that we also mocked the `commit` function.
    Normally, this function calls a mutation that modifies the state. We just want
    to know if the correct mutation is called and with the right arguments. Moreover,
    we had to wrap everything in a `try` block; without it, the test would fail over
    a timeout and we'd lose the error. Instead, now we fail immediately and we can
    read, from the console, what error caused the test to fail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
