- en: Large Application Patterns with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading pages in your vue-router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple storage for the application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Vuex mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing your actions in Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating concerns with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building getters to help retrieve your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how Vuex works and how to use it to support
    a scalable application. Vuex implements a pattern that is popular in frontend
    frameworks and consists of dividing the different concerns to manage a big global
    application state. The mutations are the only things that can change the state,
    so you have only one place to look for that. Much of the logic, along with all
    the asynchronous logic, is contained in the actions; finally, getters and modules
    further help to spread the cognitive load when it comes to computing the derived
    state and splitting your code into different files.
  prefs: []
  type: TYPE_NORMAL
- en: Along with recipes, you will find grains of wisdom that I found useful when
    developing real large applications; some have to do with naming conventions and
    others with little tricks to avoid bugs.
  prefs: []
  type: TYPE_NORMAL
- en: If you complete all the recipes, you will be ready to develop big frontend applications
    with fewer bugs and seamless collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading pages in your vue-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Soon, you will build huge Vue websites with loads of components. Loading a lot
    of JavaScript may generate wasteful and useless upfront delay. In the *Loading
    your components asynchronously*  recipe in [Chapter 4](text00195.html) , *All
    About Components* , we already saw a hint of how to retrieve our components remotely.
    Here we will apply a similar technique to components loaded by a route in vue-router.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires knowledge of vue-router. If you want, you can go through *Loading
    your components asynchronously*  in  [Chapter 4](text00195.html) , *All About
    Components* , to get a better idea of what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project with `vue-cli` by making a new directory and running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can answer the question as you prefer, as long as you add the `vue-router`
    to the template when asked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create two components: one will be our home page and it will be small
    and light, the other component will be very big and very slow to load. What we
    want to achieve is to load the home page immediately, without having to wait for
    the huge component to be downloaded by the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Hello.vue` file in the `components` folder. Delete everything and
    only leave the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same folder, create another file named `Massive.vue` and write the following
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Leave an open back tick at the last line because we have to bloat the file with
    a lot of useless data. Save and close `Massive.vue` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In a console, go to the same directory where the file is stored and use the
    following file to put a lot of garbage into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What this command does is append the `XXX`  line to the file repeatedly 10⁶
     times; this will add 4 million bytes to the file, making it too huge for a fast
    browsing experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to close the back tick we opened. Don''t try to open the file now,
    as your text editor may not be capable of opening such a big file; instead, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `Massive` component is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.js` inside the `router` folder and add the component and its route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After installing all the dependencies with `npm install` , we are now ready
    to launch our very large app with the `npm run dev`  command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will load quite fast, but that''s because it''s loading directly from
    your local storage; to simulate a more realistic scenario, open the developer
    tools at the Network tab and select network throttling. Pick something slow, such
    as GPRS or maybe good 3G, which most of us may have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00170.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now right-click on the refresh button and select Hard Reload to bypass the
    cache (or press *Shift* + *Cmd* + *R* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00171.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that the page doesn't load for a few minutes. You can stop the
    loading of the page by clicking on the refresh button again when it becomes an
    X.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, go back to the `index.js` file in the `router` folder. Delete
    the following line, where you import the `Massive` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line is telling Webpack to include all the code contained in the
    `Massive` component in a single js bundle. Instead, we want to tell Webpack to
    keep the `Massive` component as a separate bundle and to load it only when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of directly importing the component, declare `Massive` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Webpack will turn this special syntax into a separate file that will be loaded
    lazily. Save and do another hard refresh with the throttling still set to slow
    speed (like GPRS to good 3G). After a few seconds, you should be able to see the
    hello page. If you want to load the `Massive` component, just add `massive` to
    the URL, but you'll be in for some waiting.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you obviously won't have such a big component in a real application, but
    you can easily see that if the `Massive` component represents all the other components
    of your app, they can quickly amount to such a big size.
  prefs: []
  type: TYPE_NORMAL
- en: The trick here is to load them asynchronously; Webpack will help you separate
    them into smaller bundles so that they will be loaded only if and when required.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an alternative syntax to import components lazily. It may become an
    ECMA standard in the future, so you should be aware of it. Open `index.js` inside
    the `router` directory and completely remove the import of the `Massive` component
    or the `Massive` constant line we added in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the routes, try the following when specifying the component for the
    `/massive` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will be equivalent to what we have done before, because Webpack will take
    the line and instead of directly importing the code of the Massive component,
    it will create a different js file, loaded lazily.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple storage for the application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will understand the fundamentals of Vuex when building a
    big application. This recipe is a little unorthodox because to understand how
    Vuex's store work, we will manipulate it directly; you should never do that in
    a real application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before trying this recipe, you should complete Making two components talk with
    Vuex  in [*Chapter 4*](text00195.html) ,  *All About Components* .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project based on the Webpack template with the following command
    run in a new directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How you answer the question is not relevant. Run `npm intall`  and install Vuex
    with `npm install vuex --save` or `yarn add vuex` if you use yarn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the  `main.js`  file inside the `src` folder and add the following highlighted
    lines to finish installing Vuex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there is no `store` module right now, so you need to create one.
    To do this, create a folder just under the `src` folder and call it `store` .
    Inside it, create a file named `index.js` . In the `main.js`  file, we didn't
    specify to use the `index.js` file, but that's the default behavior when no file
    is specified but only the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will implement is a simplified stock market. We have three assets:
    stars (STAR), lamps (LAMP), and diamonds (DIAM). We will define two routes: one
    for the STAR/LAMP market and another for the LAMP/DIAM market.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `index.js` file in the store folder, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a new `Vuex` store that will hold our balance. Initially, we
    have 100 of each asset; in the store, the exchange rate between stars and lamps
    and between lamps and diamonds is also fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component under the `components` directory, named `Market.vue`
    . It will have the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`symbol1` and `symbol2` represent the two assets traded. In the JavaScript
    of this component, where we define the `sell` and `buy` methods, we operate directly
    on the global `Vuex` store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should never touch the state directly like I've done here. You should always
    use mutations. Here, we are skipping the middleman to keep the recipe minimalistic.
    There's more on mutations in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to use this component in `index.js` , inside the `router` folder,
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `Market` component for any route that
    contains a couple of trade symbols. As a home page, we are using the STAR/LAMP
    market.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display some navigation links to a different market and our current balance,
    we can edit the `App.vue` component with the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We don't need any JavaScript for this component, so you can delete the `<script>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app is now ready; launch it and start trading with it. The following image
    is our completed app without the styles contained in `App.vue` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00172.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The balance in the bottom is like a summary of the global state. With Vuex,
    we were able to affect other components by accessing the `$store` variable that
    gets injected in every component by the Vuex plugin. You can easily imagine how
    to use this strategy in a big application when you want to basically expand the
    scope of a variable beyond the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the states may be local, for example if you need some animations or
    you need some variables to show modal dialogs for the component; it's perfectly
    okay to not put these values in the store. Otherwise, having a structured centralized
    state in one place helps a lot. In the subsequent recipes, you'll use more advanced
    techniques to exploit the power of Vuex better.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vuex mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proper way to mutate the state in a Vuex application is with the help of
    mutations. Mutations are a very useful abstraction to decompose state changes
    in the atomic unit. In this recipe, we will explore just that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be completed without knowing too much about Vuex, but completing
    the previous recipe first is suggested.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add Vuex as a dependency to your project (the CDN address is `https://unpkg.com/vuex`
    ). I will assume that you are using JSFiddle to follow along; otherwise, just
    remember to put `Vue.use(Vuex)` before the store code.
  prefs: []
  type: TYPE_NORMAL
- en: The sample application we will build is to broadcast notifications to the users
    of the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML layout looks as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to have a textbox to write messages and the broadcasted messages
    will be displayed on the top with the most recent appearing first. The messages
    can be dismissed by clicking on the little x .
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build a store that will hold the list of broadcasted messages
    and enumerate the possible mutations we can make to said list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, we have a list of messages; we can push one to the top of the list or we
    can remove a message by knowing its index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to write the logic of the application itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now launch the app and start broadcasting messages to our imaginary
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00173.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think it's important to note the names of the mutations; they are called `pushMessage`
    and `removeMessage` , but what they really do in this application is show the
    message in a stack on the screen and (fictionally) broadcast messages to users.
    Would it be better to call them `showMessage` , or `broadcastMessage` and `hideMessage`
    ? No, that's because there has to be a clear separation of intent between the
    mutation itself and the particular effects of that mutation. The problem becomes
    clear when, for example, we decide to give users the ability to ignore these notifications
    or we introduce a delay before actually broadcasting the notifications. Then we
    will have a `showMessage` mutation that does not actually show a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computed syntax we have used is as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You don't have to explicitly use Vuex in your expression when you are importing
    Vuex as an ES6 module. You just need to write
  prefs: []
  type: TYPE_NORMAL
- en: '`import { mapState } from ''Vuex''` .'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `mapState` function will be available.
  prefs: []
  type: TYPE_NORMAL
- en: The `mapState` method takes an array of strings as a parameter, looks for a
    `state` variable in the store with the same name as the string, and creates a
    computed property with the same name. You can do this with as many variables as
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you followed along on a local npm project, open the Vue developer tools
    (unfortunately Vue developer tools is not available when using JSFiddle) and you
    will see that a new mutation is issued with each message. Consider that you click
    on the little clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00174.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Y ou can actually undo the mutation with that, as shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00175.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how the state didn't change when clicking the time travel option; that's
    because the purple ribbon is still at the last state. To examine a different state,
    just click on the name of the mutation itself.
  prefs: []
  type: TYPE_NORMAL
- en: This debug mechanism is possible because mutations are always synchronous; this
    means that it's possible to take a snapshot of the state before and after the
    mutation and navigate through time. In the next recipe, you will learn how to
    use Vuex to perform asynchronous actions.
  prefs: []
  type: TYPE_NORMAL
- en: Listing your actions in Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All your mutations must be synchronous, so how do you do things such as waiting
    for a timeout or using Axios for an AJAX request? Actions are the next level of
    abstraction that will help you with this. Inside an action, you can commit multiple
    mutations and make asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutations are the building blocks of actions, so it's highly suggested you complete
    the preceding recipe before trying this.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the setup from the *Building a simple storage for the application
    state*  recipe; you can use your own as well, but in any case this recipe is based
    on a slight modification of the official Webpack template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will build a clone of the popular Xkcd website. Actually, it will be a wrapper
    more than a real clone, since we will reuse the panels from the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Vue project based on the Webpack template with `vue init webpack`
    . The first thing we will do is wire up the API to the Xkcd website in the `index.js`
    inside the `config` folder. Put the following lines inside the `proxyTable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will redirect all the requests we make to `/comic` to the Xkcd website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src` , make a new `store` directory and an `index.js` inside it; here,
    start building the application store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should import this inside `main.js` like in previous recipes. We want to
    trace the current panel number, the link to the panel image, and the possible
    errors. The only way to modify the state is through mutations, while actions can
    perform asynchronous work.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app is loaded, we plan to display the latest comic. For this, we create
    an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For this code to work, we need to declare the endpoint and install Axios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be easy for you to write the corresponding mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll recycle the `Hello.vue` component and put the following template inside
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the last panel appear on loading you can use the following JavaScript
    in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can delete most of the `App.vue` template and leave only the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `proxyTable` object will configure the `http-proxy-middleware` . This is
    useful every time we are developing the UI of a bigger web application and we
    launch our developer server on `localhost` , but our API responds to another web
    server. This is especially relevant when we want to use CORS and we don't allow
    other websites to use our API. The Xkcd API doesn't allow `localhost` to consume
    the web service. This is why, even if we try to use the Xkcd API directly, our
    browser won't let us. The `changeOrigin` option will send the request with Xkcd
    as host, making CORS unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: To call an action from a component, we used the `dispatch` function. It's also
    possible to pass the second argument, the first being the name of the action itself.
    The second argument is then passed when you define the action as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: A last note on the naming--it being implicit that actions are asynchronous while
    mutations are synchronous, there is no need, in my opinion, to make the asynchronicity
    in the name of the actions explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Separating concerns with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building big applications, the Vuex store can become crowded. Luckily,
    it's possible to divide the different concerns of the applications into separate
    compartments with modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be a reference if you want to use modules. You are expected
    to already know enough about Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, you will have to be a little familiar with Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will model a fully functional human body in a slightly simplified
    manner. Every organ will have a separate module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Webpack template with `vue init webpack`  and `npm install vuex`
    . Create a new directory with the `src/store/index.js`  file in it. Inside, write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `heart` module is like this; put it before the store declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note how the state passed inside the mutations is not the root state, but the
    local state of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes the brain, which is divided into the left and right lobes; write
    the following before the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can implement them as simple Boolean states (write them before the brain
    on which they depend):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Setting `namespaced`  to true modifies the way you can call the mutator. Since
    they are both called `toggle` , now you can specify which lobe, for example, for
    the left lobe the mutation string becomes `left/toggle` , where `left`  says it
    is the key used in the brain to refer to the left lobe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see your store in action, you can create a component that uses all the mutations.
    For the brain, we can have two pictures of the lobes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create two drawings of brain lobes in red pencil; note the use of
    the name of the modules in a nested way. The following `off` CSS rule grays the
    lobes out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the mutations, we use the aforementioned strings in the right methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an input textbox and call the other two mutations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This was very easy, but how do you retrieve the loved name? You can put these
    mustachios in your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You obviously have to declare the `partner` variable on your Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00177.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use modules to split your application concerns into different
    units. This ability may become important as the project grows in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common pattern is that while inside a mutation, you have direct access
    to the local state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In a mutation, it makes sense to have access only to the local state. The brain,
    for example, cannot change the heart and vice versa, but what about actions? If
    we declare an action inside a module, we are passed an object called context that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we want to declare an action in the left lobe and we want to affect
    the heart, we have to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Building getters to help retrieve your data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't want to keep too much data in your state. It can be especially dangerous
    to keep duplicate or derivative data because it can be brought out of sync very
    easily. Getters help you with this without shifting the burden onto the components
    by keeping all the logic in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is for you if you already have some Vuex knowledge and want to expand
    your horizons.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are building a Bitcoin wallet. You want to give your users
    an overview of their balance, and you want them to see how many Euros it corresponds
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Webpack template with `vue init webpack`  and `npm install vuex`
    . Create a new `src/store/index.js`  file and write the following inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code is prone to errors. The first error can be a miscalculation of the
    Euro amount if we don't get the multiplication right. The second kind of error
    can be that we tell the user the `bitcoin` and `euro` balance during a transaction,
    resulting in a stale and wrong amount for one of the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tackle these issues, we use `getters` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This way the `euro` amount is never in the state but always computed. Moreover,
    it is centralized in the store, so we don't need to add anything to our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s easy to retrieve the two amounts from a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, `&#3647 ;`  is the HTML entity for the Bitcoin symbol.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a `getter` for derived data is always a good idea if we are not talking
    about input data. A notable feature of getters we have not yet discussed is their
    ability to interact with other getters and take an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing other getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second argument passed to a getter when called is the object that contains
    the other `getters` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In our recipe, we could call the `euro` getter to have some more derived data,
    like roughly how many houses we can buy with our Bitcoin given an average price
    of 150,000 euros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Passing an argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a getter returns a function with an argument, that argument will be the
    argument of the getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In our recipe, a practical example could specify the average cost of a house
    in the getter from the previous paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Testing your store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know from [*Chapter 7*](text00346.html) , *Unit Testing and End-To-End
    Testing* , testing is the most important part of professional software. As the
    store often defines the business logic of your application, testing it may be
    vital for your application. In this recipe, you will write tests for a Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires knowledge from [*Chapter 7*](text00346.html) , *Unit Testing
    and End-To-End Testing* and familiarity with Vuex; you can get it from the earlier recipes
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, I'll define some features that our store must implement; then you will
    write tests that prove that the features are present and working.
  prefs: []
  type: TYPE_NORMAL
- en: Software requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our store consists of items in a to-do list, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have an `MARK_ITEM_AS_DONE` mutation that changes the `done` field from
    false to true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a `downloadNew`  action that downloads the latest items from our
    server and adds them to the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to test your mutations, you have to make them available for your
    test files. To do this, you have to extract the mutation object from your store.
    Consider something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to extract it to something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, you can import the mutations in your test files with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for requirement number 1 can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you are using the official Webpack template, you can run your tests with
    `npm run unit` . This uses PhantomJS by default, which doesn't implement some
    features. You can either use Babel polyfills or simply go into `karma.conf.js`
    and write `Chrome`  instead of `PhantomJS`  in the `browsers` array. Remember
    to install the Chrome launcher with `npm install karma-chrome-launcher --save-dev`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Testing actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing actions** means testing that the action commits the expected mutations.
    We are not interested in the mutations themselves (not in unit tests at least)
    because they are already tested separately. We might, though, need to mock some
    dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any dependencies from Vue or Vuex (since we don''t need them and they
    may pollute the tests), we create a new `actions.js` file inside the `store` directory.
    Install Axios with `npm install axios` . The  `actions.js` file can look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To test for requirement number 2, we start by mocking the call to the server
    that should download the new to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that any call to the get method of `axios` will always return
    a new to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we want to ensure that the `ADD_ITEMS` mutation is called upon dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the testing of the mutations is pretty straightforward, I think the testing
    of the actions deserves some more explaining.
  prefs: []
  type: TYPE_NORMAL
- en: Since we didn't want to depend on external services for actions, we had to mock
    the `axios` service. We used the `inject-loader` , which takes the original library
    and mocks the parts we specify with arbitrary code (the `@` symbol is a shorthand
    for `src` ); in our case, we mocked the `axios` library and, precisely, the `get`
    method. We had to use the CommonJS syntax (with the `require` ) because that's
    the only way to tell Webpack to use loaders in imports.
  prefs: []
  type: TYPE_NORMAL
- en: What we have done in the test is that we also mocked the `commit` function.
    Normally, this function calls a mutation that modifies the state. We just want
    to know if the correct mutation is called and with the right arguments. Moreover,
    we had to wrap everything in a `try` block; without it, the test would fail over
    a timeout and we'd lose the error. Instead, now we fail immediately and we can
    read, from the console, what error caused the test to fail.
  prefs: []
  type: TYPE_NORMAL
