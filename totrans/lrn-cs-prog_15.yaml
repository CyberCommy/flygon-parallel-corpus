- en: '*Chapter 15*: New Features of C# 8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a mature programming language, but it is still evolving to satisfy new
    requirements coming from emergent software architectures. The main focus of most
    of the four language versions of C# 7 is on providing the tools for impressive
    performance when using value types.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the latest version, C# 8 introduces many new important features focusing
    on four main areas: making code more compact and easier to read, along with performance,
    robustness, and expressivity. The fundamental change in C# 8 is that it is the
    first release of the language without official support in .NET Framework because
    some of its features require the .NET Core runtime enhancements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following new language features:'
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default implementation of interface members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges and indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The using declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous Dispose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disposable patterns in structs and ref structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only struct members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null coalescing assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static local functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better interpolated verbatim strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using stackalloc in nested expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmanaged constructed types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the use cases for using each
    of these features and be able to progressively adopt them in your listings. As
    always, the more you put these features into practice, the sooner you will master
    them.
  prefs: []
  type: TYPE_NORMAL
- en: We will now start with a language feature that has the great ambition of reducing
    one of the primary causes of crashes in .NET-based applicationsâ€”`NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned that the type system in C# is split into
    **reference types** and **value types**. Value types are allocated on the stack
    and subject to memory copies every time they are assigned to a new variable. On
    the other hand, reference types are allocated on the heap, which is managed by
    the garbage collector. Every time we allocate a new reference type, we receive
    a reference acting as a key to identify the allocated memory back from the garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: The reference is essentially a pointer that can assume the special null value,
    which is the simplest, and therefore most popular, way to indicate the absence
    of a value. Remember, instead of using the null value, another solution is to
    adopt the special case architectural pattern, which, in its simplest form, is
    an instance of that object with a Boolean field indicating whether the object
    is valid, which is how `Nullable<T>` works. In many other cases, developers don't
    really need to use null values, the validation of which requires a remarkable
    amount of code that will affect runtime performance as well.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the null reference is that the compiler can't argue about potential
    problems because it is syntactically correct, but dereferencing it at runtime
    will lead to a `NullReferenceException`, which is the first cause for application
    crashes in the .NET world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider for a moment a simple class with two constructors, where only
    the second one initializes the `_name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When the first constructor is used, the `NameLength` property will cause a `NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of tests, this is the code that highlights the following two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The fundamental problem is that our code behavior depends on the values assumed
    at runtime, and obviously, the compiler cannot know if we will ever initialize
    the `_name` field after calling the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: The null reference is a concept invented by Sir Tony Hoare in 1965\. However,
    in 2009, he regretted his invention, calling it *my billion-dollar mistak*[*e*
    (https://en.wikipedia.org/wiki/Tony_Ho](https://en.wikipedia.org/wiki/Tony_Hoare)are).
    As nulls cannot be easily removed from a framework, nullable reference types aim
    to resolve the problem using a code analysis approach.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is widespread in most programming languages, including all the
    ones in the .NET ecosystem. This means that any effort to remove the null concept
    from the framework would be a huge breaking change, potentially destroying current
    applications. What can the compiler do to resolve this problem? The answer is
    to undertake *static code analysis*, a technique used to understand the runtime
    behavior of the source code without running it.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: In 2011, Microsoft started working on a revolutionary project called `Microsoft.CodeAnalysis`)
    is the ability to expose the APIs for all the processing normally done by the
    compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, compilers are black boxes, but Roslyn makes it possible to programmatically
    parse the source code, get the syntax and semantic trees, use visitors to retrieve
    or rewrite specific nodes, and analyze the semantics of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already seen static code analysis at work in Visual Studio when
    the yellow light bulb or the squiggles underneath some code suggest some refactoring
    or a potential issue in the editor. These abilities can be further extended by
    writing custom analyzers, distributed as Visual Studio extensions or in NuGet
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since static code analysis can''t know the value assumed by a reference at
    runtime, it just examines all the possible usage paths and tries to tell if one
    of those may dereference (using the dot or the square brackets) a null reference.
    But the analysis can suggest two different strategies, depending on whether it
    is desirable or not for the reference to assume the null value:'
  prefs: []
  type: TYPE_NORMAL
- en: We may want to prevent a reference from ever assuming the null value. In this
    case, the analyzer would suggest initializing at declaration or construction time
    and on any other following assignments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may need the reference to assume the null value. In this other case, the
    analyzer will verify that there is adequate null-checking code (an `if` statement
    or similar) to avoid any possible path that could dereference a null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice between these two strategies is the developer's choice, who is called
    to provide additional information so that the compiler knows which feedback it
    should provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# 8 nullable reference types feature ships the advanced static code analysis
    feature supporting both strategies, thanks to the ability to annotate the references
    to inform the compiler about the intended reference usage. For this purpose, the
    C# syntax has been extended to provide the ability to decorate the reference types
    as potentially nullable. Under this new rule, the string field declared in the
    previous sample class assumes that the reference cannot be null and must be initialized
    at construction time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When developers wants to give a hint to the compiler on the `_name` reference
    to potentially be null, they must declare it with a question mark decoration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the question mark character as a decorator is not new; it was introduced
    in C# 2 to shorten the `Nullable<T>` declaration to `T?` and consisted of wrapping
    a *value type* into a structure using a Boolean field to know whether a value
    type is set to null.
  prefs: []
  type: TYPE_NORMAL
- en: The question mark decoration for reference types is new in C# 8 and its meaning
    is similar, but no wrapper is involved. Instead, this decoration is just a way
    to inform the code analysis about the intended use of the reference.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the code analysis is turned *off* because the existing applications
    always assumed that any reference could be null, and enabling it by default on
    the existing code would result in a large number of squiggles and compiler messages
    all over the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a reference is decorated with the question mark and the nullable reference
    types feature is not yet enabled, Visual Studio will squiggle the question mark
    in green, advising that the question mark functionality isn't in effect, as the
    feature is not active.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the question mark, C# adds the **forgiving operator**, represented
    by an *exclamation mark*, which is used to inform the code analysis to *forgive*
    a statement for that specific case. Using the forgiving operator is rare because
    it means the analysis has failed to recognize a case where the developer themselves
    knows the reference cannot be null. A realistic example of its usage is when some
    unsafe/native code changes the memory values pointed by a reference without any
    evidence in the managed code. In other very edge cases, the pure managed code
    can be so complex that the compiler fails to recognize it. I would personally
    opt to simplify the code instead of using the forgiving operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the *question mark* is used while declaring the *reference*,
    while the *exclamation mark* is used when *dereferencing* it. The following example
    shows a statement that will not be analyzed from the static code analysis and
    will not provide any feedback because the developer is making a strong promise
    that the reference will never be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is worth repeating that it should be used only in extremely rare cases.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the nullable reference type feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple options to enable this feature; the reason to do so is to
    be able to progressively adapt the feature on existing code without being blocked
    or receiving a huge amount of messages. Every time you start with a new project,
    you may want to fully enable this feature to avoid excessive annoyance by opening
    the Visual Studio solution explorer, double-clicking the project node, and editing
    the `.csproj` file. Alternatively, you can right-click the project node and select
    **Edit Project File** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding the nullable XML tag, the feature will be enabled for the entire
    project, which is the best option when starting a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same on an existing project, but the amount of feedback provided
    by the compiler may be excessive, distracting the developer. For this reason,
    the C# compiler provides four new pragma directives, making it possible to enable
    and disable the feature for selected portions of the code. Interestingly, the
    restore pragma restores the previously defined setting to allow nesting of the
    pragma directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The range of possible settings for this feature enables some other nuances,
    depending on whether you want to be able to use the decorations (question and
    exclamation marks) and/or get the warnings on code that may potentially cause
    a `NullReferenceException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enabling both the warnings and annotations**: This is done by just enabling
    the feature, as we mentioned previously. Under this rule, the code can be annotated
    with the question mark to hint to the compiler about the intended usage of the
    references. The code editor will show any potential problem and the compiler will
    generate warnings for those issues:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Nullable` feature either on the whole project or on selected portions of the
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Enabling only the annotations but not the compiler warnings**: When you are
    adopting this feature in existing projects, it can be very useful to start annotating
    the code without receiving any warning in the IDE or in the compiler output. It''s
    worth remembering that many companies enforce gated check-ins, rejecting any code
    producing warnings. In this case, it can be useful to enable the annotations project-wide,
    and enable the warnings file by file, to progressively migrate the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`NullReferenceException`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Restoring the previous settings in the code (only in code files)**: When
    using pragmas, it is always better to mark the end of a given region using a restore
    pragma, instead of an enable/disable, to make nested regions behave correctly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Selectively disabling the settings (only in code files)**: The final setting
    is the one used to selectively disable either the annotations or the warnings
    in a given region of code. It is useful when you want to apply inverse logic,
    that is, enabling the feature for the whole project and disabling only selected
    portions of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This fine-grained ability to control the nullable reference types feature is
    very important when adopting this feature in existing projects. Outside that,
    you may find it simpler to just enable it project-wide.
  prefs: []
  type: TYPE_NORMAL
- en: Working with nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once enabled, the code analysis provides feedback in the code editor, which
    differs depending on whether the reference has been decorated with the question
    mark. The developer may choose not to decorate the variable, implying that the
    reference should never assume the null value. In this case, the declaration looks
    very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the code analysis will squiggle the constructor code that is responsible
    for not initializing the string that, in the absence of the question mark, cannot
    be null. The remedies, in this case, are straightforward: you can either initialize
    the `_name` variable to an empty string or remove the default constructor, forcing
    all the callers to provide a non-nullable string at the creation of the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other strategy is to declare the `_name` variable as nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code analysis will show the green squiggle when dereferencing the `Length`
    property. In this case, the solution is to explicitly check for `_name` being
    null and return an appropriate value (or throw an exception). This is a possible
    implementation for the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an alternative and more elegant implementation of the same
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotating code is simple as it resembles the strategy already used with the
    nullable types, but with the arrays, the decoration is slightly more complex since
    there are two possible reference types in the game: the array itself and the items
    held in the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An array of strings can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But remember, the more question marks we use, the more checks for null we need
    to do. Let''s consider this simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Count` property is short only because we used a modern compact syntax,
    but it still contains a null check. `GetItemLength` returns the length of the
    *n*th item held in the array, and since both the arrays and the items could be
    null, two different null checks are required.
  prefs: []
  type: TYPE_NORMAL
- en: If you are thinking to just return `string?` as the return type of the `GetItemLength`
    method, this solution will make the implementation code a bit shorter but all
    the callers will be forced to check for nulls, requiring even more code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating existing code to nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every project has its own characteristics, but from my personal experience,
    I've managed to identify a couple of best practices when migrating existing projects
    to this powerful feature.
  prefs: []
  type: TYPE_NORMAL
- en: The first suggestion is to start enabling this feature from the project at the
    bottom of the dependency tree. In the project context, you may want to enable
    the analysis using pragma directives, starting from the most frequently used code
    files, such as helpers, extension methods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second suggestion is to try avoiding the question mark: every time you
    decorate the reference with the question mark, the code analysis will require
    you to write some code to provide proof that a null dereferencing cannot occur,
    incrementing the amount of boilerplate code, which can affect the performance
    of the hot paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, when you compile a library using this feature, the compiler will apply
    two hidden attributes to leave a track in the metadata about the nullability of
    the references used publicly in your code. Every time some code referencing your
    library is compiled, the compiler will know whether the library methods accept
    nullable references or not, assuming a not-nullable reference parameter only if
    the attribute specifically advertises that. It is therefore a best practice to
    use this feature on public libraries so that others can benefit from this metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The nullable reference types are very useful to decrease the amount of `NullReferenceException`
    exceptions at runtime, which is the primary cause for an application to crash.
  prefs: []
  type: TYPE_NORMAL
- en: While this feature is optional, it is very convenient to use pragma directives
    to progressively apply the small changes required for the code to be null-proof.
    This is a typical task that any team should add to its technical debts to improve
    code quality. In addition to that, library authors embracing this feature automatically
    provide the nullability metadata in their libraries, making the whole chain of
    references more stable.
  prefs: []
  type: TYPE_NORMAL
- en: Default implementation of interface members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned that interfaces are used to define a contract that every
    implementing type must fulfill. Every interface member defines a portion of the
    contract by specifying a name and its signature (input and output parameters).
    The implementation (or body) of the defined members are then provided by the concrete
    types implementing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the *default implementation of interface members*, C# 8 widens the interface
    type syntax to include the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can now define bodies for *methods*, *properties*, *indexers*, and
    *events*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces may declare *static members*, including *static constructors* and
    *nested types*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may explicitly specify visibility modifiers, such as *private*, *protected*,
    *internal*, and *public* (which continues to be the default).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may also specify other modifiers, such as *virtual*, *abstract*, *sealed*,
    *extern*, and *partial*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for this new feature is straightforward, as it is as simple as adding
    an implementation to a member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At first sight, adding implementations to the member of the interface looks
    contradictory. In fact, the preceding example demonstrates the syntax well, but
    it is certainly not a good design strategy. You may wonder what could be a good
    use case for defining a default implementation on interface members. The first
    reason is *interface versioning*, which has been traditionally very hard to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Interface versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, let''s start from a classic interface, `IWelcome`, declaring
    two simple properties and a `Person` class to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now possible to add a new method with a default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The implementing class does not need to be updated. It can even reside in a
    different assembly without having any impact on the interface change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the implementation is provided by the interface and the class does not
    provide an implementation for the `Greet` method, it is still not accessible from
    a `Person` reference. In other words, the following declaration is not legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to invoke the default implementation, we need an `IWelcome` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The impact of this feature on a long-established interface is extremely important:
    for example, the `List<T>` class exposes the `AddRange` method, which is unfortunately
    not available in the `IList<T>` interface. After almost 20 years of applications
    relying on that interface, any change would be a huge breaking change.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the changes that could make sense on an interface? Removal of a member
    can be avoided by discouraging its usage via `ObsoleteAttribute` and maybe, a
    few versions later, it will start throwing `NotImplementedException`, without
    ever needing to remove that member from the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a member is always a bad practice because interfaces are contracts;
    usually, the need for a change can be modeled by a new member with a different
    name and signature.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new member is, therefore, the only true challenge because it breaks
    binary compatibility and forces a requirement change to every interface implementer.
    If the interface is very popular, for example, `IList<T>`, it is nearly impossible
    to add new members as it would break everybody's code.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the interface versioning problem has been solved by creating
    a new interface that extends the previous one, but this solution isn't that practical,
    since the adoption of the new interface requires the implementers to replace the
    old interface with the new one in their object inheritance declaration and, of
    course, implement the new members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default implementation in C# 8 does not behave the same way as a normal
    class implementation, as it defines the *baseline* implementation for that hierarchy.
    Let''s suppose you have a hierarchy of interfaces and a class defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the current situation, the following assert is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, fix the `ILabrador` default implementation and modify the interface, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that the `Noise` method must be redefined by specifying
    the full path: `IDog.Noise`. The reason for this is because .NET allows multiple
    inheritances with interfaces; therefore, in a more complex inheritance structure,
    there could be more than a single path leading to the `Noise` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax, therefore, requires specifying the full path to overcome this potential
    ambiguity. If the compiler finds any ambiguity that cannot be resolved by just
    specifying the full path, it will generate an explicit error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default implementation of `ILabrador` redefines the baseline implementation
    of `Noise` in `IDog`. This means that, even if we are using an `IDog` reference,
    the change in `ILabrador` will affect the result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, you may have noticed in the comments of the preceding sample that
    the interfaces and the class lie in two different assemblies. If the first assembly
    containing `ILabrador` is recompiled with the new member and the second assembly
    is instead untouched, you will still see `Noise` being updated to `woofs`. This
    means that patching the first assembly will cause all the applications to benefit
    from the update, even without recompiling the whole code.
  prefs: []
  type: TYPE_NORMAL
- en: Interface reabstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to redefine the default implementation from a derived interface
    is fundamental to understanding reabstraction. The principle is the same, but
    the deriving interface may decide to *erase* the default interface implementation,
    marking the member as abstract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going on with the previous example, we could define the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But this time, the implementers of the new interface are required to implement
    the `Noise` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This capability is useful because the default implementation was written to
    provide the best possible implementation that can be commonly used by all the
    types in the hierarchy. But there is a possibility that a branch of those types
    does not fit well with that implementation and you want to erase it at the interface
    level to avoid any misbehavior.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces as traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Treating the concept of trait composition in detail would require an entire
    chapter, but it is worth noting that C# 8 has only just opened the door to traits,
    leaving future versions of the language with the opportunity to fill the gaps,
    as you can read in the design notes of the C# language public repository.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trait composition** is a concept that''s well known in other languages such
    as C++. It involves the ability to define a set of members for determining a well-known
    behavior. The goal is defining different types (traits) with the goal to give
    any class the ability to compose its own behavior by just inheriting the traits.'
  prefs: []
  type: TYPE_NORMAL
- en: Before this release of the language, we used to create static helper classes
    to define a set of reusable behaviors. In C# 8, we can define those members inside
    the interfaces so that they can be reused by just inheriting the interfaces. The
    choice of interfaces is very convenient because .NET supports multiple inheritances
    only on interfaces, allowing multiple traits to be inherited in a new class.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to experiment with traits, try to model them without thinking
    about the classical interface usage; rather, look at them for their intrinsic
    ability to open to multiple inheritances and thus compose a set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: Traits are usually very useful when the availability of the behaviors you need
    to compose is very dependent on each class that you are going to define. In terms
    of design, this would translate into either a very long list of interfaces, each
    one defining a single behavior, or a single interface with many objects implementing
    part of its methods by throwing `NotImplementedException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to look at a very simple example where you want to expose an alphabet
    transliteration service to your application. There are multiple ways to achieve
    this: either with the Windows native APIs, a NuGet library, or a cloud service.
    We could be tempted to define a single interface with a long list of methods supporting
    all the possible permutations from one alphabet to another, but it would not be
    very practical because each of those libraries or services supports only a part
    of all the possible transliterations. This would result in many implementations
    throwing `NotImplementedException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another approach would be to define one interface for each possible transliteration,
    but the class implementing these interfaces would need to redirect the member
    implementation to some external helper class that calls the appropriate library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traits solution looks a bit simpler because it just models what we can
    do. For example, here, there are two possible transliteration interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'They are still interfaces, but the class that needs the common implementation
    can add the interface to the inheritance list, without anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in order to make the consumer''s life easier, the class could expose
    a switch expression using pattern matching to invoke the try transliteration to/from
    a given alphabet and return the computed result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code tries to transliterate the text with all the available services, and
    if one of them is implemented by the class, a conversion is tried. As soon as
    the phrase can be converted (that is, the conversion result is different from
    the input), it is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Default interface implementations in interfaces are a valuable feature for all
    pragmatists. Java and Swift are examples of programming languages that already
    support this feature. If you are a library developer needing to port your code
    across multiple languages, it will make your life easier and avoiding re-architecting
    portions of code to overcome its absence in previous versions of the language.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the recommendation is to use the default implementation with wisdom.
    It would not be useful if the use case already fit well with the previous tools
    and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fun edge case of the default implementation is that you can now define the
    entry point of your application with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The default interface members are a controversial feature leveraging the intrinsic
    capability of the .NET interfaces to support multiple inheritance. The pragmatist
    should appreciate the practical use cases justifying this little revolution, while
    the others can just continue using the interfaces as they always did before.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next feature, which should help in avoiding some headaches
    and `IndexOutOfRangeException` exceptions when slicing arrays and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges and indices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another convenient functionality introduced in C# 8 is the new syntax to identify
    single elements or ranges inside a sequence. The language already offers the ability
    to get or set elements in an array using the square brackets and a numeric index,
    but this concept has been extended by adding two operators to identify an item
    from the end of a sequence and to extract a range between two indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the aforementioned operators, the base class library now offers
    two new system types, `System.Index` and `System.Range`, which we will immediately
    see in action. Let''s consider an array of strings containing six country names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know how to use the numeric indexer to get a reference to the first
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `System.Index` type is just a convenient wrapper for the numeric index
    that can be directly used on the arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part is when we need to address the item starting from the
    end of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `^` operator provides us with a succinct and effective way to get the
    last item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very important to note that, while zero is the first index when counting
    from the beginning, it points to one item beyond the total length when counting
    from the end. This means that the `[^0]` expression will always throw `IndexOutOfRangeException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to ranges, the value of the new syntax is more evident, since
    it is a brand new concept that never existed before in the language or in the
    base class library. The new`..` operator delimits two indices that are used to
    identify a range. The delimiters on the left and the right of the operator can
    be also omitted whenever the items at the boundaries should be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows three ways to specify all the items in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expected` variable just gets a clone of the countries array and the convenient
    `SequenceEqual` Linq extension method returns true when the items in the two sequences
    are identical and are ordered the same. The previous example is not very useful,
    but highlights the semantics at the boundaries: the *left* boundary is always
    *inclusive*, while the *right* boundary is always *exclusive*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is more realistic and shows three different ways to specify
    a range that just skips the first item of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following example shows how to skip the last item in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting everything together is straightforward, and the following example shows
    how to skip both the first and the last element of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The range syntax to specify the starting and the ending indices can start counting
    from the start or the end. In the following example, the sliced array will return
    just the second and the third element, both counted from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the same is valid when counting from the end, which is the goal
    of the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is very simple, but you may have noticed that we only made use
    of arrays, which, as well as strings, are treated as special by C#. In fact, if
    we try to use this same syntax with a `List<T>`, it won''t work, since there are
    no members that know what `Index` and `Range` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The question now is, how can we make the following test pass? There are three
    different ways to make it compile and work. The first one is straightforward and
    consists of providing an indexer that takes a `System.Range` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `List<T>` base class provides the indexer taking an integer, while `MyList<T>`
    adds an overload taking a `Range` type, which is used from C# 8 as an alias of
    the `..` syntax. In the new indexer, we use `Range.GetOffsetAndLength`, a very
    convenient method that returns a tuple with the initial index and the length of
    the sequence to slice. Finally, the `List<T>.GetRange` base method provides the
    sliced sequence used to create the new `MyList<T>` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possible solution to make the previous test pass is to take advantage
    of the special `Slice` method with which the C# 8 compiler searches *by pattern*.
    In the absence of the indexer that we wrote before, if the compiler finds a method
    called `Slice` that takes two integers, it *remaps* the range syntax to a call
    to the `Slice` method. As a result, the following code is neater and simpler to
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Please note that any call with a range syntax such as `countries[1..^1]` will
    invoke the `Slice` method.
  prefs: []
  type: TYPE_NORMAL
- en: This solution is nice but can't solve the problem of the popular `List<T>` class,
    a class that can be found almost everywhere in the code, especially because the
    Linq extension method known as `ToList()` returns an `IList<T>`. Writing a `Slice`
    extension method will not work because the compiler looks for `Slice` among the
    instance methods, while extension methods are static.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to write an extension method taking a `Range`, as shown in
    the following example. This time, the countries reference is any collection inheriting
    `ICollection<T>` and supports slicing with the nice syntax of `countries.Slice(1..^1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In all the previous examples, we explicitly created `Index` and `Range` using
    their constructors, but I would recommend taking some time to explore the convenient
    static factories provided by the `Index` and `Range` classes, such as `Range.All()`
    or `Index.FromEnd()`.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges and indices provide powerful and expressive operators and types to simplify
    the selection of single or multiple items in a sequence. The main purpose is to
    make the code more readable and less prone to errors without impacting the performance.
  prefs: []
  type: TYPE_NORMAL
- en: The most important advice on ranges to remember is that boundaries are inclusive
    only on the left side of the range.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching was introduced in C# 7, but version 8 of the language specification
    widens its usage by smoothing the syntax and making it more compact and readable.
    This chapter will avoid repeating the features already seen in the previous versions
    and just focus on the new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The popular `switch` statement has evolved in C# to become an *expression*
    with a very fluent syntax. For example, suppose you are reading the console keys
    in an application using the `Console.ReadKey` method to get the colors matching
    the `R`, `G`, and `B` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you prefer an even more compact version, we could write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch` expression is not semantically changed from the previous innovations
    of C# 7 pattern matching; rather, it has become simpler and more compact with
    some important things to highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: As an expression, the `switch` statement must return a value (the `Color` enumeration
    in our sample).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The discard character `(_)` replaces the `default` keyword in the classical
    `switch` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subexpressions mapping the keys to the colors are evaluated in order, where
    the first match wins and exits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Things can get even more interesting when using the switch expression to match
    types, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes an unknown object as input and returns a string that is formatted
    differently depending on its runtime type, which must match with the exact type.
    For example, `GetString((Int16)1)` will not match nor return the string `Fallback:
    1`. Another failed matching is `GetString(10.6m)` because the literal is a decimal
    and the returned string will be `Fallback: 10.6`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 7, testing the type identity on value or reference types was pretty
    cumbersome because it required a second step to either cast the value type to
    the desired type or a null-check conditional operation for the reference types.
    Thanks to C# 7, we learned to use `is` pattern matching, which is perfect when
    checking a single type.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new C# 8 syntax, the resulting code is more succinct and less error-prone,
    with a number of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Not having to care about null references in every case, which has the positive
    effect of being a better candidate for the method to be inlined by the **Just-in-time
    Compiler** (**JIT**), resulting in better performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluation respects the order, which is very useful when testing type hierarchies.
    In our example, it is fundamental to evaluate the `Derived` class before `Base`,
    because otherwise the `switch` expression would always match `Base`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly capturing the nulls in *null case* captures avoids any conditional
    expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` expression is very powerful, but the improvements to pattern matching
    are not over yet.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pattern matching has been extended to allow drilling down into object properties
    and tuples. The syntax at the base of this improvement consists of the ability
    to specify an expression between curly braces after a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The expression inside the curly braces can only specify properties and must
    make use of constant literals. This allows us to match the type and, at the same
    time, evaluate its properties possibly recurring over subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The true power comes into play when we need to evaluate objects structured
    in a graph, like in the following two `Customer` property of the `Order` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s suppose we''re working on an e-commerce application where the discount
    depends on the order properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first subexpression reassigns the reference to the `o` variable whose
    `Quantity` property, thanks to the `when` clause, is then evaluated. If `o.Quantity
    > 100` is satisfied, a 7.5% discount is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, when `Order.IsMadeOnWeb` is true, a good 5% discount is
    returned. The third case evaluates the property obtained by navigating `Order.Customer.Country`,
    returning a 2% discount just because the order originates from Italy. Finally,
    the discard character represents the fallback to zero discount.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax with the properties is great, but things get a bit more complicated
    when it comes to tuples because you may want to match a single tuple item, as
    well as multiple ones, and their position is also fundamental.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider, for example, a simple `Point` struct with, not surprisingly,
    two integer properties of `X` and `Y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we write a method that returns whether the point lies on the horizontal
    or vertical axis? The condition is satisfied if either `X` or `Y` is zero; therefore,
    a possible approach is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Traditionally, we would write this method with one `if` using an `or` operator,
    but the more the parameters come into play, the more unreadable the code becomes.
    An interesting point of the previous example is that we built a tuple on the fly
    and evaluated it inside the `switch` expression, matching the parameters by their
    position and discarding (with the `_` character) the ones that were not relevant
    to the evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get even more interesting when writing the special `Deconstruct` method
    in the `Point` structure, as it simplifies the tuple''s creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When using tuples in a `switch` expression, there is space for getting more
    power by evaluating its values using the `when` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use the `when` clause to identify the diagonal
    positions in addition to the axis. For this purpose, we define the `SpecialPosition`
    enumerator and use the `switch` expression together with the `when` clause to
    match the diagonals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching gained a lot of power over the last two versions of the language
    and now allows the developer to focus on the important parts of the code without
    being distracted by the boilerplate code required by the previous language rules.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` expression is specifically suited for all those expressions whose
    outcome can be derived from multiple choices, should the evaluation need to dig
    into an object graph or evaluate tuples. The powerful discard character allows
    partial evaluations, avoiding code that is often complex and prone to errors.
  prefs: []
  type: TYPE_NORMAL
- en: The using declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `using` declaration is a very convenient syntax equivalent to the `try/finally`
    block and provides a deterministic call to the `Dispose` method. This declaration
    can be used on all the objects implementing the `IDisposable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know that the `using` declaration deterministically invokes the
    `Dispose` method as soon as its closing curly brace is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time multiple disposable objects need to be used in the same scope, the
    nested `using` declarations are nested, causing an annoying triangle-shaped code
    alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This annoyance can be finally removed if it is fine for the `Dispose` method
    to be called at the end of the current block (the closed curly brace), no matter
    whether the block is a statement (such as a `for`/`if`/â€¦) or the current method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new syntax in C# 8 allows us to entirely remove the curly braces from the
    `using` declarations, transforming the previous example into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first curly brace closing the current block will automatically trigger the
    three `Dispose` methods in the inverse order of declaration. But there is more
    to cover about `Dispose`; in fact, this compact syntax is also valid for the `async
    using` declaration, which will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Dispose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the advent of Tasks in .NET, most of the libraries managing I/O operations
    progressively moved to an asynchronous behavior. For example, the `System.Net.Websocket`
    class members embrace the Task-based programming strategy, providing a better
    developer experience and more efficient behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a developer needs to write a C# client to access some service based
    on the WebSocket protocol, they typically write a wrapper class exposing specialized
    *send* methods and implementing the dispose pattern to invoke the `Websocket.CloseAsync`
    method. We also know that any asynchronous method should return a `Task`, but
    the Dispose method has been defined as void far before the `Task` era, and therefore
    doesn't fit well in the `Task` chain.
  prefs: []
  type: TYPE_NORMAL
- en: The Websocket example is very realistic as I had this exact problem some time
    ago, where blocking the current thread to wait for the CloseAsync to finish inside
    the Dispose caused a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from C# 8 and .NET Core 3.0, we now have two important tools:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IAsyncDisposable` interface defined in .NET Core 3, returning a lightweight
    `ValueTask` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `await using` construct leveraging the new `AsyncDisposable` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to use those in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth remembering that the `await using` declaration benefits from succinct,
    single-line syntax, as we discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you are a library author exposing a disposable type, you can implement either
    one of the two, or even both the `IDisposable` and `IAsyncDisposable` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Disposable patterns in structs and ref structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, C# introduced some *pattern-based* constructs to resolve issues deriving
    from rules that could not be applied in every circumstance. This happens, for
    example, with the `foreach` statement not requiring an object to implement the
    `IEnumerable<>` interface, instead just relying on the presence of the `GetEnumerator`
    method, and similarly the object returned by `GetEnumerator` not needing to implement
    `IEnumerator` but just exposing the required members instead.
  prefs: []
  type: TYPE_NORMAL
- en: This change was driven by the recent introduction of the `ref structs`, which
    are important for diminishing the pressure on the garbage collector as they are
    guaranteed to live only on the stack but do not allow the implementation of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern-based approach has now been extended to the `Dispose` and `DisposeAsync`
    methods under certain conditions that we are going to discuss now.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from C# 8, developers can define `Dispose` or `DisposeAsync` without
    implementing `IDisposable` or `IAsyncDisposable`. Implementing the `Dispose` method
    by pattern has been *limited* to `ref struct` types because extending it to any
    other type could eventually cause a breaking change for types already defining
    a `Dispose` method without declaring `IDisposable` in the inheritance list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following definition is a valid implementation of the `Dispose` and `DisposeAsync`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dispose` method can be used as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'But this other declaration is not allowed because we cannot use `ref` inside
    an asynchronous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The workaround is to expand the `await using` declaration with a full `try`/`finally`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This code is certainly not very nice to read, but we should consider that declaring
    the asynchronous version of `Dispose` (in a type whose life cycle is limited to
    the stack) is probably not a great idea.
  prefs: []
  type: TYPE_NORMAL
- en: While the `Dispose` by pattern has been precautionarily limited to `ref structs`,
    the `DisposeAsync` by pattern has no restrictions, so it is perfectly legal to
    declare `DisposeAsync` in an old-fashioned class and use it with the `await using`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous streams are the final missing piece in the task story that began
    several years ago when the `Task` class, `async`, and `await` were first introduced.
    An example of an unresolved use case is the processing of data chunks coming from
    the internet while they are being downloaded. The basic point here is that we
    don't want to await the entire stream of data, but instead take a single chunk
    at a time, processing it and then awaiting the next one. This processing can therefore
    happen while the other pieces of data are still downloading and the unused thread
    time can be spent to serve other users as well, incrementing the total scalability
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging into the new C# feature, let's rapidly review how an enumerable
    is made in the synchronous world. The following examples show an enumerable sequence
    that can be used inside a `foreach` statement; you may notice that the enumerated
    type is an integer instead of the hypothetical byte array composing the chunks
    downloaded from the internet, but this is not really relevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest possible implementation leverages the C# iterator, which is implemented
    through the `yield` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Its main consumer is, of course, a `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the compiler generates the code, exposing an `IEnumerable<T>`
    whose responsibility is to provide the enumerator, a class made of the `Current`,
    `Reset`, and `MoveNext` members unrolling the sequence. The relevant part of this
    code is `Thread.Sleep` inside the `MoveNext` method, which simulates a slow iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is equivalent, but implements the `IEnumerable` and `IEnumerator`
    interfaces manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the `foreach` statement can easily consume the sequence, sharing
    the problem of the blocked thread caused by `Thread.Sleep`, which in real life
    would be an ongoing I/O operation inside the network stack of the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to resolve this problem, C# 8 introduced the very convenient `await
    foreach`, which is used to iterate an asynchronous enumeration, which in turn
    requires two new interfaces: `IAsyncEnumerable<T>` and `IAsyncEnumerator<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest possible producer and consumer for the new asynchronous streams
    are very similar to the previous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Should we need to implement those two interfaces (manually), it would not be
    much different than the synchronous implementation where, not surprisingly, we
    have to implement the asynchronous version of `MoveNext` called `MoveNextAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the same way that `IEnumerator<T>` derives from `IDisposable<T>`, the `IAsyncEnumerator<T>`
    interface derives from `IAsyncDisposable<T>`, which we already discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '`MoveNextAsync` and `Current` are the only other members required by the `IAsyncEnumerator<T>`
    interface, whose methods return the *lightweight* `ValueTask` type already seen
    in `DisposeAsync`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the only class in the base class library implementing
    `IAsyncEnumerable<T>` is `System.Threading.Channel`, so in order to fully leverage
    the power of the asynchronous streams, you should adopt an external library or
    implement those two interfaces by yourself, which is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code consuming the new asynchronous sequence is structurally the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of completeness, the consuming code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The static `TaskAsyncEnumerableExtensions` class contains some extension methods
    that allow the configuration of `IAsyncEnumerable` objects, as you would expect
    from any other `Task` object.
  prefs: []
  type: TYPE_NORMAL
- en: The first extension method is `ConfigureAwait`, which we already examined in
    [*Chapter 12*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215), *Multithreading
    and Asynchronous Programming*. The other is `WithCancellation`, which takes a
    `CancellationToken` value that can be used to cancel the ongoing task.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous streams are very powerful as they simplify the developer code while
    making it more powerful. On the producer side, implementing the required interfaces
    (`IAsyncEnumerable` and `IAsyncEnumerator`) is very simple, and on the consumer
    side, it is easy to enumerate the sequence asynchronously thanks to the new `async
    foreach`.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback is that the current library ecosystem is not compatible with the
    new interfaces. For this reason, the community already wrote a new set of Linq-style
    extension methods providing the same *look and feel* of the ones baked into the
    base class library.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to use the right tool for every use case. In other words,
    there is no need to transform everything into something asynchronous just because
    the language has been extended. This is just an important tool that every developer
    can use whenever it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Readonly struct members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the introduction of the `readonly` struct in C# 7, it is now possible
    to specify the `readonly` modifier singularly on its members. This feature has
    been added for all those cases where the struct type cannot be entirely marked
    as read-only, but when only one or more members can guarantee not to modify the
    state of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason why I love this feature is because expressing the intents explicitly
    is a best practice in terms of maintenance and usability.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important from a performance perspective because the `readonly` struct
    provides a sort of *hint* to the compiler, which can apply better optimizations.
    The modifier can be applied on fields, properties, and methods to guarantee it
    does not mutate the struct instance, but does not give any guarantee on the referenced
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with properties, the modifier can be applied on the property or
    on just one of the accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s define a `Vector struct` exposing two methods returning
    the vector length where only one of the two is marked as `readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since value types such as `Vector` are subject to be copied when they are passed
    as parameters, a common solution is to apply the `in` modifier (which means a
    `readonly` `ref`), as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the `in` modifier cannot give any guarantees about the immutability
    of the other data addressed by the reference. Therefore, as soon as the compiler
    sees the `GetLength` method being invoked, it has to assume a potential change
    to the vector instance, causing a defensive hidden local copy of `Vector`, regardless
    of the fact that it has been passed by the reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead we replace the call to `GetLength` with the read-only `GetLengthRo`
    method, the compiler understands there is no risk in modifying the `Vector` content
    and can avoid generating the local copy, providing better performance to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It is worth saying that the compiler is smart enough to provide some automatic
    optimizations. For example, automatically generated property getters are already
    marked as read-only, but remember to apply the `readonly` modifier to all the
    other members not mutating the instance state, providing an important hint to
    the compiler and obtaining the best possible optimizations in change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Version after version, the compiler improves its capability to detect potential
    side effects such as local copies. You can verify the generated IL code by yourself
    using a decompiler such as `ildasm` or the `ILSpy` tools, but be warned that these
    optimizations are subject to changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you mark a method as read-only, even if it is modifying the state of its
    instance, the compiler will generate either an error or a warning, depending on
    the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will complain with a `CS1604` error if the `readonly` method tries
    to modify any field of the struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler will generate a `CS8656` warning every time the code accesses a
    not read-only property getter to advise about the generation of the code needed
    to create a defensive hidden local copy of the struct, as stated in the message
    description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the CS8656 warning message, the compiler advises that it is going to generate
    a copy of `''this''` to avoid mutating the current instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one important side effect regarding the ability of the compiler to
    recognize undesired situations. It cannot detect any attempt to modify the changes
    to a referenced object, as demonstrated by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: While we apparently don't see any drawbacks in not applying the `readonly` modifier
    on struct members that are not modifying the state of the value type, be very
    careful, because it can make a big difference to the performance of hot paths.
  prefs: []
  type: TYPE_NORMAL
- en: Null coalescing assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The null coalescing operator, `??`, has been extended in C# 8 to support assignment.
    A popular usage for the null coalescing operator involves the parameter checks
    at the beginning of a method, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The new assignment allows us to reassign the reference whenever it is null,
    as demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter list can initially be null and in this case, it will be reassigned
    to a new instance, but the following times, the assignment will not occur anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The null coalescing assignment doesn't look very important, but its ability
    to execute the rightmost expression is a big value that you should not underestimate.
  prefs: []
  type: TYPE_NORMAL
- en: Static local functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Local functions have been introduced to make the code more readable by constraining
    the visibility of a certain piece of code to a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Obfuscated` method can only be used by `PrintName` and
    has the advantage of being able to ignore any parameter check, because the context
    where the `p` captured parameter is used does not allow its value to be null.
    This can deliver performance advantages in complex scenarios, but its ability
    to capture the local variables (including `this`) can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With C# 8, it is now possible to avoid any capturing by marking the local function
    as static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This new version of the method enforces its ability to self-describe while still
    having the advantage of ignoring any parameter-checking due to the known context.
    It is worth noting that capturing is usually not an issue in terms of performance,
    but can severely impact readability because C# allows automatic capturing by default,
    in contrast to other languages such as C++ lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Better interpolated verbatim strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned that string literals supports some *variants* to avoid
    escaping characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be used to improve formatting, thanks to interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the introduction of interpolated strings, we have always been able to
    mix the two formatting styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'But inverting the `$` and `@` characters was not possible before C# 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: With this small improvement, you don't have to bother about the order of the
    prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: Using stackalloc in nested expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With C# 7, we started using `Span<T>`, `ReadOnlySpan<T>`, and `Memory<T>` because
    they are `ref struct` instances that are guaranteed to be allocated on the stack,
    and therefore won''t affect the garbage collector. Thanks to `Span`, it was also
    possible to avoid declaring the `stackalloc` statements that are directly assigned
    to `Span` or `ReadOnlySpan` as unsafe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from C# 8, the compiler widens the use of `stackalloc` to any expression
    expecting `Span` or `ReadOnlySpan`. In the following example, the test trims the
    `input` string from three special characters, obtaining the string specified in
    the `expected` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations performed by the preceding example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AsSpan` extension method converts the string into `ReadOnlySpan<char>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Trim` extension method narrows the boundaries of `ReadOnlySpan<char>` to
    the characters specified with the `stackalloc` array. This `Trim` method does
    not require any allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `ToString` method is called to create a new string from `ReadOnlySpan<char>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of this code is that, beyond the new `int[]` expression, which
    is used to verify the test, and the `ToString` method, which is used to create
    the result, no other heap allocations are performed.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged constructed types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before digging into this new C# feature, it is necessary to understand the
    subject by analyzing the definitions of **unmanaged** and **constructed types**
    cited by the language specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: A type is called `constructed` if it is generic and the type parameter is already
    defined. For example, `List<string>` is a constructed type while `List<T>` is
    not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A type is called `unmanaged` when it can be used in an unsafe context. This
    is true for many built-in basic types. The official documentation includes the
    list of these types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`,
    `ulong`, `char`, `float`, `double`, `decimal`, `bool`, `enums`, `pointers`, and
    `struct`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of an unmanaged constructed type that it was not possible to declare
    before C# 8 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The two main advantages of allowing generic structs to be unmanaged are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They can be allocated on the stack using `stackalloc`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use those types with pointers and unsafe code to interoperate with native
    code. This is useful when dealing with native chunks whose fields could, for example,
    be either 32 or 64 bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: With this feature, the language specifications are going in the direction of
    easing the native interoperability without incurring the performance hits that,
    in the past, required the use of the C or C++ languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no doubt that the new C# 8 features mark an important milestone in
    terms of code robustness and clarity. It is not unusual for a language to become
    (version after version) more complex and difficult to read, but C# introduced
    features such as pattern matching and ranges that allow any developer to express
    their intent with more concise and unambiguous code.
  prefs: []
  type: TYPE_NORMAL
- en: While it is controversial, the default interface members introduced the Traits
    paradigm to the .NET world and addressed problems such as interface versioning,
    which caused developers to struggle for years.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about a key feature, that is, built-in nullable reference static
    code analysis, which allows us to progressively review the code and dramatically
    cut down the number of errors due to dereferencing null references.
  prefs: []
  type: TYPE_NORMAL
- en: This was not the end of tuning the language for productivity, as we continued
    through the C#7 performance journey with asynchronous streams, read-only struct
    members, and the updates to `stackalloc` and unmanaged constructed types, all
    of which combine to make C# a compelling competitor among the native languages
    while still enforcing code safety.
  prefs: []
  type: TYPE_NORMAL
- en: Other smaller features such as the succinct `using` declaration, asynchronous
    `Dispose`, the disposable pattern, static local functions, the fix on the interpolated
    string, and null-coalescing assignment are very simple to remember and deliver
    practical advantages.
  prefs: []
  type: TYPE_NORMAL
- en: New language features are not just additional tools in the developer's Swiss
    Army knife, but a big opportunity to improve the code base. If we go back in time
    and think of generic types introduced in C# 2.0, they boosted the productivity
    and performance by orders of magnitude. Later on, the language introduced LINQ
    queries, lambda expressions, and extension methods, thereby bringing more expressivity
    and opening up new design strategies that were much harder before then. The entire
    history of programming languages, not only C#, is characterized by improvements
    targeting the requirements of modern development. Nowadays, application development
    is clearly oriented toward shorter development life cycles by adopting the **Continuous
    Integration/Continuous Delivery** (**CI/CD**) pipeline, which brings with it strong
    requirements regarding code quality and productivity. By considering this broader
    view, there is no doubt that staying up to date on the latest language features
    is mandatory for any developer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how .NET Core 3 can transform language formalism
    into running code, both on Windows and on Linux. We will go through creating a
    library that can be consumed from any .NET runtime flavor; consuming packages,
    which is the real richness of this ecosystem; and finally, publishing the application,
    turning all of our work into great value for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can you minimize the amount of `NullReferenceException` exceptions in your
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best syntax to use to read the last item in an array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using `switch` expressions, what keyword is equivalent to using the discard
    character (_)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you await an asynchronous call closing a file in the `Dispose` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When assigning the `orders` variable in the following statement, is the method
    call invoked on every execution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Is defining a sequence as `IAsyncEnumerable` mandatory for it to be iterated
    with the new `async foreach` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow the evolution of C#, you can examin[e the proposals and
    the conversation](https://github.com/dotnet/csharplang)s around the next release
    of the language on GitHub at https://github.com/dotnet/csharplang.
  prefs: []
  type: TYPE_NORMAL
