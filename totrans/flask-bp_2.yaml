- en: Chapter 2. Small to Big – Growing the Flask Application Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask is a wonderful framework for people who want to write a very quick single-file
    application in order to prototype an API or to build a drop-dead simple website.
    What isn''t immediately obvious, however, is just how flexible and adept Flask
    is at growing in larger, more modular application structures that are a necessity
    once the single-module layout becomes more burdensome than convenient. The major
    points that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to convert a module-based Flask application to a package-based layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement Flask blueprints on top of a package-based application structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure that our resulting application can be run with the built-in Werkzeug
    development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your first Flask application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The canonical Flask introductory application that is found on the official
    website is a paragon of simplicity, and is something you''ve most likely come
    across beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding application can be run by first installing the `Flask` package
    from `pip` (all in a virtual environment, of course) and then executing the script
    itself under the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will start the Werkzeug development web server, which was installed when
    `Flask` was obtained via `pip`, and serve the application on `http://localhost:5000`
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical way in which people start a new `Flask` application is to add various
    endpoints to the incredibly simple module that we showed in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While straightforward, the drawbacks of this approach become apparent once
    the complexity of the application increases:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of function definitions in the module increases almost linearly with
    the number of URLs that we want to route to. Though this is not an intrinsic drawback,
    developers should prefer to split functionality into smaller packages that are
    easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The templates and static files that are required by the routes accumulate in
    the same sub-folder location, thus making their organization more complex and
    error-prone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain operations (for example, logging) become simpler when they are configured
    on a per-package basis instead of in one monolithic module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From module to package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest structural change that can be applied to a module-based Flask application
    is to transform it into a typical Python package, with special accommodation for
    the static and templates folders.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a top-level application package, moved the `app.py` module
    along with the `static` and `template` folders inside it, and renamed it `__init__.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__init__.py` file is required for a folder to be considered a valid Python
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'One detail that should be handled at this point is the code that is used to
    run the development server. If you recall, the single-module application contained
    the following conditional statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to execute the module file with the Python interpreter directly,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For a variety of reasons, this is no longer a viable option. However, we still
    wish to run the development server in a straightforward fashion. For this, we
    will create a `run.py` file as a sibling to the inner `application` package folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `run.py` file, we will add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to invoke the following command via the CLI so as to run the
    development server in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, it's considered as bad practice to include code that modifies a state
    (for example, the creation of the Flask app object) in a `__init__.py` package.
    We do this now only for illustrative purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `run` method of our Flask application object can accept a few optional
    arguments. The following are the most useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: The host IP to bind to. Defaults to any port, which is denoted by `0.0.0.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: The port the application will bind to. Defaults to `5000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`: If set to `True`, the Werkzeug development server will reload when
    it detects a code change and additionally provide an interactive debugger embedded
    in an HTML page when an unhandled exception occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the new application structure that we''ve outlined in the preceding section,
    it''s relatively simple to see how functionality such as route handler definitions,
    can be split from `__init__.py` into something like a `views.py` module. Similarly,
    our data models can be factored into a `models.py` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply need to import these modules in `__init__.py` in order to ensure
    that they are loaded when we run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we need to import the views after we instantiate the application object,
    otherwise a circular import will be created. Once we start developing applications
    with blueprints, we will generally try to avoid circular imports by ensuring that
    one blueprint does not import from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we must import the Flask application object to the `views.py` module
    so that we can use the `@app.route` decorator to define our route handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the application can still be run using the built-in Werkzeug application
    server from the **command-line interface** (**CLI**) as before; the only thiwng
    that has changed is the organization of our files. The advantage that we gained
    (at the cost of additional files and the possibility of circular imports rearing
    their ugly heads) is that of functional separation and organization: our view
    handlers may be grouped together in single or multiple modules based on their
    domain of interest, and our data layer and utility functions may exist elsewhere
    in the application structure.'
  prefs: []
  type: TYPE_NORMAL
- en: From package to blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package-based application structure that we just explored may be suitable
    for a large number of applications. However, Flask offers us a level of abstraction
    **née Blueprints**, which formalizes and enforces a separation of concerns at
    the level of views.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse the concept of a blueprint in Flask, which is an abstraction
    to factor an application into more discrete components, with that of the Packt
    book series by the same name!
  prefs: []
  type: TYPE_NORMAL
- en: 'A Flask application that has become too unwieldy can be factored into a set
    of discrete blueprints—each with their own mapping of URIs and view functions,
    static resources (for example, JavaScript and CSS files), Jinja templates, and
    even Flask extensions. In many respects, blueprints are very similar to the Flask
    applications themselves. However, a blueprint is not an independent Flask application
    and cannot be run independently as an application itself, as described in the
    official Flask documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A blueprint in Flask is not a pluggable app because it is not actually an
    application—it''s a set of operations which can be registered on an application,
    even multiple times.—Official Flask documentation, [http://flask.pocoo.org/docs/0.10/blueprints/](http://flask.pocoo.org/docs/0.10/blueprints/)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a result, all the blueprints in an application will share the same main application
    object and configuration, and they must be registered with the main Flask object
    before the URI dispatching can occur.
  prefs: []
  type: TYPE_NORMAL
- en: Our first blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous package-based application layout can be extended to include a
    blueprint-based architecture by first adding a new package that will contain our
    blueprint, which we will simply call `users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the `users` package consists of the requisite `__init__.py`
    and one other module, `views.py`. Our (simple, for now) view functions for the
    `users` blueprint will be placed in the `views.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have placed this code in the `users/__init__.py` file instead of separating
    it out into its own `views.py` module; but in doing so, we would be placing a
    side effect-generating code (that is, the instantiation of the users Blueprint
    object) in package initialization, which is generally frowned upon. The minor
    additional complexity of separating it out into a different module will save you
    from headaches later on.
  prefs: []
  type: TYPE_NORMAL
- en: In this new module, we imported the `Blueprint` class from Flask and used it
    to instantiate a `users` blueprint object. The `Blueprint` class has two required
    arguments, `name` and `import_name`, which we provide as `users` and the `__name__`
    global magic attribute available to all Python modules and scripts. The former
    may be any unique identifier among all the registered blueprints that we desire
    and the latter should be the name of the module where the blueprint object is
    instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this in place, we must amend our application initialization in
    `application/__init__.py` in order to bind the blueprint to the Flask application
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On registering the Blueprint object with the application instance, there are
    several optional arguments that can be specified. One of these arguments is `url_prefix`,
    which will automatically prefix all the routes defined in the blueprint in question
    with the given string. This makes it quite simple to encapsulate all the views
    and routes that are meant to process the requests for any endpoints that begin
    with the `/users/*` URI segment, and is a pattern we will use frequently throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once completed, we can run our application using the built-in Werkzeug application
    server in the usual way via our `run.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening up our browser of choice and navigating to `http://localhost:5000/users/me`
    yields the following rendered result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first blueprint](img/3965_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started out with the most common, simple Flask application
    architecture and explored a few of the ways in which we can extend it in order
    to allow for a more modular approach. We first went from a module-based layout
    to a package-based one and then graduated to the use of Flask blueprints, which
    paved the way for the basic application structure that we will use in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the knowledge that we gained here to create
    our first functional Flask application by utilizing the blueprint pattern and
    several well-known Flask extensions.
  prefs: []
  type: TYPE_NORMAL
