- en: Bonus - Using C++20 Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will take a quick look at some of the upcoming features
    being added to C++20\. This chapter is important because, unlike C++14 and C++17,
    C++20 adds several game-changing features to the language that will alter C++
    forever.
  prefs: []
  type: TYPE_NORMAL
- en: It begins with an introduction to C++20 Concepts, a new mechanism for defining
    the requirements of any arbitrary type. C++20 Concepts promises to change how
    we program using templates and `auto`, providing a mechanism for defining what
    is required of a type. We will then move to C++20 Modules, a new feature that
    removes the need for `#include`, changing how we define interfaces in C++. C++
    Modules is a huge change to the language, requiring a complete overhaul of the
    entire Standard Library as well as our build tools. Next, we will take a quick
    look at `std::span` and C++ Ranges. Finally, we will briefly cover another game-changing
    addition to C++20 called Coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Concepts in C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Modules in C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `std::span`, a new view on arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Ranges in C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use Coroutines in C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 19.04 with a functional internet connection.
    Note that the rest of this book uses Ubuntu 18.04\. Since we will be discussing
    C++20, which is still in development, we need the latest and greatest versions
    of GCC in this specific chapter. Before running these examples, you must install
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Code files for this chapter can be found at [//github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Concepts in C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss an upcoming addition to C++ that promises to
    completely change the way we think about template programming called C++20 Concepts.
    C++ today largely depends on the use of SFINAE to constrain the types that apply
    to any given template function. As seen in [Chapter 4](aff3ffea-2bdd-4d69-9e32-0edae7142703.xhtml), *Using
    Templates for Generic Programming*, SFINAE is hard to write, confusing to read,
    and slow to compile. This recipe is important as template programming post-C++20
    will not only be easier to code and debug, but will also reduce the human costs
    of template programming, making it easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To best explain how C++20 Concepts will aid in template programming, we will
    start with a simple example of programming an interface in C++ today. Interfaces
    define a contract between the implementation of an **Application Programming Interface**
    (**API**) and the user of the API and are heavily used in object-oriented programming
    to abstract away the interface of an API from its implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following pure virtual interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding pure virtual interface in C++ defines a `foo()` function. Clients
    of this API do not need to know how `foo()` is implemented. All they care about
    is the definition of the interface and the function signature of `foo()` to understand
    how `foo()` should behave. Using this interface, we can define an implementation
    of this interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we created a class called `A` that inherits
    the interface and override the `foo()` function to give it an implementation.
    We can do the same thing with another implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, the `B` class provides the interface with
    an alternative implementation of the interface. Clients of this interface can
    use the interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The client doesn''t actually need to know anything about `A` or `B`. It simply
    includes the definition of the interface and uses the interface to access any
    specific implementation. We can use this client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we first create instances of both `A` and
    `B`, and we then create two different clients that are given implementations of
    the interface for both `A` and `B`. Finally, we execute the `bar()` functions
    for each client, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de930bf3-bf6d-44a0-8b41-446a2d7e0f6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, the client is unaware that the interface
    was defined in two different ways as the client only concerns itself with the
    interface. This technique is demonstrated in a lot of C++ literature, specifically
    to implement what is known as the S.O.L.I.D object-oriented design principles.
    The S.O.L.I.D design principles stand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility principle**: This ensures that if an object must change,
    it only changes for one reason (that is, an object doesn''t provide more than
    one responsibility).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open–closed principle**: This ensures that an object can be extended without
    being modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution principle**: This ensures that, when inheritance is used,
    subclasses implement the behavior of functions they override and not just the
    function''s signature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation principle**: This ensures that an object has the smallest
    possible interface so that clients of the object are not forced to depend on APIs
    they do not use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion principle**: This ensures that objects are only dependent
    on interfaces and not on implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of these principles is designed to ensure that your use of object-oriented
    programming in C++ is easier to understand and maintain over time. One issue,
    however, with the existing literature for S.O.L.I.D and C++ is that it advocates
    for the heavy use of pure virtual interfaces, which come at a cost. Each class
    must be given an extra virtual table (that is, vTable), and all function calls
    encounter the extra overhead of virtual function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to solve this is to use static interfaces (something that is not often
    talked about in existing literature). To best explain how this works, let''s start
    with the definition of our interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we will leverage static polymorphism to
    implement our interface. The preceding class takes a type called `DERIVED` and
    casts an instance of the interface to the `DERIVED` class, calling a version of
    the `foo` function that has been overridden. The implementation of `A` now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, instead of inheriting the interface, `A`
    now inherits an interface of `A`. When the `foo()` function from the interface
    is called, the interface redirects the call to the `foo_override()` function for
    `A`. We can implement `B` using the same approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, `B` is capable of providing its own implementation
    of the interface. It should be noted that so far in this design pattern, we have
    yet to use `virtual`, meaning we have created an interface and implementations
    of that interface without the need for virtual inheritance, so there is no overhead
    associated with this design. In fact, the compiler is capable of removing the
    redirection of the call from `foo()` to `foo_override()`, ensuring that the use
    of abstraction doesn't provide any additional runtime costs compared to the use
    of pure virtual interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clients of `A` and `B` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the only difference between the client
    in this example and the one in the previous example is the fact that this client
    is a template class. Static polymorphism requires that the type of information
    about an interface is known at compile time. This tends to be fine in most designs
    as the use of pure virtual interfaces earlier was not because we wanted the ability
    to perform runtime polymorphism and type erasure, but instead to ensure that clients
    only adhere to interfaces and not implementations. In both cases, the implementation
    of each client is static and known at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the client, we can use some C++17 class type deduction to ensure that
    our `main()` function remains unchanged, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding example results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/417c5648-2521-4327-9b35-d507866b6af7.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, the code executes the same. The only difference
    between the two approaches is the fact that one uses pure virtual inheritance,
    which comes with a runtime cost, while the second approach uses static polymorphism,
    which comes with a human cost. Specifically, the preceding example for most beginners
    is difficult to understand. In large projects with nested dependencies, the use
    of static polymorphism can be extremely difficult to understand and read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue with the preceding example is the fact that the compiler does
    not have enough information about the interface and clients of that interface
    to provide a reasonable error message when the wrong type is given. Check out
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding error message is hardly useful, especially for a beginner. To
    overcome these issues, C++20 Concepts promises to provide a cleaner implementation
    of template programming moving forward. To best explain this, let''s look at how
    we would implement the interface using C++20 Concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we have defined a C++20 Concept called `interface`.
    Given a type `T`, this concept requires that `T` provides a function called `foo()`
    that takes no input and returns no output. We can then define `A` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, `A` no longer needs to leverage inheritance
    at all. It simply provides a `foo()` function given a normal C++ class definition.
    `B` is implemented the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, inheritance is no longer needed. Clients of this interface are
    implemented as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we have defined a class that takes a template
    type `T` and calls its `foo()` function. In our static polymorphic example earlier,
    we could have implemented the client the exact same way. The problem with that
    approach is that the client would have no way of determining whether the type
    `T` adhered to the interface. Static asserts combined with SFINAE, such as `std::is_base_of()`,
    could be leveraged to solve this issue, but every object that depends on the interface
    would have to include this logic. With C++20 concepts, however, this simplicity
    can be achieved without the need for inheritance or any complicated template tricks
    such as SFINAE. So, let''s see what we can use instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following can be used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The problem with C++ today with template programming is the fact that the `typename` keyword tells
    the compiler nothing about the type itself. SFINAE provides a means to solve this
    by defining certain characteristics about a type at a huge human cost as SFINAE
    is even more complicated to understand, and the resulting compiler errors when
    things go wrong are anything but useful. C++20 Concepts addresses all of these
    issues by defining the properties of a type, called a Concept, and then uses that
    concept in place of `typename`, providing the compiler with all of the information
    it needs to determine whether a given type adheres to the concept. When something
    goes wrong, the compiler can provide a simple error message about what the provided
    type is missing.
  prefs: []
  type: TYPE_NORMAL
- en: C++20 Concepts is an exciting new feature coming soon that promises to completely
    change how we program with C++ templates, reducing the overall human costs of
    working with templates at the expense of a more complicated compiler and C++ specification.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Modules in C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn more about a new feature coming with C++20 called
    Modules. This recipe is important as C++20 Modules removes the need for `#include`
    moving forward. C++ code today is usually divided between headers and source files.
    Every source file is compiled separately and must recompile the headers that it
    includes (and any headers the included headers include), resulting in slow compile
    times, dependency order issues, and the overuse of C-style macros. Instead, optionally,
    libraries will be included using C++20 Modules, changing the way we program even
    simple applications such as "Hello World".
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe. It should be noted that examples 2 and 4 in the source cannot
    be compiled since, at the time of writing, C++ Modules is not yet supported by
    GCC.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++20 Modules provide a new way to include the definitions of APIs used in
    C++. Let''s look at the following example of how to write a simple `Hello World`
    application in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To write this same application using C++20 Modules, you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the difference is subtle, under the hood, a lot has changed to make
    the preceding code possible. Let''s look at a more complicated example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have defined a header file that defines a class template
    called `the_answer`. To implement this template, we must include the `string`
    library. We have also added a macro to this header to test our class. We can use
    this header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we include our header, create an instance
    of our template class, and use it to output a message. When executed, we get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdf986f5-0d0d-4ff1-a0f9-edbf1528f356.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Although this is a simple example showing a class template that implements
    a C++ functor, there are some issues with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `the_answer` depends on the `string` library. This means
    that whenever you use `header.h`, you are not only including the definition of
    `the_answer`, but you are also including the complete definition of the `string`
    library, including all of its dependencies. This type of dependency chain results
    in large build time costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CHECK()` macro is accessible to the client as well. In C++, there is no
    way to namespace a macro, resulting in the possibility of macro collisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding example is small, and therefore easy to compile, but suppose our
    header was `30,000` lines of template code mixed with several includes of its
    own. Now, suppose we must include our header in hundreds of source files. The
    result of this scenario would be extremely long compile times, as each time a
    source file is compiled, it must recompile the same huge header file, over and
    over and over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how C++ Modules addresses these issues, let''s look at how this
    same code would look using modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, our custom library includes a definition
    of string and then uses the `export` module to create a new C++ module called
    `answers`. We then define our class template with the `export` definition. Whenever
    a header is compiled (really, whenever any code is compiled), the compiler usually
    first converts that human-readable C++ syntax into something called an **Intermediate
    Representation** (**IR**). This IR is then converted into a binary assembly. The
    problem is that header files contain code (such as macros and includes) that cannot
    be converted into this type of representation, which means that, each time the
    compiler sees a header, it must convert the code into an IR and then into a binary
    every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ Modules provides a syntax and a set of rules that enables the compiler
    to convert a header into an IR and store the results of this IR with the rest
    of the resulting object files. The compiler can use this IR as many times as needed,
    removing the need to constantly perform the code for the IR conversion process,
    repeatedly. To see how the preceding code is used, let''s look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, we include both the definition of `std::cout` and our `answers`
    module. The difference is that the `main()` function doesn't have to convert the
    `answers` and `std.core` definitions from C++ syntax into the compiler's IR, decreasing
    the compilation time of the `main()` source file. The `main()` source file can
    also create a macro called `CHECK()` without colliding with the same macro in
    our `answers` module as macros cannot be exported.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing std::span, a new view on arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use `std::span`, which is a new feature
    coming with C++20\. This recipe is important as `std::span` is a descendant of
    the Guideline Support Library's `gsl::span`, which is a core component of the
    library used to ensure that your C++ is Core Guideline-compliant. In this recipe,
    we will not only introduce `std::span`, but we will also explain how to use it
    in your own code and why it helps to encapsulate an array with its size as well
    as provide a convenient API for working with arrays in general.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore what `std::span` is and why it is needed. In
    C++ (and even in C), to pass an array to a function, the following is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we have created a function called `foo()`
    that takes a pointer to an array as well as the size of the array. We then use
    this information to output the contents of the array to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94681bc8-2828-4927-8427-fec635cdd27a.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem with the preceding code is that it is not C++ Core Guideline-compliant.
    Specifically, we are forced to store the size of the array independently of the
    array itself. This can lead to issues if the array and its size become out-of-sync
    (something that is possible in large projects). The use of a pointer in relation
    to an array also prevents the use of ranged `for` loops, meaning we must manually
    traverse the array, which can also lead to potential stability issues if the `for`
    loop is not properly constructed. Lastly, we were required to calculate by hand
    the size of the array, an operation that, as shown, is prone to error, using `sizeof()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to solve this issue is to use a template function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we have defined a template function
    that takes a reference to an integer array of size `N`. We can then use `N` to
    traverse through this array. We can even use ranged `for` loops on the array since
    the compiler knows what the size of the array is at compile time. This code can
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, we have made several improvements. We are no longer passing around
    pointers that could lead to `NULL` pointer violations. We are no longer calculating
    the size of the array by hand using `sizeof()`, and we no longer need to store
    the size of the array independently of the array itself. The problem with the
    preceding code is that each time the size of the array changes, we must compile
    a completely different version of the `foo()` function. If the `foo()` function
    is large, this could be a problem. This code also doesn't support dynamically
    allocated arrays (in other words, whether the array was allocated using `std::unique_ptr`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, C++20 has added the `std::span` class. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we have created the `foo()` function
    using `std::span`, which stores an array of integers. Like most other C++ containers,
    we can get the size of the array, and we can use the subscript operator to access
    individual elements of the array. To use this function, we simply call it the
    same way we did using the template function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `std::span`, we can now provide the same `foo()` function with arrays
    of different sizes, and we can even allocate the arrays using dynamic memory (in
    other words, `std::unique_ptr`) without having to re-implement the `foo()` function.
    Ranged `for` loops even work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `foo()` with dynamic memory, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we ran the `foo()` function with three different
    types of memory created dynamically. The first time we ran `foo()`, we allocated
    memory using `new()`/`delete()`. If you are attempting to remain C++ Core Guideline-compliant,
    you are likely not interested in this approach. The second and third approaches
    allocated the memory using `std::vector` or `std::unique_ptr`. Both have their
    inherent disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector` stores its own `size()`, but also stores its capacity and, by default,
    initializes the memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unique_ptr` doesn''t store its own `size()`, and it, too, defaults initialized
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, C++ does not have an array type capable of allocating a dynamic array
    of uninitialized memory while also storing the array's size (and only its size).
    `std::span`, however, can be used with some combination of the preceding approaches
    to manage an array depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should also be noted that when we created `std::span` in the preceding example,
    we passed it the size of the array based on the total number of elements, not
    the total number of bytes. `std::span` is capable of providing both for you, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding implementation of `foo()`, with the aforementioned dynamic
    memory examples, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cd2b8ea-8b69-4e72-8ea6-39e36b056750.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can use the span to create additional sub-spans, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `foo2()` function, we take a span and output all of its elements
    using a ranged `for` loop. We can then use the following to create sub-spans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The result of the `subspan()` function is another `std::span`. The difference
    is the fact that the pointer it stores internally has been advanced by `5` elements,
    and `size()` that the span stores is now `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ranges in C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use C++ Ranges, a new feature set coming
    with C++20\. Ranges provides convenient functions for working with anything that
    mimics a range of objects or values. For example, 4, 8, 15, 16, 23, 42 is a range
    of integers. In C++ today, working with ranges can be cumbersome depending on
    what you are doing. This recipe is important as C++ ranges removes a lot of complexity
    associated with working with ranges, ensuring that your code is easier to read
    and maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform this recipe, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ Ranges is a welcome addition to C++20 as it provides a simple means for
    working with any list of objects or values. To best explain how this works, let''s
    look at the following example (note that, in these recipes, we will use Ranges
    v3 while we wait for GCC to support Ranges as v3 was the implementation adopted
    by C++20):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we have created a list of integers
    (in this specific case, we have created a simple initializer list). We then use
    the `ranges::count()` function to count the total number of times the value `42`
    shows up in the list, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29bc917b-ce5c-4907-ac11-e21b6e099e03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ranges can also be used for searching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we have created the same initializer list
    of integers and we use ranges to return an iterator. This iterator can be used
    to traverse the list or get the located value. Initializer lists already support
    iterators, and one thing that Ranges does is extend this functionality to other
    types, including simple C-style arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses a C-style array instead of an initializer list and,
    as shown, Ranges provides an iterator to work with, in the C-style array, something
    currently not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranges also provides some convenience algorithms. For example, consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created a list of integers. We then loop over
    the entire range of integers and execute a lambda on this list. Although this
    could be done using traditional loops, such as the range-based loops added in
    C++11, `for_each` could simplify your logic (depending on your use case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranges also provides the ability to transform one list into another. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start this example by creating our own type. As shown in the preceding
    code snippet, we have a new type called `my_type` that is constructed with an
    integer and returns the integer using the `get()` function. We can then extend
    our previous examples to transform our list of integers into a list of our custom
    types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we create our initial list of integers and
    then convert this list into a second list of our custom types using the `ranges::views::transform`
    function. We can then iterate over this new list using a traditional range-based
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Ranges also provides some actions that let you actually modify an
    existing range. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we use the `actions::sort` function to sort our list
    of vectors, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2017152b-aba7-4295-99e7-bbbadae2dde7.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, C++20 Ranges provides us with a simple means
    to sort `std::vector` using the pipe operator instead of having to use `std::sort`,
    explicitly defining our begin and end iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use Coroutines in C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a brief peek into an upcoming feature in C++20
    called Coroutines. Unlike some of the other features in being added to C++20,
    Coroutines are not possible in C++ today. Coroutines provide the ability to suspend
    the execution of a function and yield a result. Once the result is used, the function
    can be resumed where it left off to continue execution. This recipe is important
    as C++20 will be adding first-class support (that is, new keywords) to C++ to
    support Coroutines and it is likely that this new feature will begin to surface
    in libraries and examples in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try this recipe, please perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated earlier, Coroutines provide the ability to suspend and resume the
    execution of a function. To demonstrate how this will work in C++20, we will briefly
    look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have created a function called `even_numbers()`
    that, given a range, returns `std::vector` of even numbers. We can then use this
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8884a7b-b906-4296-a575-a6701c548375.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem with the preceding implementation is that this code requires the
    use of `std::vector` just to create a range of numbers to iterator over. With
    Coroutines, we will be able to implement this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of returning `std::vector`, we now return `generator<int>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we loop through each even value in our loop, we call `co_yield`. This causes
    the `even_numbers()` function to return with the value provided while saving its
    place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the `even_numbers()` function is resumed, it returns to where `co_yield`
    was originally executed, meaning the function can now continue its execution producing
    the next even number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process continues until the `for` loop finishes and the Coroutine returns
    the last even number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this function, our `main()` code doesn''t change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that we are not returning `std::vector` but instead returning
    the integer provided by the Coroutine.
  prefs: []
  type: TYPE_NORMAL
