- en: Coding Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible can help you automate just about all of your daily IT tasks, from mundane
    tasks, such as applying patches or deploying configuration files, to deploying
    entirely new infrastructure as code. The use of, and engagement with, Ansible
    has been growing year by year as more and more people come to realize both its
    power and simplicity. You will find many example Ansible playbooks, roles, blog
    articles, and so on across the internet, and combined with resources such as this
    book, you will become proficient at writing your own Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, how do you know what the best approaches for writing your automation code
    in Ansible are? How can you tell whether an example you found on the internet
    is actually a good way of doing things? In this chapter, we will take you through
    a practical guide of the best practices in Ansible, showing you what is currently
    considered good practice when it comes to directory structure and playbook layout,
    how to make effective use of inventories (especially on the cloud), and how best
    to differentiate your environments. By the end of this chapter, you should be
    able to proceed with confidence in writing everything from small single-task playbooks
    to large-scale playbooks for complex environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The preferred directory layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best approach to cloud inventories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between different environment types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proper approach to defining group and host variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using top-level playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging version control tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting OS and distribution variances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting between Ansible versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting Started with
    Ansible*, and that you are using the most recent version available; the examples
    in this chapter were tested on Ansible 2.9\. This chapter also assumes that you
    have at least one additional host to test against; ideally, this should be Linux-based.
    Although we will give specific examples of hostnames in this chapter, you are
    welcome to substitute them with your own hostname and/or IP addresses, and details
    of how to do this are provided in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle used in this chapter is available at [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%207](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%207).
  prefs: []
  type: TYPE_NORMAL
- en: The preferred directory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have explored Ansible throughout this book, we have shown many times that
    the more your playbook grows in size and scale, the more likely you are to want
    to divide it up into multiple files and directories. A great example of this is
    roles, which we covered in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*, where we defined roles to not only enable us to reuse common
    automation code but also to split up what could potentially be a massive, single
    playbook into smaller, logically organized, manageable chunks. We also looked,
    in [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*,
    at the process of defining your inventory file and how you can also split this
    up across multiple files and directories. What we have not looked at, however,
    is how we can put all of this together. All of this is documented in the official
    Ansible documentation at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#content-organization](https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#content-organization).
  prefs: []
  type: TYPE_NORMAL
- en: However, in this chapter, let's get started with a practical example of this
    to show you a great way of setting up your directory structure for a simple role-based
    playbook that has two different inventories—one for a development environment
    and one for a production environment (you would want to keep these separate in
    any real-world use case, although ideally, you should be able to execute the same
    plays on both for consistency and for testing purposes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by building the directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory tree for your development inventory with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define an INI-formatted inventory file for our development inventory—in
    our example, we''ll keep this really simple with just two servers. The file to
    create is `inventories/development/hosts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To further our example, we''ll add a group variable to our app group. As discussed
    in [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*,
    create a file called `app.yml` in the `group_vars` directory we created in the
    previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `production` directory structure using the same method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an inventory file called `hosts` in the newly created `production` directory
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll define a different value to the `http_port` group variable for
    our production inventory. Add the following contents to `inventories/production/group_vars/app.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That completes our inventory definition. Next, we will add in any custom modules
    or plugins that we might find useful for our playbook. Suppose we want to use
    the `remote_filecopy.py` module we created in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*. Just as we discussed in this chapter, we first
    create the directory for this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, add the `remote_filecopy.py` module to this library. We won't relist the
    code here to save space, but you can copy it from the section called *Developing
    custom modules* from [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*, or take advantage of the example code that accompanies
    this book on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be done for the plugins; if we also want to use our `filter` plugin
    that we created in [Chapter 6](8a78c6c0-fc74-44eb-aa2b-f0d0c6c62cb4.xhtml), *Consuming
    and Creating Plugins*, we would create an appropriately named directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, copy the `filter` plugin code into this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll create a role to use in our new playbook structure. Naturally,
    you will have many roles, but we''ll create one as an example and then you can
    repeat the process for each role. We''ll call our role `installapp` and use the
    `ansible-galaxy` command (covered in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml), *Playbooks
    and Roles*) to create the directory structure for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `roles/installapp/tasks/main.yml` file, we''ll add the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've reused a number of examples from earlier chapters
    of this book. You can also define the handlers, variables, default values, and
    so on to the role, as discussed previously, but for our example, this will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stage in creating our best practice directory structure is to add
    a top-level playbook to run. By convention, this will be called `site.yml` and
    it will have the following simple contents (note that the directory structure
    we have built takes care of many things, allowing the top-level playbook to be
    incredibly simple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of clarity, your resulting directory structure should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can simply run our playbook in the normal manner. For example, to run
    it on the development inventory, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, run the following for the production inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the appropriate hosts and associated variables are picked up for
    each inventory and how tidy and well organized our directory structure is. This
    is the ideal way for you to lay out your playbooks and will ensure that they can
    be scaled up to whatever size you need them to be, without them becoming unwieldy
    and difficult to manage or troubleshoot. In the next section of this chapter,
    we will explore the best approaches for working with cloud inventories.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach to cloud inventories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*,
    we looked at a simple example of how you can work with a dynamic inventory, and
    we walked you through a practical example using the Cobbler provisioning system.
    However, when it comes to working with cloud inventories (which are simply a form
    of dynamic inventory, but specifically focused on the cloud), they might, at first,
    seem somewhat confusing and you may find it difficult to get them up and running.
    If you follow the high-level procedure outlined in this section, this will become
    an easy and straightforward task.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a practically focused book, we will choose an example to work with.
    Sadly, we don't have space to provide practical examples for all of the cloud
    providers, but if you follow the high-level process we will outline for Amazon
    EC2 and apply it to your desired cloud provider (for example, Microsoft Azure
    or Google Cloud Platform), you will find that the process of getting up and running
    is actually quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: An important note before we start, however, is that in Ansible versions up to
    and including 2.8.x, the dynamic inventory scripts are part of the Ansible source
    code itself and can be obtained from the main Ansible repository that we examined
    and cloned previously in this book. With the ever-growing and expanding nature
    of Ansible, it has become necessary, in the version 2.9.x releases (and beyond),
    to separate the dynamic inventory scripts into a new distribution mechanism called
    Ansible collections, which will become mainstream in the 2.10 version (not yet
    released at the time of writing). You can learn more about Ansible collections
    and what they are at [https://www.ansible.com/blog/getting-started-with-ansible-collections](https://www.ansible.com/blog/getting-started-with-ansible-collections).
  prefs: []
  type: TYPE_NORMAL
- en: The way you download and work with dynamic inventory scripts is likely to change
    radically with the 2.10 release of Ansible, yet sadly, very little has been revealed,
    at the time of writing, of what this will look like. As a result, we will guide
    you through the process of downloading your required dynamic inventory provider
    scripts for the current 2.9 release, and advise you to consult the Ansible documentation
    when the 2.10 release comes out for the download location of the relevant scripts.
    Once you have downloaded them, it is my understanding that you will be able to
    continue working with them as outlined in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with the 2.9 release of Ansible, you can find and download
    all of the latest dynamic inventory scripts from the stable-2.9 branch on GitHub,
    at [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the official Ansible documentation has been updated, most guides on
    the internet still reference the old GitHub locations of these scripts and you
    will find that they no longer work. Do bear this in mind when working with dynamic
    inventories! Let''s now proceed to cover at the process for working with a dynamic
    inventory script for a cloud provider; we will use the following Amazon EC2 dynamic
    inventory script as a working example, but the principles we apply here can equally
    be used with any other cloud inventory scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having established that we are going to work with Amazon EC2, our first task
    is to obtain the dynamic inventory script and its associated configuration file.
    As cloud technologies move fast, it is probably safest to download the latest
    version of these files directly from the official Ansible project on GitHub. The
    following three commands will download the dynamic inventory script and make it
    executable, as well as downloading the template configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the files successfully downloaded, let''s take a look inside them. Unfortunately,
    Ansible dynamic inventories do not have the same neat documentation system that
    we have seen in modules and plugins. Fortunately for us, however, the authors
    of these dynamic inventory scripts have put lots of helpful comments at the top
    of these files to get us started. Let''s take a look inside `ec2.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are pages of documentation to read, but some of the most pertinent information
    is contained within those first few lines. First of all, we need to ensure that
    the `Boto` library is installed. Secondly, we need to set the AWS access parameters
    for `Boto`. The author of this document has given us the quickest way to get started
    (indeed, it is not their job to replicate the `Boto` documentation).
  prefs: []
  type: TYPE_NORMAL
- en: However, if you refer to the official documentation for `Boto`, you'll see that
    there are lots of ways of configuring it with your AWS credentials—setting the
    environment variables is just one. You can read more about configuring the `Boto`
    authentication at [https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go ahead and install `Boto`, let''s take a look at the sample `ec2.ini`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see pages of well-documented options in this file, and if you
    scroll all the way to the bottom, you'll even see that you can specify your credentials
    in this file as an alternative to the methods discussed previously. The default
    settings for this file are, however, sufficient if you just want to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now make sure the `Boto` library is installed; exactly how you do this
    will depend on your chosen OS and your version of Python. You might be able to
    install it through a package; on CentOS 7, you can do this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `pip` for this purpose. For example, to install
    it as part of your Python 3 environment, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have `Boto` installed, let''s go ahead and set our AWS credentials
    using the environment variables suggested to us in the preceding documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With these steps complete, you can now use your dynamic inventory script in
    the usual way—you simply reference the executable inventory script with the `-i`
    parameter in the same way you do with static inventories. For example, if you
    want to run the Ansible `ping` module as an ad hoc command against all the hosts
    you have running in Amazon EC2, you would need to run the following command. Make
    sure you substitute the user account specified by the `-u` switch with the one
    you connect to your EC2 instances with. Also, reference your private SSH key file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it—if you approach all dynamic inventory scripts in this
    same methodical manner, you will have no problem getting them up and running.
    Just remember that the documentation is normally embedded in both the script file
    and its accompanying configuration file, and make sure you read both before you
    attempt to use the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note is that many of the dynamic inventory scripts, `ec2.py` included,
    cache the results of their API calls to the cloud provider to speed up repeated
    runs and avoid excessive API calls. However, you might find that in a fast-moving
    development environment, changes to your cloud infrastructure are not picked up
    fast enough. For most scripts, there are two ways around this—most feature cache
    configuration parameters in their configuration file, such as the `cache_path`
    and `cache_max_age` parameters in  `ec2.ini`. If you don''t want to set these
    for every single run, you can also refresh the cache manually by calling the dynamic
    inventory script directly with a special switch—for example, in `ec2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our practical introduction to cloud inventory scripts. As we
    discussed, provided you consult the documentation (both on the internet and embedded
    within each dynamic inventory script) and follow the simple methodology we described,
    you should have no problems and should be able to get up and running with dynamic
    inventories in minutes. In the next section, we'll revert back to looking at static
    inventories and the best ways to differentiate your various technology environments.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between different environment types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In almost every business, you will need to split your technology environment
    by type. For example, you will almost certainly have a development environment,
    where all the testing and development work is performed, and a production environment,
    where all of the stable test code is run. The environments should (in a best-case
    scenario) make use of the same Ansible playbooks—after all, the logic is that
    if you can successfully deploy and test an application in your development environment,
    then you should be able to deploy it in the same way in a production environment
    and have it work just as well. However, there are always differences between the
    two environments, not just in the hostnames, but also sometimes in the parameters,
    the load balancer names, the port numbers, and so on—the list can seem endless.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *The preferred directory layout* section of this chapter, we covered
    a way of differentiating between a development and production environment using
    two separate inventory directory trees. This is how you should proceed when it
    comes to differentiating these environments; so, obviously, we won''t repeat the
    examples, but it''s important to note that when working with multiple environments,
    your goals should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Try and reuse the same playbooks for all of your environments that run the same
    code. For example, if you deploy a web app in your development environment, you
    should be confident that your playbooks will deploy the same app in the production
    environment (and your **Quality Assurance** (**QA**) environment, as well as any
    others that it might need to be deployed in).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that not only are you testing your application deployments and code,
    you are also testing your Ansible playbooks and roles as part of your overall
    testing process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your inventories for each environment should be kept in separate directory trees
    (as we saw in the *The preferred directory layout *section of this chapter), but
    all roles, playbooks, plugins, and modules (if used) should be in the same directory
    structure (this should be the case for both environments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is normal for different environments to require different authentication
    credentials; you should keep these separate not only for security but also to
    ensure that playbooks are not accidentally run in the wrong environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your playbooks should be in your version control system, just as your code is.
    This enables you to track changes over time and ensure that everyone is working
    from the same copy of the automation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you pay attention to these simple pointers, you will find that your automation
    workflow becomes a real asset to your business and ensures reliability and consistency
    across all of your deployments. Conversely, failure to follow these pointers puts
    you at risk of experiencing the dreaded, *it worked in development but it doesn't
    work in production* deployment failures that so often plague the technology industry.
    Let's now build on this discussion in the next section by looking at best practices
    when handling host and group variables, something that, as we saw in *The* *preferred
    directory layout* section, you need to apply, especially when working with multiple
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: The proper approach to defining group and host variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with group and host variables, you can split them up using the
    directory-based approach we used in the *The preferred directory layout* section.
    However, there are a few additional pointers to managing this that you should
    be aware of. First and foremost, you should always pay attention to variable precedence.
    A detailed list of variable precedence order can be found at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable).
    However, the key takeaways for working with multiple environments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Host variables are always of a higher order of precedence than group variables;
    so, you can override any group variable with a host variable. This behavior is
    useful if you take advantage of it in a controlled manner, but can yield unexpected
    results if you are not aware of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a special group variables definition called `all`, which is applied
    to all inventory groups. This has a lower order of precedence than specifically
    defined group variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you define the same variable twice in two groups? If this happens,
    both groups have the same order of precedence, so which one wins? To demonstrate
    this (and our earlier examples), we will create a simple practical example for
    you to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, let''s create a directory structure for our inventories. To
    keep this example as concise as possible, we will only create a development environment.
    However, you are free to expand on these concepts by building on the more complete
    example we covered in the *The preferred directory layout* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an inventory directory structure with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a simple inventory file with two hosts in a single group in the `inventories/development/hosts`
    file; the contents should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a special group variable file for all the groups in the
    inventory; this file will be called `inventories/development/group_vars/all.yml`
    and should contain the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create a simple playbook called `site.yml` to query and print
    the value of the variable we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this playbook, we''ll see that the variable (which we only defined
    in one place) takes the value we would expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good! Now, let''s add a new file to our inventory directory structure,
    with the `all.yml` file remaining unchanged. Let''s also create a new file located
    in `inventories/development/group_vars/app.yml`, which will contain the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now defined the same variable twice—once in a special group called
    `all` and once in the `app` group (which both servers in our development inventory
    belong to). So, what happens if we now run our playbook? The output should appear
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the variable definition in the specific group won, which is in
    line with the order of precedence documented for Ansible. Now, let''s see what
    happens if we define the same variable twice in two specifically named groups.
    To complete this example, we''ll create a child group, called `centos`, and another
    group that could notionally contain hosts built to a new build standard, called
    `newcentos`, which both application servers will be a member of. This means modifying
    `inventories/development/hosts` so that it now looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s redefine the `http_port` variable for the `centos` group by creating
    a file called `inventories/development/group_vars/centos.yml`, which contains
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to add to the confusion, let''s also define this variable for the `newcentos`
    group in `inventories/development/group_vars/newcentos.yml`, which will contain
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve now defined the same variable four times at the group level! Let''s
    rerun our playbook and see which value comes through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The value we entered in `newcentos.yml` won—but why? The Ansible documentation
    states that where identical variables are defined at the group level in the inventory
    (the one place you can do this), the one from the last-loaded group wins. Groups
    are processed in alphabetical order and `newcentos` is the group with the name
    beginning furthest down the alphabet—so, its value of `http_port` was the value
    that won.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for completeness, we can override all of this by leaving the `group_vars`
    directory untouched, but adding a file called `inventories/development/host_vars/app01.dev.example.com.yml`,
    which will contain the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our playbook one final time, we will see that the value we defined
    at the host level completely overrides any value that we set at the group level
    for `app01.dev.example.com`. `app02.dev.example.com` is unaffected as we did not
    define a host variable for it, so the next highest level of precedence—the group
    variable from the `newcentos` group—won:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With this knowledge, you can now make advanced decisions about how to structure
    your variables within your inventory to make sure you achieve the desired results
    at both a host and group level. It's important to know about variable precedence
    ordering, as these examples have demonstrated, but following the documented order
    will also allow you to produce powerful, flexible playbook inventories that work
    well across multiple environments. Now, you may have noticed that, throughout
    this chapter, we have used a top-level playbook in our directory structure called
    `site.yml`. We will look at this playbook in greater detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using top-level playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all of the examples so far, we have built out using the best practice directory
    structure recommended by Ansible and continually referred to a top-level playbook,
    typically called `site.yml`. The idea behind this playbook, and, indeed, its common
    name across all of our directory structures, is so that it can be used across
    your entire server estate—that is to say, your **site**.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is not to say that you have to use the same set of playbooks
    across every server in your infrastructure or for every single function; rather,
    it means only you can make the best decision as to what suits your environment
    best. However, the whole aim of Ansible automation is that the created solution
    is simple to run and operate. Imagine handing a playbook directory structure with
    100 different playbooks to a new system administrator—how would they know which
    ones to run and in which circumstances? The task of training someone to use the
    playbooks would be immense and would simply move complexity from one area to another.
  prefs: []
  type: TYPE_NORMAL
- en: At the other the end of the spectrum, you could make use of the `when` clauses
    with facts and inventory grouping, such that your playbook knows exactly what
    to run on each server in every possible circumstance. This, of course, is unlikely
    to happen and the truth is that your automation solution will end up somewhere
    in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is that, on receipt of a new playbook directory structure,
    a new operator at least knows what the starting point for both running the playbooks,
    and understanding the code is. If the top-level playbook they encounter is always
    `site.yml`, then at least everyone knows where to start. Through the clever use
    of roles and the `import_*` and `include_*` statements, you can split your playbook
    up into logical portions of reusable code, as we previously discussed, all from
    one playbook file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about the importance of top-level playbooks, let's
    take a look, in the next section, at how to take advantage of version control
    tools to ensure good practices are adhered to when it comes to centralizing and
    maintaining your automation code.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging version control tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier in this chapter, it is vital that you version control
    and test not only your code but also your Ansible automation code. This should
    include inventories (or dynamic inventory scripts), any custom modules, plugins,
    roles, and playbook code. The reason for this is simple—the ultimate goal of Ansible
    automation is likely to be to deploy an entire environment using a playbook (or
    set of playbooks). This might even involve deploying infrastructure as code, especially
    if you are deploying to a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Any changes to your Ansible code could mean big changes to your environment,
    and possibly even whether an important production service works or not. As a result,
    it is vital that you maintain a version history of your Ansible code and that
    everyone works from the same version. You are free to choose the version control
    system that suits you best; most corporate environments will already have some
    kind of version control system in place. However, if you haven't worked with version
    control systems before, we recommend that you sign up for a free account on somewhere
    such as GitHub or GitLab, which both offer version control repositories for free,
    along with more advanced paid-for plans.
  prefs: []
  type: TYPE_NORMAL
- en: A complete discussion of version control with Git is beyond the scope of this
    book; there are, indeed, entire books devoted to the subject. However, we will
    take you through the simplest possible use case. It is assumed, in the following
    examples, that you are using a free account on GitHub, but if you are using a
    different provider, simply change the URLs to match those given to you by your
    version control repository host.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, you will need to install the command-line Git tools on
    your Linux host. On CentOS, you would install these as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, the process is similarly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once the tools are installed and your account is set up, your next task is to
    clone a Git repository to your machine. If you want to start working with your
    own repository, you will need to set this up with your provider—excellent documentation
    is provided by both GitHub and GitLab and you should follow this to set up your
    first repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is set up and initialized, you can clone a copy to your local machine
    to make changes to your code. This local copy is called a working copy, and you
    can work through the process of cloning it and making changes as follows (note
    that these are purely hypothetical examples to give you an idea of the commands
    you will need to run; you should adapt them for your own use case):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone your `git` repository to your local machine to create a working copy
    using a command such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the directory of the code you cloned (the working copy) and make
    any code changes you need to make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to test your code and, when you are happy with it, add the changed
    files that are ready for committing a new version using a command such as the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to commit the changes you have made. A commit is basically
    a new version of code within the repository, so it should be accompanied by a
    meaningful `commit` message (specified in quotes after the `-m` switch), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, all of these changes live solely in the working copy on your local
    machine. This is good by itself, but it would be better if the code was available
    to everyone who needs to view it on the version control system. To push your updated
    commits back to (for example) GitHub, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, other collaborators can clone your code just as we did in *step 1*. Alternatively,
    if they already have a working copy of your repository, they can update their
    working copy using the following command (you can also do this if you want to
    update your working copy to see changes made by someone else):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are some incredibly advanced topics and use cases for Git that are beyond
    the scope of this book. However, you will find that roughly 80% of the time, the
    preceding commands are all the Git command-line knowledge you need. There are
    also a number of graphical frontends to Git, as well as code editors and **Integrated
    Development Environments** (**IDEs**), that integrate with Git repositories and
    can assist you further in taking advantage of them. With that complete, let's
    take a look at how to ensure you can use the same playbook (or role) across multiple
    hosts, even though they might have different OSes and versions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting OS and distribution variances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated earlier, our goal is to try to use the same automation code as widely
    as possible. However, as much as we try to standardize our technology environments,
    variants always creep in. For example, it is impossible to simultaneously perform
    a major upgrade on all your servers in one go, so when a major new OS version
    comes out, such as **Red Hat Enterprise Linux** (**RHEL**) 8 or Ubuntu Server
    20.04, it is inevitable that some machines will remain on older versions as others
    are upgraded. Similarly, an environment might be standardized on Ubuntu, but then
    an application is introduced that has only been certified to run on CentOS. In
    short, as important as standardization is, variances will always creep in.
  prefs: []
  type: TYPE_NORMAL
- en: When writing Ansible playbooks, especially roles, your goal should be for them
    to be as widely applicable as possible throughout your environment. A classic
    example of this is package management—let's say you are writing a role to install
    the Apache 2 web server. If you have to support both Ubuntu and CentOS with this
    role, not only do you have different package managers to deal with (`yum` and `apt`),
    you also have different package names (`httpd` and `apache2`).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml), *Playbooks and Roles*,
    we looked at how to apply conditions to tasks using the `when` clause, along with
    facts gathered by Ansible, such as `ansible_distribution`. However, there is another
    way of running tasks on specific hosts that we haven't yet looked at. In the same
    chapter, we also looked at the concept of defining multiple plays in one playbook—there
    is a special module that can create inventory groups for us based on Ansible facts
    and we can leverage this along with multiple plays to create a playbook that runs
    the appropriate tasks on each host based on its type. This is best explained by
    a practical example, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we are using the following simple inventory file for this example,
    which has two hosts in a single group called `app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now build a simple playbook that demonstrates how you can group differing
    plays using an Ansible fact so that the OS distribution determines which play
    in a playbook gets run. Follow these steps to create this playbook and observe
    it''s operation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new playbook—we''ll call it `osvariants.yml`—with the following
    `Play` definition. It will also contain a single task, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The playbook structure will be, by now, incredibly familiar to you. However,
    the use of the `group_by` module is new. It dynamically creates new inventory
    groups based on the key that we specify—in this example, we are creating groups
    based on a key comprised of the `os_` fixed string, followed by the OS distribution
    fact obtained from the `Gathering Facts` stage. The original inventory group structure
    is preserved and unmodified, but all the hosts are also added to the newly created
    groups according to their facts.
  prefs: []
  type: TYPE_NORMAL
- en: So, the two servers in our simple inventory remain in the `app` group, but if
    they are based on Ubuntu, they will be added to a newly created inventory group
    called `os_Ubuntu`. Similarly, if they are based on CentOS, they will be added
    to a group called `os_CentOS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this information, we can go ahead and create additional plays based
    on the newly created groups. Let''s add the following `Play` definition to the
    same playbook file to install Apache on CentOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfectly normal `Play` definition that uses the `yum` module to install
    the `httpd` package (as required on CentOS). The only thing that differentiates
    it from our earlier work is the `hosts` definition at the top of the play. This
    uses the newly created inventory group created by the `group_by` module in the
    first play.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, similarly, add a third `Play` definition, this time for installing
    the `apache2` package on Ubuntu using the `apt` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If our environment is based on CentOS servers and we run this playbook, the
    results are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the task to install Apache on CentOS was run. It was run this way
    because the `group_by` module created a group called `os_CentOS` and our second
    play only runs on hosts in the group called `os_CentOS`. As there were no servers
    running on Ubuntu in the inventory, the `os_Ubuntu` group was never created and
    so the third play does not run. We receive a warning about the fact that there
    is no host pattern that matches `os_Ubuntu`, but the playbook does not fail—it
    simply skips this play.
  prefs: []
  type: TYPE_NORMAL
- en: We provided this example to show you another way of managing the inevitable
    variance in OS types that you will come across in your automation coding. At the
    end of the day, it is up to you to choose the coding style most appropriate to
    you. You can make use of the `group_by` module, as detailed here, or write your
    tasks in blocks and add a `when` clause to the blocks so that they only run when
    a certain fact-based condition is met (for example, the OS distribution is CentOS)—or
    perhaps even a combination of the two. The choice is ultimately yours and these
    different examples are provided to empower you with multiple options that you
    can choose between to create the best possible solution for your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's round off this chapter with a look at porting your automation
    code between Ansible versions.
  prefs: []
  type: TYPE_NORMAL
- en: Porting between Ansible versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a fast-moving project, and with releases and new features added,
    new modules (and module enhancements) are released and the inevitable bugs that
    come with the software are fixed. There is no doubt that you will end up writing
    your code against one version of Ansible only to need to run it on a newer version
    again at some point. By way of example, when we started writing this book, the
    current release of Ansible was 2.7\. As we are editing this book ready for publication,
    version 2.9.6 is the current stable version.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you will find that your code from an earlier version "just about works"
    when you upgrade it, but this isn't always a given. Modules are sometimes deprecated
    (although usually not without warning) and features do change. Several major changes
    are expected when Ansible 2.10 is released. So, the question remains—how can you
    ensure that your playbooks, roles, modules, and plugins still work when you update
    your Ansible installation?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the answer is to establish which version of Ansible you are
    starting from. For example, let''s say you are preparing for the release of Ansible
    2.10\. If you query the version of Ansible you already have installed and see
    something like the following, then you know you are starting from Ansible release
    2.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, your first port of call should be to review the porting guide for the Ansible
    2.10 release; a porting guide is normally written for every major release (such
    as 2.8, 2.9, and so on). The guide for 2.10 can be found at [https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.10.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.10.html).
  prefs: []
  type: TYPE_NORMAL
- en: If we review this document, we can see that there are a number of changes coming—whether
    they are significant to you really depends on the code you are running. For example,
    if we review the *Modules Removed* section of the guide, we can see that the `letsencrypt`
    module has been removed and it is suggested that you use the `acme_certificate`
    module instead. If you are generating free SSL certificates using the `letsencrypt`
    module in Ansible, then you would certainly need to update your playbooks and
    roles to accommodate this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding link, there are a great number of changes between
    the 2.9 and 2.10 releases of Ansible. To that end, it''s also important to note
    that the porting guides are written from the perspective of an upgrade from the
    previous major release. That is to say, if you query your Ansible version and
    it returns the following, you are porting from Ansible 2.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you move straight to Ansible 2.10 when it comes out, then you need to review
    the porting guides for both 2.9 (which covers the changes required to your code
    between releases 2.8 and 2.9) and 2.10 (which covers the changes required to upgrade
    from 2.9 to 2.10). An index of all the porting guides can be found on the official
    Ansible website at [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html).
  prefs: []
  type: TYPE_NORMAL
- en: Another great source of information, especially more fine-grained information,
    on the changes between releases are the changelogs. These are released and updated
    for every minor release and can currently be found at the official Ansible GitHub
    repository on the `stable` branch for the release you wish to query. For example,
    if you wish to review all the changelogs for Ansible 2.9, you would need to go
    to [https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst](https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst).
  prefs: []
  type: TYPE_NORMAL
- en: The trick to porting code between Ansible releases (if, indeed, you can call
    it a trick) is simply to read the excellent documentation released by the Ansible
    project team. A lot of effort goes into creating this documentation, so you are
    advised to make good use of it. That concludes our look at the best practices
    for working with Ansible. We hope you have found this chapter valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible automation projects often start out small, but as people come to realize
    the power and simplicity of Ansible, both the code and the inventories tend to
    grow at an exponential pace (at least in my experience). It is important that
    in the push for greater automation, the Ansible automation code and infrastructure
    itself doesn't become another headache. By embedding a few good practices early
    on and applying them consistently throughout your automation journey with Ansible,
    you will find that managing your Ansible automation is simple and easy and is
    a true benefit to your technology infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the best practices for directory layout that
    you should adopt for your playbooks and the steps you should adopt when working
    with cloud inventories. You then learned new ways of differentiating environments
    by OS type, as well as more about variable precedence and how to leverage it when
    working with host and group variables. You then explored the importance of the
    top-level playbook, before looking at how to make use of version control tools
    to manage your automation code. Finally, you explored the new techniques for creating
    single playbooks that will manage servers of different OS versions and distributions,
    before finally looking at the important topic of porting your code to new Ansible
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the more advanced ways that you
    can use Ansible to take care of some special cases that may arise on your automation
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a safe and easy way to manage (that is, modify, fix, and create) code
    changes continuously and share them with others?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Playbook revision
  prefs: []
  type: TYPE_NORMAL
- en: B) Task history
  prefs: []
  type: TYPE_NORMAL
- en: C) Ad hoc creation
  prefs: []
  type: TYPE_NORMAL
- en: D) With a Git repository
  prefs: []
  type: TYPE_NORMAL
- en: E) Log management
  prefs: []
  type: TYPE_NORMAL
- en: True or false – Ansible Galaxy supports sharing roles with other users from
    a central, community-supported repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: True or false – Ansible modules are guaranteed to be available in all future
    releases of Ansible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manage multiple repositories, versions, or tasks by creating branches and tags
    to control multiple versions effectively. Refer to the following links for more
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to use Git tagging: [https://git-scm.com/book/en/v2/Git-Basics-Tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use Git branches: [https://git-scm.com/docs/git-branch](https://git-scm.com/docs/git-branch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
