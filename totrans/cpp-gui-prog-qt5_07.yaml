- en: Map Viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User location and map display are two features that have become more common
    these days and have been used in various types of applications. They are commonly
    used for both backend analytics and frontend display purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The map viewer can be used for navigation, nearby point-of-interest lookup,
    location-based services (such as calling for a taxi), and so on. You can use Qt
    to achieve most of it but you will require an advanced database system, if you're
    going for something more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to embed a web browser into your application.
    In this chapter, we will try something more fun, which covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a map display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marker and shape display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining a user's location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geo Routing Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's proceed to create our own map viewer!
  prefs: []
  type: TYPE_NORMAL
- en: Map display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt Location module provides developer access to geocoding and navigation
    information. It can also allow the user to do a place search for which the data
    needs to be retrieved, either from a server or from the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, Qt's map view does not support C++, only QML. This means that
    we can only use QML script to alter anything related to the visual—displaying
    a map, adding a marker, and so on; on the other hand, we can use the C++ classes
    provided by the module to obtain information from a database or from a service
    provider, before displaying it to the user via QML.
  prefs: []
  type: TYPE_NORMAL
- en: Just a quick note, **QML** (**Qt Modeling Language**) is a user interface markup
    language for Qt Quick applications. Since QML is powered by the JavaScript framework,
    its coding syntax is almost similar to the JavaScript. If you need an in-depth
    learning on QML and Qt Quick, please proceed to [Chapter 14](f8abebf4-f2be-457b-802a-4744ddba7eac.xhtml),
    *Qt Quick and QML,* as it is an entire chapter dedicated to it.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tutorials out there that teach you how to create a fully fledged
    map viewer using Qt Quick and QML language, but there isn't a lot that teaches
    you how to combine C++ with QML. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Qt location module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, create a new Qt Widgets Application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, open up your project file (`.pro`) and add the following modules
    to your Qt project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Besides the `location` module, we also added `qml` and `quickwidgets` modules,
    which are required by the map display widget in the next section. That is all
    we need to do for enabling the `Qt Location` module in our project. Next, we will
    proceed to add the map display widget to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a map display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you are ready, let''s open up `mainwindow.ui` and remove the menuBar,
    toolBar, and statusBar as we don''t need any of those in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0b7b1d8-e5fe-4bcc-a390-a313956cddb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, drag a QQuickWidget from the widget box to the UI canvas. Then,
    click on the Lay Out Horizontally button located at the top of the canvas to add
    layout properties to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28d2e932-e3fa-4392-a2b3-0426a394ff24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, set all the margin properties of the central widget to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a817668-af69-4e72-9b67-377db36a1240.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to create a new file called `mapview.qml` by going to File |
    New File or Project.... After that, select Qt category and follow QML File (Qt
    Quick 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a51fac1-dd56-4e67-bf24-8ac694b71266.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the QML file has been created, open it up and add the following code to
    include the `location`and `positioning`modules to this file so that we can use
    its functions later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we create a `Plugin` object and name it **osm** (**Open Street
    Map**), we then create a Map object and apply the plugin to its `plugin` property.
    We also set the starting coordinates to (`40.7264175,-73.99735`), which is somewhere
    in New York. Other than that, the default `zoom level` is set to `14`, which is
    enough to have a good view of the city:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Before we're able to display the map on our application, we must first create
    a resource file and add the QML file to it. This can be done by going to File
    | Create New File or Project.... Then, select Qt category and pick Qt Resource
    File.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the resource file has been created, add a prefix called `qml`, and add
    the QML file to the prefix, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccdd7e2f-cb58-4ebd-b4f3-dc5320be49f4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now open up `mainwindow.ui` and set the `source` property of the QQuickWidget
    to `qrc:/qml/mapview.qml`. You may also click the button behind the source property
    to select the QML file straight from the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re done, let''s compile and run our project and see what we''ve got!
    You can try panning around and zooming in and out from the map using the mouse,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7151aaa3-59be-4e8a-8dee-883c039e2c05.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though we can achieve the same result by using the web view widget, it
    will make us write a ton of JavaScript code just to display a map like this. By
    using Qt Quick, we only need to write a few simple lines of QML code and that's
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Marker and shape display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we successfully created a map display, but that is
    just the beginning of this project. We need to be able to display custom data
    in the form of markers or shapes layered on top of the map, so that the user can
    understand the data.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying position markers on a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I tell you my favorite restaurant is located at (`40.7802655, -74.108644`),
    you won't be able to make sense of it. However, if those coordinates are being
    displayed on the map view in the form of a location marker, instantly, you will
    have an idea of where it is. Let's see how we can add position markers to our
    map view!
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a marker image that should look something like this,
    or even better, design your own marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04d42016-db00-4884-a2c8-0c8edfb9052d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we need to register this image to our project''s resource file.
    Open up `resource.qrc` with Qt Creator and create a new prefix called `images`.
    Then, add the marker image to the newly created prefix. Do make sure that the
    image has a transparent background to look good on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/935d7d97-990d-4453-a247-1a9a05867f34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, open up `mapview.qml` and replace the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first added an image object that will be used as the
    marker's image. Since the original image is really huge, we have to resize it
    by setting the `sourceSize` property to `50x50`. We must also set the `anchor
    point` of the marker image to the `center-bottom` of the image because that is
    where the tip of the marker is located.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we create a `MapQuickItem` object that will be served as the marker
    itself. Set the marker image as the `sourceItem` of the `MapQuickItem` object,
    then add the marker to the map by calling `map.addMapItem()`. This function must
    be called after the map has been created and is ready to be displayed, which means
    we can only call it after the `Component.onCompleted` event has been triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done with the code, let''s compile and look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6977a437-56a1-4f90-bcc9-55b5005d9fda.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though it's now looking all good, we don't want to hardcode the marker
    in QML. Imagine adding hundreds of markers to the map, it's simply impossible
    to manually add each marker using a distinct set of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a function that allows us to dynamically create position
    markers, we need to first separate the marker QML code from `mapview.qml` to a
    new QML file. Let''s create a new QML file called `marker.qml` and add it to the
    resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dd8239b-895d-482c-985e-cde898426da4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, remove both the `MapQuickItem` and `Image` objects from `mapview.qml` and
    move it to `marker.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, I have merged the `Image` object with
    the `MapQuickItem` object. The coordinate property has also been removed as we
    will only set it when putting the marker on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open up `mapview.qml` again, and add this function to the `Item` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we first created a component by loading the `marker.qml`
    file. Then, we created an object/item from the component by calling `createObject()`.
    In the `createObject()` function, we made the window object as its parent and
    set its position to the coordinate supplied by the `addMarker()` function. Finally,
    we added the item to the map for it to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we want to create a new position marker, we''ll just have to call
    this `addMarker()` function. To demonstrate this, let''s create three different
    markers by calling `addMarker()` three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project again, and you should be able to see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/581d34bc-8dfb-46c4-80e3-fbea4706da85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can go even further by adding a text label to each of the markers. To do
    that, first open up `marker.qml`, then add another module called `QtQuick.Controls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add a custom property to the `MapQuickItem` object called `labelText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re done, change its `sourceItem` property into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we created an `Item` object to group multiple objects
    together. Then, we created a `Rectangle` object to serve as the label background
    and a `Label` object for the text. The `text` property of the `Label` object will
    get linked to the `labelText` property of the `MapQuickItem` object. We can add
    another input to the `addMarker()` function for setting the `labelText` property,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, when we create the markers, we can call the `addMarker()` function
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project again and you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b2f536b-7199-4fd7-bd36-b15745c7e285.png)'
  prefs: []
  type: TYPE_IMG
- en: Pretty awesome isn't it? However, we're not done yet. Since we're most likely
    using C++ to obtain data from the database through Qt's SQL module, we need to
    find a way to call the QML function from C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, let''s comment out the three `addMarker()` functions in `mapview.qml`
    and open up `mainwindow.h` and the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.cpp` and call the `QMetaObject::invokeMethod()`
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code might seem complex, but it's actually really simple if we
    dissect it and analyze each of its arguments. The first argument of the preceding
    function is the object that we want to call the function from, and in this case,
    it is the root object (the `Item` object in `mapview.qml`) of the map view widget.
    Next, we want to tell which function name we want to call, and it is the `addMarker()`
    function. After that, the third argument is the connection type used by the signal
    and slot system to invoke this method. For this, we'll just let it be the default
    setting, which is `Qt::AutoConnection`. The rest are the arguments that are needed
    by the `addMarker()` function. We used the `Q_ARG` macro for indicating the type
    and value of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, build and run the application again. You will see a marker with the
    label has been added to the map, but this time, it''s called from our C++ code
    instead of QML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3372e8f3-0227-467a-ba57-3a7033d395e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying shapes on a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides adding markers to the map, we can also draw different types of shapes
    on the map to indicate an area of interest or serve as geofences, which give out
    warnings whenever a target is entering or leaving the area covered by the shape.
    A geofence is a polygonal shape that defines an area of interest or virtual geographic
    boundary on a map for location-based services. Usually, geofences are used to
    trigger an alarm when a device is entering and/or exiting a geofence. A good example
    of using a geofence is when you need a shopping reminder, you can draw a geofence
    around the supermarket and attach a shopping list along with the geofence. When
    you (and your phone) are entering the area of the geofence, you will get a notification
    on your phone that reminds you what to buy. Wouldn't that be great?
  prefs: []
  type: TYPE_NORMAL
- en: For more information about geofences, please visit: `https://en.wikipedia.org/wiki/Geo-fence`
  prefs: []
  type: TYPE_NORMAL
- en: We won't be creating a functional geofence in this chapter as it is quite an
    advanced topic, and it usually runs as a server-side service for checking and
    triggering an alarm. We will only use Qt to draw the shape and display it visually
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw shapes on the map view widget, we''ll create a few more QML files for
    each type of shape and add them to the program''s resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ea97aa7-6e6d-4218-8515-adc2ad7578b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For each of the newly created QML files, we''ll do something similar to the
    position marker. For `circle.qml`, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We only declare `borderWidth` in this file because we can directly set the
    other properties later, when calling the `createCircle()` function. The same goes
    for `rectangle.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat a similar step for `polygon.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set other properties if you want, but for the sake of demonstration,
    we only change a few of the properties such as color, shape, and border width.
    Once you''re done, let''s open up `mapview.qml` and define a few functions for
    adding the shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are very similar to the `addMarker()` function, except it takes
    in different arguments that are later passed to the `createObject()` function.
    After that, let''s try and create the shapes using the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the shapes created using the functions we have just defined.
    I have called each of the functions separately to demonstrate its outcome, hence
    the three different windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6a0e1b2-e88a-4a65-b6a0-c5c4ea11274d.png)'
  prefs: []
  type: TYPE_IMG
- en: Obtaining a user's location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides us with a set of functions to retrieve a user's location information,
    but it will only work if the user's device supports geopositioning. This should
    work on all modern smartphones and might work on some of the modern computers
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the user''s location using the `Qt Location` module, first let''s
    open up `mainwindow.h` and add the following header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, declare the following `slot` function in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after that, open up `mainwindow.cpp` and add the following code to the
    place where you want it to start getting the user''s location. For demonstration
    purposes, I''ll just call it within the `MainWindow` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `positionUpdated()` function we declared earlier, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you build and run the application now, you may or may not get any location
    information, depending on the device you use to run the test. If you get debug
    messages like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d9095bd8-9aa1-4369-998f-0cc65b69698d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then you probably need to find some other devices for the test. Otherwise,
    you may get a result similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: I will leave you an assignment here which you can try and do by making use of
    the functions that we have created thus far. Since you can now obtain the coordinates
    of your location, try and further enhance your application by adding a marker
    to the map display to show where you are currently located. That should be fun
    to work with!
  prefs: []
  type: TYPE_NORMAL
- en: Geo Routing Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another important feature called **Geo Routing Request**, which is
    a set of functions that help you plot out the route (often the shortest route)
    from point A to point B. This feature requires a service provider; in this case,
    we will be using **Open Street Map** (**OSM**) as it is completely free.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that OSM is an online collaborative project, which means that if no
    one from your area contributed the route data to the OSM server, then you won't
    be able to get an accurate result. Optionally, you can also use paid services
    such as Mapbox or ESRI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can implement Geo Routing Request in Qt! First, include the
    following headers to our `mainwindow.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add two slot functions to `MainWindow` class, namely, `routeCalculated()`
    and `routeError()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re done, open up `mainwindow.cpp` and create a service provider object
    in the `MainWindow` constructor method. We will be using the OSM service so we''ll
    place the acronym `"osm"` when initiating the `QGeoServiceProvider` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after that, we''ll get the pointer of the routing manager from the service
    provider object we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, connect the `finished()` signal and `error()` signal from the routing
    manager with the `slot` functions we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These slot functions will be triggered when there is a reply from the service
    provider upon a successful request, or when the request is failed and returned
    with an error message instead. The `routeCalculated()` slot function looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `QGeoRouteReply` pointer contains route information sent
    by the service provider upon a successful request. Sometimes it comes with more
    than one route, so in the example, we just obtain the first route and display
    it through Qt's application output window. Alternatively, you can use these coordinates
    to draw a path or animate your marker along the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for `routeError()` slot function, we''ll just output the error string sent
    by the service provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re done with that, let''s initiate a Geo Routing Request in the `MainWindow`
    constructor method and send it to the service provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the project now and you should see results like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/849cb2c6-e347-4f25-b95e-743695a488fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Here comes another challenging assignment for you—try to put all these coordinates
    into an array and create an `addLine()` function that takes in the array and draws
    a series of straight lines that represent the route described by the Geo Routing
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Geo Routing has been one of the most important features ever since GPS navigator
    systems were invented. Hopefully, you will be able to create something useful
    after going through the tutorial!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create our own map view similar to Google
    Maps. We have learned how to create a map display, placing markers and shapes
    on the map, and finally finding a user's location. Do note that you can also use
    the web view and call Google's JavaScript mapping API to create a similar map
    display. However, using QML is much simpler, lightweight (we don't have to load
    the entire web engine module just to use the map), works very well on mobile and
    touch screens, and it can also be easily ported to other map services. Hopefully,
    you can make use of this knowledge and create something really awesome and useful.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into how to display information using graphical
    items. Let's move on!
  prefs: []
  type: TYPE_NORMAL
