- en: Working with Numbers and Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Converting between numeric and string types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and other properties of numeric types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pseudo-random numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing all bits of internal state of a pseudo-random number generator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw string literals to avoid escaping characters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cooked user-defined literals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raw user-defined literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library of string helpers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the format of a string using regular expressions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the content of a string using regular expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the content of a string using regular expressions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using string_view instead of constant string references
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between numeric and string types
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting between number and string types is a ubiquitous operation. Prior
    to C++11, there was little support for converting numbers to strings and back,
    and developers had to resort mostly to type-unsafe functions and usually wrote
    their own utility functions in order to avoid writing the same code over and over
    again. With C++11, the standard library provides utility functions for converting
    between numbers and strings. In this recipe, you will learn how to convert between
    numbers and strings and the other way around using modern C++ standard functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the utility functions mentioned in this recipe are available in the `<string>`
    header.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following standard conversion functions when you need to convert between
    numbers and strings:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert from an integer or floating point type to a string type, use `std::to_string()`
    or `std::to_wstring()` as shown in the following code snippet:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To convert from a string type to an integer type, use `std::stoi()`, `std::stol()`,
    `std::stoll()`, `std::stoul()`, or `std::stoull()`; refer to the following code
    snippet:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To convert from a string type to a floating point type, use `std::stof()`,
    `std::stod()`, or `std::stold()`, as shown in the following code snippet:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert between an integral or floating point type to a string type, you
    can use either the `std::to_string()` or `std::to_wstring()` function. These functions
    are available in the `<string>` header and have overloads for signed and unsigned
    integer and real types. They produce the same result as `std::sprintf()` and `std::swprintf()`
    would produce when called with the appropriate format specifier for each type.
    The following code snippet list all the overloads of these two functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When it comes to the opposite conversion, there is an entire set of functions
    that have the name with the format **ston** (**string to number**), where **n**
    stands for **i** (`integer`), **l** (`long`), **ll** (`long long`), **ul** (`unsigned
    long`), or **ull** (`unsigned long long`). The following listing shows all these
    functions, each of them with two overloads, one that takes an `std::string` and
    one that takes an `std::wstring` as the first parameter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The way the string to integral type functions work is by discarding all white
    spaces before a non-whitespace character, then taking as many characters as possible
    to form a signed or unsigned number (depending on the case), and then converting
    that to the requested integral type (`stoi()` will return an `integer`, `stoul()`
    will return an `unsigned long`, and so on). In all the following examples, the
    result is integer `42`, except for the last example where the result is `-42`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A valid integral number may consist of the following parts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: A sign, plus (`+`) or minus (`-`) (optional).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix `0` to indicate an octal base (optional).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix `0x` or `0X` to indicate a hexadecimal base (optional).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence of digits.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional prefix `0` (for octal) is applied only when the specified base
    is `8` or `0`. Similarly, the optional prefix `0x` or `0X` (for hexadecimal) is
    applied only when the specified base is `16` or `0`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions that convert a string to an integer have three parameters:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The input string.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer that when not null will receive the number of characters that were
    processed and that can include any leading white spaces that were discarded, the
    sign, and the base prefix, so it should not be confused with the number of digits
    the integral value has.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指针，如果不为空，将接收处理的字符数，可以包括任何被丢弃的前导空格，符号和基数前缀，因此不应与整数值的数字数量混淆。
- en: A number indicating the base; by default, this is `10`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示基数的数字；默认情况下为`10`。
- en: The valid digits in the input string depend on the base. For base `2`, the only
    valid digits are `0` and `1`; for base `5`, they are `01234`. For base `11`, the
    valid digits are `0-9` and characters `A` and `a`. This continues until we reach
    base `36` that has valid characters `0-9`, `A-Z`, and `a-z`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符串中的有效数字取决于基数。对于基数`2`，唯一有效的数字是`0`和`1`；对于基数`5`，它们是`01234`。对于基数`11`，有效数字是`0-9`和字符`A`和`a`。这一直持续到我们达到基数`36`，它具有有效字符`0-9`，`A-Z`和`a-z`。
- en: 'The following are more examples of strings with numbers in various bases converted
    to decimal integers. Again, in all cases, the result is either `42` or `-42`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将各种基数的字符串转换为十进制整数的更多示例。同样，在所有情况下，结果要么是`42`，要么是`-42`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An important thing to note is that these conversion functions throw if the
    conversion fails. There are two exceptions that can be thrown:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，如果转换失败，这些转换函数会抛出异常。可以抛出两种异常：
- en: '`std::invalid_argument`: If the conversion cannot be performed:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::invalid_argument`：如果无法执行转换：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`std::out_of_range`: If the converted value is outside the range of the result
    type (or if the underlying function sets `errno` to `ERANGE`):'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::out_of_range`：如果转换后的值超出了结果类型的范围（或者如果底层函数将`errno`设置为`ERANGE`）：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The other set of functions that convert a string to a floating point type is
    very similar, except that they don''t have a parameter for the numeric base. A
    valid floating point value can have different representations in the input string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为浮点类型的另一组函数非常相似，只是它们没有用于数字基数的参数。有效的浮点值可以在输入字符串中有不同的表示：
- en: Decimal floating point expression (optional sign, sequence of decimal digits
    with optional point, optional `e` or `E` followed by exponent with optional sign).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制浮点表达式（可选符号，带有可选小数点的十进制数字序列，可选的`e`或`E`后跟带有可选符号的指数）。
- en: Binary floating point expression (optional sign, `0x` or `0X` prefix, sequence
    of hexadecimal digits with optional point, optional `p` or `P` followed by exponent
    with optional sign).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制浮点表达式（可选符号，`0x`或`0X`前缀，带有可选小数点的十六进制数字序列，可选的`p`或`P`后跟带有可选符号的指数）。
- en: Infinity expression (optional sign followed by case insensitive `INF` or `INFINITY`).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷大表达式（可选符号后跟不区分大小写的`INF`或`INFINITY`）。
- en: A non-number expression (optional sign followed by case insensitive `NAN` and
    possibly other alphanumeric characters).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非数字表达式（可选符号后跟不区分大小写的`NAN`和可能的其他字母数字字符）。
- en: 'The following are various examples of converting strings to doubles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将字符串转换为双精度浮点数的各种示例：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The floating-point base 2 scientific notation, seen earlier in the form `0xF.6E6666p3`,
    is not the topic of this recipe. However, for a clear understanding, a short description
    is provided; although, it is recommended that you see additional references for
    details. A floating-point constant in the base 2 scientific notation is composed
    of several parts:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前看到的浮点基数2科学计数法，以`0xF.6E6666p3`的形式出现，不是本篇文章的主题。但是，为了清楚起见，提供了一个简短的描述；尽管建议您查看其他参考资料以获取详细信息。基数2科学计数法中的浮点常数由几个部分组成：
- en: The hexadecimal prefix `0x`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制前缀`0x`。
- en: An integer part, in this example was `F`, which in decimal is 15.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数部分，在这个例子中是`F`，在十进制中是15。
- en: 'A fractional part, which in this example was `6E6666`, or `011011100110011001100110`
    in binary. To convert that to decimal, we need to add inverse powers of two: `1/4
    + 1/8 + 1/32 + 1/64 + 1/128 + ...`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小数部分，在这个例子中是`6E6666`，或者用二进制表示为`011011100110011001100110`。要将其转换为十进制，我们需要加上二的倒数幂：`1/4
    + 1/8 + 1/32 + 1/64 + 1/128 + ...`。
- en: A suffix, representing a power of 2; in this example, `p3` means 2 at the power
    of 3.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个后缀，表示2的幂；在这个例子中，`p3`表示2的3次幂。
- en: The value of the decimal equivalent is determined by multiplying the significant
    (composed of the integer and fractional parts) and the base at the power of exponent.
    For the given hexadecimal base 2 floating point literal, the significant is `15.4312499...`
    (note that digits after the seventh one are not shown), the base is 2, and the
    exponent is 3\. Therefore, the result is `15.4212499... * 8`, which is `123.44999980926514`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制等价值的值由乘以有效数字（由整数和小数部分组成）和基数的幂决定。对于给定的十六进制基数2浮点文字，有效数字是`15.4312499...`（注意第七位后的数字没有显示），基数是2，指数是3。因此，结果是`15.4212499...
    * 8`，即`123.44999980926514`。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '**Limits and other properties of numeric types**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字类型的限制和其他属性**'
- en: Limits and other properties of numeric types
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型的限制和其他属性
- en: Sometimes, it is necessary to know and use the minimum and maximum values representable
    with a numeric type, such as `char`, `int`, or `double`. Many developers are using
    standard C macros for this, such as `CHAR_MIN`/`CHAR_MAX`, `INT_MIN`/`INT_MAX`,
    or `DBL_MIN`/`DBL_MAX`. C++ provides a class template called `numeric_limits`
    with specializations for every numeric type that enables you to query the minimum
    and maximum value of a type, but is not limited to that and offers additional
    constants for type properties querying, such as whether a type is signed or not,
    how many bits it needs for representing its values, for floating point types whether
    it can represent infinity, and many others. Prior to C++11, the use of `numeric_limits<T>`
    was limited because it could not be used in places where constants were needed
    (examples can include the size of arrays and switch cases). Due to that, developers
    preferred to use the C macros throughout their code. In C++11, that is no longer
    the case, as all the static members of `numeric_limits<T>` are now `constexpr`,
    which means they can be used everywhere a constant expression is expected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要知道和使用数值类型表示的最小和最大值，比如`char`、`int`或`double`。许多开发人员在这方面使用标准C宏，如`CHAR_MIN`/`CHAR_MAX`、`INT_MIN`/`INT_MAX`或`DBL_MIN`/`DBL_MAX`。C++提供了一个名为`numeric_limits`的类模板，为每种数值类型提供了特化，使您能够查询类型的最小和最大值，但不仅限于此，并提供了用于查询类型属性的其他常量，例如类型是否有符号，它需要多少位来表示其值，对于浮点类型是否可以表示无穷大等。在C++11之前，`numeric_limits<T>`的使用是有限的，因为它不能在需要常量的地方使用（例如数组的大小和switch
    case）。因此，开发人员更喜欢在他们的代码中使用C宏。在C++11中，情况已经不再是这样了，因为`numeric_limits<T>`的所有静态成员现在都是`constexpr`，这意味着它们可以在需要常量表达式的所有地方使用。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `numeric_limits<T>` class template is available in the namespace `std` in
    the `<limits>` header.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`numeric_limits<T>`类模板在`<limits>`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use `std::numeric_limits<T>` to query various properties of a numeric type
    `T`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::numeric_limits<T>`来查询数值类型`T`的各种属性：
- en: 'Use `min()` and `max()` static methods to get the smallest and largest finite
    numbers of a type:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`min()`和`max()`静态方法来获取类型的最小和最大有限数：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use other static methods and static constants to retrieve other properties
    of a numeric type:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他静态方法和静态常量来检索数值类型的其他属性：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In C++11, there is no limitation to where `std::numeric_limits<T>` can be used;
    therefore, preferably use it over C macros in your modern C++ code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，`std::numeric_limits<T>`的使用没有限制；因此，在现代C++代码中最好使用它而不是C宏。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::numeric_limits<T>` is a class template that enables developers to
    query property of numeric types. Actual values are available through specializations,
    and the standard library provides specializations for all the built-in numeric
    types (`char`, `short`, `int`, `long`, `float`, `double`, and so on). In addition,
    third parties may provide additional implementation for other types. An example
    could be a numeric library that implements a `bigint` integer type and a `decimal`
    type and provides specializations of `numeric_limits` for these types (such as
    `numeric_limits<bigint>` and `numeric_limits<decimal>`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::numeric_limits<T>`是一个类模板，使开发人员能够查询数值类型的属性。实际值可以通过特化获得，并且标准库为所有内置数值类型（`char`、`short`、`int`、`long`、`float`、`double`等）提供了特化。此外，第三方可能为其他类型提供额外的实现。例如，一个数值库可能实现了`bigint`整数类型和`decimal`类型，并为这些类型提供了`numeric_limits`的特化（如`numeric_limits<bigint>`和`numeric_limits<decimal>`）。'
- en: 'The following specializations of numeric types are available in the `<limits>` header.
    Note that specializations for `char16_t` and `char32_t` are new in C++11; the
    others were available previously. Apart from the specializations listed ahead,
    the library also includes specializations for every `cv-qualified` version of
    these numeric types, and they are identical to the unqualified specialization.
    For example, consider type `int`; there are four actual specializations (and they
    are identical): `numeric_limits<int>`, `numeric_limits<const int>`, `numeric_limits<volatile
    int>`, and `numeric_limits<const volatile int>`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数值类型的特化在`<limits>`头文件中可用。请注意，`char16_t`和`char32_t`的特化是C++11中的新内容；其他的在此之前就已经可用了。除了列出的特化之外，该库还包括了这些数值类型的每个`cv-qualified`版本的特化，并且它们与未经修饰的特化相同。例如，考虑类型`int`；有四个实际的特化（它们是相同的）：`numeric_limits<int>`、`numeric_limits<const
    int>`、`numeric_limits<volatile int>`和`numeric_limits<const volatile int>`：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As mentioned earlier, in C++11, all static members of `numeric_limits` are
    `constexpr`, which means they can be used in all places where constant expressions
    are needed. These have several major advantages over C++ macros:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在C++11中，`numeric_limits`的所有静态成员都是`constexpr`，这意味着它们可以在需要常量表达式的所有地方使用。它们比C++宏有几个主要优势：
- en: They are easier to remember, as the only thing you need to know is the name
    of the type that you should know anyway, and not countless names of macros.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更容易记住，因为你唯一需要知道的是你本来就应该知道的类型的名称，而不是无数的宏名称。
- en: They support types that are not available in C, such as `char16_t` and `char32_t`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持在C中不可用的类型，比如`char16_t`和`char32_t`。
- en: They are the only possible solution for templates where you don't know the type.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是你不知道类型的模板的唯一可能的解决方案。
- en: Minimum and maximum are only two of the various properties of types it provides;
    therefore, its actual use is beyond the numeric limits. As a side note, for this
    reason, the class should have been perhaps called `numeric_properties`, instead
    of `numeric_limits`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值和最大值只是它提供的各种类型属性中的两个；因此，它的实际用途超出了数值限制。顺便说一句，因此，这个类可能本应该被称为`numeric_properties`，而不是`numeric_limits`。
- en: 'The following function template `print_type_properties()` prints the minimum
    and maximum finite values of the type as well as other information:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数模板`print_type_properties()`打印类型的最小和最大有限值以及其他信息：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we call the `print_type_properties()` function for unsigned `short`, `int`,
    and `double`, it will have the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '| `unsigned short` | `int` | `double` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| min=0max=65535bits=16decdigits=4integral=1signed=0exact=1infinity=0 | min=-2147483648max=2147483647bits=31decdigits=9integral=1signed=1exact=1infinity=0
    | min=2.22507e-308max=1.79769e+308bits=53decdigits=15integral=0signed=1exact=0infinity=1
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: 'The one thing to take note of is the difference between the `digits` and `digits10`
    constants:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`digits` represent the number of bits (excluding the sign bit if present) and
    padding bits (if any) for integral types and the number of bits of the mantissa
    for floating point types.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digits10` is the number of decimal digits that can be represented by a type
    without a change. To understand this better, let''s consider the case of `unsigned
    short`. This is a 16-bit integral type. It can represent numbers between 0 and
    65536\. It can represent numbers up to five decimal digits, 10,000 to 65,536,
    but it cannot represent all five decimal digit numbers, as numbers from 65,537
    to 99,999 require more bits. Therefore, the largest numbers that it can represent
    without requiring more bits have four decimal digits (numbers from 1,000 to 9,999).
    This is the value indicated by `digits10`. For integral types, it has a direct
    relationship to constant `digits`; for an integral type `T`, the value of `digits10`
    is `std::numeric_limits<T>::digits * std::log10(2)`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pseudo-random numbers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating random numbers is necessary for a large variety of applications,
    from games to cryptography, from sampling to forecasting. However, the term *random
    numbers* is not actually correct, as the generation of numbers through mathematical
    formulas is deterministic and does not produce true random numbers, but numbers
    that look random and are called *pseudo-random*. True randomness can only be achieved
    through hardware devices, based on physical processes, and even that can be challenged,
    as one may consider even the universe to be actually deterministic. Modern C++
    provides support for generating pseudo-random numbers through a pseudo-random
    number library containing number generators and distributions. Theoretically,
    it can also produce true random numbers, but in practice, those could actually
    be only pseudo-random.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we discuss the standard support for generating pseudo-random
    numbers. Understanding the difference between random and pseudo-random numbers
    is the key. On the other hand, being familiar with various statistical distributions
    is a plus. It is mandatory, though, that you know what a uniform distribution
    is because all engines in the library produce numbers that are uniformly distributed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate pseudo-random numbers in your application, you should perform the
    following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the header `<random>`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use an `std::random_device` generator for seeding a pseudo-random engine:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use one of the available engines for generating numbers and initialize it with
    a random seed:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use one of the available distributions for converting the output of the engine
    to one of the desired statistical distributions:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Generate the pseudo-random numbers:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pseudo-random number library contains two types of components:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*Engines*, which are generators of random numbers; these could produce either
    pseudo-random numbers with a uniform distribution or, if available, actual random
    numbers.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Distributions* that convert the output of an engine into a statistical distribution.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All engines (except for `random_device`) produce integer numbers in a uniform
    distribution, and all engines implement the following methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`min()`: This is a static method that returns the minimum value that can be
    produced by the generator.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max()`: This is a static method that returns the maximum value that can be
    produced by the generator.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seed()`: This initializes the algorithm with a start value (except for `random_device`,
    which cannot be seeded).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed()`: 用起始值初始化算法（除了 `random_device`，它不能被种子化）。'
- en: '`operator()`: This generates a new number uniformly distributed between `min()`
    and `max()`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator()`: 生成一个在 `min()` 和 `max()` 之间均匀分布的新数字。'
- en: '`discard()`: This generates and discards a given number of pseudo-random numbers.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard()`: 生成并丢弃给定数量的伪随机数。'
- en: 'The following engines are available:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引擎可用：
- en: '`linear_congruential_engine`: This is a linear congruential generator that
    produces numbers using the following formula:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性同余引擎：这是一个使用以下公式产生数字的线性同余生成器：
- en: '*x(i) = (A * x(i-1) + C) mod M*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*x(i) = (A * x(i-1) + C) mod M*'
- en: '`mersenne_twister_engine`: This is a Mersenne twister generator that keeps
    a value on *W * (N-1) * R* bits; each time a number needs to be generated, it
    extracts *W* bits. When all bits have been used, it twists the large value by
    shifting and mixing the bits so that it has a new set of bits to extract from.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mersenne_twister_engine：这是一个 Mersenne twister 生成器，保留了 *W * (N-1) * R* 位的值；每次需要生成一个数字时，它提取
    *W* 位。当所有位都被使用时，它通过移位和混合位来扭转大值，以便它有一个新的位组来提取。
- en: '`subtract_with_carry_engine`: This is a generator that implements a *subtract
    with carry* algorithm based on the following formula:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: subtract_with_carry_engine：这是一个基于以下公式实现 *减去进位* 算法的生成器：
- en: '*x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M*'
- en: 'In the preceding formula, *cy* is defined as:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述公式中，*cy* 定义为：
- en: '*cy(i) = x(i - S) - x(i - R) - cy(i - 1) < 0 ? 1 : 0*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*cy(i) = x(i - S) - x(i - R) - cy(i - 1) < 0 ? 1 : 0*'
- en: 'In addition, the library provides engine adapters that are also engines wrapping
    another engine and producing numbers based on the output of the base engine. Engine
    adapters implement the same methods mentioned earlier for the base engines. The
    following engine adapters are available:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该库还提供了引擎适配器，它们也是包装另一个引擎并基于基础引擎的输出生成数字的引擎。引擎适配器实现了前面提到的基础引擎的相同方法。以下引擎适配器可用：
- en: '`discard_block_engine`: A generator that from every block of P numbers generated
    by the base engine keeps only R numbers, discarding the rest.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: discard_block_engine：从基础引擎生成的每个P个数字块中仅保留R个数字，丢弃其余数字。
- en: '`independent_bits_engine`: A generator that produces numbers with a different
    number of bits than the base engine.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: independent_bits_engine：生成具有与基础引擎不同位数的数字的生成器。
- en: '`shuffle_order_engine`: A generator that keeps a shuffled table of K numbers
    produced by the base engine and returns numbers from this table, replacing them
    with numbers generated by the base engine.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shuffle_order_engine：保持基础引擎生成的K个数字的洗牌表，并从该表返回数字，用基础引擎生成的数字替换它们。
- en: All these engines and engine adaptors are producing pseudo-random numbers. The
    library, however, provides another engine called `random_device` that is supposed
    to produce non-deterministic numbers, but this is not an actual constraint as
    physical sources of random entropy might not be available. Therefore, implementations
    of `random_device` could actually be based on a pseudo-random engine. The `random_device` class
    cannot be seeded like the other engines and has an additional method called `entropy()` that
    returns the random device entropy, which is 0 for a deterministic generator and
    nonzero for a non-deterministic generator. However, this is not a reliable method
    for determining whether the device is actually deterministic or non-deterministic.
    For instance, both GNU `libstdc++` and LLVM `libc++` implement a non-deterministic
    device, but return `0` for entropy. On the other hand, `VC++` and `boost.random`
    return `32` and `10`, respectively, for entropy.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些引擎和引擎适配器都产生伪随机数。然而，该库还提供了另一个称为 `random_device` 的引擎，它应该产生非确定性数字，但这并不是一个实际的约束，因为可能没有随机熵的物理来源。因此，`random_device`
    的实现实际上可能基于伪随机引擎。`random_device` 类不能像其他引擎一样进行种子化，并且具有一个额外的名为 `entropy()` 的方法，返回随机设备的熵，对于确定性生成器为0，对于非确定性生成器为非零。然而，这并不是确定设备实际上是确定性还是非确定性的可靠方法。例如，GNU
    `libstdc++` 和 LLVM `libc++` 实现了一个非确定性设备，但对于熵返回 `0`。另一方面，`VC++` 和 `boost.random`
    对于熵分别返回 `32` 和 `10`。
- en: 'All these generators produce integers in a uniform distribution. This is, however,
    only one of the many possible statistical distributions that random numbers are
    needed in most applications. To be able to produce numbers (either integer or
    real) in other distributions, the library provides several classes that are called
    *distributions* and are converting the output of an engine according to the statistical
    distribution it implements. The following distributions are available:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些生成器产生均匀分布的整数。然而，这只是大多数应用程序中需要的许多可能统计分布中的一个。为了能够以其他分布（整数或实数）产生数字，该库提供了几个称为
    *分布* 的类，它们根据它们实现的统计分布将引擎的输出转换为数字。以下分布可用：
- en: '| **Type** | **Class name** | **Numbers** | **Statistical distribution** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '**类型** | **类名** | **数字** | **统计分布** |'
- en: '| Uniform | `uniform_int_distribution` | integer | Uniform |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: 均匀 | 均匀整数分布 | 整数 | 均匀 |
- en: '|  | `uniform_real_distribution` | real | Uniform |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: 均匀实数分布 | 实数 | 均匀 |
- en: '| Bernoulli | `bernoulli_distribution` | boolean | Bernoulli |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: 伯努利 | 伯努利分布 | 布尔 | 伯努利 |
- en: '|  | `binomial_distribution` | integer | binomial |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: 二项式 | 二项分布 | 整数 | 二项式 |
- en: '|  | `negative_binomial_distribution` | integer | negative binomial |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: 负二项式 | 负二项分布 | 整数 | 负二项式 |
- en: '|  | `geometric_distribution` | integer | geometric |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: 几何分布 | 整数 | 几何 |
- en: '| Poisson | `poisson_distribution` | integer | poisson |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: 泊松 | 泊松分布 | 整数 | 泊松 |
- en: '|  | `exponential_distribution` | real | exponential |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: 指数 | 指数分布 | 实数 | 指数 |
- en: '|  | `gamma_distribution` | real | gamma |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: 伽玛 | 伽玛分布 | 实数 | 伽玛 |
- en: '|  | `weibull_distribution` | real | Weibull |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: 威布尔 | 威布尔分布 | 实数 | 威布尔 |
- en: '|  | `extreme_value_distribution` | real | extreme value |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: 极值分布 | 实数 | 极值 |
- en: '| Normal | `normal_distribution` | real | standard normal (Gaussian) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 正态 | `normal_distribution` | real | 标准正态（高斯） |'
- en: '|  | `lognormal_distribution` | real | lognormal |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | `lognormal_distribution` | real | 对数正态 |'
- en: '|  | `chi_squared_distribution` | real | chi-squared |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | `chi_squared_distribution` | real | 卡方 |'
- en: '|  | `cauchy_distribution` | real | Cauchy |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | `cauchy_distribution` | real | 柯西 |'
- en: '|  | `fisher_f_distribution` | real | Fisher''s F-distribution |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | `fisher_f_distribution` | real | 费舍尔F分布 |'
- en: '|  | `student_t_distribution` | real | Student''s t-distribution |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  | `student_t_distribution` | real | 学生t分布 |'
- en: '| Sampling | `discrete_distribution` | integer | discrete |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 采样 | `discrete_distribution` | 整数 | 离散 |'
- en: '|  | `piecewise_constant_distribution` | real | values distributed on constant
    subintervals |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | `piecewise_constant_distribution` | real | 在常数子区间上分布的值 |'
- en: '|  | `piecewise_linear_distribution` | real | values distributed on defined
    subintervals |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  | `piecewise_linear_distribution` | real | 在定义的子区间上分布的值 |'
- en: Each of the engines provided by the library has advantages and disadvantages.
    The linear congruential engine has a small internal state, but it is not very
    fast. On the other hand, the subtract with carry engine is very fast, but requires
    more memory for its internal state. The Mersenne twister is the slowest of them
    and the one that has the largest internal state, but when initialized appropriately
    can produce the longest non-repeating sequence of numbers. In the following examples,
    we will use `std::mt19937`, a 32-bit Mersenne twister with 19,937 bits of internal
    state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 库提供的每个引擎都有优缺点。线性同余引擎具有较小的内部状态，但速度不是很快。另一方面，减法进位引擎非常快，但需要更多内部状态的内存。Mersenne扭曲器是它们中最慢的，也是内部状态最大的一个，但在适当初始化时可以产生最长的不重复数字序列。在以下示例中，我们将使用`std::mt19937`，一个32位Mersenne扭曲器，内部状态有19,937位。
- en: 'The simplest way to generate random numbers looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的最简单方法如下：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, `mtgen` is an `std::mt19937` Mersenne twister. To generate
    numbers, you only need to use the call operator that advances the internal state
    and returns the next pseudo-random number. However, this code is flawed, as the
    engine is not seeded. As a result, it always produces the same sequence of numbers,
    which is probably not what you want in most cases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mtgen`是一个`std::mt19937` Mersenne扭曲器。要生成数字，只需要使用调用运算符来推进内部状态并返回下一个伪随机数。然而，这段代码有缺陷，因为引擎没有被种子化。因此，它总是产生相同的数字序列，这在大多数情况下可能不是你想要的。
- en: 'There are different approaches for initializing the engine. One approach, common
    with the C rand library, is to use the current time. In modern C++, it should
    look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来初始化引擎。一种方法，与C rand库常见，是使用当前时间。在现代C++中，应该是这样的：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, `seed` is a number representing the number of ticks since
    the clock''s epoch until the present moment. This number is then used to seed
    the engine. The problem with this approach is that the value of that `seed` is
    actually deterministic, and in some classes of applications it could be prone
    to attacks. A more reliable approach is to seed the generator with actual random
    numbers. The `std::random_device` class is an engine that is supposed to return
    true random numbers, though implementations could actually be based on a pseudo-random
    generator:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`seed`是一个表示自时钟时代以来的滴答数的数字，直到当前时刻。然后使用这个数字来种子化引擎。这种方法的问题是`seed`的值实际上是确定性的，在某些类别的应用中可能容易受到攻击。更可靠的方法是用真正的随机数来种子化生成器。`std::random_device`类是一个应该返回真正随机数的引擎，尽管实现实际上可能基于伪随机生成器：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Numbers produced by all engines follow a uniform distribution. To convert the
    result to another statistical distribution, we have to use a distribution class.
    To show how generated numbers are distributed according to the selected distribution,
    we will use the following function. This function generates a specified number
    of pseudo-random numbers and counts their repetition in a map. The values from
    the map are then used to produce a bar-like diagram showing how often each number
    occurred:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引擎产生的数字都遵循均匀分布。要将结果转换为另一个统计分布，我们必须使用分布类。为了展示生成的数字如何根据所选的分布进行分布，我们将使用以下函数。该函数生成指定数量的伪随机数，并计算它们在映射中的重复次数。然后使用映射中的值生成类似条形图的图表，显示每个数字发生的频率：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code generates random numbers using the `std::mt19937` engine
    with a uniform distribution in the range `[1, 6]`; that is basically what you
    get when you throw a dice:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`std::mt19937`引擎生成在范围`[1, 6]`内均匀分布的随机数；这基本上就是掷骰子时得到的结果：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the program looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/0aa92f90-d587-4c3d-880b-bd0a859d81b4.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0aa92f90-d587-4c3d-880b-bd0a859d81b4.png)'
- en: 'In the next and final example, we change the distribution to a normal distribution
    with the mean `5` and the standard deviation `2`. This distribution produces real
    numbers; therefore, in order to use the previous `generate_and_print()` function,
    the numbers must be rounded to integers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个和最后一个例子中，我们将分布更改为均值为`5`，标准差为`2`的正态分布。这个分布产生实数；因此，为了使用先前的`generate_and_print()`函数，数字必须四舍五入为整数：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following will be the output of the earlier code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前代码的输出：
- en: '![](img/2f94f238-cc47-44ce-a685-b2e9e437441e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f94f238-cc47-44ce-a685-b2e9e437441e.png)'
- en: See also
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Initializing all bits of internal state of a pseudo-random number generator*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化伪随机数生成器的所有内部状态位*'
- en: Initializing all bits of internal state of a pseudo-random number generator
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化伪随机数生成器的所有内部状态位
- en: In the previous recipe, we have looked at the pseudo-random number library with
    its components and how it can be used to produce numbers in different statistical
    distributions. One important factor that was overlooked in that recipe is the proper
    initialization of the pseudo-random number generators. In this recipe, you will
    learn how to initialize a generator in order to produce the best sequence of pseudo-random
    numbers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们已经看过了伪随机数库及其组件以及如何用它来产生不同统计分布中的数字。 在那个教程中忽略的一个重要因素是伪随机数生成器的正确初始化。
    在本教程中，您将学习如何初始化生成器以产生最佳序列的伪随机数。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe, *Generating pseudo-random numbers*, to
    get an overview of what the pseudo-random number library offers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读前一个教程，*生成伪随机数*，以了解伪随机数库提供了什么。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To properly initialize a pseudo-random number generator to produce the best
    sequence of pseudo-random numbers, perform the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确初始化伪随机数生成器以产生最佳序列的伪随机数，请执行以下步骤：
- en: 'Use an `std::random_device` to produce random numbers to be used as seeding
    values:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::random_device`生成随机数以用作种子值：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Generate random data for all internal bits of the engine:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为引擎的所有内部位生成随机数据：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create an `std::seed_seq` object from the previously generated pseudo-random
    data:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从先前生成的伪随机数据创建一个`std::seed_seq`对象：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create an engine object and initialize all the bits representing the internal
    state of the engine; for example, a `mt19937` has 19,937 bits of internal states:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建引擎对象并初始化表示引擎内部状态的所有位；例如，`mt19937`有19,937位的内部状态：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the appropriate distribution based on the requirements of the application:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据应用程序的要求使用适当的分布：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In all examples shown in the previous recipe, we used an `std::mt19937` engine
    to produce pseudo-random numbers. Though the Mersenne twister is slower than the
    other engines, it can produce the longest sequences of non-repeating numbers and
    with the best spectral characteristics. However, initializing the engine in the
    manner shown in the previous recipe will not have this effect. With a careful
    analysis (that is beyond the purpose of this recipe or this book), it can be shown
    that the engine has a bias toward producing some values repeatedly and omitting
    others, thus generating numbers not in a uniform distribution, but rather in a
    binomial or Poisson distribution. The problem is that the internal state of `mt19937`
    has 624 32-bit integers, and in the examples from the previous recipe we have
    only initialized one of them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中显示的所有示例中，我们使用了一个`std::mt19937`引擎来产生伪随机数。 尽管梅森旋转器比其他引擎慢，但它可以产生最长的非重复数字序列，并具有最佳的频谱特性。
    但是，以前的教程中显示的引擎初始化不会产生这种效果。 通过仔细分析（超出了本教程或本书的目的），可以证明引擎倾向于重复产生一些值并省略其他值，从而生成不均匀分布的数字，而是二项式或泊松分布。
    问题在于`mt19937`的内部状态有624个32位整数，在上一个教程的示例中，我们只初始化了其中一个。
- en: 'When working with the pseudo-random number library, remember the following
    rule of thumb (shown in the information box):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用伪随机数库时，请记住以下经验法则（在信息框中显示）：
- en: In order to produce the best results, engines must have all their internal state
    properly initialized before generating numbers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生最佳结果，引擎在生成数字之前必须正确初始化其所有内部状态。
- en: The pseudo-random number library provides a class for this particular purpose,
    called `std::seed_seq`. This is a generator that can be seeded with any number
    of 32-bit integers and produces a requested number of integers evenly distributed
    in the 32-bit space.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数库提供了一个特定目的的类，称为`std::seed_seq`。 这是一个可以用任意数量的32位整数进行种子化，并在32位空间中产生请求的整数数量的生成器。
- en: In the preceding code from the *How to do it...* section, we defined an array
    called `seed_data` with a number of 32-bit integers equal to the internal state
    of the `mt19937` generator; that is 624 integers. Then, we initialized the array
    with random numbers produced by an `std::random_device`. The array was later used
    to seed an `std::seed_seq`, which in turn was used to seed the `mt19937` generator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分的上述代码中，我们定义了一个名为`seed_data`的数组，其中包含与`mt19937`生成器的内部状态相等的32位整数数量；即624个整数。
    然后，我们使用`std::random_device`生成的随机数初始化了数组。 稍后，该数组用于种子`std::seed_seq`，而`std::seed_seq`又用于种子`mt19937`生成器。
- en: Creating cooked user-defined literals
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建熟悉的用户定义文字
- en: Literals are constants of built-in types (numerical, boolean, character, character
    string, and pointer) that cannot be altered in a program. The language defines
    a series of prefixes and suffixes to specify literals (and the prefix/suffix is
    actually part of the literal). C++11 allows creating user-defined literals by
    defining functions called *literal operators* that introduce suffixes for specifying
    literals. These work only with numerical character and character string types.
    This opens the possibility of defining both standard literals in future versions
    and allows developers to create their own literals. In this recipe, we will see
    how we can create our own cooked literals.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 文字是内置类型（数字，布尔，字符，字符串和指针）的常量，不能在程序中更改。 语言定义了一系列前缀和后缀来指定文字（前缀/后缀实际上是文字的一部分）。 C++11允许通过定义称为*文字运算符*的函数来创建用户定义的文字，引入后缀以指定文字。
    这些仅适用于数字字符和字符串类型。 这打开了在将来版本中定义标准文字并允许开发人员创建自己的文字的可能性。 在本教程中，我们将看到如何创建我们自己的熟悉文字。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'User-defined literals can have two forms: *raw* and *cooked*. Raw literals
    are not processed by the compiler, whereas cooked literals are values processed
    by the compiler (examples can include handling escape sequences in a character
    string or identifying numerical values such as integer 2898 from literal 0xBAD).
    Raw literals are only available for integral and floating-point types, whereas
    cooked literals are also available for character and character string literals.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义文字可以有两种形式：*原始*和*熟*。原始文字不会被编译器处理，而熟文字是编译器处理的值（示例可以包括处理字符字符串中的转义序列或从文字0xBAD中识别整数值2898）。原始文字仅适用于整数和浮点类型，而熟文字也适用于字符和字符字符串文字。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To create cooked user-defined literals, you should follow these steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建熟用户定义文字，应遵循以下步骤：
- en: Define your literals in a separate namespace to avoid name clashes.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的文字定义在单独的命名空间中，以避免名称冲突。
- en: Always prefix the user-defined suffix with an underscore (`_`).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终使用下划线（`_`）作为用户定义后缀的前缀。
- en: 'Define a literal operator of the following form for cooked literals:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为熟文字定义以下形式的文字运算符：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following example creates a user-defined literal for specifying kilobytes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个用于指定千字节的用户定义文字：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the compiler encounters a user-defined literal with a user-defined suffix
    `S` (it always has a leading underscore for third-party suffixes, as the suffixes
    without a leading underscore are reserved for the standard library) it does an
    unqualified name lookup in order to identify a function with the name operator
    `"operator "" S`. If it finds one, then it calls it according to the type of the
    literal and the type of the literal operator. Otherwise, the compiler will yield
    and error.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到具有用户定义后缀`S`的用户定义文字时（对于第三方后缀，它总是具有前导下划线，因为没有前导下划线的后缀是为标准库保留的），它会进行无限定名称查找，以便识别具有名称`operator
    "" S`的函数。如果找到一个，那么根据文字的类型和文字运算符的类型调用它。否则，编译器将产生错误。
- en: In the example from the *How to do it...* section, the literal operator is called
    `operator "" _KB` and has an argument of type `unsigned long long int`. This is
    the only integral type possible for literal operators for handling integral types.
    Similarly, for floating-point user-defined literals, the parameter type must be
    `long double` since for numeric types the literal operators must be able to handle
    the largest possible values. This literal operator returns a `constexpr` value
    so that it can be used where compile time values are expected, such as specifying
    the size of an array as shown in the above example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做到...*部分的示例中，文字运算符称为`operator "" _KB`，其参数类型为`unsigned long long int`。这是处理整数类型的文字运算符的唯一可能类型。类似地，对于浮点数用户定义文字，参数类型必须是`long
    double`，因为对于数值类型，文字运算符必须能够处理可能的最大值。此文字运算符返回`constexpr`值，以便在需要编译时值的地方使用，例如在上面示例中指定数组大小时。
- en: 'When the compiler identifies a user-defined literal and has to call the appropriate
    user-defined literal operator, it will pick the overload from the overload set
    according to the following rules:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器识别用户定义文字并且必须调用适当的用户定义文字运算符时，它将根据以下规则从重载集中选择重载：
- en: '**For integral literals**: It calls in the following order: the operator that
    takes an `unsigned long long`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于整数文字**：按以下顺序调用：接受`unsigned long long`的运算符，接受`const char*`的原始文字运算符，或文字运算符模板。'
- en: '**For floating-point literals**: It calls in the following order: the operator
    that takes a `long double`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于浮点文字**：按以下顺序调用：接受`long double`的运算符，接受`const char*`的原始文字运算符，或文字运算符模板。'
- en: '**For character literals**: It calls the appropriate operator depending on
    the character type (`char`, `wchar_t`, `char16_t`, and `char32_t`).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于字符文字**：根据字符类型（`char`、`wchar_t`、`char16_t`和`char32_t`）调用适当的运算符。'
- en: '**For string literals**: It calls the appropriate operator, depending on the
    string type that takes a pointer to the string of characters and the size.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于字符串文字**：根据接受指向字符字符串和大小的指针的字符串类型调用适当的运算符。'
- en: 'In the following example, we define a system of units and quantities. We want
    to operate with kilograms, pieces, liters, and other types of units. This could
    be useful in a system that can process orders and you need to specify the amount
    and unit for each article. The following are defined in the namespace `units`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个单位和数量的系统。我们希望使用千克、件、升和其他类型的单位进行操作。这在需要处理订单并且需要为每个商品指定数量和单位的系统中可能很有用。以下内容在命名空间`units`中定义：
- en: 'A scoped enumeration for the possible types of units (kilogram, meter, liter,
    and pieces):'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于单位可能类型（千克、米、升和件）的作用域枚举：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A class template to specify quantities of a particular unit (such as 3.5 kilograms
    or 42 pieces):'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于指定特定单位的数量的类模板（例如3.5千克或42件）：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `operator+` and `operator-` functions for the `quantity` class template
    in order to be able to add and subtract quantities:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`类模板的`operator+`和`operator-`函数，以便能够添加和减去数量：'
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Literal operators to create `quantity` literals, defined in an inner namespace
    called `unit_literals`. The purpose of this is to avoid possible name clashes
    with literals from other namespaces. If such collisions do happen, developers
    could select the ones that they should use using the appropriate namespace in
    the scope where the literals need to be defined:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字运算符用于创建`quantity`文字，定义在名为`unit_literals`的内部命名空间中。这样做的目的是避免与其他命名空间中的文字可能发生的名称冲突。如果确实发生这样的冲突，开发人员可以在需要定义文字的范围中使用适当的命名空间来选择他们应该使用的文字：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By looking carefully, you can note that the literal operators defined earlier
    are not the same:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，可以注意到先前定义的文字运算符不同：
- en: '`_kg` is defined for both integral and floating point literals; that enables
    us to create both integral and floating point values such as `1_kg` and `1.0_kg`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_l` and `_m` are defined only for floating point literals; that means we can
    only define quantity literals for these units with floating points, such as `4.5_l`
    and `10.0_m`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_pcs` is only defined for integral literals; that means we can only define
    quantities of an integer number of pieces, such as `42_pcs`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having these literal operators available, we can operate with various quantities.
    The following examples show both valid and invalid operations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`q1` is a quantity of 1 kg; that is an integer value. Since an overloaded `operator
    "" _kg(unsigned long long const)` exists, the literal can be correctly created
    from the integer 1\. Similarly, `q2` is a quantity of 4.5 kilograms; that is a
    real value. Since an `overload operator "" _kg(long double)` exists, the literal
    can be created from the double floating point value 4.5.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `q6` is a quantity of 1 liter. Since there is no overloaded `operator
    "" _l(unsigned long long)`, the literal cannot be created. It would require an
    overload that takes a `unsigned long long`, but such an overload does not exist.
    Similarly, `q7` is a quantity of 2.0 pieces, but piece literals can only be created
    from integer values and, therefore, this generates another compiler error.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though user-defined literals are available from C++11, standard literal operators
    have been available only from C++14\. The following is a list of these standard
    literal operators:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`operator""s` for defining `std::basic_string` literals:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`operator""h`, `operator""min`, `operator""s`, `operator""ms`, `operator""us`,
    and `operator""ns` for creating a `std::chrono::duration` value:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`operator""if`, `operator""i`, and `operator""il` for creating a `std::complex`
    value:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using raw string literals to avoid escaping characters*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating raw user-defined literals*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raw user-defined literals
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have looked at the way C++11 allows library implementers
    and developers to create user-defined literals and the user-defined literals available
    in the C++14 standard. However, user-defined literals have two forms, a cooked
    form, where the literal value is processed by the compiler before being supplied
    to the literal operator, and a raw form, in which the literal is not parsed by
    the compiler. The latter is only available for integral and floating-point types.
    In this recipe, we will look at creating raw user-defined literals.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before continuing with this recipe, it is strongly recommended that you go through
    the previous one, *Creating cooked user-defined literals*, as general details
    about user-defined literals will not be reiterated here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: To exemplify the way raw user-defined literals can be created, we will define
    binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned)
    types. These types will be called `byte8`, `byte16`, and `byte32`, and the literals
    we create will be called `_b8`, `_b16`, and `_b32`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create raw user-defined literals, you should follow these steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Define your literals in a separate namespace to avoid name clashes.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always prefix the used-defined suffix with an underscore (`_`).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a literal operator or literal operator template of the following form:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following sample shows a possible implementation of 8-bit, 16-bit, and
    32-bit binary literals:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation in the previous section enables us to define binary literals
    of the form 1010_b8 (a `byte8` value of decimal 10) or 000010101100_b16 (a `byte16`
    value of decimal 2130496). However, we want to make sure that we do not exceed
    the number of digits for each type. In other words, values such as 111100001_b8
    should be illegal and the compiler should yield an error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we define everything inside a namespace called `binary` and start
    with introducing several type aliases (`byte8`, `byte16`, and `byte32`).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The literal operator templates are defined in a nested namespace called `binary_literal_internals`.
    This is a good practice in order to avoid name collision with other literal operators
    from other namespaces. Should something like that happen, you can choose to use
    the appropriate namespace in the right scope (such as one namespace in a function
    or block and another namespace in another function or block).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The three literal operator templates are very similar. The only things that
    are different are their names (`_b8`, `_16`, and `_b32`), return type (`byte8`,
    `byte16`, and `byte32`), and the condition in the static assert that checks the
    number of digits.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the details of variadic template and template recursion in
    a later recipe; however, for a better understanding, this is how this particular
    implementation works: `bits` is a template parameter pack, that is not a single
    value, but all the values the template could be instantiated with. For example,
    if we consider the literal `1010_b8`, then the literal operator template would
    be instantiated as `operator"" _b8<''1'', ''0'', ''1'', ''0''>()`. Before proceeding
    with computing the binary value, we check the number of digits in the literal.
    For `_b8`, this must not exceed eight (including any trailing zeros). Similarly,
    it should be up to 16 digits for `_b16` and 32 for `_b32`. For this, we use the
    `sizeof...` operator that returns the number of elements in a parameter pack (in
    this case, `bits`).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: If the number of digits is correct, we can proceed to expand the parameter pack
    and recursively compute the decimal value represented by the binary literal. This
    is done with the help of an additional class template and its specializations.
    These templates are defined in yet another nested namespace, called `binary_literals_internals`.
    This is also a good practice because it hides (without proper qualification) the
    implementation details from the client (unless an explicit using namespace directive
    makes them available to the current namespace).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Even though this looks like recursion, it is not a true runtime recursion, because
    after the compiler expands and generates the code from templates, what we end
    up with is basically calls to overloaded functions with a different number of
    parameters. This is later explained in the recipe *Writing a function template
    with a variable number of arguments*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The `binary_struct` class template has a template type `CharT` for the return
    type of the function (we need this because our literal operator templates should
    return either `byte8`, `byte16`, or `byte32`) and a parameter pack:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Several specializations of this class template are available with parameter
    pack decomposition. When the first digit of the pack is ''0'', the computed value
    remains the same, and we continue expanding the rest of the pack. If the first
    digit of the pack is ''1'', then the new value is 1 shifted to the left with the
    number of digits in the remainder of the pack bit, or the value of the rest of
    the pack:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The last specialization covers the case when the pack is empty; in this case
    we return 0:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After defining these helper classes, we could implement the `byte8`, `byte16`,
    and `byte32` binary literals as intended. Note that we need to bring the content
    of the namespace `binary_literals` in the current namespace in order to use the
    literal operator templates:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following definitions trigger compiler errors because the condition in
    `static_assert` is not met:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using raw string literals to avoid escaping character*s'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a function template with variable number of arguments* recipe of [Chapter
    10](5ca9534c-f23e-4ef3-a59f-7bd377721eea.xhtml), *Exploring Functions*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw string literals to avoid escaping characters
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings may contain special characters, such as non-printable characters (newline,
    horizontal and vertical tab, and so on), string and character delimiters (double
    and single quotes) or arbitrary octal, hexadecimal, or Unicode values. These special
    characters are introduced with an escape sequence that starts with a backslash,
    followed by either the character (examples include `'` and `"`), its designated
    letter (examples include `n` for a new line, `t` for a horizontal tab), or its
    value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As a result,
    the backslash character itself has to be escaped with another backslash character.
    This leads to more complicated literal strings that can be hard to read.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: To avoid escaping characters, C++11 introduced raw string literals that do not
    process escape sequences. In this recipe, you will learn how to use the various
    forms of raw string literals.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, and throughout the rest of the book, I will use the `s` suffix
    to define `basic_string` literals. This has been covered in the recipe *Creating
    cooked user-defined literals*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid escaping characters, define the string literals with the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`R"( literal )"` as the default form:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`R"delimiter( literal )delimiter"` where `delimiter` is any character sequence
    not present in the actual string when the sequence `)"` should actually be part
    of the string. Here is an example with `!!` as delimited:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When string literals are used, escapes are not processed, and the actual content
    of the string is written between the delimiter (in other words, what you see is
    what you get). The following example shows what appears as the same raw literal
    string; however, the second one still contains escaped characters. Since these
    are not processed in the case of string literals, they will be printed as they
    are in the output:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In case the text has to contain the `)"` sequence, then a different delimiter
    must be used, in the `R"delimiter( literal )delimiter"` form. According to the
    standard, the possible characters in a delimiter can be as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'any member of the basic source character set except: space, the left parenthesis
    (the right parenthesis ), the backslash \, and the control characters representing
    horizontal tab, vertical tab, form feed, and newline.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Raw string literals can be prefixed by one of `L`, `u8`, `u`, and `U` to indicate
    a wide, UTF-8, UTF-16, or UTF-32 string literal. The following are examples of
    such string literals. Note that the presence of string literal `operator ""s`
    at the end of the string makes the compiler deduce the type as various string
    classes and not character arrays:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library of string helpers
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string types from the standard library are a general purpose implementation
    that lacks many helpful methods, such as changing the case, trimming, splitting,
    and others that may address different developer needs. Third-party libraries that
    provide rich sets of string functionalities exist. However, in this recipe, we
    will look at implementing several simple, yet helpful, methods you may often need
    in practice. The purpose is rather to see how string methods and standard general
    algorithms can be used for manipulating strings, but also to have a reference
    to reusable code that can be used in your applications.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement a small library of string utilities that
    will provide functions for the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Changing a string to lowercase or uppercase.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a string.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming white spaces from the beginning and/or the end of the string.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming a specific set of characters from the beginning and/or the end of the
    string.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing occurrences of a character anywhere in the string.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokenizing a string using a specific delimiter.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The string library we will be implementing should work with all the standard
    string types, `std::string`, `std::wstring`, `std::u16string`, and `std::u32string`.
    To avoid specifying long names such as `std::basic_string<CharT, std::char_traits<CharT>,
    std::allocator<CharT>>`, we will use the following alias templates for strings
    and string streams:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To implement these string helper functions, we need to include the header `<string>`
    for strings and `<algorithm>` for the general standard algorithms we will use.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In all the examples in this recipe, we will use the standard user-defined literal
    operators for strings from C++14, for which we need to explicitly use the `std::string_literals` namespace.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert a string to lowercase or uppercase, apply the `tolower()` or `toupper()`
    functions on the characters of a string using the general purpose algorithm `std::transform()`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To reverse a string, use the general purpose algorithm `std::reverse()`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To trim a string, at the beginning, end, or both, use `std::basic_string`''s
    methods `find_first_not_of()` and `find_last_not_of()`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To trim characters in a given set from a string, use overloads of `std::basic_string`''s
    methods `find_first_not_of()` and `find_last_not_of()`, that take a string parameter
    that defines the set of characters to look for:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To remove characters from a string, use `std::remove_if()` and `std::basic_string::erase()`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To split a string based on a specified delimiter, use `std::getline()` to read
    from an `std::basic_stringstream` initialized with the content of the string.
    The tokens extracted from the stream are pushed into a vector of strings:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For implementing the utility functions from the library, we have two options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Functions would modify a string passed by a reference.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions would not alter the original string but return a new string.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option has the advantage that it preserves the original string, which
    may be helpful in many cases. Otherwise, in those cases, you would first have
    to make a copy of the string and alter the copy. The implementation provided in
    this recipe takes the second approach.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The first functions we implemented in the *How to do it...* section were `to_upper()`
    and `to_lower()`. These functions change the content of a string either to uppercase
    or lowercase. The simplest way to implement this is using the `std::transform()`
    standard algorithm. This is a general purpose algorithm that applies a function
    to every element of a range (defined by a begin and end iterator) and stores the
    result in another range for which only the begin iterator needs to be specified.
    The output range can be the same as the input range, which is exactly what we
    did to transform the string. The applied function is `toupper()` or `tolower()`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The next function we considered was `reverse()`, that, as the name implies,
    reverses the content of a string. For this, we used the `std::reverse()` standard
    algorithm. This general purpose algorithm reverses the elements of a range defined
    by a begin and end iterator:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When it comes to trimming, a string can be trimmed at the beginning, end, or
    both sides. Because of that, we implemented three different functions: `trim()`
    for trimming at both ends, `trimleft()` for trimming at the beginning of a string,
    and `trimright()` for trimming at the end of a string. The first version of the
    functions trims only spaces. In order to find the right part to trim, we use the `find_first_not_of()`
    and `find_last_not_of()` methods of `std::basic_string`. These return the first
    and last characters in the string that are not the specified character. Subsequently,
    a call to the `substr()` method of `std::basic_string` returns a new string. The
    `substr()` method takes an index in the string and a number of elements to copy
    to the new string:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It could be sometimes useful to trim other characters and then spaces from
    a string. In order to do that, we provided overloads for the trimming functions
    that specify a set of characters to be removed. That set is also specified as
    a string. The implementation is very similar to the previous one because both
    `find_first_not_of()` and `find_last_not_of()` have overloads that take a string
    containing the characters to be excluded from the search:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If removing characters from any part of the string is necessary, the trimming
    methods are not helpful because they only treat a contiguous sequence of characters
    at the start and end of a string. For that, however, we implemented a simple `remove()`
    method. This uses the `std:remove_if()` standard algorithm. Both `std::remove()`
    and `std::remove_if()` work in a way that may not be very intuitive at first.
    They remove elements that satisfy the criteria from a range defined by a first
    and last iterator by rearranging the content of the range (using move assignment).
    The elements that need to be removed are placed at the end of the range, and the
    function returns an iterator to the first element in the range that represents
    the removed elements. This iterator basically defines the new end of the range
    that was modified. If no element was removed, the returned iterator is the end
    iterator of the original range. The value of this returned iterator is then used
    to call the `std::basic_string::erase()` method that actually erases the content
    of the string defined by two iterators. The two iterators in our case are the
    iterator returned by `std::remove_if()` and the end of the string:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The last method we implemented splits the content of a string based on a specified
    delimiter. There are various ways to implement this. In this implementation, we
    used `std::getline()`. This function reads characters from an input stream until
    a specified delimiter is found and places the characters in a string. Before starting
    to read from the input buffer, it calls `erase()` on the output string to clear
    its content. Calling this method in a loop produces tokens that are placed in
    a vector. In our implementation, empty tokens were skipped from the result set:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the format of a string using regular expressions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are a language intended for performing pattern matching
    and replacements in texts. C++11 provides support for regular expressions within
    the standard library through a set of classes, algorithms, and iterators available
    in the header `<regex>`. In this recipe, we will see how regular expressions can
    be used to verify that a string matches a pattern (examples can include verifying
    an e-mail or IP address formats).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this recipe, we will explain whenever necessary the details of the
    regular expressions that we use. However, you should have at least some basic
    knowledge of regular expressions in order to use the C++ standard library for
    regular expressions. A description of regular expressions syntax and standards
    is beyond the purpose of this book; if you are not familiar with regular expressions,
    it is recommended that you read more about them before continuing with the recipes
    that focus on regular expressions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to verify that a string matches a regular expression, perform the
    following steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Include headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user-defined literals for strings:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (that can occur frequently). The following regular expression validates
    most e-mails formats:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To ignore casing or specify other parsing options, use an overloaded constructor
    that has an extra parameter for regular expression flags:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Use `std::regex_match()` to match the regular expression to an entire string:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering the problem of verifying the format of e-mail addresses, even though
    this may look like a trivial problem, in practice it is hard to find a simple
    regular expression that covers all the possible cases for valid e-mail formats.
    In this recipe, we will not try to find that ultimate regular expression, but
    rather to apply a regular expression that is good enough for most cases. The regular
    expression we will use for this purpose is this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following table explains the structure of the regular expression:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of string |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z0-9._%+-]+` | At least one character in the range A-Z, 0-9, or one of
    -, %, + or - that represents the local part of the email address |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: '| `@` | Character @ |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z0-9.-]+` | At least one character in the range A-Z, 0-9, or one of -,
    %, + or - that represents the hostname of the domain part |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| `\.` | A dot that separates the domain hostname and label |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z]{2,}` | The DNS label of a domain that can have between 2 and 63 characters
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of the string |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: Bear in mind that in practice a domain name is composed of a hostname followed
    by a dot-separated list of DNS labels. Examples include `localhost`, `gmail.com`,
    or `yahoo.co.uk`. This regular expression we are using does not match domains
    without DNS labels, such as localhost (an e-mail, such as `root@localhost` is
    a valid e-mail). The domain name can also be an IP address specified in brackets,
    such as `[192.168.100.11]` (as in `john.doe@[192.168.100.11]`). E-mail addresses
    containing such domains will not match the regular expression defined above. Even
    though these rather rare formats will not be matched, the regular expression can
    cover most of the e-mail formats.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression in the example in this chapter is provided for didactical
    purposes only, and it is not intended for being used as it is in production code.
    As explained earlier, this sample does not cover all possible e-mail formats.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'We began by including the necessary headers, `<regex>` for regular expressions
    and `<string>` for strings. The `is_valid_email()` function shown in the following (that
    basically contains the samples from the *How to do it...* section) takes a string
    representing an e-mail address and returns a boolean indicating whether the e-mail
    has a valid format or not. We first construct an `std::regex` object to encapsulate
    the regular expression indicated with the raw string literal. Using raw string
    literals is helpful because it avoids escaping backslashes that are used for escape
    characters in regular expressions too. The function then calls `std::regex_match()`,
    passing the input text and the regular expression:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `std::regex_match()` method tries to match the regular expression against
    the entire string. If successful it returns `true`, otherwise `false`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this simple test, the only e-mails that do not match the regular expression
    are `ROOT@LOCALHOST` and `john.doe@domain.com`. The first contains a domain name
    without a dot-prefixed DNS label and that case is not covered in the regular expression.
    The second contains only lowercase letters, and in the regular expression, the
    valid set of characters for both the local part and the domain name was uppercase
    letters, A to Z.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of complicating the regular expression with additional valid characters
    (such as `[A-Za-z0-9._%+-]`), we can specify that the match can ignore the case.
    This can be done with an additional parameter to the constructor of the `std::basic_regex`
    class. The available constants for this purpose are defined in the `regex_constants`
    namespace. The following slight change to the `is_valid_email_format()` will make
    it ignore the case and allow e-mails with both lowercase and uppercase letters
    to correctly match the regular expression:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This `is_valid_email_format()` function is pretty simple, and if the regular
    expression was provided as a parameter along with the text to match, it could
    be used for matching anything. However, it would be nice to be able to handle
    with a single function not only multi-byte strings (`std::string`) but also wide
    strings (`std::wstring`). This can be achieved by creating a function template
    where the character type is provided as a template parameter:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We start by creating an alias template for `std::basic_string` in order to
    simplify its use. The new `is_valid_format()` function is a function template
    very similar to our implementation of `is_valid_email()`**.** However, we now
    use `std::basic_regex<CharT>` instead of the typedef `std::regex,` which is `std::basic_regex<char>,`
    and the pattern is provided as the first argument. We now implement a new function
    called `is_valid_email_format_w()` for wide strings that relies on this function
    template. The function template, however, can be reused for implementing other
    validations, such as if a license plate has a particular format:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Of all the examples shown above, the only one that does not match is `ROOT@LOCAHOST`,
    as already expected.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The `std::regex_match()` method has, in fact, several overloads, and some of
    them have a parameter that is a reference to an `std::match_results` object to
    store the result of the match. If there is no match, then `std::match_results`
    is empty and its size is 0\. Otherwise, if there is a match, the `std::match_results`
    object is not empty and its size is 1 plus the number of matched subexpressions.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'The following version of the function uses the mentioned overloads and returns
    the matched subexpressions in an `std::smatch` object. Note that the regular expression
    is changed, as three caption groups are defined-- one for the local part, one
    for the hostname part of the domain, and one for the DNS label. If the match is
    successful, then the `std::smatch` object will contain four submatch objects:
    the first to match the entire string, the second for the first capture group (the
    local part), the third for the second capture group (the hostname), and the fourth
    for the third and last capture group (the DNS label). The result is returned in
    a tuple, where the first item actually indicates success or failure:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Following the preceding code, we use C++17 structured bindings to unpack the
    content of the tuple into named variables:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output of the program will be as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There's more...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple versions of regular expressions, and the C++ standard library
    supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and
    egrep (grep with option `-E`). The default grammar used is ECMAScript, and in
    order to use another, you explicitly have to specify the grammar when defining
    the regular expression. In addition to specifying the grammar, you can also specify
    parsing options, such as matching by ignoring the case.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library provides more classes and algorithms than what we have
    seen so far. The main classes available in the library are the following (all
    of them are class templates and, for convenience, `typedef`s are provided for
    different character types):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The class template `std::basic_regex` defines the regular expression object:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The class template `std::sub_match` represents a sequence of characters that
    matches a capture group; this class is actually derived from `std::pair`, and
    its `first` and `second` members represent iterators to the first and the one-past-end
    characters in the match sequence; if there is no match sequence, the two iterators
    are equal:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The class template `std::match_results` is a collection of matches; the first
    element is always a full match in the target, and the other elements are matches
    of subexpressions:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The algorithms available in the regular expressions standard library are the
    following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`std::regex_match()`: This tries to match a regular expression (represented
    by a `std::basic_regex` instance) to an entire string.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_search()`: This tries to match a regular expression (represented
    by a `std::basic_regex` instance) to a part of a string (including the entire
    string).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_replace()`: This replaces matches from a regular expression according
    to a specified format.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The iterators available in the regular expressions standard library are the
    following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '`std::regex_interator`: A constant forward iterator used to iterate through
    the occurrences of a pattern in a string. It has a pointer to an `std::basic_regex`
    that must live until the iterator is destroyed. Upon creation and when incremented,
    the iterator calls `std::regex_search()` and stores a copy of the `std::match_results`
    object returned by the algorithm.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_token_iterator`: A constant forward iterator used to iterate through
    the submatches of every match of a regular expression in a string. Internally,
    it uses an `std::regex_iterator` to step through the submatches. Since it stores
    a pointer to an `std::basic_regex` instance, the regular expression object must
    live until the iterator is destroyed.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Parsing the content of a string using regular expressions*'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing the content of a string using regular expressions*'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using structured bindings to handle multi-return values* recipe of [Chapter
    8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning Modern Core Language
    Features*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the content of a string using regular expressions
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have looked at how to use `std::regex_match()` to
    verify that the content of a string matches a particular format. The library provides
    another algorithm called `std::regex_search()` that matches a regular expression
    against any part of a string, and not only the entire string as `regex_match()`
    does. This function, however, does not allow searching through all the occurrences
    of a regular expression in an input string. For this purpose, we need to use one
    of the iterator classes available in the library.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to parse the content of a string using regular
    expressions. For this purpose, we will consider the problem of parsing a text
    file containing name-value pairs. Each such pair is defined on a different line
    having the format `name = value`, but lines starting with a `#` represent comments
    and must be ignored. The following is an example:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Getting ready
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For general information about regular expressions support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe. Basic
    knowledge of regular expressions is required for proceeding with this recipe.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, `text` is a variable defined as shown here:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How to do it...
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to search for occurrences of a regular expression through a string
    you should perform the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Include headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user-defined literals for strings:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (that can occur frequently). The following regular expression validates
    the file format proposed earlier:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To search for the first occurrence of a regular expression in a given text,
    use the general purpose algorithm `std::regex_search()` (example 1):'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To find all the occurrences of a regular expression in a given text, use the
    iterator `std::regex_iterator` (example 2):'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To iterate through all the subexpressions of a match, use the iterator `std::regex_token_iterator`
    (example 3):'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How it works...
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple regular expression that can parse the input file shown earlier may
    look like this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This regular expression is supposed to ignore all lines that start with a `#`;
    for those that do not start with `#`, match a name followed by the equal sign
    and then a value that can be composed of alphanumeric characters and several other
    characters (underscore, dot, comma, and so on). The exact meaning of this regular
    expression is explained as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of line |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| `(?!#)` | A negative lookahead that makes sure that it is not possible to
    match the # character |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: '| `(\w)+` | A capturing group representing an identifier of at least a one
    word character |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
- en: '| `\s*` | Any white spaces |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| `=` | Equal sign |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: '| `\s*` | Any white spaces |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
- en: '| `([\w\d]+[\w\d._,\-:]*)` | A capturing group representing a value that starts
    with an alphanumeric character, but can also contain a dot, comma, backslash,
    hyphen, colon, or an underscore. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of line |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
- en: We can use `std::regex_search()` to search for a match anywhere in the input
    text. This algorithm has several overloads, but in general they work in the same
    way. You must specify the range of characters to work through, an output `std::match_results`
    object that will contain the result of the match, and a `std::basic_regex` object
    representing the regular expression and matching flags (that define the way the
    search is done). The function returns `true` if a match was found or `false` otherwise.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example from the previous section (see the 4th list item), `match`
    is an instance of `std::smatch` that is a `typedef` of `std::match_results` with
    `string::const_iterator` as the template type. If a match was found, this object
    will contain the matching information in a sequence of values for all matched
    subexpressions. The submatch at index 0 is always the entire match. The submatch
    at index 1 is the first subexpression that was matched, the submatch at index
    2 is the second subexpression that was matched, and so on. Since we have two capturing
    groups (that are subexpressions) in our regular expression, the `std::match_results`
    will have three submatches in case of success. The identifier representing the
    name is at index 1, and the value after the equal sign is at index 2\. Therefore,
    this code only prints the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `std::regex_search()` algorithm is not able to iterate through all the possible
    matches in a text. To do that, we need to use an iterator. `std::regex_iterator` is intended
    for this purpose. It allows not only iterating through all the matches, but also
    accessing all the submatches of a match. The iterator actually calls `std::regex_search()`
    upon construction and on each increment, and it remembers the result `std::match_results`
    from the call. The default constructor creates an iterator that represents the
    end of the sequence and can be used to test when the loop through the matches
    should stop.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example from the previous section (see the 5th list item), we
    first create an end of sequence iterator, and then we start iterating through
    all the possible matches. When constructed, it will call `std::regex_match()`,
    and if a match is found, we can access its results through the current iterator.
    This will continue until no match is found (end of the sequence). This code will
    print the following output:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'An alternative to `std::regex_iterator` is `std::regex_token_iterator`. This
    works similar to the way `std::regex_iterator` works and, in fact, it contains
    such an iterator internally, except that it enables us to access a particular
    subexpression from a match. This is shown in the third example in the *How to
    do it..*. section (the the 6th list item). We start by creating an end-of-sequence
    iterator and then loop through the matches until the end-of-sequence is reached.
    In the constructor we used, we did not specify the index of the subexpression
    to access through the iterator; therefore, the default value of 0 is used. That
    means this program will print the entire matches:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we wanted to access only the first subexpression (that means the names in
    our case), all we had to do was specify the index of the subexpression in the
    constructor of the token iterator. This time, the output that we get is only the
    names:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'An interesting thing about the token iterator is that it can return the unmatched
    parts of the string if the index of the subexpressions is `-1`, in which case
    it returns an `std::match_results` object that corresponds to the sequence of
    characters between the last match and the end of the sequence:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This program will output the following (note that the empty lines are actually
    part of the output):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: See also
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Verifying the format of a string using regular expressions*'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing the content of a string using regular expressions*'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the content of a string using regular expressions
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two recipes, we have looked at how to match a regular expression
    on a string or a part of a string and iterate through matches and submatches.
    The regular expression library also supports text replacement based on regular
    expressions. In this recipe, we will see how to use `std::regex_replace()` to
    perform such text transformations.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For general information about regular expressions support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to perform text transformations using regular expressions, you should
    perform the following:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user defined literals for strings:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Use the `std::regex_replace()` algorithm with a replacement string as the third argument.
    Consider this example: replace all words composed of exactly three characters
    that are either `a`, `b`, or `c` with three hyphens:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Use the `std::regex_replace()` algorithm with match identifiers prefixed with
    a `$` for the third argument. For example, replace names in the "lastname, firstname"
    with names in the format "firstname lastname", as follows:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works...
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::regex_replace()` algorithm has several overloads with different types
    of parameters, but the meaning of the parameters is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The input string on which the replacement is performed.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `std::basic_regex` object that encapsulates the regular expression used to
    identify the parts of the strings to be replaced.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string format used for replacement.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional matching flags.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return value is, depending on the overload used, either a string or a copy
    of the output iterator provided as an argument. The string format used for replacement
    can either be a simple string or a match identifier indicated with a `$` prefix:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '`$&` indicates the entire match.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1`, `$2`, `$3`, and so on, indicate the first, second, third submatch, and
    so on.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`` indicates the part of the string before the first match.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$''` indicates the part of the string after the last match.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first example shown in the *How to do it...* section, the initial text
    contains two words made of exactly three `a`, `b`, or `c` characters, `abc` and
    `bca`. The regular expression indicates an expression of exactly three characters
    between word boundaries. That means a subtext, such as `bbbb`, will not match
    the expression. The result of the replacement is that the string text will be
    `--- aa --- ca bbbb`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional flags for the match can be specified to the `std::regex_replace()`
    algorithm. By default, the matching flag is `std::regex_constants::match_default`
    that basically specifies ECMAScript as the grammar used for constructing the regular
    expression. If we want, for instance, to replace only the first occurrence, then
    we can specify `std::regex_constants::format_first_only`. In the next example,
    the result is `--- aa bca ca bbbb` as the replacement stops after the first match
    is found:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The replacement string, however, can contain special indicators for the whole
    match, a particular submatch, or the parts that were not matched, as explained
    earlier. In the second example shown in the *How to do it...* section, the regular
    expression identifies a word of at least one character, followed by a coma and
    possible white spaces and then another word of at least one character. The first
    word is supposed to be the last name and the second word is supposed to be the
    first name. The replacement string has the `$2 $1` format. This is an instruction
    to replace the matched expression (in this example, the entire original string)
    with another string formed of the second submatch followed by space and then the
    first submatch.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the entire string was a match. In the next example, there will
    be multiple matches inside the string, and they will all be replaced with the
    indicated string. In this example, we are replacing the indefinite article *a*
    when preceding a word that starts with a vowel (this, of course, does not cover
    words that start with a vowel sound) with the indefinite article *an*:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The regular expression identifies the letter *a* as a single word (`\b` indicates
    a word boundary, so `\ba` means a word with a single letter *a*) followed by a
    space and a word of at least two characters starting with a vowel. When such a
    match is identified, it is replaced with a string formed of the fixed string *an*
    followed by a space and the first subexpression of the match, which is the word
    itself. In this example, the `newtext` string will be *this is an example with
    an error*.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the identifiers of the subexpressions (`$1`, `$2`, and so on), there
    are other identifiers for the entire match (`$&`), the part of the string before
    the first match (`$``) and the part of the string after the last match (`$''`).
    In the last example, we change the format of a date from `dd.mm.yyyy` to `yyyy.mm.dd`,
    but also show the matched parts:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The regular expression matches a one- or two-digit number followed by a dot,
    hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen,
    or slash; and last a four-digit number.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: For `newtext1`, the replacement string is `$5$4$3$2$1`; that means year, followed
    by the second separator, then month, the first separator, and finally day. Therefore,
    for the input string *"today is 1.06.2016!"*, the result is *"today is 2016.06.1!!"*.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: For `newtext2`, the replacement string is `[$`][$&][$']`; that means the part
    before the first match, followed by the entire match, and finally the part after
    the last match are in square brackets. However, the result is not *"[!!][1.06.2016][today
    is ]"* as you perhaps might expect at a first glance, but *"today is [today is
    ][1.06.2016][!!]!!"*. The reason is that what is replaced is the matched expression,
    and, in this case, that is only the date (*"1.06.2016"*). This substring is replaced
    with another string formed of the all parts of the initial string.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Verifying the format of a string using regular expressions*'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parsing the content of a string using regular expressions*'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using string_view instead of constant string references
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with strings, temporary objects are created all the time, even
    if you might not be really aware of it. Many times the temporary objects are irrelevant
    and only serve the purpose of copying data from one place to another (for example,
    from a function to its caller). This represents a performance issue because they
    require memory allocation and data copying, which is desirable to be avoided.
    For this purpose, the C++17 standard provides a new string class template called
    `std::basic_string_view` that represents a non-owning constant reference to a
    string (that is, a sequence of characters). In this recipe, you will learn when
    and how you should use this class.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `string_view` class is available in the namespace `std` in the `string_view` header.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should use `std::string_view` to pass a parameter to a function (or return
    a value from a function), instead of `std::string const &` unless your code needs
    to call other functions that take `std::string` parameters (in which case, conversions
    would be necessary):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works...
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at how the new string type works, let's consider the following
    example of a function that is supposed to extract the name of a file without its
    extension. This is basically how you would write the function from the previous
    section before C++17.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this example the file separator is `\` (backslash) as in Windows.
    For Linux-based systems, it has to be changed to `/` (slash).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is a relatively simple function. It takes a constant reference to an `std::string`
    and identifies a substring bounded by the last file separator and the last dot
    that basically represents a filename without an extension (and without folder
    names).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this code, however, is that it creates one, two, or, possibly,
    even more temporaries, depending on the compiler optimizations. The function parameter
    is a constant `std::string` reference, but the function is called with a string
    literal, which means `std::string` needs to be constructed from the literal. These
    temporaries need to allocate and copy data, which is both time- and resource-consuming.
    In the last example, all we want to do is check whether the first character of
    the filename is an underscore, but we create at least two temporary string objects
    for that purpose.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: The `std::basic_string_view` class template is intended to solve this problem.
    This class template is very similar to `std::basic_string`, the two having almost
    the same interface. The reasons for this is that the `std::basic_string_view`
    is intended to be used instead of a constant reference to an `std::basic_string`
    without further code changes.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with `std::basic_string`, there are specializations for all types
    of standard characters:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `std::basic_string_view` class template defines a reference to a constant
    contiguous sequence of characters. As the name implies, it represents a view and
    cannot be used to modify the reference sequence of characters. An `std::basic_string_view`
    object has a relatively small size because all that it needs is a pointer to the
    first character in the sequence and the length. It can be constructed not only
    from an `std::basic_string` object but also from a pointer and a length or from
    a null-terminated sequence of characters (in which case, it will require an initial
    traversing of the string in order to find the length). Therefore, the `std::basic_string_view`
    class template can also be used as a common interface for multiple types of strings
    (as long as data only needs to be read). On the other hand, converting from an `std::basic_string_view`
    to an `std::basic_string` is easy because the former has both a `to_string()`
    and a converting `operator std::basic_string` to create a new `std::basic_string`
    object.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Passing `std::basic_string_view` to functions and returning `std::basic_string_view`
    still creates temporaries of this type, but these are small size objects on the
    stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore,
    they should incur fewer performance costs than allocating heap space and copying
    data.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all major compilers provide an implementation of std::basic_string
    that includes a small string optimization. Although the implementation details
    are different, they typically rely on having a statically allocated buffer of
    a number of characters (16 for VC++ and gcc 5 or newer) that does not involve
    heap operations, which are only required when the size of the string exceeds that
    number of characters.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the methods that are identical to those available in `std::basic_string`,
    the `std::basic_string_view` has two more:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '`remove_prefix()`: Shrinks the view by incrementing the start with *N* characters
    and decrementing the length with *N* characters.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_suffix()`: Shrinks the view by decrementing the length with *N* characters.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two member functions are used in the following example to trim an `std::string_view`
    from spaces, both at the beginning and the end. The implementation of the function
    first looks for the first element that is not a space and then for the last element
    that is not a space. Then, it removes from the end everything after the last non-space
    character, and from the beginning everything until the first non-space character.
    The function returns the new view trimmed at both ends:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When using an `std::basic_string_view`, you must be aware of two things: you
    cannot change the underlying data referred by a view and you must manage the lifetime
    of the data, as the view is a non-owning reference.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating a library of string helpers*'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
