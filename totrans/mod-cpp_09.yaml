- en: Working with Numbers and Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting between numeric and string types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and other properties of numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pseudo-random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing all bits of internal state of a pseudo-random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw string literals to avoid escaping characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cooked user-defined literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raw user-defined literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library of string helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the format of a string using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the content of a string using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the content of a string using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using string_view instead of constant string references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between numeric and string types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting between number and string types is a ubiquitous operation. Prior
    to C++11, there was little support for converting numbers to strings and back,
    and developers had to resort mostly to type-unsafe functions and usually wrote
    their own utility functions in order to avoid writing the same code over and over
    again. With C++11, the standard library provides utility functions for converting
    between numbers and strings. In this recipe, you will learn how to convert between
    numbers and strings and the other way around using modern C++ standard functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the utility functions mentioned in this recipe are available in the `<string>`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following standard conversion functions when you need to convert between
    numbers and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert from an integer or floating point type to a string type, use `std::to_string()`
    or `std::to_wstring()` as shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert from a string type to an integer type, use `std::stoi()`, `std::stol()`,
    `std::stoll()`, `std::stoul()`, or `std::stoull()`; refer to the following code
    snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert from a string type to a floating point type, use `std::stof()`,
    `std::stod()`, or `std::stold()`, as shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert between an integral or floating point type to a string type, you
    can use either the `std::to_string()` or `std::to_wstring()` function. These functions
    are available in the `<string>` header and have overloads for signed and unsigned
    integer and real types. They produce the same result as `std::sprintf()` and `std::swprintf()`
    would produce when called with the appropriate format specifier for each type.
    The following code snippet list all the overloads of these two functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to the opposite conversion, there is an entire set of functions
    that have the name with the format **ston** (**string to number**), where **n**
    stands for **i** (`integer`), **l** (`long`), **ll** (`long long`), **ul** (`unsigned
    long`), or **ull** (`unsigned long long`). The following listing shows all these
    functions, each of them with two overloads, one that takes an `std::string` and
    one that takes an `std::wstring` as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The way the string to integral type functions work is by discarding all white
    spaces before a non-whitespace character, then taking as many characters as possible
    to form a signed or unsigned number (depending on the case), and then converting
    that to the requested integral type (`stoi()` will return an `integer`, `stoul()`
    will return an `unsigned long`, and so on). In all the following examples, the
    result is integer `42`, except for the last example where the result is `-42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A valid integral number may consist of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A sign, plus (`+`) or minus (`-`) (optional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix `0` to indicate an octal base (optional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix `0x` or `0X` to indicate a hexadecimal base (optional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence of digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional prefix `0` (for octal) is applied only when the specified base
    is `8` or `0`. Similarly, the optional prefix `0x` or `0X` (for hexadecimal) is
    applied only when the specified base is `16` or `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions that convert a string to an integer have three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The input string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer that when not null will receive the number of characters that were
    processed and that can include any leading white spaces that were discarded, the
    sign, and the base prefix, so it should not be confused with the number of digits
    the integral value has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number indicating the base; by default, this is `10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The valid digits in the input string depend on the base. For base `2`, the only
    valid digits are `0` and `1`; for base `5`, they are `01234`. For base `11`, the
    valid digits are `0-9` and characters `A` and `a`. This continues until we reach
    base `36` that has valid characters `0-9`, `A-Z`, and `a-z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are more examples of strings with numbers in various bases converted
    to decimal integers. Again, in all cases, the result is either `42` or `-42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An important thing to note is that these conversion functions throw if the
    conversion fails. There are two exceptions that can be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::invalid_argument`: If the conversion cannot be performed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`std::out_of_range`: If the converted value is outside the range of the result
    type (or if the underlying function sets `errno` to `ERANGE`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The other set of functions that convert a string to a floating point type is
    very similar, except that they don''t have a parameter for the numeric base. A
    valid floating point value can have different representations in the input string:'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal floating point expression (optional sign, sequence of decimal digits
    with optional point, optional `e` or `E` followed by exponent with optional sign).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary floating point expression (optional sign, `0x` or `0X` prefix, sequence
    of hexadecimal digits with optional point, optional `p` or `P` followed by exponent
    with optional sign).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinity expression (optional sign followed by case insensitive `INF` or `INFINITY`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-number expression (optional sign followed by case insensitive `NAN` and
    possibly other alphanumeric characters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are various examples of converting strings to doubles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The floating-point base 2 scientific notation, seen earlier in the form `0xF.6E6666p3`,
    is not the topic of this recipe. However, for a clear understanding, a short description
    is provided; although, it is recommended that you see additional references for
    details. A floating-point constant in the base 2 scientific notation is composed
    of several parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal prefix `0x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer part, in this example was `F`, which in decimal is 15.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A fractional part, which in this example was `6E6666`, or `011011100110011001100110`
    in binary. To convert that to decimal, we need to add inverse powers of two: `1/4
    + 1/8 + 1/32 + 1/64 + 1/128 + ...`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A suffix, representing a power of 2; in this example, `p3` means 2 at the power
    of 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the decimal equivalent is determined by multiplying the significant
    (composed of the integer and fractional parts) and the base at the power of exponent.
    For the given hexadecimal base 2 floating point literal, the significant is `15.4312499...`
    (note that digits after the seventh one are not shown), the base is 2, and the
    exponent is 3\. Therefore, the result is `15.4212499... * 8`, which is `123.44999980926514`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Limits and other properties of numeric types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and other properties of numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to know and use the minimum and maximum values representable
    with a numeric type, such as `char`, `int`, or `double`. Many developers are using
    standard C macros for this, such as `CHAR_MIN`/`CHAR_MAX`, `INT_MIN`/`INT_MAX`,
    or `DBL_MIN`/`DBL_MAX`. C++ provides a class template called `numeric_limits`
    with specializations for every numeric type that enables you to query the minimum
    and maximum value of a type, but is not limited to that and offers additional
    constants for type properties querying, such as whether a type is signed or not,
    how many bits it needs for representing its values, for floating point types whether
    it can represent infinity, and many others. Prior to C++11, the use of `numeric_limits<T>`
    was limited because it could not be used in places where constants were needed
    (examples can include the size of arrays and switch cases). Due to that, developers
    preferred to use the C macros throughout their code. In C++11, that is no longer
    the case, as all the static members of `numeric_limits<T>` are now `constexpr`,
    which means they can be used everywhere a constant expression is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `numeric_limits<T>` class template is available in the namespace `std` in
    the `<limits>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use `std::numeric_limits<T>` to query various properties of a numeric type
    `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `min()` and `max()` static methods to get the smallest and largest finite
    numbers of a type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use other static methods and static constants to retrieve other properties
    of a numeric type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In C++11, there is no limitation to where `std::numeric_limits<T>` can be used;
    therefore, preferably use it over C macros in your modern C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::numeric_limits<T>` is a class template that enables developers to
    query property of numeric types. Actual values are available through specializations,
    and the standard library provides specializations for all the built-in numeric
    types (`char`, `short`, `int`, `long`, `float`, `double`, and so on). In addition,
    third parties may provide additional implementation for other types. An example
    could be a numeric library that implements a `bigint` integer type and a `decimal`
    type and provides specializations of `numeric_limits` for these types (such as
    `numeric_limits<bigint>` and `numeric_limits<decimal>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following specializations of numeric types are available in the `<limits>` header.
    Note that specializations for `char16_t` and `char32_t` are new in C++11; the
    others were available previously. Apart from the specializations listed ahead,
    the library also includes specializations for every `cv-qualified` version of
    these numeric types, and they are identical to the unqualified specialization.
    For example, consider type `int`; there are four actual specializations (and they
    are identical): `numeric_limits<int>`, `numeric_limits<const int>`, `numeric_limits<volatile
    int>`, and `numeric_limits<const volatile int>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, in C++11, all static members of `numeric_limits` are
    `constexpr`, which means they can be used in all places where constant expressions
    are needed. These have several major advantages over C++ macros:'
  prefs: []
  type: TYPE_NORMAL
- en: They are easier to remember, as the only thing you need to know is the name
    of the type that you should know anyway, and not countless names of macros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support types that are not available in C, such as `char16_t` and `char32_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the only possible solution for templates where you don't know the type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum and maximum are only two of the various properties of types it provides;
    therefore, its actual use is beyond the numeric limits. As a side note, for this
    reason, the class should have been perhaps called `numeric_properties`, instead
    of `numeric_limits`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following function template `print_type_properties()` prints the minimum
    and maximum finite values of the type as well as other information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `print_type_properties()` function for unsigned `short`, `int`,
    and `double`, it will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `unsigned short` | `int` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| min=0max=65535bits=16decdigits=4integral=1signed=0exact=1infinity=0 | min=-2147483648max=2147483647bits=31decdigits=9integral=1signed=1exact=1infinity=0
    | min=2.22507e-308max=1.79769e+308bits=53decdigits=15integral=0signed=1exact=0infinity=1
    |'
  prefs: []
  type: TYPE_TB
- en: 'The one thing to take note of is the difference between the `digits` and `digits10`
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`digits` represent the number of bits (excluding the sign bit if present) and
    padding bits (if any) for integral types and the number of bits of the mantissa
    for floating point types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digits10` is the number of decimal digits that can be represented by a type
    without a change. To understand this better, let''s consider the case of `unsigned
    short`. This is a 16-bit integral type. It can represent numbers between 0 and
    65536\. It can represent numbers up to five decimal digits, 10,000 to 65,536,
    but it cannot represent all five decimal digit numbers, as numbers from 65,537
    to 99,999 require more bits. Therefore, the largest numbers that it can represent
    without requiring more bits have four decimal digits (numbers from 1,000 to 9,999).
    This is the value indicated by `digits10`. For integral types, it has a direct
    relationship to constant `digits`; for an integral type `T`, the value of `digits10`
    is `std::numeric_limits<T>::digits * std::log10(2)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pseudo-random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating random numbers is necessary for a large variety of applications,
    from games to cryptography, from sampling to forecasting. However, the term *random
    numbers* is not actually correct, as the generation of numbers through mathematical
    formulas is deterministic and does not produce true random numbers, but numbers
    that look random and are called *pseudo-random*. True randomness can only be achieved
    through hardware devices, based on physical processes, and even that can be challenged,
    as one may consider even the universe to be actually deterministic. Modern C++
    provides support for generating pseudo-random numbers through a pseudo-random
    number library containing number generators and distributions. Theoretically,
    it can also produce true random numbers, but in practice, those could actually
    be only pseudo-random.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we discuss the standard support for generating pseudo-random
    numbers. Understanding the difference between random and pseudo-random numbers
    is the key. On the other hand, being familiar with various statistical distributions
    is a plus. It is mandatory, though, that you know what a uniform distribution
    is because all engines in the library produce numbers that are uniformly distributed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate pseudo-random numbers in your application, you should perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the header `<random>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use an `std::random_device` generator for seeding a pseudo-random engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use one of the available engines for generating numbers and initialize it with
    a random seed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use one of the available distributions for converting the output of the engine
    to one of the desired statistical distributions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the pseudo-random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pseudo-random number library contains two types of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Engines*, which are generators of random numbers; these could produce either
    pseudo-random numbers with a uniform distribution or, if available, actual random
    numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Distributions* that convert the output of an engine into a statistical distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All engines (except for `random_device`) produce integer numbers in a uniform
    distribution, and all engines implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min()`: This is a static method that returns the minimum value that can be
    produced by the generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max()`: This is a static method that returns the maximum value that can be
    produced by the generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seed()`: This initializes the algorithm with a start value (except for `random_device`,
    which cannot be seeded).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator()`: This generates a new number uniformly distributed between `min()`
    and `max()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discard()`: This generates and discards a given number of pseudo-random numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following engines are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`linear_congruential_engine`: This is a linear congruential generator that
    produces numbers using the following formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x(i) = (A * x(i-1) + C) mod M*'
  prefs: []
  type: TYPE_NORMAL
- en: '`mersenne_twister_engine`: This is a Mersenne twister generator that keeps
    a value on *W * (N-1) * R* bits; each time a number needs to be generated, it
    extracts *W* bits. When all bits have been used, it twists the large value by
    shifting and mixing the bits so that it has a new set of bits to extract from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract_with_carry_engine`: This is a generator that implements a *subtract
    with carry* algorithm based on the following formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding formula, *cy* is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cy(i) = x(i - S) - x(i - R) - cy(i - 1) < 0 ? 1 : 0*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the library provides engine adapters that are also engines wrapping
    another engine and producing numbers based on the output of the base engine. Engine
    adapters implement the same methods mentioned earlier for the base engines. The
    following engine adapters are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`discard_block_engine`: A generator that from every block of P numbers generated
    by the base engine keeps only R numbers, discarding the rest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`independent_bits_engine`: A generator that produces numbers with a different
    number of bits than the base engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shuffle_order_engine`: A generator that keeps a shuffled table of K numbers
    produced by the base engine and returns numbers from this table, replacing them
    with numbers generated by the base engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these engines and engine adaptors are producing pseudo-random numbers. The
    library, however, provides another engine called `random_device` that is supposed
    to produce non-deterministic numbers, but this is not an actual constraint as
    physical sources of random entropy might not be available. Therefore, implementations
    of `random_device` could actually be based on a pseudo-random engine. The `random_device` class
    cannot be seeded like the other engines and has an additional method called `entropy()` that
    returns the random device entropy, which is 0 for a deterministic generator and
    nonzero for a non-deterministic generator. However, this is not a reliable method
    for determining whether the device is actually deterministic or non-deterministic.
    For instance, both GNU `libstdc++` and LLVM `libc++` implement a non-deterministic
    device, but return `0` for entropy. On the other hand, `VC++` and `boost.random`
    return `32` and `10`, respectively, for entropy.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these generators produce integers in a uniform distribution. This is, however,
    only one of the many possible statistical distributions that random numbers are
    needed in most applications. To be able to produce numbers (either integer or
    real) in other distributions, the library provides several classes that are called
    *distributions* and are converting the output of an engine according to the statistical
    distribution it implements. The following distributions are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Class name** | **Numbers** | **Statistical distribution** |'
  prefs: []
  type: TYPE_TB
- en: '| Uniform | `uniform_int_distribution` | integer | Uniform |'
  prefs: []
  type: TYPE_TB
- en: '|  | `uniform_real_distribution` | real | Uniform |'
  prefs: []
  type: TYPE_TB
- en: '| Bernoulli | `bernoulli_distribution` | boolean | Bernoulli |'
  prefs: []
  type: TYPE_TB
- en: '|  | `binomial_distribution` | integer | binomial |'
  prefs: []
  type: TYPE_TB
- en: '|  | `negative_binomial_distribution` | integer | negative binomial |'
  prefs: []
  type: TYPE_TB
- en: '|  | `geometric_distribution` | integer | geometric |'
  prefs: []
  type: TYPE_TB
- en: '| Poisson | `poisson_distribution` | integer | poisson |'
  prefs: []
  type: TYPE_TB
- en: '|  | `exponential_distribution` | real | exponential |'
  prefs: []
  type: TYPE_TB
- en: '|  | `gamma_distribution` | real | gamma |'
  prefs: []
  type: TYPE_TB
- en: '|  | `weibull_distribution` | real | Weibull |'
  prefs: []
  type: TYPE_TB
- en: '|  | `extreme_value_distribution` | real | extreme value |'
  prefs: []
  type: TYPE_TB
- en: '| Normal | `normal_distribution` | real | standard normal (Gaussian) |'
  prefs: []
  type: TYPE_TB
- en: '|  | `lognormal_distribution` | real | lognormal |'
  prefs: []
  type: TYPE_TB
- en: '|  | `chi_squared_distribution` | real | chi-squared |'
  prefs: []
  type: TYPE_TB
- en: '|  | `cauchy_distribution` | real | Cauchy |'
  prefs: []
  type: TYPE_TB
- en: '|  | `fisher_f_distribution` | real | Fisher''s F-distribution |'
  prefs: []
  type: TYPE_TB
- en: '|  | `student_t_distribution` | real | Student''s t-distribution |'
  prefs: []
  type: TYPE_TB
- en: '| Sampling | `discrete_distribution` | integer | discrete |'
  prefs: []
  type: TYPE_TB
- en: '|  | `piecewise_constant_distribution` | real | values distributed on constant
    subintervals |'
  prefs: []
  type: TYPE_TB
- en: '|  | `piecewise_linear_distribution` | real | values distributed on defined
    subintervals |'
  prefs: []
  type: TYPE_TB
- en: Each of the engines provided by the library has advantages and disadvantages.
    The linear congruential engine has a small internal state, but it is not very
    fast. On the other hand, the subtract with carry engine is very fast, but requires
    more memory for its internal state. The Mersenne twister is the slowest of them
    and the one that has the largest internal state, but when initialized appropriately
    can produce the longest non-repeating sequence of numbers. In the following examples,
    we will use `std::mt19937`, a 32-bit Mersenne twister with 19,937 bits of internal
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to generate random numbers looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `mtgen` is an `std::mt19937` Mersenne twister. To generate
    numbers, you only need to use the call operator that advances the internal state
    and returns the next pseudo-random number. However, this code is flawed, as the
    engine is not seeded. As a result, it always produces the same sequence of numbers,
    which is probably not what you want in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different approaches for initializing the engine. One approach, common
    with the C rand library, is to use the current time. In modern C++, it should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `seed` is a number representing the number of ticks since
    the clock''s epoch until the present moment. This number is then used to seed
    the engine. The problem with this approach is that the value of that `seed` is
    actually deterministic, and in some classes of applications it could be prone
    to attacks. A more reliable approach is to seed the generator with actual random
    numbers. The `std::random_device` class is an engine that is supposed to return
    true random numbers, though implementations could actually be based on a pseudo-random
    generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers produced by all engines follow a uniform distribution. To convert the
    result to another statistical distribution, we have to use a distribution class.
    To show how generated numbers are distributed according to the selected distribution,
    we will use the following function. This function generates a specified number
    of pseudo-random numbers and counts their repetition in a map. The values from
    the map are then used to produce a bar-like diagram showing how often each number
    occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code generates random numbers using the `std::mt19937` engine
    with a uniform distribution in the range `[1, 6]`; that is basically what you
    get when you throw a dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0aa92f90-d587-4c3d-880b-bd0a859d81b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next and final example, we change the distribution to a normal distribution
    with the mean `5` and the standard deviation `2`. This distribution produces real
    numbers; therefore, in order to use the previous `generate_and_print()` function,
    the numbers must be rounded to integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output of the earlier code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f94f238-cc47-44ce-a685-b2e9e437441e.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Initializing all bits of internal state of a pseudo-random number generator*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing all bits of internal state of a pseudo-random number generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have looked at the pseudo-random number library with
    its components and how it can be used to produce numbers in different statistical
    distributions. One important factor that was overlooked in that recipe is the proper
    initialization of the pseudo-random number generators. In this recipe, you will
    learn how to initialize a generator in order to produce the best sequence of pseudo-random
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should read the previous recipe, *Generating pseudo-random numbers*, to
    get an overview of what the pseudo-random number library offers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To properly initialize a pseudo-random number generator to produce the best
    sequence of pseudo-random numbers, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use an `std::random_device` to produce random numbers to be used as seeding
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate random data for all internal bits of the engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `std::seed_seq` object from the previously generated pseudo-random
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an engine object and initialize all the bits representing the internal
    state of the engine; for example, a `mt19937` has 19,937 bits of internal states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the appropriate distribution based on the requirements of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all examples shown in the previous recipe, we used an `std::mt19937` engine
    to produce pseudo-random numbers. Though the Mersenne twister is slower than the
    other engines, it can produce the longest sequences of non-repeating numbers and
    with the best spectral characteristics. However, initializing the engine in the
    manner shown in the previous recipe will not have this effect. With a careful
    analysis (that is beyond the purpose of this recipe or this book), it can be shown
    that the engine has a bias toward producing some values repeatedly and omitting
    others, thus generating numbers not in a uniform distribution, but rather in a
    binomial or Poisson distribution. The problem is that the internal state of `mt19937`
    has 624 32-bit integers, and in the examples from the previous recipe we have
    only initialized one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the pseudo-random number library, remember the following
    rule of thumb (shown in the information box):'
  prefs: []
  type: TYPE_NORMAL
- en: In order to produce the best results, engines must have all their internal state
    properly initialized before generating numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudo-random number library provides a class for this particular purpose,
    called `std::seed_seq`. This is a generator that can be seeded with any number
    of 32-bit integers and produces a requested number of integers evenly distributed
    in the 32-bit space.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code from the *How to do it...* section, we defined an array
    called `seed_data` with a number of 32-bit integers equal to the internal state
    of the `mt19937` generator; that is 624 integers. Then, we initialized the array
    with random numbers produced by an `std::random_device`. The array was later used
    to seed an `std::seed_seq`, which in turn was used to seed the `mt19937` generator.
  prefs: []
  type: TYPE_NORMAL
- en: Creating cooked user-defined literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Literals are constants of built-in types (numerical, boolean, character, character
    string, and pointer) that cannot be altered in a program. The language defines
    a series of prefixes and suffixes to specify literals (and the prefix/suffix is
    actually part of the literal). C++11 allows creating user-defined literals by
    defining functions called *literal operators* that introduce suffixes for specifying
    literals. These work only with numerical character and character string types.
    This opens the possibility of defining both standard literals in future versions
    and allows developers to create their own literals. In this recipe, we will see
    how we can create our own cooked literals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'User-defined literals can have two forms: *raw* and *cooked*. Raw literals
    are not processed by the compiler, whereas cooked literals are values processed
    by the compiler (examples can include handling escape sequences in a character
    string or identifying numerical values such as integer 2898 from literal 0xBAD).
    Raw literals are only available for integral and floating-point types, whereas
    cooked literals are also available for character and character string literals.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create cooked user-defined literals, you should follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your literals in a separate namespace to avoid name clashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always prefix the user-defined suffix with an underscore (`_`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a literal operator of the following form for cooked literals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example creates a user-defined literal for specifying kilobytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the compiler encounters a user-defined literal with a user-defined suffix
    `S` (it always has a leading underscore for third-party suffixes, as the suffixes
    without a leading underscore are reserved for the standard library) it does an
    unqualified name lookup in order to identify a function with the name operator
    `"operator "" S`. If it finds one, then it calls it according to the type of the
    literal and the type of the literal operator. Otherwise, the compiler will yield
    and error.
  prefs: []
  type: TYPE_NORMAL
- en: In the example from the *How to do it...* section, the literal operator is called
    `operator "" _KB` and has an argument of type `unsigned long long int`. This is
    the only integral type possible for literal operators for handling integral types.
    Similarly, for floating-point user-defined literals, the parameter type must be
    `long double` since for numeric types the literal operators must be able to handle
    the largest possible values. This literal operator returns a `constexpr` value
    so that it can be used where compile time values are expected, such as specifying
    the size of an array as shown in the above example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler identifies a user-defined literal and has to call the appropriate
    user-defined literal operator, it will pick the overload from the overload set
    according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For integral literals**: It calls in the following order: the operator that
    takes an `unsigned long long`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For floating-point literals**: It calls in the following order: the operator
    that takes a `long double`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For character literals**: It calls the appropriate operator depending on
    the character type (`char`, `wchar_t`, `char16_t`, and `char32_t`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For string literals**: It calls the appropriate operator, depending on the
    string type that takes a pointer to the string of characters and the size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we define a system of units and quantities. We want
    to operate with kilograms, pieces, liters, and other types of units. This could
    be useful in a system that can process orders and you need to specify the amount
    and unit for each article. The following are defined in the namespace `units`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A scoped enumeration for the possible types of units (kilogram, meter, liter,
    and pieces):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A class template to specify quantities of a particular unit (such as 3.5 kilograms
    or 42 pieces):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `operator+` and `operator-` functions for the `quantity` class template
    in order to be able to add and subtract quantities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Literal operators to create `quantity` literals, defined in an inner namespace
    called `unit_literals`. The purpose of this is to avoid possible name clashes
    with literals from other namespaces. If such collisions do happen, developers
    could select the ones that they should use using the appropriate namespace in
    the scope where the literals need to be defined:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By looking carefully, you can note that the literal operators defined earlier
    are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_kg` is defined for both integral and floating point literals; that enables
    us to create both integral and floating point values such as `1_kg` and `1.0_kg`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_l` and `_m` are defined only for floating point literals; that means we can
    only define quantity literals for these units with floating points, such as `4.5_l`
    and `10.0_m`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_pcs` is only defined for integral literals; that means we can only define
    quantities of an integer number of pieces, such as `42_pcs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having these literal operators available, we can operate with various quantities.
    The following examples show both valid and invalid operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`q1` is a quantity of 1 kg; that is an integer value. Since an overloaded `operator
    "" _kg(unsigned long long const)` exists, the literal can be correctly created
    from the integer 1\. Similarly, `q2` is a quantity of 4.5 kilograms; that is a
    real value. Since an `overload operator "" _kg(long double)` exists, the literal
    can be created from the double floating point value 4.5.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `q6` is a quantity of 1 liter. Since there is no overloaded `operator
    "" _l(unsigned long long)`, the literal cannot be created. It would require an
    overload that takes a `unsigned long long`, but such an overload does not exist.
    Similarly, `q7` is a quantity of 2.0 pieces, but piece literals can only be created
    from integer values and, therefore, this generates another compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though user-defined literals are available from C++11, standard literal operators
    have been available only from C++14\. The following is a list of these standard
    literal operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator""s` for defining `std::basic_string` literals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`operator""h`, `operator""min`, `operator""s`, `operator""ms`, `operator""us`,
    and `operator""ns` for creating a `std::chrono::duration` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`operator""if`, `operator""i`, and `operator""il` for creating a `std::complex`
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using raw string literals to avoid escaping characters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating raw user-defined literals*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raw user-defined literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have looked at the way C++11 allows library implementers
    and developers to create user-defined literals and the user-defined literals available
    in the C++14 standard. However, user-defined literals have two forms, a cooked
    form, where the literal value is processed by the compiler before being supplied
    to the literal operator, and a raw form, in which the literal is not parsed by
    the compiler. The latter is only available for integral and floating-point types.
    In this recipe, we will look at creating raw user-defined literals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before continuing with this recipe, it is strongly recommended that you go through
    the previous one, *Creating cooked user-defined literals*, as general details
    about user-defined literals will not be reiterated here.
  prefs: []
  type: TYPE_NORMAL
- en: To exemplify the way raw user-defined literals can be created, we will define
    binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned)
    types. These types will be called `byte8`, `byte16`, and `byte32`, and the literals
    we create will be called `_b8`, `_b16`, and `_b32`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create raw user-defined literals, you should follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your literals in a separate namespace to avoid name clashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always prefix the used-defined suffix with an underscore (`_`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a literal operator or literal operator template of the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sample shows a possible implementation of 8-bit, 16-bit, and
    32-bit binary literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation in the previous section enables us to define binary literals
    of the form 1010_b8 (a `byte8` value of decimal 10) or 000010101100_b16 (a `byte16`
    value of decimal 2130496). However, we want to make sure that we do not exceed
    the number of digits for each type. In other words, values such as 111100001_b8
    should be illegal and the compiler should yield an error.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we define everything inside a namespace called `binary` and start
    with introducing several type aliases (`byte8`, `byte16`, and `byte32`).
  prefs: []
  type: TYPE_NORMAL
- en: The literal operator templates are defined in a nested namespace called `binary_literal_internals`.
    This is a good practice in order to avoid name collision with other literal operators
    from other namespaces. Should something like that happen, you can choose to use
    the appropriate namespace in the right scope (such as one namespace in a function
    or block and another namespace in another function or block).
  prefs: []
  type: TYPE_NORMAL
- en: The three literal operator templates are very similar. The only things that
    are different are their names (`_b8`, `_16`, and `_b32`), return type (`byte8`,
    `byte16`, and `byte32`), and the condition in the static assert that checks the
    number of digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the details of variadic template and template recursion in
    a later recipe; however, for a better understanding, this is how this particular
    implementation works: `bits` is a template parameter pack, that is not a single
    value, but all the values the template could be instantiated with. For example,
    if we consider the literal `1010_b8`, then the literal operator template would
    be instantiated as `operator"" _b8<''1'', ''0'', ''1'', ''0''>()`. Before proceeding
    with computing the binary value, we check the number of digits in the literal.
    For `_b8`, this must not exceed eight (including any trailing zeros). Similarly,
    it should be up to 16 digits for `_b16` and 32 for `_b32`. For this, we use the
    `sizeof...` operator that returns the number of elements in a parameter pack (in
    this case, `bits`).'
  prefs: []
  type: TYPE_NORMAL
- en: If the number of digits is correct, we can proceed to expand the parameter pack
    and recursively compute the decimal value represented by the binary literal. This
    is done with the help of an additional class template and its specializations.
    These templates are defined in yet another nested namespace, called `binary_literals_internals`.
    This is also a good practice because it hides (without proper qualification) the
    implementation details from the client (unless an explicit using namespace directive
    makes them available to the current namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Even though this looks like recursion, it is not a true runtime recursion, because
    after the compiler expands and generates the code from templates, what we end
    up with is basically calls to overloaded functions with a different number of
    parameters. This is later explained in the recipe *Writing a function template
    with a variable number of arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `binary_struct` class template has a template type `CharT` for the return
    type of the function (we need this because our literal operator templates should
    return either `byte8`, `byte16`, or `byte32`) and a parameter pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Several specializations of this class template are available with parameter
    pack decomposition. When the first digit of the pack is ''0'', the computed value
    remains the same, and we continue expanding the rest of the pack. If the first
    digit of the pack is ''1'', then the new value is 1 shifted to the left with the
    number of digits in the remainder of the pack bit, or the value of the rest of
    the pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The last specialization covers the case when the pack is empty; in this case
    we return 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining these helper classes, we could implement the `byte8`, `byte16`,
    and `byte32` binary literals as intended. Note that we need to bring the content
    of the namespace `binary_literals` in the current namespace in order to use the
    literal operator templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following definitions trigger compiler errors because the condition in
    `static_assert` is not met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using raw string literals to avoid escaping character*s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a function template with variable number of arguments* recipe of [Chapter
    10](5ca9534c-f23e-4ef3-a59f-7bd377721eea.xhtml), *Exploring Functions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw string literals to avoid escaping characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings may contain special characters, such as non-printable characters (newline,
    horizontal and vertical tab, and so on), string and character delimiters (double
    and single quotes) or arbitrary octal, hexadecimal, or Unicode values. These special
    characters are introduced with an escape sequence that starts with a backslash,
    followed by either the character (examples include `'` and `"`), its designated
    letter (examples include `n` for a new line, `t` for a horizontal tab), or its
    value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As a result,
    the backslash character itself has to be escaped with another backslash character.
    This leads to more complicated literal strings that can be hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid escaping characters, C++11 introduced raw string literals that do not
    process escape sequences. In this recipe, you will learn how to use the various
    forms of raw string literals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, and throughout the rest of the book, I will use the `s` suffix
    to define `basic_string` literals. This has been covered in the recipe *Creating
    cooked user-defined literals*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid escaping characters, define the string literals with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R"( literal )"` as the default form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`R"delimiter( literal )delimiter"` where `delimiter` is any character sequence
    not present in the actual string when the sequence `)"` should actually be part
    of the string. Here is an example with `!!` as delimited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When string literals are used, escapes are not processed, and the actual content
    of the string is written between the delimiter (in other words, what you see is
    what you get). The following example shows what appears as the same raw literal
    string; however, the second one still contains escaped characters. Since these
    are not processed in the case of string literals, they will be printed as they
    are in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In case the text has to contain the `)"` sequence, then a different delimiter
    must be used, in the `R"delimiter( literal )delimiter"` form. According to the
    standard, the possible characters in a delimiter can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'any member of the basic source character set except: space, the left parenthesis
    (the right parenthesis ), the backslash \, and the control characters representing
    horizontal tab, vertical tab, form feed, and newline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raw string literals can be prefixed by one of `L`, `u8`, `u`, and `U` to indicate
    a wide, UTF-8, UTF-16, or UTF-32 string literal. The following are examples of
    such string literals. Note that the presence of string literal `operator ""s`
    at the end of the string makes the compiler deduce the type as various string
    classes and not character arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library of string helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string types from the standard library are a general purpose implementation
    that lacks many helpful methods, such as changing the case, trimming, splitting,
    and others that may address different developer needs. Third-party libraries that
    provide rich sets of string functionalities exist. However, in this recipe, we
    will look at implementing several simple, yet helpful, methods you may often need
    in practice. The purpose is rather to see how string methods and standard general
    algorithms can be used for manipulating strings, but also to have a reference
    to reusable code that can be used in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement a small library of string utilities that
    will provide functions for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing a string to lowercase or uppercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming white spaces from the beginning and/or the end of the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming a specific set of characters from the beginning and/or the end of the
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing occurrences of a character anywhere in the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokenizing a string using a specific delimiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The string library we will be implementing should work with all the standard
    string types, `std::string`, `std::wstring`, `std::u16string`, and `std::u32string`.
    To avoid specifying long names such as `std::basic_string<CharT, std::char_traits<CharT>,
    std::allocator<CharT>>`, we will use the following alias templates for strings
    and string streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To implement these string helper functions, we need to include the header `<string>`
    for strings and `<algorithm>` for the general standard algorithms we will use.
  prefs: []
  type: TYPE_NORMAL
- en: In all the examples in this recipe, we will use the standard user-defined literal
    operators for strings from C++14, for which we need to explicitly use the `std::string_literals` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert a string to lowercase or uppercase, apply the `tolower()` or `toupper()`
    functions on the characters of a string using the general purpose algorithm `std::transform()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To reverse a string, use the general purpose algorithm `std::reverse()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To trim a string, at the beginning, end, or both, use `std::basic_string`''s
    methods `find_first_not_of()` and `find_last_not_of()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To trim characters in a given set from a string, use overloads of `std::basic_string`''s
    methods `find_first_not_of()` and `find_last_not_of()`, that take a string parameter
    that defines the set of characters to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove characters from a string, use `std::remove_if()` and `std::basic_string::erase()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To split a string based on a specified delimiter, use `std::getline()` to read
    from an `std::basic_stringstream` initialized with the content of the string.
    The tokens extracted from the stream are pushed into a vector of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For implementing the utility functions from the library, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions would modify a string passed by a reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions would not alter the original string but return a new string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option has the advantage that it preserves the original string, which
    may be helpful in many cases. Otherwise, in those cases, you would first have
    to make a copy of the string and alter the copy. The implementation provided in
    this recipe takes the second approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first functions we implemented in the *How to do it...* section were `to_upper()`
    and `to_lower()`. These functions change the content of a string either to uppercase
    or lowercase. The simplest way to implement this is using the `std::transform()`
    standard algorithm. This is a general purpose algorithm that applies a function
    to every element of a range (defined by a begin and end iterator) and stores the
    result in another range for which only the begin iterator needs to be specified.
    The output range can be the same as the input range, which is exactly what we
    did to transform the string. The applied function is `toupper()` or `tolower()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function we considered was `reverse()`, that, as the name implies,
    reverses the content of a string. For this, we used the `std::reverse()` standard
    algorithm. This general purpose algorithm reverses the elements of a range defined
    by a begin and end iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to trimming, a string can be trimmed at the beginning, end, or
    both sides. Because of that, we implemented three different functions: `trim()`
    for trimming at both ends, `trimleft()` for trimming at the beginning of a string,
    and `trimright()` for trimming at the end of a string. The first version of the
    functions trims only spaces. In order to find the right part to trim, we use the `find_first_not_of()`
    and `find_last_not_of()` methods of `std::basic_string`. These return the first
    and last characters in the string that are not the specified character. Subsequently,
    a call to the `substr()` method of `std::basic_string` returns a new string. The
    `substr()` method takes an index in the string and a number of elements to copy
    to the new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be sometimes useful to trim other characters and then spaces from
    a string. In order to do that, we provided overloads for the trimming functions
    that specify a set of characters to be removed. That set is also specified as
    a string. The implementation is very similar to the previous one because both
    `find_first_not_of()` and `find_last_not_of()` have overloads that take a string
    containing the characters to be excluded from the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If removing characters from any part of the string is necessary, the trimming
    methods are not helpful because they only treat a contiguous sequence of characters
    at the start and end of a string. For that, however, we implemented a simple `remove()`
    method. This uses the `std:remove_if()` standard algorithm. Both `std::remove()`
    and `std::remove_if()` work in a way that may not be very intuitive at first.
    They remove elements that satisfy the criteria from a range defined by a first
    and last iterator by rearranging the content of the range (using move assignment).
    The elements that need to be removed are placed at the end of the range, and the
    function returns an iterator to the first element in the range that represents
    the removed elements. This iterator basically defines the new end of the range
    that was modified. If no element was removed, the returned iterator is the end
    iterator of the original range. The value of this returned iterator is then used
    to call the `std::basic_string::erase()` method that actually erases the content
    of the string defined by two iterators. The two iterators in our case are the
    iterator returned by `std::remove_if()` and the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method we implemented splits the content of a string based on a specified
    delimiter. There are various ways to implement this. In this implementation, we
    used `std::getline()`. This function reads characters from an input stream until
    a specified delimiter is found and places the characters in a string. Before starting
    to read from the input buffer, it calls `erase()` on the output string to clear
    its content. Calling this method in a loop produces tokens that are placed in
    a vector. In our implementation, empty tokens were skipped from the result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the format of a string using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are a language intended for performing pattern matching
    and replacements in texts. C++11 provides support for regular expressions within
    the standard library through a set of classes, algorithms, and iterators available
    in the header `<regex>`. In this recipe, we will see how regular expressions can
    be used to verify that a string matches a pattern (examples can include verifying
    an e-mail or IP address formats).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this recipe, we will explain whenever necessary the details of the
    regular expressions that we use. However, you should have at least some basic
    knowledge of regular expressions in order to use the C++ standard library for
    regular expressions. A description of regular expressions syntax and standards
    is beyond the purpose of this book; if you are not familiar with regular expressions,
    it is recommended that you read more about them before continuing with the recipes
    that focus on regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to verify that a string matches a regular expression, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user-defined literals for strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (that can occur frequently). The following regular expression validates
    most e-mails formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To ignore casing or specify other parsing options, use an overloaded constructor
    that has an extra parameter for regular expression flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `std::regex_match()` to match the regular expression to an entire string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering the problem of verifying the format of e-mail addresses, even though
    this may look like a trivial problem, in practice it is hard to find a simple
    regular expression that covers all the possible cases for valid e-mail formats.
    In this recipe, we will not try to find that ultimate regular expression, but
    rather to apply a regular expression that is good enough for most cases. The regular
    expression we will use for this purpose is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table explains the structure of the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of string |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z0-9._%+-]+` | At least one character in the range A-Z, 0-9, or one of
    -, %, + or - that represents the local part of the email address |'
  prefs: []
  type: TYPE_TB
- en: '| `@` | Character @ |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z0-9.-]+` | At least one character in the range A-Z, 0-9, or one of -,
    %, + or - that represents the hostname of the domain part |'
  prefs: []
  type: TYPE_TB
- en: '| `\.` | A dot that separates the domain hostname and label |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z]{2,}` | The DNS label of a domain that can have between 2 and 63 characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of the string |'
  prefs: []
  type: TYPE_TB
- en: Bear in mind that in practice a domain name is composed of a hostname followed
    by a dot-separated list of DNS labels. Examples include `localhost`, `gmail.com`,
    or `yahoo.co.uk`. This regular expression we are using does not match domains
    without DNS labels, such as localhost (an e-mail, such as `root@localhost` is
    a valid e-mail). The domain name can also be an IP address specified in brackets,
    such as `[192.168.100.11]` (as in `john.doe@[192.168.100.11]`). E-mail addresses
    containing such domains will not match the regular expression defined above. Even
    though these rather rare formats will not be matched, the regular expression can
    cover most of the e-mail formats.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression in the example in this chapter is provided for didactical
    purposes only, and it is not intended for being used as it is in production code.
    As explained earlier, this sample does not cover all possible e-mail formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'We began by including the necessary headers, `<regex>` for regular expressions
    and `<string>` for strings. The `is_valid_email()` function shown in the following (that
    basically contains the samples from the *How to do it...* section) takes a string
    representing an e-mail address and returns a boolean indicating whether the e-mail
    has a valid format or not. We first construct an `std::regex` object to encapsulate
    the regular expression indicated with the raw string literal. Using raw string
    literals is helpful because it avoids escaping backslashes that are used for escape
    characters in regular expressions too. The function then calls `std::regex_match()`,
    passing the input text and the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::regex_match()` method tries to match the regular expression against
    the entire string. If successful it returns `true`, otherwise `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this simple test, the only e-mails that do not match the regular expression
    are `ROOT@LOCALHOST` and `john.doe@domain.com`. The first contains a domain name
    without a dot-prefixed DNS label and that case is not covered in the regular expression.
    The second contains only lowercase letters, and in the regular expression, the
    valid set of characters for both the local part and the domain name was uppercase
    letters, A to Z.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of complicating the regular expression with additional valid characters
    (such as `[A-Za-z0-9._%+-]`), we can specify that the match can ignore the case.
    This can be done with an additional parameter to the constructor of the `std::basic_regex`
    class. The available constants for this purpose are defined in the `regex_constants`
    namespace. The following slight change to the `is_valid_email_format()` will make
    it ignore the case and allow e-mails with both lowercase and uppercase letters
    to correctly match the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This `is_valid_email_format()` function is pretty simple, and if the regular
    expression was provided as a parameter along with the text to match, it could
    be used for matching anything. However, it would be nice to be able to handle
    with a single function not only multi-byte strings (`std::string`) but also wide
    strings (`std::wstring`). This can be achieved by creating a function template
    where the character type is provided as a template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating an alias template for `std::basic_string` in order to
    simplify its use. The new `is_valid_format()` function is a function template
    very similar to our implementation of `is_valid_email()`**.** However, we now
    use `std::basic_regex<CharT>` instead of the typedef `std::regex,` which is `std::basic_regex<char>,`
    and the pattern is provided as the first argument. We now implement a new function
    called `is_valid_email_format_w()` for wide strings that relies on this function
    template. The function template, however, can be reused for implementing other
    validations, such as if a license plate has a particular format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Of all the examples shown above, the only one that does not match is `ROOT@LOCAHOST`,
    as already expected.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::regex_match()` method has, in fact, several overloads, and some of
    them have a parameter that is a reference to an `std::match_results` object to
    store the result of the match. If there is no match, then `std::match_results`
    is empty and its size is 0\. Otherwise, if there is a match, the `std::match_results`
    object is not empty and its size is 1 plus the number of matched subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following version of the function uses the mentioned overloads and returns
    the matched subexpressions in an `std::smatch` object. Note that the regular expression
    is changed, as three caption groups are defined-- one for the local part, one
    for the hostname part of the domain, and one for the DNS label. If the match is
    successful, then the `std::smatch` object will contain four submatch objects:
    the first to match the entire string, the second for the first capture group (the
    local part), the third for the second capture group (the hostname), and the fourth
    for the third and last capture group (the DNS label). The result is returned in
    a tuple, where the first item actually indicates success or failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the preceding code, we use C++17 structured bindings to unpack the
    content of the tuple into named variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple versions of regular expressions, and the C++ standard library
    supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and
    egrep (grep with option `-E`). The default grammar used is ECMAScript, and in
    order to use another, you explicitly have to specify the grammar when defining
    the regular expression. In addition to specifying the grammar, you can also specify
    parsing options, such as matching by ignoring the case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library provides more classes and algorithms than what we have
    seen so far. The main classes available in the library are the following (all
    of them are class templates and, for convenience, `typedef`s are provided for
    different character types):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class template `std::basic_regex` defines the regular expression object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The class template `std::sub_match` represents a sequence of characters that
    matches a capture group; this class is actually derived from `std::pair`, and
    its `first` and `second` members represent iterators to the first and the one-past-end
    characters in the match sequence; if there is no match sequence, the two iterators
    are equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The class template `std::match_results` is a collection of matches; the first
    element is always a full match in the target, and the other elements are matches
    of subexpressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithms available in the regular expressions standard library are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::regex_match()`: This tries to match a regular expression (represented
    by a `std::basic_regex` instance) to an entire string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_search()`: This tries to match a regular expression (represented
    by a `std::basic_regex` instance) to a part of a string (including the entire
    string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_replace()`: This replaces matches from a regular expression according
    to a specified format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The iterators available in the regular expressions standard library are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::regex_interator`: A constant forward iterator used to iterate through
    the occurrences of a pattern in a string. It has a pointer to an `std::basic_regex`
    that must live until the iterator is destroyed. Upon creation and when incremented,
    the iterator calls `std::regex_search()` and stores a copy of the `std::match_results`
    object returned by the algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_token_iterator`: A constant forward iterator used to iterate through
    the submatches of every match of a regular expression in a string. Internally,
    it uses an `std::regex_iterator` to step through the submatches. Since it stores
    a pointer to an `std::basic_regex` instance, the regular expression object must
    live until the iterator is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Parsing the content of a string using regular expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing the content of a string using regular expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using structured bindings to handle multi-return values* recipe of [Chapter
    8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning Modern Core Language
    Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the content of a string using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have looked at how to use `std::regex_match()` to
    verify that the content of a string matches a particular format. The library provides
    another algorithm called `std::regex_search()` that matches a regular expression
    against any part of a string, and not only the entire string as `regex_match()`
    does. This function, however, does not allow searching through all the occurrences
    of a regular expression in an input string. For this purpose, we need to use one
    of the iterator classes available in the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to parse the content of a string using regular
    expressions. For this purpose, we will consider the problem of parsing a text
    file containing name-value pairs. Each such pair is defined on a different line
    having the format `name = value`, but lines starting with a `#` represent comments
    and must be ignored. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For general information about regular expressions support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe. Basic
    knowledge of regular expressions is required for proceeding with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, `text` is a variable defined as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to search for occurrences of a regular expression through a string
    you should perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user-defined literals for strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (that can occur frequently). The following regular expression validates
    the file format proposed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for the first occurrence of a regular expression in a given text,
    use the general purpose algorithm `std::regex_search()` (example 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To find all the occurrences of a regular expression in a given text, use the
    iterator `std::regex_iterator` (example 2):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate through all the subexpressions of a match, use the iterator `std::regex_token_iterator`
    (example 3):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple regular expression that can parse the input file shown earlier may
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This regular expression is supposed to ignore all lines that start with a `#`;
    for those that do not start with `#`, match a name followed by the equal sign
    and then a value that can be composed of alphanumeric characters and several other
    characters (underscore, dot, comma, and so on). The exact meaning of this regular
    expression is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of line |'
  prefs: []
  type: TYPE_TB
- en: '| `(?!#)` | A negative lookahead that makes sure that it is not possible to
    match the # character |'
  prefs: []
  type: TYPE_TB
- en: '| `(\w)+` | A capturing group representing an identifier of at least a one
    word character |'
  prefs: []
  type: TYPE_TB
- en: '| `\s*` | Any white spaces |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Equal sign |'
  prefs: []
  type: TYPE_TB
- en: '| `\s*` | Any white spaces |'
  prefs: []
  type: TYPE_TB
- en: '| `([\w\d]+[\w\d._,\-:]*)` | A capturing group representing a value that starts
    with an alphanumeric character, but can also contain a dot, comma, backslash,
    hyphen, colon, or an underscore. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of line |'
  prefs: []
  type: TYPE_TB
- en: We can use `std::regex_search()` to search for a match anywhere in the input
    text. This algorithm has several overloads, but in general they work in the same
    way. You must specify the range of characters to work through, an output `std::match_results`
    object that will contain the result of the match, and a `std::basic_regex` object
    representing the regular expression and matching flags (that define the way the
    search is done). The function returns `true` if a match was found or `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example from the previous section (see the 4th list item), `match`
    is an instance of `std::smatch` that is a `typedef` of `std::match_results` with
    `string::const_iterator` as the template type. If a match was found, this object
    will contain the matching information in a sequence of values for all matched
    subexpressions. The submatch at index 0 is always the entire match. The submatch
    at index 1 is the first subexpression that was matched, the submatch at index
    2 is the second subexpression that was matched, and so on. Since we have two capturing
    groups (that are subexpressions) in our regular expression, the `std::match_results`
    will have three submatches in case of success. The identifier representing the
    name is at index 1, and the value after the equal sign is at index 2\. Therefore,
    this code only prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `std::regex_search()` algorithm is not able to iterate through all the possible
    matches in a text. To do that, we need to use an iterator. `std::regex_iterator` is intended
    for this purpose. It allows not only iterating through all the matches, but also
    accessing all the submatches of a match. The iterator actually calls `std::regex_search()`
    upon construction and on each increment, and it remembers the result `std::match_results`
    from the call. The default constructor creates an iterator that represents the
    end of the sequence and can be used to test when the loop through the matches
    should stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example from the previous section (see the 5th list item), we
    first create an end of sequence iterator, and then we start iterating through
    all the possible matches. When constructed, it will call `std::regex_match()`,
    and if a match is found, we can access its results through the current iterator.
    This will continue until no match is found (end of the sequence). This code will
    print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative to `std::regex_iterator` is `std::regex_token_iterator`. This
    works similar to the way `std::regex_iterator` works and, in fact, it contains
    such an iterator internally, except that it enables us to access a particular
    subexpression from a match. This is shown in the third example in the *How to
    do it..*. section (the the 6th list item). We start by creating an end-of-sequence
    iterator and then loop through the matches until the end-of-sequence is reached.
    In the constructor we used, we did not specify the index of the subexpression
    to access through the iterator; therefore, the default value of 0 is used. That
    means this program will print the entire matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to access only the first subexpression (that means the names in
    our case), all we had to do was specify the index of the subexpression in the
    constructor of the token iterator. This time, the output that we get is only the
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting thing about the token iterator is that it can return the unmatched
    parts of the string if the index of the subexpressions is `-1`, in which case
    it returns an `std::match_results` object that corresponds to the sequence of
    characters between the last match and the end of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will output the following (note that the empty lines are actually
    part of the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Verifying the format of a string using regular expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing the content of a string using regular expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the content of a string using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two recipes, we have looked at how to match a regular expression
    on a string or a part of a string and iterate through matches and submatches.
    The regular expression library also supports text replacement based on regular
    expressions. In this recipe, we will see how to use `std::regex_replace()` to
    perform such text transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For general information about regular expressions support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to perform text transformations using regular expressions, you should
    perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user defined literals for strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `std::regex_replace()` algorithm with a replacement string as the third argument.
    Consider this example: replace all words composed of exactly three characters
    that are either `a`, `b`, or `c` with three hyphens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `std::regex_replace()` algorithm with match identifiers prefixed with
    a `$` for the third argument. For example, replace names in the "lastname, firstname"
    with names in the format "firstname lastname", as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::regex_replace()` algorithm has several overloads with different types
    of parameters, but the meaning of the parameters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The input string on which the replacement is performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `std::basic_regex` object that encapsulates the regular expression used to
    identify the parts of the strings to be replaced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string format used for replacement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional matching flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return value is, depending on the overload used, either a string or a copy
    of the output iterator provided as an argument. The string format used for replacement
    can either be a simple string or a match identifier indicated with a `$` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$&` indicates the entire match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1`, `$2`, `$3`, and so on, indicate the first, second, third submatch, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`` indicates the part of the string before the first match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$''` indicates the part of the string after the last match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first example shown in the *How to do it...* section, the initial text
    contains two words made of exactly three `a`, `b`, or `c` characters, `abc` and
    `bca`. The regular expression indicates an expression of exactly three characters
    between word boundaries. That means a subtext, such as `bbbb`, will not match
    the expression. The result of the replacement is that the string text will be
    `--- aa --- ca bbbb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional flags for the match can be specified to the `std::regex_replace()`
    algorithm. By default, the matching flag is `std::regex_constants::match_default`
    that basically specifies ECMAScript as the grammar used for constructing the regular
    expression. If we want, for instance, to replace only the first occurrence, then
    we can specify `std::regex_constants::format_first_only`. In the next example,
    the result is `--- aa bca ca bbbb` as the replacement stops after the first match
    is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The replacement string, however, can contain special indicators for the whole
    match, a particular submatch, or the parts that were not matched, as explained
    earlier. In the second example shown in the *How to do it...* section, the regular
    expression identifies a word of at least one character, followed by a coma and
    possible white spaces and then another word of at least one character. The first
    word is supposed to be the last name and the second word is supposed to be the
    first name. The replacement string has the `$2 $1` format. This is an instruction
    to replace the matched expression (in this example, the entire original string)
    with another string formed of the second submatch followed by space and then the
    first submatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the entire string was a match. In the next example, there will
    be multiple matches inside the string, and they will all be replaced with the
    indicated string. In this example, we are replacing the indefinite article *a*
    when preceding a word that starts with a vowel (this, of course, does not cover
    words that start with a vowel sound) with the indefinite article *an*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression identifies the letter *a* as a single word (`\b` indicates
    a word boundary, so `\ba` means a word with a single letter *a*) followed by a
    space and a word of at least two characters starting with a vowel. When such a
    match is identified, it is replaced with a string formed of the fixed string *an*
    followed by a space and the first subexpression of the match, which is the word
    itself. In this example, the `newtext` string will be *this is an example with
    an error*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the identifiers of the subexpressions (`$1`, `$2`, and so on), there
    are other identifiers for the entire match (`$&`), the part of the string before
    the first match (`$``) and the part of the string after the last match (`$''`).
    In the last example, we change the format of a date from `dd.mm.yyyy` to `yyyy.mm.dd`,
    but also show the matched parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression matches a one- or two-digit number followed by a dot,
    hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen,
    or slash; and last a four-digit number.
  prefs: []
  type: TYPE_NORMAL
- en: For `newtext1`, the replacement string is `$5$4$3$2$1`; that means year, followed
    by the second separator, then month, the first separator, and finally day. Therefore,
    for the input string *"today is 1.06.2016!"*, the result is *"today is 2016.06.1!!"*.
  prefs: []
  type: TYPE_NORMAL
- en: For `newtext2`, the replacement string is `[$`][$&][$']`; that means the part
    before the first match, followed by the entire match, and finally the part after
    the last match are in square brackets. However, the result is not *"[!!][1.06.2016][today
    is ]"* as you perhaps might expect at a first glance, but *"today is [today is
    ][1.06.2016][!!]!!"*. The reason is that what is replaced is the matched expression,
    and, in this case, that is only the date (*"1.06.2016"*). This substring is replaced
    with another string formed of the all parts of the initial string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Verifying the format of a string using regular expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parsing the content of a string using regular expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using string_view instead of constant string references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with strings, temporary objects are created all the time, even
    if you might not be really aware of it. Many times the temporary objects are irrelevant
    and only serve the purpose of copying data from one place to another (for example,
    from a function to its caller). This represents a performance issue because they
    require memory allocation and data copying, which is desirable to be avoided.
    For this purpose, the C++17 standard provides a new string class template called
    `std::basic_string_view` that represents a non-owning constant reference to a
    string (that is, a sequence of characters). In this recipe, you will learn when
    and how you should use this class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `string_view` class is available in the namespace `std` in the `string_view` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should use `std::string_view` to pass a parameter to a function (or return
    a value from a function), instead of `std::string const &` unless your code needs
    to call other functions that take `std::string` parameters (in which case, conversions
    would be necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at how the new string type works, let's consider the following
    example of a function that is supposed to extract the name of a file without its
    extension. This is basically how you would write the function from the previous
    section before C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this example the file separator is `\` (backslash) as in Windows.
    For Linux-based systems, it has to be changed to `/` (slash).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This is a relatively simple function. It takes a constant reference to an `std::string`
    and identifies a substring bounded by the last file separator and the last dot
    that basically represents a filename without an extension (and without folder
    names).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this code, however, is that it creates one, two, or, possibly,
    even more temporaries, depending on the compiler optimizations. The function parameter
    is a constant `std::string` reference, but the function is called with a string
    literal, which means `std::string` needs to be constructed from the literal. These
    temporaries need to allocate and copy data, which is both time- and resource-consuming.
    In the last example, all we want to do is check whether the first character of
    the filename is an underscore, but we create at least two temporary string objects
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::basic_string_view` class template is intended to solve this problem.
    This class template is very similar to `std::basic_string`, the two having almost
    the same interface. The reasons for this is that the `std::basic_string_view`
    is intended to be used instead of a constant reference to an `std::basic_string`
    without further code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with `std::basic_string`, there are specializations for all types
    of standard characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The `std::basic_string_view` class template defines a reference to a constant
    contiguous sequence of characters. As the name implies, it represents a view and
    cannot be used to modify the reference sequence of characters. An `std::basic_string_view`
    object has a relatively small size because all that it needs is a pointer to the
    first character in the sequence and the length. It can be constructed not only
    from an `std::basic_string` object but also from a pointer and a length or from
    a null-terminated sequence of characters (in which case, it will require an initial
    traversing of the string in order to find the length). Therefore, the `std::basic_string_view`
    class template can also be used as a common interface for multiple types of strings
    (as long as data only needs to be read). On the other hand, converting from an `std::basic_string_view`
    to an `std::basic_string` is easy because the former has both a `to_string()`
    and a converting `operator std::basic_string` to create a new `std::basic_string`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Passing `std::basic_string_view` to functions and returning `std::basic_string_view`
    still creates temporaries of this type, but these are small size objects on the
    stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore,
    they should incur fewer performance costs than allocating heap space and copying
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all major compilers provide an implementation of std::basic_string
    that includes a small string optimization. Although the implementation details
    are different, they typically rely on having a statically allocated buffer of
    a number of characters (16 for VC++ and gcc 5 or newer) that does not involve
    heap operations, which are only required when the size of the string exceeds that
    number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the methods that are identical to those available in `std::basic_string`,
    the `std::basic_string_view` has two more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove_prefix()`: Shrinks the view by incrementing the start with *N* characters
    and decrementing the length with *N* characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_suffix()`: Shrinks the view by decrementing the length with *N* characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two member functions are used in the following example to trim an `std::string_view`
    from spaces, both at the beginning and the end. The implementation of the function
    first looks for the first element that is not a space and then for the last element
    that is not a space. Then, it removes from the end everything after the last non-space
    character, and from the beginning everything until the first non-space character.
    The function returns the new view trimmed at both ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When using an `std::basic_string_view`, you must be aware of two things: you
    cannot change the underlying data referred by a view and you must manage the lifetime
    of the data, as the view is a non-owning reference.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating a library of string helpers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
