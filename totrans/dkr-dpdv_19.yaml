- en: '17: Enterprise-grade features'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter follows on from the previous chapter, and covers some of the enterprise-grade
    features provided by Docker Universal Control Plane (UCP) and Docker Trusted Registry
    (DTR).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be assuming you’ve read the previous chapter, so know how to install and
    configure them, as well as perform backup and recovery operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split this chapter into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise-grade features - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enterprises want to use Docker and containers, but they need things packaged
    and supported like a real enterprise app. They also need things like role-based
    access control and integration with enterprise directory services like Active
    Directory. This is where *Docker Enterprise Edition* comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Enterprise Edition is a hardened version of the Docker engine, an Ops
    UI, a secure registry, and a bunch of enterprise-focussed features. You can deploy
    it on-premises or in the cloud, you manage it yourself, and you can get it with
    a support contract.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, it’s a container-as-a-service platform that you can run in the safety
    of your own corporate data center.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise-grade features - The Deep Dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll divide this main section of the chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active Directory integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Content Trust (DCT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Docker Trusted Registry (DTR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Trusted Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image promotions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Routing Mesh (HRM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve spent the majority of the last 10 years of my career running IT in the
    financial services sector. Two checkboxes that are mandatory at most places I
    worked, are role-based access control (RBAC) and Active Directory (AD) integration.
    If you were trying to sell us a product, and it didn’t have these two features,
    we wouldn’t buy it!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Docker EE has both. In this section we’ll talk about RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: 'UCP implements RBAC via something called a *grant*. At a high level, a grant
    is made of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *subject* is one or more users or a team. The *role* is the set of permissions,
    and the *collection* is the resources these permissions apply to. See Figure 17.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 Grant](images/figure17-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 Grant
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2, shows an example where the `SRT` team has `container-full-control`
    access to all resources in the `/zones/dev/srt` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2](images/figure17-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s complete the following steps to create a grant:'
  prefs: []
  type: TYPE_NORMAL
- en: Create users and teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only UCP Admins can create and manage users, teams, roles, collections, and
    grants. So to follow along, you’ll need to be logged in as a UCP admin.
  prefs: []
  type: TYPE_NORMAL
- en: Create users and teams
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s a best practice to group users into teams, and assign teams to grants.
    You *can* assign individual users to a *grant*, but it’s not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create some users and teams.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to UCP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand `User Management` and click `Users`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here you can create users.
  prefs: []
  type: TYPE_NORMAL
- en: Click `Organization & Teams`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here you can create organizations. For the examples in the next few steps,
    we’ll be using an organization called “manufacturing”.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `manufacturing` organization and create a team.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Teams exist within an organization. It’s not possible to create a team that
    isn’t part of an organization, and a team can only be a member of one organization.
  prefs: []
  type: TYPE_NORMAL
- en: Add users to a team.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a user to a team, you need to click into the team and choose `Add Users`
    from the `Actions` menu.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 shows how to add users to the `SRT` team in the `manufacturing`
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 Adding users to teams](images/figure17-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 Adding users to teams
  prefs: []
  type: TYPE_NORMAL
- en: You now have some users and teams. UCP shares its user database with DTR, meaning
    any users and teams you create in UCP are also available in DTR.
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom role
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Custom roles are powerful, they let you get extremely granular with the permissions
    you assign. In this step we’ll create a new custom role called `secret-ops` that
    allows subjects to create, delete, update, use, and view Docker secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `User Management` tab of the left-hand navigation pane and select
    `Roles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the role a name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example we’re going to create a new custom role called “secret-ops”
    with permission to perform all secret-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: Select `Operations` and explore the list of operations that can be assigned
    to the role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list is long, and allows you to specify individual API operations.
  prefs: []
  type: TYPE_NORMAL
- en: Select the individual API operations you want to assign to the role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the example, we’ll assign all secret-related API operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 Assigning API operations to a custom role](images/figure17-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 Assigning API operations to a custom role
  prefs: []
  type: TYPE_NORMAL
- en: Click `Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The role is now on the system and can be assigned to multiple grants.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Create a collection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the previous chapter we learned that networks, volumes, secrets, services,
    and nodes are Swarm resources — they get stored in the Swarm config at `/var/lib/docker/swarm`.
    *Collections* let you group these in ways that match your organizational structure
    and IT requirements. For example, your IT infrastructure might be divided into
    three zones; `prod`, `test`, and `dev`. If this is the case, you could create
    three collections and assign resources to each, as shown in Figure 17.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 High-level collections](images/figure17-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 High-level collections
  prefs: []
  type: TYPE_NORMAL
- en: Each resource can only be in one collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next steps, we’ll create a new collection called `zones/dev/srt` and
    assign a secret to it. Collections are hierarchical by nature, so you’ll need
    to create three nested collections like this: `zones` > `dev` > `srt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Perform all of the following steps from the Docker UCP web UI.
  prefs: []
  type: TYPE_NORMAL
- en: Select `Collections` from the left navigation pane, and choose `Create Collection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the root collection called `zones`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `View Children` for the `/zones` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a nested child collection called `dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `View Children` for the `/zones/dev` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the final nested child collection called `srt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have a collection called `/zones/dev/srt`. However, it’s currently empty.
    In the next steps we’ll add a *secret* to it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create it from the command line or the UCP web UI. We’ll explain the
    web UI method.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the UCP web UI click: `Secrets` > `Create Secret`. Give it a name, some
    data and click `Save`.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to configure the *collection* at the same time you create the
    secret. But we’re not doing it that way.
  prefs: []
  type: TYPE_NORMAL
- en: Locate and select the secret in the UCP web UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Collection` from the `Configure` drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate through the `View Children` hierarchy until the `/zones/dev/srt` collection
    is selected and click `Save`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The secret is now part of the `/zones/dev/srt` collection. It cannot be a member
    of any other collections.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing about *collections* before we create the *grant*. Collections
    have an inheritance model where access to any collection automatically implies
    access to nested child collections. In Figure 17.6, the `dev` team has access
    to the `/zones/dev` collection, and as such, it automatically gets access to the
    resources in the `srt`, `hellcat` and `daemon` child collections.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6 Collection inheritance](images/figure17-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.6 Collection inheritance
  prefs: []
  type: TYPE_NORMAL
- en: Create a grant
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have users and teams, a custom role, and a collection, you can
    create a grant. In this example, we’ll create a grant for the `srt-dev` team to
    have the custom `secret-ops` role against all resources in the `/zones/dev/srt`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Grants are about *who*, gets *what access*, to *which resources*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/figure17-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Expand the `User Management` tab on the left navigation pane and click `Grants`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new grant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Subject` and choose the `SRT` team from the `manufacturing` organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s possible to select an entire organization. If you do this, all teams within
    the organization will be included in the grant.
  prefs: []
  type: TYPE_NORMAL
- en: Click `Role` and select the custom `secret-ops` role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Collections` and select the `/zones/dev/srt` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have to view the children of the top-level `Swarm` collection before
    you see `/zones`.
  prefs: []
  type: TYPE_NORMAL
- en: Click `Save` to create the grant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The grant is now created and can be viewed in the list of all grants on the
    system. Members of the `manufacturing/SRT` team can now perform all secret-related
    operations on resources in the `/zones/dev/srt` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/figure17-8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can modify components of a grant while the grant is live. For example, you
    can add users to the team, and resources to the collection. But you cannot alter
    the API operations assigned to the role. If you want to change the permissions
    of the role, you will need to create a new one with the desired permissions.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC for nodes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One final thing on RBAC. It’s possible to group the worker nodes in your cluster
    for scheduling purposes. For example, you might run a single cluster for dev,
    testing, and QA workloads — a single cluster might reduce admin overheads and
    make it easier to assign nodes to the three different environments. But you might
    also want worker nodes divided up so that only members of the `dev` team can schedule
    work onto nodes in the `dev` collection etc.
  prefs: []
  type: TYPE_NORMAL
- en: As you’d expect, you accomplish this with *grants*. First of all, you’d assign
    UCP Worker nodes to a custom *collection*. Then you’d create a grant comprising
    the collection, the built-in `Scheduler` *role*, and the team that you want to
    assign the grant to. This lets you control which users can schedule work to which
    nodes in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: As a simple example, the grant shown in Figure 17.9 will allow members of the
    `dev` team to be able to schedule services and containers onto worker nodes in
    the `/zones/dev` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.9 RBAC for nodes](images/figure17-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.9 RBAC for nodes
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You know how to implement RBAC in Docker UCP!
  prefs: []
  type: TYPE_NORMAL
- en: Active Directory integration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like all good enterprise tools, UCP integrates with Active Directory and other
    LDAP directory services. This allows it to leverage existing users and groups
    from your organization’s established single-sign-on system.
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further in this section, it is vital that you discuss any AD/DLAP
    integration plans with the teams responsible for directory services in your organization.
    Get them involved from the start, so that your planning and implementation can
    be as smooth as possible!
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-the-box, UCP user and group data is stored in a local database that’s
    leveraged by DTR for a single-sign-on (SSO) experience. This authenticates all
    access requests locally, and allows you to login to DTR without having to enter
    your UCP credentials again. However, **UCP admins** can configure UCP to leverage
    existing corporate user accounts stored in AD or other LDAP directory services
    — offloading authentication and account management to existing teams and processes.
  prefs: []
  type: TYPE_NORMAL
- en: The following procedure will show you how to configure UCP to leverage AD for
    user accounts. At a high level, the process tells UCP to search for user accounts,
    in a specific directory, and copy them into UCP. As previously stated, co-ordinate
    this work with your directory services team.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do it.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `Admin` drop-down in the left navigation pane and select `Admin Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Authentication & Authorization` and click `Yes` under the **LDAP Enabled**
    heading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure LDAP Server settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At a high level, you can think of the `LDAP Server Settings` as *where to search*.
    E.g. which directories to look in for user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: The values entered here will be specific to your environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**LDAP Server URL** is the name of an LDAP server in the domain you’ll be searching
    for accounts in. For example, `ad.mycompany.internal`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reader DN** and **Reader Password** are the credentials for an account in
    the directory with permission to search it. The account must exist in, or be trusted
    by, the directory you are searching. It’s best practice for it to have *read-only*
    permissions in the directory.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `Add LDAP Domain +` button to add additional domains to search.
    Each one needs its own LDAP Server URL and Reader account.
  prefs: []
  type: TYPE_NORMAL
- en: Configure LDAP User Search Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `LDAP Server Settings` is *where to search*, then `LDAP User Search Configuration`
    is *what to search for*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Base DN** Specifies the LDAP node to start the search from.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Username Attribute** is the LDAP attribute to use as the UCP username.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full Name Attribute** is the LDAP Attribute to use as the full name of the
    UCP account.'
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for other more advanced settings. You should also consult
    with you directory services team when configuring LDAP integration.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve configured the LDAP settings, UCP Will search for matching users
    and create them in the UCP user database. It will then perform periodic sync operations
    according to the `Sync Interval (Hours)` setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you checked the `Just-In-Time User Provisioning` box, UCP will defer the
    creation of user accounts until each account’s first logon event.
  prefs: []
  type: TYPE_NORMAL
- en: Before clicking `Save`, you should always perform a test login under the `LDAP
    Test Login` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test login needs to be with a valid user account in the LDAP system you’re
    configuring UCP To use. The test will apply all of the configuration values defined
    in the sections above (the LDAP config you’re about to save).
  prefs: []
  type: TYPE_NORMAL
- en: Only save the configuration if the test login succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Save the configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, UCP will search the LDAP system and create the user accounts
    matching the Base DN and other criteria provided.
  prefs: []
  type: TYPE_NORMAL
- en: Local user accounts created prior to configuring LDAP will still be present
    on the system and can still be used.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Content Trust (DCT)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the modern IT world, *trust* is a big deal! And going forward, it’s going
    to get bigger. Fortunately, Docker implements trust through a feature called Docker
    Content Trust (DCT).
  prefs: []
  type: TYPE_NORMAL
- en: At a very high level, publishers of Docker images can sign their images when
    pushing them to a repo. Consumers can then verify them when they pull them, or
    perform build and run operations. To cut a long story short, DCT enables consumers
    to guarantee they’re getting what they ask for!
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.10 shows the high level architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.10 High level DCT architecture](images/figure17-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.10 High level DCT architecture
  prefs: []
  type: TYPE_NORMAL
- en: DCT implements *client-side* signing and verification operations, meaning the
    Docker client performs them.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s obvious that cryptographic guarantees like this are important when
    pulling and pushing software across the internet, it’s increasingly important
    at every level of the stack and at every step in the software delivery pipeline.
    Hopefully it won’t be long before all aspects of the delivery chain are infused
    with cryptographic trust guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through a quick example of configuring DCT and seeing it in action.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a single Docker client and a repository that you can push an image
    to. A repository on Docker Hub will work.
  prefs: []
  type: TYPE_NORMAL
- en: DCT is turned on and off via the `DOCKER_CONTENT_TRUST` environment variable.
    Setting it to a value of “1” will turn DCT **on** in your current session. Setting
    it to any other value will turn it **off**. The following example will turn it
    on a Linux-based Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`All future `docker push` commands will automatically sign images as part of
    the push operation. Likewise, all `pull`, `build`, and `run` commands will only
    work if the image they are acting on is signed.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s push an image to a repo with a new tag.
  prefs: []
  type: TYPE_NORMAL
- en: The image being pushed can be any image. In fact, the one I’m using is the current
    `alpine:latest` that I just pulled a minute ago. At the moment, it’s not signed
    by me!
  prefs: []
  type: TYPE_NORMAL
- en: Tag the image so it can be pushed to your desired repo. I’m going to push it
    to a new repo within the namespace of my personal Docker Hub account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`*   Login to Docker Hub (or another registry) so you can push the image in
    the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`*   Push the newly tagged image.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: $ docker image pull nigelpoulton/dockerbook:unsigned
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: trust data does not exist `for` docker.io/nigelpoulton/dockerbook:'
  prefs: []
  type: TYPE_NORMAL
- en: notary.docker.io no trust data `for` docker.io/nigelpoulton/dockerbook
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: $ docker image pull --disable-content-trust nigelpoulton/dockerbook:unsigned
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: $ docker container run -d --rm nigelpoulton/dockerbook:unsigned
  prefs: []
  type: TYPE_NORMAL
- en: 'docker: No trust data `for` unsigned.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: $ docker pull alpine:latest
  prefs: []
  type: TYPE_NORMAL
- en: 'latest: Pulling from library/alpine'
  prefs: []
  type: TYPE_NORMAL
- en: 'ff3a5c916c92: Pull `complete`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digest: sha256:7df6...b1c0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: Downloaded newer image `for` alpine:latest'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: $ docker image tag alpine:latest dtr.mydns.com/technology/test:v1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: $ eval "$(<env.sh)"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: $ docker login dtr.mydns.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: nigelpoulton'
  prefs: []
  type: TYPE_NORMAL
- en: 'Password:'
  prefs: []
  type: TYPE_NORMAL
- en: Login Succeeded
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: $ docker image push dtr.mydns.com/technology/test:v1
  prefs: []
  type: TYPE_NORMAL
- en: The push refers to a repository `[`dtr.mydns.com/technology/test`]`
  prefs: []
  type: TYPE_NORMAL
- en: 'cd7100a72410: Pushed'
  prefs: []
  type: TYPE_NORMAL
- en: 'v1: digest: sha256:8c03...acbc size: `528`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12][PRE13]'
  prefs: []
  type: TYPE_NORMAL
