- en: Once Upon a Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding today's date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting date to string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the string into date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting dates to epoch and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving time units from the date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date arithmetics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the difference between two dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the code block periodically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting a certain amount of time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeout long-running operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing the time and date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about time-related tasks and operations. Go concentrates
    all these in the standard package called `time`. With this package, you are able
    to obtain the current time and date, format the date to the string, convert time
    zones, create timers, and create tickers. Keep in mind that there are always many
    ways you can implement and design functionality, and this chapter will show only
    a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Verify whether Go is installed properly. In case of any issues, see the *Retrieving
    Golang version* recipe in [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    With the Environment,* and follow the steps of the *Getting ready* section.
  prefs: []
  type: TYPE_NORMAL
- en: Finding today's date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obtaining the current date is a very common task for any system or application.
    Let's look at how this is done with help of Go's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `today.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run today.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01a225d3-8492-4f44-b48e-6fdef81198ae.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in package `time` contains the function `Now`, which provides the
    instance of a `Time` initialized to the current local time and date.
  prefs: []
  type: TYPE_NORMAL
- en: The `Time` type is an instant in time in nanoseconds. The zero value of `Time`
    is January 1, year 1, 00:00:00.000000000 UTC.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer to the `Time` type should not be used. If only the value (not pointer
    to variable) is used, the `Time` instance is considered to be safe for use across
    multiple goroutines. The only exception is with serialization.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on the `Time` type, see the `time` package documentation
    at: [https://golang.org/pkg/time](https://golang.org/pkg/time).
  prefs: []
  type: TYPE_NORMAL
- en: Formatting date to string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case the textual representation of a time value is needed, usually, certain
    formatting is expected. The `Time` type of the `time` package provides the ability
    to create the `string` output in the given format. There are some rules on how
    to do this and we will cover a few useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `format.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run format.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02ed7afe-9a89-4625-aa04-81a27912fc40.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` type of the `time` package provides the `Format` method for formatting
    the output string.
  prefs: []
  type: TYPE_NORMAL
- en: Go uses the referential time value `Jan 2 15:04:05 2006 MST` to define the formatting
    layout. See the code example for padding options.
  prefs: []
  type: TYPE_NORMAL
- en: The memo for the reference date is that when given in number form, it is represented
    as 1,2,3,4,5,6,-7\. The -7 value means that the MST time zone is 7 hours behind
    the UTC.
  prefs: []
  type: TYPE_NORMAL
- en: The time package includes some predefined formats (for example, `time.Kitchen`);
    you can discover these in the documentation for package constants. ([https://golang.org/pkg/time/#pkg-constants](https://golang.org/pkg/time/#pkg-constants))
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all predefined formats and formatting options, see the documentation for
    the `time` package at: [https://golang.org/pkg/time](https://golang.org/pkg/time).
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the string into date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same concept as the one used in date formatting is also used by date parsing.
    The same reference date and layout principles can be used. This recipe will show
    you how to transform the string input into a `Time` instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `parse.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run parse.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84a97be8-223e-4212-9988-93c0f3e92b6e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `time` package contains the `Parse` function for parsing the string with
    time information.
  prefs: []
  type: TYPE_NORMAL
- en: The format of an incoming date string is given by the referential date, formatted
    to the matching format. Remember that the reference time is `Jan 2 15:04:05 2006
    MST`.
  prefs: []
  type: TYPE_NORMAL
- en: If the given time string does not contain the information about the timezone,
    the result of the `Parse` function will always be in `UTC`.
  prefs: []
  type: TYPE_NORMAL
- en: If the timezone information is provided, then the time is always the time instant
    in the provided timezone.
  prefs: []
  type: TYPE_NORMAL
- en: The `ParseInLocation` function accepts the third argument, which is the location.
    If the time string does not contain any timezone information, then the time is
    parsed to the `Time` instance in given location.
  prefs: []
  type: TYPE_NORMAL
- en: Converting dates to epoch and vice versa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The epoch is the universal system to describe the point in time. The beginning
    of epoch time is defined as `00:00:00 1 Jan 1970 UTC`. The value of epoch is the
    amount of seconds since the timestamp, minus the amount of leap seconds since
    then.
  prefs: []
  type: TYPE_NORMAL
- en: The `time` package and `Time` type provide you with the ability to operate and
    find out the UNIX epoch time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `epoch.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run epoch.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74703915-d328-43b9-9ec7-4bbbc990943a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `time` package contains the `Unix` function which accepts two `int64` arguments,
    and the seconds and nanoseconds of epoch time. This way, you can get the `Time`
    instance from the epoch value.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the epoch value from the `Time` instance, the method with the same
    name as the creation of `Time` from epoch, `Unix`, can be called. There is one
    more method called `UnixNano`, which returns the count of milliseconds instead
    of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving time units from the date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` type also provides the API to retrieve time units from the instance.
    This means you are able to find out what day in a month or what hour in a day
    the instance represents.  This recipe shows how to obtain such units.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `units.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run units.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a18e0d22-8751-42ab-a76e-54b4bf68ead0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` type provides methods to extract time units. The preceding example
    shows the extraction of a weekday, month, and the day of a month. Similarly, the
    hour, seconds, and other units can be extracted.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the units that are not provided by the API directly need to be derived
    from the existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Date arithmetics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` type of the `time` package also allows you to perform basic arithmetic
    on the given date and time. This way, you can find out past and future dates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `arithmetics.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run arithmetics.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4106be0-dec1-4342-908b-44dcd867bcaa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` type of the `time` package provides two essential methods to operate
    on date and time.
  prefs: []
  type: TYPE_NORMAL
- en: The first method, `Add`, accepts the `time.Duration` and `AddDate`. With the `Add`
    method, you can shift the time toward the future with the positive sign and move
    the time backward just by adding the negative sign.
  prefs: []
  type: TYPE_NORMAL
- en: The second method, `AddDate`, consumes the `int64` arguments as the year, month,
    and day, and adds the bigger time amounts.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that `AddDate` normalizes the result, the same as the `time.Date` function.
    Normalization means that adding the month to Aug-31 will result in Oct-1, because
    the following month contains only 30 days (Sep-31 does not exist).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the difference between two dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding the difference between two dates is not an unusual task. For this operation,
    the Go standard package `time`, respectively the `Time` type, provides supporting
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `diff.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run diff.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d05543a-bf46-4d35-9888-f3d353b5722b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Sub` method of the `Time` instance is the universal one to find out the
    difference between two dates. The result is `time.Duration`, which represents
    the nanosecond count between these dates.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the difference exceeds the limit of the maximum/minimum `time.Duration`,
    then the maximum or minimum is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The functions `Since` and `Until` are just a shorter way on how to work out
    the difference between now and the given date. These work as their names prompts.
    The `Since` function returns the same result as `time.Now().Sub(t)`; similarly,
    the `Until` returns the same result as `t.Sub(time.Now())`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Sub` method naturally also counts with time zones. So, the difference is
    returned with respect to the location of each `Time` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with time zones is hard. A good way to handle the different time zones
    is to keep one timezone as referential in the system and convert the others if
    needed. This recipe shows you how the conversion of time between time zones is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `timezones.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run timezones.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06f456c8-8d94-4a35-9f9c-127fc9104f02.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` type provides the `In` method which consumes the pointer to `time.Location`.
    The returned `Time` is the original one converted to the given time zone. Note
    that the `Time` instance is considered to be immutable, so the methods changing
    the instance result in a new `Time` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `time` package refers to the *IANA Time Zone* database as a source of locations.
    The `LoadLocation` function looks for the directory or ZIP file from the `ZONEINFO`
    environment variable. If not found, the known installation locations on UNIX systems
    are searched. Finally, it looks in `$GOROOT/lib/time/zoneinfo.zip`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code block periodically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the date and time operations, the `time` package also provides support
    for periodic and delayed code execution. Typically, the application health checks,
    activity checks, or any periodic job can be implemented this way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `ticker.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run ticker.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait a few seconds, and then press *Ctrl* + *C* to send `SIGINT` a signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c22423f1-d477-4182-8e45-4e9bd9bf34db.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Ticker` holds the `C` channel which delivers the periodical ticks. The
    instance is created with a given interval between ticks. The interval is defined
    by the `time.Duration` value.
  prefs: []
  type: TYPE_NORMAL
- en: The code which is intended to be executed periodically is executed in the goroutine
    in an infinite loop. The reading from the `Ticker` channel blocks the loop until
    the tick is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Note that once the `Ticker` is stopped by calling the `Stop` method, the `C`
    channel is not closed, it just stops delivering the ticks. For this reason, the
    preceding code contains the `select` construct where the stop channel can deliver
    the stop signal. This way, a graceful shutdown can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting a certain amount of time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe describes how to execute the code periodically. This recipe
    will show you how to execute the code with a delay.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `delay.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run delay.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d718e9b-9730-4ca5-bdb7-8942f441d9fb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To execute the code with some delay only once, the `Timer` from the `time` package
    can be used. The concept of how this works is the same as described in the previous recipe, *Running
    the code block periodically*.
  prefs: []
  type: TYPE_NORMAL
- en: The `Timer` contains the `C` channel, which delivers the tick after a given
    time. After that, no other ticks are delivered through the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The same functionality delivers the `AfterFunc` function of the `time` package.
    It just simplifies the usage. Note that there is no channel needed. The sample
    code uses the `sync.WaitGroup` to wait until the given function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `time.After` is the last option in the preceding example. The function returns
    a channel that delivers the tick after a given period. Note the difference between
    the `Timer` and `After` functions. The `Timer` is the reusable structure (it provides
    the `Stop` and `Reset` methods). On the other hand, the `After` function can only
    be used once as it does not provide any reset option.
  prefs: []
  type: TYPE_NORMAL
- en: Timeout long-running operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe describes the concept of executing the code with some delay.
    The same concept can be used to implement the timeout for long running operations.
    This recipe will illustrate how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `timeout.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run timeout.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19a82e55-b388-4e05-a6dd-d69c8bad235b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The timeout for the long-running operation in the previous code is implemented
    with the use of the `time.After` function, which provides the channel delivering
    the tick after the given period.
  prefs: []
  type: TYPE_NORMAL
- en: The operation itself is wrapped to select a statement which chooses between
    the `time.After` channel and the default option, which executes the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you need to allow the code to read from the `time.After` channel periodically
    to find out whether the timeout is exceeded or not. Otherwise, if the default
    code branch blocks the execution entirely, there is no way how to find out if
    the timeout has already elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example implementation uses the `time.After` function, but the `Timer` function
    can also be used in the same way. The built-in libraries also use the `context.WithTimeout` to
    implement timeout functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing the time and date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When serializing the date and time information, it is necessary to choose the
    proper format. This recipe will illustrate how the `time` package helps to choose
    one and do the serialization properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter04/recipe12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `serialize.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run serialize.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '>![](img/2ec429f9-a46c-45ee-871b-de8aaadbd171.png)'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Time` function implements the interfaces for Binary, Gob, and JSON serialization.
    The JSON format is considered to be very universal, so an example on how the value
    is serialized to JSON is shown. Note that the `Time` function serializes the value
    in the manner of RFC 3339 ([https://www.ietf.org/rfc/rfc3339.txt](https://www.ietf.org/rfc/rfc3339.txt)),
    which proposes a so-called internet date/time format.
  prefs: []
  type: TYPE_NORMAL
- en: Another very universal way to serialize/keep the time is to use the epoch time.
    The epoch time is independent of timezones because it is defined by seconds/nanoseconds
    elapsed since an absolute point in time. Finally, it is represented as a number
    so there is no reason to serialize and deserialize the value.
  prefs: []
  type: TYPE_NORMAL
