- en: Chapter 3. Data Structures and Communicating Protocol in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter dealt with installation of Redis and running some simple
    programs. Since Redis is a datastore, so it's important to understand how Redis
    treats data by providing data structures to handle and store them. Also important
    is how Redis deals with data while communicating it to a client such as the communication
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structure, as the word suggests, means a structure for storing data. In
    the world of computing, data is always organized in a way that makes sense to
    the program storing it. Data structure can vary from a simple sequential arrangement
    of characters to a complex map where keys are not arranged sequentially, but on
    the basis of an algorithm. Data structures are often composite in nature, which
    means that one data structure can hold other data structure, which is a map holding
    another map.
  prefs: []
  type: TYPE_NORMAL
- en: The key influencing factors in designing a data structure are performance and
    memory management of the data structure. Some of the common examples of data structures
    are lists, sets, maps, graphs and trees, tuples, and so on. As programmers, we
    have used data structures in our programs time and again. In an object-oriented
    world, a simple *object* is also a data structure since it contains data, and
    logic to access those data. Every data structure is governed by an algorithm which
    decides the efficiency and functional capability of it. So, if the algorithm can
    be classified then it would give a clear idea on the performance of data structure;
    when data is pumped into the data structure or when data is read or when data
    is deleted from the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Big O notation is a means to classify the algorithm (data structure) on its
    performance when the data grows. From Redis perspective, we will be classifying
    the data structure on the basis of these following notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`O (1)`: Time taken by the command on a data structure is constant irrespective
    of the amount of data it contains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O (N)`: Time taken by the command on a data structure scales linearly on the
    amount of data it contains, where `N` is the number of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O (log (N))`: Time taken by the command on a data structure is logarithmic
    in nature, where `N` is the number of elements. Algorithms exhibiting this are
    highly efficient and used to find elements in sorted arrays. This can be interpreted
    to be fairly constant with time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O (log (N) + M)`: Time taken by the command is dependent on logarithmic value,
    where `M` is the total number of elements in the sorted sets and `N` is the range
    from which the search has to find. This can be interpreted to be fairly dependent
    on the value of `M`. With increase in the value of `M,` time taken for search
    would increase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O (M log (M))`: Time taken by the command is log-linear in nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis, a data structure server has many in-built data types, which makes it
    a bit different from other key-value NoSQL datastores in the ecosystem. Unlike
    other NoSQL, Redis provides the users with many in-built data types which provide
    a sematic way of arranging their data. Think of it like this; while designing
    a solution we need domain objects which in a way shape up our data layer. After
    deciding on the domain objects, we need to design the structure for our data that
    will be saved in the data store for which we need some predefined data structures.
    The advantage of this is that it saves time and efforts of the programmers to
    externally create and manage this data. For example, suppose in our program there
    is a requirement for a Set like data structure. Using Java, we can easily use
    an in-built data structure such as Set. If we were to put this data as a key-value,
    we will have to put the entire set against a key. Now if we were to sort this
    Set, the normal way would be to extract the data out and programmatically sort
    the data, which can be cumbersome. It would be good if the data store itself gives
    a mechanism to sort the data internally. Redis has the following data types built
    into it for storing data:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure represents the data types that can be mapped to a key.
    The key itself is of type string in Redis and the values it can store can be any
    one of them as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data types in Redis](img/1794_0123OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of key and the values it can store
  prefs: []
  type: TYPE_NORMAL
- en: The string data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**String** types are the basic data types in Redis. Though misleading in terminology,
    string in Redis can be considered as a byte array which can hold string, integers,
    images, files, and serializable objects in them. These byte arrays are binary
    safe in nature and the maximum size they can hold is 512 MB. In Redis, strings
    are called **Simple Dynamic String** (**SDS**), which in C language is implemented
    as `Char` array with some other attributes, such as `len` and `free`. These strings
    are binary safe too. The SDS header file is defined in `sds.h` file as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So any string, integer, bitmap, image files, and so on, in Redis are stored
    in `buf[]` (`Char` array), the `len` stores the length of the buffer array, and
    `free` stores additional bytes for storage. Redis has an in-built mechanism to
    detect the type of data stored in the array. More information on this can be found
    at [http://redis.io/topics/internals-sds](http://redis.io/topics/internals-sds).
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands in Redis for the string can be categorized in the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters and getters commands**: These are the commands that can be used to
    set or get values in Redis. There are commands for single key-value as well as
    multiple key-values. For single get and set, following commands can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get` key: This key gets the value for a key. Time-based performance for this
    command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set` key: This key sets a value against a key. Time-based performance for
    this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SETNX` key: This key sets a value against a key if key doesn''t exist - no
    overwrite is done. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GETSET` key: This key gets the old value and sets a new value. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MGET key1` key: This key gets all the corresponding values of keys. Time-based
    performance for this command is `O (N)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSET` key: This key sets all the corresponding values of keys. Time-based
    performance for this command is `O (N)`, where `N` is the number of keys to be
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSETNX` key: This sets all the corresponding values of keys if all the don''t
    keys exist, that is if one key exists then no values are set. Time-based performance
    for this command is `O (N)`, where `N` is the number of keys to be set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data clean commands**: These are the commands that can be used for managing
    the lifecycle of a value. By default, the values for the key do not have an expiry
    time. However, if you have a use case where values need to have life duration,
    then use the following keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET PX/ EX`: Removes the values and the key gets expired after expiry time
    in milliseconds. Time based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SETEX`: Removes the values and the key gets expired after the expiry time
    in seconds. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility commands**: Following are some of these commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APPEND`: This command appends to the existing value or sets if it does not
    exist. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STRLEN`: This command returns the length of the value stored as string. Time-based
    performance for this command is `O (1).`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SETRANGE`: This command overwrites the string at the given offset. Time-based
    performance for this command is `O (1)`, provided the length of the new string
    does not take long time to copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GETRANGE`: This command gets the substring value from the given offsets. Time-based
    performance for this command is `O (1)`, provided the length of the new substring
    is not too big.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample program to demonstrate the simple usage of commands for a string is
    given as follows. Execute the program and analyze the result yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands in Redis for the integer and float can be categorized in the following
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters and getters commands**: The set of commands is same as what is mentioned
    for string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data clean commands**: The set of commands is same as what is mentioned for
    string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility commands**: The commands here will help to manipulate the integer
    and float values. For integers, this operation is limited to 64 bit signed integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APPEND**: This will concatenate the existing integer with the new integer.
    Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DECR**: This will decrement the value by one. Time-based performance for
    this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DECRBY**: This will decrement the value by the given value. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INCR**: This will increment the value by one. Time-based performance for
    this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INCRBY**: This will increment the value by the given value. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INCRBYFLOAT**: This will increment the value by the given floating value.
    Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from regular number, string, and so on, string data type can store a special
    type of data structure called **BitSet** or **bitmap.** Let's learn a bit more
    about them and see their usage.
  prefs: []
  type: TYPE_NORMAL
- en: The BitSet or bitmap data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are special space-efficient types of data structure used to store special
    kind of information. Bitmaps are specially used for real-time analytics work.
    Though bitmap can only store values in binary (1 or 0) but the fact that they
    consume less space and the performance for getting value is `O (1)`, makes them
    very attractive for real-time analytics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The BitSet or bitmap data type](img/1794_0123OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of Bitmap
  prefs: []
  type: TYPE_NORMAL
- en: The key can be any date-based key. Let's say that the key here represents the
    bitmap about the users who purchased a book on December 12, 2014.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `12/12/2014-user_purchased_book_learning_redis`. Offset here represents
    a unique integer ID associated with a user. Here we have users associated with
    number 0, 1, 2...n and so on. Whenever a user makes a purchase, we find the corresponding
    unique ID of the user, and at that offset position, change the value to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following questions can be answered with the help of this space optimizing,
    high performance bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: How many purchases were made on December 12, 2014?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Answer: Count the number of 1 in the bitmap, which is the number of users who
    made the purchase, say 9.'
  prefs: []
  type: TYPE_NORMAL
- en: Did user associated with ID (offset number) 15 make a purchase?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Answer: The value at offset 15 is 0, so the user did not make a purchase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Collection of these bitmaps can be used in union to find answers to more complicated
    analytics. Let''s add another bitmap to an existing sample and let''s call it
    `12/12/2014-user_browsed_book_learning_redis`, for example. Using these two bitmaps,
    we can find answers to the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How many users browsed the product (*Learning Redis*) page?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many users purchased the product (*Learning Redis*) page?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many users who browsed the product page purchased the book?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many users who did not browse the product page purchased the book?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis string can be used to store object IDs. For example, session ID, configuration
    values as XML, JSON, and so on. Redis string (storing integer) can be used as
    atomic counters. Redis string (storing bitmaps) can be used as real-time analytics
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: The Hashes data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hashes are Redis version of what a map would do in Java. Hashes in Redis are
    used to store map of attributes and their values against a key. To understand
    it better, let''s say we have an object called *Learning Redis*; this object will
    have many properties, such as author, publisher, ISBN number, and so on. To represent
    this in a storage system, we can store the information as XML, JSON against our
    key *Learning Redis*. If we require some particular value, for example, author
    stored against *Learning Redis*, then the entire dataset has to be retrieved and
    required value has to be filtered out. Doing work this way will not be efficient
    because lot of data needs to travel via network, and the processing at the client
    side would increase. Redis provides hashes data structures which can be used for
    storing such kinds of data. The following figure give a diagrammatic representation
    of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Hashes data type](img/1794_0123OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The HAshes data types
  prefs: []
  type: TYPE_NORMAL
- en: Hashes are stored in such a way that they take up less space and each Hash in
    Redis can store up to 2^(32)–one field-value pairs, that is more than 4 billion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands in Hashes start with `H` and the commands in Redis for the Hashes
    can be categorized in the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters and getters commands**: Following are the commands for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HGET`: This command gets the value of a field for a key. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HGETALL`: This command gets all the values and fields for a key. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HSET`: This command sets the value of a field for a key. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HMGET`: This command gets the values for the fields for a key. Time-based
    performance for this command is `O (N),` where `N` is the number of fields. However,
    it''s `O (1)` if `N` is small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HMSET`: This command sets multiple values for respective fields for a key.
    Time-based performance for this command is `O (N),` where `N` is the number of
    fields. However, it''s `O (1)` if `N` is small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HVALS`: This command gets all the values in the Hash for the key. Time-based
    performance for this command is `O (N),` where `N` is the number of fields. However,
    it''s `O (1)` if N is small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HSETNX`: This command sets the value against the field for the key provided
    the field does not exist. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEYS`: This command gets all the fields in the Hash for the key. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data clean commands**: Following is the command for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HDEL`: This command deletes the fields for a key. Time-based performance for
    this command is `O (N),` where `N` is the number of fields. However, it''s `O
    (1)` if `N` is small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility commands**: Following are the commands for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEXISTS`: This command checks for the existence of a field for a key. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HINCRBY`: This command increments the value (provided the value is an integer)
    of a field for a key. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HINCRBYFLOAT`: This command increments the value (provided the value is a
    float) of a field for a key. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HLEN`: This command gets the number of fields for the key. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample program to demonstrate the simple usage of commands for Hashes is given
    as follows. Execute the program and analyze the result yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Use case scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hashes provide a sematic interface to store simple and complex data objects
    in the Redis server. For example, user profile, product catalogue, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Lists data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis lists are similar to what linked lists are in Java. This Redis list can
    have elements added to the head or tail. The performance of doing that is constant
    or can be expressed as `O (1)`. What it means is that suppose you have a list
    with 100 elements, the time taken to add elements to the list is equal to the
    time taken to add elements to a list of 10,000 elements. But on the flip side,
    accessing elements in the Redis list would result in the scanning of the entire
    list which means that the performance degrades if the number of items in the list
    is high.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the Redis list getting implemented as a linked list rather
    than an array list is because Redis list as a data type was designed to have faster
    writes than reads (a trait shown by all data stores).
  prefs: []
  type: TYPE_NORMAL
- en: '![The Lists data type](img/1794_0123OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Lists Data types
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands in Redis for the lists normally start with `L`. This can also
    be interpreted that all the commands will execute from *Left or head of the list*,
    and where the commands are executed from *Right or tail of the list*, they start
    with R. The commands can be categorized in the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters and getters commands**: Following are the examples for this type
    of commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LPUSH`: This command prepends the values to the list from the left of the
    list. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPUSH`: This command prepends the values to the list from the right of the
    list. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LPUSHX`: This command prepends the values to the list from the left of the
    list if the key exists. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPUSHX`: This command prepends the values to the list from the right of the
    list if the key exists. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINSERT`: This command inserts a value in the list after the *pivot* position.
    This pivot position is calculated from the left. Time-based performance for this
    command is `O (N)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LSET`: This command sets the value of an element in a list based on the index
    mentioned. Time-based performance for this command is `O (N)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LRANGE`: This command gets the sub list of elements based on the start index
    and the end index. Time-based performance for this command is *O (S+N)*. Here
    *S* is the start of the offset and *N* is the number of elements we are asking
    for in the list. What this means is that the time taken to find the element will
    increase if the offset is farther away from the head and the length of the range
    is higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data clean commands**: Following are the example of this type of commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LTRIM`: This command deletes the elements outside the range specified. Time-based
    performance for this command is `O (N)`. Here `N` is the length of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPOP`: This command removes the last element. Time-based performance for this
    command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LREM`: This command removes the element at the index point specified. Time-based
    performance for this command is `O (N)`. Here `N` is the length of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LPOP`: This command removes the first element of the list. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility commands**: Following are the commands that come under this type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINDEX`: This command gets the element from the list based on the index mentioned.
    Time-based performance for this command is `O (N)`. Here `N` is the number of
    elements it has to traverse to reach the element at the desired index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LLEN`: This command gets the length of the list. Time-based performance for
    this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced command**: Following commands come under this type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLPOP`: This command gives the element from the index, which is nonempty,
    in the sequence of lists mentioned or blocks the call if there is no value in
    the head till the time at least a value is set or timeout occurs. The alphabet
    `B` in `BLPOP` hints this call to be blocking. Time-based performance for this
    command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BRPOP`: This command gives the element from the trail which is nonempty in
    the sequence of lists mentioned or blocks the call if there is no value in the
    head till the time at least a value is set or timeout occurs. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPOPLPUSH`: This command operates on two lists. Let''s say source list and
    destination list, where it will take the last element on the source list and push
    it to the first element of the destination list. Time-based performance for this
    command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BRPOPLPUSH`: This command is the *blocking* variety of the `RPOPLPUSH` command.
    In this, if the source list is empty then Redis will block the operation until
    a value is pushed into the list or a timeout is reached. These commands can be
    used to create queues. Time-based performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample program to demonstrate the simple usage of commands for lists is given
    as follows. Execute the program and analyze the result yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Use case scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: List provides with a sematic interface to store data sequentially in a Redis
    server where the *write* speeds are more desirable than *read* performance. For
    example, log messages.
  prefs: []
  type: TYPE_NORMAL
- en: The Sets data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis Sets are data structures that are an unordered collection of SDS. The
    values in Sets are unique and cannot have duplicate value. One of the interesting
    aspects in terms of performance of Redis Sets is that they show constant timing
    for adding, removing, and checking for existence of an element. The maximum number
    of entries that can be in a Set is 2^32,–that is 4 billion per Set. These Set
    values are unordered in nature. From the look of it, Sets might look like lists,
    but then they have a different implementation, which makes them perfect candidates
    for solving problems around Set theory.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Sets data type](img/1794_0123OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Sets data types
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands in Redis for the Sets can be categorized in the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters and getters commands**: This type includes the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SADD`: This command adds one or more elements to the Set. Time-based performance
    for this command is `O (N)`. Here `N` is the number of elements that needs to
    be added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data clean commands**: Following are some commands that come under this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPOP`: This command removes and returns a random element from the set. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SREM`: This command removes and returns the specified elements from the set.
    Time-based performance for this command is `O (N)`.Here `N` is the number of elements
    to be removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility Commands**: Following are the commands that come under this type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCARD`: This command gets the number of elements in a Set. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDIFF`: This command gets the list of elements from the first set after subtracting
    its elements from the other mentioned sets. Time-based performance for this command
    is `O (N)`. Here `N` is the number of elements in all the sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDIFFSTORE`: This command gets the list of elements from the first set after
    subtracting its elements from the other mentioned sets. This set is pushed into
    another Set. Time-based performance for this command is `O (N)`. Here `N` is the
    number of elements in all the sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SINTER`: This command gets the common elements in all the sets mentioned.
    Time-based performance for this command is `O (N * M)`. Here `N` is the cardinality
    of the smallest set and `M` is the number of sets. What basically is happening
    here is that Redis will take the smallest set and look for common elements between
    this set and other sets. The resultant sets are again compared for common elements,
    such as the preceding process, until only one set remains with the desired result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SINTERSTORE`: This command works in the same way as command `SINTER` but here
    the result is stored in a mentioned set. Time-based performance for this command
    is `O (N * M)`. Here `N` is the cardinality of the smallest set and `M` is the
    number of sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SISMEMBER`: This command finds if the value is a member of set. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SMOVE`: This command moves members from one set to another set. Time-based
    performance for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRANDMEMBER`: This command gets one or multiple random members from the set.
    Time-based performance for this command is `O (N)`. Here `N` is the number of
    members passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUNION`: This command adds multiple sets. Time-based performance for this
    command is `O (N)`. Here `N` is the number of elements in all the sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUNIONSTORE`: This command adds multiple sets and stores the result in a set.
    Time-based performance for this command is `O (N)`. Here `N` is the number of
    elements in all the sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample program to demonstrate the simple usage of commands for sets is given
    as follows. Execute the program and analyze the result yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use case scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets provides with a sematic interface to store data as a set in Redis server.
    The use cases for this kind of data would be more for an analytics purpose, for
    example how many people browse the product page and how many end up purchasing
    the product.
  prefs: []
  type: TYPE_NORMAL
- en: The Sorted Sets data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redis Sorted Sets are very much like Redis Sets in the way that they don''t
    store duplicate values, but the area where they differ from Redis Sets is that
    the values are sorted on the basis of a score, or integer, float values. These
    values are provided while setting a value in the Set. The performance of these
    Sorted Sets is proportional to the logarithm of the number of elements. The data
    is always kept in a sorted way. This concept is diagrammatically explained in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Sorted Sets data type](img/1794_0123OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The concept of Sorted Sets
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands in Redis for the Sorted Sets can be categorized in the following
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters and getters commands**: Following are the commands that come under
    this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZADD`: This command adds or updates one or more members to a Sorted Set. Time-based
    performance for this command is `O (log (N))`. Here `N` is the number of elements
    in the Sorted Sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZRANGE`: This command gets the specified range by rank of elements in the
    Sorted Set. Time-based performance for this command is *O (log (N) +M)*. Here
    `N` is the number of elements and `M` is the number of elements returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZRANGEBYSCORE`: This command gets elements from the Sorted Sets within the
    range by score given. The values in the default Set are ascending by nature. Time-based
    performance for this command is `O (log (N) +M)`. Here `N` is the number of elements
    and `M` is the number of elements returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZREVRANGEBYSCORE`: This command gets elements from the Sorted Sets within
    the score given. Time-based performance for this command is `O (log (N) +M)`.
    Here `N` is the number of elements and `M` is the number of elements removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZREVRANK`: This command returns the rank of the member in the Sorted Set.
    Time-based performance for this command is `O (log (N))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZREVRANGE`: This command returns the specified range of elements in the Sorted
    Set. Time-based performance for this command is `O (log (N) + M)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data clean commands**: Following are the commands that come under this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZREM`: This command removes the specified members in the Sorted Set. Time-based
    performance for this command is `O (M*log (N))`. Here `M` is number of elements
    removed and `N` is the number of elements in the Sorted Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZREMRANGEBYRANK`: This command removes the members in a Sorted Set within
    the given indexes. Time-based performance for this command is `O (log (N) * M)`.
    Here `N` is the number of elements and `M` is the number of elements removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZREMRANGEBYSCORE`: This command removes the members in a Sorted Set within
    the given scores. Time-based performance for this command is `O (log (N) * M)`.
    Here `N` is the number of elements and `M` is the number of elements removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility commands**: Following are the commands that come under this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZCARD`: This command gets the number of members in a Sorted Set. Time-based
    performance for this command is `O (1))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZCOUNT`: This command gets the number of members in a Sorted Set within the
    score boundaries. Time-based performance for this command is `O (log (N) * M)`.
    Here `N` is the number of elements and `M` is the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZINCRBY`: This command increases the score of an element in the Sorted Set.
    Time-based performance for this command is `O (log (N))`. Here `N` is the number
    of elements in the Sorted Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZINTERSTORE`: This command calculates the common elements in the Sorted Sets
    given by the specified keys, and stores the result in destination Sorted Set.
    Time based performance for this command is `O (N*K) + O (M*log (M))`. Here `N`
    is the smallest Sorted Set, `K` is the number of input Set, and `M` is the number
    of elements in the result Sorted Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZRANK`: This command gets the index of the element in the Sorted Set. Time-based
    performance for this command is `O (log (N))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZSCORE`: This command returns the score of the member. Time-based performance
    for this command is `O (1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZUNIONSTORE`: This command computes the union of keys in the given Sorted
    Set and stores the result in the resultant Sorted Set. Time-based performance
    for this command is `O (N) +O (M log (M))`. Here `N` is the sum of sizes of input
    Sorted Set and `M` is the number of elements in the Sorted Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample program to demonstrate the simple usage of commands for Sorted Sets
    is given as follows. Execute the program and analyze the result yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Use case scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sorted Sets provide with a sematic interface to store data as a Sorted Set in
    Redis server. The use cases for this kind of data would be more in analytics purpose
    and in the gaming world. For example, how many people played a particular game
    and categorizing them on the basis of their score.
  prefs: []
  type: TYPE_NORMAL
- en: Communication protocol – RESP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis in principle works on a client-server model. So like in every client-server
    model, the client and the server need to have a protocol to communicate with.
    Communication protocol can be understood as a message exchange taking place between
    client and the server (and vice versa) based on some fixed agreement or rule between
    them. So every communication protocol has to adhere to some syntax and semantics,
    which should be followed by both the parties (client and server) for the communication
    to be successful. There is also another dimension to this communication protocol,
    which is the network layer interaction, or better known as TCP/IP Model. The TCP/IP
    Model can be divided into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the communication protocol between two applications is at application
    layer, so we intend to focus only on the application layer. The following diagram
    is a representation of what happens in the communication protocol level at application
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication protocol – RESP](img/1794_0123OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of communication protocol at application layer
  prefs: []
  type: TYPE_NORMAL
- en: In any application protocol, we will have a header and body. The header will
    contain Meta information about the protocol, that is protocol name, version, security
    related details, Meta information about the request (number of arguments, type
    of arguments), and so on, and the body will contain the actual data. The first
    thing any server will do is to parse the header information. If the header gets
    successfully parsed, then only rest of the body gets processed. In a way, the
    server and the client need to have a pipe-like architecture to process header
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol used for Redis is fairly simple to understand. This section will
    focus on the communication protocol used in Redis. By the end of this section,
    we would have understood the protocol and created a client that connects to Redis
    server, sends the request, and gets the response from the server. Like in any
    other protocol, the Redis protocol also has a header (Meta information) and a
    body part (request data). The request data part consists of information such as
    command and command data. In response, it will contain parts such as Meta information
    (if the request was a success or failure) and actual response data payload. The
    following explains this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication protocol – RESP](img/1794_0123OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of Meta information and request data
  prefs: []
  type: TYPE_NORMAL
- en: 'Any request in Redis basically constitutes of two parts, and they are discussed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Meta information about the request, say, **Number of arguments**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body part will further have three more pieces of information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of bytes for every argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Carriage Return and Line Feeds** (**CRLF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Communication protocol – RESP](img/1794_0123OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of the body part of a request
  prefs: []
  type: TYPE_NORMAL
- en: So the information that we will hold in the Meta information will be two, since
    this is the number of the arguments we will be passing as indicative, as shown
    in the preceding figure. In the body part, we will capture information, such as
    what is the number of bytes of argument we are sending, that is if the name of
    the argument is `GET`, then the number of bytes would be `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response in Redis can be segregated into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Response for commands which will go and add or manipulate data (no return value
    is expected):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+` sign suggesting the request was success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` sign suggesting the request was failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Response for commands which will go and fetch data (string type return value
    is expected):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$-1` will be the response if error is the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` and the size of the response if the response is a success followed by the
    actual string data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an exercise, let''s make a small test client in Java code and record our
    interactions with the Redis server. The client is just a sample to educate on
    the Redis protocol and does not intend to replace the client we will use in the
    book, that is Jedis. Let''s get a brief overview of the classes participating
    in the small test client. For starters, from a design patterns perspective, we
    will be using command pattern for this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Command`: This class is the abstract class and all the command classes will
    be extended from this class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetCommand`: This is the class which will fetch the string value for the key
    given and print the server response and response values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetCommand`: This is the class which will set the key and the value data for
    the command and print the server response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionProperties`: This is the interface which will hold the host and
    the port address. (This is going to behave more like a properties file.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestClient`: This is the class that is going to call all the commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the domain diagram for the simple test client application. Here
    the command objects are doing the bulk of the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication protocol – RESP](img/1794_0123OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Domain diagram for a simple client application
  prefs: []
  type: TYPE_NORMAL
- en: 'A look into the code will give more idea and clarity about the simple test
    client for Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConnectionProperties.java`: This is the class that will hold the configuration
    value for the host and the port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`TestClient.java`: As shown, this is the client which will execute the commands
    for setting the value and fetching the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes right, following is the message that you should see in your
    console. Please remember this is a successful operation and your console should
    look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication protocol – RESP](img/1794_0123OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here in this sample, we executed two commands consecutively:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetCommand`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetCommand`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of `SetCommand` is `+OK`. The `+` sign indicates that the server
    has returned a success result followed by the message `OK`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of `GetCommand` is a multi line result. The first line is a string
    `$32`, which means the size of the result is 32 bytes long, followed by the result
    `Hello world : simple test client`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s attempt to pass a key that does not exist in the `Get` command.
    The code snippet will look something like shown next (key passed in `wrong-key`,
    which does not exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code should look something like the `$-1` command.
    Here the return value is null since the key does not exist. So the length is `-1`.
    Going forward, we will wrap this message with something more human readable, like
    `This key does not exist!` Following are some of the classes discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Command.java`: This is the abstract class to which all the commands would
    extend to. This class has the responsibility to instantiate a socket for the implementing
    commands and create a proper payload to be sent to the Redis server. Understanding
    this will give us a hint of how actually the Redis server accepts requests.![Communication
    protocol – RESP](img/1794_0123OS_03_12.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representation of Command.java
  prefs: []
  type: TYPE_NORMAL
- en: 'The first character is the `*` character followed by **number of arguments**
    that we will pass. This means that if we intend to do a **Set** command, that
    is **SET MSG Hello** `,` then the total number of arguments is three here. If
    we intend to pass a **Get** command such as **GET MSG,** then the number of arguments
    is two. Followed by the number of arguments, we will use **CRLF** as a separator.
    The subsequent messages will follow a pattern which will get repeated. The pattern
    is very simple to understand, that is **$** followed by the length of the argument
    in bytes followed by **CRLF** followed by argument itself. If we have more arguments,
    then the same pattern is followed, but then they are separated by CRLF separator.
    Following is the code for `Command.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code is simple to understand and it does preparation and formatting of the
    message payload. The `Command` class has two methods that are abstract and need
    to be implemented by the implementing command. Apart from this, `Command` class
    creates a new socket based on the properties set in `ConnectionProperties.java`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetCommand.java`: This is the class that implements the `GET KEY` command.
    The class extends the `Command.java`. Following is the source code for `GetCommand`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The implementing class does two things in principle. First it passes the argument
    array with a proper value to the super class, which formats it the way Redis will
    understand, and then, it sends the payload to the Redis server and prints the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '`SetCommand`: This is similar to the previous command but in this, we will
    be setting the value. The class will extend the `Command.java` class. Following
    is the source code for `SetCommand`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command is similar to the previous command in that it does two things in
    principle. First it passes the argument array in with a proper value to the super
    class, which formats it the way Redis will understand, and it then, passes the
    payload to the Redis server and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: Have fun compiling the program and running it; add more commands and extend
    it to suit your business requirements. I would strongly recommend using Jedis
    as it is stable, its community is very active, and it provides implementation
    for newer commands getting introduced with newer versions of Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we brushed with various data structures or data types which
    Redis provides. We also wrote a few programs to see them working and made an attempt
    to understand how and where these data types can be used. Finally, we understood
    how Redis communicates with the clients and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our understanding a notch higher and make
    an attempt to understand Redis Server and the functionality that'll handle it.
  prefs: []
  type: TYPE_NORMAL
