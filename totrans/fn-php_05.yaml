- en: Chapter 5.  Functors, Applicatives, and Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced the first real functional techniques, such as
    function composition and currying. In this chapter, we will delve into more theoretical
    concepts again by presenting the concept of monads. There won't be a lot of practical
    application as we have a lot of ground to cover. However, [Chapter 6](ch06.html
    "Chapter 6.  Real-Life Monads"), *Real-life Monads* will use everything we learn
    here to solve real issues.
  prefs: []
  type: TYPE_NORMAL
- en: You might already have heard the term **monad**. Usually, it is associated with
    a sense of dread by non functional programmers. Monads are usually described as
    hard to understand despite countless tutorials on the subject. The fact is, they
    are hard to understand and people writing those tutorials often forget how much
    time it took them to understand the idea correctly. This is a common pedagogic
    pitfall, probably much better described in this article at [https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/).
  prefs: []
  type: TYPE_NORMAL
- en: You will probably not get everything the first time. Monads are a highly abstract
    concept and, even if the topic seems clear to you at the end of the chapter, you
    will probably stumble upon something later on that will baffle your intuition
    of what a monad really is.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will try to do my best to explain things clearly, but if you find my explanations
    lacking, I added references to other material about the topic in the *Further
    reading* section at the end of this chapter. In this chapter, we will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functors and related laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicative functors and related laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids and related laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads and related laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be a lot of theoretical content only with implementation of the concepts.
    Don't expect a lot of examples until [Chapter 6](ch06.html "Chapter 6.  Real-Life
    Monads"), *Real-life Monads*.
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before speaking directly of monads, let us start at the beginning. In order
    to understand what a monad is, we need to introduce a few related concepts. The
    first one is functors.
  prefs: []
  type: TYPE_NORMAL
- en: To complicate matters a bit, the term **functor** is used in imperative programming
    to describe a function object, which is something totally different. In PHP, an
    object with the `__invoke` method, as we saw in [Chapter 1](ch01.html "Chapter 1. Functions
    as First Class Citizens in PHP"), *Functions as First Class Citizens*, is such
    a function object.
  prefs: []
  type: TYPE_NORMAL
- en: However, in functional programming, a functor is a concept taken and adapted
    from the mathematical field of category theory. Details aren't that important
    for our purpose; it suffice it to say that a functor is a pattern allowing us
    to map a function to one or more values contained in a context. Also, in order
    for the definition to be as complete as possible, our functor must respect some
    laws, which we will describe and verify later.
  prefs: []
  type: TYPE_NORMAL
- en: We have already used map multiple times on collections, which makes them de
    facto functors. But if you remember correctly, we also named our method to apply
    a function to the value contained in Maybe in the same way. The reason is that
    functors can be seen as containers with a means to apply a function to the contained
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sense, any class that implements the following interface could be called
    a `Functor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, describing it like that is a bit reductive. A simple PHP array is also
    a functor (because the `array_map` function exists), as is anything implementing
    the `Traversable` interface as soon as you use the `functional-php` library and
    its map function.
  prefs: []
  type: TYPE_NORMAL
- en: Why such a fuss for such a simple idea? Because, although the idea is simple
    in itself, it allows us to reason about what is happening in a different light
    and possibly helps understand and refactor the code.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `map` function can do much more than blindly apply the given `callable`
    type, as is the case with an array. If you remember our `Maybe` type implementation,
    in the case of a value `Nothing`, the `map` function simply kept returning the
    `Nothing` value in order to allow for a simpler management of null values.
  prefs: []
  type: TYPE_NORMAL
- en: We could also imagine having much more complicated data structures in our functors,
    such as trees, where the function given to the `map` function is applied to all
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Functors allow us to share a common interface, our `map` method or function,
    to perform a similar operation on a variety of data types while hiding the complexity
    of the implementation. As often with functional programming, the cognitive burden
    is reduced because you don't have multiple names for an identical operation. Function
    and method names such as "apply", "perform", and "walk" are often seen to describe
    the same thing for example.
  prefs: []
  type: TYPE_NORMAL
- en: Identity function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final concern is the two functor laws that come with the concept. But before
    introducing them, we need to take a small detour about the identity function,
    or often `id`. It is a really simple function that simply returns its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Why would anyone need a function doing as little as this? First of all, we will
    need it later to prove the laws of the various abstractions presented in this
    chapter. But real-world applications also exist.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you are doing a fold with numbers, say summing them, you will
    use the initial value `0`. The `id` function will have the same role when folding
    over functions. As a matter of fact, the compose function is implemented using
    the `id` function in the `functional-php` library.
  prefs: []
  type: TYPE_NORMAL
- en: Another use might be some function from another library that performs an operation
    you are interested in, but also calls a callback on the resulting data. If the
    callback is mandatory, but you don't want to do anything else to your data, just
    pass `id` and you will get them unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our new function to declare a property of our `compose` function
    for any function `f`, taking only one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What this basically says is that, if you first apply the argument `id` then
    `f`, you will get the exact same result as when first applying `f` and then `id`.
    At this point, this should be evident to you. If not, I encourage you to revisit
    the last chapter until you clearly understand why this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: Functor laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our identity function covered, let''s get back to our laws.
    They are important for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They give us a set of constraints to guarantee the validity of our functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow us to perform refactoring that is proven correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without further ado, here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*map(id) == id*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*compose(map(f), map(g)) == map(compose(f, g))*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first law states that mapping the `id` function on the contained value is
    exactly the same as calling the `id` function directly on the functor itself.
    When this law holds, this guarantees us that our map function only applies the
    given function to the data without performing any other kind of treatment.
  prefs: []
  type: TYPE_NORMAL
- en: The second law states that first mapping the `f` function then the g one on
    our value is the same as first composing `f` and `g` together and then mapping
    the resulting function. Knowing this, we can perform all kinds of optimization.
    For example, instead of looping three times over our data for three different
    methods, we can compose them together and perform only one loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can imagine not everything being crystal clear for you right now, so instead
    of wasting time trying to explain them further, let''s verify if they hold for
    the `array_map` method. This will probably help you to get the gist of it; the
    following code expects the `id` function defined previously to be in scope :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The composition is performed manually; as in my opinion resorting to currying
    here would only have made things more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, both laws hold for the `array_map` method, which is a good sign
    because it means there is no hidden data processing done in the shadow and we
    can avoid looping two or more times on our array when only once is enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try the same with our `Maybe` type defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to switch to a non-strict equality for the `$just` case because we would
    have a result of false otherwise as PHP compares object instances and not their
    values. A `Maybe` type wraps the resulting value in a new object and PHP only
    performs internal value comparison in the case of a non-strict equality; the`add2`,
    `times10`, and `composed` functions defined above are expected to be in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great, our `Maybe` type implementation is a valid functor.
  prefs: []
  type: TYPE_NORMAL
- en: Identity functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed in the section about the identity function, an identity functor
    also exists. It acts as a really simple functor that does nothing to the value
    besides holding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with the identity function, the use for such a functor is not immediately
    evident. However, the idea is the same-you can use it when you have some function
    having a functor as a parameter, but you don't want to modify your actual value.
  prefs: []
  type: TYPE_NORMAL
- en: This should begin to make more sense in the following chapters of this book.
    In the meantime, we will use the identity functor to explain some more advanced
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Closing words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let me reiterate again that functors are a really simple abstraction to understand,
    but also a really powerful one. We've seen only two of them, but an infinity of
    data structures that can be transformed to functors really easily.
  prefs: []
  type: TYPE_NORMAL
- en: Any function or class that allows you to map a given function to one or more
    values held in a context can be considered a functor. Identity functors or arrays
    are simple example of such a context; other examples would be the `Maybe` and
    `Either` types we discussed earlier or any class having a `map` method that allows
    you to apply a function to the contained valued.
  prefs: []
  type: TYPE_NORMAL
- en: I cannot encourage you enough to try implementing this map pattern and verify
    whether both laws hold wherever you create a new class or data structure. This
    will allow you to have an easier understanding of what your code can perform and
    you will be able to perform optimization using composition with the guarantee
    that your refactoring is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an instance of our identity functor, holding some integer and a
    curryied version of an `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what happens when we try to map the `$add` parameter on our functor? Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you may have guessed, our functor now contains a closure representing a partially
    applied `add` parameter with the value `5` as the first parameter. You can use
    the `get` method to retrieve the function and use it, but it is not really that
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility would be to map another function, taking our function as
    a parameter, and doing something with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But I imagine we can all agree that this is not a really effective way to perform
    such an operation. What would be great is to be able to simply pass the value
    `10` or maybe another functor to `$hum` and achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Enters the applicative functor. As the name suggests, the idea is to apply functors.
    More precisely, to apply functors to other functors. In our case, we could apply
    `$hum`, which is a functor containing a function, to another functor containing
    the value `10` and obtain the value `15` we are after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an extended version of our `IdentityFunctor` class to test our
    idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even create your `Applicative` class containing only your function
    and apply the values afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The applicative abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now able to use our `IdentifyFunctor` class as a curryied function holder.
    What if we could abstract this idea away and create something on top of the `Functor`
    class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created a new abstract class instead of an interface. The
    reason is because we can implement the `map` function using the `pure` and `apply`
    methods so it makes no sense to force everyone wanting to create an `Applicative` class
    to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: The `pure` function is called so because anything stored inside an `Applicative`class
    is considered pure as there is no way to modify it directly. The term is taken
    from the Haskell implementation. Other implementations sometimes use the name
    *unit* instead. pure is used to create a new applicative from any `callable`.
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` function applies the stored function to the given parameter. The
    parameter must be of the same type so that the implementation knows how to access
    the inner value. Sadly, the PHP type system does not allow us to enforce this
    rule and we must resign ourselves to defaulting to `Applicative`.
  prefs: []
  type: TYPE_NORMAL
- en: We have the same issue for the definition of map that has to keep the return
    type as `Functor`. We need to do this as the PHP type engine does not support
    a feature called **return type covariance**. If it did, we could specify a more
    specialized type (that is a child type) as a return value.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function is implemented using the aforementioned functions. First
    we encapsulate our `callable` using the `pure` method and we apply this new applicative
    on the actual value. Nothing really fancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Everything seems to work fine. We were even able to verify that our map implementation
    seems to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the functor, we can create the simplest of the `Applicative` class
    abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Applicative laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first important property of applicative is that they are *closed under composition*,
    meaning an applicative will return a new applicative of the same type. Also, the
    apply method takes an applicative of its own type. We cannot enforce this using
    the PHP type system, so you will need to be careful otherwise something might
    break at some point.
  prefs: []
  type: TYPE_NORMAL
- en: The following rules also need to be respected to have a proper applicative functor.
    We will first present them all in detail and then verify that they hold for our
    `IdentityApplicative` class later.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*pure(f)->apply == map(f)*'
  prefs: []
  type: TYPE_NORMAL
- en: Applying a function using an applicatives is the same as mapping this function
    over. This law simply tells us that we can use an applicative anywhere we used
    a functor before. We lose no power by switching to an applicative.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is not really a law as it can be inferred from the following four
    laws. But as it is not at all evident, and in order to make things clearer, let's
    state it.
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*pure(id)->apply($x) == id($x)*'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the identity function results in no change to the value. As with the
    identity law for functors, this ensure that the `apply` method does nothing but
    apply the function. No hidden transformation is happening behind our backs.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*pure(f)->apply($x) == pure(f($x))*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an applicative functor and applying it to a value has the same effect
    as first calling the function on the value and boxing it inside the functor afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important law because our first motivation to dive into applicative
    is usage of the curryied function instead of unary functions. This law ensures
    that we can create our applicative at any stage instead of needing to box our
    function right away.
  prefs: []
  type: TYPE_NORMAL
- en: Interchange
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*pure(f)->apply($x) == pure(function($f) { $f($x); })->apply(f)*'
  prefs: []
  type: TYPE_NORMAL
- en: This one is a bit tricky. It states that applying a function on a value is the
    same as creating an applicative functor with a lifted value and applying it to
    the function. In this case, a lifted value is a closure around the value that
    will call the given function on it. The law guarantees that the pure function
    performs no modification besides boxing the given value.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*pure(compose)->apply(f1)->apply(f2)->apply($x) == pure(f1)->apply(pure(f2)->apply($x))*'
  prefs: []
  type: TYPE_NORMAL
- en: A simpler version of this law could be written with *pure(compose(f1, f2))->apply($x)*
    on the left-hand side. It simply states, as the composition law for functors,
    that you can apply a composed version of two functions to your value or call them
    separately. This ensures that you can perform the same optimizations for functors.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the laws hold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw for functors, it is more than recommended to test whether your implementations
    hold for all laws. This can be a really tedious process, especially if you have
    four of them. So instead of performing the check manually, let''s write a helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `identity` and `compose` functions are declared inside the helper so that
    it is completely self-contained and you can use it in a variety of situations.
    Also the `compose` function from the `functional-php` library is not adapted as
    it is not curryied and it takes a variable number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in order to avoid having a lot of arguments, we take an instance of the
    `Applicative`class so we can have a first function and the type to check and then
    a `callable` and a value that will be lifted to the applicative and used whenever
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This choice limits the functions we can use as the value must match the type
    of the parameter for both functions; the first function must also return a parameter
    of the same type. If this is too constraining for you, you can decide to extend
    the helper to take two more arguments, a second applicative and a lifted value,
    and use those when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify our `IdentityApplicative` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great, everything seems to be fine. If you want to use this helper, you need
    to choose functions that are compatible as you might encounter some error messages
    that lack clarity as we cannot ensure that the type of the return value for the
    first function matches the type of the first parameter for the second function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this kind of automatic checking can greatly help, let us quickly write
    the same kind of function for functors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And check our never tested `IdentityFunctor` with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Good, everything is fine.
  prefs: []
  type: TYPE_NORMAL
- en: Using applicatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already saw, arrays are functors, because they have a `map` function.
    But a collection can also easily be an applicative. Let''s implement a `CollectionApplicative`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is all fairly easy. To simplify our life we just wrap
    anything that is not a collection inside an array and we transform instances of
    the `Traversable` interface to a real array. This code would obviously need some
    improvement to be used in production, but it will suffice for our little demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here? We have a list of functions in our applicative and we
    apply that to a list of numbers. The result is a new list with each function applied
    to each number.
  prefs: []
  type: TYPE_NORMAL
- en: 'This small example is not really useful, but the idea can be applied to anything.
    Imagine you have some kind of image gallery application where the user can upload
    some images. You also have various  processing you want to make on those images:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the size of the final image as the user tends to upload them too big
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a thumbnail for the index page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a small version for mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only thing you need to do is create an array of all your functions, an
    array of the uploaded images, and apply the same pattern we just did to our numbers.
    You can then use the group function from the `functional-php` library to regroup
    your images together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the index in the transformed array to regroup the images together. Every
    third image is the limited one, every fourth the thumbnail, and finally we have
    the mobile version. The result can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You might be hungry for more at this stage, but you will need to be patient.
    Let's finish first with the theory in this chapter and we will soon see more potent
    examples in the next.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of applicative functors, we need to add one
    last piece to the puzzle before speaking about monads, the monoid. Once again,
    the concept is taken from the mathematical field of category theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **monoid** is a combination of any type and a binary operation on this type
    with an associated identity element. For example, here are some combinations that
    you probably never expected were monoids:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer number and the addition operation, the identity being 0 because*$i +
    0 == $i*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer number and the multiplication operation, the identity being 1 because*$i
    * 1 == $i*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and the merge operation, the identity being the empty array because *array_merge($a,
    []) == $a*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String and the concatenate operation, the identity being the empty string because
    *$s . '' == $s*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the remainder of the chapter, let's call our operation *op* and the identity
    element *id*. The `op`call comes from operation or operator and is used in some
    `Monoid` implementation across multiple languages. Haskell uses the terms **mempty**
    and **mappend** to avoid clashes with other function names. Sometimes zero is
    used instead of *id* or identity.
  prefs: []
  type: TYPE_NORMAL
- en: A monoid must also respect a certain number of laws, two to be precise.
  prefs: []
  type: TYPE_NORMAL
- en: Identity law
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*$a op id == id op $a == $a*'
  prefs: []
  type: TYPE_NORMAL
- en: The first law ensures that the identity can be used on both sides of the operator.
    An identity element can work only when applied as the right-hand or left-hand
    side of the operator. This is, for example, the case for operations on matrices.
    In this case, we speak of left and right identity elements. In the case of a `Monoid`,
    we need a two-sided identity, or simply identity.
  prefs: []
  type: TYPE_NORMAL
- en: As for most identity laws, verifying it for a `Monoid` implementation ensures
    that we correctly apply the operator with no other side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity law
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*($a op $b) op $c == $a op ($b op $c)*'
  prefs: []
  type: TYPE_NORMAL
- en: This law guarantees that we can regroup our call to the operator in any order
    we want, as long as some other operations are not interleaved. This is important
    because it allows us to reason about possible optimization with the insurance
    that the result will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that a sequence of operations is associative; you can also separate
    the sequence into multiple parts, distribute the computation across multiple threads,
    cores, or computers, and when all the intermediary results come in, apply the
    operation between them to get the final result.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the laws hold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s verify those laws for the monoids we spoke about earlier. First, the
    integer addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the integer multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the array merge as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the string concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Great, all our monoids respect both laws.
  prefs: []
  type: TYPE_NORMAL
- en: What about subtraction or division? Are they also a monoid? It's pretty obvious
    that 0 is the identity of subtraction and 1 is the identity for division, but
    what about associativity?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following for checking the associativity of subtraction or division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We clearly see that neither subtraction nor division is associative. When working
    with such abstraction, it is always important to test our assumption using the
    law. Otherwise a refactoring or calling some function expecting a `Monoid` could
    go really wrong. Obviously, the same applies for functors and applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: What are monoids useful for?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Honestly, monoids themselves are not really useful, especially in PHP. Eventually,
    in a language where you can either declare new operators or redefine existing
    ones, you could ensure their associativity and the existence of an identity using
    monoids. But even so, there would be no real advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the language could automatically distribute work done with operators
    that are part of a `Monoid`, it would be a great way to speed up lengthy computation.
    But I am not aware of any language, even academic ones, that are currently capable
    of doing so. Some languages perform operation reordering to improve efficiency,
    but that's about it. Obviously, PHP can't do any of that since the concept of
    monoid is not in the core.
  prefs: []
  type: TYPE_NORMAL
- en: Why bother then? Because monoids can be used with higher-order functions and
    some constructs that we will discover later can take full advantage of their laws.
    Also, since PHP does not allow us to use existing operators as functions, as is
    the case with Haskell, for example, we've had to define functions such as `add`
    before. Instead, we can define a `Monoid` class. It would have the same utility
    as our simple function with some nice properties added.
  prefs: []
  type: TYPE_NORMAL
- en: At the risk of sounding like a broken record, explicitly stating that an operation
    is a monoid reduces cognitive burden. When using a monoid, you have the assurance
    that the operation is associative and that it respects a two-sided identity.
  prefs: []
  type: TYPE_NORMAL
- en: A monoid implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP does not support generics, so we have no way to encode the type information
    of our `Monoid` formally. You will have to choose a self-explanatory name or document
    that is the type clearly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as we want our implementation to replace functions such as `add`, we
    need some additional methods on our class to allow for this usage. Let''s see
    what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we have our `id` and `op` functions declared abstract as those will
    be the specific parts for each of our monoids.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of having a `Monoid` is easily being able to fold
    a collection of values having the type of the `Monoid` class. This is why we create
    the `concat` method as a helper to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have an `__invoke` function so that our `Monoid` can be used like
    a normal function. The function is curryied in a specific way. If you pass more
    than one parameter on the first call, the `concat` method will be used to return
    a result immediately. Otherwise, with exactly one parameter, you will get a new
    function waiting for a second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are at it, let''s write a function to check the laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our first monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create monoids for the cases we''ve seen previously and demonstrate
    how we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s validate the laws on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For the example, let''s try to create a monoid for subtraction and check the
    laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the associativity laws fail. We also have an issue with the left
    identity because of *0 - $a == -$a*. So let's not forget to test our monoids regarding
    the laws to ensure that they are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two interesting monoids can be created regarding the Boolean type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'These two monoids allow us to verify whether at least one or all conditions
    are met. These are the monoidic versions of the every and some functions in the
    `functional-php` library. These two monoids serve the same purpose as the sum
    and product ones since PHP does not allow us to use Boolean operators as functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: They can prove useful when you need to create a series of conditions programmatically.
    Instead of iterating over all of them to generate results, just feed them to the
    `Monoid`. You can also write a *none* monoid as an exercise to see if you understood
    the concept well.
  prefs: []
  type: TYPE_NORMAL
- en: Using monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most obvious ways to use our new monoids is to fold a collection
    of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This property is so interesting that most functional programming languages implement
    the idea of a `Foldable` type. Such a type needs to have an associated monoid.
    With the help of the property we have just seen, the type can then be easily folded.
    However, the idea is difficult to port to PHP as we will miss the syntactic sugar
    needed to improve over using the `concat` method like we just did.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use them as the `callable` type and pass them to higher order
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this is not limited to the compose function. You could rewrite all
    of the previous examples from this book that used an `add` function and use our
    new `Monoid` instead.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress in this book, we will see more ways to use monoids associated
    with functional techniques that we have yet to discover.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started learning about functors, which are a collection of values that can
    be mapped over. We then introduced the idea of applicative functors, which allow
    us to put those values in a certain context and apply functions to them while
    preserving the context. We also made a quick detour to talk about monoids and
    their properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this prior knowledge, we are finally ready to start with the idea
    of monads. As James Iry humorously noted in *A Brief, Incomplete, and Mostly Wrong
    History of Programming Languages*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A monad is a monoid in the category of endofunctors, what''s the problem?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This fictional quote, attributed to Philip Wadler, one of the original people
    involved in the Haskell specification and a proponent of the use of monads, can
    be found in context at [http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html).
  prefs: []
  type: TYPE_NORMAL
- en: Without some knowledge of category theory, it would be hard to clearly explain
    what the quote is all about, especially since it is fictional and voluntarily
    vague enough to be funny. Suffice to say that monads are akin to monoids as they
    share roughly the same set of laws. Also, they are directly linked to the concept
    of functors and applicative.
  prefs: []
  type: TYPE_NORMAL
- en: 'A monad, like a functor, acts as some kind of container for a value. Also,
    like for applicative, you can apply functions to the encapsulated values. All
    three patterns are a way to put some data inside a context. However, there are
    a few differences between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: The applicative encapsulates a function. The monad, and the functor, encapsulate
    a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The applicative uses functions that return non-lifted values. The monad uses
    functions that return a monad of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As functions are also valid values, this doesn''t mean both are incompatible,
    it only means we will need to define a new API for our monad type. However, we
    can freely extend Applicative as it contains totally valid methods in a monadic
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation is pretty simple. We alias pure with return as Haskell uses
    this term in monads so that people don't get lost. Be aware that it has nothing
    to do with the return keyword you are accustomed to; it's really just to put the
    value inside the context of the monad. We also define a new bind function that
    takes a `callable` type as parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we don''t know how the internal value will be stored and because of the
    limitations of the PHP type system, we cannot implement neither the `apply` nor
    the `bind` function although they should be pretty similar:'
  prefs: []
  type: TYPE_NORMAL
- en: The `apply`method takes a value wrapped in the `Applicative` class and applies
    the stored function to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bind` method takes a function and applies it to the stored value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the two is that the `bind`method needs to return the
    value directly, whereas the `apply` method first wraps the value again using the
    `pure` or `return` functions.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have come to understand, people using different languages tend to
    name things a bit differently. This is why you will sometimes see the `bind` method
    called **chain** or **flatMap**, depending on the implementation that you are
    looking at.
  prefs: []
  type: TYPE_NORMAL
- en: Monad laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know the drill by now; there are also some laws a monad must respect to
    be called a monad. The laws are the same as for a monoid-identity and associativity.
    So all the same useful properties of a monoid are also true for a monad.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you will see, the laws we will describe seem to have nothing in
    common with the identity and associativity laws we've seen for monoids. This is
    linked to the way we defined the `bind` and `return` functions. Using something
    called the **Kleisli** composition operator we can transform the laws so that
    they read a bit like the ones we saw before. However, this is a bit complicated
    and not at all useful for our purpose. If you want to read more about it, I can
    direct you to [https://wiki.haskell.org/Monad_laws](https://wiki.haskell.org/Monad_laws).
  prefs: []
  type: TYPE_NORMAL
- en: Left identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*return(x)->bind(f) == f(x)*'
  prefs: []
  type: TYPE_NORMAL
- en: The law states that, if you take a value, wrap it in the context of the monad,
    and bind it to *f*, the result has to be the same as if you call the function
    directly on the value. It ensures that the `bind` method has no side effects on
    the function and the value besides applying it.
  prefs: []
  type: TYPE_NORMAL
- en: This can only be true because, contrary to the `apply` method, the `bind`method
    does not wrap the return value of the function inside the monad again. This is
    the work of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Right identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*m->bind(return) == m*'
  prefs: []
  type: TYPE_NORMAL
- en: This law states that, if you bind the returned value to a monad, you will get
    your monad back. It ensures that return has no effect than putting the value inside
    the context of the monad.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*m->bind(f)->bind(g) == m->bind((function($x) { f($x)->bind(g); })*'
  prefs: []
  type: TYPE_NORMAL
- en: This laws states that you can either bind the value inside the monad first to
    *f* then to *g* or you can bind it to the composition of the first function with
    the second. We need an intermediary function to simulate this like we needed one
    in the interchange law for applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: This law allows us the same benefits as previous associative and composition
    laws. The form is a bit strange because the monad holds the value and not the
    function or operator.
  prefs: []
  type: TYPE_NORMAL
- en: Validating our monads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a function to check a monad validity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need an identity monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can finally verify that everything holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Why monads?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first reason is a practical one. When you apply a function using an applicative,
    the result is automatically put inside the context of the applicative. This means
    that, if you have a function returning an applicative and you apply it, the result
    will be an applicative inside an applicative. Anyone who has seen the film *Inception*
    knows it is not always a great idea to put something, inside something, inside
    something.
  prefs: []
  type: TYPE_NORMAL
- en: Monads are a way to avoid this unnecessary nesting. The `bind` function delegates
    the task of encapsulating the return value to the function, meaning you will only
    have one level of depth.
  prefs: []
  type: TYPE_NORMAL
- en: Monads are also a way to perform flow control. As we've seen, functional programmers
    tend to avoid using loops or any other kind of control flow, such as the `if`
    conditions that make your code harder to reason upon. Monads are a powerful way
    to sequence transformation in a really expressive way while keeping your code
    clean.
  prefs: []
  type: TYPE_NORMAL
- en: Languages such as Haskell also have specific syntactic sugar to work with monads,
    such as the `do` notation, which makes your code even easier to read. Some people
    have tried implementing such a thing in PHP without much success in my opinion.
  prefs: []
  type: TYPE_NORMAL
- en: However, to truly understand the power of the monad abstraction you have to
    look at some specific implementations, as we will do in the next chapter. They
    will allow us to perform *IO* operation in a purely functional way, pass log messages
    from one function to another, and even compute random numbers with a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: Another take on monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We decided to implement our `Monad` class leaving both the `apply` and `bind`
    methods abstract. We had no other choice as the way the value is stored inside
    the `Monad` class will only be decided in the `child` class.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we already said, The `bind` method is sometimes called flatMap in
    Scala, for example. As the name implies, this is nothing but the combination of
    a map and a function called `flatten`.
  prefs: []
  type: TYPE_NORMAL
- en: Do you get where I am going with this? Remember the issue with nested applicatives?
    We could add a `flatten` function, or join as Haskell calls it, method to our
    `Monad` class, and instead of having `bind` as an abstract method, we could implement
    it using `map` and our new method.
  prefs: []
  type: TYPE_NORMAL
- en: We will still have two methods to implement, but instead of both doing roughly
    the same job, calling a function with a value, one will continue to do that and
    the other one will be in charge of un-nesting the `Monad` instances.
  prefs: []
  type: TYPE_NORMAL
- en: As such a function has only limited use for the outside world, I decided to
    go with the presented implementation. Doing it with the `flatten` function instead
    is a nice exercise that you can try to solve to get a better understanding of
    how monad works.
  prefs: []
  type: TYPE_NORMAL
- en: A quick monad example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that we need to read the content of a file using the `read_file` function
    and then send it to a **webservice** using the post function. We will create two
    versions, as follows, of the upload function to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: The first version will use traditional functions, returning a Boolean `false`
    in case of an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functional version will assume curryied functions returning an instance
    of the `Either` monad. We will describe this monad further in the next chapter;
    let's just assume it works like the `Either` type we already saw earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of success, the given callback must be called with the status code
    returned by the `post` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the functional version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: I don't know which one you prefer, but my choice is clear. The choice of using
    `Either` instead of `Maybe` is also not innocent. It means the functional version
    can also return a detailed error message instead of just `false` in case of error.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If after completing this chapter you still find yourself a bit lost, as this
    is such an important topic, don''t hesitate to read one of the following articles
    or some others you found yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: A small introduction to monads in PHP also with a related library at [http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html](http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good introduction to Scala, which anyone who has written some Java should
    understand, at [https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534](https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A video with a more mathematical approach at [https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads](https://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A humorous JavaScript tutorial on monads. You either love or hate the style.
    If you are fluent with JavaScript, I can only recommend you read the whole book:
    [https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch9.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A really complete, if somewhat difficult, introduction to monads. Some basic
    Haskell knowledge is needed to understand the explanations at [https://wiki.haskell.org/All_About_Monads](https://wiki.haskell.org/All_About_Monads).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was certainly a mouthful, but fear not, it was the last of its
    kind. From now on, we will tackle more practical topics with real-life applications.
    [Chapter 6](ch06.html "Chapter 6.  Real-Life Monads"), *Real life monads* will
    present some useful uses of the abstractions we just learned about.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions, such as functors, applicative, and monads, are the design patterns
    of the functional world. They are high-level abstractions that can be found in
    a lot of different places and you will need some time to be able to discern them.
    However, once you will get the feel for them, you will probably realize that they
    are everywhere and it will greatly help you to think in terms of manipulating
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The laws that preside over our abstractions are really prevalent. You probably
    assume them already when writing code without noticing it. Being able to recognize
    the patterns we've learned about will bring you more confidence when doing refactoring
    or writing algorithms because what your instinct always suspected will be backed
    up by facts.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play around with this chapter's concepts, I can only recommend
    you start playing with the `functional-php` library we presented in [Chapter 3](ch03.html
    "Chapter 3.  Functional Basis in PHP"), *Functional basis in PHP*. It contains
    a lot of interfaces defining various algebraic structures, the fancy name given
    by mathematicians to functors, monads, and such. Some of the method names will
    not be exactly the ones we used, but you should be well equipped to understand
    the idea behind them. As the library name makes it a bit hard to find, here is
    the link once more, [https://github.com/widmogrod/php-functional](https://github.com/widmogrod/php-functional).
  prefs: []
  type: TYPE_NORMAL
