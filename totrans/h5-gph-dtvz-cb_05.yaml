- en: Chapter 5. Getting Out of the Box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Going though a funnel (a pyramid chart)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Revisiting lines: making the line chart interactive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree mapping and recursiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding user interaction into tree mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an interactive click meter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered our bases with the majority of the standard charts. At this
    stage, it's time for us to become more creative with our charts. From this chapter
    onwards, we will progress into more out-of-the-box, less commonly used charts
    and revisit some of our old charts to incorporate dynamic data into them or to
    change their layout.
  prefs: []
  type: TYPE_NORMAL
- en: Going through a funnel (a pyramid chart)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's rare that you see a pyramid chart that is actually created dynamically.
    For the most part, they're designed and fleshed out creatively and turn into a
    `.jpg` file when they reach the web, and that's exactly why I wanted to start
    this chapter with this chart—it's not as complex as it might sound.
  prefs: []
  type: TYPE_NORMAL
- en: '![Going through a funnel (a pyramid chart)](img/3707OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A pyramid chart is in essence a way for us to visualize changes in data that
    are quantitative by nature. They have a clear relationship between the lower layers
    and the higher layers. That sounded very vague, so let's explain it through an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that X amount of people complete their eighth year of school in a given
    year, if we follow the same group of people, how many of them would have completed
    their twelfth year of education four years later? Fair enough! We can't know the
    answer to that, but one thing we do know is that it can't be more than the initial
    X amount of people. The idea of a pyramid chart is exactly that of a body of data,
    of which less and less goes through the funnel as time or something else changes
    It's a really great chart to compare between levels of education, finance, involvement
    in politics, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as always, set up our HTML file logic. For a refresher on how to start
    up the HTML file, please go back to the *Graphics with 2D canvas* recipe in [Chapter
    1](ch01.html "Chapter 1. Drawing Shapes in Canvas"), *Drawing Shapes in Canvas*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond our standard HTML preparation, we need to come up with the data sources
    that we wish to showcase. Let's start building our pyramid. Go right into the
    JS file and let's start.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will create a pyramid to find out how many people that read
    this book from chapter one through chapter five actually reach chapter five (this
    data is fake; I hope everyone that starts reading will get there!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, provide some charting and styling information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, for the first time, we are differentiating between what we want the
    size of our canvas to be and the actual size of our chart (funnel/triangle). Another
    important thing to note is that, for our sample to work in its current format,
    our triangle height and width (base) must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Define a few global helper variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's time for us to create our `init` function. This function will be doing
    most of the heavy lifting with the help of another function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function performs the normal setup and executes the styling logic and then
    it creates a triangle, after which it finds the right points (by using the `findLine`
    function) at which we should cut the triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function finds the dots on our triangle based on the data of the current
    line. That's it; now its time to understand what we just did.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After setting the code for lines in the `init` function, we are ready to start
    thinking about our triangle. First, we need to find out the total pixels that
    are within our triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That is easy as we know our height and our width, so the formula is really simple.
    The next data point that is critical is the total amount of data. We can create
    a relationship between the pixels and the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As such, we loop through all the data layers and calculate the summary of all
    data points. At this stage, we are ready to find out the actual number of pixels.
    Each data element is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up the styles for our stroke and fill, we stop to think about
    the best translation that would help us build our triangle. For our triangle,
    I''ve picked the top edge to be the `0,0` point, after creating the triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines of our `init` function call the `findLine` method for each
    element in our `layers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Time to dig into how the `findLine` function actually finds the points to create
    the lines. The idea is very simple. The basic idea is to try to find out how many
    lines it would take to complete the number of pixels in a triangle. As we are
    not building a math formula, we don't care if it's 100 percent accurate, but it
    should be accurate enough to work visually.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with introducing color into our pallet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: OK, we are done with the easy part. Now, it's time to rework our logic.
  prefs: []
  type: TYPE_NORMAL
- en: Making findLine smarter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For us to be able to create a closed shape, we need to have a way to change
    the direction of the line drawn from right to left or from left to right and not
    have it go in one direction always. Beyond that, we are using `moveTo` right now
    and as such can never create a closed shape. What we actually want is to move
    our point and draw a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our next problem is that we don't want to change the actual triangle height
    as we will be calling this function more times than we did in the past. To come
    up with a plan for this problem, we need to extract some of the logic. We will
    return the new number of lines that were created, so that we can remove them externally
    from the triangle. This action enables us to have more finite control over visuals
    (a thing that will be important when we incorporate text).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, our `findLine` function is really smart and is capable of helping
    us to create closed shapes without controlling more than it needs to control (as
    it isn't changing any of our global data).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the logic in init to create shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a smart `findLine` function, it's time for us to rewrite our
    logic related to drawing lines in the `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, we draw all elements in our loop, minus the last one (as our last element
    is actually a triangle and not a line). Then, to help us hide our mathematical
    inaccuracy, we create a new path each time our loop starts and call our `findLine`
    function first with no new data (drawing a line in the last place where it drew
    a line as there is no data) and then drawing a second line, this time with the
    real new data.
  prefs: []
  type: TYPE_NORMAL
- en: Our exception to the rule is created out of the loop, and there, we just manually
    draw our shape, starting with the last line, and add the `0,0` point into it,
    over our triangle.
  prefs: []
  type: TYPE_NORMAL
- en: Adding text into our graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This one will be simple, as we are already getting back the line count before
    we resize our triangle. We can use this data to calculate where we want to position
    our textfield variable, so let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Just see the difference between drawing our text in the loop and out of it.
    As we don't get new line data out of the loop, we need to change the point logic
    by using the total size of our leftover triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting lines: making the line chart interactive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will travel back in time to one of our earlier recipes, *Building
    line charts in* [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"),
    *Creating Cartesian-based Graphs* and add some user control to it. This control
    enables the user to turn on and off the streams of data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting lines: making the line chart interactive](img/3707OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step that you will need to take is to grab the source code from [Chapter
    3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"), *Creating Cartesian-based
    Graphs*. We will rename `03.05.line-revamp.html` and `03.05.line-revamp.js` to
    `05.02.line-revisit`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our files up to date, add our HTML file—three radio groups
    to represent the three data sources (years 2009, 2010, and 2011).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that I've named each radio group with "i" added to the year and set the
    possible values to be `-1`, `0`, or `1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a few constants (well, variables that are not going to change), and
    set the following three lines, now that the default values have already been assigned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Time to move the logic of creating the chart into a separate function. Everything
    after the initalization of our canvas is going to be moved out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Update the radio boxes to highlight whatever is currently selected and to add
    the `onchange` events to all radio buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make some updates in our `drawChart` function. Our goal is to incorporate the
    new controller `elementStatus` into the drawing of lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, let's add the logic into our `onChangedRadio` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We just added user interaction into our chart.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We haven''t planned for user interaction on this chart in advance. As such,
    we need to revisit it to change some of the logic. When Canvas draws something,
    that''s it, it''s there forever! We can''t just delete an object, as there are
    no objects in Canvas, and as such, we need a way to redraw on demand. To accomplish
    that, we need to extract all the drawing logic from the `init` function and create
    the `drawChart` function. Besides adding our logic to the end of the function,
    we also need to add the start of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although we originally worked out the default to use as the width for our background,
    in a second redraw, our canvas would still have stored its last size (in our case
    it could be `3`), and as such, we reset it to the original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using an object called `elementStatus` to store the current status of
    each line on our chart. The values it can store are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-1`: Do not draw'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: Draw a line with no fill'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Draw a fill'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As such, we are adding the following logic into the end of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As the logic repeats three times, let's just focus on one of them. If we want,
    we can use our constant variables to make the logic easier to view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The logic breaks down into a first `if` statement, testing to see if our content
    should be hidden. If we establish that this line should be added, we draw it by
    sending into the fill/line parameter the outcome of comparing our current value
    to `FILL_ELEMENT`, resulting in two variations based on the outcome of this operation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, because we are not using any open source library, the built-in
    HTML capabilities don't allow us to set events to groups of radios, and as such,
    we need to find them all and add the `onchange` event to them using the IDs we
    are storing in our `elementStatus` controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the highlighted code. Here, we are checking to see whether
    our current radio button's value matches our element value in `elementStatus`.
    If it does, it means that the radio button will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the logic of onChangedRadio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take another peek at the logic in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is save the newly selected value into our `elementStatus`
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We follow that by deleting everything from our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, wipe the slate clean and start with a new path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And... you guessed it... Then start drawing everything all over, and our new
    parameter in `elementStatus` will validate that the right things will be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Building line charts* recipe in [Chapter 3](ch03.html "Chapter 3. Creating
    Cartesian-based Graphs"), *Creating Cartesian-based Graphs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree mapping and recursiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tree mapping enables us to see in-depth data from a bird's-eye view. Contrary
    to comparative charts—such as most of the charts that we have created until now—tree
    mapping displays tree structured data as a set of nested rectangles, enabling
    us to visualize their quantitative nature and relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree mapping and recursiveness](img/3707OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with a tree mapping that showcases only one level of information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our application with the number of people in the world, in millions,
    divided by continent (based on public data from 2011).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will update this data source later in our example, so keep in mind that this
    dataset is temporary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a simple, working, flat tree chart. Let''s jump right
    into it and figure out the steps involved in creating the tree map:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a few helper variables on top of our dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create the `init` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create the function `drawTreeMap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Create a few formatting functions to help us create a random color for our tree
    map block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is a bit of overkill in the creation of so many formatting functions;
    their main goal is to help us when we are ready for the next step—to create more
    depth in our data (refer to the *There's more...* section in this recipe for more
    details).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the initial idea. Our goal is to create a map that will showcase
    the bigger volume areas inside our rectangular area and leave a strip on the side
    for the smaller areas. So, let''s start with our `init` function. Our first task
    beyond our basic getting started work is to calculate the actual total. We do
    that by looping through our data source, thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We continued with some playing around with the design and making our work area
    10 pixels smaller than our total canvas size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It's time to take a look into how our `drawTreeMap` function works. The first
    thing to notice is that we send in an array instead of working directly with our
    data source. We do that because we want to be open to the idea that this function
    will be re-used when we start building the inner depths of this visualization
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start our function with a few helper variables (the `percent` variable will
    store the current `percent` value in a loop). The `cx` (the current x) position
    of our rectangle and `rollingPercent` will keep track of how much of our total
    chart has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Time to start looping through our data and drawing out the rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Before we complete our first loop, we will test it to see when we cross our
    threshold (you are welcome to play with that value). When we reach it, we need
    to stop the loop, so that we can start drawing our rectangles by height instead
    of by width.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Before we start working on our boxes, which take the full leftover width and
    expand to the height, we need a few helper variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As we need to calculate each element from now on based on the amount of space
    left, we will figure out the value (`leftOverPercent`), and then we will extract
    the remaining width of our shape and start up a new `cy` variable to store the
    current y position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We start our loop with one value higher than what we left off (as we broke out
    of our earlier loop before we had a chance to update its value and draw to the
    height of our remaining area.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in both loops we are using `formatColorObject` and `getRandomColor`.
    The breakdown of these functions was created so that we can have an easier way
    to manipulate the colors returned in our next part.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our chart to really have that extra kick, we need to have a way to make
    it capable of showing data in at least a second lower-level details of data. To
    do that, we will revisit our data source and re-edit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now we have two regions of the world with a more in-depth view of their subregions.
    It's time for us to start modifying our code, so that it will work again with
    this new data.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the init function – recalculating the total
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step we need to carry out in the `init` function is to replace the
    current total loop with a new one that can dig deeper into elements to count the
    real total.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In essence, we are checking to see whether there is no total and whether there
    is a data source. If that is the case, we start a new loop to calculate the actual
    total for our elements—a good exercise for you now would be to try to make this
    logic into a recursive function (so that you can have more layers of data).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will change `drawTreeMap` and get it ready to become a recursive function.
    To make that happen, we need to extract the global variables from it and send
    them in as parameters of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Turning drawTreeMap into a recursive function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's update our function to enable recursive operations. We start by adding
    an extra new parameter to capture the latest color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we pass a `clr` parameter, we need to keep that color throughout all the
    new rectangles that will be created, and we need to add a padding around the shapes
    so that it becomes easier to see them. We make the color a bit darker as well
    by subtracting 10 percent of its color on all its RGA properties.
  prefs: []
  type: TYPE_NORMAL
- en: The next stage is to add the padding and recursive logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The same logic is then implemented on the second loop as well (to see it check
    the source files).
  prefs: []
  type: TYPE_NORMAL
- en: Turning the data and total to recursive data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start by updating our tree data to be really recursive (for the full dataset
    please refer to the source code).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, with a tree map that has over four levels of information, we can revisit
    our code and finalize our last outstanding issue validating that our total is
    always up-to-date at all levels. To fix that, we will extract the logic of calculating
    the total into a new function and update the `total` line in the `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Time to create this magical (recursive) function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The logic is really similar to what it was, with the exception that all the
    data entries are internal to the function, and each time there is a need to deal
    with another level of data, it's re-sent to the same function (in a recursive
    way) until all data is resolved—until it returns the total.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding user interaction into tree mapping* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding user interaction into tree mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have limited our user interaction with our samples. In one of
    our last samples, we added a controlled way to add and remove chart elements;
    in this one, we will enable the user to dig deeper into the chart and see more
    details by creating a truly endless experience (if we only had an endless amount
    of data to dig into).
  prefs: []
  type: TYPE_NORMAL
- en: In the following image, on the left-hand side, you can see the initial state
    and what happens after one click of the user (the chart redraws itself to showcase
    the area that was clicked on).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding user interaction into tree mapping](img/3707OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider the case when the user clicks on the chart (for example, the next picture
    is generated by clicking on the left-hand side rectangle—the tree map will update
    and zoom into that area).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding user interaction into tree mapping](img/3707OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get this sample right, you will need to start from our last recipe, *Tree
    maping and recursiveness*, and adjust it to work for this sample.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is our first sample where we make our canvas area interactive. In the
    next few steps, we will add some logic from the last sample into our recipe, to
    enable the user to zoom into or out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new global variable,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Store the current data that is sent to the tree mapping function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Add a `click` event to our canvas area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Create the `onTreeClick` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw a rectangle twice—within `drawTreemap`—for the first time in the first
    loop and again in the second loop. Let''s replace it with an external function—replace
    both the `for` loop lines to draw a rectangle with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Time to create the rectangle function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There you go! We have a fully functional, deep-level, endless interaction with
    the user (just dependent on how much data we have).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Canvas element doesn't currently support a smart way to interact with objects.
    As there are no objects in the canvas, as soon as you create the element it tunes
    into a bitmap and its information is removed from memory. Luckily for us, our
    sample is constructed out of rectangles, making it much easier to recognize when
    our element is clicked on. We will need to store in memory the current box location
    of each element that we draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, our first step of logic is the last thing that we did in our procedure
    (in step 6). We want to capture the points that construct our rectangles, so then
    in our `click` event we can figure out where our dot is in relation to the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We loop through our data source (current one) and check to see whether the element
    we are currently in has a data source (that is, children); if it does, we continue,
    and if not, we will skip to the next element to test it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know our element has children, we are ready to see if our dot is
    in the range of our element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If it is, we are ready to redraw the tree map and replace our current dataset
    with the current deeper dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We then exit from the loop (by using a `break` statement). Please note that
    the last thing we do is update `currentDataset`, as we still need information
    from it to send the total data into `drawTreeMap`. When we have finished using
    it, we are ready to override it with the new dataset (what were the children before
    turn into our main players for the next round).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, there is just no way to get back without refreshing everything. So,
    let's add it to our logic that if the user clicks in an element with no children,
    we will revert to the original map.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the main treemap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add the following code into the `click` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Fantastically done! We have just finished creating a fully interactive experience
    for our users, and now it's in your hands to make this look a bit better. Add
    some rollover labels and all the visualization that will make your chart visually
    pleasing and will help understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Making an interactive click meter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next example, we will focus on one more powerful feature of any client-side
    programming—the ability to interact with the user and the ability to update data
    dynamically. To keep it simple, let's revisit an old chart—the bar chart from
    [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"), *Creating
    Cartesian-based Graphs*—and integrate a counter that will count how many times
    a user clicks on an HTML document in any given second and update the chart accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making an interactive click meter](img/3707OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the steps are going to be familiar, if you have worked on the bar chart
    from [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based Graphs"), *Creating
    Cartesian-based Graphs*. So, let''s run through them and then focus on the new
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create some helper variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Follow this with our `init` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to create the `onTimeReset` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create the `onClick` listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now create the `refreshChart` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, let's create `drawChart` (most of its logic is the same
    as for the `init` function discussed in [Chapter 3](ch03.html "Chapter 3. Creating
    Cartesian-based Graphs"), *Creating Cartesian-based Graphs*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have an interactive chart that will be updated every second, depending
    on how many times you manage to click your mouse in 1 second—I assume no one can
    click more than 10 times a second but I've managed to get there (when using two
    hands).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's focus on the breakdown of the data variables in [Chapter 3](ch03.html
    "Chapter 3. Creating Cartesian-based Graphs"), *Creating Cartesian-based Graphs*.
    We had all our data ready inside our data object. This time around, we are keeping
    the data object empty, and instead, we have one data line in a separate variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Each time the user clicks, we update the counter for `currentObject` and refresh
    the chart thus making the user experience more dynamic and live.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the interval in the `init` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Every time a second passes, the function checks whether the user had any clicks
    in that time interval, and if they did, it ensures that we push `currentObject`
    into the dataset. If the size of the dataset is greater than `25`, we cut the
    first item out of it and we refresh the chart. No matter what we create, a new
    empty object is labeled with a new label showing the current time in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing that you should look at before we wrap this sample up is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This part of our logic is really the glue that makes it possible for us to update
    our data every time a user clicks a button. The idea is we want to have a new
    array that will store the new data, but we do not want to the current element
    to be affected, so for that we are duplicating this data source by adding the
    new data object into it and then sending it off to create the chart.
  prefs: []
  type: TYPE_NORMAL
