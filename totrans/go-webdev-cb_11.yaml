- en: Deploying a Go Web App and Docker Containers to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first EC2 instance to run a Go web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with your first EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, copying, and running a Go web application on your first EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an EC2 instance to run a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling a Docker image on an AWS EC2 instance from Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your Go Docker container on an EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, every organization is moving toward DevOps and everyone is talking
    about continuous integration and continuous deployment, often termed as CI and
    CD, which have become must-have skills for developers to learn. When we refer
    to CI/CD, at a very high level, we talk about the deployment of containers to
    public/private clouds through continuous integration tools, such as Jenkins and
    Bamboo.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to deploy a simple Go web application and a Go
    Docker container to an EC2 instance provisioned manually. As we are going to work
    with Docker and AWS, I will assume you possess basic knowledge of Docker and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first EC2 instance to run a Go web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an EC2 instance on AWS is the same as getting a new machine and installing
    the required software to run a web application. In this recipe, we will create
    an EC2 instance, provision it, and run a simple Go web application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with the creating and deploying on an AWS EC2 instance, firstly, you
    have to create and activate an AWS account. Because this is out of context for
    this recipe, we will not be doing it here.
  prefs: []
  type: TYPE_NORMAL
- en: A well-explained process you can follow to create and activate an AWS account
    is available at `https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/`
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Login into AWS, move to the EC2 Management Console,and click on Launch Instance
    in the Create Instance section, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b7216bc-c335-49db-810c-3bf19012c046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Amazon Linux AMI 2017.09.1 (HVM), SSD Volume Type, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b7fe94d-6d3d-462c-a44c-5138afc0c490.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the t2.micro instance type and click on Next: Configure Instance Details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/240f1ef5-9fe6-4ee2-99aa-e759f59e179c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enable Auto-assign Public IP in the Configure Instance Details section, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1eb73f25-5ea4-4ba8-8774-7aaa94d41ba6.png)'
  prefs: []
  type: TYPE_IMG
- en: Do not make any changes to the Add Storage and Add Tags section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the HTTP and HTTPS rule and click on the Review and Launch button in the
    Configure Security Group section, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e235e2dc-d91a-4057-bc40-270e30ba1cd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Create a new key pair from the drop-down menu, give a name to the key
    pair, and click on the Download Key Pair button. Save the `my-first-ec2-instance.pem` file
    and click on Launch Instance, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4e206edf-805a-4d7f-b758-7a238d6efa34.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you click on Launch Instance, it will create and boot up a Linux machine
    on AWS, assigning the instance an ID, public DNS, and public IP through which
    we can access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving to the Instances section of the EC2 Dashboard, you can see the instance
    running, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbcb316a-24cd-43ae-aaf6-2f06ad1e15b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Interacting with your first EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To deploy an application on an EC2 instance, we first have to login into it
    and install the necessary packages/software, which can be easily done through
    an `SSH` client, such as `MobaXterm`, `Putty`, and so on. In this recipe, we will
    login into an EC2 instance, which we created in the previous recipe, and install
    `Go` using the Red Hat package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set the permissions of the private key file—`my-first-ec2-instance.pem`—to
    `400`, which means the user/owner can read, can''t write, and can''t execute,
    whereas the group and others can''t read, can''t write, and can''t execute it,
    by executing the `chmod` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the public DNS of the EC2 instance and connect to it using a private key
    file as an `ec2-user` by executing the `ssh` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command has executed successfully, we will be logged in to the EC2
    instance and the output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b1473d-ab5b-4cca-a5f5-f30c83772e46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Switch to the `root` user from `ec2-user` by executing the `sudo` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `Go` using the Red Hat package manager,  `yum`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether `Go` has been installed successfully for the `ec2-user` by executing
    the `go version` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating, copying, and running a Go web application on your first EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have an EC2 instance ready with the required libraries installed, we
    can simply copy the application using the secure copy protocol and then run it
    using the `go run` command, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `http-server.go`, where we will create a simple HTTP server that will
    render Hello World! browsing `http://ec2-instance-public-dns:80` or executing
    `curl -X GET http://ec2-instance-public-dns:80` from the command line, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1efd7ced-8473-4115-99e1-bfaa0826117b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy `http-server.go` from the local machine directory to an EC2 user home
    (`/home/ec2-user`) directory using the secure copy or `scp` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Login into an EC2 instance using a private key file and a public DNS name,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `http-server.go` in the background, executing the no hang-up or `nohup`
    command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program on an EC2 instance, the HTTP server will start locally
    listening on port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute a `GET` request from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give Hello World! as a response, which will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Setting up an EC2 instance to run a Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run a Docker container on an EC2 instance, we first have to set up an instance
    with a Docker installation and add an `ec2-user` to the Docker group so that we
    can execute Docker commands with an `ec2-user` rather than as a `root` user, which
    we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switch to the `root` user from the `ec2-user` user by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `Docker` and update an EC2 instance by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start `Docker` as a service on an EC2 instance by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `ec2-user` to the `docker` group so that you can execute Docker commands
    without using `sudo`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Log out of the EC2 instance by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in again to pick up the new Docker group permissions by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the output on the console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19744d6c-1cb4-46f0-8538-976756388639.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Login into an EC2 instance and verify whether `ec2-user` can run Docker commands
    without using `sudo` by executing following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display system-wide information regarding the Docker installation,
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Pulling a Docker image on an AWS EC2 instance from Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run a Docker container, we need to have a Docker image, which we can either
    build from a `DockerFile` or can pull from any of the public or private Docker
    registries, such as Docker Hub, Quay, Google Container Registry, AWS Container
    Registry, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already learned how to create a Docker image from a `DockerFile`
    and push it to Docker Hub in Chapter 9, *Working with Go and Docker*, we will
    not build an image again in this recipe. Instead, we will be pulling the pre-built
    image from Docker Hub on an EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Building your first Go Docker image* recipe in [Chapter 9](0f2d1029-2554-4f34-86ea-b5a7b4c3bcbd.xhtml),
    *Working with Go and Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Login into Docker Hub using your credentials from the command line by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `docker pull` command to pull `arpitaggarwal/golang-image` from
    Docker Hub, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8883ec18-7b18-4cac-bfc2-f24ec5718ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Login into an EC2 instance and verify whether `arpitaggarwal/golang-image` has
    been pulled successfully from Docker Hub by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all the top-level images, their repositories, tags, and their
    size, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb1282fa-47ba-4e7b-b1b2-db37c328f248.png)'
  prefs: []
  type: TYPE_IMG
- en: Running your Go Docker container on an EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a Docker image and Docker installed on an EC2 instance, then you
    can simply run the Docker container by executing the `docker run` command, which
    we will cover in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Login into an EC2 instance and execute the `docker run` command to create and
    run a Docker container from `arpitaggarwal/golang-image`, assigning the container
    name as `golang-container`, using the `--name` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `-d` flag specified in the `docker run` command starts the container in
    a daemon mode and the hash string at the end represents the ID of the `golang-container`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` flag specified in the `docker run` command publishes a container's
    port(s) to the host. As we have an HTTP server running on port `8080` inside a
    Docker container and we opened port `80` for inbound traffic of our E2C instance,
    we mapped it as `80:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Login into an EC2 instance and verify whether the Docker container has been
    created and is running successfully by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command has executed successfully, it will give us the running
    Docker container details, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccb92238-edb4-46df-8319-951abd427ea1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Get the public DNS of an EC2 instance and execute a `GET` request from the
    command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give Hello World! as a response, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
