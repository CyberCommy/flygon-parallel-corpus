- en: Chapter 7. Communication between Classes and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter shows you how to write your own UInterfaces, and demonstrates
    how to take advantage of them within C++ to minimize class coupling and help keep
    your code clean. The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `UInterface`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a `UInterface` on an object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if a class implements a `UInterface`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to a `UInterface` implemented in native code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling native `UInterface` functions from C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting `UInterface` from one another
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding `UInterface` functions in C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing `UInterface` methods to Blueprint from a native base class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `UInterface` functions in Blueprint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ `UInterface` function implementations that can be overridden in
    Blueprint
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Blueprint-defined interface functions from C++
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple interaction system with UInterfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your game projects, you will sometimes require a series of potentially disparate
    objects to share a common functionality, but it would be inappropriate to use
    inheritance, because there is no "is-a" relationship between the different objects
    in question. Languages such as C++ tend to use multiple inheritance to solve this
    issue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: However, in Unreal, if you wanted functions from both the parent classes to
    be accessible to Blueprint, you would need to make both of them `UCLASS`. This
    is a problem for two reasons. Inheriting from `UClass` twice in the same object
    would break the concept that `UObject` should form a neatly traversable hierarchy.
    It also means that there are two instances of the `UClass` methods on the object,
    and they would have to be explicitly differentiated between within the code. The
    Unreal codebase solves this issue by borrowing a concept from C#—that of an explicit
    Interface type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using this approach, instead of composition, is that Components
    are only available on Actors, not on UObjects in general. Interfaces can be applied
    to any `UObject`. Furthermore, it means that we are no longer modeling an "is-a"
    relationship between the object and the component; instead, it would only be able
    to represent "has-a" relationships.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UInterface
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UInterfaces are a pair of classes that work together to enable classes to exhibit
    polymorphic behavior among multiple class hierarchies. This recipe shows you the
    basic steps involved in creating a `UInterface` purely in code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UInterfaces don't show up inside the main class wizard within Unreal, so we'll
    need to add the class manually using Visual Studio.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right click on your Source folder inside **Solution Explorer,** and select **Add**
    | **New Item**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a `.h` file to start, and name it `MyInterface.h.`
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you change the directory for the item to be placed in from Intermediate
    to Source/ProjectName.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to create a new header file in your project folder.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the steps in order to create `MyInterface.cpp` as your implementation
    file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the header file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement the class with this code in the `.cpp` file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile your project to verify that the code was written without errors.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UInterfaces are implemented as a pair of classes declared in the interface's
    header.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, because we are leveraging Unreal's reflection system, we need to
    include our generated header file. Refer to *Handling events implemented via virtual
    functions* in [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    for more information.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with classes that inherit from `UObject`, which uses `UCLASS`, we need to
    use the `UINTERFACE` macro to declare our new `UInterface`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is tagged `UE4COOKBOOK_API` to help with the exporting of library
    symbols.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base class for the `UObject` portion of the interface is `UInterface`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like `UCLASS` types, we require a macro to be placed inside the body of
    our class so that the auto-generated code is inserted into it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That macro is `GENERATED_BODY()` for UInterfaces. The macro must be placed at
    the very start of the class body.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second class is also tagged `UE4COOKBOOK_API`, and is named in a specific
    way.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `UInterface`-derived class and the standard class have the same
    name but a different prefix. The `UInterface`-derived class has the prefix `U`,
    and the standard class has the prefix `I`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is important as this is how the Unreal Header Tool expects the classes
    to be named for the code it generates to work properly.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The plain native Interface class requires its own autogenerated content, which
    we include using the `GENERATED_BODY()` macro.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare functions that classes inheriting the interface should implement
    inside `IInterface`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the implementation file, we implement the constructor for our `UInterface`,
    as it is declared by the Unreal Header Tool, and requires an implementation.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create a default implementation for our `GetTestName()` function. Without
    this, the linking phase of compilation will fail. This default implementation
    uses the `unimplemented()` macro, which will issue a debug assert when the line
    of code is executed.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to *Passing payload data with a delegate binding* in [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*;
    the first recipe, in particular, explains some of the principles that we've applied
    here
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UInterface on an object
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you've followed the previous recipe in order to have a `UInterface`
    ready to be implemented.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class using the Unreal Wizard, called `SingleInterfaceActor`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `IInterface`—in this case, `IMyInterface`—to the public inheritance list
    for our new `Actor` class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an `override` declaration to the class for the `IInterface` function(s)
    that we wish to override:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the overridden function in the implementation file by adding the
    following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ uses multiple inheritance for the way it implements interfaces, so we leverage
    that mechanism here with the declaration of our `SingleInterfaceActor` class,
    where we add `public IMyInterface`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We inherit from `IInterface` rather than `UInterface` to prevent `SingleInterfaceActor`
    from inheriting two copies of `UObject`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that the interface declares a `virtual` function, we need to redeclare
    that function with the override specifier if we wish to implement it ourselves.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our implementation file, we implement our overridden `virtual` function.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our function override, for demonstration purposes, we call the base `IInterface`
    implementation of the function. Alternatively, we could write our own implementation,
    and avoid calling the base class one altogether.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use `IInterface:: specifier` rather than `Super`, because `Super` refers
    to the `UClass` that is the parent of our class, and IInterfaces aren''t UClasses
    (hence, no `U` prefix).'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can implement a second, or multiple, IInterfaces on your object, as needed.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking if a class implements a UInterface
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the first two recipes so that you have a `UInterface` we can check for,
    and a class implementing the interface, which can be tested against.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your Game Mode implementation, add the following code to the `BeginPlay`
    function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Given that we are referencing both `ASingleInterfaceActor` and `IMyInterface`,
    we need to `#include` both `MyInterface.h` and `SingleInterfaceActor.h` in our
    Source file.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we create an empty `FTransform` function, which has the
    default value of `0` for all translation and rotation components, so we don't
    need to explicitly set any of them.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use the `SpawnActor` function from `UWorld` so that we can create an
    instance of our `SingleActorInterface`, storing the pointer to the instance into
    a temporary variable.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`UWorld`中的`SpawnActor`函数，这样我们就可以创建我们的`SingleActorInterface`的实例，并将指针存储到临时变量中。
- en: We then use `GetClass()` on our instance to get a reference to its associated
    `UClass`. We need a reference to `UClass,` because that object is the one which
    holds all of the reflection data for the object.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`GetClass()`在我们的实例上获取一个引用到其关联的`UClass`。我们需要一个对`UClass`的引用，因为该对象是保存对象的所有反射数据的对象。
- en: Reflection data includes the names and types of all `UPROPERTY` on the object,
    the inheritance hierarchy for the object, and a list of all the interfaces that
    it implements.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射数据包括对象上所有`UPROPERTY`的名称和类型，对象的继承层次结构，以及它实现的所有接口的列表。
- en: As a result, we can call `ImplementsInterface()` on `UClass`, and it will return
    `true` if the object implements the `UInterface` in question.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以在`UClass`上调用`ImplementsInterface()`，如果对象实现了所讨论的`UInterface`，它将返回`true`。
- en: If the object implements the interface, and therefore, returns `true` from `ImplementsInterface`,
    we then print a message to the screen.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象实现了接口，因此从`ImplementsInterface`返回`true`，我们就会在屏幕上打印一条消息。
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    has a number of recipes relating to the spawning of actors'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121 "第5章。处理事件和委托"),
    *处理事件和委托*，有许多与生成actor相关的配方'
- en: Casting to a UInterface implemented in native code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本机代码中实现UInterface的转换
- en: One advantage that UInterfaces provides you with as a developer is the ability
    to treat a collection of heterogeneous objects that implement a common interface
    as a collection of the same object, using `Cast< >` to handle the conversion.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，UInterfaces为您提供的一个优势是，使用`Cast< >`来处理转换，可以将实现共同接口的异构对象集合视为相同对象的集合。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that this won't work if your class implements the interface through
    a Blueprint.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您的类通过Blueprint实现接口，则此方法将无效。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a `UInterface`, and an `Actor` implementing the interface ready
    for this recipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该为此配方准备一个`UInterface`和一个实现接口的`Actor`。
- en: Create a new game mode using the wizard within Unreal, or optionally, reuse
    a project and `GameMode` from a previous recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unreal中的向导创建一个新的游戏模式，或者可选地，重用以前配方中的项目和`GameMode`。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Open your game mode''s declaration, and add a new `UPROPERTY() macro` to it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开游戏模式的声明，并向其中添加一个新的`UPROPERTY()宏`：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add `#include "MyInterface.h"` to the header's include section.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件的包含部分添加`#include "MyInterface.h"`。
- en: 'Add the following within the game mode''s `BeginPlay` implementation:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式的`BeginPlay`实现中添加以下内容：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Set the level's game mode override to your game mode, then drag a few instances
    of your custom Interface-implementing actor into the level.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将级别的游戏模式覆盖设置为您的游戏模式，然后将几个实现自定义接口的actor实例拖放到级别中。
- en: When you play your level, a message should be printed on screen that indicates
    the number of instances of the interface that have been implemented in Actors
    in the level:![How to do it...](img/00110.jpeg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放级别时，屏幕上应该打印一条消息，指示在级别中实现了接口的实例的数量：![操作步骤...](img/00110.jpeg)
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create an array of pointers to `MyInterface` implementations.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个指向`MyInterface`实现的指针数组。
- en: Inside `BeginPlay`, we use `TActorIterator<AActor>` to get all of the `Actor`
    instances in our level.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，我们使用`TActorIterator<AActor>`来获取我们级别中的所有`Actor`实例。
- en: '`TActorIterator` has the following constructor:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TActorIterator`有以下构造函数：'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`TActorIterator` expects a world to act on as well as a `UClass` instance to
    specify what type of Actors we are interested in.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TActorIterator`期望一个要操作的世界，以及一个`UClass`实例来指定我们感兴趣的Actor类型。'
- en: '`ActorIterator` is an iterator like the STL iterator type. This means we can
    write a `for` loop of the following form:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActorIterator`是类似STL迭代器类型的迭代器。这意味着我们可以编写以下形式的`for`循环：'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the loop, we dereference the iterator to get an `Actor` pointer.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内，我们取消引用迭代器以获取`Actor`指针。
- en: We then attempt to cast it to our interface; this will return a pointer to the
    interface if it does implement it, else it will return `nullptr`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们尝试将其转换为我们的接口；如果它实现了它，这将返回一个指向接口的指针，否则将返回`nullptr`。
- en: As a result, we can check if the interface pointer is `null`, and if not, we
    can add the interface pointer reference to our array.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以检查接口指针是否为`null`，如果不是，我们可以将接口指针引用添加到我们的数组中。
- en: Finally, once we've iterated through all the actors in `TActorIterator`, we
    can display a message on the screen, which displays the count of items that implemented
    the interface.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们遍历了`TActorIterator`中的所有actor，我们就可以在屏幕上显示一条消息，显示实现了接口的项目的计数。
- en: Calling native UInterface functions from C++
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++调用本机UInterface函数
- en: Follow the previous recipe to get an understanding of casting an `Actor` pointer
    to an Interface pointer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前一个配方来理解将`Actor`指针转换为接口指针。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that as this recipe relies on the casting technique used in the previous
    recipe, it will only work with objects that implement the interface using C++
    rather than Blueprint. This is because Blueprint classes are not available at
    compile time, and so, technically, don't inherit the interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于此配方依赖于前一个配方中使用的转换技术，因此它只能与使用C++实现接口的对象一起使用，而不能与Blueprint一起使用。这是因为Blueprint类在编译时不可用，因此在技术上不继承该接口。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new `Actor` class using the editor wizard. Call it `AntiGravityVolume`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑向导创建一个新的`Actor`类。将其命名为`AntiGravityVolume`。
- en: Add `BoxComponent` to the new `Actor`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BoxComponent`添加到新的`Actor`中。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Override the following `Actor` `virtual` functions in the header:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中重写以下`Actor` `virtual`函数：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create an implementation within your source file, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件中创建一个实现，如下所示：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initialize the `BoxComponent` in your constructor:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化`BoxComponent`：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create an interface called `GravityObject`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GravityObject`的接口。
- en: 'Add the following `virtual` functions to `IGravityObject`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IGravityObject`中添加以下`virtual`函数：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the default implementation of the `virtual` functions inside the `IGravityObject`
    implementation file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IGravityObject`实现文件中创建`virtual`函数的默认实现：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a subclass of `Actor` called `PhysicsCube`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PhysicsCube`的`Actor`子类。
- en: 'Add a static mesh:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个静态网格：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initialize the component in your constructor:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化组件：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To have `PhysicsCube` implement `GravityObject`, first `#include "GravityObject.h"`
    in the header file, then modify the class declaration:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使`PhysicsCube`实现`GravityObject`，首先在头文件中`#include "GravityObject.h"`，然后修改类声明：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile your project.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。
- en: Create a new level, and place an instance of our gravity volume in the scene.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的关卡，并在场景中放置一个重力体积的实例。
- en: Place an instance of `PhysicsCube` above the gravity volume, then rotate it
    slightly so that it has one corner lower than the others, as shown in the following
    image:![How to do it...](img/00111.jpeg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重力体积上放置一个`PhysicsCube`的实例，然后稍微旋转它，使其有一个角落比其他角落低，如下图所示：![操作步骤...](img/00111.jpeg)
- en: Verify that the gravity is turned off on the object when it enters the volume,
    then turns back on again.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证当对象进入体积时重力被关闭，然后再次打开。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the gravity volume doesn't need to know anything about your `PhysicsCube`
    actor, just the Gravity Object interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重力体积不需要知道任何关于您的`PhysicsCube` actor的信息，只需要知道重力对象接口。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create a new `Actor` class, and add a box component to give the actor something
    that will collide with the character. Alternatively, you could subclass `AVolume`
    if you wanted to use the BSP functionality to define the volume's shape.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的`Actor`类，并添加一个箱子组件，以便给角色添加一个会与角色发生碰撞的物体。或者，如果您想要使用BSP功能来定义体积的形状，您也可以对`AVolume`进行子类化。
- en: '`NotifyActorBeginOverlap` and `NotifyActorEndOverlap` are overridden so that
    we can perform some operation when an object enters or leaves the `AntiGravityVolume`
    area.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`NotifyActorBeginOverlap`和`NotifyActorEndOverlap`，以便在对象进入或离开`AntiGravityVolume`区域时执行某些操作。
- en: Inside `NotifyActorBeginOverlap` implementation, we attempt to cast the object
    that overlapped us into an `IGravityObject` pointer.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyActorBeginOverlap`实现中，我们尝试将与我们发生重叠的对象转换为`IGravityObject`指针。
- en: This tests if the object in question implements the interface.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个测试是为了检查所讨论的对象是否实现了该接口。
- en: If the pointer is valid, then the object does implement the interface, so it
    is safe to use the interface pointer to call interface methods on the object.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指针有效，则对象确实实现了接口，因此可以安全地使用接口指针调用对象上的接口方法。
- en: Given that we are inside `NotifyActorBeginOverlap`, we want to disable the gravity
    on the object, so we call `DisableGravity()`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于我们在`NotifyActorBeginOverlap`内部，我们希望禁用对象上的重力，因此我们调用`DisableGravity()`。
- en: Inside `NotifyActorEndOverlap`, we perform the same check, but we re-enable
    gravity on the object.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyActorEndOverlap`内部，我们执行相同的检查，但是我们重新启用了对象的重力。
- en: Within the default implementation of `DisableGravity`, we cast our own pointer
    (the `this` pointer) to `AActor`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DisableGravity`的默认实现中，我们将我们自己的指针（`this`指针）转换为`AActor`。
- en: This allows us to confirm that the interface has been implemented only on the
    `Actor` subclasses as well as to call methods defined in `AActor`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使我们能够确认接口仅在`Actor`子类上实现，并调用在`AActor`中定义的方法。
- en: If the pointer is valid, we know we are an `Actor`, so we can use `GetComponents<class
    ComponentType>()` to get a `TArray` of all components of a specific type from
    ourselves.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指针有效，我们知道我们是一个`Actor`，所以我们可以使用`GetComponents<class ComponentType>()`来从自身获取特定类型的所有组件的`TArray`。
- en: '`GetComponents` is a `template` function. It expects some template parameters:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetComponents`是一个`template`函数。它需要一些模板参数：'
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the 2014 version of the standard, C++ supports compile-time deduction
    of template parameters. This means that we don't need to actually specify the
    template parameters when we call the function if the compiler can work them out
    from the normal function parameters that we provide.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自2014年标准以来，C++支持模板参数的编译时推断。这意味着如果编译器可以从我们提供的普通函数参数中推断出模板参数，那么在调用函数时我们不需要实际指定模板参数。
- en: The default implementation of `TArray` is `template<typename T, typename Allocator
    = FDefaultAllocator>` class `TArray;`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TArray`的默认实现是`template<typename T, typename Allocator = FDefaultAllocator>`类`TArray;`'
- en: This means that we don't need to specify an allocator by default, so we just
    use `TArray<UPrimitiveComponent*>` when we declare the array.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着我们不需要默认情况下指定分配器，因此当我们声明数组时，我们只使用`TArray<UPrimitiveComponent*>`。
- en: When `TArray` is passed into the `GetComponents` function, the compiler knows
    it is actually `TArray<UPrimitiveComponent*, FDefaultAllocator>`, and it is able
    to fill in the template parameters `T` and `AllocatorType` with `UPrimitiveComponent`
    and `FDefaultAllocator`, so neither of those are required as template parameters
    for the function's invocation.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TArray`传递到`GetComponents`函数中时，编译器知道它实际上是`TArray<UPrimitiveComponent*, FDefaultAllocator>`，并且能够填充模板参数`T`和`AllocatorType`，所以在函数调用时不需要这两个作为模板参数。
- en: '`GetComponents` iterates through the components that `Actor` has, and any components
    that inherit from `typename T` have pointers to them stored inside the `PrimitiveComponents`
    array.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetComponents`遍历`Actor`拥有的组件，并且从`typename T`继承的任何组件都有指针存储在`PrimitiveComponents`数组中。'
- en: Using a range-based `for` loop, another new feature of C++, we can iterate over
    the components that the function placed into our `TArray` without needing to use
    the traditional `for` loop structure.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于范围的`for`循环，这是C++的另一个新特性，我们可以在不需要使用传统的`for`循环结构的情况下迭代函数放入我们的`TArray`中的组件。
- en: Each of the components has `SetEnableGravity(false)` called on them, which disables
    gravity.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个组件调用`SetEnableGravity(false)`，这将禁用重力。
- en: Likewise, the `EnableGravity` function iterates over all the primitive components
    contained in the actor, and enables gravity with `SetEnableGravity(true)`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components,* for extensive discussions
    on Actors and Components. [Chapter 5,](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates") *Handling Events and Delegates,* discusses
    events such as `NotifyActorOverlap`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting UInterface from one another
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may need to create a `UInterface` that specializes on a more
    general `UInterface`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to use inheritance with UInterfaces to specialize
    a **Killable** interface with an **Undead** interface that cannot be killed by
    normal means.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `UINTERFACE`/`IInterface` called `UKillable`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))` to the `UInterface`
    declaration.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the header file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Provide default implementations for the interface inside the implementation
    file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new `UINTERFACE`/`IInterface` called `Undead`. Modify them to inherit
    from `UKillable`/`IKillable`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ensure that you include the header defining the `Killable` interface.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some overrides and new method declarations to the new interface:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create implementations for the functions:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create two new `Actor` classes in C++: one called `Snail`, and the other called
    `Zombie`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Snail` class to implement the `IKillable` interface, and add the appropriate
    header file, `#include`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, set the `Zombie` class to implement `IUndead`, and `#include "Undead.h"`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the editor, and drag an instance of both `Zombie` and `Snail` into your
    level.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to each of them in the **Level Blueprints**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Die` (Message) on each reference.![How to do it...](img/00112.jpeg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution pins of the two message calls, then wire it up to `Event
    BeginPlay`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game, and then verify that the `Zombie` is disdainful of your efforts
    to kill it, but the `Snail` groans and then dies (is removed from the world outliner).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00113.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make it possible to test this recipe in the **Level Blueprints**, we need
    to make the interface functions callable via blueprint, so we need the `BlueprintCallable`
    specifier on our `UFUNCTION`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, in a `UInterface`, the compiler expects the interface to be implementable
    via both C++ and Blueprint by default. This conflicts with `BlueprintCallable`,
    which is merely saying that the function can be invoked from Blueprint, not that
    it can be overridden in it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can resolve the conflict by marking the interface as `CannotImplementInterfaceInBlueprint`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This enables the use of `BlueprintCallable` as our `UFUNCTION` specifier rather
    than `BlueprintImplementableEvent` (which has extra overhead due to the extra
    code allowing for the function to be overridden via Blueprint).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `IsDead` and `Die` as `virtual` to enable them to be overridden in
    another C++ class which inherits this one.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our default interface implementation, `IsDead` always returns `false`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default implementation of `Die` prints a death message to the screen, and
    then destroys the object implementing this interface if it is an `Actor`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a second interface called `Undead`, which inherits from `Killable`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `public UKillable`/`public IKillable` in the class declarations to
    express this.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, as a result, we need to include the header file that defines the
    `Killable` interface.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new interface overrides the two functions that `Killable` defines to provide
    more appropriate definitions of `IsDead`/`Die` for `Undead`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our overridden definitions have `Undead` already dead by returning `true` from
    `IsDead`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `Die` is called on `Undead`, we simply print a message with `Undead` laughing
    at our feeble attempt to kill it again, and do nothing.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also specify default implementations for our `Undead`-specific functions,
    namely `Turn()` and `Banish()`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `Undead` are Turned, they flee, and for demonstration purposes, we print
    a message to the screen.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an `Undead` is Banished, however, they are annihilated and destroyed without
    a trace.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to test our implementation, we create two `Actors` that each inherit
    from one of the two interfaces.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we add an instance of each actor to our level, we use **Level Blueprints**
    to access the level's `BeginPlay` event.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the level begins play, we use a message call to try and call the `Die`
    function on our instances.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The messages that print out are different, and correspond to the two function
    implementations showing that the Zombie's implementation of `Die` is different,
    and has overridden the Snail's.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding UInterface functions in C++
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One side effect of UInterfaces allowing inheritance in C++ is that we can override
    default implementations in subclasses as well as in Blueprint. This recipe shows
    you how to do so.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the recipe *Calling native UInterface functions from C++* in which a
    Physics Cube is created so that you have the class ready.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Interface called `Selectable`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the following functions inside `ISelectable`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Provide a default implementation for functions like this:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a class based on `APhysicsCube` called `SelectableCube`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include "Selectable.h"` inside the `SelectableCube` class'' header.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `ASelectableCube` declaration like this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following functions to the header:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the functions:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create a new class, called `NonSelectableCube`, which inherits from `SelectableCube`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NonSelectableCube` should override the functions from `SelectableInterface`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The implementation file should be altered to include the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Place an instance of `SelectableCube` into the level at a certain range above
    the ground, and play your game. You should get messages verifying that the actor
    is selectable, and that it has accepted the selection, when the cube hits the
    ground.![How to do it...](img/00114.jpeg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove `SelectableCube` and replace it with an instance of `NonSelectableCube`
    to see the alternative messages indicating that this actor isn't selectable, and
    has refused selection.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create three functions inside the `Selectable` interface.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IsSelectable` returns a Boolean to indicate if the object is selectable. You
    could avoid this and simply use `TrySelect`, given that it returns a Boolean value
    to indicate success, but, for example, you might want to know if the object inside
    your UI is a valid selection without having to actually try it.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TrySelect` actually attempts to select the object. There''s no explicit contract
    forcing users to respect `IsSelectable` when trying to select the object, so `TrySelect`
    is named to communicate that the selection may not always succeed.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, `Deselect` is a function added to allow objects to handle losing the
    player selection. This could involve changing the UI elements, halting sounds
    or other visual effects, or simply removing a selection outline from around the
    unit.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default implementations of the functions return `true` for `IsSelectable`
    (the default is for any object to be selectable), `true` for `TrySelect` (selection
    attempts always succeed), and issues a debug assert if `Deselect` is called without
    being implemented by the class.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could also implement `Deselect` as a pure `virtual` function if you wish.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SelectableCube` is a new class inheriting from `PhysicsCube`, but also implementing
    the `ISelectable` interface.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also overrides `NotifyHit`, a `virtual` function defined in `AActor` that
    triggers when the actor undergoes a **RigidBody** collision.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the constructor from `PhysicsCube` with the `Super()` constructor call
    inside the implementation of `SelectableCube`. We then add our own implementation,
    which calls `SetNotifyRigidBodyCollision(true)` on our static mesh instance. This
    is necessary, because by default, RigidBodies (such as `PrimitiveComponents` with
    a collision) don't trigger `Hit` events as a performance optimization. As a result,
    our overridden `NotifyHit` function would never be called.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`SelectableCube`的实现中使用`Super()`构造函数调用来调用`PhysicsCube`的构造函数。然后，我们添加我们自己的实现，它在我们的静态网格实例上调用`SetNotifyRigidBodyCollision(true)`。这是必要的，因为默认情况下，刚体（例如具有碰撞的`PrimitiveComponents`）不会触发`Hit`事件，以进行性能优化。因此，我们重写的`NotifyHit`函数将永远不会被调用。
- en: Within the implementation of `NotifyHit`, we call some of the `ISelectable`
    interface functions on ourselves. Given that we know we are an object that inherits
    from `ISelectable`, we don't need to cast to an `ISelectable*` in order to call
    them.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyHit`的实现中，我们在自身上调用了一些`ISelectable`接口函数。鉴于我们知道我们是从`ISelectable`继承的对象，我们无需转换为`ISelectable*`即可调用它们。
- en: We check to see if the object is selectable with `IsSelectable`, and if so,
    we try to actually perform the selection using `TrySelect`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`IsSelectable`来检查对象是否可选择，如果是，则尝试使用`TrySelect`来实际执行选择。
- en: '`NonSelectableCube` inherits from `SelectableCube`, so we can force the object
    to never be selectable.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NonSelectableCube`继承自`SelectableCube`，因此我们可以强制该对象永远不可选择。'
- en: We accomplish this by overriding the `ISelectable` interface functions again.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过再次重写`ISelectable`接口函数来实现这一点。
- en: Within `ANonSelectableCube::IsSelectable()`, we print a message to the screen
    so we can verify that the function is being called, and then return `false` to
    indicate that the object isn't selectable at all.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ANonSelectableCube::IsSelectable()`中，我们在屏幕上打印一条消息，以便我们可以验证该函数是否被调用，然后返回`false`以指示该对象根本不可选择。
- en: In case the user doesn't respect `IsSelectable()`, `ANonSelectableCube::TrySelect()`
    always returns `false` to indicate that the selection wasn't successful.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户不尊重`IsSelectable()`，`ANonSelectableCube::TrySelect()`始终返回`false`，以指示选择不成功。
- en: Given that it is impossible for `NonSelectableCube` to be selected, `Deselect()`
    calls `unimplemented()`, which throws an assert warning that the function was
    not implemented.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于不可能选择`NonSelectableCube`，`Deselect()`调用`unimplemented()`，这会引发一个断言警告，指出该函数未被实现。
- en: Now, when playing your scene, each time `SelectableCube`/`NonSelectableCube`
    hits another object, causing a RigidBody collision, the actor in question will
    attempt to select itself, and print messages to the screen.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在播放场景时，每当`SelectableCube`/`NonSelectableCube`撞击另一个物体，导致刚体碰撞时，相关的角色将尝试选择自己，并在屏幕上打印消息。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer [Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* which shows you how
    to **Raycast** from the mouse cursor into the game world to determine what is
    being clicked on, and could be used to extend this recipe to allow the player
    to click on items to select them
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第6章](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121 "第6章.输入和碰撞")，*输入和碰撞*，其中向您展示了如何**从鼠标光标向游戏世界进行射线投射**，并且可以用于扩展此示例以允许玩家点击物品进行选择
- en: Exposing UInterface methods to Blueprint from a native base class
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地基类向蓝图公开UInterface方法
- en: Being able to define `UInterface` methods in C++ is great, but they should be
    accessible from Blueprint too. Otherwise, designers or others who are using Blueprint
    won't be able to interact with your `UInterface`. This recipe shows you how to
    make a function from an interface callable within the Blueprint system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在C++中定义`UInterface`方法非常好，但它们也应该从蓝图中可访问。否则，使用蓝图的设计师或其他人将无法与您的`UInterface`进行交互。本示例向您展示了如何使接口中的函数在蓝图系统中可调用。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a `UInterface` called `UPostBeginPlay`/`IPostBeginPlay`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UPostBeginPlay`/`IPostBeginPlay`的`UInterface`。
- en: 'Add the following `virtual` method to `IPostBeginPlay`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`IPostBeginPlay`添加以下`virtual`方法：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Provide an implementation of the function:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供函数的实现：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create a new `Actor` class called `APostBeginPlayTest`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`APostBeginPlayTest`的新的`Actor`类。
- en: 'Modify the class declaration so that it also inherits `IPostBeginPlay`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类声明，使其还继承`IPostBeginPlay`：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile your project. Inside the editor, drag an instance of `APostBeginPlayTest`
    into your level. With the instance selected, click on **Open Level Blueprint**:![How
    to do it...](img/00115.jpeg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。在编辑器内，将`APostBeginPlayTest`的实例拖入您的级别中。选择该实例，单击**打开级别蓝图**：![如何做...](img/00115.jpeg)
- en: Inside the Level Blueprint, right-click and **Create a Reference to PostBeginPlayTest1**.![How
    to do it...](img/00116.jpeg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在级别蓝图内，右键单击并**创建对PostBeginPlayTest1的引用**。![如何做...](img/00116.jpeg)
- en: Drag away from the blue pin on the right-hand side of your actor reference,
    then search the context menu for `onpost` to see your new interface function available.
    Click on it to insert a call to your native `UInterface` implementation from Blueprint.![How
    to do it...](img/00117.jpeg)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从actor引用的右侧蓝色引脚拖动，然后在上下文菜单中搜索`onpost`，以查看您的新接口函数是否可用。单击它以在蓝图中插入对本机`UInterface`实现的调用。![如何做...](img/00117.jpeg)
- en: Finally, connect the execution pin (white arrow) from the `BeginPlay` node to
    the execution pin for `OnPostBeginPlay`.![How to do it...](img/00118.jpeg)
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`BeginPlay`节点的执行引脚（白色箭头）连接到`OnPostBeginPlay`的执行引脚。![如何做...](img/00118.jpeg)
- en: When you play your level, you should see the message **PostBeginPlay called**
    visible on screen for a short amount of time verifying that Blueprint has successfully
    accessed and called through to your native code implementation of the `UInterface`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放级别时，您应该看到屏幕上出现**PostBeginPlay called**的消息，验证蓝图已成功访问并调用了您的`UInterface`的本地代码实现。
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UINTERFACE`/`IInterface` pair function as in other recipes, with the `UInterface`
    containing reflection information and other data, and the `IInterface` functioning
    as the actual interface class that can be inherited from.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most significant element that allows the function inside `IInterface` to
    be exposed to Blueprint is the `UFUNCTION` specifier.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintCallable` marks this function as one that can be called from the
    Blueprint system.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any functions exposed to Blueprint in any way require a `Category` value also.
    This `Category` value specifies the heading under which the function will be listed
    in the context menu.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function must also be marked `virtual`—this is so that a class that implements
    the interface via native code can override the implementations of the functions
    inside it. Without the `virtual` specifier, the Unreal Header Tool will give you
    an error indicating that you have to either add `virtual`, or `BlueprintImplementableEvent`
    as a `UFUNCTION` specifier.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason for this is that without either of those, the interface function
    wouldn't be overridable in C++ (due to the absence of `virtual`), or Blueprint
    (because `BlueprintImplementableEvent` was missing). An interface that can't be
    overridden, but only inherited, has limited utility, so Epic have chosen not to
    support it within UInterfaces.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then provide a default implementation of the `OnPostBeginPlay` function,
    which uses the `GEngine` pointer to display a debug message confirming that the
    function was invoked.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* for a number of recipes showing how you can integrate your C++
    classes with Blueprint
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UInterface functions in Blueprint
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key advantages of UInterface in Unreal is the ability for users to
    implement `UInterface` functions in the editor. This means the interface can be
    implemented strictly in Blueprint without needing any C++ code, which is helpful
    to designers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `UInterface` called `AttackAvoider`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following function declaration to the header:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create a new **Blueprint Class** within the Editor:![How to do it...](img/00119.jpeg)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Base the class on **Actor**:![How to do it...](img/00120.jpeg)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Class Settings**:![How to do it...](img/00121.jpeg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the drop-down menu for **Implement Interface**, and select **AttackAvoider**:![How
    to do it...](img/00122.jpeg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compile** your blueprint:![How to do it...](img/00123.jpeg)'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the Event Graph, and type `event attack`. Within the **Context
    Sensitive** menu, you should see **Event Attack Incoming**. Select it to place
    an event node in your graph:![How to do it...](img/00124.jpeg)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out from the execution pin on the new node, and release. Type `print string`
    into the **Context Sensitive** menu to add a **Print String** node.![How to do
    it...](img/00125.jpeg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now implemented a `UInterface` function within Blueprint.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UINTERFACE`/`IInterface` are created in exactly the same way that we see
    in other recipes in this chapter.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we add a function to the interface, however, we use a new `UFUNCTION`
    specifier: `BlueprintImplementableEvent`.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintImplementableEvent` tells the Unreal Header Tool to generate code
    that creates an empty stub function that can be implemented by Blueprint. We do
    not need to provide a default C++ implementation for the function.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement the interface inside Blueprint, which exposes the function for
    us in a way that allows us to define its implementation in Blueprint.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The autogenerated code created by the header tool forwards the calls to the
    `UInterface` function to our Blueprint implementation.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following recipe shows you how to define a default implementation for your
    `UInterface` function in C++, then optionally override it in Blueprint if necessary
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ UInterface function implementations that can be overridden in Blueprint
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as with the previous recipe, UInterfaces are useful, but that utility is
    severely limited without their functionality being usable by designers.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The previous recipe shows you how to call C++ `UInterface` functions from Blueprint;
    this recipe will show you how to replace the implementation of a `UInterface`
    function with your own custom Blueprint-only function.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new interface called `Wearable` (`IWearable`, `UWearable`).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the header:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following function implementations in the implementation file:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a new `Actor` class called `Boots` inside the editor.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `#include "Wearable.h"` to the header file for `Boots`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class declaration as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following implementation of the pure `virtual` functions created by
    our Interface:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a new Blueprint class called `Gloves` based on `Actor`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class settings, select `Wearable` as the interface that the `Gloves`
    actor will implement.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `Gloves`, override the `OnEquip` function like this:![How to do it...](img/00126.jpeg)
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of both `Gloves` and `Boots` into your level for testing purposes.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following blueprint code to your level:![How to do it...](img/00127.jpeg)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that `Boots` performs the default behavior, but `Gloves` performs the
    blueprint-defined behavior.![How to do it...](img/00128.jpeg)
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses two `UFUNCTION` specifiers together: `BlueprintNativeEvent`
    and `BlueprintCallable`.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintCallable` has been shown in previous recipes, and is a way of marking
    your `UFUNCTION` as visible and invokable in the Blueprint Editor.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintNativeEvent` signifies a `UFUNCTION` that has a default C++ (native
    code) implementation, but is also overridable in Blueprint. It''s the combination
    of a virtual function along with `BlueprintImplementableEvent`.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for this mechanism to work, the Unreal Header Tool generates the body
    of your functions so that the Blueprint version of the function is called if it
    exists; otherwise, it dispatches the method call through to the native implementation.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to separate your default implementation from the dispatch functionality
    though, UHT defines a new function that takes its name from your declared function,
    but appends `_Implementation` to the end.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is why the header file declares `GetStrengthRequirement`, but has no implementation,
    because that is autogenerated.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is also why your implementation file defines `GetStrengthRequirement_Implementation`,
    but there is no declaration for it, because it is also autogenerated.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Boots` class implements `IWearable`, but doesn't override the default functionality.
    However, because the `_Implementation` functions are defined as `virtual`, we
    still need to explicitly implement the interface functions, and then call the
    default implementation directly.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In contrast, `Gloves` also implements `IWearable`, but has an overridden implementation
    for `OnEquip` defined in Blueprint.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This can be verified when we use **Level Blueprints** to call `OnEquip` for
    the two actors.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling Blueprint-defined interface functions from C++
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the previous recipes have focused on C++ being usable in Blueprint, such
    as being able to call functions from C++ in Blueprint, and override C++ functions
    with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined
    interface function from C++.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `UInterface` called `UTalker`/`ITalker`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UFUNCTION` implementation:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Provide a default empty implementation inside the `.cpp` file:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a new class based on `StaticMeshActor`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `#include` and modify the class declaration to include the talker interface:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Also, add the following function to the class declaration:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within the implementation, add the following to the constructor:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create a new class based on `DefaultPawn` to function as our player character.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some `UPROPERTY`/`UFUNCTION` to our class header:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Modify the constructor:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement `OnTalkOverlap`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a new `GameMode`, and set `TalkingPawn` as the default pawn class for
    the player.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of your `ATalkingMesh` class into the level.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blueprint class based on `ATalkingMesh` by right-clicking on it,
    and selecting the appropriate option from the context menu:![How to do it...](img/00129.jpeg)
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `MyTalkingMesh`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the blueprint editor, create an implementation for `StartTalking` like
    this:![How to do it...](img/00130.jpeg)
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of your new Blueprint into the level beside your `ATalkingMesh`
    instance.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walk up to the two actors, and verify that your custom Pawn is correctly invoking
    either the default C++ implementation or the Blueprint implementation, as appropriate.![How
    to do it...](img/00131.jpeg)
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we create a new interface, and then add some function definitions
    to the `IInterface` class.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `BlueprintNativeEvent` specifier to indicate that we want to declare
    a default implementation in C++ that can then be overridden in Blueprint.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new class (inheriting from `StaticMeshActor` for convenience), and
    implement the interface on it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation of the new class constructor, we load a static mesh, and
    set our collision as usual.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add an implementation for our interface function, which simply prints
    a message to the screen.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you were using this in a full-blown project, you could play animations, play
    audio, alter the user interface, and whatever else was necessary to start a conversation
    with your `Talker`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, though, we don't have anything to actually call `StartTalking`
    on our `Talker`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simplest way to implement this is to create a new `Pawn` subclass (again,
    inheriting from `DefaultPawn` for convenience) that can start talking to any `Talker`
    actors that it collides with.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for this to work, we create a new `BoxComponent` to establish the radius
    at which we will trigger a conversation.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, it is a `UPROPERTY`, so it won't get garbage collected.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create the definition for a function that will get triggered when the
    new `BoxComponent` overlaps another `Actor` in the scene.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor for our `TalkingPawn` initializes the new `BoxComponent`, and
    sets its extents appropriately.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor also binds the `OnTalkOverlap` function as an event handler
    to handle collisions with our `BoxComponent`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also attaches the box component to our `RootComponent` so that it moves with
    the rest of the player character as the player moves around the level.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `OnTalkOverlap`, we need to check if the other actor, which is overlapping
    our box, implements the `Talker` interface.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most reliable way to do this is with the `ImplementsInterface` function
    in `UClass`. This function uses the class information generated by the Unreal
    Header Tool during compilation, and correctly handles both C++ and Blueprint-implemented
    interfaces.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the function returns `true`, we can use a special autogenerated function
    contained in our `IInterface` to invoke the interface method of our choice on
    our instance.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a static method of the form `<IInterface>::Execute_<FunctionName>`.
    In our instance, our `IInterface` is `ITalker`, and the function is `StartTalking`,
    so the function we want to invoke is `ITalker::Execute_StartTalking()`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason we need this function is that when an interface is implemented in
    Blueprint, the relationship isn't actually established at compile time. C++ is,
    therefore, not aware of the fact that the interface is implemented, and so we
    can't cast the Blueprint class to `IInterface` to call functions directly.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Execute_` functions take a pointer to the object that implements the interface,
    and call a number of internal methods to invoke the desired function's Blueprint
    implementation.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play the level, and walk around, the custom `Pawn` is constantly receiving
    notifications when it's `BoxComponent` overlaps other objects.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they implement the `UTalker`/`ITalker` interface, the pawn then tries to
    invoke `StartTalking` on the `Actor` instance in question, which then prints the
    appropriate message on screen.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a simple interaction system with UInterfaces
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to combine a number of other recipes in this chapter
    to demonstrate a simple interaction system, and a door with an interactable doorbell
    to cause the door to open.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new interface, `Interactable`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the `IInteractable` class declaration:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create default implementations for both functions in the implementation file:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a second interface, `Openable`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this function to its declaration:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As with `Interactable`, create a default implementation for the `Open` function:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a new class, based on `StaticMeshActor`, called `DoorBell`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include "Interactable.h"` in `DoorBell.h`, and add the following functions
    to the class declaration:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the `.cpp` file for `DoorBell`, `#include "Openable.h"`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load a static mesh for our `DoorBell` in the constructor:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following function implementations to implement the `Interactable`
    interface on our `DoorBell`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now create a new `StaticMeshActor`-based class called `Door`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include` the Openable and Interactable interfaces into the class header,
    then modify Door''s declaration:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the interface functions to `Door`:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As with `DoorBell`, in the `Door` constructor, initialize our mesh component,
    and load a model in:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Implement the interface functions:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create a new `DefaultPawn`-based class called `AInteractingPawn`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the `Pawn` class header:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside the implementation file for the `Pawn`, `#include "Interactable.h"`,
    and then provide implementations for both functions from the header:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, either create a new `GameMode` in C++ or Blueprint, and set `InteractingPawn`
    as our default `Pawn` class.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of both `Door` and `Doorbell` into the level:![How to do it...](img/00132.jpeg)
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the eyedropper beside doorbell's **Door to Open**, as shown in the following
    screenshot, then click on the door actor instance in your level:![How to do it...](img/00133.jpeg)![How
    to do it...](img/00134.jpeg)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Action binding in the editor called `Interact`**,** and bind it
    to a key of your choice:![How to do it...](img/00135.jpeg)
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level, and walk up to the doorbell. Look at it, and press whatever
    key you bound `Interact` with. Verify that the door moves once.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also interact with the door directly to receive some information about
    it.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in previous recipes, we mark `UFUNCTION` as `BlueprintNativeEvent` and `BlueprintCallable`
    in order to allow the `UInterface` to be implemented in either native code or
    Blueprint, and allow the functions to be called with either method.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `DoorBell` based on `StaticMeshActor` for convenience, and have `DoorBell`
    implement the `Interactable` interface.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the constructor for `DoorBell`, we initialize `HasBeenPushed` and `DoorToOpen`
    to the default safe values.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the implementation for `CanInteract`, we return the inverse of `HasBeenPushed`
    so that once the button has been pushed it, can't be interacted with.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `PerformInteract`, we check if we have a reference to a door object to
    open.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have a valid reference, we verify that the door actor implements `Openable`,
    then we invoke the `Open` function on our door.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `Door`, we implement both `Interactable` and `Openable`, and override
    the functions from each.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Door` implementation of `CanInteract` to be the same as the default.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `PerformInteract`, we display a message to the user.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `Open`, we use `AddActorLocalOffset` to move the door a certain distance
    away. With Timeline in Blueprint or a linear interpolation, we could make this
    transition smooth rather than a teleport.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we create a new `Pawn` so that the player can actually interact with
    objects.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `TryInteract` function, which we bind to the `Interact` input action
    in the overridden `SetupPlayerInputComponent` function.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that when the player performs the input that is bound to `Interact`,
    our `TryInteract` function will run.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TryInteract` gets a reference to `PlayerController`, casting the generic controller
    reference that all Pawns have.'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayerCameraManager` is retrieved through `PlayerController`, so we can access
    the current location and rotation of the player camera.'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create start and end points using the camera's location, then 100 units in
    the forward direction away from the camera's location, and pass those into `GetWorld::SweepSingleByObjectType`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function takes in a number of parameters. `HitResult` is a variable that
    allows the function to return information about any object hit by the trace. `CollisionObjectQueryParams`
    allows us to specify if we are interested in dynamic, static items, or both.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We accomplish a sphere trace by passing the shape in using the `MakeSphere`
    function.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sphere traces allow for slightly more human error by defining a cylinder to
    check for objects rather than a straight line. Given that the players might not
    look exactly at your object, you can tweak the sphere's radius as appropriate.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final parameter, `SweepSingleByObjectType`, is a struct that gives the trace
    a name, lets us specify if we are colliding against complex collision geometry,
    and most importantly, allows us to specify that we want to ignore the object which
    is initiating the trace.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `HitResult` contains an actor after the trace is done, we check if the actor
    implements our interface, then attempt to call `CanInteract` on it.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the actor indicates yes, it can be interacted with, so we then tell it to
    actually perform the interaction.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
