- en: Chapter 7. Communication between Classes and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter shows you how to write your own UInterfaces, and demonstrates
    how to take advantage of them within C++ to minimize class coupling and help keep
    your code clean. The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `UInterface`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a `UInterface` on an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if a class implements a `UInterface`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to a `UInterface` implemented in native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling native `UInterface` functions from C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting `UInterface` from one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding `UInterface` functions in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing `UInterface` methods to Blueprint from a native base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `UInterface` functions in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ `UInterface` function implementations that can be overridden in
    Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Blueprint-defined interface functions from C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple interaction system with UInterfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your game projects, you will sometimes require a series of potentially disparate
    objects to share a common functionality, but it would be inappropriate to use
    inheritance, because there is no "is-a" relationship between the different objects
    in question. Languages such as C++ tend to use multiple inheritance to solve this
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: However, in Unreal, if you wanted functions from both the parent classes to
    be accessible to Blueprint, you would need to make both of them `UCLASS`. This
    is a problem for two reasons. Inheriting from `UClass` twice in the same object
    would break the concept that `UObject` should form a neatly traversable hierarchy.
    It also means that there are two instances of the `UClass` methods on the object,
    and they would have to be explicitly differentiated between within the code. The
    Unreal codebase solves this issue by borrowing a concept from C#—that of an explicit
    Interface type.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using this approach, instead of composition, is that Components
    are only available on Actors, not on UObjects in general. Interfaces can be applied
    to any `UObject`. Furthermore, it means that we are no longer modeling an "is-a"
    relationship between the object and the component; instead, it would only be able
    to represent "has-a" relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UInterface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UInterfaces are a pair of classes that work together to enable classes to exhibit
    polymorphic behavior among multiple class hierarchies. This recipe shows you the
    basic steps involved in creating a `UInterface` purely in code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UInterfaces don't show up inside the main class wizard within Unreal, so we'll
    need to add the class manually using Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right click on your Source folder inside **Solution Explorer,** and select **Add**
    | **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a `.h` file to start, and name it `MyInterface.h.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you change the directory for the item to be placed in from Intermediate
    to Source/ProjectName.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to create a new header file in your project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the steps in order to create `MyInterface.cpp` as your implementation
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the class with this code in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project to verify that the code was written without errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UInterfaces are implemented as a pair of classes declared in the interface's
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, because we are leveraging Unreal's reflection system, we need to
    include our generated header file. Refer to *Handling events implemented via virtual
    functions* in [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with classes that inherit from `UObject`, which uses `UCLASS`, we need to
    use the `UINTERFACE` macro to declare our new `UInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is tagged `UE4COOKBOOK_API` to help with the exporting of library
    symbols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base class for the `UObject` portion of the interface is `UInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like `UCLASS` types, we require a macro to be placed inside the body of
    our class so that the auto-generated code is inserted into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That macro is `GENERATED_BODY()` for UInterfaces. The macro must be placed at
    the very start of the class body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second class is also tagged `UE4COOKBOOK_API`, and is named in a specific
    way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `UInterface`-derived class and the standard class have the same
    name but a different prefix. The `UInterface`-derived class has the prefix `U`,
    and the standard class has the prefix `I`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is important as this is how the Unreal Header Tool expects the classes
    to be named for the code it generates to work properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The plain native Interface class requires its own autogenerated content, which
    we include using the `GENERATED_BODY()` macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare functions that classes inheriting the interface should implement
    inside `IInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the implementation file, we implement the constructor for our `UInterface`,
    as it is declared by the Unreal Header Tool, and requires an implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create a default implementation for our `GetTestName()` function. Without
    this, the linking phase of compilation will fail. This default implementation
    uses the `unimplemented()` macro, which will issue a debug assert when the line
    of code is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to *Passing payload data with a delegate binding* in [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*;
    the first recipe, in particular, explains some of the principles that we've applied
    here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UInterface on an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you've followed the previous recipe in order to have a `UInterface`
    ready to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class using the Unreal Wizard, called `SingleInterfaceActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `IInterface`—in this case, `IMyInterface`—to the public inheritance list
    for our new `Actor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `override` declaration to the class for the `IInterface` function(s)
    that we wish to override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the overridden function in the implementation file by adding the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ uses multiple inheritance for the way it implements interfaces, so we leverage
    that mechanism here with the declaration of our `SingleInterfaceActor` class,
    where we add `public IMyInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We inherit from `IInterface` rather than `UInterface` to prevent `SingleInterfaceActor`
    from inheriting two copies of `UObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that the interface declares a `virtual` function, we need to redeclare
    that function with the override specifier if we wish to implement it ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our implementation file, we implement our overridden `virtual` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our function override, for demonstration purposes, we call the base `IInterface`
    implementation of the function. Alternatively, we could write our own implementation,
    and avoid calling the base class one altogether.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use `IInterface:: specifier` rather than `Super`, because `Super` refers
    to the `UClass` that is the parent of our class, and IInterfaces aren''t UClasses
    (hence, no `U` prefix).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can implement a second, or multiple, IInterfaces on your object, as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking if a class implements a UInterface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the first two recipes so that you have a `UInterface` we can check for,
    and a class implementing the interface, which can be tested against.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your Game Mode implementation, add the following code to the `BeginPlay`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Given that we are referencing both `ASingleInterfaceActor` and `IMyInterface`,
    we need to `#include` both `MyInterface.h` and `SingleInterfaceActor.h` in our
    Source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we create an empty `FTransform` function, which has the
    default value of `0` for all translation and rotation components, so we don't
    need to explicitly set any of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use the `SpawnActor` function from `UWorld` so that we can create an
    instance of our `SingleActorInterface`, storing the pointer to the instance into
    a temporary variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `GetClass()` on our instance to get a reference to its associated
    `UClass`. We need a reference to `UClass,` because that object is the one which
    holds all of the reflection data for the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reflection data includes the names and types of all `UPROPERTY` on the object,
    the inheritance hierarchy for the object, and a list of all the interfaces that
    it implements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we can call `ImplementsInterface()` on `UClass`, and it will return
    `true` if the object implements the `UInterface` in question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the object implements the interface, and therefore, returns `true` from `ImplementsInterface`,
    we then print a message to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    has a number of recipes relating to the spawning of actors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to a UInterface implemented in native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One advantage that UInterfaces provides you with as a developer is the ability
    to treat a collection of heterogeneous objects that implement a common interface
    as a collection of the same object, using `Cast< >` to handle the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that this won't work if your class implements the interface through
    a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have a `UInterface`, and an `Actor` implementing the interface ready
    for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new game mode using the wizard within Unreal, or optionally, reuse
    a project and `GameMode` from a previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your game mode''s declaration, and add a new `UPROPERTY() macro` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Add `#include "MyInterface.h"` to the header's include section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following within the game mode''s `BeginPlay` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Set the level's game mode override to your game mode, then drag a few instances
    of your custom Interface-implementing actor into the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play your level, a message should be printed on screen that indicates
    the number of instances of the interface that have been implemented in Actors
    in the level:![How to do it...](img/00110.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create an array of pointers to `MyInterface` implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we use `TActorIterator<AActor>` to get all of the `Actor`
    instances in our level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TActorIterator` has the following constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`TActorIterator` expects a world to act on as well as a `UClass` instance to
    specify what type of Actors we are interested in.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ActorIterator` is an iterator like the STL iterator type. This means we can
    write a `for` loop of the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside the loop, we dereference the iterator to get an `Actor` pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then attempt to cast it to our interface; this will return a pointer to the
    interface if it does implement it, else it will return `nullptr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we can check if the interface pointer is `null`, and if not, we
    can add the interface pointer reference to our array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, once we've iterated through all the actors in `TActorIterator`, we
    can display a message on the screen, which displays the count of items that implemented
    the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling native UInterface functions from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the previous recipe to get an understanding of casting an `Actor` pointer
    to an Interface pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that as this recipe relies on the casting technique used in the previous
    recipe, it will only work with objects that implement the interface using C++
    rather than Blueprint. This is because Blueprint classes are not available at
    compile time, and so, technically, don't inherit the interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class using the editor wizard. Call it `AntiGravityVolume`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `BoxComponent` to the new `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the following `Actor` `virtual` functions in the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an implementation within your source file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `BoxComponent` in your constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create an interface called `GravityObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `virtual` functions to `IGravityObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the default implementation of the `virtual` functions inside the `IGravityObject`
    implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create a subclass of `Actor` called `PhysicsCube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a static mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the component in your constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To have `PhysicsCube` implement `GravityObject`, first `#include "GravityObject.h"`
    in the header file, then modify the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new level, and place an instance of our gravity volume in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an instance of `PhysicsCube` above the gravity volume, then rotate it
    slightly so that it has one corner lower than the others, as shown in the following
    image:![How to do it...](img/00111.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the gravity is turned off on the object when it enters the volume,
    then turns back on again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the gravity volume doesn't need to know anything about your `PhysicsCube`
    actor, just the Gravity Object interface.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a new `Actor` class, and add a box component to give the actor something
    that will collide with the character. Alternatively, you could subclass `AVolume`
    if you wanted to use the BSP functionality to define the volume's shape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NotifyActorBeginOverlap` and `NotifyActorEndOverlap` are overridden so that
    we can perform some operation when an object enters or leaves the `AntiGravityVolume`
    area.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `NotifyActorBeginOverlap` implementation, we attempt to cast the object
    that overlapped us into an `IGravityObject` pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tests if the object in question implements the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pointer is valid, then the object does implement the interface, so it
    is safe to use the interface pointer to call interface methods on the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we are inside `NotifyActorBeginOverlap`, we want to disable the gravity
    on the object, so we call `DisableGravity()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `NotifyActorEndOverlap`, we perform the same check, but we re-enable
    gravity on the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the default implementation of `DisableGravity`, we cast our own pointer
    (the `this` pointer) to `AActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to confirm that the interface has been implemented only on the
    `Actor` subclasses as well as to call methods defined in `AActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pointer is valid, we know we are an `Actor`, so we can use `GetComponents<class
    ComponentType>()` to get a `TArray` of all components of a specific type from
    ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetComponents` is a `template` function. It expects some template parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since the 2014 version of the standard, C++ supports compile-time deduction
    of template parameters. This means that we don't need to actually specify the
    template parameters when we call the function if the compiler can work them out
    from the normal function parameters that we provide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default implementation of `TArray` is `template<typename T, typename Allocator
    = FDefaultAllocator>` class `TArray;`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that we don't need to specify an allocator by default, so we just
    use `TArray<UPrimitiveComponent*>` when we declare the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `TArray` is passed into the `GetComponents` function, the compiler knows
    it is actually `TArray<UPrimitiveComponent*, FDefaultAllocator>`, and it is able
    to fill in the template parameters `T` and `AllocatorType` with `UPrimitiveComponent`
    and `FDefaultAllocator`, so neither of those are required as template parameters
    for the function's invocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetComponents` iterates through the components that `Actor` has, and any components
    that inherit from `typename T` have pointers to them stored inside the `PrimitiveComponents`
    array.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a range-based `for` loop, another new feature of C++, we can iterate over
    the components that the function placed into our `TArray` without needing to use
    the traditional `for` loop structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of the components has `SetEnableGravity(false)` called on them, which disables
    gravity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, the `EnableGravity` function iterates over all the primitive components
    contained in the actor, and enables gravity with `SetEnableGravity(true)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components,* for extensive discussions
    on Actors and Components. [Chapter 5,](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates") *Handling Events and Delegates,* discusses
    events such as `NotifyActorOverlap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting UInterface from one another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may need to create a `UInterface` that specializes on a more
    general `UInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to use inheritance with UInterfaces to specialize
    a **Killable** interface with an **Undead** interface that cannot be killed by
    normal means.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `UINTERFACE`/`IInterface` called `UKillable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))` to the `UInterface`
    declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide default implementations for the interface inside the implementation
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `UINTERFACE`/`IInterface` called `Undead`. Modify them to inherit
    from `UKillable`/`IKillable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you include the header defining the `Killable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some overrides and new method declarations to the new interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create implementations for the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two new `Actor` classes in C++: one called `Snail`, and the other called
    `Zombie`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Snail` class to implement the `IKillable` interface, and add the appropriate
    header file, `#include`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, set the `Zombie` class to implement `IUndead`, and `#include "Undead.h"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the editor, and drag an instance of both `Zombie` and `Snail` into your
    level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to each of them in the **Level Blueprints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Die` (Message) on each reference.![How to do it...](img/00112.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution pins of the two message calls, then wire it up to `Event
    BeginPlay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game, and then verify that the `Zombie` is disdainful of your efforts
    to kill it, but the `Snail` groans and then dies (is removed from the world outliner).
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make it possible to test this recipe in the **Level Blueprints**, we need
    to make the interface functions callable via blueprint, so we need the `BlueprintCallable`
    specifier on our `UFUNCTION`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, in a `UInterface`, the compiler expects the interface to be implementable
    via both C++ and Blueprint by default. This conflicts with `BlueprintCallable`,
    which is merely saying that the function can be invoked from Blueprint, not that
    it can be overridden in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can resolve the conflict by marking the interface as `CannotImplementInterfaceInBlueprint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This enables the use of `BlueprintCallable` as our `UFUNCTION` specifier rather
    than `BlueprintImplementableEvent` (which has extra overhead due to the extra
    code allowing for the function to be overridden via Blueprint).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `IsDead` and `Die` as `virtual` to enable them to be overridden in
    another C++ class which inherits this one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our default interface implementation, `IsDead` always returns `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default implementation of `Die` prints a death message to the screen, and
    then destroys the object implementing this interface if it is an `Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a second interface called `Undead`, which inherits from `Killable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `public UKillable`/`public IKillable` in the class declarations to
    express this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, as a result, we need to include the header file that defines the
    `Killable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new interface overrides the two functions that `Killable` defines to provide
    more appropriate definitions of `IsDead`/`Die` for `Undead`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our overridden definitions have `Undead` already dead by returning `true` from
    `IsDead`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `Die` is called on `Undead`, we simply print a message with `Undead` laughing
    at our feeble attempt to kill it again, and do nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also specify default implementations for our `Undead`-specific functions,
    namely `Turn()` and `Banish()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `Undead` are Turned, they flee, and for demonstration purposes, we print
    a message to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an `Undead` is Banished, however, they are annihilated and destroyed without
    a trace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to test our implementation, we create two `Actors` that each inherit
    from one of the two interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we add an instance of each actor to our level, we use **Level Blueprints**
    to access the level's `BeginPlay` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the level begins play, we use a message call to try and call the `Die`
    function on our instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The messages that print out are different, and correspond to the two function
    implementations showing that the Zombie's implementation of `Die` is different,
    and has overridden the Snail's.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding UInterface functions in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One side effect of UInterfaces allowing inheritance in C++ is that we can override
    default implementations in subclasses as well as in Blueprint. This recipe shows
    you how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the recipe *Calling native UInterface functions from C++* in which a
    Physics Cube is created so that you have the class ready.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Interface called `Selectable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the following functions inside `ISelectable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a default implementation for functions like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Create a class based on `APhysicsCube` called `SelectableCube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include "Selectable.h"` inside the `SelectableCube` class'' header.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `ASelectableCube` declaration like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following functions to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class, called `NonSelectableCube`, which inherits from `SelectableCube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NonSelectableCube` should override the functions from `SelectableInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation file should be altered to include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Place an instance of `SelectableCube` into the level at a certain range above
    the ground, and play your game. You should get messages verifying that the actor
    is selectable, and that it has accepted the selection, when the cube hits the
    ground.![How to do it...](img/00114.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove `SelectableCube` and replace it with an instance of `NonSelectableCube`
    to see the alternative messages indicating that this actor isn't selectable, and
    has refused selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create three functions inside the `Selectable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IsSelectable` returns a Boolean to indicate if the object is selectable. You
    could avoid this and simply use `TrySelect`, given that it returns a Boolean value
    to indicate success, but, for example, you might want to know if the object inside
    your UI is a valid selection without having to actually try it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TrySelect` actually attempts to select the object. There''s no explicit contract
    forcing users to respect `IsSelectable` when trying to select the object, so `TrySelect`
    is named to communicate that the selection may not always succeed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, `Deselect` is a function added to allow objects to handle losing the
    player selection. This could involve changing the UI elements, halting sounds
    or other visual effects, or simply removing a selection outline from around the
    unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default implementations of the functions return `true` for `IsSelectable`
    (the default is for any object to be selectable), `true` for `TrySelect` (selection
    attempts always succeed), and issues a debug assert if `Deselect` is called without
    being implemented by the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could also implement `Deselect` as a pure `virtual` function if you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SelectableCube` is a new class inheriting from `PhysicsCube`, but also implementing
    the `ISelectable` interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also overrides `NotifyHit`, a `virtual` function defined in `AActor` that
    triggers when the actor undergoes a **RigidBody** collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the constructor from `PhysicsCube` with the `Super()` constructor call
    inside the implementation of `SelectableCube`. We then add our own implementation,
    which calls `SetNotifyRigidBodyCollision(true)` on our static mesh instance. This
    is necessary, because by default, RigidBodies (such as `PrimitiveComponents` with
    a collision) don't trigger `Hit` events as a performance optimization. As a result,
    our overridden `NotifyHit` function would never be called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the implementation of `NotifyHit`, we call some of the `ISelectable`
    interface functions on ourselves. Given that we know we are an object that inherits
    from `ISelectable`, we don't need to cast to an `ISelectable*` in order to call
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check to see if the object is selectable with `IsSelectable`, and if so,
    we try to actually perform the selection using `TrySelect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NonSelectableCube` inherits from `SelectableCube`, so we can force the object
    to never be selectable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We accomplish this by overriding the `ISelectable` interface functions again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `ANonSelectableCube::IsSelectable()`, we print a message to the screen
    so we can verify that the function is being called, and then return `false` to
    indicate that the object isn't selectable at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case the user doesn't respect `IsSelectable()`, `ANonSelectableCube::TrySelect()`
    always returns `false` to indicate that the selection wasn't successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that it is impossible for `NonSelectableCube` to be selected, `Deselect()`
    calls `unimplemented()`, which throws an assert warning that the function was
    not implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when playing your scene, each time `SelectableCube`/`NonSelectableCube`
    hits another object, causing a RigidBody collision, the actor in question will
    attempt to select itself, and print messages to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer [Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* which shows you how
    to **Raycast** from the mouse cursor into the game world to determine what is
    being clicked on, and could be used to extend this recipe to allow the player
    to click on items to select them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing UInterface methods to Blueprint from a native base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to define `UInterface` methods in C++ is great, but they should be
    accessible from Blueprint too. Otherwise, designers or others who are using Blueprint
    won't be able to interact with your `UInterface`. This recipe shows you how to
    make a function from an interface callable within the Blueprint system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `UInterface` called `UPostBeginPlay`/`IPostBeginPlay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `virtual` method to `IPostBeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide an implementation of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Actor` class called `APostBeginPlayTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class declaration so that it also inherits `IPostBeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project. Inside the editor, drag an instance of `APostBeginPlayTest`
    into your level. With the instance selected, click on **Open Level Blueprint**:![How
    to do it...](img/00115.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the Level Blueprint, right-click and **Create a Reference to PostBeginPlayTest1**.![How
    to do it...](img/00116.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag away from the blue pin on the right-hand side of your actor reference,
    then search the context menu for `onpost` to see your new interface function available.
    Click on it to insert a call to your native `UInterface` implementation from Blueprint.![How
    to do it...](img/00117.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the execution pin (white arrow) from the `BeginPlay` node to
    the execution pin for `OnPostBeginPlay`.![How to do it...](img/00118.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play your level, you should see the message **PostBeginPlay called**
    visible on screen for a short amount of time verifying that Blueprint has successfully
    accessed and called through to your native code implementation of the `UInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UINTERFACE`/`IInterface` pair function as in other recipes, with the `UInterface`
    containing reflection information and other data, and the `IInterface` functioning
    as the actual interface class that can be inherited from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most significant element that allows the function inside `IInterface` to
    be exposed to Blueprint is the `UFUNCTION` specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintCallable` marks this function as one that can be called from the
    Blueprint system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any functions exposed to Blueprint in any way require a `Category` value also.
    This `Category` value specifies the heading under which the function will be listed
    in the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function must also be marked `virtual`—this is so that a class that implements
    the interface via native code can override the implementations of the functions
    inside it. Without the `virtual` specifier, the Unreal Header Tool will give you
    an error indicating that you have to either add `virtual`, or `BlueprintImplementableEvent`
    as a `UFUNCTION` specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason for this is that without either of those, the interface function
    wouldn't be overridable in C++ (due to the absence of `virtual`), or Blueprint
    (because `BlueprintImplementableEvent` was missing). An interface that can't be
    overridden, but only inherited, has limited utility, so Epic have chosen not to
    support it within UInterfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then provide a default implementation of the `OnPostBeginPlay` function,
    which uses the `GEngine` pointer to display a debug message confirming that the
    function was invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* for a number of recipes showing how you can integrate your C++
    classes with Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UInterface functions in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key advantages of UInterface in Unreal is the ability for users to
    implement `UInterface` functions in the editor. This means the interface can be
    implemented strictly in Blueprint without needing any C++ code, which is helpful
    to designers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `UInterface` called `AttackAvoider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following function declaration to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Create a new **Blueprint Class** within the Editor:![How to do it...](img/00119.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Base the class on **Actor**:![How to do it...](img/00120.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Class Settings**:![How to do it...](img/00121.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the drop-down menu for **Implement Interface**, and select **AttackAvoider**:![How
    to do it...](img/00122.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compile** your blueprint:![How to do it...](img/00123.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the Event Graph, and type `event attack`. Within the **Context
    Sensitive** menu, you should see **Event Attack Incoming**. Select it to place
    an event node in your graph:![How to do it...](img/00124.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out from the execution pin on the new node, and release. Type `print string`
    into the **Context Sensitive** menu to add a **Print String** node.![How to do
    it...](img/00125.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now implemented a `UInterface` function within Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UINTERFACE`/`IInterface` are created in exactly the same way that we see
    in other recipes in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we add a function to the interface, however, we use a new `UFUNCTION`
    specifier: `BlueprintImplementableEvent`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintImplementableEvent` tells the Unreal Header Tool to generate code
    that creates an empty stub function that can be implemented by Blueprint. We do
    not need to provide a default C++ implementation for the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement the interface inside Blueprint, which exposes the function for
    us in a way that allows us to define its implementation in Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The autogenerated code created by the header tool forwards the calls to the
    `UInterface` function to our Blueprint implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following recipe shows you how to define a default implementation for your
    `UInterface` function in C++, then optionally override it in Blueprint if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ UInterface function implementations that can be overridden in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as with the previous recipe, UInterfaces are useful, but that utility is
    severely limited without their functionality being usable by designers.
  prefs: []
  type: TYPE_NORMAL
- en: The previous recipe shows you how to call C++ `UInterface` functions from Blueprint;
    this recipe will show you how to replace the implementation of a `UInterface`
    function with your own custom Blueprint-only function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new interface called `Wearable` (`IWearable`, `UWearable`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementations in the implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Actor` class called `Boots` inside the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `#include "Wearable.h"` to the header file for `Boots`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class declaration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following implementation of the pure `virtual` functions created by
    our Interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Blueprint class called `Gloves` based on `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class settings, select `Wearable` as the interface that the `Gloves`
    actor will implement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `Gloves`, override the `OnEquip` function like this:![How to do it...](img/00126.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of both `Gloves` and `Boots` into your level for testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following blueprint code to your level:![How to do it...](img/00127.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that `Boots` performs the default behavior, but `Gloves` performs the
    blueprint-defined behavior.![How to do it...](img/00128.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses two `UFUNCTION` specifiers together: `BlueprintNativeEvent`
    and `BlueprintCallable`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintCallable` has been shown in previous recipes, and is a way of marking
    your `UFUNCTION` as visible and invokable in the Blueprint Editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintNativeEvent` signifies a `UFUNCTION` that has a default C++ (native
    code) implementation, but is also overridable in Blueprint. It''s the combination
    of a virtual function along with `BlueprintImplementableEvent`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for this mechanism to work, the Unreal Header Tool generates the body
    of your functions so that the Blueprint version of the function is called if it
    exists; otherwise, it dispatches the method call through to the native implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to separate your default implementation from the dispatch functionality
    though, UHT defines a new function that takes its name from your declared function,
    but appends `_Implementation` to the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is why the header file declares `GetStrengthRequirement`, but has no implementation,
    because that is autogenerated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is also why your implementation file defines `GetStrengthRequirement_Implementation`,
    but there is no declaration for it, because it is also autogenerated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Boots` class implements `IWearable`, but doesn't override the default functionality.
    However, because the `_Implementation` functions are defined as `virtual`, we
    still need to explicitly implement the interface functions, and then call the
    default implementation directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In contrast, `Gloves` also implements `IWearable`, but has an overridden implementation
    for `OnEquip` defined in Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This can be verified when we use **Level Blueprints** to call `OnEquip` for
    the two actors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling Blueprint-defined interface functions from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the previous recipes have focused on C++ being usable in Blueprint, such
    as being able to call functions from C++ in Blueprint, and override C++ functions
    with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined
    interface function from C++.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `UInterface` called `UTalker`/`ITalker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UFUNCTION` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a default empty implementation inside the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class based on `StaticMeshActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `#include` and modify the class declaration to include the talker interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following function to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the implementation, add the following to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class based on `DefaultPawn` to function as our player character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some `UPROPERTY`/`UFUNCTION` to our class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `OnTalkOverlap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `GameMode`, and set `TalkingPawn` as the default pawn class for
    the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of your `ATalkingMesh` class into the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blueprint class based on `ATalkingMesh` by right-clicking on it,
    and selecting the appropriate option from the context menu:![How to do it...](img/00129.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `MyTalkingMesh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the blueprint editor, create an implementation for `StartTalking` like
    this:![How to do it...](img/00130.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of your new Blueprint into the level beside your `ATalkingMesh`
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walk up to the two actors, and verify that your custom Pawn is correctly invoking
    either the default C++ implementation or the Blueprint implementation, as appropriate.![How
    to do it...](img/00131.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we create a new interface, and then add some function definitions
    to the `IInterface` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `BlueprintNativeEvent` specifier to indicate that we want to declare
    a default implementation in C++ that can then be overridden in Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new class (inheriting from `StaticMeshActor` for convenience), and
    implement the interface on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation of the new class constructor, we load a static mesh, and
    set our collision as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add an implementation for our interface function, which simply prints
    a message to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you were using this in a full-blown project, you could play animations, play
    audio, alter the user interface, and whatever else was necessary to start a conversation
    with your `Talker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, though, we don't have anything to actually call `StartTalking`
    on our `Talker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simplest way to implement this is to create a new `Pawn` subclass (again,
    inheriting from `DefaultPawn` for convenience) that can start talking to any `Talker`
    actors that it collides with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for this to work, we create a new `BoxComponent` to establish the radius
    at which we will trigger a conversation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, it is a `UPROPERTY`, so it won't get garbage collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create the definition for a function that will get triggered when the
    new `BoxComponent` overlaps another `Actor` in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor for our `TalkingPawn` initializes the new `BoxComponent`, and
    sets its extents appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor also binds the `OnTalkOverlap` function as an event handler
    to handle collisions with our `BoxComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also attaches the box component to our `RootComponent` so that it moves with
    the rest of the player character as the player moves around the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `OnTalkOverlap`, we need to check if the other actor, which is overlapping
    our box, implements the `Talker` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most reliable way to do this is with the `ImplementsInterface` function
    in `UClass`. This function uses the class information generated by the Unreal
    Header Tool during compilation, and correctly handles both C++ and Blueprint-implemented
    interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the function returns `true`, we can use a special autogenerated function
    contained in our `IInterface` to invoke the interface method of our choice on
    our instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a static method of the form `<IInterface>::Execute_<FunctionName>`.
    In our instance, our `IInterface` is `ITalker`, and the function is `StartTalking`,
    so the function we want to invoke is `ITalker::Execute_StartTalking()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason we need this function is that when an interface is implemented in
    Blueprint, the relationship isn't actually established at compile time. C++ is,
    therefore, not aware of the fact that the interface is implemented, and so we
    can't cast the Blueprint class to `IInterface` to call functions directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Execute_` functions take a pointer to the object that implements the interface,
    and call a number of internal methods to invoke the desired function's Blueprint
    implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play the level, and walk around, the custom `Pawn` is constantly receiving
    notifications when it's `BoxComponent` overlaps other objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they implement the `UTalker`/`ITalker` interface, the pawn then tries to
    invoke `StartTalking` on the `Actor` instance in question, which then prints the
    appropriate message on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a simple interaction system with UInterfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to combine a number of other recipes in this chapter
    to demonstrate a simple interaction system, and a door with an interactable doorbell
    to cause the door to open.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new interface, `Interactable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the `IInteractable` class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create default implementations for both functions in the implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Create a second interface, `Openable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this function to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `Interactable`, create a default implementation for the `Open` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class, based on `StaticMeshActor`, called `DoorBell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include "Interactable.h"` in `DoorBell.h`, and add the following functions
    to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the `.cpp` file for `DoorBell`, `#include "Openable.h"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load a static mesh for our `DoorBell` in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementations to implement the `Interactable`
    interface on our `DoorBell`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now create a new `StaticMeshActor`-based class called `Door`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include` the Openable and Interactable interfaces into the class header,
    then modify Door''s declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the interface functions to `Door`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `DoorBell`, in the `Door` constructor, initialize our mesh component,
    and load a model in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the interface functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `DefaultPawn`-based class called `AInteractingPawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the `Pawn` class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the implementation file for the `Pawn`, `#include "Interactable.h"`,
    and then provide implementations for both functions from the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, either create a new `GameMode` in C++ or Blueprint, and set `InteractingPawn`
    as our default `Pawn` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of both `Door` and `Doorbell` into the level:![How to do it...](img/00132.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the eyedropper beside doorbell's **Door to Open**, as shown in the following
    screenshot, then click on the door actor instance in your level:![How to do it...](img/00133.jpeg)![How
    to do it...](img/00134.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Action binding in the editor called `Interact`**,** and bind it
    to a key of your choice:![How to do it...](img/00135.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level, and walk up to the doorbell. Look at it, and press whatever
    key you bound `Interact` with. Verify that the door moves once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also interact with the door directly to receive some information about
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in previous recipes, we mark `UFUNCTION` as `BlueprintNativeEvent` and `BlueprintCallable`
    in order to allow the `UInterface` to be implemented in either native code or
    Blueprint, and allow the functions to be called with either method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `DoorBell` based on `StaticMeshActor` for convenience, and have `DoorBell`
    implement the `Interactable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the constructor for `DoorBell`, we initialize `HasBeenPushed` and `DoorToOpen`
    to the default safe values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the implementation for `CanInteract`, we return the inverse of `HasBeenPushed`
    so that once the button has been pushed it, can't be interacted with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `PerformInteract`, we check if we have a reference to a door object to
    open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have a valid reference, we verify that the door actor implements `Openable`,
    then we invoke the `Open` function on our door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `Door`, we implement both `Interactable` and `Openable`, and override
    the functions from each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Door` implementation of `CanInteract` to be the same as the default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `PerformInteract`, we display a message to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `Open`, we use `AddActorLocalOffset` to move the door a certain distance
    away. With Timeline in Blueprint or a linear interpolation, we could make this
    transition smooth rather than a teleport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we create a new `Pawn` so that the player can actually interact with
    objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `TryInteract` function, which we bind to the `Interact` input action
    in the overridden `SetupPlayerInputComponent` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that when the player performs the input that is bound to `Interact`,
    our `TryInteract` function will run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TryInteract` gets a reference to `PlayerController`, casting the generic controller
    reference that all Pawns have.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayerCameraManager` is retrieved through `PlayerController`, so we can access
    the current location and rotation of the player camera.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create start and end points using the camera's location, then 100 units in
    the forward direction away from the camera's location, and pass those into `GetWorld::SweepSingleByObjectType`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function takes in a number of parameters. `HitResult` is a variable that
    allows the function to return information about any object hit by the trace. `CollisionObjectQueryParams`
    allows us to specify if we are interested in dynamic, static items, or both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We accomplish a sphere trace by passing the shape in using the `MakeSphere`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sphere traces allow for slightly more human error by defining a cylinder to
    check for objects rather than a straight line. Given that the players might not
    look exactly at your object, you can tweak the sphere's radius as appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final parameter, `SweepSingleByObjectType`, is a struct that gives the trace
    a name, lets us specify if we are colliding against complex collision geometry,
    and most importantly, allows us to specify that we want to ignore the object which
    is initiating the trace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `HitResult` contains an actor after the trace is done, we check if the actor
    implements our interface, then attempt to call `CanInteract` on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the actor indicates yes, it can be interacted with, so we then tell it to
    actually perform the interaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
