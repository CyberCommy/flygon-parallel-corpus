- en: Chapter 1. Our First API in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any time developing applications on the Web (or off it, for that
    matter), it won't be long before you find yourself facing the prospect of interacting
    with a web service or an API.
  prefs: []
  type: TYPE_NORMAL
- en: Whether it's a library that you need or another application's sandbox with which
    you have to interact, the world of development relies in no small part on the
    cooperation among dissonant applications, languages, and formats.
  prefs: []
  type: TYPE_NORMAL
- en: That, after all, is why we have APIs to begin with—to allow standardized communication
    between any two given platforms.
  prefs: []
  type: TYPE_NORMAL
- en: If you spend a long amount of time working on the Web, you'll encounter bad
    APIs. By *bad* we mean APIs that are not all-inclusive, do not adhere to best
    practices and standards, are confusing semantically, or lack consistency. You'll
    encounter APIs that haphazardly use OAuth or simple HTTP authentication in some
    places and the opposite in others, or more commonly, APIs that ignore the stated
    purposes of HTTP verbs (we will discuss more on this later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Google's Go language is particularly well suited to servers. With its built-in
    HTTP serving, a simple method for XML and JSON encoding of data, high availability,
    and concurrency, it is the ideal platform for your API.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we'll not only explore a robust and clean API development
    but also its interaction with other APIs and data sources, and best practices
    for such development. We'll build one large service and a bunch of smaller ones
    for individual, self-contained lessons.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, by the end, you should be able to interact with any networked
    API in Go and be able to design and execute a well-polished API suite yourself.
  prefs: []
  type: TYPE_NORMAL
- en: This book requires at least a casual familiarity with the web-based APIs and
    a beginner's level competency in Go, but we'll do some very brief introductions
    when we discuss new concepts and steer you to more information if it turns out
    that you're not entirely versed in this aspect of either Go or APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We will also touch a bit on concurrency in Go, but we won't get too detailed—if
    you wish to learn more about this, please check out for the book authored by me,
    *Mastering Concurrency in Go*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding requirements and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the HTTP package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our first routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting data via HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving data from the datastore to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding requirements and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get too deep into the weeds in this book, it would be a good idea
    for us to examine the things that you will need to have installed in order to
    handle all our examples as we develop, test, and deploy our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should go without saying that we will need to have the Go language installed.
    However, there are a few associated items that you will also need to install in
    order to do everything we do in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go is available for Mac OS X, Windows, and most common Linux variants. You can
    download the binaries at [http://golang.org/doc/install](http://golang.org/doc/install).
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, you can generally grab Go through your distribution's package manager.
    For example, you can grab it on Ubuntu with a simple `apt-get install golang`
    command. Something similar exists for most distributions.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the core language, we'll also work a bit with the Google App
    Engine, and the best way to test with the App Engine is to install the **Software
    Development Kit** (**SDK**). This will allow us to test our applications locally
    prior to deploying them and simulate a lot of the functionality that is provided
    only on the App Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The App Engine SDK can be downloaded from [https://developers.google.com/appengine/downloads](https://developers.google.com/appengine/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: While we're obviously most interested in the Go SDK, you should also grab the
    Python SDK as there are some minor dependencies that may not be available solely
    in the Go SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using quite a few different databases and datastores to manage our
    test and real data, and MySQL will be one of the primary ones.
  prefs: []
  type: TYPE_NORMAL
- en: We will use MySQL as a storage system for our users; their messages and their
    relationships will be stored in our larger application (we will discuss more about
    this in a bit).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL can be downloaded from [http://dev.mysql.com/downloads/](http://dev.mysql.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also grab it easily from a package manager on Linux/OS X as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu: `sudo apt-get install mysql-server mysql-client`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OS X with Homebrew: `brew install mysql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is the first of the two NoSQL datastores that we'll be using for a couple
    of different demonstrations, including caching data from our databases as well
    as the API output.
  prefs: []
  type: TYPE_NORMAL
- en: If you're unfamiliar with NoSQL, we'll do some pretty simple introductions to
    results gathering using both Redis and Couchbase in our examples. If you know
    MySQL, Redis will at least feel similar, and you won't need the full knowledge
    base to be able to use the application in the fashion in which we'll use it for
    our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis can be downloaded from [http://redis.io/download](http://redis.io/download).
  prefs: []
  type: TYPE_NORMAL
- en: 'Redis can be downloaded on Linux/OS X using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu: `sudo apt-get install redis-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OS X with Homebrew: `brew install redis`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Couchbase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Couchbase will be our second NoSQL solution that we'll
    use in various products, primarily to set short-lived or ephemeral key store lookups
    to avoid bottlenecks and as an experiment with in-memory caching.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Redis, Couchbase uses simple REST commands to set and receive data, and
    everything exists in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Couchbase can be downloaded from [http://www.couchbase.com/download](http://www.couchbase.com/download).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ubuntu (`deb`), use the following command to download Couchbase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For OS X with Homebrew use the following command to download Couchbase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Nginx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Go comes with everything you need to run a highly concurrent, performant
    web server, we're going to experiment with wrapping a reverse proxy around our
    results. We'll do this primarily as a response to the real-world issues regarding
    availability and speed. *Nginx is not available natively for Windows*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Ubuntu, use the following command to download Nginx:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For OS X with Homebrew, use the following command to download Nginx:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Apache JMeter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll utilize JMeter for benchmarking and tuning our API for performance. You
    have a bit of a choice here, as there are several stress-testing applications
    for simulating traffic. The two we'll touch on are **JMeter** and Apache's built-in
    **Apache Benchmark** (**AB**) platform. The latter is a stalwart in benchmarking
    but is a bit limited in what you can throw at your API, so JMeter is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that we'll need to consider when building an API is its ability
    to stand up to heavy traffic (and introduce some mitigating actions when it cannot),
    so we'll need to know what our limits are.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apache JMeter can be downloaded from [http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi).
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it's not entirely necessary to have our dummy dataset throughout the course
    of this book, you can save a lot of time as we build our social network by bringing
    it in because it is full of users, posts, and images.
  prefs: []
  type: TYPE_NORMAL
- en: By using this dataset, you can skip creating this data to test certain aspects
    of the API and API creation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our dummy dataset can be downloaded at [https://github.com/nkozyra/masteringwebservices](https://github.com/nkozyra/masteringwebservices).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A choice of **Integrated Development Environment** (**IDE**) is one of the most
    personal choices a developer can make, and it's rare to find a developer who is
    not steadfastly passionate about their favorite.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing in this book will require one IDE over another; indeed, most of Go's
    strength in terms of compiling, formatting, and testing lies at the command-line
    level. That said, we'd like to at least explore some of the more popular choices
    for editors and IDEs that exist for Go.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As one of the most popular and expansive IDEs available for any language, Eclipse
    is an obvious first mention. Most languages get their support in the form of an
    Eclipse plugin and Go is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: There are some downsides to this monolithic piece of software; it is occasionally
    buggy on some languages, notoriously slow for some autocompletion functions, and
    is a bit heavier than most of the other available options.
  prefs: []
  type: TYPE_NORMAL
- en: However, the pluses are myriad. Eclipse is very mature and has a gigantic community
    from which you can seek support when issues arise. Also, it's free to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eclipse can be downloaded from [http://eclipse.org/](http://eclipse.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the Goclipse plugin at [http://goclipse.github.io/](http://goclipse.github.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sublime Text is our particular favorite, but it comes with a large caveat—it
    is the only one listed here that is not free.
  prefs: []
  type: TYPE_NORMAL
- en: This one feels more like a complete code/text editor than a heavy IDE, but it
    includes code completion options and the ability to integrate the Go compilers
    (or other languages' compilers) directly into the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Although Sublime Text's license costs $70, many developers find its elegance
    and speed to be well worth it. You can try out the software indefinitely to see
    if it's right for you; it operates as nagware unless and until you purchase a
    license.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sublime Text can be downloaded from [http://www.sublimetext.com/2](http://www.sublimetext.com/2).
  prefs: []
  type: TYPE_NORMAL
- en: LiteIDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LiteIDE is a much younger IDE than the others mentioned here, but it is noteworthy
    because it has a focus on the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: It's cross-platform and does a lot of Go's command-line magic in the background,
    making it truly integrated. LiteIDE also handles code autocompletion, `go fmt`,
    build, run, and test directly in the IDE and a robust package browser.
  prefs: []
  type: TYPE_NORMAL
- en: It's free and totally worth a shot if you want something lean and targeted directly
    for the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LiteIDE can be downloaded from [https://code.google.com/p/golangide/](https://code.google.com/p/golangide/).
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right up there with Eclipse is the JetBrains family of IDE, which has spanned
    approximately the same number of languages as Eclipse. Ultimately, both are primarily
    built with Java in mind, which means that sometimes other language support can
    feel secondary.
  prefs: []
  type: TYPE_NORMAL
- en: The Go integration here, however, seems fairly robust and complete, so it's
    worth a shot if you have a license. If you do not have a license, you can try
    the Community Edition, which is free.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download IntelliJ IDEA at [http://www.jetbrains.com/idea/download/](http://www.jetbrains.com/idea/download/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go language support plugin is available at [http://plugins.jetbrains.com/plugin/?idea&id=5047](http://plugins.jetbrains.com/plugin/?idea&id=5047)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some client-side tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the vast majority of what we'll be covering will focus on Go and API
    services, we will be doing some visualization of client-side interactions with
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: In doing so, we'll primarily focus on straight HTML and JavaScript, but for
    our more interactive points, we'll also rope in jQuery and AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of what we do for client-side demonstrations will be available at this
    book's GitHub repository at [https://github.com/nkozyra/goweb](https://github.com/nkozyra/goweb)
    under client.
  prefs: []
  type: TYPE_NORMAL
- en: Both jQuery and AngularJS can be loaded dynamically from Google's CDN, which
    will prevent you from having to download and store them locally. The examples
    hosted on GitHub call these dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load AngularJS dynamically, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To load jQuery dynamically, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Looking at our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we'll be building myriad small applications to demonstrate
    points, functions, libraries, and other techniques. However, we'll also focus
    on a larger project that mimics a social network wherein we create and return
    to users, statuses, and so on, via the API.
  prefs: []
  type: TYPE_NORMAL
- en: Though we'll be working towards the larger application as a way to demonstrate
    each piece of the puzzle, we'll also build and test self-contained applications,
    APIs, and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The latter group will be prefaced with a quick hitter to let you know that it's
    not part of our larger application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we'll be designing a social network that operates almost
    entirely at the API level (at least at first) as our *master* project in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we think of the major social networks (from the past and in the present),
    there are a few omnipresent concepts endemic among them, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create a user and maintain a user profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to share messages or statuses and have conversations based on them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to express pleasure or displeasure on the said statuses/messages
    to dictate the worthiness of any given message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few other features that we''ll be building here, but let''s start
    with the basics. Let''s create our database in MySQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the basis of our social network product in this book. For now,
    we''ll just need a `users` table to store our individual users and their most
    basic information. We''ll amend this to include more features as we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We won't need to do too much in this chapter, so this should suffice. We'll
    have a user's most basic information—name, nickname, and e-mail, and not much
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the HTTP package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vast majority of our API work will be handled through REST, so you should
    become pretty familiar with Go's `http` package.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to serving via HTTP, the `http` package comprises of a number of
    other very useful utilities that we'll look at in detail. These include cookie
    jars, setting up clients, reverse proxies, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The primary entity about which we're interested right now, though, is the `http.Server`
    struct, which provides the very basis of all of our server's actions and parameters.
    Within the server, we can set our TCP address, HTTP multiplexing for routing specific
    requests, timeouts, and header information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also provides some shortcuts for invoking a server without directly initializing
    the struct. For example, if you have a lot of default properties, you could use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simply execute using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke a server struct for you and set only the `Addr` and `Handler`
    properties within.
  prefs: []
  type: TYPE_NORMAL
- en: There will be times, of course, when we'll want more granular control over our
    server, but for the time being, this will do just fine. Let's take this concept
    and output some JSON data via HTTP for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Quick hitter – saying Hello, World via API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, we'll go off course and do some work that
    we'll preface with **quick hitter** to denote that it's unrelated to our larger
    project.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we just want to rev up our `http` package and deliver some JSON
    to the browser. Unsurprisingly, we'll be merely outputting the uninspiring `Hello,
    world` message to, well, the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set this up with our required package and imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the bare minimum that we need to output a simple string in JSON via
    HTTP. Marshalling JSON data can be a bit more complex than what we'll look at
    here, so if the struct for our message doesn't immediately make sense, don't worry.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our response struct, which contains all of the data that we wish to
    send to the client after grabbing it from our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is not a lot here yet, obviously. All we're setting is a single message
    string in the obviously-named `Message` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to set up our main function (as follows) to respond to a route
    and deliver a marshaled JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Upon entering `main()`, we set a route handling function to respond to requests
    at `/api` that initializes an API struct with `Hello, world!` We then marshal
    this to a JSON byte array, `output`, and after sending this message to our `iowriter`
    class (in this case, an `http.ResponseWriter` value), we cast that to a string.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is a kind of quick-and-dirty approach for sending our byte array
    through a function that expects a string, but there's not much that could go wrong
    in doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Go handles typecasting pretty simply by applying the type as a function that
    flanks the target variable. In other words, we can cast an `int64` value to an
    integer by simply surrounding it with the `int(OurInt64)` function. There are
    some exceptions to this—types that cannot be directly cast and some other pitfalls,
    but that's the general idea. Among the possible exceptions, some types cannot
    be directly cast to others and some require a package like `strconv` to manage
    typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we head over to our browser and call `localhost:8080/api` (as shown in the
    following screenshot), you should get exactly what we expect, assuming everything
    went correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick hitter – saying Hello, World via API](img/1304OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building our first route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about routing in Go nomenclature, we're more accurately discussing
    a multiplexer or `mux`. In this case, the multiplexer refers to taking URLs or
    URL patterns and translating them into internal functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of this as a simple mapping from a request to a function (or
    a handler). You might draw up something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are some limitations with the built-in mux/router provided by the `net/http`
    package. You cannot, for example, supply a wildcard or a regular expression to
    a route.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might expect to be able to do something as discussed in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, this results in a parsing error.
  prefs: []
  type: TYPE_NORMAL
- en: If you've spent any serious time in any mature web API, you'll know that this
    won't do. We need to be able to react to dynamic and unpredictable requests. By
    this we mean that anticipating every numerical user is untenable as it relates
    to mapping to a function. We need to be able to accept and use patterns.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few solutions for this problem. The first is to use a third-party
    platform that has this kind of robust routing built in. There are a few very good
    platforms to choose from, so we'll quickly look at these now.
  prefs: []
  type: TYPE_NORMAL
- en: Gorilla
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gorilla is an all-inclusive web framework, and one that we'll use quite a bit
    in this book. It has precisely the kind of URL routing package that we need (in
    its `gorilla/mux` package), and it also supplies some other very useful tools,
    such as JSON-RPC, secure cookies, and global session data.
  prefs: []
  type: TYPE_NORMAL
- en: Gorilla's `mux` package lets us use regular expressions, but it also has some
    shorthand expressions that let us define the kind of request string we expect
    without having to write out full expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a request like `/api/users/309`, we can simple route
    it as follows in Gorilla:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, there is a clear risk in doing so—by leaving this so open-ended, we
    have the potential to get some data validation issues. If this function accepts
    anything as a parameter and we expect digits or text only, this will cause problems
    in our underlying application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Gorilla allows us to clarify this with regular expressions, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we will only get what we expect—digit-based request parameters. Let''s
    modify our previous example with this concept to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code, we have some validation at the routing level. A valid request
    to `/api/44` will give us a proper response, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gorilla](img/1304OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An invalid request to something like `/api/nkozyra` will give us a 404 response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the Gorilla web toolkit from [http://www.gorillatoolkit.org/](http://www.gorillatoolkit.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation on its URL multiplexer can be found at [http://www.gorillatoolkit.org/pkg/mux](http://www.gorillatoolkit.org/pkg/mux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Routes, from `drone.io`, is explicitly and solely a routing package for Go.
    This makes it much more focused than the Gorilla web toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, URL routing will not be a bottleneck in a smaller application,
    but it's something that should be considered as your application scales. For our
    purpose, the differences in speed between, say, Gorilla and Routes is negligible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining your `mux` package in routes is very clean and simple. Here is a variation
    on our `Hello world` message that responds to URL parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary difference here (as with Gorilla) is that we''re passing our `routes`
    multiplexer to `http` instead of using the internal one. And as with Gorilla,
    we can now use variable URL patterns to change our output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Routes](img/1304OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about routes and how to install them at: [https://github.com/drone/routes](https://github.com/drone/routes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Setting data via HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've examined how we're going to handle routing, let's take a stab
    at injecting data into our database directly from a REST endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we'll be looking exclusively at the `POST` request methods because
    in most cases when large amounts of data could be transferred, you want to avoid
    the length limitations that the `GET` requests impose.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically, a `PUT` request is the semantically correct method to use for requests
    that are made to create data in the **create-read-update-delete** (**CRUD**) concept,
    but years of disuse have largely relegated `PUT` to a historical footnote. Recently,
    some support for restoring `PUT` (and `DELETE`) to their proper place has taken
    hold. Go (and Gorilla) will gladly allow you to relegate requests to either and
    as we go forward, we'll move towards more protocol-valid semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has a largely built-in agnostic database connection facility, and most third-party
    database connectivity packages yield to it. Go's default SQL package is `database/sql`,
    and it allows more general database connectivity with some standardization.
  prefs: []
  type: TYPE_NORMAL
- en: However, rather than rolling our own MySQL connection (for now, at least), we'll
    yield to a third-party add-on library. There are a couple of these libraries that
    are available, but we'll go with `Go-MySQL-Driver`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can install `Go-MySQL-Driver` using the following command (it requires
    Git):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of this example, we'll assume that you have MySQL running with
    a localhost on the `3306` standard port. If it is not running, then please make
    the necessary adjustments accordingly in the examples. The examples here will
    also use a passwordless root account for the sake of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our imports will remain largely the same but with two obvious additions: the
    `sql` package (`database/sql`) and the aforementioned MySQL driver that is imported
    solely for side effects by prepending it with an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll set a new endpoint using Gorilla. You may recall that when we intend
    to set or create data, we''ll generally push for a `PUT` or `POST` verb, but for
    the purposes of this demonstration, appending URL parameters is the easiest way
    to push data. Here is how we''d set up this new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we're specifying the verbs that we'll accept for this request. In
    real usage, this is recommended for the `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `CreateUser` function will accept several parameters—`user`, `email`, `first`,
    and `last`. `User` represents a short user name and the rest should be self-explanatory.
    We''ll precede our code with the definition of a `User` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s take a look at the `CreateUser` function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, our routed API endpoint should be available at `localhost:8080/api/user/create`.
    Though if you look at the call itself, you''ll note that we need to pass URL parameters
    to create a user. We''re not yet doing any sanity checking on our input, nor are
    we making certain it''s clean/escaped, but we''ll hit the URL as follows: `http://localhost:8080/api/user/create?user=nkozyra&first=Nathan&last=Kozyra&email=nathan@nathankozyra.com`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, we''ll end up with a user created in our `users` table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to MySQL](img/1304OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Serving data from the datastore to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, if we start setting data via API endpoint—albeit crudely—we''ll
    also want to retrieve the data via another API endpoint. We can easily amend our
    current call using the following code to include a new route that provides the
    data back via a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re doing a couple of new and noteworthy things here. First, we''re using
    a `QueryRow()` method instead of `Exec()`. Go''s default database interface offers
    a couple of different querying mechanisms that do slightly different things. These
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Exec()`: This method is used for queries (`INSERT`, `UPDATE`, and `DELETE`
    primarily) that will not return rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query()`: This method is used for queries that will return one or more rows.
    This is usually designated for the `SELECT` queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryRow()`: This method is like `Query()`, but it expects just one result.
    This is typically a row-based request similar to the one we had in our previous
    example. We can then run the `Scan()` method on that row to inject the returned
    values into our struct''s properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we're scanning the returned data into our struct, we don't get a return
    value. With the `err` value, we run a switch to determine how to convey a response
    to the user or the application that's using our API.
  prefs: []
  type: TYPE_NORMAL
- en: If we have no rows, it is likely that there is an error in the request and we'll
    let the recipient know that an error exists.
  prefs: []
  type: TYPE_NORMAL
- en: However, if there is a SQL error, then we'll stay quiet for now. It's a bad
    practice to expose internal errors to the public. However, we should respond that
    something went wrong without being too specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if the request is valid and we get a record, we will marshal that
    into a JSON response and cast it to a string before returning it. Our following
    result looks like what we''d expect for a valid request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serving data from the datastore to the client](img/1304OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then, it appropriately returns an error (as shown in the following screenshot)
    if we request a particular record from our users'' table that does not actually
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serving data from the datastore to the client](img/1304OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting headers to add detail for clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something that will come up a bit more as we go on is the idea of using HTTP
    headers to convey important information about the data that we're sending or accepting
    via the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly look at the headers that are being sent through our API now
    by running a `curl` request against it. When we do, we''ll see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty small set of headers that is sent by Go, by default. As we
    go forward, we may wish to append more informative headers that tell a recipient
    service how to handle or cache data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's very briefly try to set some headers and apply them to our request using
    the `http` package. We'll start with one of the more basic response headers and
    set a Pragma. This is a `no-cache` Pragma on our result set to tell users or services
    that ingest our API to always request a fresh version from our database.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, given the data we're working with, this is unnecessary in this case,
    but is the simplest way to demonstrate this behavior. We may find going forward
    that endpoint caching helps with performance, but it may not provide us with the
    freshest data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `http` package itself has a pretty simple method for both setting response
    headers and getting request headers. Let''s modify our `GetUser` function to tell
    other services that they should not cache this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Header()` method returns the `Header` struct of `iowriter`, which we can
    then add directly using `Set()` or get by using values using `Get()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve done that, let''s see how our output has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we'd expect, we now see our value directly in CURL's header information and
    it properly returns that this result should not be cached.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, far more valuable response headers that we can send with
    web services and APIs, but this is a good start. As we move forward, we'll utilize
    more of these, including `Content-Encoding`, `Access-Control-Allow-Origin`, and
    more headers that allow us to specify what our data is, who can access it, and
    what they should expect in terms of formatting and encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've touched on the very basics of developing a simple web service interface
    in Go. Admittedly, this particular version is extremely limited and vulnerable
    to attack, but it shows the basic mechanisms that we can employ to produce usable,
    formalized output that can be ingested by other services.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have the basic tools at your disposal that are necessary
    to start refining this process and our application as a whole. We'll move forward
    with applying a fuller design to our API as we push forward, as two randomly chosen
    API endpoints will obviously not do much for us.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll dive in deeper with API planning and design, the
    nitty-gritty of RESTful services, and look at how we can separate our logic from
    our output. We'll briefly touch on some logic/view separation concepts and move
    toward more robust endpoints and methods in [Chapter 3](ch03.html "Chapter 3. Routing
    and Bootstrapping"), *Routing and Bootstrapping*.
  prefs: []
  type: TYPE_NORMAL
