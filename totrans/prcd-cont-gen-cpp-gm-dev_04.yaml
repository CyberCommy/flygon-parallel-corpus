- en: Chapter 4. Procedurally Populating Game Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're comfortable using **Random Number Generator** (**RNG**) with
    core C++ data types, let's have a look at how to create a highly randomized environment.
    This will include the random generation and positioning of items, enemies, and
    more. We'll also touch upon random map generation in this chapter before tackling
    it head-on toward the end of the book.
  prefs: []
  type: TYPE_NORMAL
- en: The way in which objects are spawned will largely depend on the infrastructure
    of your level data. With most 2D games, you'll be able to take an approach that
    is similar, if not identical, to the one demonstrated in this chapter. However,
    a 3D game requires more work because there's an extra dimension to deal with,
    but the principles are still valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Obstacles with procedurally populating an environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the spawn area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomly selecting a game `tile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning items at a random location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedurally generating changes to an environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating game environments randomly isn't as simple as it may first appear.
    It's not just a case of generating a random number within the bounds of a level.
    Though this might technically work, there is no control there, and the environment
    that is generated as a result will have many flaws. Objects may overlap, be located
    in unreachable places, or be laid out in a poor order. In order to generate meaningful
    and playable levels there needs to be more control.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping within the bounds of a level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm sure that at some point we've all played a game where an item spawned beyond
    our reach. It's infuriating to have that shiny new item just out of reach, but
    this can easily happen when spawning objects randomly around a map. Therefore,
    it's important to establish accurate bounds within which the objects can be spawned.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, the complexity of this task will match the complexity of
    your environment. Thankfully for us, our level is described as a simple 2D array.
    Hence, it's fairly easy to calculate the bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding overlapping objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if you define your level bounds perfectly, you are still not home and dry.
    Environments are generally not empty, and are mostly filled with scenery and other
    game objects. It's important to take these objects into account when choosing
    random spawn coordinates as to not spawn object within them, again pushing items
    out of the reach of the player.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we're not going to have to worry too much about this as we will have
    simple levels with no scenery.
  prefs: []
  type: TYPE_NORMAL
- en: Creating meaningful levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After all is said and done, the level has to make sense. Even if we avoid spawning
    items that are beyond the reach of the player, and which don't overlap one another,
    it's no good if they all spawn in one far corner.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create suitable parameters within which our RNG operates so we retain
    a suitable level of control over the results. It's one of the major pitfalls of
    procedurally generated games. Time and time again, you will see a level that just
    doesn't make much sense because the algorithm has produced an odd result.
  prefs: []
  type: TYPE_NORMAL
- en: Level tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start working with a `level` grid, we need to know how it is set
    up! Our `level` is described as a 2D array of a custom type `Tile`, a `struct`
    defined in `Level.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry about the final four values at this point; we''ll use them later
    when we get to the section on path finding! For now, we just need to know that
    each `tile` struct stores its type, position in the 2D array, and its sprite.
    All the possible `tile` types are defined in an enumerator in `Util.h`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This gives every `tile` type a string constant. So, instead of working with
    vague numbers, we can work with these values instead. With this sorted, let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the spawn area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know what obstacles lie ahead, and how the level data is stored, let's
    take a look at how we can spawn items at random locations in our `roguelike` object.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the level bounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to calculate the level bounds. Since we're making a 2D `roguelike`
    object, described in a 2D array, we need to identify the tiles that are suitable
    to spawn items on. If this was done for a 3D game, you would also have to take
    into account the third axis. Though we could just find the top left point of the
    map and calculate the distance to the bottom right, this would almost certainly
    cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned earlier that it''s important that items are spawned within valid
    level areas. If we take this simple approach, we run the risk of spawning items
    in the walls. The following pseudocode shows how this can be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the spawn area if we use this simple approach
    in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the level bounds](img/B04920_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the spawn area that was created exceeds the playable level area,
    even though it is technically within the level bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the underlying game grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to do this in our case is by checking the underlying game grid.
    Since each floor tile in the level grid has a unique tile type that denotes what
    kind of tile it is, we can iterate over the level grid and only mark the tiles
    with a valid type as possible spawn locations. The previous pseudocode has been
    modified and updated in the following way to make this check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran a check like this, we would end up with the following possible spawn
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the underlying game grid](img/B04920_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this is a much better area to spawn items. The next step is
    to choose a point within this area as the spawn location.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a suitable game tile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to find suitable tiles, we will generate random spawn coordinates. We know
    that all tiles with the `TILE::FLOOR` or `TILE::FLOOR_ALT` type are floor tiles.
    Therefore, we can select a tile at random and deduce if it's suitable for the
    spawning of an item.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having to do these checks ourselves, the project provides the `Level::IsFloor`
    function. It is quite self-explanatory; you can pass it a tile, or the indices
    of one, and it will return true if it's a floor tile. We'll use that from now
    on to check whether the tiles are valid for spawning an item.
  prefs: []
  type: TYPE_NORMAL
- en: Randomly selecting a tile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first function that we'll look at is choosing a value from an underlying
    grid. In our case, the level data is described in a 2D array. Therefore, we simply
    need to generate a random column and a row index.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that this range is the number of rows and columns - 1 as all indices
    start from 0\. If we have a grid with 10 rows and columns, then they are numbered
    0 to 9, and the total is 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some pseudocode to generate a random index for a 2D array with 10 rows
    and 10 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To get the `Tile` object from the level, we just need to call the `Level::GetTile`
    function and pass the randomly generated indices.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a tile is suitable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check whether a `tile` is valid, we can use the `Level::IsFloor` function
    that we had a look at earlier. The following pseudocode will achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Converting to absolute position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can choose a valid `tile` in the game grid, we need to convert that
    position to an absolute screen position. To convert indices into a position that
    is relative to the grid, we simply need to multiply them by the width of a tile
    in the game. In our case, the tiles have a size of 50 square pixels. For example,
    if we're at location `[1][6]` in the grid, the position relative to the grid will
    be 50*300.
  prefs: []
  type: TYPE_NORMAL
- en: Now we just need to add the location of the grid to these values, making them
    absolute coordinated relative to our window. The practice of converting a grid
    position to an absolute position will come in handy. So let's encapsulate the
    behavior in its own function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Level.h`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Level.cpp`, add the following definition of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Spawning items at a random location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s tie all of this together to spawn items randomly in the map. Here
    is a quick overview of the steps that we''ll take:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a random `tile` from the **level** data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether this tile is a `floor` tile. If not, go to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the tile location to the absolute position and give it to the item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is to select a random tile in the **level** data. Earlier in
    this chapter, we covered how we''ll achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to check whether the randomly selected tile is suitable for the
    spawning of an item. We know that we can do this by checking the type of the tile,
    but we need to incorporate this into some kind of loop, so that if the randomly
    selected tile is unsuitable, it will try again. To accomplish this, we''ll wrap
    the random tile selection code inside a `while` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth noting that having a while loop here will not be suitable for all
    game types. In our game, there is more area where an item can be spawned as compared
    to the area where it can't be spawned. Therefore, a valid location can be easily
    found. If this is not the case and a suitable spawn location is scarce, then a
    while loop may hold the game up indefinitely, as it is looped to find the area.
    Use the `while` statements with extreme caution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code now loops until it finds a suitable, but still random, `tile` where
    we can spawn items. This is very useful and will most likely be reused multiple
    times. Therefore, we will create a dedicated function for the code named `Level::GetRandomSpawnLocation`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to the body of the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that at the end of the function we've added a `return` statement. When
    a suitable `tile` is found, we fetch the absolute position using the function
    that we added earlier, and then return the value. We also add a random offset
    to the coordinates of our items so they aren't all fixed to the dead center of
    the `tile` that they lie on.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a function that will return absolute coordinates for a suitable
    spawn location in the level. Very handy indeed! The final step is to incorporate
    this function in the `Game::PopulateLevel` spawn function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we''ve set the position of the items manually. To make use of the
    new function, simply replace the fixed values with the results of a call to the
    `Level::GetRandomSpawnLocation()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time we create an item, its location will be generated randomly.
    If we run the game now, we will see that the items are spread through the level
    randomly, but only on the tiles that are valid and which the player can reach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawning items at a random location](img/B04920_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding the spawning system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last chapter, we covered the use of enumerators; we're going to put that
    to good use here. We're going to break the item `spawn` code into its own dedicated
    function. This will give us greater control over how we populate the level. We'll
    also expand this system to include all items and enemies!
  prefs: []
  type: TYPE_NORMAL
- en: Using enumerators to denote an object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in constructing this system is to look at the items. In `Util.h`,
    all the item types are described in the following enumerator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When deciding what items need to be spawned, we will select random values from
    these enumerator values.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another technique that we'll utilize in this system is the use of optional parameters.
    By default the function will spawn an item at a random location, but we may sometimes
    wish to override this behavior with a set location. This is achieved by using
    optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `TestFunction()` function created from this declaration requires spawn coordinates
    that need to be passed. We could just pass an `sf::Vector` value that is equal
    to `{0.f, 0.f}` and ignore these values, but that's a bit messy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional parameters are those that are given a default value in the function
    declaration. If these parameters aren''t provided in the function call, the default
    values are used. Let''s rewrite this same function declaration, this time utilizing
    optional parameters in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another approach to this is to create two distinct functions. One function takes
    parameters and the other one doesn't; you can give them different names to highlight
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `position` variable has a default value of `{-1.f, -1.f}`. So, if
    no values are passed with the function call, these defaults will be used. This
    is the behavior that we''re going to need from the spawning functions. So, with
    this in mind, let''s declare a new function named `Game::SpawnItem`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the default values set, we now need to determine whether they should be
    used or not. To check this, we can just evaluate the *x* and *y* values of the
    `position` variable. If *x* and *y* remain at `-1.f`, then we know that the user
    has not overridden them and wants to generate a value randomly. However, if *x*
    and *y* are not `-1.f`, then they have been overridden and we should use them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I've used `-1.f` as my default parameter as it's an invalid spawn coordinate.
    The default parameter should allow you to easily determine whether they have been
    overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code will choose a random spawn location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `position` variable is optional, both the following function calls are
    now valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The complete spawn functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s put all of this together and create the `SpawnItem()` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the new function, we can update the `Game::PopulateLevel` function
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This may seem like a lot of work for a seemingly small change that does not
    affect the gameplay, but it's an important one. Software should be built in such
    a way that it is easily maintainable and scalable. Now that this system is in
    place, we can spawn an item with a single function call. Spot on!
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick run of the game confirms that the code is working as intended, and
    we''ve taken a big step towards an entirely procedurally populated environment,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The complete spawn functions](img/B04920_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Updating the spawn code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `Game::SpawnItem` function is up and running, let''s refactor
    the `Game::PopulatelLevel` function a little. In `Game.h`, let''s declare the
    following static `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Instead of hard-coding the limit of the `for` loop, we can instead use this
    constant. The purpose of this is to remove all hard-coded values from the code.
    If we hard-code a value here instead of using a `const`, every time we want to
    change the value we will have to do so manually. This is both time-consuming and
    prone to errors. With a `const`, we can simply change its value, and this will
    affect every instance in which it's used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also tidy up some variables now that we''re comfortable with what the
    function is doing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this tidied up, we can now extend this approach to spawning enemies into
    the level!
  prefs: []
  type: TYPE_NORMAL
- en: Randomly spawning enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can spawn items into the game, let''s take this same system and
    use it to spawn in enemies! We''ll start by defining a `Game::SpawnEnemy` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, declare another static `const` to cap the maximum number of enemies that
    we can spawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this declared, we can now add the function''s definition. It will be much
    like the `Game::SpawnItem` function, only instead of switching through the values
    in the item enumerator, we''ll create enemies that are defined in the following
    enumerator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to call this function, we need to jump back to the `Game::Populate` level
    function and add another loop to create enemies in a way that is similar to how
    we created items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, items and enemies will be spawned randomly across the level.
    This system is very flexible and easy. To add another item or enemy, we just need
    to add it to the relevant enumerator and add a corresponding `switch` statement.
    This is the kind of flexible approach that is needed when generating procedural
    content and systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the game and have a look at the populated level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Randomly spawning enemies](img/B04920_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spawning random tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The spawning of environmental features will be covered briefly here as there's
    a whole chapter toward the end of the book that is dedicated to procedurally generating
    the game map. This is our end goal. So, to get started, we'll generate some superficial
    environmental features that will be ready for the random level generation later.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new `tile` to the game will greatly increase the diversity of levels.
    One of the problems with procedural generation is that environments can feel too
    unnatural and generic. So this will help avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following declaration to `Game.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have two parameters in this function. One allows us to specify a `tile` index
    that we would like to spawn, and the second allows us to specify how many. We
    could have skipped the creation of a function and just hard-coded the behavior
    in the `Game::PopulateLevel` function, which would have worked, but couldn't have
    been used for anything else.
  prefs: []
  type: TYPE_NORMAL
- en: However, with our approach, we can easily reuse the code, specifying the `tile`
    that needs to be used, and the number of tiles that we wish to spawn. If we use
    RNG to determine these values, we gain even more procedural generation and randomness
    in the system. When writing procedural systems, always bear this in mind, and
    avoid using hard-coded values as much as possible. Always create options, even
    if they end up not being used.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new game tile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to add the new `tile` assets in the level object, and the
    `Level::AddTile()`function does just that. In `Game::Initialize`, we''ll make
    a call to this function and add a new `tile`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two parameters, namely a `path` to a `resource` and the
    `ID` parameter value that the `tile` should have. In this case, we're using the
    `TILE::FLOOR_ALT` value.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a random tile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we're going to spawn tiles randomly in the level, we need to first choose
    a random floor tile in the game grid. Luckily, we've already written the code
    to do this; it's in the `Level::GetRandomSpawnLocation()` function. Therefore,
    we can use the code and add it to the new function. We also created a parameter
    for the number of tiles that need to be created. So, we'll wrap up everything
    inside a `for` loop to repeat the process the correct number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give the function a definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once we find a `tile` that is a valid `floor` tile, we can update its type to
    that passed in the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SpawnRandomTiles function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The very last step is to make a call to `Game::SpawnRandomTiles`. This function
    relies on the level grid that has already been in place. So, we''ll call it at
    the end of the `Game::Initialize` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I've hard-coded the parameters here, but to make it even more random, you can
    generate random numbers that can be used in their place. I've left this as one
    of the exercises in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to now run the game and see our work in action in the following
    screenshot. We can see that where the floor used to be a single tile, there are
    now randomly distributed broken tiles, and we can control both the sprite and
    their amount thanks to the way we architected the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the SpawnRandomTiles function](img/B04920_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you access your strengths and weaknesses in
    the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new item to the game. Then, hook it up to the spawn system so that it
    can be randomly spawned with the existing items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your own `tile` to the game. Hook this up to the spawn code and change the
    underlying level grid so that the player cannot move through it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether the number of tiles that we created when calling `Game::SpawnRandomTiles()`
    are hard-coded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Use RNG to generate a count during the runtime instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our Game::SpawnItem function, update our enemy item drops to use
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we now have a function to calculate actual tile location, update our torch
    spawn code so we don't do the position calculations ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented RNG to procedurally generate a suitable spawn
    location in the levels, and we encapsulated this behavior in its own function.
    We then used this to spawn items and enemies around the map at random locations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to look at creating unique, randomized game
    objects. Certain items will be procedurally generated during runtime, meaning
    there will be an almost infinite number of possible combinations. We covered the
    skills and techniques that are used to achieve this in the earlier chapters, so
    it's time to pull it together and build our own procedural system!
  prefs: []
  type: TYPE_NORMAL
