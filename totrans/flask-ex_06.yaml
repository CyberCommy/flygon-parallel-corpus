- en: Chapter 6. Building an Interactive Crime Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first project notably lacked any sort of long term memory. Although we worked
    around the issues using cookies to simulate long-term storage, we also saw the
    limitations of these. In this project, we'll build an interactive crime map that
    allows users to tag locations with details of witnessed or experienced criminal
    activities. As we want to keep the data for the long term and make it available
    to many users, we cannot rely on our users' local and temporary storage.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first step to our project will be setting up a MySQL database
    on our VPS and linking this to a new Flask web application. We'll use the Google
    Maps API to allow users to view our map and add new markers to it (in which each
    marker represents a crime).
  prefs: []
  type: TYPE_NORMAL
- en: We'll also have some more advanced user input than in our previous project,
    allowing users to filter their view of the map and add fairly complex data to
    the map. Therefore, we'll have a stronger focus on input validation and sanitization.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal for the project is a web page containing an interactive map. The user
    should be able to submit new crimes by choosing a location for the map and entering
    a date, category, and description of the crime. The user should also be able to
    view all the previously recorded crimes as icons on the map and more details about
    any specific crime by selecting the relevant icon from the map. The point of the
    map is to be able to easily view areas with high crime rates as well as to assist
    investigators in detecting patterns and trends in crime.
  prefs: []
  type: TYPE_NORMAL
- en: A substantial chunk of this chapter is devoted to setting up a MySQL database
    on our VPS and creating a database for the crime data. This will be followed by
    us setting up a basic page containing a map and text box. We'll see how to link
    Flask to MySQL by storing data entered into the text box in our database.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous project, we'll avoid the frameworks and automation tools
    that we'd almost certainly use in a "real-world" project. As we will focus on
    learning, a lower level of abstraction is useful. Therefore, we won't be using
    **Object-relational Mapping** (**ORM**) for our database queries or a JavaScript
    framework for user input and interaction. This means that there will be some laborious
    writing of SQL and vanilla JavaScript, but it's important to fully understand
    why the tools and frameworks exist and what problems they solve, before diving
    in and using them blindly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring MySQL on our VPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Crime Map database in MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic database web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a new Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create a new Git repository for our new code base as, although some
    of the setup will be similar, our new project should be completely unrelated to
    our first one. If you need more help with this step, head back to [Chapter 1](ch01.html
    "Chapter 1. Hello, World!"), *Hello, World!*, and follow the detailed instructions
    in the *Installing and using Git* section. If you feel confident, check whether
    you can do this just with the following summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the website for Bitbucket, GitHub, or whichever hosting platform
    you used for the first project. Log in and create a new repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name your repository `crimemap` and take note of the URL you're given
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On your local machine, fire up a terminal and run the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll leave this repository empty for now as we need to set up a database on
    our VPS. Once we have the database installed, we'll come back here to set up our
    Flask project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its simplest form, a relational database management system, such as MySQL,
    is a glorified spreadsheet program, such as Microsoft Excel. We use it to store
    data in rows and columns. Every row is a "*thing*" and every column is a specific
    piece of information about the "*thing"* in the relevant row. I put "*thing*"
    in inverted commas because we''re not limited to storing objects. In fact, the
    most common example of a thing, both in the real world and in explaining databases,
    is data about people. A basic database storing information about customers of
    an e-commerce website could look something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ID | First name | Surname | E-mail address | Telephone |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Frodo | Baggins | `fbaggins@example.com` | +1 111 111 1111 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Bilbo | Baggins | `bbaggins@example.com` | +1 111 111 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Samwise | Gamgee | `sgamgee@example.com` | +1 111 111 1001 |'
  prefs: []
  type: TYPE_TB
- en: If we look from the left to the right in a single row, we will get all the information
    about one person. If we look in a single column from the top to the bottom, we
    will get one piece of information (for example, an e-mail address) for everyone.
    Both can be useful; if we want to add a new person or contact a specific person,
    we will probably be interested in a specific row. If we want to send a newsletter
    to all our customers, we will just be interested in the e-mail column.
  prefs: []
  type: TYPE_NORMAL
- en: So, why can't we just use spreadsheets instead of databases then? Well, if we
    take the example of an e-commerce store further, we will quickly see the limitations.
    If we want to store a list of all the items we have on offer, we can create another
    table similar to the preceding with columns such as `Item name`, `Description`,
    `Price`, and `Quantity in stock`. Our model continues to be useful; however, now,
    if we want to store a list of all the items Frodo has ever purchased, there's
    no good place to put the data. We could add 1,000 columns to our customer table
    (as seen earlier), such as `Purchase 1`, `Purchase 2`, and so on until `Purchase
    1000`, and hope that Frodo never buys more than 1,000 items. This is neither scalable
    nor easy to work with. How do we get the description for the item Frodo purchased
    last Tuesday? Do we just store the `name` item in our new column? What happens
    with items that don't have unique names?
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will realize that we need to think about it backwards. Instead of storing
    the items purchased by a person in the `Customers` table, we need to create a
    new table called `Orders`, and store a reference to the customer in every order.
    Thus, an order "knows" which customer it belongs to, but a customer has no inherent
    knowledge of which orders belong to him/her.
  prefs: []
  type: TYPE_NORMAL
- en: While our model still fits into a spreadsheet at a push, as we grow our data
    model and size, our spreadsheet becomes more cumbersome. We need to do complicated
    queries, such as "I want to see all items that are in stock, have been ordered
    at least once in the last six months, and cost more than $10".
  prefs: []
  type: TYPE_NORMAL
- en: Enter **Relational Database Management Systems** (**RDBMS**). They've been around
    for decades and are a tried-and-tested way of solving a common problem (such as
    storing data with complicated relations in an organized and accessible manner).
    We won't touch on their full capabilities in our Crime Map (in fact, we could
    probably store our data in a text file if we needed to), but if you're interested
    in building web applications, you will need a database at some point. So, let's
    start small and add the powerful MySQL tool to our growing toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend that you learn more about databases! If the you experience
    in building our current project takes your fancy, go read and learn about databases.
    The history of RDBMS is interesting, and the complexities and subtleties of normalization
    and database varieties (including NoSQL databases, which we'll see some of in
    our next project) deserve more study time than we can devote to them in a book
    that focuses on Python web development.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring MySQL on our VPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing and configuring MySQL is an extremely common task. You can, therefore,
    find it in prebuilt images or in scripts that build entire *stacks* for you. A
    common stack is called the **LAMP stack**, which stands for **Linux**, **Apache**,
    **MySQL**, and **PHP**, and many VPS providers provide a one-click LAMP stack
    image.
  prefs: []
  type: TYPE_NORMAL
- en: As we will use Linux and have already installed Apache manually, after installing
    MySQL, we'll be very close to the traditional LAMP stack; we will just use the
    P for Python instead of PHP. In keeping with our goal of "education first", we'll
    install MySQL manually, and configure it through the command line instead of installing
    a GUI control panel. If you've used MySQL before, feel free to set it up as you
    see fit.
  prefs: []
  type: TYPE_NORMAL
- en: '**MySQL and Git**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that neither our setup of MySQL nor the data we store in it is
    part of our Git repository. Be careful as any mistakes made at a database level,
    including misconfiguration or deleting data, will be harder to undo.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL on our VPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing MySQL on our server is quite straightforward. SSH into your VPS
    and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an interface prompting you for a root password for MySQL. Enter
    a password and repeat it where prompted. Once the installation is complete, you
    can get a live SQL shell by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, enter the password you chose earlier when prompted. We could create a
    database and schema using this shell, but we'd rather do this through Python;
    so, type `quit` and hit the *Enter* key to terminate the MySQL shell if you opened
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python drivers for MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we want to use Python to talk to our database, we need to install another
    package. There are two main MySQL connectors for Python: *PyMySQL* and *MySQLdb*.
    The first is preferable from a simplicity and ease-of-use point of view. It is
    a pure Python library, which means that it has no dependencies. MySQLdb is a C
    extension and therefore has some dependencies, but it is a bit faster in theory.
    They work very similarly once installed. We''ll use PyMySQL in our examples throughout
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, run (while still on your VPS) the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating our Crime Map database in MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some knowledge of SQL's syntax will be useful for the rest of this chapter,
    but you should be able to follow either way. The first thing we need to do is
    create a database for our web application. If you're comfortable using a command-line
    editor, you can create the following scripts directly on the VPS as this can make
    them easier to debug and we won't run them locally. However, developing over an
    SSH session is far from ideal; so, I recommend that you write them locally and
    use Git to transfer them to the server before running.
  prefs: []
  type: TYPE_NORMAL
- en: This may make debugging a bit frustrating, so be extra careful in writing these
    scripts. If you want, you can get them directly from the code bundle that comes
    with this book. In this case, you simply need to populate the user and password
    fields in the `dbconfig.py` file. correctly, and everything should work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database setup script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `crimemap` directory in which we initialized our Git repository at the
    beginning of the chapter, create a python file called `db_setup.py` containing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at what this code does. First, we imported the `PyMySQL` library
    we just installed. We also imported `dbconfig`, which we'll create locally in
    a bit and populate with the database credentials (we don't want to store these
    in our repository). Then, we will create a connection to our database using `localhost`
    (because our database is installed on the same machine as our code) and the credentials
    that don't exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have connection to our database, we can get a cursor. You can think
    of a cursor a bit like the blinking object in your word processor that indicates
    where text will appear when you start typing. A database cursor is an object that
    points to a place in the database where we want to create, read, update, or delete
    data. Once we start dealing with database operations, there are various exceptions
    that could occur. We'll always want to close our connection to the database, so
    we will create a cursor (and do all the subsequent operations) inside a `try`
    block with `connection.close()` in a `finally` block (the `finally` block will
    get executed whether or not the `try` block succeeds).
  prefs: []
  type: TYPE_NORMAL
- en: The cursor is also a resource, so we'll grab one and use it in a `with:` block
    so that it'll automatically be closed when we're done with it. With the setup
    done, we can start executing the SQL code.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `cursor.execute()` function, the SQL code we will pass in will
    be run using the database engine, and the cursor will be populated with results
    if they are appropriate. We'll discuss later how we can read and write data using
    the cursor and the `execute()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQL reads similarly to English, so it's normally quite straightforward to work
    out what the existing SQL code does, even if it's a bit trickier to write new
    code. Our first SQL statement creates a `crimemap` database if it doesn't already
    exist (this means that if we come back to this script, we can leave this line
    in without deleting the entire database every time). We will create our first
    SQL statement as a string and use the `sql` variable to store it. Then, we will
    execute the statement using the cursor we created.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at our table columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know we have a database, we can create a table. The table will
    store the data for all the crimes that we record, with each crime in a row of
    the table. Therefore, we need several columns. Each column can be seen in our
    `create table` statement along with the type of data that will be stored in this
    column. To break these down, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**id**: This is a unique number that''s automatically recorded for every crime
    we have. We don''t need to worry too much about this field as MySQL will automatically
    insert it for us every time we add new crime data—starting at 1 and incrementing
    as required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latitude and longitude**: These fields will be used to store the location
    of each crime. We will specify `(10, 6)` after the floats which means that each
    float can be up to 10 digits and up to 6 digits can be after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date**: This is the date and time of the crime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category**: We will define several categories to classify different types
    of crime. This will help in filtering the crimes later. `VARCHAR(50)` means that
    this will be data of variable length and up to 50 characters long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: This is similar to `Category` but with a maximum of 1000 characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updated_at**: This is another field that we don''t need to worry about. MySQL
    will set this to the current time when we insert the data or edit it. This could
    be useful if we want to, for example, remove a bunch of data that was inserted
    by mistake at a specific time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing and committing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last line of our `create table` query specifies our `id` column as a *primary
    key*. This means that it'll be indexed (and therefore, we'll be able to find data
    very efficiently if we use it when we query our database), and will have various
    other useful properties, such as enforced existence and uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: Once we define this more complicated piece of SQL, we will execute it as well
    in the following line. Then, we will commit our changes to the database. Think
    of this as saving our changes; if we close the connection without the commit,
    our changes will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Commit**:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forgetting to commit changes is a common error of SQL beginners. If you get
    to a point where your database doesn't behave as expected and you can't figure
    out why, check whether you forgot a commit somewhere in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the database setup script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Save our script locally and push it to the repository. Refer to the following
    commands in this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH to your VPS and clone the new repository to your /var/www directory using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding credentials to our setup script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we still don''t have the credentials that our script relies on. We''ll
    do two things before using our setup script:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `dbconfig.py` file with a database and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add this file to `.gitignore` to prevent it from being added to our repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create and edit the `dbconfig.py` file directly on your VPS using `nano`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, type the following using the password you chose when you installed MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save it by hitting *Ctrl* + *X* and entering *Y* when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use similar `nano` commands to create, edit, and save `.gitignore`, which
    should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line prevents our `dbconfig` file from being added to our Git repository,
    which helps prevent an unauthorized use of our database password. The second line
    prevents compiled Python files from being added to the repository as these are
    simply runtime optimizations and are relevant to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Running our database setup script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With this done, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Assuming everything goes smoothly, you should now have a database with a table
    to store crimes. Python will output any SQL errors, allowing you to debug if necessary.
    If you make changes to the script from the server, run the same `git add`, `git
    commit`, and `git push` commands that you did from your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**git status:**'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run `git status` from the terminal (make sure you are in your repository
    directory) to see a summary of the files that are committed. You could use this
    now (before `git push`) to make sure that you didn't commit the `dbconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our preliminary database setup! Now, we can create a basic Flask
    project that uses our database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic database web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by building a skeleton of our Crime Map application. It''ll be
    a basic Flask application with a single page that:'
  prefs: []
  type: TYPE_NORMAL
- en: Displays all the data in the `crimes` table of our database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows users to input data and stores this data in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a **Clear** button that deletes all the previously input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although what we will store and display can't really be described as *crime
    data* yet, we'll store it in the `crimes` table that we created earlier. We'll
    just use the `description` field for now, ignoring all the other ones.
  prefs: []
  type: TYPE_NORMAL
- en: The process of setting up the Flask application is very similar to what we did
    before. We will separate out the database logic into a separate file, leaving
    our main `crimemap.py` file for the Flask setup and routing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On your local machine, change to the `crimemap` directory. If you created the
    database setup script on the server or made any changes to it there, make sure
    to sync the changes locally. Then, create the `templates` directory and touch
    the files we will use by running the following commands (or using the GUI file
    explorer if you prefer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looking at our application code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to the `crimemap.py` file. This contains nothing unexpected
    and should all be familiar from our Headlines project. The only thing to point
    out is the `DBHelper()` class, which we''ll consider the code for next. We will
    simply create a global `DBHelper` instance right after initializing our application
    and then use it in the relevant methods to grab data from the database, insert
    data into the database, or delete all data from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Looking at our SQL code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a little bit more SQL to learn from our database helper code. Add
    the following code to the `dbhelper.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As in our setup script, we need to make a connection with our database and then
    get a cursor from our connection in order to do anything meaningful. Again, we
    will do all our operations in `try:` `finally:` blocks in order to ensure that
    the connection is closed.
  prefs: []
  type: TYPE_NORMAL
- en: In our helper, we will consider three of the four main database operations.
    **CRUD** (**Create, Read, Update,** and **Delete**) describes the basic database
    operations. We will either create and insert new data, read the existing data,
    modify the existing data, or delete the existing data. We have no need to update
    data in our basic app, but creating, reading, and deleting are certainly useful.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with reading, assuming that there is some data already in our database.
    In SQL, this is done using the `SELECT` statement; we will choose which data we
    want to retrieve based on a set of conditions. In our case, the query in the `get_all_inputs`
    function is `SELECT description FROM crimes;`. We'll take a look a bit later at
    how to refine a `SELECT` query, but this one just grabs the `description` field
    for every row in our `crimes` table. This is similar to the example we talked
    about at the beginning of this chapter, in which we wanted to send out a newsletter
    and needed the e-mail address of each of our customers. Here, we want the description
    of each of our crimes.
  prefs: []
  type: TYPE_NORMAL
- en: Once the cursor executes the query, it will point to the beginning of a data
    structure containing the results. We will perform `fetchall()` on our cursor,
    which transforms our results set to a list so that we can pass them back to our
    application code. (If you've used generators in Python, it may help to think of
    a database cursor as a generator. It knows how to iterate over the data but doesn't
    itself contain all the data).
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next up is our `add_input()` function. This takes the data input by the user
    and *inserts* it into the database. Creating data in SQL is done using the `INSERT`
    keyword. Our query (assuming `foobar` is our passed in data) is `INSERT into crimes
    (description) VALUES ('foobar')`.
  prefs: []
  type: TYPE_NORMAL
- en: This may look overcomplicated for what it actually does, but remember that we're
    still dealing with a single field (description). We'll discuss later how `INSERT`
    is designed to accept multiple but arbitrary columns, which can all be named in
    the first set of brackets, and then matching values for each of these, which are
    given in the second set of brackets, after `VALUES`.
  prefs: []
  type: TYPE_NORMAL
- en: As we made changes to the database, we will need to *commit* our connection
    to make these permanent.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we will take a look at how concise a `DELETE` statement in SQL can
    be. `DELETE FROM crimes` wipes all the data from our `crimes` database. We'll
    consider later how to make this keyword behave less like a nuke by specifying
    conditions to delete only some data.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this makes changes to our database, so we need to commit these.
  prefs: []
  type: TYPE_NORMAL
- en: If all the new SQL commands seem to be a lot to take in, go play around with
    them for a bit in an online sandbox or even in our own live SQL shell that we
    discussed how to access earlier. You'll find that SQL comes quite naturally after
    a while as most of its keywords are taken from a natural language, and it uses
    very few symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's take a look at our HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our view code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python and SQL are fun to write, and they are indeed the main part of our application.
    However, at the moment, we have a house without doors or windows; the difficult
    and impressive bit is done, but it's unusable. Let's add a few lines of HTML to
    allow the world to interact without the code we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `templates/home.html`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing we haven't seen before. Here, we had a form with a single text
    input to add data to our database by calling the `/add` function of our app, and
    directly below it, we looped through all the existing data and displayed each
    piece within `<p>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code on our VPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need to make our code accessible to the world. This means pushing
    it to our `git` repo, pulling it onto the VPS, and configuring Apache to serve
    it. Run the following commands locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on your VPS, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a `.wsgi` file to link Python to Apache, which can be created
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.wsgi` file should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, hit *Ctrl* + *X* and then enter *Y* when prompted to save.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a new Apache `.conf` file, and to set this as the default
    (instead of `headlines`, the `.conf` file that is our current default). Run the
    following commands to create the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is so similar to the `headlines.conf` file we created for our previous
    project that you might find it easier to just copy the previous one and substitute
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to deactivate the old site and activate the new one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything should be working. If you copied the code out manually, it's
    almost certain that there's a bug or two to deal with. Don't be discouraged by
    this; remember that debugging is expected to be a large part of development! If
    necessary, run `tail –f /var/log/apache2/error.log` while you load the site to
    note any errors. If this fails, add some print statements to `crimemap.py` and
    `dbhelper.py` to narrow down where things are breaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything works, you should be able to see a web page with a single text
    input. When you submit text through the input, you should see the text displayed
    on the page, as in the example that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the code on our VPS](img/B04312_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how the data we get from the database is a tuple, so it is surrounded by
    brackets and has a trailing comma. This is because we selected only a single field,
    `'description'`, from our `crimes` table, while we could, in theory, be dealing
    with many columns for each crime (and soon we will do so).
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating against SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application contains a fatal flaw. We take input from our users and insert
    it into our SQL statements using Python string formatting. This works well when
    the user enters a normal alphanumeric string as expected, but if the user is malicious,
    they can actually inject their own SQL code and take control of our database.
    Although SQL injection is an old attack and most modern technology automatically
    mitigates against it, there are still dozens of attacks against major corporations
    every year in which passwords or financial data are leaked due to a SQL injection
    vulnerability. We'll take a moment to discuss what an SQL injection is and how
    to prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting SQL into our database application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigate to our web application and hit the **clear** link to remove any saved
    inputs. Now, in the input, type `Bobby` and click on the **Submit** button. The
    page should now look similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injecting SQL into our database application](img/B04312_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this input, now type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''); DELETE FROM crimes; --`'
  prefs: []
  type: TYPE_NORMAL
- en: All characters are important here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input needs to start with a single quote followed by a close bracket, followed
    by a semicolon, and then followed by the delete statement, another semicolon,
    a space, and finally two hyphens. You might expect to see a second line when the
    page refreshes, listing this strange-looking string beneath the **Bobby** output,
    but instead, you''ll see a blank page that looks similar to the screenshot that
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injecting SQL into our database application](img/B04312_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is weird, right? Let''s take a look at what happened. In our `DBHelper`
    class, our insert statements have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the user''s input gets added into the SQL code just before
    we run the code on the database. When we put the strange-looking input that we
    used previously into the placeholder of the SQL statement, we will get the following
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These are two SQL statements instead of one. We closed off the `INSERT` statement
    with an empty value and then deleted everything in the `crimes` table with the
    `DELETE` statement. The two hyphens at the end form an SQL comment so that the
    extra close quotation mark and bracket don't cause any syntax errors. When we
    input our data, we inserted a blank row into our database and then deleted all
    the data from the `crimes` table!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a creative attacker could run any SQL statement in place of the `DELETE`
    statement that we chose. They could drop an entire table (refer to [https://xkcd.com/327/](https://xkcd.com/327/)
    for a humorous example), or they could run a select statement to bypass a database
    login function. Alternatively, if you store credit card information, a similar
    attack could be used to fetch the data and display it to the attacker. In general,
    we don't want the users of our web application to be able to run arbitrary code
    on our database!
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating against SQL injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mitigating against SQL injection involves sanitizing user inputs and making
    sure that if the user inputs special characters that might be interpreted as SQL
    syntax, these characters are ignored. There are different ways to do this, and
    we'll use a simple one provided automatically by our Python SQL library. For more
    comprehensive information on this topic, take a look at [https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `dbhelper.py` file, change the `add_input()` method to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `%s` token that we used here is a string placeholder similar to `%d`, which
    is used in normal Python strings as a placeholder and an older alternative to
    braces. However, instead of using Python's `str.format()` function, we will pass
    the string and values that we want to insert into the placeholders to the PyMySQL
    `cursor.execute()` function. This will now automatically escape all characters
    that are meaningful to SQL so that we don't have to worry about them being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try the inputs again, you''ll see them displayed as expected-special
    characters and all-as in the screenshot that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mitigating against SQL injection](img/B04312_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the final chapter of this book, we'll briefly talk about ORM techniques that
    can provide even stronger mitigation against SQL injection attacks. While it might
    seem to be a simple problem that we've solved by escaping some special characters,
    it can actually become quite subtle. Tools such as **sqlmap** ([http://sqlmap.org/](http://sqlmap.org/))
    can try hundreds of different variants on the same idea (that is, the idea of
    inputting special characters against a database) until one gets unexpected results
    and a vulnerability is found. Remember that for your application to be secure,
    it has to be protected against every possible vulnerability; for it to be insecure,
    it only has to be vulnerable to one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it for the introduction to our Crime Map project. We discussed how to
    install a MySQL database on our VPS and how to hook it up to Flask. We looked
    at creating, reading, updating, and deleting data, and we created a basic database
    web application that can accept user input and display it back again. We finished
    off by looking at the SQL injection vulnerability and how to protect ourselves
    against it.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll add a Google Maps widget and some better aesthetics.
  prefs: []
  type: TYPE_NORMAL
