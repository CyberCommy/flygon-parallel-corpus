- en: '*Chapter 6*: Spawning Processes and Using Job Control'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about how processes are created on the system,
    which process is the very first one, and how all processes are related to each
    other. We'll then learn the many terms involved in processes and process management
    in Linux. After that, we'll learn how to fork new processes and what **zombies**
    and **orphans** are. At the end of this chapter, we'll learn what a **daemon**
    is and how to create one, before learning about what signals are and how to implement
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing how processes are created on the system is key to implementing good
    daemons, dealing with security, and creating efficient programs. It will also
    give you a better understanding of the overall system. In this chapter, we will
    cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring how processes are created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using job control in Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling and terminating processes using signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the program in a process with `execl()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forking a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a new program in a forked process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a new process with `system()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a zombie process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about what orphans are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a signal handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll need the GCC compiler and Make tool. We installed these
    tools in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting
    the Necessary Tools and Writing Our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need a new program called `pstree` for this chapter. You can install
    it with your package manager. If you are using Debian or Ubuntu, you can install
    it with `sudo apt install psmisc`. If, on the other hand, you are using Fedora
    or CentOS, you can install it with `sudo dnf install psmisc`.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need the generic `Makefile` we wrote in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*. The Makefile is also available on GitHub, together
    with all the code samples for this chapter, at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3cxY0eQ](https://bit.ly/3cxY0eQ)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring how processes are created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go into the details of creating processes and daemons, we need a general
    understanding of processes. The best way to get this understanding is by looking
    at the processes already running on your system, which is what we are going to
    do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Every process on the system has started its life by being *spawned*—forked—from
    another process. The very first process to be used on Unix and Linux systems has
    historically been `init` process has been replaced in modern Linux distributions
    with **systemd**. They both serve the same purpose; to start the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical **process tree** may look like this, where a user has logged on via
    a terminal (that is, if we skip the complexity of X Window logons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The process IDs are the numbers in parenthesis. `systemd` (or `init` on some
    older systems) have a `init`, even though `systemd` is used. In this case, `init`
    is just a link to `systemd`. There are still Linux systems that use `init`, though.
  prefs: []
  type: TYPE_NORMAL
- en: Having a deep understanding of how processes **spawn** is essential when it
    comes to writing system programs. For example, when we want to create a daemon,
    we often spawn a new process. There are many other use cases where we must spawn
    processes or execute a new program from an existing process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need `pstree`. Installation instructions for `pstree`
    are listed in the *Technical requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at our system and the processes it runs. We will
    use `pstree` to get a visual representation of these processes. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a way to get our current process ID. The `$$` environment variable
    contains the current shell''s **PID**. Please note that the PID will differ on
    every system and also from one time to another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at our current process, as well as its parent processes and
    child processes, with `pstree`. The parent process is what has started the process,
    while a child process is any process under it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output from the `pstree` command will most likely be different on your computer.
    Instead of `tmux`, you might have `xterm`, `konsole`, `mate-terminal`, or something
    similar. The `-A` option means to print the lines using ASCII characters, the
    `-p` option means to print the PID numbers, and the `-s` option means that we
    want to show the parent processes of the selected process (which is `$$` in our
    case). In my example, `tmux` is a child process of `systemd`, `bash` is a child
    process of `tmux`, and `pstree` is a child process of `bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A process can also have several children. For example, we can start several
    processes in Bash. Here, we will start three sleep processes. Each sleep process
    will sleep for 120 seconds. We will then print another `pstree`. In this example,
    `pstree` and the three `sleep` processes are all children of `bash`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of this chapter, we provided a sample process tree that showed
    a process called `login`. That process originally started out as `getty`, a process
    that manages TTYs on the system. `getty`/`login` concept, switch over to TTY3
    with *Ctrl*+*Alt*+*F3* to activate it. Then, go back to X (often on *Ctrl*+*Alt*+*F7*
    or *Ctrl*+*Alt*+*F1*). Here, we will use `grep` with `ps` to find TTY3 and make
    a note of its PID. The `ps` program is used to find and list processes on the
    system. Then, we will log in with a user on TTY3 (*Ctrl*+*Alt*+*F3*). After that,
    we will need to go back to our X Window session (and our terminal) again and use
    `grep` to find the PID we noted from TTY3\. The program in that process has now
    been replaced with `login`. In other words, a process can swap out its program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned about several important concepts regarding processes
    on Linux systems. We will need this knowledge moving forward. First off, we learned
    that all processes get spawned from an existing process. The very first process
    is `init`. On newer Linux distributions, this is a symbolic link to `systemd`.
    `systemd` then spawns several processes on the system, such as `getty`, to handle
    the terminals. When a user starts to log in on a TTY, `getty` is replaced with
    `login`, the program that handles logins. When the user finally logs in, the `login`
    process spawns a shell for the user, such as Bash. Every time the user then executes
    a program, Bash spawns a copy of itself and replaces it with the program the user
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify the process/program terminology a bit: a `getty`/`login` example.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using TTY3 in this recipe is that we get a *real* login process
    with `getty`/`login`, something we don't get when logging in via a X Window session
    or over SSH.
  prefs: []
  type: TYPE_NORMAL
- en: A process ID is denoted as PID. A parent process ID is denoted as `1`).
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that a process can have several children, as with the example
    provided of the `sleep` processes. We started the `sleep` processes with an `&`
    symbol at the end. This ampersand tells the shell that we want to start the process
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The acronym TTY comes from the fact that, back in the old days, it was an actual
    *teletype* connected to the machine. A teletype is a typewriter-looking terminal.
    You type your commands on the typewriter and read the response on the paper. For
    anyone interested in teletypes, Columbia University has some exciting pictures
    and information at [http://www.columbia.edu/cu/computinghistory/teletype.html](http://www.columbia.edu/cu/computinghistory/teletype.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using job control in Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only will job control give you a better understanding of foreground and
    background processes, but it will also make you more efficient when working on
    a terminal. Being able to put a process in the background frees up your terminal
    to do other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nothing particular is required for this recipe, except for the Bash shell. Bash
    is most often the default shell, so it's likely that you already have it installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will start and stop several processes, send them to the
    background, and bring them back to the foreground. This will give us an understanding
    of background and foreground processes. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we have seen how to start a process in the background with an ampersand
    (`&`). We will repeat that here, but we will also list the current jobs running
    and bring one of them to the foreground. The first background process we''ll start
    here is `sleep`, while the other will be a manual page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have two processes in the `jobs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sleep` process is in a running state, meaning that the seconds are ticking
    away in the program. The `man ls` command has been stopped, though. The `man`
    command is waiting for you to do something with it since it requires a terminal.
    So, right now, it doesn''t do anything. We can bring it to the foreground by using
    the `fg` command (`fg` command is the job ID from the `jobs` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Quit the manual page by hitting *Q*. `man ls` will appear on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, bring the sleep process to the foreground with `fg 1`. It only says `sleep
    300`, nothing more. But now, the program is in the foreground. This means we can
    now stop the program by hitting *Ctrl*+*Z*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With that, the program has been stopped, meaning it doesn't count down anymore.
    We can now once again bring it back to the foreground with `fg 1` and let it finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the previous process has finished, let''s start a new `sleep` process.
    This time, we can start it in the foreground (by omitting the ampersand). Then,
    we can stop the program by hitting *Ctrl*+*Z*. List the jobs and notice that the
    program is in a stopped state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can continue running the program in the background using the `bg` command
    (`bg` stands for *background*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also find the PID of the program by using a command called `pgrep`.
    The name `pgrep` stands for *Process Grep*. The `-f` option lets us specify the
    complete command, including its options, so that we get the correct PID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know the PID, we can kill the program using `kill`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also kill a program using `pkill`. Here, we will start another process
    and kill it with `pkill` instead. This command is used with the same options as
    `pgrep`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned about background processes, foreground process, stopped
    and running jobs, killing processes, and much more. These are some basics concepts
    that are used in job control in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: When we killed the process with `kill`, `kill` sent a signal to the process
    in the background. The default signal for `kill` is the `TERM` signal. `TERM`
    signal, though. The `TERM` signal is number 15\. A signal that can't be handled—that
    always kills a program—is signal 9, or the `KILL` signal. We will cover signal
    handling in more depth in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling and terminating processes using signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a bit more about processes, it's time to move on to signals
    and learn how we can kill and control a process using signals. In this recipe,
    we will also write our first C program, which will have a signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll explore how to control and terminate processes with
    signals. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by listing the signals we can send to a process using the `kill`
    command. The list you get from this command is rather long, so it''s not been
    included here. The most interesting—and used—signals are the first 31:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how some of these signals work. We can send the `STOP` signal (number
    19) to a process, which has the same effect as we saw when hitting *Ctrl*+*Z*
    in `sleep`. But here, we are sending the `STOP` signal to a background process
    directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can continue the process again by sending it the `CONT` signal (short
    for **continue**). We can type the name of the signal instead, if we wish, instead
    of its number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can kill the process by sending it the `KILL` signal (number 9):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a small program that acts upon different signals and ignores
    (or blocks) *Ctrl*+*C*, the interrupt signal. The `USR1` and `USR2` signals are
    perfect for this. Write the following code in a file and save it as `signals.c`.
    This code has been split up into multiple steps here, but all the code goes into
    this file. To register a signal handler in a program, we can use the `sigaction()`
    system call. We need to define `_POSIX_C_SOURCE` since `sigaction()` and its friends
    aren''t included in strict C99\. We also need to include the necessary headers
    files, write the handler function prototype, and begin the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create some variables and structures that we need. The `sigaction`
    struct that we will create, `action`, is for the `sigaction()` system call. A
    bit further down in the code, we set its member. First, we must set `sa_handler`
    to our function, which will execute when the signal is received. Second, we set
    `sa_mask` to all signals using `sigfillset()`. This will ignore all the signals
    while our signal handler is being executed, preventing it from being interrupted.
    Third, we set `sa_flags` to `SA_RESTART`, meaning any interrupted systems calls
    will be restarted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to register the signal handlers using `sigaction()`. The first
    argument to `sigaction()` is the signal we want to catch, the second argument
    is a struct for the new action that should be taken, and the third argument gives
    us the old action. If we are not interested in the old action, we set this to
    `NULL`. The actions must be a `sigaction` structs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we wanted the program to ignore *Ctrl*+*C* (the interrupt signal)?
    This can be achieved by calling `sigprocmask()` before the code that should ignore
    the signal. But first, we must create a *signal set* with all the signals it should
    ignore/block. First, we will empty the set with `sigemptyset()`, and then add
    the required signals with `sigaddset()`. The `sigaddset()` function can be called
    multiple times to add more signals. The first argument to `sigprocmask()` is the
    behavior, which is `SIG_BLOCK` here. The second argument is the signal set, while
    the third argument can be used to retrieve the old set. However, here, we will
    set it to `NULL`. After that, we start the infinite `for` loop. And after the
    loop, we unblock the signal set again. In this case, it''s not necessary since
    we will just quit the program, but in other cases, it''s advised to unblock the
    signals once we have moved past the section of code that should ignore them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s write the function that will be executed on `SIGUSR1` and `SIGUSR2`.
    The function will print the received signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program, either in a separate terminal or in the same terminal in the
    background. Notice that we are using the signal names here with `kill`; it''s
    a bit easier than keeping track of the numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we explored the many `TERM`, `KILL`, `QUIT`, `STOP`, `HUP`, `INT`, `STOP`,
    and `CONT`, as we saw here.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used the `STOP` and `CONT` signals to achieve the same effect that
    we achieved in the previous recipe; that is, to stop and continue running a background
    process. In the previous recipe, we used `bg` to continue running a process in
    the background, while to stop a process, we hit *Ctrl*+*Z*. This time, we didn't
    need to have the program open in the foreground to stop it; we just sent it the
    `STOP` signal with `kill`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we moved on and wrote a C program that catches two signals, `USR1`
    and `USR2`, and blocks the `SIGINT` signal (*Ctrl*+*C*). Depending on the signal
    we send to the program, different texts are printed. We did this by implementing
    a signal handler. A `sigaction()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling the `sigaction()` system call, we had to populate the `sigaction`
    structure with information about the handler function, which signals to ignore
    during the handler's execution, and which behavior it should have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signal sets, both for sigaction''s `sa_mask` and `sigprocmask()`, are created
    using the `sigset_t` type and manipulated with the following function calls (here,
    we''re assuming a `sigset_t` variable with the name `s` is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sigemptyset(&s);` clears all signals from `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigaddset(&s, SIGUSR1);` adds the `SIGUSR1` signal to `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigdelset(&s, SIGUSR1);` removes the `SIGUSR` signal from `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigfillset(&s);` sets all signals in `s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigismember(&s, SIGUSR1);` finds out if `SIGUSR1` is a member of `s` (not
    used in our example code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To print the PID of the process when it starts, we must fetch the PID with the
    `getpid()` system call. We store the PID in a variable of the `pid_t` type, as
    we have seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a lot of useful information in the manual pages for `kill`, `pkill`,
    `sigprocmask()`, and the `sigaction()` system call. I suggest you read them by
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 1 kill`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 1 pkill`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 sigprocmask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 sigaction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a much simpler system call, called `signal()`, that is also used for
    signal handling. Nowadays, that system call is more or less considered deprecated.
    But if you're interested, you can read about it in `man 2 signal`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the program in a process with execl()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we saw how `getty` gets replaced by `login`
    when a user logs in. In this recipe, we will write a small program that does exactly
    that—replaces its program with a new one. The system call for this is called `execl()`.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use `execl()` enables you to write programs that execute new
    programs inside the existing process. It also enables you to start a new program
    in a spawned process. When we start a new process, we probably want to replace
    that copy with a new program. So, understanding `execl()` is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to have read the first three recipes in this chapter to understand
    this one fully. The other requirements for this recipe are mentioned in the *Technical
    requirements* section of this chapter; for example, you'll need the `pstree` tool.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need two terminals or two terminal windows for this recipe. In
    one of these terminals, we will be running the program, while in the other terminal,
    we'll be looking at `pstree` for the process.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will write a small program that replaces the program running
    inside the process. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `execdemo.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program in your *current* terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start a *new* terminal and execute `pstree` with the PID from `execdemo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, go back to the first terminal, where `execdemo` is running, and hit *Enter*.
    This will print the password file with `less`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, go back to the second terminal—the one where you ran `pstree`. Rerun
    the same `pstree` command. Note that `execdemo` has been replaced with `less`,
    even though the PID is still the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `execl()` function executes a new program and replaces the old one in the
    same process. To make the program pause its execution so that we had time to view
    it in `pstree`, we used `getchar()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `execl()` function takes four mandatory arguments. The first one is the
    path to the program we want to execute. The second argument is the program's name,
    as it would be printed from `argv[0]`. Finally, the third and any following argument
    is the argument we want to pass to the program we are about to execute. To *terminate*
    this list of arguments that we want to pass to the program, we must end it with
    a pointer to `NULL`, cast as a `char`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to look at a process is to think of it as an execution environment.
    The program running inside that environment can be replaced. That's why we talk
    about processes and why we call them *Process IDs*, not Program IDs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several other `exec()` functions we can use, each with their own unique
    features and characteristics. These are often referred to as the "`exec()` family."
    You can read all about them by using the `man 3 execl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Forking a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we have been saying *spawned* when a program creates a new process.
    The correct terminology is to **fork** a process. What's happening is that a process
    creates a copy of itself—it *forks*.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to execute a new program inside a process
    using `execl()`. In this recipe, we'll learn how to fork a process using `fork()`.
    The forked process—the child—is a duplicate of the calling process—the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to fork a process enables us to create new processes on the system
    programmatically. Without being able to fork, we are limited to only a single
    process. For example, if we want to launch a new program from an existing one
    and still keep the original, we must fork.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in the previous recipes, you'll need the `pstree` tool. The *Technical
    requirements* section covers how to install it. You'll also need the GCC compiler
    and the Make tool. You'll also need two terminals; one terminal to execute the
    program and another to view a process tree with `pstree`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use `fork()` to fork a process. We''ll also view a process
    tree so that we can see what''s going on. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a program and save it as `forkdemo.c`. The `fork()`
    system call is highlighted in this code. Before we `fork()`, we print the PID
    of the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program in your *current* terminal and take note of the PID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in a new terminal, run `pstree` with the PID of `forkdemo`. Here, we can
    see that `forkdemo` has forked and that the PID that we got from the program before
    the fork is the parent process. The forked process is the `forkdemo` running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a process forks, it creates a duplicate of itself. This duplicate becomes
    a child process of the process that called `fork()`—the `fork()` returns the PID
    of the child process. Inside the child process, `0` is returned. This is why the
    parent could print the PID of the child process.
  prefs: []
  type: TYPE_NORMAL
- en: Both processes contain the same program code, and both processes are running,
    but only the specific parts in the `if` statements get executed, depending on
    whether the process is the parent or the child.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally speaking, both the parent and the child are identical except for the
    PID. There are, however, some other differences; for example, CPU counters are
    reset in the child. There are other such minor differences that you can read about
    in `man 2 fork`. However, the overall program code is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a new program in a forked process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to fork a process using the `fork()`
    system call. In the recipe before that, we learned how to replace the program
    in a process with `execl()`. In this recipe, we'll combine the two, `fork()` and
    `execl()`, to execute a new program in a forked process. This is what happens
    every time we run a program in Bash. Bash forks itself and executes the program
    we typed in.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use `fork()` and `execl()` enables you to write programs that
    start new programs. For example, you could write your own shell with this knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the `pstree` tool, the GCC compiler, and the Make
    tool. You can find installation instructions for these programs in the *Technical
    requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program that `forks()` and executes a new program
    in the child process. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following program code in a file and save it as `my-fork.c`. When
    we execute a new program inside a child process, we shall wait for the child process
    to finish. This is what we do with `waitpid()`. The `waitpid()` call also has
    another important function; to get the return status from the child process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In your current terminal, find the PID of the current shell and make a note
    of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute the program we compiled with `./my-fork`. This will display the
    manual page for `ls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a new terminal and look at the process tree for the shell in the other
    terminal. Note that `my-fork` has forked and replaced its content with `man`,
    which has forked and replaced its content with `pager` (to display the content):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Quit the manual page in the first terminal by hitting *Q*. This will yield
    the following text. Compare the PID of the parent process and the child process
    from `pstree`. Notice that the child process is `5850`, which was the `man` command.
    It started out as a copy of `my-fork`, but then replaced its program with `man`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fork()` system call is responsible for forking processes on Linux and Unix
    systems. `execl()` (or one of the other `exec()` functions) is then responsible
    for executing—and replacing its own—program with a new one. This is essentially
    how any program gets started on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we needed to tell the parent process to wait for the child process
    with `waitpid()`. If we needed to run a program that didn't require a terminal,
    we could have done without `waitpid()`. However, we should always wait for the
    child process. If we don't, the child will end up as an **orphan**. This is something
    we will discuss in great detail later on in this chapter, in the *Learning what
    orphans are* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: But in this particular case, where we execute the `man` command, which requires
    a terminal, we need to wait for the child for everything to work. The `waitpid()`
    call also enables us to grab the *return status* of the child. We also prevent
    the child from becoming an orphan.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the program and looked at the process tree with `pstree`, we saw
    that the `my-fork` process had forked itself and replaced its program with `man`.
    We could see this because the PID of the `man` command was the same as the PID
    of the child process of `my-fork`. We also noticed that the `man` command, in
    turn, had forked itself and replaced its child with `pager`. The `pager` command
    is responsible for displaying the actual text on the screen, which is usually
    `less`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new process with system()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we just covered regarding using `fork()`, `waitpid()`, and `execl()` to
    start a new program in a forked process is the key to understanding Linux and
    processes at a deeper level. This understanding is key to becoming an excellent
    system developer. However, there is a shortcut. Instead of manually dealing with
    forking, waiting, and executing, we can use `system()`. The `system()` function
    does all these steps for us.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you only need what's listed in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll rewrite the previous program—`my-fork`—using the `system()`
    function instead. You''ll notice how much shorter this program is compared to
    the previous one. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `sysdemo.c`. Notice how much
    smaller (and easier) this program is. The `system()` function does all the complex
    stuff for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a note of the shell''s PID using the `$$` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program in the current terminal. This will display the manual
    page for the `ls` command. Leave it running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new terminal and execute `pstree` on the PID from *step 3*. Notice
    that we have an additional process here called `sh`. This is because the `system()`
    function executes the `man` command from `sh` (the basic Bourne Shell):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This program was much smaller and easier to write. However, as we saw with
    `pstree`, there is an extra process compared to the previous recipe: `sh` (shell).
    The `system()` function works by executing the `man` command from `sh`. The manual
    page (`man 3 system`) clearly states this. It executes the command we specify
    by using the following `execl()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same, though. It performs a `fork()` and then an `execl()`
    call, and it waits for the child with `waitpid()`. This is also a great example
    of a higher-level function that uses lower-level system calls.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a zombie process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully understand processes in Linux, we also need to look at what a zombie
    process is. And to fully understand what this is, we need to create one ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: A **zombie** process is a child that has exited before the parent, and the parent
    process hasn't waited for the child's status. The name "zombie process" comes
    from the fact that the process is *undead*. The process has exited, but there
    is still an entry for it in the system process table.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what a zombie process is and how it's created will help you avoid writing
    bad programs that create zombie processes on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will write a small program that creates a zombie process
    on the system. We will also view the zombie process using the `ps` command. To
    prove that we can avoid zombies by waiting for the child, we will also write a
    second version with `waitpid()`. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and name it `create-zombie.c`. This program
    is the same as the one we saw in the `forkdemo.c` file, except that the child
    exits using `exit(0)` before the parent exits. The parent sleeps for 2 minutes
    after the child has exited, without waiting for the child with `waitpid()`, thus
    creating a zombie process. The call to `exit()` is highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program in the current terminal. The program (the parent process) will
    stay alive for 2 minutes. In the meantime, the child is a zombie since the parent
    didn''t wait for it or its status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'While the program is running, open up another terminal and check out the child''s
    PID with `ps`. You get the child''s PID from the preceding output from `create-zombie`.
    Here, we can see that the process is a zombie because of its status, `Z+`, and
    the word `<defunct>` after the process name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After 2 minutes—when the parent process has finished executing—rerun the `ps`
    command with the same PID. The zombie process will now be gone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, rewrite the program so that it looks as follows. Name the new version
    `no-zombie.c`. The code that''s been added is highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this new version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program in the current terminal. Just as before, it will create a child
    process that will exit immediately. The parent process will continue running for
    2 minutes, giving us enough time to search for the child''s PID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `no-zombie` program is running, open a new terminal and search for
    the child''s PID with `ps` and `grep`. As you will see, there is no process that
    matches the PID of the child. Hence, the child has exited correctly since the
    parent waited for its status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We always want to avoid creating zombie processes on the system, and the best
    way to do that is to wait for the child processes to finish.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 1 to 5*, we wrote a program that creates a zombie process. The zombie
    process gets created by the fact that the parent didn't wait for the child with
    the `waitpid()` system call. The child does exit, but it remains in the system
    process table. When we searched for the process with `ps` and `grep`, we saw the
    child process's status as `Z+`, meaning zombie. The process doesn't exist since
    it has exited using the `exit()` system call. However, it's still in there according
    to the system process table; hence, it's undead—a zombie.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 6 to 9*, we rewrote the program using the `waitpid()` system call
    to wait for the child. The child still exists before the parent, but this time,
    the parent gets the child's status.
  prefs: []
  type: TYPE_NORMAL
- en: A zombie process doesn't use up any system resources since the process has terminated.
    It only resides in the system process table. However, every process on the system—including
    zombies—takes up a PID number. Since there are a finite number of PIDs available
    to the system, there's a risk of running out of PIDs if dead processes are taking
    up PID numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many details about child process and their state changes in the manual
    page for `waitpid()`. There's actually three `wait()` functions available in Linux.
    You can read about them all by using the `man 2 wait` command.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about what orphans are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding what orphans are in a Linux system is just as crucial as understanding
    zombies. This will give you a deeper understanding of the entire system and how
    processes get inherited by `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: An `systemd`, which is the first process on the system—PID `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll write a small program that forks, thus creating a child
    process. The parent process will then exit, leaving the child as an orphan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything you need for this recipe is listed in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will write a short program that creates an orphan process
    that will be inherited by `systemd`. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `orphan.c`. The program will
    create a child process that will run for 5 minutes in the background. When we
    press *Enter*, the parent process will exit. This gives us time to investigate
    the child process with `pstree` both before and after the parent has exited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program in the current terminal and leave the program running. Don''t
    press *Enter* just yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in a new terminal, run `pstree` with the PID of the child. Here, we will
    see that it looks just like it did in the previous recipes. The process has been
    forked, which has created a child process with the same content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to end the parent process. Go back and hit *Enter* in the terminal
    where `orphan` is still running. This will end the parent process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run `pstree` again in the second terminal. This is the same command that
    you just ran. As you can see, the child process has now been inherited by `systemd`
    since its parent has died. After 5 minutes, the child process will exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other, more standardized tools we can use to view the `ps`. Run the
    following `ps` command to view more detailed information about the child process.
    Here, we will see a lot more information. The most important to us is the PPID,
    PID, and the **Session ID** (**SID**). We will also see the **User ID** (**UID**)
    here, which specifies who owns the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every process needs a parent process. That's the reason why `systemd` inherits
    any processes on the system that end up as orphans.
  prefs: []
  type: TYPE_NORMAL
- en: The code inside `if (pid == 0)` continued to run for 5 minutes. That gave us
    enough time to check that the child process had been inherited by `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we used `ps` to view more details about the child process.
    Here, we saw the PPID, PID, PGID, and SID. Some new names have been mentioned
    here that are important to know. We already know about PPID and PID, but PGID
    and SID haven't been covered yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**PGID** stands for **Process Group ID** and is a way for the system to group
    processes. The PGID for the child process is the PID of the parent process. In
    other words, this PGID was created to group the parent and child process since
    they belong together. The system sets the PGID to the PID of the parent who created
    the group. We don''t need to create these groups ourselves; that is something
    the system does for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '`18817`, which is the PID of the Bash shell. The same rules apply here; the
    SID number will be the same as the PID of the process that started the session.
    This session consists of my user''s shell and all the programs that I start from
    it. That way, the system can kill all the processes that belong to that session
    if I log off the system.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of information you can get with `ps`. I recommend that you at
    least skim through the manual with `man 1 ps`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common assignment when working with system programming is to create various
    daemons. A **daemon** is a background process that runs on the system and performs
    some tasks. The SSH daemon is a great example of this. Another great example is
    the NTP daemon, which takes care of synchronizing the computer clock and sometimes
    even distributing the time to other computers.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to create a daemon will enable you to create server software; for
    example, web servers, chat servers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple daemon to demonstrate some important
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll only need the components listed in the *Technical requirements* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a small daemon that will run in the background
    in our system. The only "work" the daemon will do is write the current date and
    time to a file. This proves that the daemon is alive and well. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the daemon is rather long compared to our previous examples. Therefore,
    the code has been split into several steps. There are some new things here as
    well that we haven''t covered yet. Write the code in a file and save it as `my-daemon.c`.
    Remember that all the code in all the steps goes into this file. We''ll start
    with all the `include` files, the variables we''ll need, and our `fork()`, as
    we have seen previously. This `fork()` will be the first of two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve forked, we want the parent to exit. Once the parent has exited,
    we will be in the child process. In the child process, we will create a new session
    with `setsid()`. Creating a new session will free the process from the controlling
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to `fork()` again. This second fork will create a new process
    just as before, but since it''s a new process in an already existing session,
    it will not be a session leader, preventing it from obtaining a new controlling
    terminal. The new child process is referred to as a grandchild. Once again, we
    exit the parent process (the child process). However, before we exit the child,
    we write the PID of the grandchild to a **PID file**. This PID file is used to
    keep track of the daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the default mode (*umask*) to something sensible for the daemon. We
    must also change the current working directory to `/` so that the daemon won''t
    prevent a filesystem from unmounting or a directory from being deleted. Then,
    we must open the daemon file, which is what we will write our messages to. The
    messages will contain the current date and time and will let us know if everything
    is working. Normally, this would be a log file instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the daemon will only run detached in the background, we have no use for
    stdin, stdout, and stderr, so let''s close them all. However, it''s not safe to
    leave them closed. If something in the code would open a file descriptor at a
    later time, it will get file descriptor 0, which is usually stdin. File descriptors
    are assigned in sequence. If there are no open file descriptors, the first call
    to `open()` will get descriptor `0`; the second call will get descriptor `1`.
    Another problem might be that some parts might try to write to stdout, which no
    longer exists, making the program crash. Therefore, we must reopen them all, but
    to `/dev/null` (the black hole) instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can start the daemon''s work. This is just a `for` loop that writes
    a message to the daemon file saying the daemon is still alive. Notice that we
    must flush the file pointer after each `fprintf()` with `fflush()`. Usually, in
    Linux, things are *line buffered*, meaning only a single line is buffered before
    writing. However, since this is a file and not stdout, it''s fully buffered instead,
    meaning it buffers all data until either the buffer is full or the file stream
    is closed. Without `fflush()`, we wouldn''t see any text in the file until we
    have filled the buffer. By using `fflush()` after each `fprintf()`, we can see
    the text live in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to compile the entire daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the daemon. Since we are writing the PID file to `/var/run`,
    we need to execute the daemon as root. We won''t get any output from the daemon;
    it will silently detach from the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the daemon is running, let''s check out the PID number that''s been
    written to `/var/run/my-daemon.pid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s investigate the daemon process using both `ps` and `pstree`. If everything
    has worked out the way it should have, it should have `systemd` as its parent,
    and it should be in its own session (SID should be the same as the process ID):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also take a look at the `/tmp/my-daemon-is-alive.txt` file. This file
    should contain some rows specifying the date and time, 30 seconds apart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s kill the daemon so that it doesn''t continue to write to the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The daemon we have just written is a basic traditional daemon, but it demonstrates
    all the concepts we need to understand well. One of these new and important concepts
    is how to start a new session with `setsid()`. If we don't create a new session,
    the daemon will still be a part of the user's login session and die when the user
    logs off. But since we've created a new session for the daemon and it is inherited
    by `systemd`, it now lives on its own, unaffected by the user and process that
    started it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for forking the second time is that a session leader—which is what
    our first child after the `setsid()` call is—can acquire a new controlling terminal
    if it were to open a terminal device. When we do the second fork, that new child
    is just a member of the session that was created by the first child, not the leader,
    and hence it cannot acquire a **controlling terminal** anymore. The reason for
    avoiding a controlling terminal is that if that terminal would exit, so would
    the daemon. Forking twice when creating a daemon is often called the **double-fork**
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we needed to start the daemon as root is that it needs to write to
    `/var/run/`. If we were to change the directory—or skip it entirely—the daemon
    would run just fine as a regular user. However, most daemons do run as root. There
    are, however, daemons that run as regular users; for example, daemons that handle
    user-related things, such as `tmux` (a **terminal multiplexer**).
  prefs: []
  type: TYPE_NORMAL
- en: We also changed the working directory to `/`. This is so that the daemon won't
    lock up a directory. The top root directory isn't going to be removed or unmounted,
    which makes it a safe working directory for the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have written here is a traditional Linux/Unix daemon. These kinds of
    daemons are still used today, for example, for small and quick daemons like this
    one. However, since `systemd` came around, we no longer need to "daemonize" a
    daemon the way we just did. For example, it's advised to leave stdout and stderr
    open and send all log messages there instead. These messages will then show up
    in the *journal*. We will cover systemd and the journal in more depth in [*Chapter
    7*](B13043_07_Final_SK_ePub.xhtml#_idTextAnchor299)*, Using systemd to Handle
    Your Daemons*.
  prefs: []
  type: TYPE_NORMAL
- en: The type of daemon we have written here is called *forking* in systemd language,
    which we'll learn more about later on.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `system()` simplified things for us when executing new programs, there
    is a function called `daemon()` that can create daemons for us. This function
    will do all the heavy lifting for us, such as forking, closing and reopening the
    file descriptors, changing the working directory, and more. However, please note
    that this function doesn't use the double-fork technique we used for our daemons
    in this recipe. This fact is clearly stated under the BUGS section in the `man
    3 daemon` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a signal handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we wrote a simple but functional daemon. However, there
    are some problems with it; for example, the PID file isn't removed when the daemon
    is killed. Likewise, the open file stream (`/tmp/my-daemon-is-alive.txt`) isn't
    closed when the daemon is killed. A proper daemon should clean up after itself
    when it exits.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to clean up on exit, we need to implement a signal handler. The signal
    handler should then take care of all the cleanup before the daemon is terminated.
    We have already seen examples of signal handlers in this chapter, so this concept
    isn't new.
  prefs: []
  type: TYPE_NORMAL
- en: It's not only daemons that use signal handlers, though. This is a common way
    of controlling processes, especially processes that don't have a controlling terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the previous recipe before reading this one so that you understand
    what the daemon does. Other than that, you'll need the programs listed in the
    *Technical requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll add signal handlers to the daemon we wrote in the previous
    recipe. Since the code will be a bit longer, I have split it up into several steps.
    Remember, though, that all the code goes in the same file. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in and file a name it `my-daemon-v2.c`. We''ll start
    with the `#include` files and the variables, just as we did previously. However,
    notice that this time, we have moved some of the variables to the global space.
    We have done this so that the signal handler can access them. There is no way
    to pass extra arguments to a signal handler, so this is the best way to access
    them. Here, we must also define `_POSIX_C_SOURCE` for `sigaction()`. We must also
    create a prototype for our signal handler here, called `sigHandler()`. Also, notice
    the new `sigaction` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did previously, we must create a new session after the first fork.
    After that, we must do the second fork to make sure it isn''t a session leader
    anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, as we did previously, we must change the umask, the current working
    directory, and open the daemon file with `fopen()`. Next, we must close and reopen
    stdin, stdout, and stderr:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s finally time to prepare and register the signal handlers. This is
    exactly what we covered earlier in this chapter, only here, we are registering
    handlers for all the common exit signals, such as terminate, interrupt, quit,
    and abort. Once we have dealt with the signal handlers, we will begin the daemon''s
    work; that is, the `for` loop that will write messages to the daemon file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must implement the function for the signal handler. Here, we clean
    up after the daemon by removing the PID file before exiting. We also close the
    open file stream to the daemon file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the new version of the daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the daemon as root, just as we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the PID in the PID file and make note of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Check it out with `ps` to see that it''s running as it should:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Kill the daemon with the default signal, `TERM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything has worked out as planned, the PID file will have been removed.
    See if you can access the PID file with `cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we implemented a signal handler that takes care of all the
    cleanup. It removes the PID file and closes the open file stream. To cover the
    most common "exit" signals, we registered the handler with four different signals:
    *terminate*, *interrupt*, *quit*, and *abort*. When one of these signals is received
    by the daemon, it triggers the `sigHandler()` function. This function then removes
    the PID file and closes the file stream. Finally, the function exits the entire
    daemon by calling `exit()`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, since we can't pass the filename or the file stream as an argument
    to the signal handler, we placed those variables in the global scope instead.
    This makes it possible for both `main()` and `sigHandler()` to reach them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that we had to flush the stream for the time and date to show up in
    `/tmp/my-daemon-is-alive.txt`? Since we now close the file stream once the daemon
    exits, we don't need `fflush()` anymore. The data is written to the file when
    it closes. However, then we can't see the time and date "live" while the daemon
    is running. That's why we still have `fflush()` in the code.
  prefs: []
  type: TYPE_NORMAL
