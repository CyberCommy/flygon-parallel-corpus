- en: Tools for Cleaner Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools we use have a massive impact on the habits we fall into when writing
    code. When coding, just as in life, we want to gather good habits and avoid bad
    habits. An example of a good habit would be writing syntactically valid JavaScript.
    To help us enforce this good habit, we can use a linter to inform us when our
    code is invalid. We should consider each tool in this way. What good habit does
    it inspire? What bad habit does it discourage?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we recall our original tenets of clean code (*R.E.M.U*) we can observe how
    various tools help us abide by them. Here''s just a small collection of tools
    that would be of service to the four tenets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: Testing tools, user feedback, error loggers, analytics, linters,
    static typing tools, and languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Performance measurement, analytics, user feedback, UX reviews,
    ecological costing (for example, *carbon footprint*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Formatters, linters, documentation generators, automated
    builds, and continuous integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Analytics, user feedback, documentation generators, accessibility
    checkers, UX reviews, and *hallway testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tools that inspire good habits work by augmenting our *feedback loops*. A feedback
    loop is whatever eventually makes you realize that you need to make a change.
    Perhaps you introduced a bug that caused an error to be logged. Perhaps your implementation
    is unclear and a colleague complained. If tools can catch these situations early,
    then it can speed up our feedback loop, enabling us to work faster and to a higher
    level of quality. In the following diagram, we illustrate **Our Feedback Loop** and
    how it is fed by information from tools at each stage of development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab23a961-0c64-451d-9f3d-cbf75064f16b.png)'
  prefs: []
  type: TYPE_IMG
- en: Throughout our stages of development, there are many avenues of feedback. There
    are linters to tell us when our syntax is problematic, static type checkers to
    confirm we are using types correctly, and tests to confirm our expectations. Even
    after deployment, this feedback continues. We have error logs that indicate failure,
    analytics that tell us about user behavior, and feedback from end users and other
    individuals informing us about breakages or areas for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Different projects will operate in different ways. You may be a solo programmer
    or 1 of 100 programmers dedicated to a specific project. Regardless, there will
    likely be various stages of development, and the possibility of feedback exists
    at every stage. Tooling and communication is vital to an effective feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering a small selection of the tools that can
    help us in building good habits and a positive feedback loop. Specifically, we''re
    going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linters and formatters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E testing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated builds and CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linters and formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **linter** is a tool used to analyze code and discover bugs, syntax errors,
    stylistic inconsistencies, and suspicious constructs. Popular linters for JavaScript
    include *ESLint*, *JSLint*, and *JSHint*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most linters allow us to specify what types of bugs or inconsistencies we would
    like to look for. *ESLint*, for example, will allow us to specify a global configuration
    for a given code base in a root-level `.eslintrc` (or `.eslintrc.json`) file.
    In it, we can specify the version of the language we are using, which features
    we are using, and which linting rules we would like to be enforced. Here''s an
    example `.eslintrc.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an explanation of our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ecmaVersion`: Here, we are specifying that our code base is written in the
    ECMAScript 6 (2016) version of JavaScript. This means that the linter will not
    complain if it sees you are using ES6 features. It will, however, complain if
    you use ES7/8 features, as you would expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sourceType`: This specifies that we are using ES modules (imports and exports).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ecmaFeatures`: This informs ESLint that we wish to use JSX, a syntax extension
    that allows us to specify XML-like hierarchies (this is used considerably in component
    frameworks like React).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extends`: Here, we specify a default ruleset of `"eslint:recommended"`, which
    means that we''re happy for ESLint to enforce a recommended set of rules. Without
    this, ESLint would only enforce the rules we specify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rules`: Lastly, we are configuring the specific rules we wish to set on top
    of the recommended configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semi`: This rule relates to semicolons; in our override, we are specifying
    that we wish for an error to be produced in the case of a missing semicolon in
    case of a mere warning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quotes`: This rule relates to quotes and specifies that we wish for single
    quotes to be enforced, meaning that the linter will warn us if it sees double
    quotes in our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can try our configuration out by writing a piece of code that intentionally
    breaks the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we install and run ESLint on this code (within bash: `> eslint example.js`),
    then we''ll receive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This details all of the errors in the syntax according to our configured rules.
    As you can see, it details the rule that was broken and the line the problem was
    found on. ESLint and other linting tools can be incredibly helpful in finding
    hard-to-spot syntax errors, some of which may, if left untouched, lead to difficult
    to debug functional bugs in the future. Linting also gives the code more consistency,
    enabling programmers to feel a sense of familiarity and endure less cognitive
    burden, as would be the case in a code base with many different syntax conventions.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint also includes a facility for fixing a subset of these syntax errors via
    its `--fix` option, although you may have noticed that only a subset of errors
    can be fixed this way. Others will need to be done manually. Thankfully, though,
    there are a number of more advanced tools available to help us out. Formatters,
    such as **Prettier** and **Standard JS**, will take our syntactic preferences
    and make active changes to our code to ensure that it remains consistent. This
    means that programmers don't have to burden themselves with specific syntactic
    rules, or endlessly change code in response to linters. They can write code in
    the manner they desire, and when they're done, the formatter will change the code
    to conform to the agreed upon syntax conventions or warn the programmer if there
    is a severe or invalid syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let''s run Prettier with its default configuration on a simple
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the preceding code through Prettier, we receive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Prettier has removed and changed some of our syntactic habits
    to its configured conventions. Namely, it has exchanged single quotes for double
    quotes, it has removed redundant parentheses, and it's made significant changes
    to the whitespace. The magic of formatters is that they take the pain away from
    the programmer. They do the work of correcting minor syntactic habits, leaving
    the programmer free to pursue more important work. The general trend in the industry
    is away from simple linters and toward more fully featured tools that combine
    both linting and formatting.
  prefs: []
  type: TYPE_NORMAL
- en: The decision over what syntactic conventions to abide by is configurable and
    entirely up to you. There are many strongly held opinions about this, but the
    most important tenet to uphold is consistency. I personally prefer single quotes
    to double quotes, for example, but if I'm working in a code base where double
    quotes are the established convention, then I'll have no qualms about changing
    my habits. Most of the time, syntactic preferences are just subjective and inherited
    norms, so what's important is not which norm we use, but whether or not we all
    abide by it.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the norms we have grown used to within the JavaScript language have
    been guided by its dynamically typed nature. For example, we have become used
    to having to check manually for specific types in order to provide meaningful
    warnings or errors within our interfaces. For many, these norms have been challenging
    to adapt to, and they have grown desperate for a higher level of confidence in
    the types they use. Thus, people have brought various static typing tools and
    language extensions to JavaScript. We'll be exploring these next, and while we
    do, take note of how such static typing tools might change or improve your personal
    development feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: Static typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've explored at length, JavaScript is a dynamically typed language. If
    wielded carefully, this can be a great benefit, allowing you to work quickly and
    permit a level of flexibility in your code that enables colleagues to work with
    it less painfully. However, there are situations in which dynamic types can create
    the possibility of bugs and needless cognitive burdens for programmers. Statically
    typed compiled languages, such as Java or Scala, force the programmer to specify
    the types they are expecting at the point of declaration (or infer the type by
    how it is used, prior to execution).
  prefs: []
  type: TYPE_NORMAL
- en: 'Static typing has the following potential benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The programmer can **have confidence in the types** they'll be dealing with,
    and thus, can make a number of safe assumptions about the capabilities and characteristics
    of their values, easing development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code can be statically type-checked prior to execution, meaning that **potential
    bugs can be caught** easily and are not liable to specific (and accidental) arrangements
    of types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintainers and users of the code (or its APIs) have a **clearer set of
    expectations** to operate under and are not left guessing what may or may not
    work. The specification of types can itself serve as a sort of documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though JavaScript is dynamically typed, there have been efforts to give
    JavaScript programmers the benefits of a static typing system. Two pertinent examples
    of this are Flow and TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow** ([https://flow.org/](https://flow.org/)) is a static type checker
    and language extension to JavaScript. It allows you to annotate types using its
    own specific syntax, although it isn''t considered a distinct language of its
    own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript** ([http://www.typescriptlang.org/](http://www.typescriptlang.org/))
    is a superset language of JavaScript, developed by Microsoft (meaning that valid
    JavaScript is always valid TypeScript). It is a language unto itself, with its
    own syntax for type annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both Flow and TypeScript allow you to declare the types that you are declaring,
    either alongside variable declarations or parameter declarations within functions.
    Here''s an example of declaring a function that accepts `productName` (`string`)
    and `rating` (`number`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Both Flow and TypeScript generally allow the annotation of types following
    a declaration identifier in the `IDENTIFIER: TYPE` form, where `TYPE` can be any
    of `number`, `string`, `boolean`, and many more. They do differ in many ways though,
    so it''s important to investigate both. Naturally, both Flow and TypeScript, and
    most other static type checking technologies for JavaScript, will require a *build*
    or *compilation* step in order to work, as they include syntax extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that static typing is not an elixir. The cleanliness of our code is
    not only constrained to its ability to avoid type-related bugs and difficulties.
    We have to *zoom out*, in our perspective, and remember to consider the user and
    what they're trying to achieve via our software. It's quite common to see passionate
    programmers get lost in the minutiae of their syntax but forgo the bigger picture.
    So, to change tack slightly, we'll now explore *E2E testing tools*, as E2E testing
    can be as significant in its effect on the quality of a code base as the typing
    system or syntax we use, if not more!
  prefs: []
  type: TYPE_NORMAL
- en: E2E testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few chapters, we explored the benefits and types of testing, including
    an overview of E2E testing. The testing libraries we typically use to build test
    suites and make assertions rarely include E2E testing facilities, so it's necessary
    for us to find our own tooling for this.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of an E2E test is to emulate user behavior upon our application and
    to make assertions about the application's state at various stages of user interaction.
    Typically, an E2E test will test a specific user flow, such as *user can register
    new account* or *user can log in and buy product*. Whether we're using JavaScript
    on the server side or the client side, if we're building a web application, it
    will be hugely beneficial to carry out such testing. To do so, we need to use
    a tool that can artificially create the user environment. In the case of a web
    application, the user environment is a browser. And thankfully, there are a large
    number of tools that can either emulate or run real (or *headles**s*) browsers
    that we can access and control via JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: A **headless** browser is a web browser without a graphic user interface. Imagine
    the Chrome or Firefox browser, but without any visible UI, entirely controllable
    via a CLI or a JavaScript library. Headless browsers allow us to load up our web
    application and make assertions about it without having to pointlessly expend
    hardware capabilities on rendering a GUI (meaning we can run such tests on our
    own computers or *in the cloud* as part of our *continuous integration/deployment* process).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of such a tool is **Puppeteer**, a Node.js library that provides
    an API to control Chrome (or Chromium). It can run either headless or non-headless.
    Here''s an example in which we open a page and log its `<title>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Puppeteer provides a high-level API that allows the creation and navigation
    of browser pages. Within this context, using a `page` instance, we can then evaluate
    specific client-side JavaScript via the `evaluate()` method. Any code passed to
    this method will be run within the context of the document, and will, therefore,
    have access to the DOM and other browser APIs.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we're able to retrieve the `textContent` property of the `<title>`
    element. You'll have noticed that much of Puppeteer's API is asynchronous, meaning
    that we have to either use `Promise#then` or `await` to wait for each instruction
    to complete. This may be bothersome, but considering the fact that the code is
    running and controlling an entire web browser, it makes sense that some tasks
    are asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'E2E testing is rarely embraced because it is perceived as being difficult.
    While that perception was accurate at one point, it is no longer so. With APIs
    like that of Puppeteer, we can easily launch our web application, trigger specific
    actions, and make assertions about the results. Here''s an example of using Jest
    (a testing library) with Puppeteer to make an assertion about the text within
    the `<title>` element at `https://google.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Fetching a page, parsing its HTML, and producing a DOM that we can make assertions
    about is a very complex process. Browsers are incredibly effective at doing this,
    so it makes sense to utilize them in our testing process. After all, it is whatever
    the browser sees that will dictate what the end user sees. E2E tests give us realistic
    insights into potential breakages, and it's no longer hard to write or run them.
    They are immensely powerful for the clean coder especially, as they let us see
    the reliability of our code from a more user-oriented perspective.
  prefs: []
  type: TYPE_NORMAL
- en: As with many of the tools we've explored, E2E testing may be best integrated
    into our development experience via automation. We'll now explore this in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Automated builds and CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have highlighted, there are a large number of tools available to help
    us write clean code. These tools can be activated manually, usually via a **command-line
    interface** (**CLI**) or sometimes within our IDEs. Usually, however, it is prudent
    to have them run as part of our various stages of development. If using source
    control, then this process will include a *commitment* or *staging* process and
    then a *pushing* or *checking-in *process. These events, when combined with the
    simple act of making changes to files, represent the three vital development stages
    that our tooling can use to generate their outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upon changes to files**: It is typical for JavaScript (or CSS) transpilation
    or compilation to occur at this stage. For example, if you''re writing JS that
    includes the JSX language extension (React), then you''re likely relying on *Babel*
    to constantly compile your JS hybrid to valid ECMAScript (see Babel''s `--watch`
    command flag). It''s also common to have linting or other code formatting occur
    when files are mutated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upon committing**: It is typical for linting, testing, or other code validation
    to occur at the pre- or post-commit stage. This is useful in that any invalid
    or broken code can be flagged before it is pushed. It''s not rare for asset generation
    or compilation to also occur at this stage (for example, generating valid CSS
    from SASS, an alternative style sheet language).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upon pushing**: It is typical for all processes (linting, testing, compilation,
    generation of assets, and so on) to occur within a remote machine when new code
    has been pushed to either a feature branch or the master branch. This is called
    **continuous integration** and allows programmers to see how their code would
    run when combined with their colleagues'' code before deploying to production.
    Examples of tools and services that are used for CI include **TravisCI**, **Jenkins**,
    and **CircleCI**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can greatly ease development to have your tooling activate automatically,
    however, this isn't a requirement. You can lint your code, run tests, transpile
    your CSS, or generate compressed assets all via the CLI, without having to fuss
    with automation. You may find this to be slower though, and it's more likely that
    your tooling will be used inconsistently amongst your team if it is not standardized
    into a set of automations. It may be the case, for example, that your colleague
    always runs tests before transpiling SCSS to CSS, while you tend to do it the
    other way round. This can result in inconsistent bugs and *it works on my machine *syndrome.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discovered the usefulness of tooling, highlighting
    its power to improve our feedback loops, and how it empowers us to write cleaner
    code. We have explored a number of specific libraries and utilities as well, giving
    us a flavor of what types of tools exist and the various ways in which our abilities
    and habits as programmers can be augmented. We've tried out linters, formatters,
    static type checkers, and E2E testing tools, and we've seen the merits of tooling
    at every stage of development.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter begins our journey into the art and science of collaboration;
    a vital ingredient for anyone who wants to write clean code. We'll begin with
    an exploration of how we can write clear and understandable documentation.
  prefs: []
  type: TYPE_NORMAL
