- en: '*Chapter 11*: Debugging Using LLVM Tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM comes with a set of tools that helps you to identify certain errors in
    your application. All of these tools make use of the LLVM and **Clang** libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to instrument an application with **sanitizers**,
    how to use the most common sanitizer to identify a wide range of bugs, and how
    to implement fuzz testing for your application. This will help you to identify
    bugs that are usually not found with unit testing. You will also learn how to
    identify performance bottlenecks in your application, running the **static analyzer**
    to identify problems normally not found by the compiler, and creating your own
    Clang-based tool with which you can extend Clang with new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting an application with sanitizers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding bugs with **libFuzzer**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance profiling with **XRay**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the source with the **Clang Static Analyzer**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own Clang-based tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to use various LLVM and Clang tools
    to identify a large category of errors in an application. You will also acquire
    the knowledge to extend Clang with new functionality, for example, to enforce
    a naming convention or to add new source analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the **flame graph** in the *Performance profiling with XRay* section,
    you need to install the scripts from [https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph).
    Some systems, such as **Fedora** and **FreeBSD**, provide a package for these
    scripts, which you can also use.
  prefs: []
  type: TYPE_NORMAL
- en: To view the **Chrome visualization** in the same section, you need to have the
    **Chrome** browser installed. You can download the browser from [https://www.google.com/chrome/](https://www.google.com/chrome/),
    or use the package manager of your system to install the Chrome browser. The code
    files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter11)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting an application with sanitizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM comes with a couple of `compiler-rt` project. Sanitizers can be enabled
    in Clang, which makes them very comfortable to use. In the following sections,
    we will have a look at the available sanitizers, namely, `address`, `memory`,
    and `thread`. We will first look at the `address` sanitizer.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting memory access problems with the address sanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use the `address` sanitizer to detect a couple of memory access bugs in
    an application. This includes common errors such as using dynamically allocated
    memory after freeing it, or writing to dynamically allocated memory outside the
    boundaries of the allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: When enabled, the `address` sanitizer replaces calls to the `malloc()` and `free()`
    functions with its own version, and instruments all memory access with a checking
    guard. Of course, this adds a lot of overhead to the application, and you will
    use the `address` sanitizer only during the testing phase of the application.
    If you are interested in the implementation details, then you can find the source
    of the pass in the `llvm/lib/Transforms/Instrumentation/AddressSanitzer.cpp` file
    and a description of the algorithm used at [https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a short example to demonstrate the capabilities of the `address`
    sanitizer. The following example application, `outofbounds.c`, allocates `12`
    bytes of memory, but initializes `14` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can compile and run this application without noticing any problems. This
    is typical for this kind of error. Even in larger applications, this kind of bug
    can go unnoticed for a long time. But, if you enable the `address` sanitizer with
    the `-fsanitize=address` option, then the application stops after detecting the
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also useful to enable debug symbols with the `–g` option, because it
    helps to identify the location of the error in the source. The following code
    is an example of how to compile the source file with the `address` sanitizer and
    debug symbols enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you get a lengthy error report when running the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The report also contains detailed information about the memory content. The
    important information is the type of error – `address` sanitizer intercepts the
    execution of the application. It shows *line 6* in the `outofbounds.c` file, which
    is the line containing the call to `memset()` – indeed, the exact place where
    the buffer overflow happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you replace the line containing `memset(p, 0, 14);` in the `outofbounds.c`
    file with the following code, then you introduce access to memory after the memory
    is freed. You''ll need to store the source in the `useafterfree.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, if you compile and run it, the use of the pointer after the memory is
    free is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time, the report points to *line 8*, which contains dereferencing of the
    `p` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'On `ASAN_OPTIONS` environment variable to the value `detect_leaks=1` before
    running the application, then you also get a report about memory leaks. On the
    command line, you do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `address` sanitizer is very useful, because it catches a category of bugs
    that are otherwise difficult to detect. The `memory` sanitizer does a similar
    task, and we'll look at it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Finding uninitialized memory access with the memory sanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using uninitialized memory is another category of bugs that are hard to find.
    In **C** and **C++**, the general memory allocation routines do not initialize
    the memory buffer with a default value. The same is true for automatic variables
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of opportunities for errors, and the `memory` sanitizer helps
    to find the bugs. If you are interested in the implementation details, you can
    find the source for the `memory` sanitizer pass in the `llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp`
    file. The comment at top of the file explains the ideas behind the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a small example and save the following source as the `memory.c`
    file. You should note that the `x` variable is not initialized, but is used as
    a `return` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the sanitizer, the application will run just fine. However, you will
    get an error report if you use the `-fsanitize=memory` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Like the `address` sanitizer, the `memory` sanitizer stops the application at
    the first found error.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at how we can use the `thread` sanitizer to detect
    data races in multi-threaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pointing out data races with the thread sanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To leverage the power of modern CPUs, applications now use multiple threads.
    This is a powerful technique, but it also introduces new sources of errors. A
    very common problem in multi-threaded applications is that access to global data
    is not protected, for example, with a `thread` sanitizer can detect data races
    in `llvm/lib/Transforms/Instrumentation/ThreadSanitize.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the functionality of the `thread` sanitizer, we will create
    a very simple producer/consumer-style application. The producer thread increments
    a global variable, while the consumer thread decrements the same variable. The
    access to the global variable is not protected, so this is clearly a data race.
    You''ll need to save the following source in the `thread.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, the `data` variable is shared between two threads.
    Here, it is of the `int` type to make the example simple. Most often, a data structure
    such as the `std::vector` class or similar would be used. These two threads run
    the `producer()` and `consumer()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `producer()` function only increments the `data` variable, while the `consumer()`
    function decrements it. No access protection is implemented, so this constitutes
    a data race. The `main()` function starts both threads with the `pthread_create()`
    function, waits for the end of the threads with the `pthread_join()` function,
    and returns the current value of the `data` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you compile and run this application, then you will note no error; that is,
    the return value is always 0\. An error, in this case, a return value not equal
    to 0, will show up if the number of loops performed is increased by a factor of
    100\. Then, you'll see other values showing up.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `thread` sanitizer to identify the data race. To compile with the
    `thread` sanitizer being enabled, you''ll need to pass the `-fsanitize=thread`
    option to Clang. Adding debug symbols with the `–g` option gives you line numbers
    in the report, which helps a lot. Note that you also need to link the `pthread`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The report points us to *lines 6* and *11* of the source file, where the global
    variable is accessed. It also shows that two threads, named *T1* and *T2*, accessed
    the variable, as well as the file and line number of the respective calls to the
    `pthread_create()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use three sanitizers to identify common problems
    in applications. The `address` sanitizer helps us to identify common memory access
    errors, such as out-of-bounds access or using memory after being freed. Using
    the `memory` sanitizer, we can find accesses to uninitialized memory, and the
    `thread` sanitizer helps us to identify data races.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we try to trigger the sanitizers by running our application
    on random data, called **fuzz testing**.
  prefs: []
  type: TYPE_NORMAL
- en: Finding bugs with libFuzzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test your application, you'll need to write **unit tests**. This is a great
    way to make sure your software behaves correctly. However, due to the exponential
    number of possible inputs, you'll probably miss certain weird inputs, and a few
    bugs as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fuzz testing** can help here. The idea is to present your application with
    randomly generated data, or data based on valid input but with random changes.
    This is done over and over again, and so your application is tested with a large
    number of inputs. This is a very powerful testing approach. Literally hundreds
    of bugs in web browsers and other software have been found with fuzz testing.'
  prefs: []
  type: TYPE_NORMAL
- en: LLVM comes with its own fuzz testing library. Originally part of the LLVM core
    libraries, the `compiler-rt`. The library is designed to test small and fast functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a small example. You''ll need to provide the `LLVMFuzzerTestOneInput()`
    function. This function is called by the `fuzzer.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, the `count()` function counts the number of digits
    in the memory pointed to by the `Data` variable. The size of the data is only
    checked to determine whether there are any bytes available. Inside the `while`
    loop, the size is not checked.
  prefs: []
  type: TYPE_NORMAL
- en: Used with normal `0` byte. The `LLVMFuzzerTestOneInput()` function is the so-called
    `0`, which is currently the only allowed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the file with libFuzzer, you add the `-fsanitize=fuzzer` option.
    The recommendation is to also enable the `address` sanitizer and the generation
    of debug symbols. Use the following command to compile the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the test, a lengthy report is emitted. The report contains more
    information than a stack trace, so let''s have a closer look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line tells you the seed that was used to initialize the random number
    generator. You can use the `–seed=` option to repeat this execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, libFuzzer limits inputs to at most 4,096 bytes. You can change
    the default by using the `–max_len=` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run the test without providing sample input. The set of all sample
    inputs is called the corpus, and it is empty for this run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Some information about the generated test data will follow. It shows you that
    `28` inputs were tried and `6` inputs, with a combined length of `19` bytes, were
    found, which together cover `6` coverage points or basic blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, a buffer overflow was detected, and it follows the information
    from the `address` sanitizer. Lastly, the report tells you where the input causing
    the buffer overflow is saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the saved input, you can execute the test case with just the crashing
    input again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously a great help to identify the problem. Only, using random data
    is often not very helpful. If you try to fuzz test the `tinylang` lexer or parser,
    then pure random data leads to immediate rejection of the input, because no valid
    token can be found.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, it is more useful to provide a small set of valid input, called
    the corpus. Then, the files of the corpus are randomly mutated and used as input.
    You can think of the input as mostly valid, with just a few bits flipped. This
    also works great with other input, which must have a certain format. For example,
    for a library processing **JPEG** and **PNG** files, you will provide some small
    **JPEG** and **PNG** files as the corpus.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save the corpus files in one or more directories and you can create
    a simple corpus for your fuzz test with the help of the `printf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the test, you will provide the directory on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The corpus is then used as the base for generating random input, as the report
    tells you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are testing a function that works on tokens or other magic values, such
    as a programming language, then you can speed up the process by providing a dictionary
    with the tokens. For a programming language, the dictionary would contain all
    the keywords and special symbols used in the language. The dictionary definitions
    follow a simple key-value style. For example, to define the `if` keyword in the
    dictionary, you can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, the key is optional and can be left out. You can then specify the dictionary
    file on the command line with the `–dict=` option. In the next section, we'll
    get to know the limitations and alternatives for the libFuzzer implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations and alternatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The libFuzzer implementation is fast but poses a number of restrictions on
    the test target. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The function under test must accept the input as an array in memory. Some library
    functions require a file path to the data instead, and they cannot be tested with
    libFuzzer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exit()` function should not be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global state should not be altered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware random number generators should not be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the aforementioned restrictions, the first two restrictions are an implication
    of the implementation of libFuzzer as a library. The latter two restrictions are
    needed to avoid confusion in the evaluation algorithm. If one of these restrictions
    is not met, then two identical calls to the fuzz target can give different results.
  prefs: []
  type: TYPE_NORMAL
- en: The best-known alternative tool for fuzz testing is **AFL**, found at [https://github.com/google/AFL](https://github.com/google/AFL).
    AFL needs an instrumented binary (an LLVM plugin for instrumentation is provided)
    and requires the application to take the input as the file path on the command
    line. AFL and libFuzzer can share the same corpus and the same dictionary files.
    Thus, it is possible to test an application with both tools. In cases where libFuzzer
    is not applicable, AFL may be a good alternative.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more ways of influencing the way libFuzzer works. You can read
    the reference page at [https://llvm.org/docs/LibFuzzer.html](https://llvm.org/docs/LibFuzzer.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at a totally different problem an application can
    have; we try to identify performance bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Performance profiling with XRay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application seems to run slow, then you might want to know where all
    the time is spent in the code. In this case, instrumenting the code with `llvm/lib/XRay/`
    directory. The runtime portion is part of `compiler-rt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example source, real work is simulated by calling the `usleep()`
    function. The `func1()` function sleeps for 10 µs. The `func2()` function either
    calls `func1()` or sleeps for 100 µs, depending on whether the `n` parameter is
    odd or even. Inside the `main()` function, both functions are called inside a
    loop. This is already enough to get interesting information. You''ll need to save
    the following source code in the `xraydemo.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the XRay instrumentation during compilation, you will need to specify
    the `-fxray-instrument` option. Functions with less than 200 instructions are
    not instrumented. This is an arbitrary threshold defined by the developers, and
    in our case, the functions would not be instrumented. The threshold can be specified
    with the `-fxray-instruction-threshold=` option. Alternatively, we can add a function
    attribute to control whether a function should be instrumented. For example, adding
    the following prototype would result in always instrumenting the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, by using the `xray_never_instrument` attribute, you can turn off instrumentation
    for a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now use the command-line option and compile the `xraydemo.c` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the resulting binary, instrumentation is turned off by default. If you run
    the binary, you will note no difference to a not-instrumented binary. The `XRAY_OPTIONS`
    environment variable is used to control the recording of runtime data. To enable
    data collection, you run the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `xray_mode=xray-basic` option tells the runtime that we want to use basic
    mode. In this mode, all runtime data is collected, which can result in huge log
    files. When the `patch_premain=true` option is given, then functions that are
    run before the `main()` function are instrumented, too.
  prefs: []
  type: TYPE_NORMAL
- en: After running this command, you see a new file in the directory, in which the
    collected data is stored. You need to use the `llvm-xray` tool to extract readable
    information from this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `llvm-xray` tool supports various subcommands. You use the `account` subcommand
    to extract some basic statistics. For example, to get the top 10 most called functions,
    you add the `-top=10` option to limit the output, and the `-sort=count` option
    to specify the function call count as the sort criteria. You can influence the
    sort order with the `-sortorder=` option. Run the following command to get the
    statistic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `func1()` function is called most often, as well as the
    accumulated time spent in this function. The example only has three functions,
    so the `–top=` option has no visible effect here, but for real applications, it
    is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the collected data, it is possible to reconstruct all the stack frames
    that occurred during runtime. You use the `stack` subcommand to view the top 10
    stacks. The output shown here is reduced for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A `func2()` function is called by the `main()` function, and this is the stack
    frame with the largest accumulated time. The depth depends on how many functions
    are called, and the stack frames are usually large.
  prefs: []
  type: TYPE_NORMAL
- en: This subcommand can also be used to create a `flamegraph.pl` script, you convert
    the data into a **Scalable Vector Graphics** (**SVG**) file, which you can view
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following command, you instruct `llvm-xray` to output all stack frames
    with the `–all-stacks` option. Using the `–stack-format=flame` option, the output
    is in the format expected by the `flamegraph.pl` script. With the `–aggregation-type`
    option, you can choose whether stack frames are aggregated by total time or by
    the number of invocations. The output of `llvm-xray` is piped into the `flamegraph.pl`
    script, and the resulting output is saved in the `flame.svg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the generated `flame.svg` file in your browser. The graphic looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Flame graph produced by llvm-xray'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Flame graph produced by llvm-xray
  prefs: []
  type: TYPE_NORMAL
- en: Flame graphs can be confusing at the first look, because the *x* axis does not
    have the usual meaning of elapsed time. Instead, the functions are simply sorted
    by name. The colors are chosen to have good contrast and have no other meaning.
    From the preceding graph, you can easily determine the call hierarchy and the
    time spent in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Information about a stack frame is displayed only after you move the mouse cursor
    over the rectangle representing the frame. With a mouse click on the frame, you
    can zoom into this stack frame. Flame graphs are of great help if you want to
    identify functions worth optimizing. To find out more about flame graphs, please
    visit the website of Brendan Gregg, the inventor of flame graphs, [http://www.brendangregg.com/flamegraphs.html](http://www.brendangregg.com/flamegraphs.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `convert` subcommand to convert the data into `.yaml` format
    or into the format used by the `xray.evt` file, you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify the `–symbolize` option, then no function names are shown
    in the resulting graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that is done, open the Chrome browser and type `chrome:///tracing`. Then,
    click on the `xray.evt` file. You will see the following visualization of the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Chrome trace viewer visualization generated by llvm-xray'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Chrome trace viewer visualization generated by llvm-xray
  prefs: []
  type: TYPE_NORMAL
- en: In this view, the stack frames are sorted by the time the function call occurs.
    For further interpretation of the visualization, please read the tutorial at [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `llvm-xray` tool has more functionality. You can read about it on the LLVM
    website at [https://llvm.org/docs/XRay.html](https://llvm.org/docs/XRay.html)
    and [https://llvm.org/docs/XRayExample.html](https://llvm.org/docs/XRayExample.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to instrument an application with XRay, how
    to collect runtime information, and how to visualize that data. We can use this
    knowledge to find performance bottlenecks in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to identifying errors in an application is to analyze the source
    code, which is done with the static analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the source with the Clang Static Analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Clang Static Analyzer** is a tool that performs additional checking on
    C, C++, and **Objective C** source code. The checks performed by the static analyzer
    are more thorough than the checks the compiler performs. They are also more costly
    in terms of time and required resources. The static analyzer has a set of checkers
    that check for certain bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The tool performs a symbolic interpretation of the source code that looks at
    all the code paths through an application and derives constraints on the values
    used in the application from it. **Symbolic interpretation** is a common technique
    used in compilers, for example, to identify constant values. In the context of
    the static analyzer, the checkers are applied to the derived values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the divisor of a division is 0, then the static analyzer warns
    about it. We can check this with the following example stored in the `div.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The static analyzer will warn about a division by `0` in the example. However,
    when compiling, the file with the `clang -Wall -c div.c` command will show no
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to invoke the static analyzer from the command line. The
    older tool is `scan-build` tool is the easier solution. You simply pass the `compile`
    command to the tool, and everything else is done automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The output on the screen already tells you that a problem was found, that is,
    the checker with the name `core.DivideZero` was triggered. But that is not all.
    You will find a complete report in HTML in the mentioned subdirectory of the `/tmp`
    directory. You can use the `scan-view` command to view the report or open the
    `index.html` file found in the subdirectory in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first page of the report shows you a summary of the found bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Summary page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Summary page
  prefs: []
  type: TYPE_NORMAL
- en: For each found error, the summary page shows the type of the error, the location
    in the source, and the path length after which the analyzer finds the error. A
    link to a detailed report for the error is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the detailed report for the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Detailed report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Detailed report
  prefs: []
  type: TYPE_NORMAL
- en: With the detailed report, you are able to verify the error by following the
    numbered bubbles. In our simple example, it shows in three steps how passing `0`
    as a parameter value leads to a division by zero error.
  prefs: []
  type: TYPE_NORMAL
- en: Verification through a human is indeed required. If the derived constraints
    are not precise enough for a certain checker, then false positives are possible,
    that is, an error is reported for perfectly fine code. Based on the report, you
    can identify false positives.
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to the checkers that are provided with the tool. You can
    also add new checkers. The next section shows how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new checker to the Clang Static Analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a new checker to the Clang Static Analyzer, you create a new subclass
    of the `Checker` class. The static analyzer tries all possible paths through the
    code. The analyzer engine generates events at certain points, for example, before
    a function call or after a function call. Your class has to provide callbacks
    for these events if you need to handle them. The `Checker` class and the registrations
    for the events are provided in the `clang/include/clang/StaticAnalyzer/Core/Checker.h`
    header file.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a checker needs to track some symbols. But the checker can't manage
    the state, because it does not know which code path the analyzer engine currently
    tries. Therefore, the tracked state must be registered with the engine, and can
    only be changed using a `ProgramStateRef` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Many libraries provide functions that must be used in pairs. For example, the
    C standard library provides the `malloc()` and `free()` functions. The memory
    allocated by the `malloc()` function must be freed exactly one time by the `free()`
    function. Not calling the `free()` function, or calling it several times, is a
    programming error. There are many more instances of this coding pattern, and the
    static analyzer provides checkers for some of them.
  prefs: []
  type: TYPE_NORMAL
- en: The `iconv` library provides the `iconv_open()` and `iconv_close()` functions,
    which must be used in pairs. You implement a checker to check for this.
  prefs: []
  type: TYPE_NORMAL
- en: To detect the errors, the checker needs to track the descriptor returned from
    the `iconv_open()` function. The analyzer engine returns a `SymbolRef` instance
    for the return value of the `iconv_open()` function. We associate this symbol
    with a state to reflect whether `iconv_close()` was called or not. For the state,
    we create the `IconvState` class, which encapsulates a `bool` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `IconvChecker` class needs to handle four events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostCall`, which occurs after a function call. After the `iconv_open()` function
    is called, we retrieve the symbol for the return value and remember it as being
    in an open state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreCall`, which occurs before a function call. Before the `iconv_close()`
    function is called, we check whether the symbol for the descriptor is in an open
    state. If not, then the `iconv_close()` function was already called for the descriptor,
    and we have detected a double call to the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeadSymbols`, which occurs when unused symbols are cleaned up. We check whether
    an unused symbol for a descriptor is still in an open state. If yes, then we have
    detected a missing call to `iconv_close()`, which is a resource leak.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PointerEscape`, which is called when the symbols can no longer be tracked
    by the analyzer. In this case, we remove the symbol from the state, because we
    can no longer reason whether the descriptor was closed or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new checker is implemented inside the Clang project. Let''s begin with
    adding the new checker to the collection of all checkers, which is the `clang/include/clang/StaticAnalyzer/Checkers/Checkers.td`
    file. Each checker is associated with packages. Our new checker is under development,
    and therefore it belongs in the `alpha` package. The iconv API is a POSIX-standardized
    API, so it also belongs in the `unix` package. Locate the `UnixAlpha` section
    in the `Checkers.td` file and add the following code to register the new `IconvChecker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This adds the new checker to the collection of known **checkers**, sets help
    text for the command-line option, and states that there is no documentation for
    this checker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement the checker in the `clang/lib/StaticAnalyzer/Checkers/IconvChecker.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the implementation, we need to include several header files. The `BuiltinCheckerRegistration.h`
    file is required to register the checker. The `Checker.h` file provides the declaration
    of the `Checker` class and the callbacks for the events. The `CallEvent.h` file
    declares the class used for call events, and the `CheckerContext.h` file is required
    for the declaration of the `CheckerContext` class, which is the central class
    providing access to the state of the analyzer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid typing the namespace names, we use the `clang` and `ento` namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We associate a state with each symbol representing an iconv descriptor. The
    state can be open or closed, and we use a `bool`-type variable, with the `true`
    value for an open state. The state value is encapsulated in the `IconvState` struct.
    This struct is used with a `FoldingSet` data structure, which is a hash set that
    filters duplicate entries. To be usable with this data structure implementation,
    the `Profile()` method is added here, which sets the unique bits of this struct.
    We put the struct into an anonymous namespace, to avoid pollution of the global
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IconvState` struct represents the state of an iconv descriptor, which
    is represented by a symbol of the `SymbolRef` class. This is best done with a
    map, which has the symbol as the key and the state as the value. As explained
    earlier, the checker cannot hold the state. Instead, the state must be registered
    with the global program state, which is done with the `REGISTER_MAP_WITH_PROGRAMSTATE`
    macro. This macro introduces the `IconvStateMap` name, which we use later to access
    the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also implement the `IconvChecker` class in an anonymous namespace. The requested
    `PostCall`, `PreCall`, `DeadSymbols`, and `PointerEscape` events are template
    parameters to the `Checker` base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IconvChecker` class only has fields of the `CallDescription` type, which
    are used to identify `iconv_open()`, `iconv()`, and `iconv_close()` function calls
    in the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `report()` method generates an error report. The important parameters to
    the method are an array of symbols, the type of the bug, and a bug description.
    Inside the method, a bug report is created for each symbol, and the symbol is
    marked as the interesting one for the bug. If a source range is provided as a
    parameter, then this is also added to the report. Finally, the report is emitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the `IconvChecker` class only initializes the `CallDescription`
    fields using the name of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkPostCall()` method is called after the analyzer has executed a function
    call. If the executed function is not a global C function and not named `iconv_open`,
    then there is nothing to do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we try to get the return value of the function as a symbol. To store
    the symbol with the open state in the global program state, we need to get a `ProgramStateRef`
    instance from the `CheckerContext` instance. The state is immutable, so adding
    the symbol to the state results in a new state. The analyzer engine is informed
    about the new state with a call to the `addTransition()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `checkPreCall()` method is called before the analyzer executes
    a function. Only a global C function with the name `iconv_close` is of interest
    to us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the symbol for the first argument of the function, which is the iconv descriptor,
    is known, then we retrieve the state of the symbol from the program state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the state represents the closed state, then we have detected a double close
    error, and we generate a bug report for it. The call to `generateErrorNode()`
    can return a `nullptr` value if an error report was already generated for this
    path, so we have to check for this situation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we set the state for the symbol to closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkDeadSymbols()` method is called to clean up unused symbols. We loop
    over all symbols we track and ask the `SymbolReaper` instance whether the current
    symbol is dead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the symbol is dead, then we need to check the state. If the state is still
    open, then this is a potential resource leak. There is one exception: `iconv_open()`
    returns `-1` in the case of an error. If the analyzer is in a code path handling
    this error, then it is wrong to assume a resource leak, because the function call
    failed. We try to get the value of the symbol from the `ConstraintManager` instance,
    and we do not consider the symbol as a resource leak if this value is `-1`. We
    add a leaked symbol to a `SmallVector` instance, for generating the error report
    later. Finally, we remove the dead symbol from the program state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After the loop, we call the `generateNonFatalErrorNode()` method. This method
    transitions to the new program state, and returns an error node if there is not
    already an error node for this path. The `LeakedSyms` container holds the (possibly
    empty) list of leaked symbols, and we call the `report()` method to generate an
    error report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkPointerEscape()` function is called when the analyzer detects a function
    call for which the parameters cannot be tracked. In such a case, we must assume
    that we do not know whether the iconv descriptor will be closed inside the function
    or not. The only exception is a call to the `iconv()` function, which does the
    conversion and is known to not call the `iconv_close()` function. This finishes
    the implementation of the `IconvChecker` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the new checker needs to be registered at a `CheckerManager` instance.
    The `shouldRegisterIconvChecker()` method returns `true` to indicate that `IconvChecker`
    should be registered by default, and the `registerIconvChecker()` method performs
    the registration. Both methods are called via the code generated from the `Checkers.td`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This finishes the implementation of the new checker. You just need to add the
    filename to the list of source filenames in the `clang/lib/StaticAnalyzer/Checkers/CmakeLists.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the new checker, you change to your build directory and run the
    `ninja` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the new checker with the following source saved in the `conv.c`
    file, which has two calls to the `iconv_close()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You learned how to extend the Clang Static Analyzer with your own checker. You
    can use this knowledge to either create new general checkers and contribute them
    to the community, or you can create checkers specifically built for your needs,
    to raise the quality of your product.
  prefs: []
  type: TYPE_NORMAL
- en: The static analyzer is built leveraging the Clang infrastructure, and the next
    section introduces you to how can build your own plugin extending Clang.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own Clang-based tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The static analyzer is an impressive example of what you can do with the Clang
    infrastructure. It is also possible to extend Clang with plugins, so you are able
    to add your own functionality to Clang. The technique is very similar to adding
    a pass plugin to LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the functionality with a simple plugin. The LLVM coding standard
    requires function names to begin with a lowercase letter. However, the coding
    standard has evolved over time, and there are many instances in which a function
    begins with an uppercase letter. A plugin that warns about a violation of the
    naming rule can help to fix the issue, so let's give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Because you want to run a user-defined action over the `PluginASTAction` class.
    If you write your own tool using the Clang libraries, then you define subclasses
    of the `ASTFrontendAction` class for your actions. The `PluginASTAction` class
    is a subclass of the `ASTFrontendAction` class, with the additional ability to
    parse command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other class you need is a subclass of the `ASTConsumer` class. An AST consumer
    is a class using which you can run an action over an AST, regardless of the origin
    of the AST. Nothing more is needed for our first plugin. You can create the implementation
    in the `NamingPlugin.cpp` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by including the required header files. Besides the mentioned `ASTConsumer`
    class, you also need an instance of the compiler and the plugin registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `clang` namespace and put your implementation into an anonymous namespace
    to avoid name clashes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Next, define your subclass of the `ASTConsumer` class. Later, you will want
    to emit warnings if you detect a violation of the naming rule. To do so, you need
    a reference to a `DiagnosticsEngine` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll need to store a `CompilerInstance` instance in the class, then you
    can ask for a `DiagnosticsEngine` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'An `ASTConsumer` instance has several entry methods. The `HandleTopLevelDecl()`
    method fits our purpose. The method is called for each declaration at the top
    level. This includes more than functions, for example, variables. So, you will
    use the LLVM RTTI `dyn_cast<>()` function to determine whether the declaration
    is a function declaration. The `HandleTopLevelDecl()` method has a declaration
    group as a parameter, which can contain more than a single declaration. This requires
    a loop over the declarations. The following code shows us the `HandleTopLevelDecl()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After having found a function declaration, you''ll need to retrieve the name
    of the function. You''ll also need to make sure that the name is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function name does not start with a lowercase letter, then you''ll have
    found a violation of the naming rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To emit a warning, you need a `DiagnosticsEngine` instance. Additionally, you
    need a message ID. Inside Clang, the message ID is defined as an enumeration.
    Because your plugin is not part of Clang, you need to create a custom ID, which
    you then use to emit the warning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside from closing all open braces, you need to return `true` from this function
    to indicate that processing can continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to create the `PluginASTAction` subclass, which implements the
    interface called by Clang:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method you must implement is the `CreateASTConsumer()` method, which
    returns an instance of your `NamingASTConsumer` class. This method is called by
    Clang, and the passed `CompilerInstance` instance gives you access to all the
    important classes of the compiler. The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A plugin also has access to command-line options. Your plugin has no command-line
    parameters, and you will just return `true` to indicate success:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The action type of a plugin describes when the action is invoked. The default
    value is `Cmdline`, which means that the plugin must be named on the command line
    in order to be invoked. You''ll need to override the method and change the value
    to `AddAfterMainAction`, which automatically runs the action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of your `PluginNamingAction` class is finished; only the
    closing braces for the class and the anonymous namespace are missing. Add them
    to the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you need to register the plugin. The first parameter is the name of
    the plugin, and the second parameter is the help text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This finishes the implementation of the plugin. To compile the plugin, create
    a build description in the `CMakeLists.txt` file. The plugin lives outside the
    Clang source tree, so you need to set up a complete project. You can do so by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the definition of the required **CMake** version and the name of
    the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, include the LLVM files. If CMake is not able to find the files automatically,
    then you have to set the `LLVM_DIR` variable to point to the LLVM directory containing
    the CMake files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Append the LLVM directory with the CMake files to the search path, and include
    some required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, load the CMake definitions for Clang. If CMake is not able to find the
    files automatically, then you have to set the `Clang_DIR` variable to point to
    the Clang directory containing the CMake files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define where the headers files and the library files are located, and
    which definitions to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous definitions set up the build environment. Insert the following
    command, defining the name of your plugin, the source file(s) of the plugin, and
    that it is a Clang plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'On **Windows**, the plugin support is different from the **Unix** platforms,
    and the required LLVM and Clang libraries must be linked in. The following code
    ensures this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Save both files in the `NamingPlugin` directory. Create a `build-naming-plugin`
    directory at the same level as the `NamingPlugin` directory, and build the plugin
    with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: These steps create the `NamingPlugin.so` shared library in the `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the plugin, save the following source as the `naming.c` file. The `Func1`
    function name violates the naming rule, but not the `main` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the plugin, you need to specify the `–fplugin=` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This kind of invocation requires that you override the `getActionType()` method
    of the `PluginASTAction` class, and that you return a value different from the
    `Cmdline` default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you did not do this, for example, because you want to have more control
    over the invocation of the plugin action, then you can run the plugin from the
    compiler command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Congrats, you have built your first Clang plugin!
  prefs: []
  type: TYPE_NORMAL
- en: 'The disadvantage of this approach is that it has certain limitations. The `ASTConsumer`
    class has different entry methods, but they are all coarse-grained. This can be
    solved by using a `RecursiveASTVisitor` class. This class traverses all AST nodes,
    and you can override the `VisitXXX()` methods you are interested in. You can rewrite
    the plugin to use the visitor with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need an additional `include` for the definition of the `RecursiveASTVisitor`
    class. Insert it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the visitor as the first class in the anonymous namespace. You
    will only store a reference to the AST context, which will give you access to
    all the important methods for AST manipulation, including the `DiagnosticsEngine`
    instance required for emitting the warning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'During traversal, the `VisitFunctionDecl()` method is called whenever a function
    declaration is discovered. Copy the body of the inner loop inside the `HandleTopLevelDecl()`
    function here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This finishes the visitor implementation. In your `NamingASTConsumer` class,
    you will now only store a visitor instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You will remove the `HandleTopLevelDecl()` method, because the functionality
    is now in the visitor class, so you''ll need to override the `HandleTranslationUnit()`
    method instead. This class is called once for each translation unit, and you will
    start the AST traversal here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This new implementation has exactly the same functionality. The advantage is
    that it is easier to extend. For example, if you want to examine variable declarations,
    then you implement the `VisitVarDecl()` method. Or if you want to work with a
    statement, then you implement the `VisitStmt()` method. Basically, you have a
    visitor method for each entity of the C, C++, and Objective C languages.
  prefs: []
  type: TYPE_NORMAL
- en: Having access to the AST allows you to build plugins that perform complex tasks.
    Enforcing naming conventions, as described in this section, is a useful addition
    to Clang. Another useful addition you could implement as a plugin is the calculation
    of a software metric such as **cyclomatic complexity**. You can also add or replace
    AST nodes, allowing you, for example, to add runtime instrumentation. Adding plugins
    allows you to extend Clang in the way you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to apply various sanitizers. You detected pointer
    errors with the `address` sanitizer, uninitialized memory access with the `memory`
    sanitizer, and detected data races with the `thread` sanitizer. Application errors
    are often triggered by malformed input, and you implemented fuzz testing to test
    your application with random data.
  prefs: []
  type: TYPE_NORMAL
- en: You instrumented your application with XRay to identify the performance bottlenecks,
    and you also learned about the various ways to visualize data. In this chapter,
    you also used the Clang Static Analyzer to find possible errors through interpretation
    of the source, and you learned how to build your own Clang plugin.
  prefs: []
  type: TYPE_NORMAL
- en: These skills will help you to raise the quality of the applications you build.
    It is certainly good to find runtime errors before your application users complain
    about them. Applying the knowledge gained in this chapter, you can not only find
    a wide range of common errors but also extend Clang with new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to add a new backend to LLVM.
  prefs: []
  type: TYPE_NORMAL
