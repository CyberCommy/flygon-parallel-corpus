- en: Chapter 1. Numbers, Strings, and Tuples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。数字，字符串和元组
- en: 'We''ll cover these recipes to introduce basic Python data types:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍这些食谱来介绍基本的Python数据类型：
- en: Creating meaningful names and using variables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有意义的名称并使用变量
- en: Working with large and small integers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大整数和小整数
- en: Choosing between float, decimal, and fraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浮点数，小数和分数之间进行选择
- en: Choosing between true division and floor division
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真除法和地板除法之间进行选择
- en: Rewriting an immutable string
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写不可变字符串
- en: String parsing with regular expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串
- en: Building complex strings with "template".format()
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“template”。格式（）构建复杂的字符串
- en: Building complex strings from lists of characters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符列表构建复杂的字符串
- en: Using the Unicode characters that aren't on our keyboards
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不在键盘上的Unicode字符
- en: Encoding strings – creating ASCII and UTF-8 bytes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码字符串-创建ASCII和UTF-8字节
- en: Decoding bytes – how to get proper characters from some bytes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码字节-如何从一些字节中获取正确的字符
- en: Using tuples of items
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目的元组
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will look at some central types of Python objects. We'll look at
    the different kinds of numbers, working with strings, and using tuples. We'll
    look at these first because they're the simplest kinds of data Python works with.
    In later chapters, we'll look at data collections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Python对象的一些中心类型。我们将研究不同类型的数字，处理字符串和使用元组。我们首先研究这些，因为它们是Python处理的最简单的数据类型。在后面的章节中，我们将研究数据集合。
- en: Most of these recipes assume a beginner's level of understanding of Python 3\.
    We'll be looking at how we use the essential built-in types available in Python—numbers,
    strings, and tuples. Python has a rich variety of numbers, and two different division
    operators, so we'll need to look closely at the choices available to us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大多数食谱假设初学者对Python 3有一定的理解。我们将研究如何使用Python中提供的基本内置类型-数字，字符串和元组。Python有各种各样的数字和两种不同的除法运算符，因此我们需要仔细研究可用的选择。
- en: When working with strings, there are several common operations that are important.
    We'll explore some of the differences between bytes—as used by our OS files, and
    Strings—as used by Python. We'll look at how we can exploit the full power of
    the Unicode character set.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，有几个重要的常见操作。我们将探讨字节（由操作系统文件使用）和字符串（由Python使用）之间的一些区别。我们将看看如何利用Unicode字符集的全部功能。
- en: In this chapter, we'll show the recipes as if we're working from the `>>>` prompt
    in interactive Python. This is sometimes called the **read-eval-print loop** (
    **REPL** ). In later chapters, we'll look more closely at writing script files.
    The goal is to encourage interactive exploration because it's a great way to learn
    the language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示食谱，就好像我们是从交互式Python的`>>>`提示符中工作一样。这有时被称为**读取-求值-打印循环**（**REPL**）。在后面的章节中，我们将更仔细地研究编写脚本文件。目标是鼓励交互式探索，因为这是学习语言的好方法。
- en: Creating meaningful names and using variables
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建有意义的名称并使用变量
- en: How can we be sure our programs make sense? One of the core elements of making
    expressive code is to use *meaningful* names. But what counts as meaningful? In
    this recipe, we'll review some common rules for creating meaningful Python names.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保我们的程序是有意义的？制作表达性代码的核心元素之一是使用*有意义*的名称。但什么算是有意义的？在这个食谱中，我们将回顾一些创建有意义的Python名称的常见规则。
- en: We'll also look at some of Python's assignment statement variations. We can,
    for example, assign more than one variable in a single statement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一些Python的赋值语句变体。例如，我们可以在单个语句中分配多个变量。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: The core issue when creating a name is to ask ourselves the question *what is
    this thing?* For software, we'd like a name that's descriptive of the object being
    named. Clearly, a name like `x` is not very descriptive, it doesn't seem to refer
    to an actual thing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名称时的核心问题是问自己一个问题*这是什么东西？*对于软件，我们希望一个描述对象的名称。显然，像`x`这样的名称并不是很描述性，它似乎并不指代实际的东西。
- en: Vague, non-descriptive names are distressingly common in some programming. It's
    not helpful to others when we use them. A descriptive name helps everyone.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程中，模糊的，不具描述性的名称是令人沮丧的常见现象。当我们使用它们时，对他人并不有帮助。描述性的名称有助于每个人。
- en: When naming things, it's also important to separate the problem domain—what
    we're really trying to accomplish—from the solution domain. The solution domain
    consists of the technical details of Python, OS, and Internet. Anyone who reads
    the code can see the solution; it doesn't require deep explanation. The problem
    domain, however, can be obscured by technical details. It's our job to make the
    problem clearly visible. Well-chosen names will help.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名事物时，将问题域-我们真正想要实现的目标-与解决方案域分开也很重要。解决方案域包括Python，操作系统和互联网的技术细节。任何阅读代码的人都可以看到解决方案；它不需要深入解释。然而，问题域可能会被技术细节所掩盖。我们的工作是使问题清晰可见。选择恰当的名称将有所帮助。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll look at names first. Then we'll move on to assignment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看名称。然后我们将转向赋值。
- en: Choosing names wisely
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明智地选择名称
- en: On a purely technical level, Python names must begin with a letter. They can
    include any number of letters, digits, and the _ character. Python 3 is based
    on Unicode, so a letter is not limited to the Latin alphabet. While the A-Z Latin
    alphabet is commonly used, it's not required.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯技术层面上讲，Python名称必须以字母开头。它们可以包括任意数量的字母，数字和_字符。Python 3基于Unicode，因此字母不限于拉丁字母表。虽然A-Z拉丁字母表通常被使用，但并非必需。
- en: When creating a descriptive variable, we want to create names that are both
    specific and articulate the relationships among things in our programs. One widely
    used technique is to create longer names in a style that moves from particular
    to general.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建描述性变量时，我们希望创建既具体又能表达程序中事物之间关系的名称。一个广泛使用的技术是创建更长的名称，风格从具体到一般。
- en: 'The steps to choosing a name are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择名称的步骤如下：
- en: The last part of the name is a very broad summary of the thing. In a few cases,
    this may be all we need; context will supply the rest. We'll suggest some typical
    broad summary categories later.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称的最后部分是对这个事物的一个非常广泛的总结。在一些情况下，这可能是我们所需要的全部；上下文会提供其余的部分。我们稍后会提出一些典型的广泛总结类别。
- en: Use a prefix to narrow this name around your application or problem domain.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前缀来围绕你的应用程序或问题域缩小这个名称。
- en: If needed, put more narrow and specialized prefixes on this name to clarify
    how it's distinct from other classes, modules, packages, functions, and other
    objects. When in doubt about prefixing, remember how domain names work. Think
    of `mail.google.com` —the name flows from particular to general. There's no magic
    about the three levels of naming, but it often happens to work out that way.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以在这个名称上加上更窄和专业的前缀，以澄清它与其他类、模块、包、函数和其他对象的区别。如果对于加前缀感到犹豫，可以回想一下域名是如何工作的。想想`mail.google.com`
    ——名称从具体到一般。命名的三个级别并没有什么神奇之处，但通常情况下会按照这种方式进行。
- en: 'Format the name depending on how it''s used in Python. There are three broad
    classes of things we''ll put names on, which are shown as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Python中的使用方式来格式化名称。我们将给出三种我们会给名称的东西的广泛类别，如下所示：
- en: '**Classes** : A class has a name that summarizes the objects that are part
    of the class. These names will (often) use `CapitalizedCamelCase` . The first
    letter of a class name is capitalized to emphasize that it''s a class, not an
    instance of the class. A class is often a generic concept, rarely a description
    of a tangible thing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：类有一个总结了属于该类的对象的名称。这些名称通常会使用`CapitalizedCamelCase`。类名的第一个字母大写是为了强调它是一个类，而不是类的实例。类通常是一个通用的概念，很少是一个具体的东西的描述。'
- en: '**Objects** : A name for an object usually uses `snake_case` - all lowercase
    with multiple `_` characters between words. In Python, this includes variables,
    functions, modules, packages, parameters, attributes of objects, methods of classes,
    and almost everything else.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：对象的名称通常使用`snake_case`——所有小写，单词之间用多个`_`字符分隔。在Python中，这包括变量、函数、模块、包、参数、对象的属性、类的方法，几乎所有其他东西。'
- en: '**Script and module files** : These are really the OS resources, as seen by
    Python. Therefore, a filename should follow the conventions for Python objects,
    using letters, the `_` characters and ending with the `.py` extension. It''s technically
    possible to have pretty wild and free filenames. Filenames that don''t follow
    Python rules can be difficult to use as a module or package.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本和模块文件**：这些实际上是Python所看到的操作系统资源。因此，文件名应该遵循Python对象的约定，使用字母、`_`字符，并以`.py`扩展名结尾。技术上可以有相当狂野和自由的文件名。不遵循Python规则的文件名可能很难作为模块或包使用。'
- en: How do we choose the broad category part of a name? The general category depends
    on whether we're talking about a thing or a property of a thing. While the world
    is full of things, we can create some board groupings that are helpful. Some of
    the examples are Document, Enterprise, Place, Program, Product, Process, Person,
    Asset, Rule, Condition, Plant, Animal, Mineral, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何选择名称的广泛类别部分？一般的类别取决于我们是在谈论一个事物还是一个事物的属性。虽然世界充满了事物，但我们可以创建一些有用的广泛分类。一些例子是Document、Enterprise、Place、Program、Product、Process、Person、Asset、Rule、Condition、Plant、Animal、Mineral等等。
- en: 'We can then narrow these with qualifiers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用限定词来缩小这些范围：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first example is a class called `Document` . We've narrowed it slightly
    by adding a prefix to call it a `StatusDocument` . We narrowed it even further
    by calling it a `FinalStatusDocument` . The second example is a `Name` that we
    narrowed by specifying that it's a `ReceivedInventoryItemName` . This example
    required a four-level name to clarify the class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是一个名为`Document`的类。我们通过添加前缀稍微缩小了它，称其为`StatusDocument`。我们甚至进一步缩小了它，称其为`FinalStatusDocument`。第二个例子是一个`Name`，我们通过指定它是一个`ReceivedInventoryItemName`来缩小了它。这个例子需要一个四级名称来澄清这个类。
- en: An object often has properties or attributes. These have a decomposition based
    in the kind of information that's being represented. Some examples of terms that
    should be part of a complete name are amount, code, identifier, name, text, date,
    time, datetime, picture, video, sound, graphic, value, rate, percent, measure,
    and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象通常有属性。这些属性有一个基于所表示信息类型的分解。一些应该作为完整名称的一部分的术语的例子是amount、code、identifier、name、text、date、time、datetime、picture、video、sound、graphic、value、rate、percent、measure等等。
- en: 'The idea is to put the narrow, more detailed description first, and the broad
    kind of information last:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是先放窄、更详细的描述，然后是广泛的信息类型：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first example, `height` narrows a more general representation term `value`
    . And `measured_height_value` further narrows this. Given this name, we can expect
    to see other variations on height. Similar thinking applies to `weight_value`
    , `delivery_date` and `location_code` . Each of these has a narrowing prefix or
    two.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`height`缩小了更一般的表示术语`value`。而`measured_height_value`进一步缩小了这个范围。根据这个名称，我们可以期待看到关于height的其他变化。类似的思路也适用于`weight_value`，`delivery_date`和`location_code`。每个名称都有一个缩小的前缀或两个。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Some things to avoid** :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要避免的事情：
- en: Don't include detailed technical type information using coded prefixes or suffixes.
    This is often called **Hungarian Notation** ; we don't use `f_measured_height_value`
    where the `f` is supposed to mean a floating-point. A variable like `measured_height_value`
    can be any numeric type and Python will do all the necessary conversions. The
    technical decoration doesn't offer much help to someone reading our code, because
    the type specification can be misleading or even incorrect.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用编码的前缀或后缀包含详细的技术类型信息。这通常被称为**匈牙利命名法**；我们不使用`f_measured_height_value`，其中`f`应该表示浮点数。像`measured_height_value`这样的变量可以是任何数字类型，Python会进行所有必要的转换。技术装饰对于阅读我们的代码的人并没有太多帮助，因为类型规范可能是误导性的，甚至是错误的。
- en: Don't waste a lot of effort forcing names to look like they belong together.
    We don't need to make `SpadesCardSuit` , `ClubsCardSuit` , and so on. Python has
    many different kinds of namespaces, including packages, modules, and classes,
    as well as namespace objects to gather related names together. If you combine
    these names in a `CardSuit` class, you can use `CardSuit.Spades` , which uses
    the class as namespace to separate these names from other, similar names.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不要浪费大量精力让名称看起来像是属于一起的。我们不需要让`SpadesCardSuit`，`ClubsCardSuit`等看起来像是属于一起的。Python有许多不同类型的命名空间，包括包、模块和类，以及命名空间对象来将相关名称聚集在一起。如果你将这些名称组合在一个`CardSuit`类中，你可以使用`CardSuit.Spades`，这样可以使用类作为命名空间将这些名称与其他类似的名称分开。
- en: Assigning names to objects
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给对象命名
- en: 'Python doesn''t use static variable definitions. A variable is created when
    a name is assigned to an object. It''s important to think of the objects as central
    to our processing, and variables as little more than sticky notes that identify
    an object. Here''s how we use the fundamental assignment statement:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python不使用静态变量定义。当一个名称被赋予一个对象时，变量就被创建了。重要的是要把对象看作是我们处理的中心，而变量只是标识对象的便利贴。以下是我们如何使用基本的赋值语句：
- en: Create an object. In many of the examples we'll create objects as literals.
    We'll use `355` or `113` as literal representations of integer objects in Python.
    We might use a string like `FireBrick` or a tuple like `(178, 34, 34)` .
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象。在许多例子中，我们将创建对象作为文字。我们将使用`355`或`113`作为Python中整数对象的文字表示。我们可能会使用像`FireBrick`这样的字符串，或者像`(178,
    34, 34)`这样的元组。
- en: 'Write the following kind of statement: *variable = object* . Here are some
    examples:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下类型的陈述：*变量 = 对象*。以下是一些例子：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've created some objects and assigned them to variables. The first object
    is the result of a calculation. The next two objects are simple literals. Generally,
    objects are created by expressions that involve functions or classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一些对象并将它们分配给变量。第一个对象是计算的结果。接下来的两个对象是简单的文字。通常，对象是通过涉及函数或类的表达式创建的。
- en: 'This basic statement isn''t the only kind of assignment. We can assign a single
    object to multiple variables using a kind of duplicated assignment like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本的语句并不是唯一一种赋值方式。我们可以使用一种重复赋值的方式将单个对象分配给多个变量，就像这样：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This creates two names for the same string object. We can confirm this by checking
    the internal ID values that Python uses:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了同一个字符串对象的两个名称。我们可以通过检查Python使用的内部ID值来确认这一点：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This comparison shows us that the internal identifiers for these two objects
    are the same.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较告诉我们，这两个对象的内部标识符是相同的。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A test for equality uses `==` . Simple assignment uses `=` .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的测试使用`==`。简单的赋值使用`=`。
- en: 'When we look at numbers and collections, we''ll see that we can combine assignment
    with an operator. We can do things like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看数字和集合时，我们会发现我们可以将赋值与运算符结合起来。我们可以做这样的事情：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've augmented assignment with an operator. `total_count += 5` is the same
    as `total_count = total_count + 5` . This technique has the advantage of being
    shorter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用运算符增强了赋值。`total_count += 5`与`total_count = total_count + 5`是一样的。这种技术的优点是更短。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This approach to creating names follows the pattern of using narrow, more specific
    qualifiers first and the wider, less-specific category last. This follows the
    common convention used for domain names and e-mail addresses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名称的这种方法遵循了首先使用狭窄、更具体的限定词，然后是更广泛、不太具体的类别的模式。这遵循了用于域名和电子邮件地址的常见约定。
- en: For example, a domain name like `mail.google.com` has a specific service, a
    more general enterprise, and finally a very general domain. This follows the principle
    of narrow-to-wider.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像`mail.google.com`这样的域名具有特定的服务，更一般的企业，最后是一个非常普遍的域。这遵循了由狭窄到更广泛的原则。
- en: As another example, service@packtpub.com starts with a specific destination
    name, has a more general enterprise, and finally a very general domain. Even the
    name of destination ( *PacktPub* ) is a two-part name with a narrow enterprise
    name ( *Packt* ) followed by a wider industry ( *Pub* , short for *publishing*
    ). ( *We don't agree with those who suggest it stands for Public House.* )
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，service@packtpub.com以特定的目的地名称开头，具有更一般的企业，最后是一个非常普遍的域。甚至目的地的名称（*PacktPub*）也是一个由狭窄的企业名称（*Packt*）和更广泛的行业（*Pub*，缩写为*publishing*）组成的两部分名称。（*我们不同意那些认为它代表公共场所的人。*）
- en: The assignment statement is the only way to put a name on an object. We noted
    that we can have two names for the same underlying object. This isn't too useful
    right now. But in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* we'll see some
    interesting consequences of multiple names for a single object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句是将名称放在对象上的唯一方法。我们注意到我们可以为同一个基础对象有两个名称。目前这并不太有用。但是在[第4章](text00048.html#page
    "第4章。内置数据结构-列表、集合、字典")中，*内置数据结构-列表、集合、字典*，我们将看到单个对象的多个名称的一些有趣的后果。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We'll try to show descriptive names in all of the recipes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在所有的食谱中展示描述性的名称。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have to grant exceptions to existing software which doesn't follow this pattern.
    It's often better to be consistent with legacy software than impose new rules
    even if the new rules are better.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对不遵循这种模式的现有软件做出例外。与强加新规则相比，与遗留软件保持一致通常更好，即使新规则更好。
- en: Almost every example will involve assignment to variables. It's central to stateful
    object-oriented programming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个例子都涉及对变量的赋值。这对于有状态的面向对象编程至关重要。
- en: We'll look at classes and class names in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* ; we'll look at modules
    in [Chapter 13](text00137.html#page "Chapter 13. Application Integration") , *Application
    Integration* .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](text00070.html#page "第6章。类和对象的基础")中查看类和类名，*类和对象的基础*；我们将在[第13章](text00137.html#page
    "第13章。应用集成")中查看模块，*应用集成*。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The subject of descriptive naming is a source of ongoing research and discussion.
    There are two aspects—syntax and semantics. The starting point for thoughts on
    Python syntax is the famous **Python Enhancement Proposal number 8** ( **PEP-8**
    ). This leads to use of `CamelCase` , and `snake_case` names.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性命名的主题是持续研究和讨论的来源。有两个方面——语法和语义。关于Python语法的思考的起点是著名的**Python Enhancement Proposal
    number 8**（**PEP-8**）。这导致使用`CamelCase`和`snake_case`名称。
- en: 'Also, be sure to do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一定要这样做：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will provide more insight into Python ideals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更多地了解Python的理想。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For information on semantics, look at the legacy UDEF and NIEM Naming and Design
    Rules standards ([http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf](http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf)
    ). Additional details are in ISO11179 ([https://en.wikipedia.org/wiki/ISO/IEC_11179](https://en.wikipedia.org/wiki/ISO/IEC_11179)
    ), which talks in detail about meta-data and naming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关语义的信息，请参阅传统的UDEF和NIEM命名和设计规则标准（[http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf](http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf)）。ISO11179中还有更多详细信息（[https://en.wikipedia.org/wiki/ISO/IEC_11179](https://en.wikipedia.org/wiki/ISO/IEC_11179)），其中详细讨论了元数据和命名。
- en: Working with large and small integers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用大和小整数
- en: Many programming languages make a distinction between integers, bytes, and long
    integers. Some languages include distinctions for *signed versus* *unsigned* integers.
    How do we map these concepts to Python?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言区分整数、字节和长整数。一些语言包括*有符号*和*无符号*整数的区别。我们如何将这些概念映射到Python呢？
- en: The easy answer is that we don't. Python handles integers of all sizes in a
    uniform way. From bytes to immense numbers with hundreds of digits, it's all just
    integers to Python.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是我们不需要。Python以统一的方式处理所有大小的整数。从字节到数百位数的巨大数字，对Python来说都只是整数。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Imagine you need to calculate something really big. For example, calculate the
    number of ways to permute the cards in a 52-card deck. The number 52! = 52 × 51
    × 50 × ... × 2 × 1, is a very, very large number. Can we do this in Python?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要计算一个非常大的东西。例如，计算52张牌的牌组的排列方式。数字52! = 52 × 51 × 50 × ... × 2 × 1，是一个非常非常大的数字。我们可以在Python中做到这一点吗？
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Don''t worry. Really. Python behaves as if it has one universal type of integer,
    and this covers all of the bases from bytes to numbers that fill all of the memory.
    Here are the steps to using integers properly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心。真的。Python的行为就好像它有一种通用类型的整数，这涵盖了从字节到填满所有内存的数字的所有基础。以下是使用整数的步骤：
- en: 'Write the numbers you need. Here are some smallish numbers: 355, 113\. There’s
    no practical upper limit.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下你需要的数字。以下是一些小数字：355，113。没有实际的上限。
- en: 'Creating a very small value—a single byte—looks like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个非常小的值——一个字节——看起来像这样：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or perhaps this, if you want to use base 16:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想使用16进制，可能是这样：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In later recipes, we''ll look at a sequence of bytes that has only a single
    value in it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的示例中，我们将看到一个字节序列，其中只有一个值：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This isn't—technically—an integer. It has a prefix of `b'` that shows us it's
    a 1-byte sequence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这不是一个整数。它有一个`b'`的前缀，表明它是一个1字节序列。
- en: 'Creating a much, much bigger number with a calculation might look like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算创建一个非常大的数字可能看起来像这样：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This number has 617 digits. We didn't show all of them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字有617位。我们没有展示所有的位数。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Internally, Python uses two kinds of numbers. The conversion between these two
    is seamless and automatic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Python使用两种类型的数字。这两者之间的转换是无缝和自动的。
- en: For smallish numbers, Python will generally use 4 or 8 byte integer values.
    Details are buried in CPython's internals, and depend on the facilities of the
    C-compiler used to build Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小整数，Python通常会使用4或8字节的整数值。细节被埋在CPython的内部，并且取决于用于构建Python的C编译器的功能。
- en: For largish numbers, over `sys.maxsize` , Python switches to large integer numbers
    which are sequences of digits. Digit, in this case, often means a 30-bit value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大整数，超过`sys.maxsize`，Python将切换到大整数数字，这些数字是数字序列。在这种情况下，数字通常意味着30位值。
- en: 'How many ways can we permute a standard deck of 52 cards? The answer is 52!
    ≈ 8 × 10^(67) . Here''s how we can compute that large number. We''ll use the factorial
    function in the `math` module, shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对标准的52张牌的牌组进行多少种排列？答案是52! ≈ 8 × 10^(67)。以下是我们如何计算这个大数字。我们将使用`math`模块中的阶乘函数，如下所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Yes, these giant numbers work perfectly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这些巨大的数字完美地工作。
- en: The first parts of our calculation of 52! (from 52 × 51 × 50 × .. *.* down to
    about 42) could be performed entirely using the smallish integers. After that,
    the rest of the calculation had to switch to largish integers. We don't see the
    switch; we only see the results.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算52!（从52×51×50×..*.*到约42）的前几部分可以完全使用较小的整数。之后，计算的其余部分必须切换到较大的整数。我们看不到切换；我们只看到结果。
- en: 'For some of the details on the internals of integers, we can look at this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于整数的内部细节，我们可以看看这个：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `sys.maxsize` value is the largest of the small integer values. We computed
    the log to base 2 to find out how many bits are required for this number.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.maxsize`值是小整数值中最大的值。我们计算了以2为底的对数，以找出这个数字需要多少位。'
- en: This tells us that our Python uses 63-bit values for small integers. The range
    of smallish integers is from -2^(64) ... 2^(63) - 1\. Outside this range, largish
    integers are used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们的Python对于小整数使用63位值。小整数的范围是从-2^(64) ... 2^(63) - 1。在此范围之外，将使用大整数。
- en: The values in `sys.int_info` tells us that large integers are a sequence of
    numbers that use 30-bit digits, and each of these digits occupies 4 bytes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.int_info`中的值告诉我们，大整数是使用30位数字的数字序列，每个数字占据4个字节。'
- en: A large value like 52! consists of 8 of these 30-bit-sized digits. It can be
    a little confusing to think of a digit as requiring 30 bits to represent. Instead
    of 10 symbols used to represent base 10 numbers, we'd need *2**30* distinct symbols
    for each digit of these large numbers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: A calculation involving a number of big integer values can consume a fair bit
    of memory. What about small numbers? How can Python manage to keep track of lots
    of little numbers like one and zero?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'For the commonly used numbers (-5 to 256) Python actually creates a secret
    pool of objects to optimize memory management. You can see this when you check
    the `id()` value for integer objects:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've shown the internal `id` for the integer `1` and the integer `2` . When
    we calculate a value, the resulting object turns out to be the same integer `2`
    object that was found in the pool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: When you try this, your `id()` values may be different. However, every time
    the value of `2` is used, it will be the same object; on the author's laptop,
    it's id = `4297537984` . This saves having many, many copies of the 2 object cluttering
    up memory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a little trick for seeing exactly how huge a number is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a string from a calculated number. Then we asked what the length
    of the string was. The response tells us that the number had 617 digits.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python offers us a broad set of arithmetic operators: `+` , `-` , `*` , `/`
    , `//` , `%` , and `**` . The `/` and `//` are for division; we''ll look at these
    in a separate recipe named *Choosing between true division and floor division*
    . The `**` raises a number to a power.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For dealing with individual bits, we have some additional operations. We can
    use `&` , `^` , `|` , `<<` , and `>>` . These operators work bit-by-bit on the
    internal binary representations of integers. These compute a binary **AND** ,
    a binary **Exclusive OR** , I **nclusive OR** , **Left Shift** , and **Right Shift**
    respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: While these will work on very big integers, they don't really make much sense
    outside the world of individual bytes. Some binary files and network protocols
    will involve looking at the bits within an individual byte of data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: We can play around with these operators by using the `bin()` function to see
    what's going on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example of what we mean:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've used `0b0011` and `0b0101` as our two strings of bits. This helps to clarify
    precisely what the two numbers have as their binary representation. We applied
    the exclusive or (`^` ) operator to these two sequences of bits. We used the `bin()`
    function to see the result as a string of bits. We can carefully line up the bits
    to see what the operator did.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decompose a byte into portions. Say we want to separate the left-most
    two bits from the other six bits. One way to do this is with bit-fiddling expressions
    like these:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've defined a composite byte which has `01` in the most significant two bits,
    and `101100` in the least significant six bits. We used the `>>` shift operator
    to shift the value by six positions, removing the least significant bits and preserving
    the two most significant bits. We used the `&` operator with a mask. Where the
    mask has 1 bit, a position's value is preserved in the result, where a mask has
    `0` bits, the result position is set to `0` .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at the two division operators in the *Choosing between true division
    and floor division* recipe
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at other kinds of numbers in the *Choosing between float, decimal,
    and fraction* recipe
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on integer processing, see [https://www.python.org/dev/peps/pep-0237/](https://www.python.org/dev/peps/pep-0237/)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between float, decimal, and fraction
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers us several ways to work with rational numbers and approximations
    of irrational numbers. We have three basic choices:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Float
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraction
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With so many choices, when do we use each of these?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to be sure about our core mathematical expectations. If we're
    not sure what kind of data we have, or what kinds of results we want to get, we
    really shouldn't be coding. We need to take a step back and review things with
    pencil and paper.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们的核心数学期望是很重要的。如果我们不确定我们有什么样的数据，或者我们想要得到什么样的结果，我们真的不应该编码。我们需要退一步，用铅笔和纸重新审视事情。
- en: 'There are three general cases for math that involve numbers beyond integers,
    which are:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及超出整数的数字的数学有三种一般情况，即：
- en: '**Currency** : Dollars, cents, or euros. Currency generally has a fixed number
    of decimal places. There are rounding rules used to determine what 7.25% of $2.95
    is.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 货币：美元、分或欧元。货币通常有固定的小数位数。有舍入规则用于确定7.25%的$2.95是多少。
- en: '**Rational Numbers or Fractions** : When we''re working with American units
    for feet and inches, or cooking measurements in cups and fluid ounces, we often
    need to work in fractions. When we scale a recipe that serves eight, for example,
    down to five people, we''re doing fractional math using a scaling factor of 5/8
    . How do we apply this to 2/3 cup of rice and still get a measurement that fits
    an American kitchen gadget?'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有理数或分数：当我们使用英尺和英寸的美国单位，或者使用杯和液体盎司的烹饪度量时，我们经常需要使用分数。例如，当我们将为八个人的食谱缩小到五个人时，我们正在使用5/8的缩放因子进行分数运算。我们如何将这应用到2/3杯米饭，并且仍然得到一个适合美国厨房工具的度量？
- en: '**Irrational Numbers** : This includes all other kinds of calculations. It''s
    important to note that digital computers can only approximate these numbers, and
    we''ll occasionally see odd little artifacts of this approximation. The float
    approximations are very fast, but sometimes suffer from truncation issues.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无理数：这包括所有其他类型的计算。重要的是要注意，数字计算机只能近似这些数字，我们偶尔会看到这种近似的奇怪小瑕疵。浮点数近似非常快，但有时会遇到截断问题。
- en: When we have one of the first two cases, we should avoid floating-point numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有前两种情况之一时，我们应该避免使用浮点数。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll look at each of the three cases separately. First, we'll look at computing
    with currency. Then we'll look at rational numbers, and finally irrational or
    floating-point numbers. Finally, we'll look at making explicit conversions among
    these various types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看这三种情况。首先，我们将看一下使用货币进行计算。然后我们将看一下有理数，最后是无理数或浮点数。最后，我们将看一下在这些各种类型之间进行明确转换。
- en: Doing currency calculations
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行货币计算
- en: When working with currency, we should always use the `decimal` module. If we
    try to use Python's built-in `float` values, we'll have problems with rounding
    and truncation of numbers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理货币时，我们应该始终使用`decimal`模块。如果我们尝试使用Python内置的`float`值，我们将遇到舍入和截断数字的问题。
- en: 'To work with currency, we''ll do this. Import the `Decimal` class from the
    `decimal` module:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理货币，我们将这样做。从`decimal`模块导入`Decimal`类：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create `Decimal` objects from strings or integers:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串或整数创建`Decimal`对象：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created the `tax_rate` from two `Decimal` objects. One was based on a string,
    the other based on an integer. We could have used `Decimal('0.0725')` instead
    of doing the division explicitly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个`Decimal`对象创建了`tax_rate`。一个是基于字符串的，另一个是基于整数的。我们可以使用`Decimal('0.0725')`而不是显式地进行除法。
- en: The result is a hair over $0.21\. It's computed out correctly to the full number
    of decimal places.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是超过$0.21。它被正确计算到了完整的小数位数。
- en: 'If you try to create decimal objects from floating-point values, you''ll see
    unpleasant artifacts of float approximations. Avoid mixing `Decimal` and `float`
    . To round to the nearest penny, create a `penny` object:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尝试从浮点数值创建十进制对象，您将看到浮点数近似的不愉快的副作用。避免混合`Decimal`和`float`。要舍入到最接近的一分钱，创建一个`penny`对象：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Quantize your data using this penny object:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个penny对象对数据进行量化：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This shows how we can use the default rounding rule of `ROUND_HALF_EVEN` .
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们如何使用`ROUND_HALF_EVEN`的默认舍入规则。
- en: 'Every financial wizard has a different style of rounding. The `Decimal` module
    offers every variation. We might, for example, do something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个财务巫师都有不同的舍入风格。`Decimal`模块提供了每种变化。例如，我们可能会做这样的事情：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows the consequences of using a different rounding rule.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了使用不同的舍入规则的后果。
- en: Fraction calculations
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数计算
- en: 'When we''re doing calculations that have exact fraction values, we can use
    the `fractions` module. This provides us handy rational numbers that we can use.
    To work with fractions, we’ll do this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行具有精确分数值的计算时，我们可以使用`fractions`模块。这为我们提供了方便的有理数，我们可以使用。要处理分数，我们将这样做：
- en: 'Import the `Fraction` class from the `fractions` module:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`fractions`模块导入`Fraction`类：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create `Fraction` objects from strings, integers, or pairs of integers. If
    you create fraction objects from floating-point values, you may see unpleasant
    artifacts of float approximations. When the denominator is a power of 2, things
    can work out exactly:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串、整数或整数对创建`Fraction`对象。如果从浮点数值创建分数对象，可能会看到浮点数近似的不愉快的副作用。当分母是2的幂时，事情可能会完全解决：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We created one fraction from a string, `2.5` . We created the second fraction
    from a floating-point calculation, `5/8` . Because the denominator is a power
    of 2, this works out exactly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个字符串`2.5`创建了一个分数。我们从一个浮点计算`5/8`创建了第二个分数。因为分母是2的幂，这完全解决了。
- en: The result, 25/16, is a complex-looking fraction. What's a nearby fraction that
    might be simpler?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结果25/16是一个看起来复杂的分数。附近可能更简单的分数是什么？
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see that we'll use almost a cup and a half to scale the recipe for five
    people instead of eight.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们将使用将近一杯半来将为八个人的食谱缩小到五个人。
- en: Floating-point approximations
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数近似
- en: Python's built-in `float` type is capable of representing a wide variety of
    values. The trade-off here is that float often involves an approximation. In some
    cases—specifically when doing division that involves powers of 2—it can be as
    exact as a `fraction` . In all other cases, there may be small discrepancies that
    reveal the differences between the implementation of `float` and the mathematical
    ideal of an irrational number.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with `float` , we often need to round values to make them look sensible.
    Recognize that all calculations are an approximation:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Mathematically, the value should be `1` . Because of the approximations used
    for `float` , the answer isn''t exact. It''s not wrong by much, but it''s wrong.
    When we round appropriately, the value is more useful:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Know the error term. In this case, we know what the exact answer is supposed
    to be, so we can compare our calculation with the known correct answer. This gives
    us the general error value that can creep into floating-point numbers:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For most floating-point errors, this is the typical value—about 10^(-16) . Python
    has clever rules that hide this error some of the time by doing some automatic
    rounding. For this calculation, however, the error wasn't hidden.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important consequence.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't compare floating-point values for exact equality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: When we see code that uses an exact `==` test between floating-point numbers,
    there are going to be problems when the approximations differ by a single bit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers from one type to another
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `float()` function to create a `float` value from another value.
    It looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the first example, we converted a `Decimal` value to `float` . In the second
    example, we converted a `Fraction` value to `float` .
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'As we just saw, we''re never happy trying to convert `float` to `Decimal` or
    `Fraction` :'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the first example, we did a calculation among integers to create a `float`
    value that has a known truncation problem. When we created a `Fraction` from that
    truncated `float` value, we got some terrible looking numbers that exposed the
    details of the truncation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the second example tried to create a `Decimal` value from a `float`
    .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For these numeric types, Python offers us a variety of operators: `+` , `-`
    , `*` , `/` , `//` , `%` , and `**` . These are for addition, subtraction, multiplication,
    true division, truncated division, modulus, and raising to a power. We''ll look
    at the two division operators in the *Choosing between true division and floor
    division* recipe.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Python is adept at converting numbers between the various types. We can mix
    `int` and `float` values; the integers will be promoted to floating-point to provide
    the most accurate answer possible. Similarly, we can mix `int` and `Fraction`
    and the results will be `Fractions` . We can also mix `int` and `Decimal` . We
    cannot casually mix `Decimal` with `float` or `Fraction` ; we need to provide
    explicit conversions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that `float` values are really approximations. The Python
    syntax allows us to write numbers as decimal values; that's not how they're processed
    internally.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a value like this in Python, using ordinary base-10 values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The actual value used internally will involve a binary approximation of the
    decimal value we wrote.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal value for this example, `8.066e+67` , is this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The numerator is a big number, `6737037547376141` . The denominator is always
    *2^(53)* . Since the denominator is fixed, the resulting fraction can only have
    53 meaningful bits of data. Since more bits aren't available, values might get
    truncated. This leads to tiny discrepancies between our idealized abstraction
    and actual numbers. The exponent ( *2^(226)* ) is required to scale the fraction
    up to the proper range.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, 6737037547376141 * 2^(226) /2^(53) .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `math.frexp()` to see these internal details of a number:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The two parts are called the **mantissa** and the **exponent** . If we multiply
    the mantissa by *2^(53)* , we always get a whole number, which is the numerator
    of the binary fraction.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这两部分被称为**尾数**和**指数**。如果我们将尾数乘以*2^(53)*，我们总是得到一个整数，这是二进制分数的分子。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The error we noticed earlier matches this quite nicely: 10^(-16) ≈ 2^(-53)
    .'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前注意到的误差非常匹配：10^(-16) ≈ 2^(-53)。
- en: Unlike the built-in `float` , a `Fraction` is an exact ratio of two integer
    values. As we saw in the *Working with large and small integers* recipe, integers
    in Python can be very large. We can create ratios which involve integers with
    a large number of digits. We're not limited by a fixed denominator.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置的`float`不同，`Fraction`是两个整数值的精确比率。正如我们在*使用大整数和小整数*配方中看到的，Python中的整数可以非常大。我们可以创建涉及具有大量数字的整数的比率。我们不受固定分母的限制。
- en: A `Decimal` value, similarly, is based on a very large integer value, and a
    scaling factor to determine where the decimal place goes. These numbers can be
    huge and won't suffer from peculiar representation issues.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Decimal`值是基于一个非常大的整数值和一个缩放因子来确定小数点的位置。这些数字可以非常庞大，并且不会受到奇怪的表示问题的影响。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why use floating-point? Two reasons** :'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用浮点数？两个原因**：'
- en: Not all computable numbers can be represented as fractions. That's why mathematicians
    introduced (or perhaps discovered) irrational numbers. The built-in float type
    is as close as we can get to the mathematical abstraction of irrational numbers.
    A value like √2, for example, can't be represented as a fraction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有可计算的数字都可以表示为分数。这就是为什么数学家引入（或者也许是发现）无理数的原因。内置的浮点类型是我们可以接近数学抽象的无理数的方式。例如，像√2这样的值不能表示为分数。
- en: Also, float values are very fast.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浮点值非常快。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Python `math` module contains a number of specialized functions for working
    with floating-point values. This module includes common functions such as square
    root, logarithms, and various trigonometry functions. It has some other functions
    such as gamma, factorial, and the Gaussian error function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`math`模块包含了许多专门用于处理浮点数值的函数。这个模块包括了常见的函数，比如平方根、对数和各种三角函数。它还有一些其他函数，比如gamma、阶乘和高斯误差函数。
- en: The `math` module includes several functions that can help us do more accurate
    floating-point calculations. For example, the `math.fsum()` function will compute
    a floating-point sum more carefully than the built-in `sum()` function. It's less
    susceptible to approximation issues.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块包括几个函数，可以帮助我们进行更准确的浮点计算。例如，`math.fsum()`函数将比内置的`sum()`函数更谨慎地计算浮点和。它不太容易受到近似问题的影响。'
- en: 'We can also make use of the `math.isclose()` function to compare two floating-point
    values to see if they''re nearly equal:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用`math.isclose()`函数来比较两个浮点值，看它们是否几乎相等：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function provides us with a way to compare floating-point numbers meaningfully.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数为我们提供了一种有意义地比较浮点数的方法。
- en: Python also offers complex data. This involves a real and an imaginary part.
    In Python, we write `3.14+2.78j` to represent the complex number 3.14 + 2.78 √-1\.
    Python will comfortably convert between float and complex. We have the usual group
    of operators available for complex numbers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了复数数据。这涉及到一个实部和一个虚部。在Python中，我们写`3.14+2.78j`来表示复数3.14 + 2.78 √-1。Python可以很舒适地在浮点数和复数之间转换。我们有一组通常的操作符可用于复数。
- en: 'To support complex numbers, there''s a `cmath` package. The `cmath.sqrt()`
    function, for example, will return a complex value rather than raise an exception
    when extracting the square root of a negative number. Here''s an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持复数，有一个`cmath`包。例如，`cmath.sqrt()`函数将返回一个复数值，而不是在提取负数的平方根时引发异常。这里有一个例子：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is essential when working with complex numbers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这在处理复数时是必不可少的。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll talk more about floating point and fractions in the *Choosing between
    true division and floor division* recipe
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*在真除法和地板除法之间进行选择*配方中更多地讨论浮点数和分数
- en: See [https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point)
- en: Choosing between true division and floor division
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在真除法和地板除法之间进行选择
- en: Python offers us two kinds of division operators. What are they, and how do
    we know which one to use? We'll also look at the Python division rules and how
    they apply to integer values.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了两种类型的除法运算符。它们是什么，我们如何知道该使用哪一个？我们还将看一下Python的除法规则以及它们如何适用于整数值。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are several general cases for doing division:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种一般情况可以进行除法：
- en: 'A *div-mod* pair: We want two parts—the quotient and the remainder. We often
    use this when converting values from one base to another. When we convert seconds
    to hours, minutes, and seconds, we''ll be doing a *div-mod* kind of division.
    We don''t want the exact number of hours, we want a truncated number of hours,
    the remainder will be converted to minutes and seconds.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*div-mod*对：我们想要两部分——商和余数。当我们将值从一种基数转换为另一种基数时，我们经常使用这种方法。当我们将秒转换为小时、分钟和秒时，我们将进行*div-mod*类型的除法。我们不想要准确的小时数，我们想要截断的小时数，余数将被转换为分钟和秒。
- en: 'The *true* value: This is a typical floating-point value—it will be a good
    approximation to the quotient. For example, if we''re computing an average of
    several measurements, we usually expect the result to be floating-point, even
    if the input values are all integers.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*真实*值：这是典型的浮点值——它将是商的一个很好的近似值。例如，如果我们计算几个测量的平均值，我们通常希望结果是浮点数，即使输入值都是整数。'
- en: 'A *rational fraction* value: This is often necessary when working in American
    units of feet, inches, and cups. For this, we should be using the `Fraction` class.
    When we divide `Fraction` objects, we always get exact answers.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*有理分数*值：这在使用英尺、英寸和杯的美国单位时经常需要。对于这一点，我们应该使用`Fraction`类。当我们除以`Fraction`对象时，我们总是得到精确的答案。
- en: We need to decide which of these cases apply, so we know which division operator
    to use.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at the three cases separately. First we'll look at truncated floor
    division. Then we'll look at true floating-point division. Finally, we'll look
    at division of fractions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Doing floor division
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are doing the *div-mod* kind of calculations, we might use floor division,
    `//` , and modulus, `%` . Or, we might use the `divmod()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll divide the number of seconds by 3600 to get the value of `hours` ; the
    modulus, or remainder, can be converted separately to `minutes` and `seconds`
    :'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, using remaining values, we''ll divide the number of seconds by 60 to
    get `minutes` ; the remainder is a number of seconds less than 60:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s the alternative, using the `divmod()` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute quotient and remainder at the same time:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compute quotient and remainder again:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Doing true division
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A true value calculation gives as a floating-point approximation. For example,
    about how many hours is 7386 seconds? Divide using the true division operator:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We provided two integer values, but got a floating-point exact result. Consistent
    with our previous recipe for using floating-point values, we rounded the result
    to avoid having to look at tiny error values.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: This true division is a feature of Python 3\. We'll look at this from a Python
    2 perspective in the next sections.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Rational fraction calculations
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can do division using `Fraction` objects and integers. This forces the result
    to be a mathematically exact rational number:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Create at least one `Fraction` value:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the `Fraction` value in a calculation. Any integer will be promoted to
    a `Fraction` :'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If necessary, convert the exact fraction to a floating-point approximation:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we created a `Fraction` object for the total number of seconds. When
    we do arithmetic on fractions, Python will promote any integers to be fractions;
    this promotion means that the math is done as exactly as possible.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python 3 has two division operators.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The `/` true division operator always tries to produce a true, floating-point
    result. It does this even when the two operands are integers. This is an unusual
    operator in this respect. All other operators try to preserve the type of the
    data. The true division operation - when applied to integers - produces a `float`
    result.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `//` truncated division operator always tries to produce a truncated result.
    For two integer operands, this is the truncated quotient. For two floating-point
    operands, this is a truncated floating-point result:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By default, Python 2 only has one division operator. For programmers still
    using Python 2, we can start using these new division operators with this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This import will install the Python 3 division rules.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more on the choice between floating-point and fractions, see the *Choosing
    between float, decimal, and fraction* recipe
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://www.python.org/dev/peps/pep-0238/](https://www.python.org/dev/peps/pep-0238/)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting an immutable string
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we rewrite an immutable string? We can''t change individual characters
    inside a string:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since this doesn't work, how do we make a change to a string?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume we have a string like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''d like to do two transformations:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Remove the part before the `:`
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the punctuation with `_` , and make all the characters lowercase
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we can''t replace characters in a string object, we have to work out
    some alternatives. There are several common things we can do, shown as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: A combination of slicing and concatenating a string to create a new string.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When shortening, we often use the `partition()` method.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can replace a character or a substring with the `replace()` method.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can expand the string into a list of characters, then join the string back
    into a single string again. This is the subject for a separate recipe, *Building
    complex strings with a list of characters* .
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we can''t update a string in place, we have to replace the string variable''s
    object with each modified result. We''ll use a statement that looks like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or we could even use:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We'll look at a number of specific variations on this general theme. We'll slice
    a piece of a string, we'll replace individual characters within a string, and
    we'll apply blanket transformations such as making the string lowercase. We'll
    also look at ways to remove extra `_` that show up in our final string.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Slicing a piece of a string
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s how we can shorten a string via slicing:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the boundary:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The index function locates a particular substring and returns the position where
    that substring can be found. If the substring doesn't exist, it raises an exception.
    This is always `true` of the result `title[colon_position] == ':'` .
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick the substring:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've used the slicing notation to show the `start:end` of the characters to
    pick. We also used multiple assignment to assign two variables, `discard_text`
    and `post_colon_text` , from two expressions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `partition()` as well as manual slicing. Find the boundary and partition:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `partition` function returns three things: the part before the target,
    the target, and the part after the target. We used multiple assignment to assign
    each object to a different variable. We assigned the target to a variable named
    `_` because we''re going to ignore that part of the result. This is a common idiom
    for places where we must provide a variable, but we don''t care about using the
    object.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Updating a string with a replacement
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use `replace()` to remove punctuation marks. When using `replace` to
    switch punctuation marks, save the results back into the original variable. In
    this case, `post_colon_text` :'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This has replaced the two kinds of punctuation with the desired `_` characters.
    We can generalize this to work with all punctuation. This leverages the `for`
    statement, which we'll look at in [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* .
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'We can iterate through all punctuation characters:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As each kind of punctuation character is replaced, we assign the latest and
    greatest version of the string to the `post_colon_text` variable.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Making a string all lowercase
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another transformational step is changing a string to all lowercase. As with
    the previous examples, we''ll assign the results back to the original variable.
    Use the `lower()` method, assigning the result to the original variable:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Removing extra punctuation marks
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many cases, there are some additional steps we might follow. We often want
    to remove leading and trailing `_` characters. We can use `strip()` for this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In some cases, we''ll have multiple `_` characters because we had multiple
    punctuation marks. The final step would be something like this to cleanup up multiple
    `_` characters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is yet another example of the same pattern we've been using to modify a
    string in place. This depends on the `while` statement, which we'll look at in
    [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements
    and Syntax* .
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can't—technically—modify a string in place. The data structure for a string
    is immutable. However, we can assign a new string back to the original variable.
    This technique behaves the same as modifying a string in place.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'When a variable''s value is replaced, the previous value no longer has any
    references and is garbage collected. We can see this by using the `id()` function
    to track each individual string object:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Your actual id numbers may be different. What's important is that the original
    string object assigned to `post_colon_text` had one id. The new string object
    assigned to `post_colon_text` has a different id. It's a new string object.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: When the old string has no more references, it is removed from memory automatically.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'We made use of **slice notation** to decompose a string. A slice has two parts:
    `[start:end]` . A slice always includes the starting index. String indices always
    start with zero as the first item. It never includes the ending index.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The items in a slice have an index from `start` to `end-1` . This is sometimes
    called a **half-open** interval.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a slice like this: all characters where the index, *i* , are in the
    range *start ≤ i* < *end* .'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'We noted briefly that we can omit the start or end indices. We can actually
    omit both. Here are the various options available:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '`title[colon_position]` : A single item, the `:` we found using `title.index('':'')`
    .'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[:colon_position]` : A slice with the start omitted. It begins at the
    first position, index of zero.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[colon_position+1:]` : A slice with the end omitted. It ends at the end
    of the string, as if we said `len(title)` .'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[:]` : Since both start and end are omitted, this is the entire string.
    Actually, it''s a *copy* of the entire string. This is the quick and easy way
    to duplicate a string.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more features to indexing in Python collections like a string. The
    normal indices start with 0 at the left end. We have an alternate set of indices
    using negative names that work from the right end of a string.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`title[-1]` is the last character in the title, `g`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[-2]` is the next-to-last character, `n`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[-6:]` is the last six characters, `String`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a lot of ways to pick pieces and parts out of a string.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Python offers dozens of methods for modifying a string. *Section 4.7* of the
    *Python Standard Library* describes the different kinds of transformations that
    are available to us. There are three broad categories of string methods. We can
    ask about a string, we can parse a string, and we can transform a string. Methods
    such as `isnumeric()` tell us if a string is all digits.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We've looked at parsing with the `partition()` method. And we've looked at transforming
    with the `lower()` method.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at the string as list technique for modifying a string in the *Building
    complex strings from lists of characters* recipe.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes we have data that's only a stream of bytes. In order to make sense
    of it, we need to convert it into characters. That's the subject for the *Decoding
    bytes – how to get proper characters from some bytes* recipe.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String parsing with regular expressions
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we decompose a complex string? What if we have complex, tricky punctuation?
    Or—worse yet—what if we don't have punctuation, but have to rely on patterns of
    digits to locate meaningful information?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to decompose a complex string is by generalizing the string
    into a pattern and then writing a regular expression that describes that pattern.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: There are limits to the patterns that regular expressions can describe. When
    we're confronted with deeply-nested documents in a language like HTML, XML, or
    JSON, we often run into problems, and can't use regular expressions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The `re` module contains all of the various classes and functions we need to
    create and use regular expressions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to decompose text from a recipe website. Each line
    looks like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We want to separate the ingredient from the measurements.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write and use regular expressions, we often do this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Generalize the example. In our case, we have something that we can generalize
    as:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ve replaced literal text with a two-part summary: what it means and how
    it''s represented. For example, ingredient is represented as words, amount is
    represented as digits. Import the `re` module:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Rewrite the pattern into **Regular Expression** ( **RE** ) notation:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've replaced representation hints such as *words* with `\w+` . We've replaced
    *digits* with `\d+` . And we've replaced *single spaces* with `\s+` to allow one
    or more spaces to be used as punctuation. We've left the colon in place, because
    in the regular expression notation, a colon matches itself.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: For each of the fields of data, we've used `?P<name>` to provide a name that
    identifies the data we want to extract. We didn't do this around the colon or
    the spaces because we don't want those characters.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: REs use a lot of `\` characters. To make this work out nicely in Python, we
    almost always use *raw* strings. The `r'` prefix tells Python not to look at the
    `\` characters and not to replace them with special characters that aren't on
    our keyboards.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the pattern:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Match the pattern against input text. If the input matches the pattern, we''ll
    get a match object that shows details of the matching:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This, by itself, is pretty cool: we have a tuple of the different fields within
    the string. We''ll return to the use of tuples in a recipe named *Using tuples*
    .'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the named groups of characters from the match object:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Each group is identified by the name we used in the `(?P<name>...)` part of
    the RE.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of different kinds of string patterns that we can describe with
    RE.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shown a number of character classes:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`\w` matches any alphanumeric character (a to z, A to Z, 0 to 9)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d` matches any decimal digit'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches any space or tab character'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These classes also have inverses:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '`\W` matches any character that''s not a letter or a digit'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\D` matches any character that''s not a digit'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S` matches any character that''s not some kind of space or tab'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many characters match themselves. Some characters, however, have special meaning,
    and we have to use `\` to escape from that special meaning:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: We saw that `+` as a suffix means to match one or more of the preceeding patterns.
    `\d+` matches one or more digits. To match an ordinary `+` , we need to use `\+`
    .
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have `*` as a suffix which matches zero or more of the preceding patterns.
    `\w*` matches zero or more characters. To match a `*` , we need to use `\*` .
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have `?` as a suffix which matches zero or one of the preceding expressions.
    This character is used in other places, and has a slightly different meaning.
    We saw it in `(?P<name>...)` where it was inside the `()` to define special properties
    for the grouping.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.` matches any single character. To match a `.` specifically, we need to
    use `\` .
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create our own unique sets of characters using `[]` to enclose the elements
    of the set. We might have something like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This has a `\w+` to match any number of alphanumeric characters. This will be
    collected into a group with the name of `name` .
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: It uses `\s*` to match an optional sequence of spaces.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: It matches any character in the set `[=:]` . One of the two characters in this
    set must be present.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: It uses `\s*` again to match an optional sequence of spaces.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it uses `.*` to match everything else in the string. This is collected
    into a group named `value` .
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this to parse strings like this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By being flexible with the punctuation, we can make a program easier to use.
    We'll tolerate any number of spaces, and either an `=` or a `:` as a separator.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A long regular expression can be awkward to read. We have a clever Pythonic
    trick for presenting an expression in a way that''s much easier to read:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This leverages three syntax rules:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: A statement isn't finished until the `()` characters match
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjacent string literals are silently concatenated into a single long string
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything between `#` and the end of the line is a comment, and is ignored
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've put Python comments after the important clauses in our regular expression.
    This can help us understand what we did, and perhaps help us diagnose problems
    later.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Decoding Bytes - How to get proper characters from some bytes* recipe
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many books on Regular Expressions and Python Regular Expressions in
    particular like *Mastering Python Regular Expressions* ([https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions)
    )
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building complex strings with "template".format()
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating complex strings is, in many ways, the polar opposite of parsing a complex
    string. We generally find that we'll use a template with substitution rules to
    put data into a more complex format.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have pieces of data that we need to turn into a nicely formatted
    message. We might have data including the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And we''d like a line that looks like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a template string from the result, replacing all of the data items with
    `{}` placeholders. Inside each placeholder, put the name of the data item.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For each data item, append `:data type` information to the placeholders in
    the template string. The basic data type codes are:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`s` for string'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` for decimal number'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` for floating-point number'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would look like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add length information where required. Length is not always required, and in
    some cases, it''s not even desirable. In this example, though, the length information
    assures that each message has a consistent format. For strings and decimal numbers,
    prefix the format with the length like this: `19s` or `3d` . For floating-point
    numbers use a two part prefix like this: `5.2f` to specify the total length of
    five characters with two to the right of the decimal point. Here''s the whole
    format:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Use the `format()` method of this string to create the final string:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We''ve provided all of the variables by name in the `format()` method of the
    template string. This can get tedious. In some cases, we might want to build a
    dictionary object with the variables. In that case, we can use the `format_map()`
    method:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We'll return to dictionaries in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Build-in Data Structures – list, set, dict*
    .
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `vars()` function builds a dictionary of all of the local variables
    for us:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `vars()` function is very handy for building a dictionary automatically.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The string `format()` and `format_map()` methods can do a lot of relatively
    sophisticated string assembly for us.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The basic feature is to interpolate data into a string based on names of keyword
    arguments or keys in a dictionary. Variables can also be interpolated by position—we
    can provide position numbers instead of names. We can use a format specification
    like `{0:3s}` to use the first positional argument to `format()` .
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen three of the formatting conversions—`s` , `d` , `f` —there are
    many others. Details are in *Section 6.1.3* of the *Python Standard Library* .
    Here are some of the format conversions we might use:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '`b` is for binary, base 2.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` is for Unicode character. The value must be a number, which is converted
    to a character. Often, we use hexadecimal numbers for this so you might want to
    try values such as `0x2661` through `0x2666` for fun.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` is for decimal numbers.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E` and `e` are for scientific notations. `6.626E-34` or `6.626e-34` depending
    on which E or e character is used.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F` and `f` are for floating-point. For *not a number* the `f` format shows
    lowercase `nan` ; the `F` format shows uppercase `NAN` .'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G` and `g` are for general. This switches automatically between `E` and `F`
    (or `e` and `f` ,) to keep the output in the given sized field. For a format of
    `20.5G` , up to 20-digit numbers will be displayed using `F` formatting. Larger
    numbers will use `E` formatting.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` is for locale-specific decimal numbers. This will insert `,` or `.` characters
    depending on the current locale settings. The default locale may not have a thousand
    separators defined. For more information, see the `locale` module.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o` is for octal, base 8.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` is for string.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` and `x` is for hexadecimal, base 16\. The digits include uppercase `A-F`
    and lowercase `a-f` , depending on which `X` or `x` format character is used.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` is for percentage. The number is multiplied by 100 and includes the `%`
    .'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a number of prefixes we can use for these different types. The most
    common one is the length. We might use `{name:5d}` to put in a 5-digit number.
    There are several prefixes for the preceding types:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '**Fill and alignment** : We can specify a specific filler character (space
    is the default) and an alignment. Numbers are generally aligned to the right and
    strings to the left. We can change that using `<` , `>` , or `^` . This forces
    left alignment, right alignment, or centering. There''s a peculiar `=` alignment
    that''s used to put padding after a leading sign.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign** : The default rule is a leading negative sign where needed. We can
    use `+` to put a sign on all numbers, `-` to put a sign only on negative numbers,
    and a space to use a space instead of a plus for positive numbers. In scientific
    output, we must use `{value: 5.3f}` . The space makes sure that room is left for
    the sign, assuring that all the decimal points line up nicely.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alternate form** : We can use the `#` to get an alternate form. We might
    have something like `{0:#x}` , `{0:#o}` , `{0:#b}` to get a prefix on hexadecimal,
    octal, or binary values. With a prefix, the numbers will look like `0xnnn` , `0onnn`
    , or `0bnnn` . The default is to omit the two character prefix.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leading zero** : We can include `0` to get leading zeros to fill in the front
    of a number. Something like `{code:08x` ) will produce a hexadecimal value with
    leading zeroes to pad it out to eight characters.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Width and precision** : For integer values and strings, we only provide the
    width. For floating-point values we often provide `width.precision` .'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some times when we won't use a `{name:format}` specification. Sometimes
    we'll need to use a `{name!conversion}` specification. There are only three conversions
    available.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '`{name!r}` shows the representation that would be produced by `repr(name)`'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{name!s}` shows the string value that would be produced by `str(name)`'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{name!a}` shows the ASCII value that would be produced by `ascii(name)`'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we'll leverage the idea of the `{name!r}`
    format specification to simplify displaying information about related objects.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A handy debugging hack this:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `vars()` function—with no arguments—collects all of the local variables
    into a mapping. We provide that mapping for `format_map()` . The format template
    can use lots of `{variable_name!r}` to display details about various objects we
    have in local variables.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a class definition we can use techniques such as `vars(self)` . This
    looks forward to [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes
    and Objects") , *Basics of Classes and Objects* :'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Our class definition includes a `__str__()` method. This method relies on `vars(self)`
    to create a useful dictionary of just the attribute of the object.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Python Standard Library* , *Section 6.1.3* has all of the details on the
    format method of a string
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building complex strings from lists of characters
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make very complex changes to an immutable string? Can we assemble
    a string from individual characters?
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the recipes we've already seen give us a number of tools for
    creating and modifying strings. There are yet more ways in which we can tackle
    the string manipulation problem. We'll look at using a list object. This will
    dovetail with some of the recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a string that we''d like to rearrange:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We''d like to do two transformations:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Remove the part before the `:`
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the punctuation with `_` , and make all the characters lowercase
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll make use of the `string` module:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This has two important constants:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '`string.whitespace` lists all of the common whitespace characters, including
    space and tab'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string.punctuation` lists the common ASCII punctuation marks. Unicode has
    a larger list of punctuation marks; that''s also available based on your locale
    settings'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can work with a string exploded into a list. We'll look at lists in more
    depth in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* .
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'Explode the string into a `list` object:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Find the partition character. The `index()` method for a list has the same
    semantics as the `index()` method for a list. It locates the position with the
    given value:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Delete the characters no longer needed. The `del` statement can remove items
    from a list. Lists are a mutable data structures:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We don't need to carefully work with the useful piece of the original string.
    We can remove items from a list.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace punctuation by stepping through each position. In this case, we''ll
    use a `for` statement to visit every index in the string:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The expression `range(len(title_list))` generates all of the values between
    `0` and `len(title_list)-1` . This assures us that the value of position will
    be each value index in the list. Join the list of characters to create a new string.
    It seems a little odd to use zero-length string, `''''` , as a separator when
    concatenating strings together. However, it works perfectly:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We assigned the resulting string back to the original variable. The original
    string object, which had been referred to by that variable, is no longer needed:
    it''s removed from memory. The new string object replaces the value of the variable.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a change in representation trick. Since a string is immutable, we can't
    update it. We can, however, convert it into a mutable form; in this case, a list.
    We can do whatever changes are required to the mutable list object. When we're
    done, we can change the representation from a list back to a string.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Strings provide a number of features that lists don't. Conversely, strings provide
    a number of features a list doesn't have. We can't convert a list to lowercase
    the way we can convert a string.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important trade-off here:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Strings are immutable, that makes them very fast. Strings are focused on Unicode
    characters. When we look at mappings and sets, we can use strings as keys for
    mappings and items in sets because the value is immutable.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are mutable. Operations are slower. Lists can hold any kind of item. We
    can't use a list as a key for a mapping or an item in a set because the value
    could change.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings and lists are both specialized kinds of sequences. Consequently, they
    have a number of common features. The basic item indexing and slicing features
    are shared. Similarly a list uses the same kind of negative index values that
    a string does: `list[-1]` is the last item in a list object.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to mutable data structures in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've started working with a list of characters instead of a string, we
    no longer have the string processing methods. We do have a number of list-processing
    techniques available to us. In addition to being able to delete items from a list,
    we can append an item, extend a list with another list, and insert a character
    into the list.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change our viewpoint slightly, and look at a list of strings instead
    of a list of characters. The technique of doing `''''.join(list)` will work when
    we have a list of strings as well as a list of characters. For example, we might
    do this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Our `title_list` object will be mutated into a list that contains a six-character
    string, prefix, plus 30 individual characters.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also work with strings using the internal methods of a string. See the
    *Rewriting an immutable string* recipe for more techniques.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we need to build a string, and then convert it into bytes. See the
    *Encoding strings – creating ASCII and UTF-8 bytes* recipe for how we can do this.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other times, we'll need to convert bytes into a string. See the *Decoding Bytes
    - How to get proper characters from some bytes* recipe.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Unicode characters that aren't on our keyboards
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big keyboard might have almost 100 individual keys. Fewer than 50 of these
    are letters, numbers and punctuation. At least a dozen are *function* keys that
    do things other than simply *insert* letters into a document. Some of the keys
    are different kinds of *modifiers* that are meant to be used in conjunction with
    another key—we might have *Shift* , *Ctrl* , Option, and *Command* .
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Most operating systems will accept simple key combinations that create about
    100 or so characters. More elaborate key combinations may create another 100 or
    so less popular characters. This isn't even close to covering the million characters
    from the world's alphabets. And there are icons, emoticons, and dingbats galore
    in our computer fonts. How do we get to all of those glyphs?
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python works in Unicode. There are millions of individual Unicode characters
    available.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: We can see all the available characters at [https://en.wikipedia.org/wiki/List_of_Unicode_characters
    and also http://www.unicode.org/charts/](https://en.wikipedia.org/wiki/List_of_Unicode_characters%20and%20also%20http://www.unicode.org/charts/)
    .
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: We'll need the Unicode character number. We might also want the Unicode character
    name.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'A given font on our computer may not be designed to provide glyphs for all
    of those characters. In particular, Windows computer fonts may have trouble displaying
    some of these characters. Using the Windows command to change to code page 65001
    is sometimes necessary:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Linux and Mac OS X rarely have problems with Unicode characters.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python uses **escape sequences** to extend the ordinary characters we can type
    to cover the vast space of Unicode characters. The escape sequences start with
    a `\` character. The next character tells exactly how the Unicode character will
    be represented. Locate the character that''s needed. Get the name or the number.
    The numbers are always given as hexadecimal, base 16\. They''re often written
    as `U+2680` . The name might be `DIE FACE-1` . Use `\unnnn` with up to a four-digit
    number. Or use `\N{name}` with the spelled-out name. If the number is more than
    four digits, use `\Unnnnnnnn` with the number padded out to eight digits:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](Image00001.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: Yes, we can include a wide variety of characters in Python output. To place
    a `\` character in the string, we need to use `\\` . For example, we might need
    this for Windows filenames.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses Unicode internally. The 128 or so characters we can type directly
    using the keyboard all have handy internal Unicode numbers.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Python treats it as shorthand for this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Once we get beyond the characters on our keyboards, the remaining millions of
    characters are identified only by their number.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: When the string is being compiled by Python, the `\uxx` , `\Uxxxxxxxx` , and
    `\N{name}` are all replaced by the proper Unicode character. If we have something
    syntactically wrong—for example, `\N{name` with no closing `}` —we'll get an immediate
    error from Python's internal syntax checking.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Back in the *String parsing with regular expressions* recipe, we noted that
    regular expressions use a lot of `\` characters and we specifically do not want
    Python's normal compiler to touch them; we used the `r'` prefix on a regular expression
    string to prevent the `\` from being treated as an escape and possibly converted
    to something else.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: What if we need to use Unicode in a Regular Expression? We'll need to use `\\`
    all over the place in the Regular Expression. We might see this `'\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+'`
    . We skipped the `r'` prefix on the string. We doubled up the `\` used for Regular
    Expressions. We used `\uxxxx` for the Unicode characters that are part of the
    pattern. Python's internal compiler will replace the `\uxxxx` with Unicode characters
    and the `\\` with a single `\` internally.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we look at a string at the `>>>` prompt, Python will display the string
    in its canonical form. Python prefers to use the `''` as a delimiter even though
    we can use either `''` or `"` for a string delimiter. Python doesn''t generally
    display raw strings, instead it puts all of the necessary escape sequences back
    into the string:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> r"\w+"`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '`''\\w+''`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: We provided a string in raw form. Python displayed it in canonical form.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Encoding strings – creating ASCII and UTF-8 bytes* and the *Decoding
    Bytes - How to get proper characters from some bytes* recipes we'll look at how
    Unicode characters are converted to sequences of bytes so we can write them to
    a file. We'll look at how bytes from a file (or downloaded from a website) are
    turned into Unicode characters so they can be processed.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're interested in history, you can read up on ASCII and EBCDIC and other
    old-fashioned character codes here [http://www.unicode.org/charts/](http://www.unicode.org/charts/)
    .
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding strings – creating ASCII and UTF-8 bytes
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our computer files are bytes. When we upload or download from the Internet,
    the communication works in bytes. A byte only has 256 distinct values. Our Python
    characters are Unicode. There are a lot more than 256 Unicode characters.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: How do we map Unicode characters to bytes for writing to a file or transmitting?
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, a character occupied 1 byte. Python leverages the old ASCII encoding
    scheme for bytes; this sometimes leads to confusion between bytes and proper strings
    of Unicode characters.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters are encoded into sequences of bytes. We have a number of
    standardized encodings and a number of non-standard encodings.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Plus, we also have some encodings that only work for a small subset of Unicode
    characters. We try to avoid this, but there are some situations where we'll need
    to use a subset encoding scheme.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Unless we have a really good reason, we almost always use the UTF-8 encoding
    for Unicode characters. Its main advantage is that it's a compact representation
    for the Latin alphabet used for English and a number of European languages.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, an Internet protocol requires ASCII characters. This is a special
    case that requires some care because the ASCII encoding can only handle a small
    subset of Unicode characters.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python will generally use our OS''s default encoding for files and Internet
    traffic. The details are unique to each OS:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a general setting using the `PYTHONIOENCODING` environment variable.
    We set this outside of Python to assure that a particular encoding is used everywhere.
    Set the environment variable as:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run Python:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We sometimes need to make specific settings when we open a file inside our
    script. We''ll return this in [Chapter 9](text00099.html#page "Chapter 9. Input/Output,
    Physical Format, and Logical Layout") , *Input/Output, Physical Format, Logical
    Layout* . Open the file with a given encoding. Read or write Unicode characters
    to the file:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can also manually encode characters, in the rare case that we need to open
    a file in bytes mode; if we use a mode of `wb` , we''ll need to use manual encoding:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We can see that a sequence of bytes (`\xf0\x9f\x80\x80` ) was used to encode
    a single Unicode character, `U+1F000` , ![How to do it...](Image00002.jpg)  .
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unicode defines a number of encoding schemes. While UTF-8 is the most popular,
    there are also UTF-16 and UTF-32\. The number is the typical number of bits per
    character. A file with 1000 characters encoded in UTF-32 would be 4000 8-bit bytes.
    A file with 1000 characters encoded in UTF-8 could be as few as 1000 bytes, depending
    on the exact mix of characters. In the UTF-8 encoding, characters with Unicode
    numbers above `U+007F` require multiple bytes.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Various OS's have their own coding schemes. Mac OS X files are often encoded
    in `Mac Roman` or `Latin-1` . Windows files might use `CP1252` encoding.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: The point with all of these schemes is to have a sequence of bytes that can
    be mapped to a Unicode character. And—going the other way—a way to map each Unicode
    character to one or more bytes. Ideally, all of the Unicode characters are accounted
    for. Pragmatically, some of these coding schemes are incomplete. The tricky part
    is to avoid writing any more bytes than is necessary.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The historical `ASCII` encoding can only represent about 250 of the Unicode
    characters as bytes. It's easy to create a string which cannot be encoded using
    the ASCII scheme.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the error looks like:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We may see this kind of error when we accidentally open a file with a poorly
    chosen encoding. When we see this, we'll need to change our processing to select
    a more useful encoding; ideally, UTF-8.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bytes vs Strings**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Bytes are often displayed using printable characters.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: We'll see `b'hello'` as a short-hand for a five-byte value. The letters are
    chosen using the old ASCII encoding scheme. Many byte values from about `0x20`
    to `0xFE` will be shown as characters.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing. The prefix of `b'` is our hint that we're looking at
    bytes, not proper Unicode characters.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to build strings of data. See the *Building complex
    strings with "template".format()* and the *Building complex strings from lists
    of characters* recipes for examples of creating complex strings. The idea is that
    we might have an application that builds a complex string, and then we encode
    it into bytes.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the UTF-8 encoding, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    .
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For general information on Unicode encodings, see [http://unicode.org/faq/utf_bom.html](https://en.wikipedia.org/wiki/UTF-8)
    .
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding bytes – how to get proper characters from some bytes
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we work with files that aren't properly encoded? What do we do with
    files written in the ASCII encoding?
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: A download from the Internet is almost always in bytes—not characters. How do
    we decode the characters from that stream of bytes?
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Also, when we use the `subprocess` module, the results of an OS command are
    in bytes. How can we recover proper characters?
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Much of this is also relevant to the material in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout* . We've included the recipe here because it's
    the inverse of the previous recipe, *Encoding strings – creating ASCII and UTF-8
    bytes* .
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we're interested in offshore marine weather forecasts. Perhaps because
    we own a large sailboat. Or perhaps because good friends of ours have a large
    sailboat and are departing the **Chesapeake Bay** for the **Caribbean** .
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Are there any special warnings coming from the **National Weather Services**
    office in Wakefield, Virginia?
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s where we can get the warnings: [http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ](http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ)
    .'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'We can download this with Python''s `urllib` module:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Or, we can use programs like `curl` or `wget` to get this. We might do:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Since `curl` left us with an awkward file name, we needed to rename the file.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 'The `forecast_text` value is a stream of bytes. It''s not a proper string.
    We can tell because it starts like this:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: And goes on for a while providing details. Because it starts with `b'` , it's
    bytes, not proper Unicode characters. It was probably encoded with UTF-8, which
    means some characters could have weird-looking `\xnn` escape sequences instead
    of proper characters. We want to have the proper characters.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bytes vs Strings**'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Bytes are often displayed using printable characters.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: We'll see `b'hello'` as a short-hand for a five-byte value. The letters are
    chosen using the old ASCII encoding scheme. Many byte values from about `0x20`
    to `0xFE` will be shown as characters.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing. The prefix of `b'` is our hint that we're looking at
    bytes, not proper Unicode characters.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Generally, bytes behave somewhat like strings. Sometimes we can work with bytes
    directly. Most of the time, we'll want to decode the bytes and create proper Unicode
    characters.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: How to do it..
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.Determine the coding scheme if possible. In order to decode bytes to create
    proper Unicode characters, we need to know what encoding scheme was used. When
    we read XML documents, there''s a big hint provided within the document:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When browsing web pages, there''s often a header with this information:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Sometimes an HTML page may include this as part of the header:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In other cases, we're left to guess. In the case of US Weather data, a good
    first guess is UTF-8\. Other good guesses include ISO-8859-1\. In some cases,
    the guess will depend on the language.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 7.2.3* , *Python Standard Library* lists the standard encodings available.
    Decode the data:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `b'` prefix is gone. We've created a proper string of Unicode characters
    from the stream of bytes.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: If this step fails with an exception, we guessed wrong about the encoding. We
    need to try another encoding. Parse the resulting document.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is an HTML document, we should use **Beautiful Soup** . See [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)
    .
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, extract one nugget of information from this document without
    completely parsing the HTML:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This tells us what we need to know: there are no warnings at this time. That
    doesn''t mean smooth sailing, but it does mean that there aren''t any major weather
    systems that can cause catastrophes.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Encoding strings – creating ASCII and UTF-8 bytes* recipe for more
    information on Unicode and the different ways that Unicode characters can be encoded
    into streams of bytes.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: At the foundation of the operating system, files and network connections are
    built up from bytes. It's our software that decodes the bytes to discover the
    content. It might be characters, or images, or sounds. In some cases, the default
    assumptions are wrong and we need to do our own decoding.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-642
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've recovered the string data, we have a number of ways of parsing or
    rewriting it. See the *String parsing with regular expressions* recipe for examples
    of parsing a complex string.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on encodings, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    and [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html)
    .
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tuples of items
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the best way to represent simple ( *x* , *y* ) and ( *r* , *g* , *b*
    ) groups of values? How can we keep things which are pairs such as latitude and
    longitude together?
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *String parsing with regular expressions* recipe, we skipped over an
    interesting data structure.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'We had data that looked like this:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We parsed this into the meaningful data using a regular expression like this:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The result is a tuple object with three pieces of data. There are lots of places
    where this kind of grouped data come in handy.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at two aspects to this: putting things into tuples and getting
    things out of tuples.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: Creating tuples
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of places where Python creates tuples of data for us. In the
    *Getting ready* section of the *String Parsing with Regular Expressions* recipe
    we showed how a regular expression match object will create a tuple of text that
    was parsed from a string.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own tuples, too. Here are the steps:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Enclose the data in `()` .
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separate the items with a `,` .
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: There's an important special case for the one-tuple, or singleton. We have to
    include an extra `,` even when there's only one item in the tuple.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Tip
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `()` characters aren''t always required. There are a few times where we
    can omit them. It''s not a good idea to omit them, but we can see funny things
    when we have an extra comma:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The extra comma after `355` makes the value into a singleton tuple.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: Extracting items from a tuple
  id: totrans-668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea of a tuple is to be a container with a number of items that''s fixed
    by the problem domain: for example, `(red, green, blue)` color numbers. The number
    of items is always three.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we''ve got an ingredient, and amount, and units. This must
    be a three-item collection. We can look at the individual items two ways:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'By index position: Positions are numbered starting with zero from the left:'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Using multiple assignment:'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Tuples—like strings—are immutable. We can't change the individual items inside
    a tuple. We use tuples when we want to keep the data together.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are one example of the more general class of `Sequence` . We can do a
    few things with sequences.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example tuple that we can work with:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here are some operations we can perform on this tuple:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: How many items in `t` ?
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How many times does a particular value appear in `t` ?
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Which position has a particular value?
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When an item doesn''t exist, we''ll get an exception:'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Does a particular value exist?
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There's more
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple, like a string, is a sequence of items. In the case of a string, it's
    a sequence of characters. In the case of a tuple, it's a sequence of many things.
    Because they're both sequences, they have some common features. We've noted that
    we can pluck out individual items by their index position. We can use the `index()`
    method to locate the position of an item.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: The similarities end there. A string has many methods to create a new string
    that's a transformation of a string, plus methods to parse strings, plus methods
    to determine the content of the strings. A tuple doesn't have any of these bonus
    features. It's—perhaps—the simplest possible data structure.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at one other sequence, the list, in the *Building complex strings
    from lists of characters* recipe
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also look at sequences in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, tuple,
    set, dict*
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
