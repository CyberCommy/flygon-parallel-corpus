- en: Chapter 1. Numbers, Strings, and Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll cover these recipes to introduce basic Python data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating meaningful names and using variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with large and small integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between float, decimal, and fraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between true division and floor division
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting an immutable string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String parsing with regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building complex strings with "template".format()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building complex strings from lists of characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Unicode characters that aren't on our keyboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding strings – creating ASCII and UTF-8 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding bytes – how to get proper characters from some bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tuples of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will look at some central types of Python objects. We'll look at
    the different kinds of numbers, working with strings, and using tuples. We'll
    look at these first because they're the simplest kinds of data Python works with.
    In later chapters, we'll look at data collections.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these recipes assume a beginner's level of understanding of Python 3\.
    We'll be looking at how we use the essential built-in types available in Python—numbers,
    strings, and tuples. Python has a rich variety of numbers, and two different division
    operators, so we'll need to look closely at the choices available to us.
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, there are several common operations that are important.
    We'll explore some of the differences between bytes—as used by our OS files, and
    Strings—as used by Python. We'll look at how we can exploit the full power of
    the Unicode character set.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll show the recipes as if we're working from the `>>>` prompt
    in interactive Python. This is sometimes called the **read-eval-print loop** (
    **REPL** ). In later chapters, we'll look more closely at writing script files.
    The goal is to encourage interactive exploration because it's a great way to learn
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: Creating meaningful names and using variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we be sure our programs make sense? One of the core elements of making
    expressive code is to use *meaningful* names. But what counts as meaningful? In
    this recipe, we'll review some common rules for creating meaningful Python names.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at some of Python's assignment statement variations. We can,
    for example, assign more than one variable in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core issue when creating a name is to ask ourselves the question *what is
    this thing?* For software, we'd like a name that's descriptive of the object being
    named. Clearly, a name like `x` is not very descriptive, it doesn't seem to refer
    to an actual thing.
  prefs: []
  type: TYPE_NORMAL
- en: Vague, non-descriptive names are distressingly common in some programming. It's
    not helpful to others when we use them. A descriptive name helps everyone.
  prefs: []
  type: TYPE_NORMAL
- en: When naming things, it's also important to separate the problem domain—what
    we're really trying to accomplish—from the solution domain. The solution domain
    consists of the technical details of Python, OS, and Internet. Anyone who reads
    the code can see the solution; it doesn't require deep explanation. The problem
    domain, however, can be obscured by technical details. It's our job to make the
    problem clearly visible. Well-chosen names will help.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at names first. Then we'll move on to assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing names wisely
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a purely technical level, Python names must begin with a letter. They can
    include any number of letters, digits, and the _ character. Python 3 is based
    on Unicode, so a letter is not limited to the Latin alphabet. While the A-Z Latin
    alphabet is commonly used, it's not required.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a descriptive variable, we want to create names that are both
    specific and articulate the relationships among things in our programs. One widely
    used technique is to create longer names in a style that moves from particular
    to general.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to choosing a name are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the name is a very broad summary of the thing. In a few cases,
    this may be all we need; context will supply the rest. We'll suggest some typical
    broad summary categories later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a prefix to narrow this name around your application or problem domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If needed, put more narrow and specialized prefixes on this name to clarify
    how it's distinct from other classes, modules, packages, functions, and other
    objects. When in doubt about prefixing, remember how domain names work. Think
    of `mail.google.com` —the name flows from particular to general. There's no magic
    about the three levels of naming, but it often happens to work out that way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Format the name depending on how it''s used in Python. There are three broad
    classes of things we''ll put names on, which are shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes** : A class has a name that summarizes the objects that are part
    of the class. These names will (often) use `CapitalizedCamelCase` . The first
    letter of a class name is capitalized to emphasize that it''s a class, not an
    instance of the class. A class is often a generic concept, rarely a description
    of a tangible thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects** : A name for an object usually uses `snake_case` - all lowercase
    with multiple `_` characters between words. In Python, this includes variables,
    functions, modules, packages, parameters, attributes of objects, methods of classes,
    and almost everything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script and module files** : These are really the OS resources, as seen by
    Python. Therefore, a filename should follow the conventions for Python objects,
    using letters, the `_` characters and ending with the `.py` extension. It''s technically
    possible to have pretty wild and free filenames. Filenames that don''t follow
    Python rules can be difficult to use as a module or package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we choose the broad category part of a name? The general category depends
    on whether we're talking about a thing or a property of a thing. While the world
    is full of things, we can create some board groupings that are helpful. Some of
    the examples are Document, Enterprise, Place, Program, Product, Process, Person,
    Asset, Rule, Condition, Plant, Animal, Mineral, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then narrow these with qualifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first example is a class called `Document` . We've narrowed it slightly
    by adding a prefix to call it a `StatusDocument` . We narrowed it even further
    by calling it a `FinalStatusDocument` . The second example is a `Name` that we
    narrowed by specifying that it's a `ReceivedInventoryItemName` . This example
    required a four-level name to clarify the class.
  prefs: []
  type: TYPE_NORMAL
- en: An object often has properties or attributes. These have a decomposition based
    in the kind of information that's being represented. Some examples of terms that
    should be part of a complete name are amount, code, identifier, name, text, date,
    time, datetime, picture, video, sound, graphic, value, rate, percent, measure,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to put the narrow, more detailed description first, and the broad
    kind of information last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, `height` narrows a more general representation term `value`
    . And `measured_height_value` further narrows this. Given this name, we can expect
    to see other variations on height. Similar thinking applies to `weight_value`
    , `delivery_date` and `location_code` . Each of these has a narrowing prefix or
    two.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Some things to avoid** :'
  prefs: []
  type: TYPE_NORMAL
- en: Don't include detailed technical type information using coded prefixes or suffixes.
    This is often called **Hungarian Notation** ; we don't use `f_measured_height_value`
    where the `f` is supposed to mean a floating-point. A variable like `measured_height_value`
    can be any numeric type and Python will do all the necessary conversions. The
    technical decoration doesn't offer much help to someone reading our code, because
    the type specification can be misleading or even incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Don't waste a lot of effort forcing names to look like they belong together.
    We don't need to make `SpadesCardSuit` , `ClubsCardSuit` , and so on. Python has
    many different kinds of namespaces, including packages, modules, and classes,
    as well as namespace objects to gather related names together. If you combine
    these names in a `CardSuit` class, you can use `CardSuit.Spades` , which uses
    the class as namespace to separate these names from other, similar names.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning names to objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python doesn''t use static variable definitions. A variable is created when
    a name is assigned to an object. It''s important to think of the objects as central
    to our processing, and variables as little more than sticky notes that identify
    an object. Here''s how we use the fundamental assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object. In many of the examples we'll create objects as literals.
    We'll use `355` or `113` as literal representations of integer objects in Python.
    We might use a string like `FireBrick` or a tuple like `(178, 34, 34)` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following kind of statement: *variable = object* . Here are some
    examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've created some objects and assigned them to variables. The first object
    is the result of a calculation. The next two objects are simple literals. Generally,
    objects are created by expressions that involve functions or classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This basic statement isn''t the only kind of assignment. We can assign a single
    object to multiple variables using a kind of duplicated assignment like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates two names for the same string object. We can confirm this by checking
    the internal ID values that Python uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This comparison shows us that the internal identifiers for these two objects
    are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A test for equality uses `==` . Simple assignment uses `=` .
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at numbers and collections, we''ll see that we can combine assignment
    with an operator. We can do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We've augmented assignment with an operator. `total_count += 5` is the same
    as `total_count = total_count + 5` . This technique has the advantage of being
    shorter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach to creating names follows the pattern of using narrow, more specific
    qualifiers first and the wider, less-specific category last. This follows the
    common convention used for domain names and e-mail addresses.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a domain name like `mail.google.com` has a specific service, a
    more general enterprise, and finally a very general domain. This follows the principle
    of narrow-to-wider.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, service@packtpub.com starts with a specific destination
    name, has a more general enterprise, and finally a very general domain. Even the
    name of destination ( *PacktPub* ) is a two-part name with a narrow enterprise
    name ( *Packt* ) followed by a wider industry ( *Pub* , short for *publishing*
    ). ( *We don't agree with those who suggest it stands for Public House.* )
  prefs: []
  type: TYPE_NORMAL
- en: The assignment statement is the only way to put a name on an object. We noted
    that we can have two names for the same underlying object. This isn't too useful
    right now. But in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* we'll see some
    interesting consequences of multiple names for a single object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll try to show descriptive names in all of the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have to grant exceptions to existing software which doesn't follow this pattern.
    It's often better to be consistent with legacy software than impose new rules
    even if the new rules are better.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every example will involve assignment to variables. It's central to stateful
    object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at classes and class names in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* ; we'll look at modules
    in [Chapter 13](text00137.html#page "Chapter 13. Application Integration") , *Application
    Integration* .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The subject of descriptive naming is a source of ongoing research and discussion.
    There are two aspects—syntax and semantics. The starting point for thoughts on
    Python syntax is the famous **Python Enhancement Proposal number 8** ( **PEP-8**
    ). This leads to use of `CamelCase` , and `snake_case` names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, be sure to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will provide more insight into Python ideals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For information on semantics, look at the legacy UDEF and NIEM Naming and Design
    Rules standards ([http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf](http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf)
    ). Additional details are in ISO11179 ([https://en.wikipedia.org/wiki/ISO/IEC_11179](https://en.wikipedia.org/wiki/ISO/IEC_11179)
    ), which talks in detail about meta-data and naming.
  prefs: []
  type: TYPE_NORMAL
- en: Working with large and small integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many programming languages make a distinction between integers, bytes, and long
    integers. Some languages include distinctions for *signed versus* *unsigned* integers.
    How do we map these concepts to Python?
  prefs: []
  type: TYPE_NORMAL
- en: The easy answer is that we don't. Python handles integers of all sizes in a
    uniform way. From bytes to immense numbers with hundreds of digits, it's all just
    integers to Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you need to calculate something really big. For example, calculate the
    number of ways to permute the cards in a 52-card deck. The number 52! = 52 × 51
    × 50 × ... × 2 × 1, is a very, very large number. Can we do this in Python?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don''t worry. Really. Python behaves as if it has one universal type of integer,
    and this covers all of the bases from bytes to numbers that fill all of the memory.
    Here are the steps to using integers properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the numbers you need. Here are some smallish numbers: 355, 113\. There’s
    no practical upper limit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating a very small value—a single byte—looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps this, if you want to use base 16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In later recipes, we''ll look at a sequence of bytes that has only a single
    value in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This isn't—technically—an integer. It has a prefix of `b'` that shows us it's
    a 1-byte sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a much, much bigger number with a calculation might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This number has 617 digits. We didn't show all of them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, Python uses two kinds of numbers. The conversion between these two
    is seamless and automatic.
  prefs: []
  type: TYPE_NORMAL
- en: For smallish numbers, Python will generally use 4 or 8 byte integer values.
    Details are buried in CPython's internals, and depend on the facilities of the
    C-compiler used to build Python.
  prefs: []
  type: TYPE_NORMAL
- en: For largish numbers, over `sys.maxsize` , Python switches to large integer numbers
    which are sequences of digits. Digit, in this case, often means a 30-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many ways can we permute a standard deck of 52 cards? The answer is 52!
    ≈ 8 × 10^(67) . Here''s how we can compute that large number. We''ll use the factorial
    function in the `math` module, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Yes, these giant numbers work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: The first parts of our calculation of 52! (from 52 × 51 × 50 × .. *.* down to
    about 42) could be performed entirely using the smallish integers. After that,
    the rest of the calculation had to switch to largish integers. We don't see the
    switch; we only see the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some of the details on the internals of integers, we can look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `sys.maxsize` value is the largest of the small integer values. We computed
    the log to base 2 to find out how many bits are required for this number.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that our Python uses 63-bit values for small integers. The range
    of smallish integers is from -2^(64) ... 2^(63) - 1\. Outside this range, largish
    integers are used.
  prefs: []
  type: TYPE_NORMAL
- en: The values in `sys.int_info` tells us that large integers are a sequence of
    numbers that use 30-bit digits, and each of these digits occupies 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: A large value like 52! consists of 8 of these 30-bit-sized digits. It can be
    a little confusing to think of a digit as requiring 30 bits to represent. Instead
    of 10 symbols used to represent base 10 numbers, we'd need *2**30* distinct symbols
    for each digit of these large numbers.
  prefs: []
  type: TYPE_NORMAL
- en: A calculation involving a number of big integer values can consume a fair bit
    of memory. What about small numbers? How can Python manage to keep track of lots
    of little numbers like one and zero?
  prefs: []
  type: TYPE_NORMAL
- en: 'For the commonly used numbers (-5 to 256) Python actually creates a secret
    pool of objects to optimize memory management. You can see this when you check
    the `id()` value for integer objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've shown the internal `id` for the integer `1` and the integer `2` . When
    we calculate a value, the resulting object turns out to be the same integer `2`
    object that was found in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: When you try this, your `id()` values may be different. However, every time
    the value of `2` is used, it will be the same object; on the author's laptop,
    it's id = `4297537984` . This saves having many, many copies of the 2 object cluttering
    up memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a little trick for seeing exactly how huge a number is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We created a string from a calculated number. Then we asked what the length
    of the string was. The response tells us that the number had 617 digits.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python offers us a broad set of arithmetic operators: `+` , `-` , `*` , `/`
    , `//` , `%` , and `**` . The `/` and `//` are for division; we''ll look at these
    in a separate recipe named *Choosing between true division and floor division*
    . The `**` raises a number to a power.'
  prefs: []
  type: TYPE_NORMAL
- en: For dealing with individual bits, we have some additional operations. We can
    use `&` , `^` , `|` , `<<` , and `>>` . These operators work bit-by-bit on the
    internal binary representations of integers. These compute a binary **AND** ,
    a binary **Exclusive OR** , I **nclusive OR** , **Left Shift** , and **Right Shift**
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: While these will work on very big integers, they don't really make much sense
    outside the world of individual bytes. Some binary files and network protocols
    will involve looking at the bits within an individual byte of data.
  prefs: []
  type: TYPE_NORMAL
- en: We can play around with these operators by using the `bin()` function to see
    what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example of what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've used `0b0011` and `0b0101` as our two strings of bits. This helps to clarify
    precisely what the two numbers have as their binary representation. We applied
    the exclusive or (`^` ) operator to these two sequences of bits. We used the `bin()`
    function to see the result as a string of bits. We can carefully line up the bits
    to see what the operator did.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decompose a byte into portions. Say we want to separate the left-most
    two bits from the other six bits. One way to do this is with bit-fiddling expressions
    like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a composite byte which has `01` in the most significant two bits,
    and `101100` in the least significant six bits. We used the `>>` shift operator
    to shift the value by six positions, removing the least significant bits and preserving
    the two most significant bits. We used the `&` operator with a mask. Where the
    mask has 1 bit, a position's value is preserved in the result, where a mask has
    `0` bits, the result position is set to `0` .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at the two division operators in the *Choosing between true division
    and floor division* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at other kinds of numbers in the *Choosing between float, decimal,
    and fraction* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on integer processing, see [https://www.python.org/dev/peps/pep-0237/](https://www.python.org/dev/peps/pep-0237/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between float, decimal, and fraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers us several ways to work with rational numbers and approximations
    of irrational numbers. We have three basic choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With so many choices, when do we use each of these?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to be sure about our core mathematical expectations. If we're
    not sure what kind of data we have, or what kinds of results we want to get, we
    really shouldn't be coding. We need to take a step back and review things with
    pencil and paper.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three general cases for math that involve numbers beyond integers,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currency** : Dollars, cents, or euros. Currency generally has a fixed number
    of decimal places. There are rounding rules used to determine what 7.25% of $2.95
    is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rational Numbers or Fractions** : When we''re working with American units
    for feet and inches, or cooking measurements in cups and fluid ounces, we often
    need to work in fractions. When we scale a recipe that serves eight, for example,
    down to five people, we''re doing fractional math using a scaling factor of 5/8
    . How do we apply this to 2/3 cup of rice and still get a measurement that fits
    an American kitchen gadget?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Irrational Numbers** : This includes all other kinds of calculations. It''s
    important to note that digital computers can only approximate these numbers, and
    we''ll occasionally see odd little artifacts of this approximation. The float
    approximations are very fast, but sometimes suffer from truncation issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we have one of the first two cases, we should avoid floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at each of the three cases separately. First, we'll look at computing
    with currency. Then we'll look at rational numbers, and finally irrational or
    floating-point numbers. Finally, we'll look at making explicit conversions among
    these various types.
  prefs: []
  type: TYPE_NORMAL
- en: Doing currency calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with currency, we should always use the `decimal` module. If we
    try to use Python's built-in `float` values, we'll have problems with rounding
    and truncation of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with currency, we''ll do this. Import the `Decimal` class from the
    `decimal` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Decimal` objects from strings or integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We created the `tax_rate` from two `Decimal` objects. One was based on a string,
    the other based on an integer. We could have used `Decimal('0.0725')` instead
    of doing the division explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a hair over $0.21\. It's computed out correctly to the full number
    of decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to create decimal objects from floating-point values, you''ll see
    unpleasant artifacts of float approximations. Avoid mixing `Decimal` and `float`
    . To round to the nearest penny, create a `penny` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Quantize your data using this penny object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This shows how we can use the default rounding rule of `ROUND_HALF_EVEN` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Every financial wizard has a different style of rounding. The `Decimal` module
    offers every variation. We might, for example, do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This shows the consequences of using a different rounding rule.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we''re doing calculations that have exact fraction values, we can use
    the `fractions` module. This provides us handy rational numbers that we can use.
    To work with fractions, we’ll do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Fraction` class from the `fractions` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Fraction` objects from strings, integers, or pairs of integers. If
    you create fraction objects from floating-point values, you may see unpleasant
    artifacts of float approximations. When the denominator is a power of 2, things
    can work out exactly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We created one fraction from a string, `2.5` . We created the second fraction
    from a floating-point calculation, `5/8` . Because the denominator is a power
    of 2, this works out exactly.
  prefs: []
  type: TYPE_NORMAL
- en: The result, 25/16, is a complex-looking fraction. What's a nearby fraction that
    might be simpler?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we'll use almost a cup and a half to scale the recipe for five
    people instead of eight.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point approximations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python's built-in `float` type is capable of representing a wide variety of
    values. The trade-off here is that float often involves an approximation. In some
    cases—specifically when doing division that involves powers of 2—it can be as
    exact as a `fraction` . In all other cases, there may be small discrepancies that
    reveal the differences between the implementation of `float` and the mathematical
    ideal of an irrational number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with `float` , we often need to round values to make them look sensible.
    Recognize that all calculations are an approximation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Mathematically, the value should be `1` . Because of the approximations used
    for `float` , the answer isn''t exact. It''s not wrong by much, but it''s wrong.
    When we round appropriately, the value is more useful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Know the error term. In this case, we know what the exact answer is supposed
    to be, so we can compare our calculation with the known correct answer. This gives
    us the general error value that can creep into floating-point numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For most floating-point errors, this is the typical value—about 10^(-16) . Python
    has clever rules that hide this error some of the time by doing some automatic
    rounding. For this calculation, however, the error wasn't hidden.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important consequence.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't compare floating-point values for exact equality.
  prefs: []
  type: TYPE_NORMAL
- en: When we see code that uses an exact `==` test between floating-point numbers,
    there are going to be problems when the approximations differ by a single bit.
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers from one type to another
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `float()` function to create a `float` value from another value.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we converted a `Decimal` value to `float` . In the second
    example, we converted a `Fraction` value to `float` .
  prefs: []
  type: TYPE_NORMAL
- en: 'As we just saw, we''re never happy trying to convert `float` to `Decimal` or
    `Fraction` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we did a calculation among integers to create a `float`
    value that has a known truncation problem. When we created a `Fraction` from that
    truncated `float` value, we got some terrible looking numbers that exposed the
    details of the truncation.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the second example tried to create a `Decimal` value from a `float`
    .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For these numeric types, Python offers us a variety of operators: `+` , `-`
    , `*` , `/` , `//` , `%` , and `**` . These are for addition, subtraction, multiplication,
    true division, truncated division, modulus, and raising to a power. We''ll look
    at the two division operators in the *Choosing between true division and floor
    division* recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Python is adept at converting numbers between the various types. We can mix
    `int` and `float` values; the integers will be promoted to floating-point to provide
    the most accurate answer possible. Similarly, we can mix `int` and `Fraction`
    and the results will be `Fractions` . We can also mix `int` and `Decimal` . We
    cannot casually mix `Decimal` with `float` or `Fraction` ; we need to provide
    explicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that `float` values are really approximations. The Python
    syntax allows us to write numbers as decimal values; that's not how they're processed
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a value like this in Python, using ordinary base-10 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The actual value used internally will involve a binary approximation of the
    decimal value we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal value for this example, `8.066e+67` , is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The numerator is a big number, `6737037547376141` . The denominator is always
    *2^(53)* . Since the denominator is fixed, the resulting fraction can only have
    53 meaningful bits of data. Since more bits aren't available, values might get
    truncated. This leads to tiny discrepancies between our idealized abstraction
    and actual numbers. The exponent ( *2^(226)* ) is required to scale the fraction
    up to the proper range.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, 6737037547376141 * 2^(226) /2^(53) .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `math.frexp()` to see these internal details of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The two parts are called the **mantissa** and the **exponent** . If we multiply
    the mantissa by *2^(53)* , we always get a whole number, which is the numerator
    of the binary fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The error we noticed earlier matches this quite nicely: 10^(-16) ≈ 2^(-53)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the built-in `float` , a `Fraction` is an exact ratio of two integer
    values. As we saw in the *Working with large and small integers* recipe, integers
    in Python can be very large. We can create ratios which involve integers with
    a large number of digits. We're not limited by a fixed denominator.
  prefs: []
  type: TYPE_NORMAL
- en: A `Decimal` value, similarly, is based on a very large integer value, and a
    scaling factor to determine where the decimal place goes. These numbers can be
    huge and won't suffer from peculiar representation issues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why use floating-point? Two reasons** :'
  prefs: []
  type: TYPE_NORMAL
- en: Not all computable numbers can be represented as fractions. That's why mathematicians
    introduced (or perhaps discovered) irrational numbers. The built-in float type
    is as close as we can get to the mathematical abstraction of irrational numbers.
    A value like √2, for example, can't be represented as a fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Also, float values are very fast.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python `math` module contains a number of specialized functions for working
    with floating-point values. This module includes common functions such as square
    root, logarithms, and various trigonometry functions. It has some other functions
    such as gamma, factorial, and the Gaussian error function.
  prefs: []
  type: TYPE_NORMAL
- en: The `math` module includes several functions that can help us do more accurate
    floating-point calculations. For example, the `math.fsum()` function will compute
    a floating-point sum more carefully than the built-in `sum()` function. It's less
    susceptible to approximation issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make use of the `math.isclose()` function to compare two floating-point
    values to see if they''re nearly equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function provides us with a way to compare floating-point numbers meaningfully.
  prefs: []
  type: TYPE_NORMAL
- en: Python also offers complex data. This involves a real and an imaginary part.
    In Python, we write `3.14+2.78j` to represent the complex number 3.14 + 2.78 √-1\.
    Python will comfortably convert between float and complex. We have the usual group
    of operators available for complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support complex numbers, there''s a `cmath` package. The `cmath.sqrt()`
    function, for example, will return a complex value rather than raise an exception
    when extracting the square root of a negative number. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is essential when working with complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll talk more about floating point and fractions in the *Choosing between
    true division and floor division* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between true division and floor division
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers us two kinds of division operators. What are they, and how do
    we know which one to use? We'll also look at the Python division rules and how
    they apply to integer values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several general cases for doing division:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *div-mod* pair: We want two parts—the quotient and the remainder. We often
    use this when converting values from one base to another. When we convert seconds
    to hours, minutes, and seconds, we''ll be doing a *div-mod* kind of division.
    We don''t want the exact number of hours, we want a truncated number of hours,
    the remainder will be converted to minutes and seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *true* value: This is a typical floating-point value—it will be a good
    approximation to the quotient. For example, if we''re computing an average of
    several measurements, we usually expect the result to be floating-point, even
    if the input values are all integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *rational fraction* value: This is often necessary when working in American
    units of feet, inches, and cups. For this, we should be using the `Fraction` class.
    When we divide `Fraction` objects, we always get exact answers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to decide which of these cases apply, so we know which division operator
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at the three cases separately. First we'll look at truncated floor
    division. Then we'll look at true floating-point division. Finally, we'll look
    at division of fractions.
  prefs: []
  type: TYPE_NORMAL
- en: Doing floor division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are doing the *div-mod* kind of calculations, we might use floor division,
    `//` , and modulus, `%` . Or, we might use the `divmod()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll divide the number of seconds by 3600 to get the value of `hours` ; the
    modulus, or remainder, can be converted separately to `minutes` and `seconds`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, using remaining values, we''ll divide the number of seconds by 60 to
    get `minutes` ; the remainder is a number of seconds less than 60:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the alternative, using the `divmod()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute quotient and remainder at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute quotient and remainder again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Doing true division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A true value calculation gives as a floating-point approximation. For example,
    about how many hours is 7386 seconds? Divide using the true division operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We provided two integer values, but got a floating-point exact result. Consistent
    with our previous recipe for using floating-point values, we rounded the result
    to avoid having to look at tiny error values.
  prefs: []
  type: TYPE_NORMAL
- en: This true division is a feature of Python 3\. We'll look at this from a Python
    2 perspective in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Rational fraction calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can do division using `Fraction` objects and integers. This forces the result
    to be a mathematically exact rational number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create at least one `Fraction` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `Fraction` value in a calculation. Any integer will be promoted to
    a `Fraction` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If necessary, convert the exact fraction to a floating-point approximation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a `Fraction` object for the total number of seconds. When
    we do arithmetic on fractions, Python will promote any integers to be fractions;
    this promotion means that the math is done as exactly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python 3 has two division operators.
  prefs: []
  type: TYPE_NORMAL
- en: The `/` true division operator always tries to produce a true, floating-point
    result. It does this even when the two operands are integers. This is an unusual
    operator in this respect. All other operators try to preserve the type of the
    data. The true division operation - when applied to integers - produces a `float`
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `//` truncated division operator always tries to produce a truncated result.
    For two integer operands, this is the truncated quotient. For two floating-point
    operands, this is a truncated floating-point result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Python 2 only has one division operator. For programmers still
    using Python 2, we can start using these new division operators with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This import will install the Python 3 division rules.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more on the choice between floating-point and fractions, see the *Choosing
    between float, decimal, and fraction* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://www.python.org/dev/peps/pep-0238/](https://www.python.org/dev/peps/pep-0238/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting an immutable string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we rewrite an immutable string? We can''t change individual characters
    inside a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Since this doesn't work, how do we make a change to a string?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume we have a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d like to do two transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the part before the `:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the punctuation with `_` , and make all the characters lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we can''t replace characters in a string object, we have to work out
    some alternatives. There are several common things we can do, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A combination of slicing and concatenating a string to create a new string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When shortening, we often use the `partition()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can replace a character or a substring with the `replace()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can expand the string into a list of characters, then join the string back
    into a single string again. This is the subject for a separate recipe, *Building
    complex strings with a list of characters* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we can''t update a string in place, we have to replace the string variable''s
    object with each modified result. We''ll use a statement that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could even use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at a number of specific variations on this general theme. We'll slice
    a piece of a string, we'll replace individual characters within a string, and
    we'll apply blanket transformations such as making the string lowercase. We'll
    also look at ways to remove extra `_` that show up in our final string.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing a piece of a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s how we can shorten a string via slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the boundary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The index function locates a particular substring and returns the position where
    that substring can be found. If the substring doesn't exist, it raises an exception.
    This is always `true` of the result `title[colon_position] == ':'` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick the substring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We've used the slicing notation to show the `start:end` of the characters to
    pick. We also used multiple assignment to assign two variables, `discard_text`
    and `post_colon_text` , from two expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `partition()` as well as manual slicing. Find the boundary and partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `partition` function returns three things: the part before the target,
    the target, and the part after the target. We used multiple assignment to assign
    each object to a different variable. We assigned the target to a variable named
    `_` because we''re going to ignore that part of the result. This is a common idiom
    for places where we must provide a variable, but we don''t care about using the
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating a string with a replacement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use `replace()` to remove punctuation marks. When using `replace` to
    switch punctuation marks, save the results back into the original variable. In
    this case, `post_colon_text` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This has replaced the two kinds of punctuation with the desired `_` characters.
    We can generalize this to work with all punctuation. This leverages the `for`
    statement, which we'll look at in [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can iterate through all punctuation characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As each kind of punctuation character is replaced, we assign the latest and
    greatest version of the string to the `post_colon_text` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Making a string all lowercase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another transformational step is changing a string to all lowercase. As with
    the previous examples, we''ll assign the results back to the original variable.
    Use the `lower()` method, assigning the result to the original variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Removing extra punctuation marks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many cases, there are some additional steps we might follow. We often want
    to remove leading and trailing `_` characters. We can use `strip()` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, we''ll have multiple `_` characters because we had multiple
    punctuation marks. The final step would be something like this to cleanup up multiple
    `_` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is yet another example of the same pattern we've been using to modify a
    string in place. This depends on the `while` statement, which we'll look at in
    [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements
    and Syntax* .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can't—technically—modify a string in place. The data structure for a string
    is immutable. However, we can assign a new string back to the original variable.
    This technique behaves the same as modifying a string in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a variable''s value is replaced, the previous value no longer has any
    references and is garbage collected. We can see this by using the `id()` function
    to track each individual string object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Your actual id numbers may be different. What's important is that the original
    string object assigned to `post_colon_text` had one id. The new string object
    assigned to `post_colon_text` has a different id. It's a new string object.
  prefs: []
  type: TYPE_NORMAL
- en: When the old string has no more references, it is removed from memory automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We made use of **slice notation** to decompose a string. A slice has two parts:
    `[start:end]` . A slice always includes the starting index. String indices always
    start with zero as the first item. It never includes the ending index.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The items in a slice have an index from `start` to `end-1` . This is sometimes
    called a **half-open** interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a slice like this: all characters where the index, *i* , are in the
    range *start ≤ i* < *end* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We noted briefly that we can omit the start or end indices. We can actually
    omit both. Here are the various options available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title[colon_position]` : A single item, the `:` we found using `title.index('':'')`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[:colon_position]` : A slice with the start omitted. It begins at the
    first position, index of zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[colon_position+1:]` : A slice with the end omitted. It ends at the end
    of the string, as if we said `len(title)` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[:]` : Since both start and end are omitted, this is the entire string.
    Actually, it''s a *copy* of the entire string. This is the quick and easy way
    to duplicate a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more features to indexing in Python collections like a string. The
    normal indices start with 0 at the left end. We have an alternate set of indices
    using negative names that work from the right end of a string.
  prefs: []
  type: TYPE_NORMAL
- en: '`title[-1]` is the last character in the title, `g`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[-2]` is the next-to-last character, `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title[-6:]` is the last six characters, `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a lot of ways to pick pieces and parts out of a string.
  prefs: []
  type: TYPE_NORMAL
- en: Python offers dozens of methods for modifying a string. *Section 4.7* of the
    *Python Standard Library* describes the different kinds of transformations that
    are available to us. There are three broad categories of string methods. We can
    ask about a string, we can parse a string, and we can transform a string. Methods
    such as `isnumeric()` tell us if a string is all digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We've looked at parsing with the `partition()` method. And we've looked at transforming
    with the `lower()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at the string as list technique for modifying a string in the *Building
    complex strings from lists of characters* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes we have data that's only a stream of bytes. In order to make sense
    of it, we need to convert it into characters. That's the subject for the *Decoding
    bytes – how to get proper characters from some bytes* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String parsing with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we decompose a complex string? What if we have complex, tricky punctuation?
    Or—worse yet—what if we don't have punctuation, but have to rely on patterns of
    digits to locate meaningful information?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to decompose a complex string is by generalizing the string
    into a pattern and then writing a regular expression that describes that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There are limits to the patterns that regular expressions can describe. When
    we're confronted with deeply-nested documents in a language like HTML, XML, or
    JSON, we often run into problems, and can't use regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The `re` module contains all of the various classes and functions we need to
    create and use regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to decompose text from a recipe website. Each line
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We want to separate the ingredient from the measurements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write and use regular expressions, we often do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generalize the example. In our case, we have something that we can generalize
    as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve replaced literal text with a two-part summary: what it means and how
    it''s represented. For example, ingredient is represented as words, amount is
    represented as digits. Import the `re` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Rewrite the pattern into **Regular Expression** ( **RE** ) notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We've replaced representation hints such as *words* with `\w+` . We've replaced
    *digits* with `\d+` . And we've replaced *single spaces* with `\s+` to allow one
    or more spaces to be used as punctuation. We've left the colon in place, because
    in the regular expression notation, a colon matches itself.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the fields of data, we've used `?P<name>` to provide a name that
    identifies the data we want to extract. We didn't do this around the colon or
    the spaces because we don't want those characters.
  prefs: []
  type: TYPE_NORMAL
- en: REs use a lot of `\` characters. To make this work out nicely in Python, we
    almost always use *raw* strings. The `r'` prefix tells Python not to look at the
    `\` characters and not to replace them with special characters that aren't on
    our keyboards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Match the pattern against input text. If the input matches the pattern, we''ll
    get a match object that shows details of the matching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This, by itself, is pretty cool: we have a tuple of the different fields within
    the string. We''ll return to the use of tuples in a recipe named *Using tuples*
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the named groups of characters from the match object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Each group is identified by the name we used in the `(?P<name>...)` part of
    the RE.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of different kinds of string patterns that we can describe with
    RE.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shown a number of character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\w` matches any alphanumeric character (a to z, A to Z, 0 to 9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d` matches any decimal digit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches any space or tab character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These classes also have inverses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\W` matches any character that''s not a letter or a digit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\D` matches any character that''s not a digit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S` matches any character that''s not some kind of space or tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many characters match themselves. Some characters, however, have special meaning,
    and we have to use `\` to escape from that special meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: We saw that `+` as a suffix means to match one or more of the preceeding patterns.
    `\d+` matches one or more digits. To match an ordinary `+` , we need to use `\+`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have `*` as a suffix which matches zero or more of the preceding patterns.
    `\w*` matches zero or more characters. To match a `*` , we need to use `\*` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have `?` as a suffix which matches zero or one of the preceding expressions.
    This character is used in other places, and has a slightly different meaning.
    We saw it in `(?P<name>...)` where it was inside the `()` to define special properties
    for the grouping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.` matches any single character. To match a `.` specifically, we need to
    use `\` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create our own unique sets of characters using `[]` to enclose the elements
    of the set. We might have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This has a `\w+` to match any number of alphanumeric characters. This will be
    collected into a group with the name of `name` .
  prefs: []
  type: TYPE_NORMAL
- en: It uses `\s*` to match an optional sequence of spaces.
  prefs: []
  type: TYPE_NORMAL
- en: It matches any character in the set `[=:]` . One of the two characters in this
    set must be present.
  prefs: []
  type: TYPE_NORMAL
- en: It uses `\s*` again to match an optional sequence of spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it uses `.*` to match everything else in the string. This is collected
    into a group named `value` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this to parse strings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: By being flexible with the punctuation, we can make a program easier to use.
    We'll tolerate any number of spaces, and either an `=` or a `:` as a separator.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A long regular expression can be awkward to read. We have a clever Pythonic
    trick for presenting an expression in a way that''s much easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This leverages three syntax rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement isn't finished until the `()` characters match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjacent string literals are silently concatenated into a single long string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything between `#` and the end of the line is a comment, and is ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've put Python comments after the important clauses in our regular expression.
    This can help us understand what we did, and perhaps help us diagnose problems
    later.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Decoding Bytes - How to get proper characters from some bytes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many books on Regular Expressions and Python Regular Expressions in
    particular like *Mastering Python Regular Expressions* ([https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building complex strings with "template".format()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating complex strings is, in many ways, the polar opposite of parsing a complex
    string. We generally find that we'll use a template with substitution rules to
    put data into a more complex format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have pieces of data that we need to turn into a nicely formatted
    message. We might have data including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''d like a line that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a template string from the result, replacing all of the data items with
    `{}` placeholders. Inside each placeholder, put the name of the data item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For each data item, append `:data type` information to the placeholders in
    the template string. The basic data type codes are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`s` for string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` for decimal number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` for floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Add length information where required. Length is not always required, and in
    some cases, it''s not even desirable. In this example, though, the length information
    assures that each message has a consistent format. For strings and decimal numbers,
    prefix the format with the length like this: `19s` or `3d` . For floating-point
    numbers use a two part prefix like this: `5.2f` to specify the total length of
    five characters with two to the right of the decimal point. Here''s the whole
    format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `format()` method of this string to create the final string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve provided all of the variables by name in the `format()` method of the
    template string. This can get tedious. In some cases, we might want to build a
    dictionary object with the variables. In that case, we can use the `format_map()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We'll return to dictionaries in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Build-in Data Structures – list, set, dict*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `vars()` function builds a dictionary of all of the local variables
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `vars()` function is very handy for building a dictionary automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The string `format()` and `format_map()` methods can do a lot of relatively
    sophisticated string assembly for us.
  prefs: []
  type: TYPE_NORMAL
- en: The basic feature is to interpolate data into a string based on names of keyword
    arguments or keys in a dictionary. Variables can also be interpolated by position—we
    can provide position numbers instead of names. We can use a format specification
    like `{0:3s}` to use the first positional argument to `format()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen three of the formatting conversions—`s` , `d` , `f` —there are
    many others. Details are in *Section 6.1.3* of the *Python Standard Library* .
    Here are some of the format conversions we might use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b` is for binary, base 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` is for Unicode character. The value must be a number, which is converted
    to a character. Often, we use hexadecimal numbers for this so you might want to
    try values such as `0x2661` through `0x2666` for fun.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` is for decimal numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E` and `e` are for scientific notations. `6.626E-34` or `6.626e-34` depending
    on which E or e character is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F` and `f` are for floating-point. For *not a number* the `f` format shows
    lowercase `nan` ; the `F` format shows uppercase `NAN` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G` and `g` are for general. This switches automatically between `E` and `F`
    (or `e` and `f` ,) to keep the output in the given sized field. For a format of
    `20.5G` , up to 20-digit numbers will be displayed using `F` formatting. Larger
    numbers will use `E` formatting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` is for locale-specific decimal numbers. This will insert `,` or `.` characters
    depending on the current locale settings. The default locale may not have a thousand
    separators defined. For more information, see the `locale` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o` is for octal, base 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` is for string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` and `x` is for hexadecimal, base 16\. The digits include uppercase `A-F`
    and lowercase `a-f` , depending on which `X` or `x` format character is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` is for percentage. The number is multiplied by 100 and includes the `%`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a number of prefixes we can use for these different types. The most
    common one is the length. We might use `{name:5d}` to put in a 5-digit number.
    There are several prefixes for the preceding types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fill and alignment** : We can specify a specific filler character (space
    is the default) and an alignment. Numbers are generally aligned to the right and
    strings to the left. We can change that using `<` , `>` , or `^` . This forces
    left alignment, right alignment, or centering. There''s a peculiar `=` alignment
    that''s used to put padding after a leading sign.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign** : The default rule is a leading negative sign where needed. We can
    use `+` to put a sign on all numbers, `-` to put a sign only on negative numbers,
    and a space to use a space instead of a plus for positive numbers. In scientific
    output, we must use `{value: 5.3f}` . The space makes sure that room is left for
    the sign, assuring that all the decimal points line up nicely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alternate form** : We can use the `#` to get an alternate form. We might
    have something like `{0:#x}` , `{0:#o}` , `{0:#b}` to get a prefix on hexadecimal,
    octal, or binary values. With a prefix, the numbers will look like `0xnnn` , `0onnn`
    , or `0bnnn` . The default is to omit the two character prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leading zero** : We can include `0` to get leading zeros to fill in the front
    of a number. Something like `{code:08x` ) will produce a hexadecimal value with
    leading zeroes to pad it out to eight characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Width and precision** : For integer values and strings, we only provide the
    width. For floating-point values we often provide `width.precision` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some times when we won't use a `{name:format}` specification. Sometimes
    we'll need to use a `{name!conversion}` specification. There are only three conversions
    available.
  prefs: []
  type: TYPE_NORMAL
- en: '`{name!r}` shows the representation that would be produced by `repr(name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{name!s}` shows the string value that would be produced by `str(name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{name!a}` shows the ASCII value that would be produced by `ascii(name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we'll leverage the idea of the `{name!r}`
    format specification to simplify displaying information about related objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A handy debugging hack this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `vars()` function—with no arguments—collects all of the local variables
    into a mapping. We provide that mapping for `format_map()` . The format template
    can use lots of `{variable_name!r}` to display details about various objects we
    have in local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a class definition we can use techniques such as `vars(self)` . This
    looks forward to [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes
    and Objects") , *Basics of Classes and Objects* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Our class definition includes a `__str__()` method. This method relies on `vars(self)`
    to create a useful dictionary of just the attribute of the object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Python Standard Library* , *Section 6.1.3* has all of the details on the
    format method of a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building complex strings from lists of characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make very complex changes to an immutable string? Can we assemble
    a string from individual characters?
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the recipes we've already seen give us a number of tools for
    creating and modifying strings. There are yet more ways in which we can tackle
    the string manipulation problem. We'll look at using a list object. This will
    dovetail with some of the recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a string that we''d like to rearrange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d like to do two transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the part before the `:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the punctuation with `_` , and make all the characters lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll make use of the `string` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This has two important constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string.whitespace` lists all of the common whitespace characters, including
    space and tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string.punctuation` lists the common ASCII punctuation marks. Unicode has
    a larger list of punctuation marks; that''s also available based on your locale
    settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can work with a string exploded into a list. We'll look at lists in more
    depth in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Explode the string into a `list` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the partition character. The `index()` method for a list has the same
    semantics as the `index()` method for a list. It locates the position with the
    given value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the characters no longer needed. The `del` statement can remove items
    from a list. Lists are a mutable data structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to carefully work with the useful piece of the original string.
    We can remove items from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace punctuation by stepping through each position. In this case, we''ll
    use a `for` statement to visit every index in the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `range(len(title_list))` generates all of the values between
    `0` and `len(title_list)-1` . This assures us that the value of position will
    be each value index in the list. Join the list of characters to create a new string.
    It seems a little odd to use zero-length string, `''''` , as a separator when
    concatenating strings together. However, it works perfectly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We assigned the resulting string back to the original variable. The original
    string object, which had been referred to by that variable, is no longer needed:
    it''s removed from memory. The new string object replaces the value of the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a change in representation trick. Since a string is immutable, we can't
    update it. We can, however, convert it into a mutable form; in this case, a list.
    We can do whatever changes are required to the mutable list object. When we're
    done, we can change the representation from a list back to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Strings provide a number of features that lists don't. Conversely, strings provide
    a number of features a list doesn't have. We can't convert a list to lowercase
    the way we can convert a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important trade-off here:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are immutable, that makes them very fast. Strings are focused on Unicode
    characters. When we look at mappings and sets, we can use strings as keys for
    mappings and items in sets because the value is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are mutable. Operations are slower. Lists can hold any kind of item. We
    can't use a list as a key for a mapping or an item in a set because the value
    could change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings and lists are both specialized kinds of sequences. Consequently, they
    have a number of common features. The basic item indexing and slicing features
    are shared. Similarly a list uses the same kind of negative index values that
    a string does: `list[-1]` is the last item in a list object.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to mutable data structures in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've started working with a list of characters instead of a string, we
    no longer have the string processing methods. We do have a number of list-processing
    techniques available to us. In addition to being able to delete items from a list,
    we can append an item, extend a list with another list, and insert a character
    into the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change our viewpoint slightly, and look at a list of strings instead
    of a list of characters. The technique of doing `''''.join(list)` will work when
    we have a list of strings as well as a list of characters. For example, we might
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Our `title_list` object will be mutated into a list that contains a six-character
    string, prefix, plus 30 individual characters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also work with strings using the internal methods of a string. See the
    *Rewriting an immutable string* recipe for more techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we need to build a string, and then convert it into bytes. See the
    *Encoding strings – creating ASCII and UTF-8 bytes* recipe for how we can do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other times, we'll need to convert bytes into a string. See the *Decoding Bytes
    - How to get proper characters from some bytes* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Unicode characters that aren't on our keyboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big keyboard might have almost 100 individual keys. Fewer than 50 of these
    are letters, numbers and punctuation. At least a dozen are *function* keys that
    do things other than simply *insert* letters into a document. Some of the keys
    are different kinds of *modifiers* that are meant to be used in conjunction with
    another key—we might have *Shift* , *Ctrl* , Option, and *Command* .
  prefs: []
  type: TYPE_NORMAL
- en: Most operating systems will accept simple key combinations that create about
    100 or so characters. More elaborate key combinations may create another 100 or
    so less popular characters. This isn't even close to covering the million characters
    from the world's alphabets. And there are icons, emoticons, and dingbats galore
    in our computer fonts. How do we get to all of those glyphs?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python works in Unicode. There are millions of individual Unicode characters
    available.
  prefs: []
  type: TYPE_NORMAL
- en: We can see all the available characters at [https://en.wikipedia.org/wiki/List_of_Unicode_characters
    and also http://www.unicode.org/charts/](https://en.wikipedia.org/wiki/List_of_Unicode_characters%20and%20also%20http://www.unicode.org/charts/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We'll need the Unicode character number. We might also want the Unicode character
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A given font on our computer may not be designed to provide glyphs for all
    of those characters. In particular, Windows computer fonts may have trouble displaying
    some of these characters. Using the Windows command to change to code page 65001
    is sometimes necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Linux and Mac OS X rarely have problems with Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python uses **escape sequences** to extend the ordinary characters we can type
    to cover the vast space of Unicode characters. The escape sequences start with
    a `\` character. The next character tells exactly how the Unicode character will
    be represented. Locate the character that''s needed. Get the name or the number.
    The numbers are always given as hexadecimal, base 16\. They''re often written
    as `U+2680` . The name might be `DIE FACE-1` . Use `\unnnn` with up to a four-digit
    number. Or use `\N{name}` with the spelled-out name. If the number is more than
    four digits, use `\Unnnnnnnn` with the number padded out to eight digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes, we can include a wide variety of characters in Python output. To place
    a `\` character in the string, we need to use `\\` . For example, we might need
    this for Windows filenames.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses Unicode internally. The 128 or so characters we can type directly
    using the keyboard all have handy internal Unicode numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Python treats it as shorthand for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Once we get beyond the characters on our keyboards, the remaining millions of
    characters are identified only by their number.
  prefs: []
  type: TYPE_NORMAL
- en: When the string is being compiled by Python, the `\uxx` , `\Uxxxxxxxx` , and
    `\N{name}` are all replaced by the proper Unicode character. If we have something
    syntactically wrong—for example, `\N{name` with no closing `}` —we'll get an immediate
    error from Python's internal syntax checking.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the *String parsing with regular expressions* recipe, we noted that
    regular expressions use a lot of `\` characters and we specifically do not want
    Python's normal compiler to touch them; we used the `r'` prefix on a regular expression
    string to prevent the `\` from being treated as an escape and possibly converted
    to something else.
  prefs: []
  type: TYPE_NORMAL
- en: What if we need to use Unicode in a Regular Expression? We'll need to use `\\`
    all over the place in the Regular Expression. We might see this `'\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+'`
    . We skipped the `r'` prefix on the string. We doubled up the `\` used for Regular
    Expressions. We used `\uxxxx` for the Unicode characters that are part of the
    pattern. Python's internal compiler will replace the `\uxxxx` with Unicode characters
    and the `\\` with a single `\` internally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we look at a string at the `>>>` prompt, Python will display the string
    in its canonical form. Python prefers to use the `''` as a delimiter even though
    we can use either `''` or `"` for a string delimiter. Python doesn''t generally
    display raw strings, instead it puts all of the necessary escape sequences back
    into the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> r"\w+"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`''\\w+''`'
  prefs: []
  type: TYPE_NORMAL
- en: We provided a string in raw form. Python displayed it in canonical form.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Encoding strings – creating ASCII and UTF-8 bytes* and the *Decoding
    Bytes - How to get proper characters from some bytes* recipes we'll look at how
    Unicode characters are converted to sequences of bytes so we can write them to
    a file. We'll look at how bytes from a file (or downloaded from a website) are
    turned into Unicode characters so they can be processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're interested in history, you can read up on ASCII and EBCDIC and other
    old-fashioned character codes here [http://www.unicode.org/charts/](http://www.unicode.org/charts/)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding strings – creating ASCII and UTF-8 bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our computer files are bytes. When we upload or download from the Internet,
    the communication works in bytes. A byte only has 256 distinct values. Our Python
    characters are Unicode. There are a lot more than 256 Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: How do we map Unicode characters to bytes for writing to a file or transmitting?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, a character occupied 1 byte. Python leverages the old ASCII encoding
    scheme for bytes; this sometimes leads to confusion between bytes and proper strings
    of Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters are encoded into sequences of bytes. We have a number of
    standardized encodings and a number of non-standard encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, we also have some encodings that only work for a small subset of Unicode
    characters. We try to avoid this, but there are some situations where we'll need
    to use a subset encoding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Unless we have a really good reason, we almost always use the UTF-8 encoding
    for Unicode characters. Its main advantage is that it's a compact representation
    for the Latin alphabet used for English and a number of European languages.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, an Internet protocol requires ASCII characters. This is a special
    case that requires some care because the ASCII encoding can only handle a small
    subset of Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python will generally use our OS''s default encoding for files and Internet
    traffic. The details are unique to each OS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a general setting using the `PYTHONIOENCODING` environment variable.
    We set this outside of Python to assure that a particular encoding is used everywhere.
    Set the environment variable as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Run Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We sometimes need to make specific settings when we open a file inside our
    script. We''ll return this in [Chapter 9](text00099.html#page "Chapter 9. Input/Output,
    Physical Format, and Logical Layout") , *Input/Output, Physical Format, Logical
    Layout* . Open the file with a given encoding. Read or write Unicode characters
    to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also manually encode characters, in the rare case that we need to open
    a file in bytes mode; if we use a mode of `wb` , we''ll need to use manual encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a sequence of bytes (`\xf0\x9f\x80\x80` ) was used to encode
    a single Unicode character, `U+1F000` , ![How to do it...](Image00002.jpg)  .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unicode defines a number of encoding schemes. While UTF-8 is the most popular,
    there are also UTF-16 and UTF-32\. The number is the typical number of bits per
    character. A file with 1000 characters encoded in UTF-32 would be 4000 8-bit bytes.
    A file with 1000 characters encoded in UTF-8 could be as few as 1000 bytes, depending
    on the exact mix of characters. In the UTF-8 encoding, characters with Unicode
    numbers above `U+007F` require multiple bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Various OS's have their own coding schemes. Mac OS X files are often encoded
    in `Mac Roman` or `Latin-1` . Windows files might use `CP1252` encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The point with all of these schemes is to have a sequence of bytes that can
    be mapped to a Unicode character. And—going the other way—a way to map each Unicode
    character to one or more bytes. Ideally, all of the Unicode characters are accounted
    for. Pragmatically, some of these coding schemes are incomplete. The tricky part
    is to avoid writing any more bytes than is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The historical `ASCII` encoding can only represent about 250 of the Unicode
    characters as bytes. It's easy to create a string which cannot be encoded using
    the ASCII scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the error looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We may see this kind of error when we accidentally open a file with a poorly
    chosen encoding. When we see this, we'll need to change our processing to select
    a more useful encoding; ideally, UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bytes vs Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: Bytes are often displayed using printable characters.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see `b'hello'` as a short-hand for a five-byte value. The letters are
    chosen using the old ASCII encoding scheme. Many byte values from about `0x20`
    to `0xFE` will be shown as characters.
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing. The prefix of `b'` is our hint that we're looking at
    bytes, not proper Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to build strings of data. See the *Building complex
    strings with "template".format()* and the *Building complex strings from lists
    of characters* recipes for examples of creating complex strings. The idea is that
    we might have an application that builds a complex string, and then we encode
    it into bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the UTF-8 encoding, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For general information on Unicode encodings, see [http://unicode.org/faq/utf_bom.html](https://en.wikipedia.org/wiki/UTF-8)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding bytes – how to get proper characters from some bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we work with files that aren't properly encoded? What do we do with
    files written in the ASCII encoding?
  prefs: []
  type: TYPE_NORMAL
- en: A download from the Internet is almost always in bytes—not characters. How do
    we decode the characters from that stream of bytes?
  prefs: []
  type: TYPE_NORMAL
- en: Also, when we use the `subprocess` module, the results of an OS command are
    in bytes. How can we recover proper characters?
  prefs: []
  type: TYPE_NORMAL
- en: Much of this is also relevant to the material in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout* . We've included the recipe here because it's
    the inverse of the previous recipe, *Encoding strings – creating ASCII and UTF-8
    bytes* .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we're interested in offshore marine weather forecasts. Perhaps because
    we own a large sailboat. Or perhaps because good friends of ours have a large
    sailboat and are departing the **Chesapeake Bay** for the **Caribbean** .
  prefs: []
  type: TYPE_NORMAL
- en: Are there any special warnings coming from the **National Weather Services**
    office in Wakefield, Virginia?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s where we can get the warnings: [http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ](http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can download this with Python''s `urllib` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use programs like `curl` or `wget` to get this. We might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Since `curl` left us with an awkward file name, we needed to rename the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `forecast_text` value is a stream of bytes. It''s not a proper string.
    We can tell because it starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: And goes on for a while providing details. Because it starts with `b'` , it's
    bytes, not proper Unicode characters. It was probably encoded with UTF-8, which
    means some characters could have weird-looking `\xnn` escape sequences instead
    of proper characters. We want to have the proper characters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bytes vs Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: Bytes are often displayed using printable characters.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see `b'hello'` as a short-hand for a five-byte value. The letters are
    chosen using the old ASCII encoding scheme. Many byte values from about `0x20`
    to `0xFE` will be shown as characters.
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing. The prefix of `b'` is our hint that we're looking at
    bytes, not proper Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, bytes behave somewhat like strings. Sometimes we can work with bytes
    directly. Most of the time, we'll want to decode the bytes and create proper Unicode
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it..
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.Determine the coding scheme if possible. In order to decode bytes to create
    proper Unicode characters, we need to know what encoding scheme was used. When
    we read XML documents, there''s a big hint provided within the document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'When browsing web pages, there''s often a header with this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes an HTML page may include this as part of the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In other cases, we're left to guess. In the case of US Weather data, a good
    first guess is UTF-8\. Other good guesses include ISO-8859-1\. In some cases,
    the guess will depend on the language.
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 7.2.3* , *Python Standard Library* lists the standard encodings available.
    Decode the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `b'` prefix is gone. We've created a proper string of Unicode characters
    from the stream of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: If this step fails with an exception, we guessed wrong about the encoding. We
    need to try another encoding. Parse the resulting document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is an HTML document, we should use **Beautiful Soup** . See [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, extract one nugget of information from this document without
    completely parsing the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us what we need to know: there are no warnings at this time. That
    doesn''t mean smooth sailing, but it does mean that there aren''t any major weather
    systems that can cause catastrophes.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Encoding strings – creating ASCII and UTF-8 bytes* recipe for more
    information on Unicode and the different ways that Unicode characters can be encoded
    into streams of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: At the foundation of the operating system, files and network connections are
    built up from bytes. It's our software that decodes the bytes to discover the
    content. It might be characters, or images, or sounds. In some cases, the default
    assumptions are wrong and we need to do our own decoding.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've recovered the string data, we have a number of ways of parsing or
    rewriting it. See the *String parsing with regular expressions* recipe for examples
    of parsing a complex string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on encodings, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    and [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tuples of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the best way to represent simple ( *x* , *y* ) and ( *r* , *g* , *b*
    ) groups of values? How can we keep things which are pairs such as latitude and
    longitude together?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *String parsing with regular expressions* recipe, we skipped over an
    interesting data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had data that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We parsed this into the meaningful data using a regular expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The result is a tuple object with three pieces of data. There are lots of places
    where this kind of grouped data come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at two aspects to this: putting things into tuples and getting
    things out of tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of places where Python creates tuples of data for us. In the
    *Getting ready* section of the *String Parsing with Regular Expressions* recipe
    we showed how a regular expression match object will create a tuple of text that
    was parsed from a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own tuples, too. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enclose the data in `()` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separate the items with a `,` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: There's an important special case for the one-tuple, or singleton. We have to
    include an extra `,` even when there's only one item in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `()` characters aren''t always required. There are a few times where we
    can omit them. It''s not a good idea to omit them, but we can see funny things
    when we have an extra comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The extra comma after `355` makes the value into a singleton tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting items from a tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea of a tuple is to be a container with a number of items that''s fixed
    by the problem domain: for example, `(red, green, blue)` color numbers. The number
    of items is always three.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we''ve got an ingredient, and amount, and units. This must
    be a three-item collection. We can look at the individual items two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By index position: Positions are numbered starting with zero from the left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Using multiple assignment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Tuples—like strings—are immutable. We can't change the individual items inside
    a tuple. We use tuples when we want to keep the data together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are one example of the more general class of `Sequence` . We can do a
    few things with sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example tuple that we can work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some operations we can perform on this tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: How many items in `t` ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: How many times does a particular value appear in `t` ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Which position has a particular value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'When an item doesn''t exist, we''ll get an exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Does a particular value exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple, like a string, is a sequence of items. In the case of a string, it's
    a sequence of characters. In the case of a tuple, it's a sequence of many things.
    Because they're both sequences, they have some common features. We've noted that
    we can pluck out individual items by their index position. We can use the `index()`
    method to locate the position of an item.
  prefs: []
  type: TYPE_NORMAL
- en: The similarities end there. A string has many methods to create a new string
    that's a transformation of a string, plus methods to parse strings, plus methods
    to determine the content of the strings. A tuple doesn't have any of these bonus
    features. It's—perhaps—the simplest possible data structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at one other sequence, the list, in the *Building complex strings
    from lists of characters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also look at sequences in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, tuple,
    set, dict*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
