- en: Chapter 5. Linux Binary Protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the basic techniques and motivations
    for obfuscation of Linux programs. Techniques that obfuscate or encrypt binaries
    or make them difficult to tamper with are called software protection schemes.
    By "software protection," we mean binary protection or binary hardening techniques.
    Binary hardening is not exclusive to Linux; in fact, there are many more products
    for the Windows OS in this technology genre, and there are definitely more examples
    to choose from for discussion.
  prefs: []
  type: TYPE_NORMAL
- en: What many people fail to realize is that Linux has a market for this too, although
    it largely exists for anti-tamper products used by the government. There are also
    a number of ELF binary protectors that were released over the last decade in the
    hacker community, several of which paved the way for many of the technologies
    used today.
  prefs: []
  type: TYPE_NORMAL
- en: An entire book could be dedicated to the art of software protection, and as
    the author of some of the more recent binary protection technologies for ELF,
    I could easily get carried away with this chapter. Instead, I will stick to explaining
    the fundamentals and some interesting techniques that are used, followed by some
    insights into my own binary protector—**Maya's Veil**. The tricky engineering
    and skills that go into binary protection make it a challenging topic to articulate,
    but I will do my best here.
  prefs: []
  type: TYPE_NORMAL
- en: ELF binary packers – dumb protectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **packer** is a type of software that is commonly used by malware authors
    and hackers to compress or encrypt an executable in order to obfuscate its code
    and data. One very common packer is named UPX ([http://upx.sourceforge.net](http://upx.sourceforge.net))
    and is available as a package on most Linux distributions. The original purpose
    of this type of packer was to compress an executable and make it smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code is compressed, it must have a way to decompress itself before
    executing in memory—this is where things get interesting, and we will discuss
    how this works in the *Stub mechanics and the userland exec* section. At any rate,
    malware authors have realized that compressing their malware-infected files would
    evade AV detection due to obfuscation. This led malware/antivirus researchers
    to develop automated unpackers, which are now used in most, if not all, modern
    AV products.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the term "packed binary" refers not only to compressed binaries but
    also to encrypted binaries or binaries that are shielded with an obfuscation layer
    of any kind. Since the early 2000s, there have been several remarkable ELF binary
    protectors that have shaped the future of binary protection in Linux. We will
    explore each one of these and use them to model the different techniques used
    to protect ELF binaries. Beforehand, however, let's look at how stubs work to
    load and execute a compressed or encrypted binary.
  prefs: []
  type: TYPE_NORMAL
- en: Stub mechanics and the userland exec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, it is necessary to understand that a software protector is actually
    made up of two programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protection phase code**: The program that applies the protection to the target
    binary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime engine or stub**: The program that is merged with the target binary
    that is responsible for deobfuscation and anti-debugging at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protector program can vary greatly depending on the types of protection
    that are being applied to the target binary. Whatever type of protection is being
    applied to the target binary must be understood by the runtime code. The runtime
    code (or stub) must know how to decrypt or deobfuscate the binary that it is merged
    with. In most cases of software protection, there is a relatively simple runtime
    engine merged with the protected binary; its sole purpose is to decrypt the binary
    and pass control to the decrypted binary in memory.
  prefs: []
  type: TYPE_NORMAL
- en: This type of runtime engine is not so much an engine—really—and we call it a
    stub. The stub is generally compiled without any libc linkings (for example, `gcc
    -nostdlib`), or is statically compiled. This type of stub, although simpler than
    a true runtime engine, is actually still quite complicated because it must be
    able to `exec()` a program from memory—this is where **userland exec** comes into
    play. We can thank the grugq for his contributions here.
  prefs: []
  type: TYPE_NORMAL
- en: The `SYS_execve` system call, which is generally used by the `glibc` wrappers
    (for example, `execve`, `execv`, `execle`, and `execl`) will load and run an executable
    file. In the case of a software protector, the executable is encrypted and must
    be decrypted prior to being executed. Only an unseasoned hacker would program
    their stub to decrypt the executable and then write it to disk in a decrypted
    form before they execute it with `SYS_exec`, although the original UPX packer
    did work this way.
  prefs: []
  type: TYPE_NORMAL
- en: The skilled way of accomplishing this is by decrypting the executable in place
    (in memory), and then loading and executing it from the memory—not a file. This
    can be done from the userland code, and therefore we call this technique userland
    exec. Many software protectors implement a stub that does this. One of the challenges
    in implementing a stub userland exec is that it must load the segments into their
    designated address range, which would typically be the same addresses that are
    designated for the stub executable itself.
  prefs: []
  type: TYPE_NORMAL
- en: This is only a problem for ET_EXEC-type executables (since they are not position
    independent), and it is generally overcome by using a custom linker script that
    tells the stub executable segments to load at an address other than the default.
    An example of such a linker script is shown in the section on linker scripts in
    [Chapter 1](part0015_split_000.html#E9OE2-1d4163ae11644cc2802846625b2dc985 "Chapter 1. The
    Linux Environment and Its Tools"), *The Linux Environment and Its Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On x86_32, the default base is 0x8048000, and on x86_64, it is 0x400000\. The
    stub should have load addresses that do not conflict with the default address
    range. For example, a recent one that I wrote is linked such that the text segment
    is loaded at 0xa000000.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stub mechanics and the userland exec](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Illustration 5.1: A model of a binary protector stub'
  prefs: []
  type: TYPE_NORMAL
- en: '*Illustration 5.1* shows visually how the encrypted executable is embedded
    within the data segment of the stub executable, wrapped within it, which is why
    stubs are also referred to as wrappers.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will show in *Identifying protected binarires* section in [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux* how
    peeling a wrapper off can actually be a trivial task in many cases, and how it
    may also be an automated task with the use of software or scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical stub performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting its payload (which is the original executable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping the executable's loadable segments into the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping the dynamic linker into the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a stack (that is with mmap)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the stack up (argv, envp, and the auxiliary vector)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing control to the entry point of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the protected program was dynamically linked, then the control will be passed
    to the entry point of the dynamic linker, which will subsequently pass it to the
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: A stub of this nature is essentially just a userland exec implementation that
    loads and executes the program embedded within its own program body, instead of
    an executable that is a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original userland exec research and algorithm can be found in the grugq's
    paper titled *The Design and Implementation of Userland Exec* at [https://grugq.github.io/docs/ul_exec.txt](https://grugq.github.io/docs/ul_exec.txt).
  prefs: []
  type: TYPE_NORMAL
- en: An example of a protector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at an executable before and after it is protected by a simple
    protector that I wrote. Using `readelf` to view the program headers, we can see
    that the binary has all the segments that we would expect to see in a dynamically
    linked Linux executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our protector program on the binary and view the program headers
    afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are many differences that you will note. The entry point is `0xa01136`,
    and there are only two loadable segments, which are the text and data segments.
    Both of these are at completely different load addresses than before.
  prefs: []
  type: TYPE_NORMAL
- en: This is of course because the load addresses of the stub cannot conflict with
    the load address of the encrypted executable contained within it, which must be
    loaded and memory-mapped to. The original executable has a text segment address
    of `0x400000`. The stub is responsible for decrypting the executable embedded
    within and then mapping it to the load addresses specified in the `PT_LOAD` program
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the addresses conflict with the stub''s load addresses, then it will not
    work. This means that the stub program has to be compiled using a custom linker
    script. The way this is commonly done is by modifying the existing linker script
    that is used by `ld`. For the protector used in this example, I modified a line
    in the linker script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the original line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the modified line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another thing that you can notice from the program headers in the protected
    executable is that there is no `PT_INTERP` segment or `PT_DYNAMIC` segment. This
    would appear to the untrained eye as a statically linked executable, since it
    does not appear to use dynamic linking. This is because you are not viewing the
    program headers of the original executable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the original executable is encrypted and embedded within the stub
    executable, so you are really viewing the program headers from the stub and not
    from the executable that it is protecting. In many cases, the stub itself is compiled
    and linked with very minimal options and does not require dynamic linking itself.
    One of the primary characteristics of a good userland exec implementation is the
    ability to load the dynamic linker into memory.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned, the stub is a userland exec, and it will map the dynamic linker
    to the memory after it decrypts and maps the embedded executable to the memory.
    The dynamic linker will then handle symbol resolution and runtime relocations
    before it passes control to the now-decrypted program.
  prefs: []
  type: TYPE_NORMAL
- en: Other jobs performed by protector stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to decrypting and loading the embedded executable into memory, which
    is the userland exec component, the stub may also perform other tasks. It is common
    for the stub to start anti-debugging and anti-emulation routines that are meant
    to further protect the binary from being debugged or emulated in order to raise
    the bar even further so that reverse engineering is even more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, we discussed some anti-debugging techniques used to prevent
    debugging based on `ptrace`. This prevents most debuggers, including GDB, from
    trivially tracing the binary. Later in this chapter, we will summarize the most
    common anti-debugging techniques used in binary protection for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Existing ELF binary protectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, there have been a few noteworthy binary protectors that were
    released both publicly and from the underground scene. I will discuss some of
    the protectors for Linux and give a synopsis of the various features.
  prefs: []
  type: TYPE_NORMAL
- en: DacryFile by the Grugq – 2001
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DacryFile is the earliest binary protector that I am aware of for Linux ([https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile](https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile)).
    This protector is simple but nonetheless clever and works very similarly to ELF
    parasite infection from a virus. In many protectors, the stub wraps around the
    encrypted binary, but in the case of DacryFile, the stub is just a simple decryption
    routine that is injected into the binary that is to be protected.
  prefs: []
  type: TYPE_NORMAL
- en: DacryFile encrypts a binary from the beginning of the `.text` section to the
    end of the text segment using RC4 encryption. The decryption stub is a simple
    program written in asm and C, and it does not have the userland exec functionality;
    it simply decrypts the encrypted body of code. This stub is inserted at the end
    of the data segment, which is very reminiscent of how a virus inserts a parasite.
    The entry point of the executable is modified to point to the stub, and upon execution
    of the binary, the stub decrypts the text segment of the program. Then it passes
    the control to the original entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On systems that support NX bit, the data segment cannot be used to hold code
    unless it is explicitly marked with executable permission bits, that is, `'p_flags
    |= PF_X`'.
  prefs: []
  type: TYPE_NORMAL
- en: Burneye by Scut – 2002
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Burneye is said by many to have been the first example of decent binary encryption
    in Linux. By today's standards, it would be considered weak, but it nevertheless
    brought some innovative features to the table. This includes three layers of encryption,
    the third of which is a password-protected layer.
  prefs: []
  type: TYPE_NORMAL
- en: The password is converted into a type of hash-sum and then used to decrypt the
    outermost layer. This means that unless the binary is given the correct password,
    it will never decrypt. Another layer, called a fingerprint layer, can be used
    instead of the password layer. This feature creates a key out of an algorithm
    that fingerprints the system that the binary was protected on, and prevents the
    binary from being decrypted on any other system but the one it was protected on.
  prefs: []
  type: TYPE_NORMAL
- en: There was also a self-destruct feature; it deletes the binary after it is run
    once. One of the primary things that separated Burneye from other protectors was
    that it was the first to use the userland exec technique to wrap binaries. Technically,
    this was first done by John Resier for the UPX packer, but UPX is considered more
    of a binary compressor than a protector. John allegedly passed on the knowledge
    of userland exec to Scut, as mentioned in the Phrack 58 article written by Scut
    and Grugq on ELF binary protection at [http://phrack.org/issues/58/5.html](http://phrack.org/issues/58/5.html).
    This article documents the inner workings of Burneye and is highly recommended
    for reading.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tool named `objobf`, which stands for **object obfuscator**, was also designed
    by Scut. This tool obfuscates an ELF32 ET_REL (object file) so that the code is
    very difficult to disassemble but is functionally equivalent. With the use of
    techniques such as opaque branches and misaligned assembly, this can be quite
    effective in deterring static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Shiva by Neil Mehta and Shawn Clowes – 2003
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shiva was probably the best publicly available example of Linux binary protection.
    The source code was never released—only the protector was—but several presentations
    were delivered at various conferences, such as Blackhat USA, by the authors. These
    revealed many of its techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Shiva works for 32-bit ELF executables and provides a complete runtime engine
    (not just a decryption stub) that assists decryption and anti-debugging features
    throughout the duration of the process that it is protecting. Shiva provides three
    layers of encryption, where the innermost layer never fully decrypts the entire
    executable. It decrypts 1,024-byte blocks at a time and then re-encrypts.
  prefs: []
  type: TYPE_NORMAL
- en: For a sufficiently large program, no more than 1/3rd of the program will be
    decrypted at any given time. Another powerful feature is the inherent anti-debugging—the
    Shiva protector uses a technique wherein the runtime engine spawns a thread using
    `clone()`, which then traces the parent, while the parent conversely traces the
    thread. This makes using dynamic analysis based on `ptrace` impossible, since
    a single process (or thread) may not have more than a single tracer. Also, since
    both processes are being traced by each other, no other debugger can attach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A renowned reverse engineer named Chris Eagle successfully unpacked a Shiva-protected
    binary using an x86 emulator plugin for IDA and gave a presentation on this feat
    at Blackhat. This reverse engineering of Shiva was said to have been accomplished
    within a 3-week period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Presentation by the authors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf](https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Presentation by Chris Eagle (who broke Shiva):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf](http://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Maya's Veil by Ryan O'Neill – 2014
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maya's Veil was designed by me in 2014 and is for ELF64 binaries. To this day,
    the protector is in a prototype stage and has not been released publicly, but
    there are some forked versions that have transpired into variations of the Maya
    project. One of them is [https://github.com/elfmaster/](https://github.com/elfmaster/),
    which is a version of Maya that incorporates only anti-exploitation technologies,
    such as control flow integrity. As the originator and designer of the Maya protector,
    I am at liberty to elaborate on some of the details of its inner workings, primarily
    for reasons of sparking interest and creativity in readers who are interested
    in this type of thing. In addition to being the author of this book, I am also
    quite approachable as a person, so feel free to contact me if you have more questions
    about Maya's Veil.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, this protector was designed as a userland-only solution (which means
    no assistance from clever kernel modules) while still being able to protect a
    binary with sufficient anti-tamper qualities and—even more impressively—additional
    anti-exploitation features. Many of the capabilities that Maya possesses have
    so far been seen only with compiler plugins, whereas Maya operates directly on
    the already compiled executable binary.
  prefs: []
  type: TYPE_NORMAL
- en: Maya is extremely complicated, and documenting all of its inner workings would
    be a complete exegesis on the subject of binary protection, but I will summarize
    some of its most important qualities. Maya can be used to create a layer 1, layer
    2, or layer 3 protected binary. At the first layer, it uses an intelligent runtime
    engine; this engine is compiled as an object file named `runtime.o`.
  prefs: []
  type: TYPE_NORMAL
- en: This file is injected using a reverse text-padding extension (Refer to [Chapter
    4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985 "Chapter 4. ELF
    Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology – Linux/Unix Viruses*),
    combined with relocatable code injection relinking techniques. Essentially, the
    object file for the runtime engine is linked to the executable that it is protecting.
    This object file is very important as it contains the code for anti-debugging,
    anti-exploitation, custom `malloc` with an encrypted heap, metadata about the
    binary that it is protecting, and so on. This object file was written in about
    90% C and 10% x86 assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Maya's protection layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maya has multiple layers of protection and encryption. Each additional layer
    enhances the level of security by adding more work for an attacker to peel off.
    The outermost layers are the most useful for preventing static analysis, whereas
    the innermost layer (layer 1) only decrypts the functions within the present call
    stack and re-encrypts them when done. The following is a more detailed explanation
    of each layer.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A layer 1 protected binary consists of every single function of the binary individually
    encrypted. Every function decrypts and re-encrypts on the fly, as they are called
    and returned. This works because `runtime.o` contains an intelligent and autonomous
    self-debugging capability that allows it to closely monitor the execution of a
    process and determine when it is being attacked or analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime engine itself has been obfuscated using code obfuscation techniques,
    such as those found on Scut's object obfuscator tool. The key storage and metadata
    for the decrypting and re-encrypting functions are stored in a custom `malloc()`
    implementation that uses an encrypted heap spawned by the runtime engine. This
    makes locating the keys difficult. Layer 1 protection is the first and most complex
    level of protection due to the fact that it instruments the binary with an intelligent
    and autonomous self-tracing capability for dynamic decryption, anti-debugging,
    and anti-exploitation abilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layer 1](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An over-simplified diagram showing how a layer 1 protected binary is laid out
    next to the original binary
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A layer 2 protected binary is the same as a level 1 protected binary, except
    that not only the functions but also every other section in the binary is encrypted
    to prevent static analysis. These sections are decrypted at runtime, leaving certain
    data exposed if someone is able to dump the process, which would have to be done
    through a memory driver because `prctl()` is used to protect the process from
    normal userland dumps through `/proc/$pid/mem` (and also stops the process from
    dumping any core files).
  prefs: []
  type: TYPE_NORMAL
- en: Layer 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A layer 3 protected binary is the same as level 2, except that it adds one more
    complete layer of protection by embedding the layer 2 binary into the data segment
    of the layer 3 stub. The layer 3 stub works like a traditional userland exec.
  prefs: []
  type: TYPE_NORMAL
- en: Maya's nanomites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maya's Veil has many other features that make it difficult to reverse-engineer.
    One such feature is called **nanomites**. This is where certain instructions in
    the original binary are completely removed and replaced with junk instructions
    or breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: When Maya's runtime engine sees one of these junk instructions or breakpoints,
    it checks its nanomite records to see what the original instruction was that existed
    there. The records are stored in the encrypted heap segment of the runtime engine,
    so accessing this information is non-trivial for a reverse engineer. Once Maya
    knows what the original instruction did, it emulates the instruction using the
    `ptrace` system call.
  prefs: []
  type: TYPE_NORMAL
- en: Maya's anti-exploitation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The anti-exploitation features of Maya are what make it unique compared to other
    protectors. Whereas most protectors aim only to make reverse engineering difficult,
    Maya is able to strengthen a binary so that many of its inherent vulnerabilities
    (such as a buffer overflow) cannot be exploited. Specifically, Maya prevents **ROP**
    (short for **Return-Oriented Programming**) by instrumenting the binary with special
    control flow integrity technology that is embedded in the runtime engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every function in a protected binary is instrumented with a breakpoint (`int3`)
    at the entry point and at every return instruction. The `int3` breakpoint delivers
    a SIGTRAP that triggers the runtime engine; the runtime engine then does one of
    several things:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the function (only if it hits the entry `int3` breakpoint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting the function (only if it hits the return `int3` breakpoint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the return address has been overwritten
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the `int3` breakpoint is a nanomite; if so, it will emulate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third bullet is the anti-ROP feature. The runtime engine checks a hash map
    that contains valid return addresses for various points within the program. If
    the return address is invalid, then Maya will bail out and the exploitation attempt
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a vulnerable piece of software code that was
    specially crafted to test and show off Maya''s anti-ROP feature:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code of vuln.c
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example of exploiting vuln.c
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can exploit `vuln.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s protect vuln using the `-c` option of Maya, which means control
    flow integrity. Then we will try to exploit the protected binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that Maya has detected an invalid return address, `0x41414141`,
    before the return instruction actually succeeds. Maya's runtime engine interferes
    by crashing the program safely (without exploitation).
  prefs: []
  type: TYPE_NORMAL
- en: Another anti-exploitation feature that Maya enforces is **relro** (**read-only
    relocations**). Most modern Linux systems have this feature enabled, but if it
    is not enabled, Maya will enforce it on its own by creating a read-only page with
    `mprotect()` that encompasses `the.jcr`, `.dynamic`, `.got`, `.ctors` (`.init_array`),
    and `.dtors` (`.fini_array`) sections. Other anti-exploitation features (such
    as function pointer integrity) are being planned for the future and have not yet
    made it into the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Maya-protected binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who are interested in reverse-engineering some simple programs that
    were protected with Maya''s Veil, feel free to download a couple of samples that
    are available at [http://www.bitlackeys.org/maya_crackmes.tgz](http://www.bitlackeys.org/maya_crackmes.tgz).
    This link contains three files: `crackme.elf_hardest`, `crackme.elf_medium`, and
    `test.maya`.'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-debugging for binary protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since binary protectors generally encrypt or obfuscate the physical body of
    a program, static analysis can be extremely difficult and, left to its own devises,
    will prove to be futile in many cases. Most reverse engineers who are attempting
    to unpack or break a protected binary will agree that a combination of dynamic
    analysis and static analysis must be used to gain access to the decrypted body
    of a binary.
  prefs: []
  type: TYPE_NORMAL
- en: A protected binary has to decrypt itself, or at least the portions of itself
    that are executing at runtime. Without any anti-debugging techniques, a reverse
    engineer can simply attach to the process of the protected program and set a breakpoint
    on the last instruction of the stub (assuming that the stub decrypts the entire
    executable).
  prefs: []
  type: TYPE_NORMAL
- en: Once the breakpoint is hit, the attacker can look at the code segment for where
    the protected binary lives and find its decrypted body. This would be extremely
    simple, and therefore it is very important for good binary protection to use as
    many techniques as possible to make debugging and dynamic analysis difficult for
    the reverse engineer. A protector like Maya goes to great lengths to protect the
    binary from both static and dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis is not limited to the `ptrace` syscall, although most debuggers
    are limited to it for the purpose of accessing and manipulating a process. Therefore,
    a binary protector should not be limited to protecting only against `ptrace`;
    ideally it will also be resistant to other forms of dynamic analysis, such as
    emulation and dynamic instrumentation (for example, **Pin** and **DynamoRIO**).
    We covered many anti-debugging techniques against `ptrace` analysis in previous
    chapters, but what about resistance to emulation?
  prefs: []
  type: TYPE_NORMAL
- en: Resistance to emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, emulators are used to perform dynamic analysis and reverse engineering
    tasks on executables. One very good reason for this is that they allow the reverse
    engineer to easily instrument the control of the execution, and they also bypass
    a lot of typical anti-debugging techniques. There are many emulators being used
    out there—QEMU, BOCHS, and Chris Eagles' IDA X86 emulator plugin, to name some.
    So, countless anti-emulation techniques exist, but some of them are specific to
    each emulator's particular implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This topic could expand into some very in-depth discussions and move in many
    directions, but I will keep it limited to my own experience. In my own experimentation
    with emulation and anti-emulation in the Maya protector, I have learned some generic
    techniques that should work against at least some emulators. The goal of our binary
    protector's anti-emulation is to be able to detect when it is being run in an
    emulator, and if this is true, it should halt the execution and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting emulation through syscall testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique can be especially useful in application-level emulators that
    are somewhat OS agnostic and are unlikely to have implemented more than the basic
    system calls (`read`, `write`, `open`, `mmap`, and so on). If an emulator does
    not support a system call and also does not delegate the unsupported syscall to
    the kernel, it is very likely that it will posit an erroneous return value.
  prefs: []
  type: TYPE_NORMAL
- en: So, the binary protector could invoke a handful of less common syscalls and
    check whether the return value matches the expected value. A very similar technique
    would be to invoke certain interrupt handlers to see whether they behave correctly.
    In either case, we are looking for OS features that were not properly implemented
    by the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting emulated CPU inconsistencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chances of an emulator perfectly emulating CPU architectures are next to
    none. Therefore, it is common to look for certain inconsistencies between how
    the emulator behaves and how the CPU should behave. One such technique is to attempt
    writing to privileged instructions, such as debug registers (for example, `db0`
    to `db7`) or control registers (for example, `cr0` to `cr4`). The emulation detection
    code may have a stub of ASM code that attempts to write to `cr0` and see whether
    it succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Checking timing delays between certain instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another technique that can sometimes cause instability in the emulator itself
    is checking the timestamps between certain instructions and seeing how long the
    execution took. A real CPU should execute a sequence of instructions several magnitudes
    faster than an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary can be obfuscated or encrypted in many creative ways. Most binary protectors
    simply protect the entire binary with one or more layers of protection. At runtime,
    the binary is decrypted and can be dumped from the memory to acquire a copy of
    the unpacked binary. In more advanced protectors, such as Maya, every single function
    is encrypted individually, and allows only a single function to be decrypted at
    any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Once a binary is encrypted, it must, of course, store the encryption keys somewhere.
    In the case of Maya (discussed earlier), a custom heap implementation that itself
    uses encryption to store encryption keys was designed. At some point, it would
    seem that a key has to be exposed (such as the key used to decrypt another key),
    but special techniques such as white-box cryptography can be used to make these
    final keys extremely obfuscated. If assistance from the kernel is used in a protector,
    then it is possible to store the key outside of the binary and process memory
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: Code obfuscation techniques (such as false disassembly, which was described
    in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*) are also commonly used in binary protection to make static
    analysis more difficult for code that has been decrypted or is never encrypted.
    Binary protectors also usually strip the section header table from a binary and
    remove any unneeded strings and string tables from it, such as those that give
    symbol names.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting control flow integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A protected binary should aim to protect the program during runtime (the process
    itself) just as much as—if not more than—the binary at rest on the disk. Runtime
    attacks can generally be classified into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Attacks based on `ptrace`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability-based attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacks based on ptrace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first variety, `ptrace` based attacks, also falls under the category of
    debugging a process. As already discussed, a binary protector wants to make `ptrace`
    based debugging very difficult for a reverse engineer. Aside from debugging, however,
    there are many other attacks that could potentially help break a protected binary,
    and it is important to know and understand what some of these are in order to
    give further clarification as to why a binary protector wants to protect a running
    process from `ptrace`.
  prefs: []
  type: TYPE_NORMAL
- en: If a protector has gone so far that it is able to detect breakpoint instructions
    (and therefore make debugging more difficult) but is not able to protect itself
    from being traced by `ptrace`, then it is possible that it is still very vulnerable
    to `ptrace` based attacks, such as function hijacking and shared library injection.
    An attacker may not want to simply unpack a protected binary, but may aim to only
    change the binary's behavior. A good binary protector should try to protect the
    integrity of its control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that an attacker is aware that a protected binary is calling the `dlopen()`
    function to load a specific shared library, and the attacker wants the process
    to load a trojaned shared library instead. The following steps could lead to an
    attacker compromising a protected binary by changing its control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to the process with `ptrace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying the Global Offset Table entry for `dlopen()` to point to `__libc_dlopen_mode`
    (in `libc.so`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjusting the `%rdi` register so that it points to this path: `/tmp/evil_lib.so`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuing execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the attacker has just forced a protected binary to load a malicious
    shared library and has therefore completely compromised the security of the protected
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: The Maya protector, as discussed earlier, is armed against such vulnerabilities
    thanks to a runtime engine that works as an active debugger, preventing any other
    process from attaching. If a protector can disable `ptrace` from attaching to
    the protected process, then that process is at much less risk of this type of
    runtime attack.
  prefs: []
  type: TYPE_NORMAL
- en: Security vulnerability-based attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vulnerability-based attack is a type of attack in which an attacker may be
    able to exploit an inherent weakness in the protected program, such as a stack-based
    buffer overflow, and subsequently change the execution flow to something of their
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: This type of attack is often more difficult to carry out on a protected program,
    since it yields much less information about itself, and using a debugger to narrow
    down on the locations used in the memory by the exploit is potentially much more
    difficult to gain insight into. Nevertheless, this type of attack is very possible,
    and this is why the Maya protector enforces control flow integrity and read-only
    relocations to protect specifically against vulnerability exploitation attacks.
  prefs: []
  type: TYPE_NORMAL
- en: I am not aware whether any other protectors out there right now are using similar
    anti-exploitation techniques, but I can only surmise that they are out there.
  prefs: []
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing only one chapter on binary protection is not nearly comprehensive enough
    on its own to teach you all about this one subject. The other chapters in this
    book complement each other, however; when combined together, they will help you
    get to deeper levels of understanding. There are many good resources on this subject,
    some of which have already been mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'One resource in particular, written by Andrew Griffith, is highly recommended
    for reading. This paper was written over a decade ago but describes many of the
    techniques and practices that are still very pertinent to the binary protectors
    of today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.bitlackeys.org/resources/binary_protection_schemes.pdf](http://www.bitlackeys.org/resources/binary_protection_schemes.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This paper was followed by a talk given at a later date, and the slides can
    be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf](http://2005.recon.cx/recon2005/papers/Andrew_Griffiths/protecting_binaries.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we revealed the inner workings of basic binary protection schemes
    for Linux binaries, and discussed the various features of existing binary protectors
    that have been released for Linux over the last decade.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be exploring things from the opposite angle and
    begin looking at ELF binary forensics in Linux.
  prefs: []
  type: TYPE_NORMAL
