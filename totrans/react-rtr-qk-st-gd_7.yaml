- en: Using NativeRouter in a React Native Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React Router library provides the `react-router-native` package, which includes
    the implementation of the `NativeRouter` component for use in React Native applications.
    The React Native framework allows you to build native mobile applications for
    iOS and Android using JavaScript and React.
  prefs: []
  type: TYPE_NORMAL
- en: 'From React Native''s Documentation ([https://facebook.github.io/react-native/](https://facebook.github.io/react-native/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"With React Native, you don''t build a **mobile web app**, an **HTML5 app**,
    or a **hybrid app**. You build a real mobile app that''s indistinguishable from
    an app built using Objective-C or Java. React Native uses the same fundamental
    UI building blocks as regular iOS and Android apps. You just put those building
    blocks together using JavaScript and React."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics are discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: Using NativeRouter in a React Native application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NativeRouter component and its props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `<BackButton>` component to interact with a devices' back button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Deeplinks using the `<DeepLinking>` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NativeRouter in a React Native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `create-react-app` CLI, the `create-react-native-app` CLI is
    used to create an application that includes build scripts that can be used to
    build an application for both development and production environments. It also
    includes `packager`, which allows you to test your application on iOS and Android
    emulators and also on real devices.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project with the create-react-native-app CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started by first installing the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command installs the CLI in the global `node_modules` directory.
    The next step is to create a React Native project using the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `react-native-test-app` directory is created and all the required scripts
    are downloaded in the `node_modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the `npm start` script, the build script starts `packager`
    and it generates a QR code and a URL for you to access the application on a real
    device (iOS or Android) or on the emulator. Also, you could launch the iOS or
    Android emulator if you have Xcode or Android Studio installed. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of this example, we will use the Xcode emulator; here''s a
    screenshot of the application when you request the application to be viewed on
    the iOS emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f7fd2ef8-6c2e-45db-ae0f-4af41389c7c4.png)'
  prefs: []
  type: TYPE_IMG
- en: React Native provides several components that allow you to build views for the
    native platform. Let's take a look at the code and understand some of the components
    used to build the preceding view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.js`, the following code is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, React Native's `<View>` component is used to create a container in a similar
    way to how you would create a container using `<div>` or `<section>` in a React
    application. In React Native, instead of using HTML elements, such as `<div>` and `<span>`,
    React Native's components, such as `<View>` and `<Text>`, are used.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the <NativeRouter> component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now add the `react-router-native` package to the application that we
    just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `NativeRouter` component is used in React Native applications to provide
    routing and navigation support. It enables components such as `<Route>` and `<Link>`
    to be used in the native application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a side menu that includes a couple of `<Link>` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<ScrollView>` component is used as a container to host our menu items
    (the `<Link>` components). As the name suggests, the `<ScrollView>` component
    is used to create a scrollable container. The next step is to add `<Route>` components
    to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ContentView` component wraps the `<Route>` components inside a `<View>`
    component, thus defining two application routes with path `/` and `/dashboard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step, we will now use the `<SideMenu>` component from `react-native-side-menu` to
    create a drawer menu. This menu is then wrapped inside the `<NativeRouter>` component
    in App.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Similar to other Router implementations, the `NativeRouter` component wraps
    the application root component and enables the `<Route>` and `<Link>` components
    to update `history` as the user navigates through the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After rebuilding the application on the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/317f8265-8360-4d55-9354-3a4a7df48933.png)'
  prefs: []
  type: TYPE_IMG
- en: When you select either of the links, `ContentView` is updated with the component
    rendered as a result of a `<Route>` match.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding functionality is similar to how `BrowserRouter` enables you to
    navigate through various routes defined in the application. Similar to the `<Route>`
    and `<Link>` components, other components such as `<Switch>`, `<Redirect>`, and
    `<NavLink>` behave the same in a React Native application. However, when you try
    to block the navigation using the `<Prompt>` component, React Native's `Alert` component
    should be used to display a confirmation message.
  prefs: []
  type: TYPE_NORMAL
- en: 'From NativeRouter''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'NativeRouter provides a default implementation of the `getUserConfirmation` function,
    which makes use of the `Alert` component defined in the `react-native` package
    to display a confirmation message to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ebf55586-f7e0-4a03-b0cd-61f6cf419d08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This default behavior can be overridden by including the `getUserConfirmation`
    prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The <NativeRouter> component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NativeRouter` component uses the `MemoryRouter` component defined in the
    `react-router` package to provide routing support in a React Native application. `MemoryRouter`
    is used when you want to maintain the browsing history in memory without updating
    the URL in the address bar. It's particularly useful in non-browser environments
    where an address bar is not available. The `MemoryRouter` component creates a
    `history` object using the `createMemoryHistory` class available in the `history`
    package. This `history` object is then provided to the low-level `<Router>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NativeRotuer.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `MemoryRouter` component creates a `history` object using `createMemoryHistory`,
    in `MemoryRouter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `NativeRouter` component accepts props: `initialEntries`, `initialIndex`,
    `getUserConfirmation`, `keyLength`, and `children`. As mentioned previously, a
    default implementation for `getUserConfirmation` is included in the `NativeRouter` class
    and both `keyLength` and `children` props behave similarly to other Router components,
    as mentioned in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at `initialEntries` and `initialIndex` props.
  prefs: []
  type: TYPE_NORMAL
- en: The initialEntries prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `initialEntries` prop is used to populate the history stack with a list
    of locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of initializing `NativeRouter`, you could populate the history
    by providing an array of location paths. A location path could be a string or
    even an object of shape `{ pathname, search, hash, state }`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The initialIndex prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `initialIndex` prop is used to specify the index value of the location
    in the `initialEntries` array to render when the application loads. For example,
    if the `initialEntries` array has two locations listed, then an `initialIndex`
    value of `1` loads the second entry; that is, a `<Route>` instance matching the
    pathname mentioned as the second entry in `initialEntries` array is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `initialIndex` value is set to `1` and thus the `<Route>` matching
    the location path `/dashboard` is rendered when the application loads.
  prefs: []
  type: TYPE_NORMAL
- en: The <BackButton> component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, when you press the back button on an Android device, the application
    exits instead of navigating the user to the previous state in the history. The
    React Native library includes a `BackHandler` class, which lets you customize
    the behavior of the devices'' hardware back button. The `<BackButton>` component
    in React Router uses the `BackHandler` class to customize the behavior of the
    back button on an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `<BackButton>` component can be included anywhere in the application. In
    the preceding example, the component is included in the root component and it
    does not include any child components. Please note that the `<BackButton>` component
    does not render anything on the viewport; rather, it facilitates the interaction
    with the devices' back button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3ee74a56-b270-4210-a09c-3bc8a798ee30.png)'
  prefs: []
  type: TYPE_IMG
- en: Whilst on the Dashboard screen (at path `/dashboard`), when you click the devices'
    back button, the user is navigated to the home page (at path `/`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Deeplinks with <DeepLinking>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a web application, the HTTP URL refers to a location that can be accessed
    by entering the same in the address bar of the browser. In Single Page Applications,
    this location refers to a specific route that the user can navigate to. In the
    context of a mobile application, `DeepLink` refers to a specific page or content
    that you would want to view. For example, when you click on a link on a mobile
    device, instead of opening a new tab in the browser window, an application is
    launched and the requested page is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike web applications, which use HTTP to refer to a specific location, applications
    on a mobile device need to declare a URI scheme for the application. For example,
    the Twitter application uses the URI scheme `twitter://` and thus you could view
    their Twitter profile by referring to the URI `twitter://profile`. Deeplinks are
    very helpful when the user clicks on links in an email or accesses push notification
    messages, which navigate the user to the application to show the requested content.
  prefs: []
  type: TYPE_NORMAL
- en: React Native provides interfaces that allow you to create Deeplinks for devices
    on both iOS and Android platforms. In this section, we will take a look at how
    to create Deeplinks to an application's content on an Android device and thus
    we require Android Studio to be installed. Android Studio allows us to create
    virtual devices (AVD) that can then be used to test Deeplinks.
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step guide to installing the necessary components on iOS and Android
    is detailed in the React Native documentation: [https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: After installing Android Studio and creating an AVD, the application needs to
    be configured with a URI scheme. To add the URI scheme, some of the native files
    need to be updated, and to get access to these native files, you need to eject
    from the current setup.
  prefs: []
  type: TYPE_NORMAL
- en: Ejecting from the create-react-native-app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `create-react-native-app` CLI is a very good option for scaffolding a React
    Native application and for testing the application on an emulator. However, to
    test `DeepLinking` we would need to include entries in the manifest file and thus
    it''s required that we eject from the configuration using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will generate configuration files for iOS and Android platforms.
    This bare-minimum configuration allows you to generate a `.ipa` file for an iOS
    device and a `.apk` file for an Android device. In this section, we will see how
    we can generate the `.apk` file, which will then be deployed to an AVD.
  prefs: []
  type: TYPE_NORMAL
- en: 'After ejecting, you will see various directories and files generated for both
    iOS and Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to build and run the application on the Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will run the build script and generate the `.apk` file,
    which gets deployed on an AVD. Please ensure that you have the virtual device
    running before executing the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: To configure the URI scheme on an Android device, the `AndroidManifest.xml` manifest
    file located at the `/android/app/src/main` path needs to be updated. In the next
    section, we will see the configuration that needs to be added to the manifest
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding <intent-filter> to the manifest file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AndroidManifest.xml` file contains meta information about the application,
    and it is used to declare various components present in the application. These
    components are activated using intent filters. An `<intent-filter>` instance in
    the manifest file is used to define the capabilities of the application and in
    defining a policy on how other applications would interact with the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you eject from the configuration, the `AndroidManifest.xml` file is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<intent-filter>` has the action and the category defined for the application
    as `android.intent.action.MAIN` and `android.intent.category.LAUNCHER`. The previous `intent-filter`
    enables the application to be seen on the user's device and when the user taps
    on the application, `MainActivity` (see the activity tag) in the application is
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `intent-filter` for defining a URI scheme for the application can
    be added to the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `<data>` tag is used to specify the URI scheme for the application.
    The `android:scheme` attribute in the `<data>` tag is used to specify the scheme
    name and the `android:host` attribute is used to specify the type of `hostname`
    to use for the application. Thus the `deeplink://app.chapter7.com` URI is used
    to access the home page in the application. A route with the `/dashboard` path
    can be accessed using this URI: `deeplink://app.chapter7.com/dashboard`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to use React Router's `<DeepLinking>` component so that the
    application can react to the incoming request and navigate the user to the request
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Including the <DeepLinking> component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<DeepLinking>` component in the `react-router-native` package uses React
    Native's `Linking` interface to listen to the changes in the URL. Whenever a change
    is detected, the user is navigated to the requested path by adding an entry in
    the history stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<DeepLinking>` component can be included anywhere in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `<DeepLinking>` component is included in the `RootComponent` of the
    application, and also the `<Route>` paths are updated with the prefix `app.chapter7.com` to
    match the hostname declared in the `AndroidManifest.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test deep-linking, try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous command should launch the application on the AVD and navigate you
    to the route with the `/dashboard` path.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how React Router's `<NativeRouter>` component
    can be used in a React Native application. The `<NativeRouter>` component is available
    in the `react-router-native` package, and it uses the `<MemoryRouter>` component
    internally, which is defined in the `react-router` package. The `<NativeRouter>`
    component accepts props: `initialEntries`, `initialIndex`, `getUserConfirmation`,
    `keyLength`, and `children`. Also, it provides a default implementation for the `getUserConfirmation`
    function, which uses React Native's `Alert` component to display a confirmation
    message. This confirmation message is shown when the `<Prompt>` component is included
    in the application and the user tries to navigate away from the current route.
  prefs: []
  type: TYPE_NORMAL
- en: The `<BackButton>` component in `react-router-native` is a wrapper around React
    Native's `BackHandler` class, which listens to the devices' back button and navigates
    the user back by one entry in the history stack. The `<DeepLinking>` component
    is used to handle deep links to the content in the application. The component
    uses React Native's `Linking` interface to listen to the URL changes and it navigates
    the user to the requested route when the application is accessed using a deep
    link URI scheme. To define a URI scheme for the application, the `AndroidManifest.xml` manifest
    file is updated with `<intent-filter>` for the main activity (`.MainActivity`). `intent-filter`
    declares the URI scheme and the hostname to use to access the content inside the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the state management tool, Redux,
    and understand how React Router can be used in conjunction with Redux.
  prefs: []
  type: TYPE_NORMAL
