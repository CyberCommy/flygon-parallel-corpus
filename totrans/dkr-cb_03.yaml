- en: Chapter 3. Working with Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an account with Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image from the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing an image to the registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the history of an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images using Dockerfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Apache image – a Dockerfile example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Firefox from a container – a Dockerfile example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a WordPress image – a Dockerfile example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a private index/registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated Builds – with GitHub and Bitbucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the base image – using supermin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the base image – using Debootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing dependencies between layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on operations relating to images. As we know,
    images are required to run containers. You can either use existing images or create
    new custom images. You will need to create custom images to suit your development
    and deployment environment. Once you create an image, you can share it through
    the public or private registry. Before we explore more about Docker images, let''s
    look at the output of the `docker info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding command gives the current system-wide info as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It has 21 containers and 21 images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current storage driver, `devicemapper`, and its related information, such
    as thin pool name, data, metadata file, and so on. Other types of storage drivers
    are aufs, btrfs, overlayfs, vfs, and so on. Devicemapper, btrfs, and overlayfs
    have native support in the Linux kernel. AUFS support needs a patched kernel.
    We talked about the Union filesystem in [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction
    and Installation"), *Introduction and Installation*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To leverage the kernel features that enable containerization, the Docker daemon
    has to talk to the Linux kernel. This is done through the execution driver. `libconatiner`
    or `native` is one of that type. The others are `libvirt`, `lxc`, and so on, which
    we saw in [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction and Installation"),
    *Introduction and Installation*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel version on the host operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user account that is registered on the registry mentioned in the next section
    to pull/push images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am using Fedora 20/21 as my primary environment to run the recipes. They should
    also work with other environments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an account with Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub is like GitHub for images. It is a public registry on which you can
    host images both public and private, share them and collaborate with others. It
    has integration with GitHub, Bitbucket, and can trigger automated builds.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, the creation of an account on Docker Hub is free. A repository can
    hold different versions of an image. You can create any number of public repositories
    for your images. By default, you will have one private repository, which will
    not be accessible to the public. You can buy more private repositories. You can
    create an account either through a web browser or from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To sign up from the command line, you will need to have Docker installed on
    your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create an account through a web browser on Docker Hub, visit [https://hub.docker.com/account/signup/](https://hub.docker.com/account/signup/)
    and create an account:![How to do it…](../Images/image00298.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create an account using the command line, run the following command and
    submit the required details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding steps will create a Docker Hub account for you. Once the account
    is created, you'll get a confirmation mail, through which you need to confirm
    your identity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The documentation on the Docker website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-hub](https://docs.docker.com/docker-hub)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-hub/accounts/](https://docs.docker.com/docker-hub/accounts/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image from the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of ways to create images, one is by manually committing layers
    and the other way is through Dockerfiles. In this recipe, we'll see the former
    and look at Dockerfiles later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As we start a new container, a read/write layer gets attached to it. This layer
    will get destroyed if we do not save it. In this recipe, we will see how to save
    that layer and make a new image from the running or stopped container using the
    `docker commit` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a Docker image, start a container with it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do the commit, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's start a container and create/modify some files using the `install httpd`
    package:![How to do it…](../Images/image00299.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open a new terminal and create a new image by doing the commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the new image is now being committed to the local repository
    with `nkhare/fedora` as a name and `httpd` as a tag.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction and Installation"),
    *Introduction and Installation*, we saw that while starting a container, a read/write
    filesystem layer will be created on top of the existing image layers from which
    the container started, and with the installation of a package, some files would
    have been added/modified in that layer. All of those changes are currently in
    the ephemeral read/write filesystem layer, which is assigned to the container.
    If we stop and delete the container, then all of the earlier mentioned modifications
    would be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Using commit, we create a new layer with the changes that have occurred since
    the container started, which get saved in the backend storage driver.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To look for files, which are changed since the container started:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we will see something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a prefix before each entry of the output. The following is a list
    of those prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A`: This is for when a file/directory has been added'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C`: This is for when a file/directory has been modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: This is for when a file/directory has been deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, a container gets paused while doing the commit. You can change its
    behavior by passing `--pause=false` to commit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker commit`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#commit](https://docs.docker.com/reference/commandline/cli/#commit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing an image to the registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you have created an image that suits the development environment in
    your organization. You can either share it using tar ball, which we'll see later
    in this chapter, or put in a central location from where the user can pull it.
    This central location can be either a public or a private registry. In this recipe,
    we'll see how to push the image to the registry using the `docker push` command.
    Later in this chapter, we'll cover how to set up the private registry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need a valid account on Docker Hub to push images/repositories.
  prefs: []
  type: TYPE_NORMAL
- en: A local registry must be set up if you are pushing images/repositories locally.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By default, the preceding command will use the username and registry shown in
    the `docker info` command to push the images. As shown in the preceding screenshot,
    the command will use `nkhare` as the username and `https://index.docker.io/v1/`
    as the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push the image that we created in the previous section, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's say you want to push the image to the local registry, which is hosted
    on a host called `local-registry`. To do this, you first need to tag the image
    with the registry host's name or IP address with the port number on which the
    registry is running and then push the images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s say our registry is configured on `shadowfax.example.com`,
    then to tag the image use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to push the image, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It will first list down all the intermediate layers that are required to make
    that specific image. It will then check to see, out of those layers, how many
    are already present inside the registry. At last, it will copy all the layers,
    which are not present in the registry with the metadata required to build the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we pushed our image to the public registry, we can log in to Docker Hub
    and look for the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](../Images/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker push`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#push](https://docs.docker.com/reference/commandline/cli/#push)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the history of an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is handy to know how the image that we are using has been created. The `docker
    history` command helps us find all the intermediate layers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pull or import any Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To look at the history of the image, consider the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example using the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the metadata of an image, Docker can know how an image is being created.
    With the `history` command, it will look at the metadata recursively to get to
    the origin.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the commit message of a layer that got committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Currently, there is no direct way to look at the commit message for each layer
    using one single command, but we can use the `inspect` command, which we saw earlier,
    for each layer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker history`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#history](https://docs.docker.com/reference/commandline/cli/#history)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To remove the image from the host, we can use the `docker rmi` command. However,
    this does not remove images from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure one or more Docker images are locally available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove the image, consider the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, here''s an example using the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to remove all containers and images, then do following; however,
    be sure about what you are doing, as this is very destructive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop all containers, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete all containers, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete all images, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker rmi`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#rmi](https://docs.docker.com/reference/commandline/cli/#rmi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you have a customer who has very strict policies that do not allow
    them to use images from the public domain. In such cases, you can share images
    through tarballs, which later can be imported on another system. In this recipe,
    we will see how to do that using the `docker save` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pull or import one or more Docker images on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following syntax to save the image in the tar file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to create a tar archive for Fedora, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the tag name is specified with the image name we want to export, such as
    `fedora:latest`, then only the layers related to that tag will get exported.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If `--output` or `-o` is not used, then the output will be streamed to `STDOUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the contents of the container''s filesystem can be exported using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker save` and `docker export`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The documentation on the Docker website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/reference/commandline/cli/#save](https://docs.docker.com/reference/commandline/cli/#save)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/reference/commandline/cli/#export](https://docs.docker.com/reference/commandline/cli/#export)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a local copy of the image, we either need to pull it from the accessible
    registry or import it from the already exported image, as we saw in the earlier
    recipe. Using the `docker import` command, we import an exported image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need an accessible exported Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To import an image, we can use following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example using the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will first create an empty filesystem and then import
    the contents.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker import`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#import](https://docs.docker.com/reference/commandline/cli/#import)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images using Dockerfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockerfiles help us in automating image creation and getting precisely the same
    image every time we want it. The Docker builder reads instructions from a text
    file (a Dockerfile) and executes them one after the other in order. It can be
    compared as Vagrant files, which allows you to configure VMs in a predictable
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Dockerfile with build instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `Dockerfile` with the following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command inside the directory, where we created Dockerfile
    to build the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We did not specify any repository or tag name while building the image. We
    can give those with the `-t` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding output is different from what we did earlier. However, here we
    are using a cache after each instruction. Docker tries to save the intermediate
    images as we saw earlier and tries to use them in subsequent builds to accelerate
    the build process. If you don''t want to cache the intermediate images, then add
    the `--no-cache` option with the build. Let''s take a look at the available images
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](../Images/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A context defines the files used to build the Docker image. In the preceding
    command, we define the context to the build. The build is done by the Docker daemon
    and the entire context is transferred to the daemon. This is why we see the `Sending
    build context to Docker daemon 2.048 kB` message. If there is a file named `.dockerignore`
    in the current working directory with the list of files and directories (new line
    separated), then those files and directories will be ignored by the build context.
    More details about `.dockerignore` can be found at [https://docs.docker.com/reference/builder/#the-dockerignore-file](https://docs.docker.com/reference/builder/#the-dockerignore-file).
  prefs: []
  type: TYPE_NORMAL
- en: After executing each instruction, Docker commits the intermediate image and
    runs a container with it for the next instruction. After the next instruction
    has run, Docker will again commit the container to create the intermediate image
    and remove the intermediate container created in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the preceding screenshot, `eb9f10384509` is an intermediate
    image and `c5d4dd2b3db9` and `ffb9303ab124` are the intermediate containers. After
    the last instruction is executed, the final image will be created. In this case,
    the final image is `4778dd1f1a7a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](../Images/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `-a` option can be specified with the `docker images` command to look for
    intermediate layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The format of the Dockerfile is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generally, instructions are given in uppercase, but they are not case sensitive.
    They are evaluated in order. A `#` at the beginning is treated like a comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different types of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: This must be the first instruction of any Dockerfile, which sets the
    base image for subsequent instructions. By default, the latest tag is assumed
    to be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, consider the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There can be more than one `FROM` instruction in one Dockerfile to create multiple
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'If only image names, such as Fedora and Ubuntu are given, then the images will
    be downloaded from the default Docker registry (Docker Hub). If you want to use
    private or third-party images, then you have to mention this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example using the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`MAINTAINER`: This sets the author for the generated image, `MAINTAINER <name>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`: We can execute the `RUN` instruction in two ways—first, run in the shell
    (`sh -c`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, directly run an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we know with Docker, we create an overlay—a layer on top of another layer—to
    make the resulting image. Through each `RUN` instruction, we create and commit
    a layer on top of the earlier committed layer. A container can be started from
    any of the committed layers.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Docker tries to cache the layers committed by different `RUN` instructions,
    so that it can be used in subsequent builds. However, this behavior can be turned
    off using `--no-cache flag` while building the image.
  prefs: []
  type: TYPE_NORMAL
- en: '`LABEL`: Docker 1.6 added a new feature to the attached arbitrary key-value
    pair to Docker images and containers. We covered part of this in the *Labeling
    and filtering containers* recipe in [Chapter 2](part0022.xhtml#aid-KVCC1 "Chapter 2. Working
    with Docker Containers"), *Working with Docker Containers*. To give a label to
    an image, we use the `LABEL` instruction in the Dockerfile as `LABEL distro=fedora21`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`: The `CMD` instruction provides a default executable while starting a
    container. If the `CMD` instruction does not have an executable (parameter 2),
    then it will provide arguments to `ENTRYPOINT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Only one `CMD` instruction is allowed in a Dockerfile. If more than one is specified,
    then only the last one will be honored.
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`: This helps us configure the container as an executable. Similar
    to `CMD`, there can be at max one instruction for `ENTRYPOINT`; if more than one
    is specified, then only the last one will be honored:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once the parameters are defined with the `ENTRYPOINT` instruction, they cannot
    be overwritten at runtime. However, `ENTRYPOINT` can be used as `CMD`, if we want
    to use different parameters to `ENTRYPOINT`.
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPOSE`: This exposes the network ports on the container on which it will
    listen at runtime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can also expose a port while starting the container. We covered this in the
    *Exposing a port while starting a container* recipe in [Chapter 2](part0022.xhtml#aid-KVCC1
    "Chapter 2. Working with Docker Containers"), *Working with Docker Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV`: This will set the environment variable `<key>` to `<value>`. It will
    be passed all the future instructions and will persist when a container is run
    from the resulting image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`ADD`: This copies files from the source to the destination:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following one is for the path containing white spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`<src>`: This must be the file or directory inside the build directory from
    which we are building an image, which is also called the context of the build.
    A source can be a remote URL as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dest>`: This must be the absolute path inside the container in which the
    files/directories from the source will be copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY`: This is similar to `ADD.COPY <src> <dest>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`VOLUME`: This instruction will create a mount point with the given name and
    flag it as mounting the external volume using the following syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`USER`: This sets the username for any of the following run instructions using
    the following syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`WORKDIR`: This sets the working directory for the `RUN`, `CMD`, and `ENTRYPOINT`
    instructions that follow it. It can have multiple entries in the same Dockerfile.
    A relative path can be given which will be relative to the earlier `WORKDIR` instruction
    using the following syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`ONBUILD`: This adds trigger instructions to the image that will be executed
    later, when this image will be used as the base image of another image. This trigger
    will run as part of the `FROM` instruction in downstream Dockerfile using the
    following syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker build`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Apache image – a Dockerfile example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am going to refer Dockerfiles from the Fedora-Dockerfiles GitHub repo ([https://github.com/fedora-cloud/Fedora-Dockerfiles](https://github.com/fedora-cloud/Fedora-Dockerfiles))
    after forking it. If you are using Fedora, then you can also install the `fedora-dockerfiles`
    package to get the sample Dockerfiles in `/usr/share/fedora-dockerfiles`. In each
    of the subdirectories, you will put a Dockerfile, the supporting files and a README
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The Fedora-Dockerfiles GitHub repo would have the latest examples and I highly
    recommend that you try out latest bits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the Fedora-Dockerfiles Git repo using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the `apache` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The other supporting files are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: This is the README file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run-apache.sh`: This is the script to run `HTTPD` in the foreground'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`: This is the GPL license'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the following `build` command, we can build a new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build process takes a base image, installs the required `HTTPD` package
    and creates an HTML page. Then, it exposes port `80` to serve the web page and
    sets instructions to start Apache at the start of the container.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run the container from the created image, get its IP address, and access
    the web page from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](../Images/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker build`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Firefox from a container – a Dockerfile example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can do something more interesting through a Dockerfile, such as creating
    a container that just runs Firefox. This kind of use case can help run multiple
    browsers of different versions on the same machine, which can be very helpful
    in doing multibrowser testing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the Fedora-Dockerfiles Git repo using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Then, go to the `firefox` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Supporting files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: This is a README file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`: This is the GPL license'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xstartup`: This is the script to set up the X11 environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with the base Fedora image, install X Windows System, Firefox, a VNC
    server, and other packages. We then set up the VNC server to start X Windows System,
    which will start Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the container, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And give `123456` as the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'While running the container, we mapped the `5901` port of the host to `5901`
    port of the container. In order to connect to the VNC server inside the container,
    just run the following command from another terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, from another machine in the network, replace `localhost` with
    the Docker host's IP address or FQDN.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker build`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a WordPress image – a Dockerfile example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen the example of running just one service inside a container.
    If we want to run an application, which requires us to run one or more services
    simultaneously, then, either we will need to run them on the same container or
    run them on different containers and link them together. WordPress is one such
    example that requires a database and web service.
  prefs: []
  type: TYPE_NORMAL
- en: Docker only likes one process per container running in the foreground. Thus,
    in order to make Docker happy, we have a controlling process that manages the
    database and web services. The controlling process, in this case, is supervisord
    ([http://supervisord.org/](http://supervisord.org/)). This is a trick we are using
    to make Docker happy.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will use a Dockerfile from the Fedora-Dockerfiles repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the Fedora-Dockerfiles Git repo using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to the `wordpress_single_container` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The supporting files used in the preceding code are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`foreground.sh`: This is a script to run HTTPS in the foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`, `LICENSE.txt`, and `UNLICENSE.txt`: These files contain the license
    information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: This is a README file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`supervisord.conf`: This is a resulting container which will have to run `SSHD`,
    `MySQL`, and `HTTPD` at the same time. In this particular case, the supervisor
    is used to manage them. It is a configuration file of the supervisor. More information
    about this can be found at [http://supervisord.org/](http://supervisord.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start.sh`: This is a script to set up MySQL, HTTPD, and to start the supervisor
    daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the other recipes, we start with the base image, install the required
    packages, and copy the supporting files. We will then set up `sudo`, `download`,
    and `untar` WordPress inside the HTTPD document root. After this, we expose the
    ports and run the start.sh scripts, which sets up MySQL, WordPress, HTTPS permissions
    and gives control to supervisord. In the `supervisord.conf`, you will see entries,
    such as the following services that supervisord manages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start the container, get its IP address and open it through a web browser. You
    should see the Welcome screen, as shown in the following screenshot, after doing
    the language selection:![There's more…](../Images/image00310.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is now possible to run systemd inside the container, which is a more preferred
    way. Systemd can manage more than one service .You can look at the example of
    systemd at [https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/systemd](https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/systemd).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `help` option of `docker build`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a private index/registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier, the public Docker registry is the available Docker Hub ([https://registry.hub.docker.com/](https://registry.hub.docker.com/))
    through which users can push/pull images. We can also host a private registry
    either on a local environment or on the cloud. There are a few ways to set up
    the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Docker registry from Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build an image from Dockerfile and run a registry container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/registry](https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/registry)'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the distribution-specific package such as Fedora, which provides the
    docker-registry package that you can install and configure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest way to set it up is through the registry container itself.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the Docker daemon is running on the host and you can connect through
    the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the registry on the container, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the newly created registry, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a container and its ID by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed, attach to the newly created container and make some changes. Then,
    commit those changes to the local repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To push the image to the local registry, we need to tag the image with the
    hostname or IP address of the registry host. Let''s say our registry host is `registry-host`;
    then, to tag it, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have not configured HTTPS correctly while starting the registry, we will
    get an error such as the `ping attempt failed with error: Get https://dockerhost:5000/v1/_ping`,
    which is expected. For our example to work, we need to add the `--insecure-registry
    registry-host:5000` option to the daemon. If you have started the Docker daemon
    manually, then we have to run the command as follows to allow insecure registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To push the image, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To pull the image from the local registry, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding command to pull the image will download the official registry
    image from Docker Hub and run it on port `5000`. The `-p` option publishes the
    container port to the host system's port. We will look at the details about port
    publishing in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The registry can also be configured on any existing servers using the docker-registry
    app. The steps to do this are available at the docker-registry GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at Dockerfile of docker-registry to understand how the registry
    image is being created and how to set different configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding Dockerfile, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Take Ubuntu's base image install/update packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the docker-registry source code inside the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `pip install` docker-registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the configuration file to use while running the registry using the environment
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the flavor to use while running the registry using the environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose port `5000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the registry executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flavors in the configuration file (`/docker-registry/config/config_sample.yml`)
    provide different ways to configure the registry. With the preceding Dockerfile,
    we will set the `dev` flavor using the environment variables. The different types
    of flavors are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`common`: This is used by all the other flavors as base settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`: This stores data on the local filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s3`: This stores data in an AWS S3 bucket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev`: This is the basic configuration using the local flavors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: This is used by unit tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prod`: This is the production configuration (basically a synonym for the S3
    flavor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcs`: This stores data in Google cloud storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swift`: This stores data in OpenStack Swift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glance`: This stores data in OpenStack Glance, with a fallback to the local
    storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glance-swift`: This stores data in OpenStack Glance, with a fallback to Swift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elliptics`: This stores data in Elliptics key-value storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of preceding flavors, different configuration options such as loglevel,
    authentication, and so on are available. The documentation for all of the options
    are available on the GitHub page of docker-registry, which I mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation on GitHub [https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated builds – with GitHub and Bitbucket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen earlier how to push the Docker images to Docker Hub. Docker Hub
    allows us to create automated images from a GitHub/Bitbucket repository using
    its build clusters. The GitHub/Bitbucket repository should contain the Dockerfile
    and the content required to copy/add inside the image. Let's look at a GitHub
    example in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need an account on Docker Hub and GitHub. You will also need a GitHub
    repository with a corresponding Dockerfile at the top level.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log in to Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) and
    click on the green plus sign. Add the Repository icon on the top right-hand side
    corner and click on **Automated Build**. Select GitHub as a source to use for
    automated build. Then, select the **Public and Private (recommended)** option
    to connect to GitHub. Provide the GitHub username/password when prompted. Select
    the GitHub repository to perform automated build.![How to do it…](../Images/image00311.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the GitHub repository, it will ask you to pick its branch to
    use for automated build. It will also ask for a tag name to use after the image
    it automatically built. By default, the latest tag name will be used. Then, click
    on the **Save and trigger build** button to start the automated build process.
    That's it!! Your build is now submitted. You can click on the build status to
    check the status of the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we select a GitHub repository for automated build, GitHub enables the Docker
    service for that repository. You can look at the **Settings** section of the GitHub
    repository for more configuration. Whenever we make any changes to this GitHub
    repository, such as commits, an automated build gets triggered using the Dockerfile
    that resides in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](../Images/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can get the details such as the Dockerfile, build details tags, and other
    information, by going to the **Your Repositories** section. It also has the details
    of how to pull your image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](../Images/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The images that get created using the automated build process cannot be pushed
    through the `docker push` command.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the settings in the **Webhooks & Services** section of the repository
    on GitHub to unregister the Docker service. This will stop doing the automated
    builds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps for setting up automated build with Bitbucket are almost identical.
    The hook for automated build gets configured under the **Hooks** section of Bitbucket
    repository's **Settings** section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation on the Docker website [https://docs.docker.com/docker-hub/builds/](https://docs.docker.com/docker-hub/builds/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the base image – using supermin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we used the `FROM` instruction to pick the base image
    to start with. The image we create can become the base image to containerize another
    application and so on. From the very beginning to this chain, we will have a base
    image from the underlying Linux distribution that we want to use such as Fedora,
    Ubuntu, CentOS, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To build such a base image, we will need to have a distribution-specific base
    system installed into a directory, which can then be imported as an image to Docker.
    With chroot utility, we can fake a directory as the root filesystem and then put
    all the necessary files inside it before importing it as a Docker image. Supermin
    and Debootstrap are the kind of tools that can help us make the preceding process
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Supermin is a tool to build supermin appliances. These are tiny appliances,
    which get fully instantiated on the fly. Earlier this program was called febootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install supermin on the system where you want to build the base image. You
    can install supermin on Fedora with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `prepare` mode install `bash`, `coreutils`, and the related dependencies
    inside a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example using the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the `build` mode, create a chrooted environment for the base image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example using the preceding syntax :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do `ls` on the output directory, we will see a directory tree similar
    to any Linux root filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can export the directory as a Docker image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now, look at the `docker images` output. You should have a new image with `nkhare/f21_base`
    as the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Supermins has two modes, `prepare` and `build`. With the `prepare` mode, it
    just puts all the requested packages with their dependencies inside a directory
    without copying the host OS specific files.
  prefs: []
  type: TYPE_NORMAL
- en: With the `build` mode, the previously created supermin appliance from the `prepare`
    mode gets converted into a full blown bootable appliance with all the necessary
    files. This step will copy the required files/binaries from the host machine to
    the appliance directory, so the packages must be installed on the host machines
    that you want to use in the appliance.
  prefs: []
  type: TYPE_NORMAL
- en: The `build` mode has two output formats, chroot, and ext2\. With the chroot
    format, the directory tree gets written into the directory, and with the ext2
    format, a disk image gets created. We exported the directory created through the
    chroot format to create the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Supermin is not specific to Fedora and should work on any Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the `man` page of supermin for more information using the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The online documentation [http://people.redhat.com/~rjones/supermin/](http://people.redhat.com/~rjones/supermin/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub repository [https://github.com/libguestfs/supermin](https://github.com/libguestfs/supermin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the base image – using Debootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debootstrap is a tool to install a Debian-based system into a directory of an
    already installed system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install `debootstrap` on the Debian-based system using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following command can be used to create the base image using Debootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`SUITE` refers to the release code name and `MIRROR` is the respective repository.
    If you wanted to create the base image of Ubuntu 14.04.1 LTS (Trusty Tahr), then
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory on which you want to install the OS. Debootstrap also creates
    the chroot environment to install a package, as we saw earlier with supermin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using `debootstrap`, install Trusty Tahr inside the directory we created
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: You will see the directory tree similar to any Linux root filesystem, inside
    the directory in which Trusty Tahr is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can export the directory as a Docker image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now, look at the `docker images` output. You should have a new image with `nkhare/trusty_base`
    as the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Debootstrap wiki page [https://wiki.debian.org/Debootstrap](https://wiki.debian.org/Debootstrap).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few other ways to create base images. You can find links to them
    at [https://docs.docker.com/articles/baseimages/](https://docs.docker.com/articles/baseimages/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing dependencies between layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the number of images grows, it becomes difficult to find relation between
    them. There are a few utilities for which you can find the relation between images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One or more Docker images on the host running the Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command to get a tree-like view of the images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dependencies between layers will be fetched from the metadata of the Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From `--viz` to `docker` `images`, we can see dependencies graphically; to
    do this, you will need to have the `graphviz` package installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: As it states in the warning that appears when running the preceding commands,
    the `-t` and `--viz` options might get deprecated soon.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following project tries to visualize Docker data as well by using raw JSON
    output from Docker [https://github.com/justone/dockviz](https://github.com/justone/dockviz)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
