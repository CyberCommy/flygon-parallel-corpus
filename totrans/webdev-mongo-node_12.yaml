- en: Single Page Applications with Popular Frontend Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at web application development from the
    frontend perspective, specifically with a **Single Page Application** (**SPA**),
    also referred to as a thick client app. With an SPA, a large chunk of the presentation
    layer is offloaded to the browser, and the browser is responsible for rendering
    pages, handling navigation, and making data calls to an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we use a frontend framework, such as Backbone.js, Ember.js, or Angular.js?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a single page application exactly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular frontend development tools, such as Grunt, Gulp, Browserify, SAAS, and
    Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development on the frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use a frontend framework?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use frameworks to increase our productivity, keep us sane, and generally,
    to make our development process more enjoyable. In most of the chapters throughout
    this book, we worked with the Express.js MVC framework for Node.js. This framework
    allows us to organize our code, and it extrapolates out a lot of boilerplate code,
    freeing up our time to focus on our custom business logic. The same should be
    said for the front of an application, as well. Any amount of complex code is eventually
    going to need to be properly organized, and we need to use a standard set of reusable
    tools to achieve common tasks. Express.js makes our life easy when writing our
    backend code with Node.js. There are a number of popular frontend frameworks that
    you can rely on as well.
  prefs: []
  type: TYPE_NORMAL
- en: What is a single page application?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current trend with sophisticated web applications is to emulate desktop
    applications and veer away from the feel of a traditional website. With traditional
    websites, every interaction with the server requires a full-page postback that
    makes a complete round trip. As our web applications become more sophisticated,
    the need to send and retrieve data to and from the server increases.
  prefs: []
  type: TYPE_NORMAL
- en: If we rely on full-page postbacks every time, we need to facilitate one of these
    requests; our app will feel sluggish and unresponsive, as the user will have to
    wait for a full round trip with every request. Users demand more from their apps
    these days, and if you think about the application we've written, the Like button
    is a perfect example. Having to send a full-page postback to the server just because
    we wanted to increment a counter by one seems like a lot of unnecessary overhead.
    Fortunately, we were able to easily rectify this using jQuery and AJAX. This is
    a perfect example of how a single page application works (only on a much larger
    scale).
  prefs: []
  type: TYPE_NORMAL
- en: A great example of one of the first, standout single page applications is Google's
    Gmail. Gmail gives you an interface that is similar to Microsoft Outlook or any
    traditional desktop-based email client. User interaction with the application
    feels just as responsive as with a desktop application--the *page* never reloads,
    you can switch panes and tabs within the application with ease, and data is constantly
    being refreshed and updated in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an SPA typically involves having a single HTML page as the source
    of the application, which loads all of the necessary JavaScript in order to trigger
    a series of events that include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootstrapping the app**: This means connecting to the server via AJAX to
    download the necessary startup data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering the screens based on user actions**: This means monitoring events
    triggered by the user and manipulating the DOM so that sections of the app are
    hidden, revealed, or redrawn, which emulates the feel of a desktop application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communicating with the server**: This means using AJAX to constantly send
    and receive data from the server, which maintains the illusion of a stateful connection
    via the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TodoMVC project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When deciding which frontend framework to choose for your next large-scale frontend
    project, the decision making process can be crippling! Keeping track of all of
    the different frameworks and the pros and cons of each can seem like an exercise
    in futility. Luckily, people have answered the call, and a handy website exists
    to not only demonstrate the same application written in nearly every framework,
    but to also offer the complete annotated source code for each as well!
  prefs: []
  type: TYPE_NORMAL
- en: 'The TodoMVC project, [http://todomvc.com](http://todomvc.com), is a website
    that focuses on creating a simple, single page, to-do application, which is written
    using each of the proven JavaScript MVC frameworks; there''s even one written
    in vanilla JavaScript! So, the easiest way to jump into a framework would be to
    take a look at its TodoMVC code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75bee610-53e1-45ed-9e70-80206a1ee6a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Definitely spend some time checking out the website and digging into each of
    the featured frameworks. You can get a really good feel for the different frameworks
    by seeing the same code written in completely different ways; no two are identical,
    and ultimately, it's up to you to evaluate and figure out which you prefer and
    why.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, I'm going to focus on the three that I personally like
    and believe are at the top of the current list of front runners.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Backbone.js** is an extremely lightweight (6.5 KB in production) MV* framework
    that has been around for a few years. It has an extremely large established user
    base, and many large-scale web applications have been written using this framework:'
  prefs: []
  type: TYPE_NORMAL
- en: USA Today
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hulu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trello
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disqus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Khan Academy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walmart Mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backbone.js is a great framework to start with if you're comfortable with jQuery
    and have been using it for a while and want to start improving your code organization
    and modularity. Additionally, Backbone.js requires jQuery and integrates it pretty
    tightly, so that's one less thing to worry about learning as you ease into this
    new world of frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backbone.js works on the basic idea of models, collections, views, and routers.
    Take a look at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Models are the basic elements that store and manage all of the data in your
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections store models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views render HTML to the screen, retrieving dynamic data from models and collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers power the URLs of your application, allowing each individual section
    of your application its own unique URL (without actually loading live URLs) and
    ultimately tying the whole thing together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As Backbone.js is so lightweight, an extremely small and simple set of sample
    code can be put together very quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The one thing to notice is that Backbone.js, by its very nature, is so lightweight
    that it doesn't include most of the functionalities that you'd expect to work
    right out of the box. As you can see in the preceding code, in the `View` object
    that we created, we had to provide a `render` function that manually renders the
    HTML for us. For this reason, many people shy away from Backbone.js, but others
    embrace it for the raw power and flexibility it gives to developers.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, you wouldn't put all of your code into a single file, like in
    the earlier example. You would organize your models, collections, and views into
    individual folders in a structure, just like we organized the code in our Node.js
    application. Bundling all of the code together would be the job of a build tool
    (which will be discussed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Backbone.js by visiting its official website at [http://backbonejs.org](http://backbonejs.org).
    Also, don't forget to check out the Backbone.js implementation of the to-do application
    on the TodoMVC website!
  prefs: []
  type: TYPE_NORMAL
- en: I maintain a repository on GitHub that has a boilerplate web application with
    complete code that uses the full stack we've covered in this book, as well as
    Backbone.js with Marionette for the frontend. Feel free to check it out at [http://github.com/jkat98/benm](http://github.com/jkat98/benm)
    (Backbone, Express, Node, and MongoDB).
  prefs: []
  type: TYPE_NORMAL
- en: Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember.js bills itself as the *framework for creating ambitious web applications*.
    Ember's goal is to target fairly large-scale SPAs, so the idea of using it to
    build something very simple might seem like overkill, but it is certainly doable.
    A fair assessment is to take a look at the production file size of the Ember library,
    which comes in at around 90 KB (versus 6.5 KB for Backbone.js). That being said,
    if you are building something very robust with a very large code base, the added
    90 KB might not be a big deal for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very small sample application using Ember.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ember.js's code looks somewhat similar to that of Backbone.js, and it's no surprise
    that a lot of seasoned Backbone.js developers find themselves migrating to Ember.js
    as their need for more robust solutions increases. Ember.js uses familiar items,
    including views, models, collections, and routes, as well as an `Application`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Ember.js features components, which is one of its more powerful
    and beloved features. Giving a sneak preview of the future of the web, components
    allow you to create small, modular, reusable HTML components that you can plug
    into your application as needed. With components, you can basically create your
    own custom HTML tags that look and behave exactly how you define them, and they
    can be reused easily throughout an application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing with Ember.js is all about convention. Unlike Backbone.js, Ember.js
    tries to get a lot of the boilerplate out of the way and makes certain assumptions
    for you. Because of this, you need to do things a certain way, and controllers,
    views, and routes need to follow a somewhat strict pattern with regards to naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: The Ember.js website features incredible online documentation and Getting Started
    guides. If you're interested in learning more about Ember.js, check it out at
    [http://emberjs.com/guides/](http://emberjs.com/guides/). Also, don't forget to
    take a look at the TodoMVC implementation!
  prefs: []
  type: TYPE_NORMAL
- en: React.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There has never been such a great race for adapting new JavaScript technologies.
    It''s the best time for JavaScript. The Facebook team has a strong contender known
    as `React.js`. So, unlike other MVC frameworks such as Angular, `React.js` is
    just a view from Model-View-Controller. It is lightweight and renders with amazing
    speed. The basic encapsulated unit of code is called a component. These components
    are composed together, forming a whole UI. Let''s create a simple component using
    the es6 class for the greeting example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet created a simple class to greet the users. We extended
    `React.component` to provide its public methods and variables to be accessible
    in the `Greet` class. Each component created requires a `render` method, which
    contains the html template of the respective component. The `props` is the public
    variable use to pass the data from containers to child components, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to load the component in our HTML document. To do this, we need
    to register under the `reactDOM` API, which is provided globally by the `React.js`
    library. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method of the `ReactDOM` object requires two parameters. First
    the root node, and second, the root element. The root node is an element used
    to declare a host for the different parent components. The root element `<div
    id="root" />` is written in the body of our `index.html` to host the entire view
    of the `React` components.
  prefs: []
  type: TYPE_NORMAL
- en: '`reactDOM` is responsible for creating a virtual DOM and observes for any changes
    to be made to each component. Only the changed/acted on part is re-rendered, keeping
    other components intact. This boosts up the performance of application. The changes
    in the components we read about are also called states of the components maintained
    by different libraries such as `reflux.js` or `redux.js`. [](http://redux.js/)
    Another important feature is one-way binding using props. The props are only a
    way to pass data to the view. Once the scaffold and the data flow are set, the
    react projects provide great scalable code and ease of maintenance for complex
    projects. There is a huge list of projects on React.js [https://github.com/facebook/react/wiki/sites-using-react](https://github.com/facebook/react/wiki/sites-using-react).
    Once you get comfortable with the react web app, you can easily switch to react
    native which create amazing native mobile applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular exploded onto the scene because of the simple fact that it's built by
    Google (it is open source). Angular is basically like putting HTML on steroids.
    The applications and pages that you create use regular HTML that we're all used
    to, but they include a number of new and custom directives that extend the core
    functionality of HTML, giving it awesome new power.
  prefs: []
  type: TYPE_NORMAL
- en: Another great feature of Angular, which has seasoned non-web developers flocking
    to it is that it is built from the group to be heavily tested and supports dependency
    injection. It's a framework that doesn't make creating sophisticated web applications
    feel like traditional web development.
  prefs: []
  type: TYPE_NORMAL
- en: Make no mistake, however; JavaScript still plays a huge role in the development
    of Angular. The new Angular 2.0, which is now 4.0, is already one of the most
    extensively used frameworks of today. It has not only introduced TypeScript for
    syntactical modularity of code, but also provides new semantics, such as components
    (instead of controllers), pipes, life cycle hooks, and more features. Let's learn
    more about Angular by implementing a simple client application that consumes the
    phone-API created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Angular.js, Angular 2.0 is a whole framework, rather than a single includable
    file. This framework comes with a bunch of features, such as rxJs, TypeScript,
    systemJs, and so on, which provide an integrated development of code. The Angular
    team has provided simple steps to set up Angular 2.0 seed application. However,
    a developer can also create a manual list of the minimal files required for Angular
    projects, though it is not recommended and is also time consuming. For our client
    prototype, we will follow the Angular quick-start steps provided by [angular.io](http://angular.io/)
    and then integrate our functionality in to it. Let's follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding the Angular app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to [https://angular.io/guide/quickstart](https://angular.io/guide/quickstart)
    and follow the three step procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `Angular/cli`. It is globally installed with the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new project and name it `phonebook-app` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go to the `phonebook-app` directory by `cd phonebook-app`. Finally, serve the
    application with `ng serve --open`. The `ng serve` command is used to watch for
    changes while developing, transpiling, and rebuilding the app. `--open` is an
    optional command-line argument used to open the app in a browser tab. Here, in
    case you receive an error, make sure you reinstall npm packages by the **`npm
    install`** command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Google definition of transpile is the process of converting source code
    in one language to another language, which has a similar level of abstraction.
    Simply, this means we will write code in TypeScript, which is to be converted
    to JavaScript (as it works in a browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'Explaining each file in the project is out of the context of this book, however,
    we will mainly focus on Angular basic building blocks to get it started. Our main
    concern is the `src/app` directory for now. Before we create the components, let''s
    add Twitter''s bootstrap link for the basic styling of our app[.](http://app.in/)
    In our `src` directory, we have `index.html`. Insert the following HTML code in
    the `header` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Understanding TypeScript and es6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript that compiles to clean the JavaScript
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '- [https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name suggests, TypeScript implies type languages, which require us to
    specify data types during data declaration in code. This can be seen in different
    languages, such as Java, C#, and so on. In TypeScript, the declaration of a variable
    is done using an annotation colon, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, JavaScript contains most (not all) of the object-oriented features.
    So, it can be implemented semantically, but there is no provision syntactically
    . For example, an important feature of OOP is the encapsulation; let''s compare
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **TypeScript code** | **JavaScript code (ES5)** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, the frameworks that uses TypeScript as its primary scripting language
    compiles (transpiles) it into es5 JavaScript. The new es6 acts as a bridge between
    es5 and TypeScript. To date, es6 has gradually implemented TypeScript features
    into JavaScript for example classes. Knowing this, it will be easy for us to understand
    the usage of TypeScript in Angular framework. For more in depth learning, we can
    refer [https://www.TypeScriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html).
  prefs: []
  type: TYPE_NORMAL
- en: Modules and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular 2.0 provides a component-based approach for the reusability of code,
    as well as its maintainability. By visualizing each functional group of elements
    as a component, it is easy to replicate or reuse them. Let''s create a wireframe
    for our project so that we can pick out those components from our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc8b87f6-1a38-4d03-bc22-63525f3858e0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our project structure, we already have `app.component.ts` as our component
    file. We already have our `app-root` component specified in the `selector` property
    of component metadata. This file will be used for handling the root or parent
    element. According to the preceding wireframe, this file contains the `app-root`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure we have a class attached for each component so that we can export
    a `component` class and register it as an Angular component in `app.modules.ts`.
    For brevity, we follow the standard naming convention of capitalizing the first
    letter of the class name, followed by importing the Angular class prefix that
    is a component. So in the app `module.ts` file, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once registered with `NgModule`, we need to pass the root component to the bootstrap
    method/property. Bootstrap handles the loading on to the platform we decide to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per design, in app components, we just have an outline that will act as
    a container for other components, so accordingly, let''s create a template. Create
    a file with HTML code, `app.component.html` and its relative css file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.component.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`app.component.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After running this code, we get a simple outline in the browser. Use `ng serve`
    to run the app.
  prefs: []
  type: TYPE_NORMAL
- en: Angular data flow architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a brief idea of data flow, let''s make a comparative study of how MVC
    is implemented in Angular. Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a089bd9-0472-4ee0-a62f-613e4bcd9e77.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The diagram consists of basic blocks in Angular 2.0, and not all the facets.
    The model consists of static data or synchronous data classes, which are extended
    or imported in components. The components act as controllers that contain business
    logic. Each component has metadata, which connects it with templates. Finally,
    the data is bound to the `component` class variables and is available in templates.
    Now, for our application, we need the contact data list to be displayed; hence,
    we will be using this feature of data bindings in our new component file `list.component.ts`.
    This file provides the logic for listing the contacts in the phonebook. Always
    follow the three step procedure to include a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a metadata and a class for the list component with its template. So,
    we have `list.component.ts`, which consists of the following code :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It also consists of its template, `list.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the component in `app.module` and register it within the declaration
    property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This third step is to include the template for rendering the component. We
    already have our root component `root-app`. So, uncomment the `list` tag from
    `app.component.htm`. This can be done as follows :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding snippet contains static data that is binded to the `phoneList`
    property and thus rendered accordingly, which is a synchronous operation. Now,
    what if we need the asynchronous data to be displayed? Let''s consume our phonebook
    APIs and create an HTTP service for our client so that we can display the asynchronous
    data. Let''s create a service file called `phonebook.service.ts`. This file contains
    all the HTTP `request` methods required to get and set the data. For now, let''s
    create a `getContactlist` method, which will get all the contact data present
    on the server. The required code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we imported the `HttpClient` service for making XML HTTP requests from
    our browser. The `Injectable` function is needed to make this file a service provider.
    The metadata in the injectable is not provided as Angular itself will emit the
    metadata. Next, we will be using this service by injecting it inside the component's
    `constructor`. We have passed a parameterized value in the constructor, which
    is referred to as the dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the current code to the following code of `list.components.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to register the service under the providers in `app.modules`,
    as we are using it across the app. At this step, we need to have the following
    code in `app.modules`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And include it in the providers list of `ngModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For using the `Httpclient` service, we first need to register `httpModule` in
    `NgModules`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure our phonebook API node server is already running. If not, start
    it using `npm start`, and once we start `ng serve --open`, we will be receiving
    the list of superheroes contacts from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Last but not least, we need to create a form component called `add`, which
    adds a new phone record. In Angular, there are two ways to build a form: template-driven
    forms and reactive forms. As the reactive form is a new feature of Angular, we
    will be implementing it. To put it simply, reactive forms provide for the control
    of form directives through code logic and not in partials. Let''s check it out
    by implementing them for our phonebook app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new component files to be created are `add.component.ts` and its `.html`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you may observe some new facets of Angular. They are
    explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormControl` and `FormGroup`: Importing the `FormControl`, which is a directive
    that takes model data as an input and creates an instance of form elements. These
    form elements can be aggregated or grouped using `FormGroup`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Validators`: The class validators provide methods to validate the form elements.
    They are passed as a second optional argument to `FormControl`, to configure the
    validation of an element. It sets a Boolean property as valid, according to conditions
    applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Output` and `EventEmitter` will be explained later. So once we have our
    code ready, let''s create its template as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can investigate if `formGroup` is a directive that
    takes the public variable as input that is `newRecordForm`. We have an event handler
    called `ngSubmit` with public method `onSubmit`. This method is responsible for
    saving the contact details to our server. The last requirement here is that we
    map the properties of `newRecordForm` to `formControlName` so that the code logic
    is mapped to appropriate elements in the template. Classes such as `form-control`
    are used for HTML elements and are just bootstrap classes for a basic design.
  prefs: []
  type: TYPE_NORMAL
- en: Component communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to add one more change in `app.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add a change in `app.component.ts`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This change is required to communicate between two components. What is this
    communication required for?
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add a new record in the `add` component, it needs to send the newly
    added data to the list component, which cannot be bound directly, so we use `@output`
    to bind the data back to the parent. The `EventEmitter` is used to emit the response
    data via the binding in the app template, which can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<add (onAdded)="onAddedData($event)"></add>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the app component acts as a bridge between them. Once the parent receives
    the data in the `AddedData` method, it communicates to its child list component
    via the `@input` binding of the `listData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Watch for the changes in the browser; the `form` component adds new data to
    the list and our phonebook app is ready for its first prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend frameworks have recently taken on somewhat religious undertones. Post
    a negative comment or criticism about a particular framework and it's likely you'll
    get blasted by its supporters. Likewise, talk positively about a particular framework,
    and again, it's likely you'll get attacked about how much better a different framework
    handles the same topic. The bottom line when deciding which framework is right
    for you and/or your project is typically going to be about personal preference.
    Each of the frameworks featured on the TodoMVC website can clearly accomplish
    the same goals, each in its own unique way. Take some time to evaluate a few and
    decide for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Frontend development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the sophisticated nature of single page applications, there exists a
    growing suite of tools a frontend developer needs to be familiar with to manage
    many day-to-day, and sometimes, minute-to-minute tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Automated build task managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **build tool** is just what it sounds like--a tool used to build your application.
    When a frontend developer creates and maintains an application, there could be
    a number of tasks that need to be repeated literally every time a file is changed
    and saved. Using a build tool, a developer can free up time and mental resources
    by offloading the responsibility to an automated task manager that can watch files
    for changes and execute any number of tasks needed. These tasks might include
    any number of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uglification and obfuscation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency installation and preparation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom script firing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent watchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server launching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the more popular build tools today include Grunt, Gulp, and Broccoli.
    Grunt.js has been around for a number of years and is very well established in
    the development community. Gulp and Broccoli are fairly new but quickly gaining
    traction and work a little differently than Grunt. With Grunt, you define and
    manage your tasks using a configuration file, whereas with Gulp and Broccoli,
    you write Node.js code and use the raw power of streams. Many developers find
    working with Grunt's configuration file to be fairly convoluted and frustrating
    and find working with Gulp to be a refreshing change. However, it's hard to dispute
    Grunt's history and popularity.
  prefs: []
  type: TYPE_NORMAL
- en: All three are feature-extensive ecosystems of plugins that help automate literally
    everything and anything you can think of in your build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample output from a typical Grunt `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29c69e1a-9654-4c3c-a05f-e5857fb688e4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a typical single page application, the build manager can be responsible for
    downloading and installing dependencies, concatenating multiple JavaScript files
    into a single file, compiling and shimming Browserify modules, linting JavaScript
    files for syntax errors, transpiling LESS files into production-ready CSS files,
    copying files to a runtime destination, watching files for changes to repeat any
    of the tasks again, and finally, running appropriate tests any time the code is
    changed--all from a single command!
  prefs: []
  type: TYPE_NORMAL
- en: 'Grunt can be installed using `npm` and should be installed globally. Execute
    the following command to install the Grunt CLI on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the getting-started guide on the official Grunt.js website for more
    information at [http://gruntjs.com/getting-started](http://gruntjs.com/getting-started).
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, feel free to check out Gulp and Broccoli as well, for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gulpjs.com/](http://gulpjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/broccolijs/broccoli](https://github.com/broccolijs/broccoli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are literally millions of JavaScript libraries that exist to help you
    with everything from DOM manipulation (`jquery`) to timestamp formatting (`moment.js`).
    Managing these libraries and dependencies can sometimes be a bit of a headache.
    For the frontend, the dependency manager of choice is Bower.io.
  prefs: []
  type: TYPE_NORMAL
- en: Bower works in almost exactly the same way as npm; it manages the packages in
    the `bower.json` file. While working on the frontend (you need a known JavaScript
    library or plugin, such as underscore, for example), simply execute `bower install
    underscore` and the JavaScript files will be downloaded to a local `bower_components`
    folder in your project. From there, you can automate the inclusion of those scripts
    by updating your build process or by simply copying the file, including a script
    tag in your HTML; then, you're all set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bower can be installed using npm and should be installed globally. Execute
    the following command to install Bower on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Visit the Bower.io website ([http://bower.io](http://bower.io)) for more information,
    as well as the full directory of scripts available to be installed via `bower
    install`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing large JavaScript applications, the key is to keep your source code
    well-organized and structurally sane. Unfortunately, JavaScript doesn't inherently
    support the idea of modular code very well right out of-the-box. To solve this
    problem, two popular libraries exist to allow you to write modular code and to
    rely on only the modules you need within each individual piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'An absolute must-read and incredible resource for frontend design patterns
    is Addy Osmandi''s *Learning JavaScript Design Patterns*, which you can read for
    free by visiting the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://addyosmani.com/resources/essentialjsdesignpatterns/book/](http://addyosmani.com/resources/essentialjsdesignpatterns/book/)'
  prefs: []
  type: TYPE_NORMAL
- en: Require.js and Browserify are two of the most popular module loaders today.
    Each has a very unique syntax and its own set of benefits. Require.js follows
    asynchronous module definitions, which means each piece of code needs to define
    its own dependencies. Personally, I've worked with Require.js in the past, and
    I've recently found that I really like working with Browserify. One of Browserify's
    strengths is that it uses the same modular pattern as Node.js; so, writing frontend
    code using Browserify feels identical to that of Node. You use `module.exports`
    and `require` on the frontend, and you don't have to worry about the syntax context
    switching if you go back and forth between Node and the frontend within the same
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Using a module loader in conjunction with one of the popular MVC frameworks
    mentioned earlier is almost a requirement, because the two go together like peanut
    butter and jelly!
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://browserify.org/](http://browserify.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://requirejs.org/](http://requirejs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML template-rendering engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, we've already covered the idea of HTML template-rendering engines
    throughout the course of this book. The topics and concepts transfer directly
    to frontend applications as well. There are many different HTML template engines
    to choose from for use in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Many template engines will be mustache-based, meaning that they use `{{` and
    `}}` for merge variables. Handlebars is currently my personal favorite, mainly
    because it works so well in the backend and frontend of an application, and I
    really like working with its helpers. Underscore.js has a built-in `lite` template-rendering
    engine for use with Backbone.js, but its syntax uses `<%` and `%>` (much like
    classic ASP or ASP.net MVC Razor syntax). Typically, most frontend MVC frameworks
    allow you to customize the template-rendering engine and use any engine you want.
    For example, Backbone.js can be set up to use Handlebars.js very easily, instead
    of using Underscore.js by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s just a small sample list of some of the currently available frontend
    template-rendering engines:'
  prefs: []
  type: TYPE_NORMAL
- en: "**Underscore.js**: [http://underscorejs.org\uFEFF](http://underscorejs.org)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handlebars**: [http://handlebarsjs.com](http://handlebarsjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mustache**: [http://mustache.github.io](http://mustache.github.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dust.js**: [http://akdubya.github.io/dustjs](http://akdubya.github.io/dustjs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EJS**: [http://embeddedjs.com](http://embeddedjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these will work at the backend as well as on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: CSS transpiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of using variables and logic within a CSS file sounds like a dream
    come true, right? We aren't quite there yet (in the browser, anyway); however,
    there are a few tools that will let us use variables and logic in our CSS files
    and compile them during our build step. LESS and SASS are two of the most popular
    CSS transpilers currently available. They behave almost identically, with only
    slight differences in syntax and features. The big difference is that LESS was
    written using JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: and Node, whereas SASS uses Ruby; therefore, each has different requirements
    to get running on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample SASS style sheet file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the sample code, you can see that we have a few new elements that
    wouldn''t typically work in a regular CSS file. Some of these include:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom variables for use throughout the style sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining mixins, which act as pseudo functions for reusable styles (with dynamic
    parameters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixins and variables within our style definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting styles with parent/child relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the previous code is transpiled using LESS (or in the case of the sample
    code SASS), the output is a standard `.css` style sheet that adheres to all the
    normal browser rules and syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on LESS and SASS, check out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lesscss.org](http://lesscss.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://sass-lang.com](http://sass-lang.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of a sophisticated frontend application is no different than
    any other software application. The code is going to be complicated and robust,
    and there's no reason not to write tests, as well as a practice test-driven development.
    The availability of testing frameworks and languages for the frontend is just
    as robust as for any other language. All of the tools and concepts we've used
    for testing the Node.js code that we've written in this book can be used directly
    on the frontend as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other tools to consider for testing your frontend JavaScript are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Karma for running tests**: [http://karma-runner.github.io](http://karma-runner.github.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine for writing tests**: [http://jasmine.github.io](http://jasmine.github.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhantomJS headless browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing I'd like to point out with testing frontend code is that typically,
    the test runners want to run in a browser window. This is great and makes perfect
    sense, but in the real world, automating your tests or quickly executing them
    with TDD can be a bit painful when a browser window wants to open every time your
    test suite runs. PhantomJS is an available *headless* browser that works perfectly
    in this kind of scenario. A headless browser simply means it's a browser that
    runs from the command line, in memory, with no actual interface (like a typical
    browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily configure Karma to launch the test suite using PhantomJS instead
    of your browser of choice. When using PhantomJS as your browser, your tests execute
    behind the scenes, and only errors are reported. Here is a sample output of a
    test suite running with Karma using PhantomJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b13ab011-5663-4bb3-9120-36d146cdaaf3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a whirlwind tour of some of the most common frontend tools and frameworks
    used when doing typical web development. We took a look at the TodoMVC project
    and reviewed three popular JavaScript frameworks to build robust and sophisticated
    frontend applications.
  prefs: []
  type: TYPE_NORMAL
- en: Popular build tools such as Grunt.js, Gulp, and Broccoli help developers streamline
    their workflow process by automating a lot of the repetitive tasks that need to
    occur every time a file is modified. From concatenating scripts into a single
    file, to minifying and compressing, to executing automated test suites, the task
    runners can be configured to handle pretty much everything under the sun!
  prefs: []
  type: TYPE_NORMAL
- en: We took a look at two popular CSS transpilers with LESS and SASS and saw how
    they can make creating and managing CSS style sheets dynamic with the use of mixins,
    variables, and nesting.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about PhantomJS, the headless browser, and using it when
    running frontend tests so that the tests can be executed quickly and easily from
    the command line using a test runner like Karma.
  prefs: []
  type: TYPE_NORMAL
