- en: Chapter 9. The Java Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will examine the structure of a Java application from the
    perspective of packages. The use of the packages and import statements will be
    covered, along with the underlying directory structure used for packages.
  prefs: []
  type: TYPE_NORMAL
- en: We will also see how Java supports internationalization through the use of locales
    and resource bundles. An introduction to the use of JDBC will be presented, as
    well as examining how unused objects are reclaimed. This is commonly referred
    to as **garbage collection** .
  prefs: []
  type: TYPE_NORMAL
- en: Code organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The organization of code is an essential part of an application. One can go
    as far as to say that it is this organization (along with data organization) that
    determines the quality of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Java application is organized around packages. Packages contain classes.
    Classes contain data and code. Code is found in either an initializer list or
    in a method. This basic organization is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code organization](img/7324_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code can be thought of as being both static and dynamic in nature. The organization
    of a Java program is structured statically around packages, classes, interfaces,
    initializer lists, and methods. The only change in this organization comes from
    different versions of an executing program. However, as a program executes, the
    myriad of different possible execution paths result in an often complex sequence
    of execution.
  prefs: []
  type: TYPE_NORMAL
- en: The Java API is organized into many packages of hundreds of classes. New packages
    and classes are being added on a regular basis making it challenging to keep up
    with all of the capabilities of Java.
  prefs: []
  type: TYPE_NORMAL
- en: However, as mentioned in the *The Object class* section in [Chapter 7](ch07.html
    "Chapter 7. Inheritance and Polymorphism"), *Inheritance and Polymorphism*, all
    classes in Java have as a base class—`java.lang`.`Object`—either directly or indirectly.
    In the classes that you defined, if you do not explicitly extend another class,
    Java will automatically extend this class from the `Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of a package is to group related classes and other elements together.
    Ideally, they form a cohesive set of classes and interfaces. A package can consist
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is natural that classes with similar functionality should somehow be grouped
    together. Most of Java's IO classes are grouped together in the `java.io` or `java.nio`
    related packages. All of Java's network classes are found in the `java.net` package.
    This grouping mechanism provides us with a single logical grouping that is easier
    to talk about and to work with.
  prefs: []
  type: TYPE_NORMAL
- en: All classes belong to a package. If the package is not specified, then the class
    belongs to an unnamed default package. This package consists of all the classes
    in the directory that have not been declared as belonging to a package.
  prefs: []
  type: TYPE_NORMAL
- en: The directory/file organization of packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To place a class within a package it is necessary to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the package statement in the class source file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the corresponding `.class` file to the package directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The package statement needs to be the first statement in the class'' source
    file. The statement consists of the keyword, `package`, followed by the name of
    the package. The following example declares that the class `Phone` belongs to
    the `acme.telephony` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Java source code files are placed in a file with the same name as the class
    using a `.java` extension. If more than one class is saved in a file, only one
    class can be declared as public and the file must be named after this public class.
    The `java.lang` package contains many commonly used classes and is included automatically
    in every application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second requirement is to move the class file to the appropriate package
    directory. Somewhere on the system there must exist a directory structure that
    reflects the package name. For example, for a package name `employee.benefits`
    there needs to be a directory named `employee` that has a subdirectory named `benefits`.
    All of the class files for the `employee` package are placed in the `employee`
    directory. All of the class files for the `employee.benefits` package are placed
    in the `benefits` subdirectory. This is illustrated in the following diagram where
    the directories and files are located somewhere off in the `C` drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The directory/file organization of packages](img/7324_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may also find that a package's directories and classes are compressed into
    a **Java Archive** (**JAR**) or `.jar` file. If you look for a specific package
    structure in a directory system, you may find a JAR file instead. By compressing
    packages into a JAR file, memory can be minimized. If you find such files, do
    not unzip them because the Java compiler and JVM expect them to be in a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Most IDEs will separate the source files from the class files by placing them
    in separate directories. This separation makes them easier to work with and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: The import statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `import` statement provides information to the compiler in terms of where
    to find the definition of a class used in the program. There are several considerations
    regarding the import statement that we will examine:'
  prefs: []
  type: TYPE_NORMAL
- en: Its use is optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the wildcard character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing multiple classes with the same name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static import statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the import statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `import` statement is optional. In the following example, instead of using
    the `import` statement for the `BigDecimal` class we explicitly use the package
    name directly in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is more verbose but it is more expressive. It leaves no doubt that the
    `BigDecimal` class is the one found in the `java.math` package. However, if we
    used the class many times in the program then this becomes an annoyance. Normally,
    the `import` statement is used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the import statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To avoid having to prefix each class with its package name, the `import` statement
    can be used to indicate to the compiler where the class can be found. In this
    example the class, `BufferedReader` of the `java.io` package, can be used without
    having to prefix the class name with its package name each time it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the wildcard character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If more than one class needs to be used, and they are found in the same package,
    an asterisk can be used instead of including multiple import statements, one for
    each class. For example, if we need to use both the `BufferedReader` and the `BufferedWriter`
    classes in an application we could use two import statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By explicitly listing each class, the reader of the code will know immediately
    where to find the class. Otherwise, the reader might be left guessing from which
    package a class originates when the wild card character is used with multiple
    import statements.
  prefs: []
  type: TYPE_NORMAL
- en: While the explicit import of each class is better documentation, the import
    list can get quite long. Most IDEs support the ability to collapse, or otherwise
    hide the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative approach is to use one import statement with the asterisk,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the package''s elements can now be used without using the package name.
    However, this does not mean that the classes of sub-packages can be used in the
    same way. For example, there are numerous packages that start with `java.awt`.
    A few of these with some of their elements are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the wildcard character](img/7324_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It may seem the wild card character should include those classes found in these
    additional packages when used against the "base" package, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it imports only those classes in the `java.awt` package and none of
    the classes in the `java.awt.font` or similar packages. In order to also reference
    all of the classes of `java.awt.font` also, a second import statement is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Multiple classes with the same name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As it is possible to have more than one class with the same name in different
    packages, the import statement is used to specify which class to use. However,
    the second class will need to explicitly use the package name.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's assume that we have created a `BigDecimal` class in a `com.company.account`
    package and we need to use it and the `java.math.BigDecimal` class. We cannot
    use an import for both classes, as shown in the following code snippet, because
    this will generate a syntax error to the effect that the names collide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we need to either:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare one using the import statement and explicitly prefix the class name
    of the second when we use it, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d. not use the import statement at all and explicitly prefix both classes as
    we use them
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we use the `import` statement with the `java.math` class, we
    use both classes in code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we had to prefix both usages of `BigDecimal` in the second statement
    otherwise it would have assumed that the un-prefixed one was in the `java.math`
    package generating a type mismatch syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: The static import statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The static import statement can be used to simplify the use of methods. This
    is commonly used in conjunction with the `println` method. In the following example,
    we use the `println` method several times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In each case, the classname, `System`, was required. However, if we use the
    following `import` statement where we added the `static` keyword we will not need
    to use the `System` classname.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sequence of code statements achieves the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While this approach saves the time spent in typing, it can be confusing to anyone
    who does not understand the use of the static import statement.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java performs automatic garbage collection. When memory is allocated using the
    `new` keyword, the memory is obtained from the program heap. This is an area of
    memory above the program stack. The object allocated is held by the program until
    the program releases it. This is done by removing all references to the object.
    Once it is released, the garbage collection routine will eventually run and reclaim
    the memory allocated by the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sequence illustrates how a `String` object is created. It
    is then assigned to a second reference variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `s1` and `s2` both reference the string object. The following
    diagram illustrates the memory allocation for `s1` and `s2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Garbage collection](img/7324_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `new` keyword was used in this situation to ensure that the string object
    is allocated from the heap. If we had used a string literal, as shown below, the
    object is allocated to an internal pool as discussed in the *String comparisons*
    section in [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two statements illustrate how the references to the object can be
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the state of the application after these statements
    have been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Garbage collection](img/7324_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There exists a JVM background thread, which executes periodically to reclaim
    the unused objects. At some point in the future, the thread will execute. When
    an object is ready to be reclaimed, the thread will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the method's `finalize` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reclaim the memory for re-use by the heap manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finalize` method is not normally implemented by a developer. Its original
    intent was to correspond to the destructor found in languages such as C++. They
    were used to perform cleanup activities.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, you should not rely on the method to execute. For small programs, the
    garbage collection routine may never run as the program may terminate before it
    has a chance to execute. Over the years, several attempts have been made to provide
    the ability for a programmer to force the method to execute. None of these attempts
    have been successful.
  prefs: []
  type: TYPE_NORMAL
- en: Resource bundles and the Locale class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Locale` class is used to represent a part of the world. Associated with
    a locale is a set of conventions concerned with such activities as controlling
    the way currency or dates are displayed. The use of locales aids in the internationalization
    of an application. The developer specifies the locale and then uses the locale
    in various parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `Locale` class, we can also use resource bundles. They provide
    a way to customize the appearance based on the locale for data types other than
    numbers and dates. It is particularly useful when working with strings that change
    based on the locale.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a GUI application will have different visual components whose text
    should differ when used in different parts of the world. In Spain, the text and
    currency should be displayed in Spanish. In China, Chinese characters and conventions
    should be used. The use of locales can simplify the process of adapting an application
    to different regions of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section we will discuss three approaches used to support internationalization
    of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Locale` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a property resource file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ListResourceBundle` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Locale class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the use of locales we first create an instance of the `Locale`
    class. This class has a number of predefined locale constants. In the following
    example we will create a locale for the US and then display the locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part, `en_`, is short for English. The second part specifies US.
    If we change the locale to Germany as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use locales to format currency values. In the following example we
    have used the static `getCurrencyInstance` method to return an instance of a `NumberFormat`
    class using the locale for the US. The `format` method is then used to `format`
    a double number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had used the German locale, we would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Dates can also be formatted based on a locale. The `DateFormat` class'' `getDateInstance`
    method is used in the following code snippet, with the US locale. The `format`
    method uses a `Date` object to obtain a string representation of the date, as
    illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be similar to the one that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet we will use a locale for France:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using resource bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resource bundles are collections of objects organized by the locale. For example,
    we might have one resource bundle containing strings and GUI components for English
    speaker and another set for Spanish speakers. These language groups can be further
    divided into language subgroups such as US versus Canadian English speakers.
  prefs: []
  type: TYPE_NORMAL
- en: A resource bundle can be stored as a file or may be defined as a class. A property
    resource bundle is stored in a `.properties` file and is restricted to strings.
    `ListResourceBundle` is a class and can hold strings and other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using a property resource bundle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property resource bundle is a file consisting of a set of key-value string
    pairs where the file name ends with `.properties`. The string key is used to identify
    a specific string value. For example, a `WINDOW_CAPTION` key can be associated
    with a string value `Editor`. The following shows the content of a `ResourceExamples.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the value in a resource file, we need to create an instance of a
    `ResourceBundle` class. We can do this by using the `ResourceBundle` class'' static
    `getBundle` method, as shown in the following code snippet. Notice that the resource
    file name is used as an argument of the method, but it does not include the file
    extension. If we know the key, we can use it with the `getString` method to return
    its corresponding value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `getKeys` method to obtain an `Enumeration` object. As shown
    in the following code snippet, the enumeration to display all of the key-value
    pairs of the file, is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the output does not match the order or the contents of the `ResourceExamples.properties`
    file. The order is controlled by the enumeration. The content is different for
    the `FILE_NOT_FOUND` and `FILE_EXISTS` keys. This is because it actually used
    a different file, `ResourceExamples_en_US.properties`. There is a hierarchical
    relationship between the property resource bundles. The code sequence was executed
    with a default locale of the US. The system looked for the `ResourceExamples_en_US.properties`
    file as it represents the strings specific to that locale. Any missing elements
    in a resource file are inherited from its "base" file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create four different resource bundle files to illustrate the use of
    resource bundles and the hierarchical relationship between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceExamples.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceExamples_en.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceExamples_en_US.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceExamples_sp.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are related to each other hierarchically, as depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a property resource bundle](img/7324_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These files will contain strings for four keys as summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File | Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | `WINDOW_CAPTION` | Editor |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_NOT_FOUND` | The file could not be found |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_EXISTS` | The file already exists |'
  prefs: []
  type: TYPE_TB
- en: '| `UNKNOWN` | Unknown problem with application |'
  prefs: []
  type: TYPE_TB
- en: '| `en` | `WINDOW_CAPTION` | Editor |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_NOT_FOUND` | The English file could not be found |'
  prefs: []
  type: TYPE_TB
- en: '| `UNKNOWN` | Unknown problem with application |'
  prefs: []
  type: TYPE_TB
- en: '| `en_US` | `WINDOW_CAPTION` | Editor |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_NOT_FOUND` | The US file could not be found |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_EXISTS` | The US file already exists |'
  prefs: []
  type: TYPE_TB
- en: '| `UNKNOWN` | Unknown problem with application |'
  prefs: []
  type: TYPE_TB
- en: '| `sp` | `FILE_NOT_FOUND` | El archivo no se pudo encontrar |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_EXISTS` | El archivo ya existe |'
  prefs: []
  type: TYPE_TB
- en: '| `UNKNOWN` | Problema desconocido con la aplicación |'
  prefs: []
  type: TYPE_TB
- en: 'The `en` entry is missing a value for the `FILE_EXISTS` key and the `sp` entry
    is missing the `WINDOW_CAPTION` key. They will inherit the value for the default
    resource file, as illustrated below for the `en` locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output lists a value for `FILE_EXISTS` even though it is not found in the
    `ResourceExamples_en.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The inheritance behavior of these files allows the developer to create a hierarchy
    of resources files based on a base file name and then extend them by adding a
    locale suffix. This results in strings being used automatically that are specific
    for the current locale. If a locale other than the default one is needed, then
    the specific locale can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ListResourceBundle class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ListResourceBundle` class is also used to hold resources. Not only can
    it hold strings, it can also hold other types of objects. However, the keys are
    still string values. To demonstrate the use of this class, we will create the
    `ListResource` class which derives from the `ListResourceBundle` class as listed
    below. A static two dimensional array of objects is created containing key-value
    pairs. Notice the last pair contains an `ArrayList`. The class'' `getContents`
    method returns the resources as a two dimensional array of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `ArrayList` created is intended to store various name prefixes. It is created
    using the `asList` method, which is passed a variable number of string arguments
    and it returns a `List` to the `ArrayList` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to use `ListResource`. An instance of `ListResource`
    is created and then the `getString` method is executed using string keys. For
    the `PREFIXES` key, the `getObject` method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JDBC is used to connect to a database and manipulate tables in the database.
    The process to use JDBC includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an SQL statement to submit to the database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling the results and any exceptions that may be generated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java 7, the use of JDBC has been enhanced with the addition of the try-with-resources
    block, which simplifies the opening and closing of connections. A detailed explanation
    of this block is found in the *Using the try-with-resource block* section in Chapter
    8.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connecting to a database involves two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a suitable driver
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establishing a connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This assumes that a database has been setup and is accessible. In the following
    examples, we will be using MySQL Version 5.5\. MySQL comes with the `Sakila` schema
    which contains a `customer` table. We will use this table to demonstrate various
    JDBC techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a suitable driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we need to load a driver. JDBC supports a number of drivers, as discussed
    at [http://developers.sun.com/product/jdbc/drivers](http://developers.sun.com/product/jdbc/drivers).
    Here, we will use the `MySQLConnector/J` driver. We load the driver using the
    `Class` class'' `forName` method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The method throws several exceptions which need to be caught.
  prefs: []
  type: TYPE_NORMAL
- en: Note that starting with JDBC 4.0 the above sequence is no longer needed, assuming
    that the JDBC drivers used support JDBC 4.0\. This is the case for the MySQL drivers
    used with MySQL Version 5.5\. This sequence is used here because you will probably
    run across this approach in older programs.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, a connection to the database needs to be established. The `java.sql.Connection`
    represents a connection to a database. The `DriverManager` class'' static `getConnection`
    method will return a connection to a database. Its arguments include:'
  prefs: []
  type: TYPE_NORMAL
- en: A URL representing the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code sequence will use a try-with-resources block to establish
    a connection to the database. The first parameter is a MySQL specific connection
    string. Connection strings are vendor specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Creating a SQL statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to create a `Statement` object that will be used to execute a
    query. The `Connection` class'' `createStatement` method will return a `Statement`
    object. We will add it to the try-with-resources block to create the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A query string is then formed that will select the first and last name of those
    customers in the `customer` table whose `address_id` is less than 10\. We choose
    this query to minimize the size of the result set. The `executeQuery` method is
    used to execute the query and returns a `ResultSet` object that holds the rows
    of the table matching the selected query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Handling the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step is to use a while loop to iterate through the result set and
    display the rows returned. In the following example the `next` method will advance
    from row to row in the `resultset`. The `getString` method returns the value corresponding
    to the method''s argument that specifies the column to be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: JDBC supports the use of other SQL statements such as `update` and `delete`.
    In addition, it supports the use of parameterized queries and stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have re-examined the overall structure of a Java application.
    We examined the use of the `import` and `package` statements and discussed the
    relationship between a package library and its supporting directory/file underpinnings.
    We learned how to use the asterisk wildcard with the `import` statement. In addition,
    we saw the use of the static import statement.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the use of the initializer list and how garbage collection works
    in Java. This process results in the automatic recovery of objects once they are
    no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: The support provided for internationalization was explored starting with the
    `Locale` class and then with resource bundles. Both, property resource bundles
    and the `ListResourceBundle` class were covered. We learned how inheritance works
    with property resource bundles when organized using a consistent naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered the use of JDBC. We saw how a driver is needed to establish
    a connection to a database and how to use the `Statement` class to retrieve a
    `ResultSet` object. This object allowed us to iterate through the rows returned
    by a `select` query.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The certification objectives covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the structure of a Java class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a resource bundle based on locale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the proper JDBC API to submit queries and read results from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following will compile without an error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `package somepackage;`
  prefs: []
  type: TYPE_NORMAL
- en: '`import java.nio.*;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SomeClass {}`'
  prefs: []
  type: TYPE_NORMAL
- en: b. `import java.nio.*;`
  prefs: []
  type: TYPE_NORMAL
- en: '`package somepackage;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SomeClass {}`'
  prefs: []
  type: TYPE_NORMAL
- en: c. `/*This is a comment */`
  prefs: []
  type: TYPE_NORMAL
- en: '`package somepackage;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import java.nio.*;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SomeClass {}`'
  prefs: []
  type: TYPE_NORMAL
- en: For a hierarchy of a resource property file, if a key is missing from one of
    the derived files, which of the following are true about the value returned, based
    on a missing key?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The return value will be an empty string
  prefs: []
  type: TYPE_NORMAL
- en: b. The return value will be a null value
  prefs: []
  type: TYPE_NORMAL
- en: c. The return value will be a string from a base resource bundle
  prefs: []
  type: TYPE_NORMAL
- en: d. A runtime exception will be thrown
  prefs: []
  type: TYPE_NORMAL
- en: 'Which exception is not thrown by the `forName` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `InstantiationException`
  prefs: []
  type: TYPE_NORMAL
- en: b. `ClassNotFoundException`
  prefs: []
  type: TYPE_NORMAL
- en: c. `ClassDoesNotExistException`
  prefs: []
  type: TYPE_NORMAL
- en: d. `IllegalAccessException`
  prefs: []
  type: TYPE_NORMAL
