- en: Smart Wearable and IFTTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](part0111.html#39REE0-ce91715363d04669bca1c1545beb57ee), *Smart
    Wearable*, we looked at how to build a simple wearable that displays a user''s
    location and also reads accelerometer values. In this chapter, we are going to
    take that application to the next level by implementing fall detection logic on
    the device and then adding **If This Then That** (**IFTTT**) rules on top of the
    data to execute actions when certain events happen. We will look at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is IFTTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IFTTT and IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding fall detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer-based fall detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an IFTTT rules engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IFTTT and IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This reactive pattern can be easily applied to certain situations. For example,
    if a patient falls down, then call an ambulance, or if the temperature goes below
    15 degrees, then turn off the AC, and so on. These are simple rules that we define
    that can help us automate a lot of processes.
  prefs: []
  type: TYPE_NORMAL
- en: In IoT, rules engines are key to automating most monotonous tasks. In this chapter,
    we are going to build a simple hardcoded rules engine that will continuously monitor
    the incoming data. If the incoming data matches any of our rules, it will execute
    a response.
  prefs: []
  type: TYPE_NORMAL
- en: What we are building is a similar concept to [ifttt.com](https://ifttt.com/)
    ([https://ifttt.com/discover](https://ifttt.com/discover)), but is very specific
    to IoT devices that are present inside our framework. IFTTT ([https://ifttt.com/discover](https://ifttt.com/discover))
    has no relation to what we are building in our book.
  prefs: []
  type: TYPE_NORMAL
- en: Fall detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](part0111.html#39REE0-ce91715363d04669bca1c1545beb57ee), *Smart
    Wearable*, we gathered three axis values from the accelerometer. Now, we are going
    to make use of this data to detect falls.
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend watching the video *Accelerometer in Freefall* ([https://www.youtube.com/watch?v=-om0eTXsgnY](https://www.youtube.com/watch?v=-om0eTXsgnY)),
    which explains how an accelerometer behaves both when it is stationary and in
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basic concept of fall detection, let's talk about
    our specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest challenge in fall detection is to distinguish falling from other
    activities, such as running and jumping. In this chapter, we are going to keep
    things simple and work on very basic conditions, where a user at rest or in constant
    motion suddenly falls down.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify whether the user has fallen down, we use the signal magnitude vector
    or *SMV*. *SMV* is the root mean square of the values of the three axes. That
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we start plotting the **SMV** over **Time** for a user who is standing idle
    and then falls down, we will end up with a graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note the spike at the end of the chart. This is the point at which the user
    actually fell.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we gather the accelerometer values from ADXL345, we will calculate
    the SMV. Based on multiple iterations using the smart wearable we have built,
    I was consistently able to detect falls at an SMV value of 1 g. For anything less
    than 1 g SMV, the user is almost always considered to be stationary and anything
    greater than 1 g SMV is considered a fall.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that I have placed the accelerometer in such a way that the y-axis is
    perpendicular to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Once we put the setup together , you can see for yourself how the SMV values
    change with a change in the accelerometer's position.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that if you are performing other activities, such as jumping or squatting,
    the fall detection might be triggered. You can play around with the threshold
    value of 1 g SMV to get consistent fall detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also refer to *Detecting Human Falls with a 3-Axis Digital Accelerometer*:
    ([http://www.analog.com/en/analog-dialogue/articles/detecting-falls-3-axis-digital-accelerometer.html](http://www.analog.com/en/analog-dialogue/articles/detecting-falls-3-axis-digital-accelerometer.html)),
    or *Accelerometer-based on-body sensor localization for health and medical monitoring
    applications* ([https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3279922/](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3279922/)),
    and *Development of the Algorithm for Detecting Falls during Daily Activity using
    2 Tri-Axial Accelerometers* ([http://waset.org/publications/2993/development-of-the-algorithm-for-detecting-falls-during-daily-activity-using-2-tri-axial-accelerometers](http://waset.org/publications/2993/development-of-the-algorithm-for-detecting-falls-during-daily-activity-using-2-tri-axial-accelerometers))
    to get a greater understanding of this topic and improve the efficiency of the
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what needs to be done, we will get started with the code.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, create a folder named `chapter7` and make a copy of the `chapter6`
    code in the `chapter7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `pi/index.js` file. We will update the ADXL345 initialization
    setup and then start working with the values. Update `pi/index.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note `initADXL345()`. We define the measurement range as `2_G`, clear the offsets,
    and then we invoke the infinite loop function. In this scenario, we run the `setInterval()`
    every `500` ms instead of every `1` second. `readSensorValues()` is invoked every
    `500` ms instead of every `3` seconds. This is to make sure that we capture falls
    without much delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `readSensorValues()`, once the `x`, `y`, and `z` values are available,
    we calculate the SMV. Then, we check whether the SMV value is greater than `1`:
    if it is, then we have detected a fall.'
  prefs: []
  type: TYPE_NORMAL
- en: Along with the `x`, `y`, and `z` values, we send the SMV value as well as the
    fall value to the API engine. Also, do note that in this example, we are not sending
    all values as we collect them. We send data only if the fall is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save all of the files. Start the broker by running the following command from
    the `chapter7/broker` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the API engine by running the following command from the `chapter7/api-engine`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are yet to add the IFTTT logic to the API engine, which we will do in the
    next section. For now, to validate our setup, let''s run the `index.js` file on
    the Raspberry Pi by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, the accelerometer should be initialized successfully
    and the data should start coming in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simulate a free fall, we should see our first piece of data going to
    the API engine, and it should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the simulated free fall gave an SMV of `2.048` g.
  prefs: []
  type: TYPE_NORMAL
- en: 'My hardware setup is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I have glued the entire setup to a **Styrofoam** sheet, so I can comfortably
    test the fall detection logic.
  prefs: []
  type: TYPE_NORMAL
- en: I removed the 16 x 2 LCD from the setup while I was identifying the SMV for
    free fall.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to read the data that we received from the
    device and then execute rules based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Building the IFTTT rules engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are sending the required data to the API engine, we will be doing
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing data that we got from the smart wearable on the web, desktop, and mobile
    apps
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing rules on top of the data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will get started with the second objective first. We will be building a rules
    engine to execute rules based on the data we have received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by creating a folder named `ifttt` at the root of the `api-engine/server`
    folder. Inside the `ifttt` folder, create a file named `rules.json`. Update `api-engine/server/ifttt/rules.json`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, we are maintaining a JSON file with
    all of our rules. In our scenario, we have only one rule for one device, and the
    rule has two parts: the `if` part and the `then` part. The `if` refers to the
    property, which needs to be checked against the incoming data, the checking condition,
    and the value against which it needs to be checked. The `then` part refers to
    the action that needs to be taken if the `if` matches. In the preceding case,
    this action involves sending an email.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to build the rules engine itself. Create a file named `ifttt.js`
    inside the `api-engine/server/ifttt` folder and update `api-engine/server/ifttt/ifttt.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The logic is quite simple. `processData()` gets called when a new data record
    comes to the API engine. Then, we load all of the rules from the `rules.json`
    file and we iterate over them to check whether or not the current rule is meant
    for the incoming device.
  prefs: []
  type: TYPE_NORMAL
- en: If yes, then `checkRuleAndData()` is called by passing the rule and incoming
    data to check whether the current data set matches any of the predefined rules.
    If it does, we check the action, which in our case is the sending of an email.
    You can update the appropriate email credentials in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we need to invoke `processData()` from `api-engine/server/mqtt/index.js
    client.on('message')` with the `topic` equaling `accelerometer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `client.on(''message'')`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That is it. We have all the pieces needed for the IFTTT engine to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save all of the files and restart the API engine. Now, simulate a fall and
    we should see an email coming our way, which should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are done with the IFTTT engine, we will update the interfaces to
    reflect the new data we have gathered.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the web app, open `web-app/src/app/device/device.component.html`
    and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following once we navigate to the device page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will update the desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the desktop app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the web app is done, we are going to build the same and deploy it inside
    our desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head back to the terminal/prompt of the `web-app` folder and
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder inside the `web-app` folder named `dist`. The
    contents of the `dist` folder should be along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code we have written is finally bundled into the preceding files. We
    will grab all of the files (not the `dist` folder) present inside the `dist` folder
    and then paste them inside the `desktop-app/app` folder. The final structure of
    the desktop app after these changes will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To test drive, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we navigate to the VIEW DEVICE page, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are done with the desktop app, we will work on the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the mobile app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reflect the new template in the mobile app, we will update `mobile-app/src/pages/view-device/view-device.html`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all of the files and run the mobile app by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00107.gif)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with the concept of fall detection and IFTTT. Using
    the smart wearable we built in [Chapter 6](part0111.html#39REE0-ce91715363d04669bca1c1545beb57ee),
    *Smart Wearable*, we added the fall detection logic. Then, we posted the same
    data to the API engine, and in the API engine, we built our own IFTTT rules engine.
    We defined one rule for sending an email when a fall was detected.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this, we also updated the web, desktop, and mobile apps to reflect
    the new data we collected.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](part0129.html#3R0OI0-ce91715363d04669bca1c1545beb57ee), *Raspberry
    Pi Image Streaming*, we are going to work with video surveillance using Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
