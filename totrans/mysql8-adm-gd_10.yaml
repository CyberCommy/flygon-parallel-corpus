- en: MySQL 8 – Scalability and High Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following important topics for MySQL 8 scalability
    and high availability:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of scalability and high availability in MySQL 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling MySQL 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges in scaling MySQL 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving high availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we move on to the details, let's have an overview of scalability and
    high availability in MySQL 8
  prefs: []
  type: TYPE_NORMAL
- en: Overview of scalability and high availability in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any type of application, be it mobile, web portals, websites, social, e-commerce,
    enterprise or cloud applications, data is the core portion of the business. Data
    availability is considered an utmost concern for any business or organization.
    Data loss or any downtime of an application can result in a heavy loss in terms
    of money and also impact the credit of the company in the market.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider an example of an online shopping site which has a nicely covered
    market in a specific area, with customers and good business credit. If this business
    faced an issue with data loss or any application server or database server downtime,
    it would impact the whole business. Many customers would lose faith in the business
    and also the business would suffer a loss both in terms of finance and credit.
  prefs: []
  type: TYPE_NORMAL
- en: There is no single formula that can provide a solution. Different businesses
    have their own application requirements, business needs, distinct processes, different
    infrastructure in different locations, and operational competencies. In these
    circumstances, technology plays a major role in achieving high availability.
  prefs: []
  type: TYPE_NORMAL
- en: As per the requirements of scalability and high availability, MySQL can be used
    for various applications, and as per need it is capable of overcoming failures,
    including failures of MySQL, failures from the operating system, or any planned
    maintenance activity that may impact availability. Scalability in simple terms,
    that has the capability to distribute database load and application queries between
    MySQL servers.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes that matter when choosing the right solution for high availability
    depend on to what extent the system can be called highly available, as such requirements
    vary from system to system. For smaller applications, where the user load is not
    expected to be very high, setting up the replication or cluster environment can
    result in very high cost. In such cases, providing the correct configuration of
    the MySQL can also be enough to reduce application load.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections briefly describe the primary solutions supported by MySQL
    8 for high availability.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL replication allows data from one server to be replicated onto the multiple
    MySQL servers. MySQL replication provides master-slave design, so that one of
    the servers from the group acts as a master where write operations are performed
    from the application and then the master server copies the data to the multiple
    slave servers. Replication is a well established solution for high availability
    and is used by the social giants such as Facebook, Twitter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another popular high availability solution for MySQL. Clustering enables
    data to be replicated to multiple MySQL servers with automated sharing. It is
    designed for better availability and throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle MySQL cloud service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle MySQL cloud service provides an efficient means to help build a secure,
    cost-effective MySQL database as a service for applications used in modern world.
    It proves to be scalable and cost-efficient with less resource utilization for
    managing the service when compared to on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL with the Solaris cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sun Solaris cluster provided by the MySQL data service provides a mechanism
    for orderly startup and shutdown, fault monitoring, and automatic failover of
    the MySQL service. The following MySQL components are protected by the sun cluster
    HA for the MySQL data service.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some further options available using third-party solutions. Each
    architecture that is used to achieve highly available database services is differentiated
    by the levels of uptime that each offers. These architectures can be grouped into
    three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Data replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustered and virtualized systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geographically-replicated clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the best answer to the question, you can select the right option for
    your application with optimal cost and a highly available solution. This discussion
    gives us a fair overview of MySQL 8's high availability.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability is the ability to distribute the load of any application queries
    across various MySQL instances. For some cases, it is unpredictable that data
    cannot exceed up to some limit or the number of users will not go out of bounds.
    Scalable databases would be a preferable solution so that, at any point, we can
    meet unexpected demands of scale. MySQL is a rewarding database system for its
    scalability, which can scale horizontally and vertically; in terms of data, distribution
    of client queries across various MySQL instances is quite feasible. It is pretty
    easy to add horsepower to the MySQL cluster to handle the load.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for achieving **High Availability** (**HA**) and scalability
    may vary from system to system. Each system requires a different configuration
    in order to achieve these abilities. There are many questions that come to mind
    when we think about scaling in MySQL, and while we perform scaling operations
    in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is scaling required?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of scaling in MySQL?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What points need to put across in our minds when we perform scaling in MySQL?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will scaling work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it secure for data - does it provide surety of data security?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plus many more...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a real time example to understand why we need scaling in MySQL. We
    have an online e-commerce website that has covered a small market, with limited
    users and limited hits on the website, with a single database server. The business
    is growing up nicely; the performance of the business is continuously increasing
    and the user count is increasing, and with our single database server all requests
    and performance cannot be scaled at all time. This may possibly result in a server
    crash and the business might face loss in terms of profit and credit in the market.
    To avoid such a situation, scalability will perform a major part. If any request
    from a customer fails due to any reason, or if the node goes down, the other node
    will take care of it quickly and give the appropriate response to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling is required for the continuous increase in performance of database response
    time and to improve the productivity of the product. It will help the end product
    in terms of data scalability, performance, and better results. Cluster and replication
    are both key features in MySQL that can be leveraged for scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling using cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic cluster architecture is divided into four different layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Client node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef6c457f-cd0a-4f1e-99c4-762f718450e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Client node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client node is an end user or application that sends a request for any query
    in terms of read data or write data from a different device, such as a computer,
    mobile, tablet, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Application node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application node is meant to provide the bridge between the logic of the
    application and the nodes containing the data in MySQL. Applications can access
    the data, which is stored in the MySQL cluster, by SQL, with one or many MySQL
    servers using the function of SQL. In the application we have multiple technologies
    from where we connect to the MySQL server. We connect MySQL server with standard
    the MySQL connectors, which gives us the ability to connect with a wide range
    of access technologies.
  prefs: []
  type: TYPE_NORMAL
- en: As another option, we have NDB API; a high performance interface that can be
    used to control real-time user experiences and provide better throughput. In MySQL
    we have NDB API, which adds a layer additionally to NoSQL interfaces that consist
    capability to access the cluster directly. Application nodes can fetch data from
    all the data nodes, so the only cause of failure can be the unavailability of
    application services, as the application can use all data nodes to perform data
    manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Management node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The management node performs the important role of publishing relevant cluster
    information across the nodes in its cluster, along with node management. Nodes
    for management work at startup when all nodes want to join the MySQL cluster and
    also when reconfiguration of the system is required. The management node can be
    stopped and restart all services without damaging or impacting an ongoing operation,
    execution, or processing of data and the application node.
  prefs: []
  type: TYPE_NORMAL
- en: Data node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data nodes stores the data. Tables get shared across the data nodes, which
    also helps to handle load balancing, replication, and high availability failover.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data nodes are the main nodes of a MySQL cluster solution. It provides the
    following functionality and benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Data storage and management of disk-based and in-memory data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a shared-nothing scenario, data is stored in at least one replica without
    the use of shared-disk space. MySQL create one replica of the database which does
    a synchronous replication process. If any data node fails due to any specific
    reason, the replicated data will take care of it and provide the respective output.
    It does a synchronous copy of the node so it consists of the same data as the
    main node data.
  prefs: []
  type: TYPE_NORMAL
- en: We can store the data either in memory or partially on disk based on the requirement.
    Data that frequently change are suggested to be stored in-memory. In-memory data
    is routinely checked with the local disk and coordinates to update the data to
    the rest of the data nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic and user-defined partitioning of tables or sharding of tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL cluster provides low latency, high throughput, scalability, and high availability.
    This adopts horizontal scaling and auto sharding to serve heavy load read/write
    operations through the different NoSQL queries. An NDB cluster is a set of different
    nodes where each task is running on its own processor.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous data replication between data nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have data replication for the data node it follows synchronous replication,
    so at any time all node data will be in-sync. If any node fails for any reason,
    the other nodes have the same data and so will be able to provide the data for
    a query. So, without any downtime for data response, MySQL provides a perfect
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Data retrieval and transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL supports each of the transactions that can be mapped, as it is committed
    on the master server and applied on the slave server. This method is not referring
    to `binlog` files or the relevant position in the `binlog` file. `GTID` replication
    is solely working based on transactions; it becomes very easy to identify whether
    the master and the slave servers are in sync or not.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic fail over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If any data node fails for any reason, the other nodes take responsibility and
    gives the response to the request. Replication of the database is very helpful
    in critical conditions of downtime or a failure in any of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic re-synchronization for self-healing after failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If any node is failed it will start automatically and again perform the synchronization
    of data to the rest of the nodes, which are active nodes, and copy all recent
    data in the node. In that case it does self-healing of the failures.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling using memcached in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MySQL 8, using memcached is one of the ways to achieve scalability. Memcached
    is a simple and highly scalable solution for storing data in key and value form
    in cache whenever memory is available. Memcached is commonly used for quick access
    of data. Data stored in memory doesn't have I/O operations performed for fetching
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: As all the information is stored in memory, the access speed for data is much
    faster than compared to loading every time from disk and results in a better query
    execution time on the database server. This plugin also has the feature of serialization,
    which converts binary files, code blocks, or any other objects to strings that
    can be stored, and provides a simple means to retrieve such objects. While specifying
    a memory allocation it should not be larger than the available physical memory
    of the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you specify too large of a value then some of the memory allocated for memcached
    will use swap space and not physical memory. This may lead to delays when storing
    and retrieving values because data is swapped to disk instead of storing the data
    directly in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e6e6d77-6a4d-4480-ab5b-2e6faaf58d92.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image depicts memcached architecture, which displays the flow
    of the data from memcached to a client or an end user, or a request of the data
    from an application.
  prefs: []
  type: TYPE_NORMAL
- en: The data in memcached never gets stored in the database. It's always available
    in memory itself. If either of the memcached servers fail, data will be fetched
    from the database, so it will not impact end-users for data retrieval or have
    a major performance impact on the application. The only thing need to keep in
    mind while we use a memcached server is that data related to any important information,
    for instance a financial transaction, should not be placed in memcached. In that
    case if there is a failure in memcached, the data might not be retrieved. In a
    memcached server data integrity is not healthy as it stores in memory, so during
    failure it would be good to have data that is important not saved in memcached.
    When configuring a memcached server, memory size is the key factor. If there is
    improper configuration, then you can expect a bad situation.
  prefs: []
  type: TYPE_NORMAL
- en: This way we can use memcached to scale the MySQL server for an increased data
    response time, and to provide faster performance. It will reduce the load on MySQL
    server and multiple servers as a part of cache group and also provides an interface
    for multiple languages. It is suggested to be used ideally when there are heavy
    read operations.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL cluster provides numerous ways to help access the data store. One of most
    generic way is leveraging SQL; however, in real-world use cases we can also depend
    on native APIs, which allow the fetching of the data from within the database
    without affecting performance or adding further complexity by developing an application
    to convert SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling using replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Replication is the copying of a MySQL database. MySQL provides replication
    with a different approach. MySQL has a feature of replication that provides scale-out
    solutions, data security, long distance data distribution and many more benefits.
    We have discussed this at length in [Chapter 8](03c98d39-8cb9-4171-beb1-0bd9dcaac81a.xhtml),
    *Replication in MySQL 8*. The following image explains the basic architecture
    of replication in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9be2c06c-0f31-46ed-b91a-d69bc37f763c.png)'
  prefs: []
  type: TYPE_IMG
- en: Replication is one of the best features of MySQL. It simply creates a copy of
    the data to the new server or another physical machine, which will import the
    data from the master server. Whenever the data is required it will populate the
    accurate results. It follows the master and slave approach for the replication.
    The master database is the actual database of the application and the slave database
    is created by MySQL in the database server of another physical server, which contains
    replicated data from the master server. We can configure the slave database for
    the specific operation, such as when the query relates to reading the data from
    the database; we can execute this on the slave server. In this case the master
    data will have less load than earlier. Suppose we have a ratio of the 40% write
    data query and 60% read data query; in this case if we have a single server it
    will handle all operations related to the read and write operation. But, as defined
    in the preceding image we have replicated the database in two different servers
    and read operations are performed on the slave servers, so we can make use of
    one of the slave server to perform complex read queries. This makes it possible
    to generate reports for doing data analysis on MySQL 8, as performing complex
    read queries will not impact the overall application performance.
  prefs: []
  type: TYPE_NORMAL
- en: In standard MySQL replication the master server creates binary log files and
    maintains the index of the log files to maintain and keep track of log rotation.
    The binary log files serve the records updates and are sent to the slave server.
    When the slave server connects to the master database server it considers the
    last position it has read in the log files, after which the slave server then
    receives any updates that have taken place since that time. The slave subsequently
    blocks and waits for the master to notify it for further updates.
  prefs: []
  type: TYPE_NORMAL
- en: The question in mind is why do we need replication? Or, what is the purpose
    of the replication? If replication requires another database server, complexity,
    and additional configuration, it increases the maintenance and monitoring time.
    Still, we have many additional benefits for business and database admin.
  prefs: []
  type: TYPE_NORMAL
- en: Single server dependancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any case, if the master database server fails we can easily switch our database
    connection to the replicated slave server to provide stability in critical situations.
    This includes if there is network failure, server failure, hardware issues, and
    many more reasons for failure.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance is the main part in the database. When we have a distributed database
    over multiple servers we can connect different applications to different database
    servers to increase performance. This feature reduces the response time of the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Backup and recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replication helps back up the master database. It is more efficient than storing
    the database on disk. Users can store the database in the master using the replicated
    database as a backup instead of digging up the backup files. When required to
    restore the data of the master server a user can easily get it from the slave
    server, with no need to work on the backup files and go about finding the last
    updates and other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Load distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using the replication load of the database, query execution can be reduced;
    we can split read and write operations over the databases. If we execute write
    operations in the master database and read operations in the slave database that
    will improve the response time of the application. We can create load balanced
    environments in MySQL, which share the load of all requests to the database server.
    The load balancer then further sends requests to the database that can handle
    each transaction with much better throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous data replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous data replication means that data is copied from one machine to
    another, with a resultant delay. This delay is based on networking bandwidth,
    resource availability, or a time interval set by the administrator in configuration.
    The correct configuration and time setting provides an accurate result in response.
    It's based on the network administrator's configuration. Synchronous data replication
    implies that data is committed to one or more machines at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Geographical data distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Group replication makes it possible to copy the master's data to the slave server
    that resides at a remote location and perform the read operations for a separate
    group of client without impacting the master's operations.
  prefs: []
  type: TYPE_NORMAL
- en: GTID replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Global transaction identifiers** (**GTID**) uses transaction based replication
    of data instead of binary log file based replication. Until and unless transactions
    that have been operated and committed on the master servers are present on all
    the slave servers, GTID will not consider replication in a consistent state.'
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL 8 replication can be done either in asynchronous mode or in semi-synchronous
    mode. In asynchronous mode, write operations are performed on the master server
    immediately, while replication in slaves is done periodically as per the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the semi-synchronous mode of replication, if semi-synchronous configuration
    is enabled on the master and at least one slave server, a transaction on the master
    node waits before getting a transaction time out until the semi-synchronous enabled
    node confirms that required data or update has been received. And on time-out,
    the master node again looks for the semi-synchronous slave and performs the replication.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 8 provides a new replication method, GTID, where a unique identifier is
    created and connected with each transaction saved or committed on the master server.
    The uniqueness of these identifiers is in all servers that are in the server where
    it's created, and also in the replicated servers. GTID have one to one mapping
    between all transactions. The concept of the log file referencing a position within
    files is not required when starting a new slave creation or failover to a new
    MySQL master. You can use either row-based or statement-based replication with
    GTIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a global transaction ID primarily provides two major benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s easy to change a master server to connect with a slave server during
    failover**: GTID is unique out of all servers in the replication group. The slave
    server remembers the global transaction ID of the last event from the old master.
    This means it becomes easy to identify where to reinitialize replication on the
    new MySQL master, as the global transaction IDs are known throughout the entire
    replication hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The status of the slave provides a crash-safe method**: The slave holds current
    position information in the `mysql.gtid_slave_pos` system table. If this table
    is using a transactional storage engine (such as `InnoDB`, which is the default),
    then further updates are done in the same transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GTIDs is a unique key created and associated with each transaction (insert
    and update operations) committed on the master server. The key is not only unique
    to the master server, but it's unique across all servers in replication.
  prefs: []
  type: TYPE_NORMAL
- en: ZFS replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ZFS file system has the ability to provision a snapshot of the server files,
    such as file system contents, transfer the snapshot to another machine, and extract
    the snapshot to recreate the file system on a different server. Users can create
    a snapshot at any time and can create as many snapshots as required. By continually
    creating, transferring, and restoring snapshots, it can provide synchronization
    between one or more machines in a fashion similar to DRBD.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen all the possible ways to scale a database in MySQL, using different
    techniques. As per business need and flexibility we can perform scaling with database
    backup. Scaling is not an easy task but its possible in MySQL 8, with the proper
    knowledge and understanding of the requirements of the business and a configuration
    provided by MySQL 8\. For database scaling, we must have proper understanding
    of the entire workflow of the database and communication approach.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges in scaling MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how scaling works and the advantages and purpose of scaling in
    the previous topic. When we start working with scaling in MySQL 8, what type of
    challenges will we face, and what steps need to be kept in mind while we work
    towards scaling? We have to account for if we are doing scaling and the master
    server fails, limits are reached, read and write operations are not able to handle
    the requests of the application, or while re-platforming the database. Scaling
    is not an easy task; it needs to ensure it is able to handle increasing transactions
    without any difficulty. At the time of performing the scaling we need to keep
    in mind many points, such as the write and read operation limits in the master
    and slave servers. Database load balancing is one of the approaches that help
    reduce the traffic of the transaction, but again it needs perfection, and needs
    to understand the load balancing configuration properly. The following are the
    major challenges faced when we perform scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Business type and flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first point that needs to kept in mind while we perform the scaling.
    Business type or business behavior is the core part; if the business is an e-commerce,
    we already know e-commerce businesses have a number of functionalities and very
    critical data about clients, such as product details, monopoly of the business
    for offers and discounts. The main thing is customer details and payment information
    such as credit card details, debit card details, and customer feedback.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, while we are doing scaling in MySQL 8, all parameters need to
    kept in mind, such as database back up, security, roles/privileges of the database
    and backward compatibility of the scaling. While doing scaling by clustering all
    data nodes need to be on the same page. If the application is developed using
    multiple technologies and we perform the scaling for each of the stack, we can
    have different data nodes available; in this case the database sync is one of
    the most important things that need to be sure in configuration while scaling.
    Which type of data should reside in cached memory in memcached and in disk should
    also be clear before we design scaling.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the application accesses data from the shared data nodes. If
    we have an e-commerce site and we perform the sharding for the same and at a certain
    level the data are not available for the client who uses the data of the other
    shard server for any reason, at that time the cross-node transaction would be
    required. It's completely based on the business behavior, and depends on how flexible
    the business is when it comes to accepting changes regarding database scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Understand server workload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the setup of flexibility, scale, and performance improvement many options
    and actions are available in MySQL 8\. Many people face issues while performing
    such activities because they do not have enough understanding or knowledge to
    handle various technology stacks and configuration option selections that can
    improve scalability, performance, security, and the flexibility of the application
    and deployment activity. These configuration options including clustering, replication,
    sharding, memcached, storage engine, and many more, which can be well designed
    to handle the whole workload of the application. The database workload and business
    behavior helps to decide the MySQL configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Read-write operation limit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happen if the read and write limit is reached and the transaction increases
    on the master database server. MySQL has limitations to the capacity; for instance
    if a number of customers are visiting the site at the same time that a read-write
    operation is running and the server or node are not synced, then at that time
    it will create confusion or misunderstanding for the end user. Or, in an e-commerce
    site, if one customer is purchasing the product, which is last item left in stock,
    and at same time another customer searches for the same product and it's still
    available, in this case both operations are not in sync in terms of the read and
    write operation of the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the other customer might purchase the same product, which we don't
    have in the warehouse. This impacts inventory calculation, and customers have
    doubts about the process of the purchase cycle. In that case we would loose the
    faith of the customer in the business and the credit of the business would also
    be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to have database sharding. Sharding can be simply stated
    as partitioning the database in multiple servers. Sharding helps to reduce the
    load on a single database or the master database. If we have databases sharding
    geographically, and for different country or region we have different servers
    for the database, we can solve the issue of the limit of read and write operations
    on the MySQL server. But again, the technique which we use for the sharding also
    determines the performance of the database. We have already learned about this
    in detail in [Chapter 9](4c6949e6-97d3-43b6-80f1-9d4a299669a2.xhtml), *Partitioning
    in MySQL 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have performed scaling in MySQL 8, we must know how to manage master
    and slave servers, and which configuration is required while performing scaling.
    What are the steps that need to be taken care of at the time when the server is
    in a critical stage? What steps needs to be performed at time of sharding, clustering,
    or replication of the database server?
  prefs: []
  type: TYPE_NORMAL
- en: Scaling is possible but its not an easy operation. If we want to perform scaling
    we should know that the database can handle more transactions without any issue.
    We should know the appropriate configuration to be done to overcome the default
    limits on the master server for the write and read operation. Once it's completed,
    we need to perform similarly steps to configure the slave database server, which
    should only have read operations available for the end user and should always
    be in sync with the master database.
  prefs: []
  type: TYPE_NORMAL
- en: If we have multiple servers, then the maintenance of the server also becomes
    a costly overhead. All the server needs to be on same page, configuration should
    be in proper manner, and the cost of the server will also affect the business.
    If the number of data constantly increases at that time, server space also needs
    to be managed in an appropriate manner.
  prefs: []
  type: TYPE_NORMAL
- en: Master server failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the master server fails and data is not available to the customer at that
    time, the end user will get frustrated and the business will be hampered in terms
    of credit in market and in losing the customer also. The business will have to
    suffer from the loss.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether we perform the scaling with clustering or replication, in both cases
    we need to secure synchronization. All slave servers should have the same database
    as the master server. If write operations are performed on the master server and
    read operations are performed on the slave server, at that time all data needs
    to be synced up. All results should be same, and if any server goes down at a
    time when data was not synced, it will create issues regarding the loss of data.
  prefs: []
  type: TYPE_NORMAL
- en: Database security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we secure the database if we have different servers and sharding is performed?
    If we have different database servers at different locations and access to the
    database is not restricted to the user specific at that time then the issue of
    a data leak is a strong possibility. We have to completely understand access points
    of the data in terms of IP configuration of the database server, with appropriate
    roles and privileges for the database users who perform various activities. Which
    IPs have access and which IPs need to restrict the data transaction from the server?
    While we are performing the cross node transaction on the database, accurate data
    should be available; it should not give the permission to access restricted data
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Cross node transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross node transaction is required when we have multiple nodes after doing scaling
    and one node requires the other node data as a part of input. For instance, if
    we have different nodes at different locations and we have a single inventory
    for all the locations at that time, one user request for any product that is not
    available in that data node at that time will have to communicate with other data
    nodes for the information of the product, based on the user's request.
  prefs: []
  type: TYPE_NORMAL
- en: Growing team for development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the application may have a positive response and its continuous success
    increase the business team, the expansion of the database administrators will
    also be required. When we performing sharing and scaling or replication in MySQL
    8, we require appropriate team members with the proper knowledge and experience
    to handle continuous expansion and the management of database servers. It's not
    only limited to the setup of database servers; we also need to keep an eye on
    maintenance of the server and keep watching the server activity also.
  prefs: []
  type: TYPE_NORMAL
- en: Manage change request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a change in any database structure and we have already performed
    the scaling or replication than a few things need to be taken care of as part
    of a change request, or if we add a new feature or an enhancement of the functionality.
    This includes things such as updating sharing keys, modifying the data distribution
    with replication of the nodes, updating the queries to take replication latency
    into account to avoid stale data with on-going managing shards, data balancing,
    and ensuring that data is available with new updates.
  prefs: []
  type: TYPE_NORMAL
- en: Scale-up and scale-out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scale-up describes the process of maximizing the capacity that a single MySQL
    node can handle. The process of scaling-up can involve optimally tuning your database
    software and choosing the right storage engine, as previously discussed in [Chapter
    6](16211f16-1fc2-419a-a040-46f7970fc4cc.xhtml), *MySQL 8 Storage Engines,* and
    selecting appropriate hardware. There are limits on how far you can scale-up a
    node and these are determined by some combination of data size, schema complexity,
    CPU cycles, system memory, and disk IO operations. While scale-out has been garnering
    much attention because of the need to handle increasingly massive data sets, it
    is very important to remember that the better we scale-up, the fewer scale-out
    nodes that we will require and so the less we need to spend on hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Scale-out can be used to deliver solutions that cover several different use
    cases. Some of most common ones are to increase read capacity by using replication
    or to use database sharding to increase total database size and overall transaction
    throughput.
  prefs: []
  type: TYPE_NORMAL
- en: All of these are the key challenges faced while scaling MySQL 8\. These challenges
    need to be considered while we are performing scaling of the database in MySQL
    8\. A single mistake can put a business into an situation which none of us would
    like to be in. Scaling is the the better way to improve the performance of the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving high availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High availability refers to systems that are durable and can perform operations
    without any hindrance on the data that is required for the response or any request
    from any mobile, web portals, websites, social, e-commerce, enterprise, and cloud
    applications. Data availability is considered an utmost concern for any business
    or organization. Any issues with downtime may have an impact on the business credit,
    and in some cases businesses have to suffer financial loss.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we have an e-commerce application with a single database server,
    if that server goes down for reasons such as hardware failure, network issue,
    virus, or operating system issues, it impacts the data also. An e-commerce application
    may have a large number of customer hits at same time, and any server failures
    to serve the response to user requests will impact the user; they will search
    for other options for the purchase commodity.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 8 has capabilities to provide backend for the application to help achieve
    high availability and prepare a fully scalable system. An ability of the system
    to keep the connection persistent, in case a part of the infrastructure fails,
    and the ability of the system to recover from such failures is considered high
    availability. A failure of the system can be caused by either a maintenance activity
    on one part of the system, such as a hardware or software upgrade, or by the failure
    of the installed software.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose of high availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements for achieving HA and scalability may vary from system to system.
    Each system requires a different configuration in order to achieve these abilities.
    MySQL 8 also supports different approaches, such as the replication of data across
    multiple MySQL servers, or preparing multiple data centers based on geographical
    locations and serving the client requests from the data centers closest to the
    location of the client. Such solutions can be used to achieve the highest uptime
    of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Today, in the world of competitive marketing, an organization's key point is
    to have their system up and running. Any failure or downtime directly impacts
    business and revenue. Hence, high availability is a factor that cannot be overlooked.
    MySQL is quite reliable and has constant availability using cluster and replication
    configurations. Cluster servers instantly handle failures and manage the failover
    part to keep your system available almost all the time. If one server gets down,
    it will redirect the user's request to another node and perform the requested
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Data availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is always available in any situation. In any application, data is the core
    part, which is actually the wealth of the application owner. If we have a health
    care system and at the time of medical check up of any patient their data is not
    available, due to server downtime or any other reason, it might block further
    process of the doctor and in this case impacts the life of the patient.
  prefs: []
  type: TYPE_NORMAL
- en: Security of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that comes to mind is securing data, because nowadays data has
    become precious and it can impact business continuity if legal obligations are
    not met; in fact, it can be so bad that it can close down your business in no
    time. MySQL is the most secure and reliable database management system, used by
    many well-known enterprises such as Facebook, Twitter, and Wikipedia. It really
    provides a good security layer that protects sensitive information from intruders.
    MySQL gives access control management so that granting and revoking required access
    on the user is easy. Roles can also be defined with a list of permissions that
    can be granted or revoked for the user. All user passwords are stored in an encrypted
    format using plugin-specific algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have a single database server, if it goes down for any reason we would
    lose the whole database, and if we have database backup available up to the current
    day, we can restore the database till that day, but all current transactions would
    also be lost in this case. The last transaction data would not be available at
    that time.
  prefs: []
  type: TYPE_NORMAL
- en: Backup of the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database backup till the last transaction should be in the plan when a business
    has any server base application where a single database server is performing all
    the tasks. When doing high availability, include all scenarios of the backup and
    restore operation in the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Competitive market
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the market many competitors are available with the same nature of business.
    In this case, if a business is having issues with data availability to end users,
    customers might not continue with that business and instead move to another provider.
    Its an integral part of business continuity.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High availability is also important in terms of the performance of the data
    operation. If we have a single server and all operations are performed on that
    server only, it will reach its limit at some stage, where the server capacity
    is exhausted. So, in that case, if we have high availability architecture implemented
    it would provide a means to load the balance of a transaction and the performance
    of the data manipulation operation. Replication and clustering enables for better
    concurrency and manages the workload.
  prefs: []
  type: TYPE_NORMAL
- en: Updates in the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While any online site or application requires updates or any new production
    release is planned it directly impacts the end users. If an application has only
    limited users at that time, we can manage the update regarding all end-users via
    emails or messages within the application before the release. But in cases where
    there are a large number of user in a single application, at that time it will
    impact the business. It will stop all users at the same time, and due to this
    running transactions would be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we have to think about selecting the right solution for the availability.
    Many things need to be kept in mind while we plan high availability in MySQL.
    The requirements for achieving HA and scalability may vary from system to system.
    Each system requires a different configuration in order to achieve these abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such solutions can be used to achieve the highest uptime of MySQL with regard
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The level of availability required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of application being deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepted best practices within your own environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In MySQL, replication and clustering are the best options for achieving high
    availability. All applications have their own architecture, and nature of their
    business needs to be considered when we are selecting any technique to achieve
    high availability of MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of high availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the advantages that we have when we perform high availability
    in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL is quite reliable and has constant availability using cluster and replication
    configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster servers instantly handle failures and manage the failover part to keep
    your system available almost all the time. If one server goes down, it will redirect
    the user's request to another node and perform the requested operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ability of the system to keep the connection persistent, in case a part of
    infrastructure fails, and the ability of the system to recover from such failure
    is considered as high availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL 8 also supports different approaches such as replication of data across
    multiple MySQL servers or preparing multiple data centers based on geographical
    locations and serving the client requests from the data centers closest to the
    location of the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL gives high speed transaction processing with optimal speed. It can cache
    the results, which boosts read performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication and clustering enables better concurrency and manages the workload.
    Group replication basically takes care of committing transactions once most of
    the members in group replication have acknowledged the transaction has been received
    concurrently. This helps create better throughput if the overall number of writes
    does not exceed the capacity of the members in the group replication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering enables data to be replicated to multiple MySQL servers with automated
    sharing. It is designed for better availability and throughput.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcached removes the SQL layer and directly accesses the InnoDB database tables.
    Hence, overhead operations like SQL parsing will no longer be executed, which
    really impacts the performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcached with MySQL also provides you with a way to make in-memory data persistent
    so that we can use it for various data types without losing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcached APIs are available in different programming languages such as Perl,
    Python, Java, PHP, C, and Ruby. With the help of a Memcached API, an application
    can interact with the Memcached interface to store and retrieve information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with an overview of scalability and high availability
    in MySQL 8, which covered the various scalability needs, advantages, methods,
    and key points to be noted when we make scalable designs of MySQL 8\. We also
    discussed the shortcomings that we generally come across when we perform scalability
    and how to overcome challenges with appropriate solutions. We have learned about
    scaling in MySQL 8 and troubleshooting challenges in scaling MySQL 8\. We also
    learned about many diverse ways to achieve high availability in MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will learn how to take care of MySQL 8 security.
    We will learn about general factors that affect security, the security of core
    MySQL 8 files, access control, and securing the database system itself. We will
    also learn the details of security plugins and gain an in-depth understanding
    of database security in general for relational databases.
  prefs: []
  type: TYPE_NORMAL
