- en: Chapter 5. Behavioral Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral design patterns are all about the communication between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Bearing in mind the Single Responsibility Principle, it is vital that classes
    only encapsulate one responsibility. Given this, there is clearly a necessity
    to allow objects to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: By using Behavioral design patterns, we are able to increase the flexibility
    by which we conduct these communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern (SplObserver/SplSubject)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The many Iterators of PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of Responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled Task pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personality traits for passionate programmers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start talking about Behavioral design patterns, let's talk about your
    behavior as a developer. Earlier in this book I've talked about how often development
    failures emerge as a result of bad management practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: A company introduces Scrum as a methodology (or another *Agile* methodology
    that is lacking in technical knowledge), without their code being agile enough
    to withstand code. In these scenarios, when a code is added, it is often botched
    into place and it will almost certainly be the case that the code takes far longer
    to implement than it would without technical debt. This leads to a slow development
    speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, a company follows a strictly pre-defined process and that methodology
    is set in stone. These processes are often unjustifiable but developers often
    follow them as they aren't educated in better processes, don't want to enter a
    bureaucratic dispute to alter them, or may even fear disciplinary action for attempting
    to improve a process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both these scenarios, a poor process is at the heart of the problem. Even
    when you're not dealing with a legacy project, this can become a problem due to
    the change of requirements throughout a property. A good property of software
    is the ability to change and, indeed, change the design of the software itself
    (we'll discuss this in the final chapter on refactoring).
  prefs: []
  type: TYPE_NORMAL
- en: Alastair Cockburn identified that software developers don't often fit into a
    pre-defined production-line process. Humans are unpredictable, and when they are
    the key actor in any given process, the process also becomes unpredictable. Humans
    are open to error and don't act perfectly in a pre-defined process when there
    is as much room for error as there is in software development. Fundamentally,
    this is why people must come before processes, as stated in the Agile manifesto.
    The developers must come before the process.
  prefs: []
  type: TYPE_NORMAL
- en: Some of those in management positions want to buy something called Agile. They'll
    hire a consultant who fails to understand how software development can really
    be made a success, and instead, implements a ridiculous process as part of a cash
    cow operation to sell Agile. I believe that Scrum is the worst example of this
    (in part because of the number of inaccurate courses and pseudo-qualifications),
    but no doubt other Agile processes can be used as cash cows.
  prefs: []
  type: TYPE_NORMAL
- en: I have repeatedly come into contact with managers or **Scrum Masters** who claim
    that *Scrum says we should do ...* or *Agile says we should do ...*. This is mentally
    illogical and should be avoided. When you make this statement you are fundamentally
    not understanding that an Agile methodology is based on the principle of agility,
    and as such, people must come above processes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review the first scenario again. Note that the dispute largely emerges
    from a lack of development quality instead of project management processes. Scrum
    fails to implement development processes and as a result, projects attempted through
    Scrum may often fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extreme Programming (XP) contains these development rules, which Scrum lacks.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards (in PHP, you may choose the PSR standards we discussed in earlier
    chapters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the unit test first and the code should be written so it passes the test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All production code is pair-programmed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dedicated integration server with only one pair integration code at a time
    with code being integrated frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use collective ownership; no part of the codebase is off limits to another developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all completed against a backdrop of fixing XP when it breaks, making
    improving the process a regular part of development.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing technical standards and development rules requires both a pre-existing
    knowledge of development with a passion for learning more; for this, a logical
    and evidence-driven thought process is vital. These are all critical elements
    of being a great software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Pair-programming must not become an effort in mentoring, it mustn't be a student-teacher
    relationship; both developers must be willing to put forward ideas and have such
    ideas criticized. Indeed, it is vital to be able to learn from each other.
  prefs: []
  type: TYPE_NORMAL
- en: In an Agile relationship, everyone must be willing to understand and contribute
    to the planning process, as such communication is a vital skill. Similarly, respect
    for each other is key; everyone from customers to developers deserves respect.
    Developers must be courageous in many ways, not least being truthful about progress
    and estimation while crucially also adapting to change. We must seek to understand
    the feedback we receive before addressing or dismissing it.
  prefs: []
  type: TYPE_NORMAL
- en: These skills aren't merely toggles or switches, they are open-ended skills and
    knowledge bases that we must seek to maintain and exercise. Things go wrong; through
    the use of feedback, we are able to ensure our code is of a sufficiently high
    quality before it is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern (SplObserver/SplSubject)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Observer design pattern essentially allows an object (the subject) to maintain
    a list of observers that are automatically notified when the state of the that
    object changes.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern applies a one-to-many dependency between objects; there is always
    one subject that updates many observers.
  prefs: []
  type: TYPE_NORMAL
- en: The Gang of Four originally identified that this pattern was particularly applicable
    in cases where an abstraction has two aspects, with one dependent on the other.
    In addition to this, it is very useful when a change to object requires changes
    to the others and you don't know how many other objects need to be changed. Finally,
    this pattern is also incredibly useful when an object should notify other objects
    without making assumptions about what those objects are, thus making this pattern
    great for loosely coupling this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: PHP provides a very useful interface called `SplObserver` and `SplSubject`.
    These interfaces provide the template for implementing the Observer design pattern
    while not actually implementing any functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, when we implement this pattern we allow an unlimited amount of objects
    to observe events in the subjects.
  prefs: []
  type: TYPE_NORMAL
- en: By calling an `attach` method in the `subject` object, we can attach an observer
    to the subject. When a change occurs in the subject, the subject's `notify` method
    can iterate through the observers and call their `update` method polymorphically.
  prefs: []
  type: TYPE_NORMAL
- en: We are also able to call an un-notify method in the subject which will allow
    us to stop an `observer` object from observing a `subject` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, the `Subject` class contains methods to attach and detach observers
    from itself, the class also contains a `notify` method to update the observers
    that are looking at it. Therefore, PHP''s `SplSubject` interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to this, our `SplObserver` interface looks even more simple; it merely
    needs to implement a single method that allows the subjects to update the observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how we can implement these two interfaces to implement this design
    pattern. In this example, we will have a news feed class that will update various
    readers that are reading the classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our `Feed` class, which will implement the `SplSubject` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The implementation we covered is, overall, quite simple. Notice how it's using
    the `spl_object_hash` function that we explored previously in this book to allow
    us to easily detach objects. By using the hash as the key for the array we are
    able to rapidly find a given object without needing to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define our `Reader` class, which will implement the `SplObserver`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap all this together in our `index.php` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script, we firstly instantiate a feed with three readers. We attach
    all of them, then detach one. Finally, we send a new alert, which produces the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observer pattern (SplObserver/SplSubject)](graphics/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main advantage of this design pattern surrounds the loosely coupled nature
    of the relationships between the observers and the subjects. There is greater
    modularity, as subjects and observers can independently vary. In addition to this,
    we can add as many observers as we want, providing as many pieces of functionality
    as we're after. This extensibility and customization is often the reason this
    design pattern is applied in the context of view for an application and is also
    often implemented in **Model-View-Controller** (**MVC**) frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of using this pattern come when we need to debug this whole
    thing; flow control can become difficult as observers don't know about each other.
    In addition to this, there is an update overhead, which can make memory management
    difficult when dealing with particularly large observers.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this design pattern is solely for use within one program, it's
    not designed for inter-process communication or a messaging system. Later in this
    book, we'll cover how you can use Messaging patterns to describe how different
    parts of a message parsing system interconnect when we want to allow intercommunication
    between different processes, and not just different classes within one process.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Iterator design pattern is where an iterator is used to traverse a container.
    In PHP, a class is traversable using the `foreach` construct if it ultimately
    inherits the Traversable interface. Unfortunately, this is an abstract base interface,
    you can't implement it alone (unless you're writing in the PHP core itself). Instead,
    you must instead implement interfaces called `Iterator` or `IteratorAggregate`.
    By implementing either of these interfaces you make a class iterable and traversable
    using `foreach`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterator` and `IteratorAggregate` interfaces are very similar, except the
    `IteratorAggregate` interface creates an external iterator. `IteratorAggregate`
    as an interface only requires outlines one method, `getIterator`. This method
    has to return an instance of the `ArrayIterator` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: IteratorAggregate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's suppose we want to create an implementation of this interface, which will
    iterate through various times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s start off with a basic implementation of the `IternatorAggregate`
    class to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can iterate through this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IteratorAggregate](graphics/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ve modified this script so that it takes a `time` value and calculates various
    values either side and makes them iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IteratorAggregate](graphics/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's suppose we want to create an implementation of this interface that will
    iterate through various times.
  prefs: []
  type: TYPE_NORMAL
- en: The many iterators of PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we've explored some functions in the **SPL (Standard PHP Library)**,
    which is a collection of interfaces and classes that exist to solve common problems.
    Given this aim, they share a common aim with design patterns, but they both aim
    to solve these problems in different ways. No external libraries are needed to
    build this extension and compile in PHP 7; indeed, you can't even disable it.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this library, there are a lot of iterators in the SPL. You can find
    a list of them in the documentation at [http://php.net/manual/en/spl.iterators.php](http://php.net/manual/en/spl.iterators.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of some of these iterators to give you an idea of what you can
    utilize them for:'
  prefs: []
  type: TYPE_NORMAL
- en: AppendIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CachingIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CallbackFilterIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DirectoryIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EmptyIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FilesystemIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FilterIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GlobIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InfiniteIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IteratorIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LimitIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MultipleIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoRewindIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ParentIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveArrayIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveCachingIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveCallbackFilterIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveDirectoryIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveFilterIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveIteratorIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveRegexIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RecursiveTreeIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RegexIterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP has a great mechanism to create iterators in a compact fashion. This type
    of iterator comes with some severe limitations; they are forward only and cannot
    be rewound. Indeed, even to simply start an iterator from the start, you must
    rebuild the generator. In essence, this is a forward-only iterator.
  prefs: []
  type: TYPE_NORMAL
- en: A function that uses the `yield` keyword instead of the `return` keyword. This
    will act in the same way as a `return` statement, but it will not stop the execution
    of that function. A generator function can `yield` data as many times as you please.
  prefs: []
  type: TYPE_NORMAL
- en: When you populate an array with values, those values must be stored in memory
    which can cause you to exceed your PHP memory limit or require a significant amount
    of processing time for the generator. When you put the logic in a generator function,
    that overhead does not exist. The generator function may merely yield as many
    results as it needs; there's no need to prepopulate an array first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple generator that will `var_dump` a string stating, the generator
    has started. The function will then generate the first five square numbers while
    also outputting their place in the series with `var_dump` . It will then finally
    indicate the generator has ended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of this script loops through this function and runs a `var_dump`
    string on each number. The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generators](graphics/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's amend this function slightly.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to note that if you add a return type to the variable,
    you can only declare a return type of `Generator`, `Iterator` or `Traversable`,
    `integer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generators](graphics/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What if we want to yield a key as well as a value? Well, this is fairly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s something else to mention about generators to those who used them
    in PHP 5: in PHP 5, when you want to simultaneously yield a variable while setting
    it to a variable, you must wrap the yield statement in brackets. This restriction
    does not exist in PHP 7.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This works in PHP 5 and 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This only works in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose we want to amend our generator so that it yields a key-value
    result. Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we test this, we will `var_dump` a two-dimensional array containing a key-value
    store of whatever the generator has yielded in a given iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generators](graphics/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just a few other tips, a yield statement with no variable (like the one shown
    in the succeding command) will simply yield `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You may also use `yield from` which will yield the inner values of any given
    generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have an array of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use `yield from` to yield an array of two values we get the inner values
    of the array. Let me demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generators](graphics/image_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, now let''s alter this script so that it uses `yield` instead of `yield
    from`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now see that instead of merely just the inner values of the array,
    we get the outer container too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generators](graphics/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Template Method design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Template Method design pattern is used to create a group of subclasses that
    have to execute a similar group of behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern consists of a Template Method, which is an abstract class.
    Concrete subclasses can override the methods within the abstract class. The Template
    Method consists of a skeleton of an algorithm; the subclasses can use overriding
    to change the concrete behavior of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: As such, this is an incredibly simple design pattern to use; it encourages loose
    coupling while also controlling at what points subclassing is permitted. Thus,
    it is more fine-grained than simple polymorphic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following abstraction of a `Pasta` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is a simple constructor for whether the pasta should contain cheese or
    not, and a `cook` function that runs the cooking algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the functions to add various ingredients are abstracted away; in subclasses,
    we implement these methods with the required behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to make meatball pasta. We can implement this abstract class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can sample this code using the following script in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to all the `var_dump` variables in the various functions displaying
    various status messages, we can see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template Method design pattern](graphics/image_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, suppose we want to make a vegan recipe instead. We can utilize the same
    abstraction in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time when it comes to adding meat or cheese, those functions do nothing;
    they can return `false` or a `null` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s amend our `index.php` file to represent this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template Method design pattern](graphics/image_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This design pattern is simple and easy to work with, but it fundamentally allows
    you to abstract your algorithm design and delegate that responsibility to subclasses
    where you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of Responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we have a group of objects that together are meant to solve a problem.
    When one object can't solve a problem, we want the object to send the task to
    a different object in a given chain. This is what the Chain of Responsibility
    design pattern is used for.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get this to work, we need a handler, which will be our `Chain` interface.
    The various objects in the chain will all implement this `Chain` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a simple example; an associate can purchase an asset for less
    than $100, a manager can purchase something for less than $500.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our abstraction for the `Purchaser` interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our first implementation is the `Associate` class. Quite simply, we implement
    the `setNextPurchaser` function so that it will set the `nextPurchaser` class
    property to the next object in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the `buy` function, if the price is within range, the associate
    will purchase it. If not, the next purchaser in the chain will purchase it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `Manager` class is exactly the same; we just allow the manager to purchase
    assets which are under $500\. In reality, when you apply this pattern you wouldn't
    just duplicate a class as your class would have different logic; this example
    is just an incredibly simple implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's run a basic purchase from an associate in our `index.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, here''s the code we put in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of all of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of Responsibility](graphics/image_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's test our `Manager` class. We'll amend our purchase price in our
    `index.php` file and also add our `Manager` class to the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our amended `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of Responsibility](graphics/image_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see what happens if we alter the price such that the purchase will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change the final line on our `index.php` file so the purchase price is now
    $600:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of Responsibility](graphics/image_05_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now extend this script. Let's add `DirectorPurchaser` and `BoardPurchaser`
    so we can make purchases at a higher cost.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a `DirectorPurchaser` who can buy under $10,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do the same for a `BoardPurchaser` class who can purchase below $100,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we can update our `index.php` script to require the new classes, instantiate
    them, and then bind everything together in a chain. Finally, we'll attempt to
    run a purchase by calling the first in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of Responsibility](graphics/image_05_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This allows us to traverse a chain of objects to process data. This is particularly
    useful when dealing with tree data structures (for example, an XML tree). This
    can act in a launch-and-leave manner where we can lower the overhead of handling
    iterating through the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the chain is loosely coupled, data is passed through a chain until
    it is processed. Any object can be chained to any other object in any order.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Strategy design pattern exists to allow us to alter the behavior of an object
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose we have a class that will raise a number to a power, but at runtime
    we want to alter whether we square or cube a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by defining an interface a function that will raise a number
    to a given power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can accordingly define classes to `Square` and also `Cube` a given number
    by implementing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `Square` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s define our `Cube` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can now build a class that will essentially use one of these classes to process
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can demonstrate this whole setup using an `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output is as expected, 5² is `25`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy design pattern](graphics/image_05_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can swap the `Square` object with the `Cube` object in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the updated script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy design pattern](graphics/image_05_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far so good; but the reason that this is great is the fact that we can dynamically
    add logic that actually changes the operation of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rather crude demonstration of all this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So just to demonstrate this, let''s run the script with the *n*`GET` variable
    set to `4`, which should cube the number `4`, giving an output of `64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy design pattern](graphics/image_05_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now if we pass through the number `6`, we expect the script to square the number
    `6`, giving an output of `36`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy design pattern](graphics/image_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this design pattern, we have done a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined a family of algorithms, bound by one common interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These algorithms are interchangeable; they can be swapped in and out without
    affecting the client implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We encapsulated each algorithm within a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can vary the algorithm independently from the clients that use it.
  prefs: []
  type: TYPE_NORMAL
- en: Specification design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Specification design pattern is incredibly powerful. Here, I will attempt
    to provide a high-level overview of it, but there is plenty to explore; I highly
    recommend the paper *Specifications* by *Eric Evans* and *Martin Fowler* if you
    are interested in learning more.
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern is used to codify business rules that state something about
    an object. They tell us whether an object satisfies some business criteria or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use them in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: To make assertions about an object, for *validation*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fetch a *selection* of objects from a given collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To specify how an object can be created by *building to order*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we're going to build Specification to query
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's kick things off with an `EmployeeSpecification` interface; this is the
    interface that all our specifications will need to implement. Be sure to replace
    `StdClass` with the type of object you're dealing with (for example, employee,
    or the name of the class you instantiated the object from).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to write an implementation called `EmployeeIsEngineer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then iterate through our workers to check which ones meet the criteria
    we outlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put this all together in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specification design pattern](graphics/image_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Composite Specifications allow you to combine specifications. By using the `AND`,
    `NOT`, `OR` and  `NOR` operators you are able to build their respective functions
    into different specification classes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can also fetch objects using a specification.
  prefs: []
  type: TYPE_NORMAL
- en: This code gets more complicated as you go further, but you understand the gist.
    Indeed, the paper by Eric Evans and Martin Fowler I mentioned at the start of
    the section goes into some far more complicated arrangements.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, this design pattern fundamentally allows us to encapsulate business
    logic to state something about an object. It is an incredibly powerful design
    pattern and I would highly encourage studying it more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled Task pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A scheduled task fundamentally consists of three things: the task itself, the
    jobs that do the scheduling by defining when the task that is being run and when
    it is permitted to run, and finally, the job registry that executes this job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly, these are implemented by using cron on Linux servers. You add a line
    to the `configuration` file using the following configuration syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can ordinarily edit the `cron` file by running `crontab -e` in the command
    line. You can schedule any Linux command using this pattern. Here''s a cronjob
    that will run a PHP script at 20:00 (8 PM) every day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'These are very simple to run to implement, but here are some guidelines to
    help guide you when you create them:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't expose your cronjobs to the Internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you run the task, the task shouldn't check the criteria as to whether it
    needs to run or not. This test should be outside the task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task should only do the scheduled activity it's intended to do and not perform
    any other purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beware of the Database-as-IPC pattern we discussed in [Chapter 7](ch07.html
    "Chapter 7. Refactoring"), Refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can put whatever you want in the task (within reason). You may find an asynchronous
    execution the best route. Icicle is a great PHP library for performing async behavior.
    You can find the documentation online at [https://icicle.io/](https://icicle.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Where our task needs several tasks to be done in a specific order, you may benefit
    from using the Composite design pattern we discussed in the Structural design
    patterns section and calling a single task that uses this pattern to call other
    tasks using this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered some patterns that identify common communication
    patterns between objects.
  prefs: []
  type: TYPE_NORMAL
- en: We covered how the Observer pattern can be used to update observers on the status
    of a given subject. Additionally, we learned how the standard PHP library contains
    functionality that can help us with this.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to cover how we can implement iterators in many different ways
    in PHP, using various interfaces in the PHP core alongside utilizing the generator
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to discuss how the Template pattern can define an algorithm skeleton
    that we can dynamically adapt in a more stringent way than standard polymorphism.
    We covered the Chain of Responsibility pattern, which allows us link together
    objects in a chain to execute various functionality. The Strategy pattern taught
    us how we can alter behavior of code at runtime. I then introduced the basics
    of the Specification pattern and how advanced the functionality in it is. Finally,
    we revised the Scheduled Task pattern and how it can be implemented using cron
    on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: These design patterns are some of the most critical ones for developers. Communication
    between objects is vital in many projects and these patterns can really aid us
    in this communication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at Architectural patterns and how these can
    help you with the software architecture tasks that arise and how these can help
    you address the broader software engineering challenges you may face (though they
    may not be technically considered design patterns themselves).
  prefs: []
  type: TYPE_NORMAL
