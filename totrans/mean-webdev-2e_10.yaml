- en: Chapter 10. Testing MEAN Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, you learned to build your real-time MEAN application.
    You went through Express and Angular basics and learned to connect all the parts
    together. However, when your application becomes bigger and more complex, you''ll
    soon find out that it''s very difficult to manually verify your code. You will
    then need to start testing your application automatically. Fortunately, testing
    a web application, which was once a complicated task, has become much easier with
    the help of new tools and suitable testing frameworks. In this chapter, you''ll
    learn to cover your MEAN application code using modern test frameworks and popular
    tools. We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JavaScript TDD and BDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your testing environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring the Mocha test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Express model and controller tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring the Karma test runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jasmine to unit test your Angular entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and running end-to-end Angular tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing JavaScript testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know, in the past couple of years, JavaScript has evolved dramatically.
    It was once a simple scripting language made for small web applications, but now
    it's the backbone for complex architectures, both in the server and the browser.
    However, this evolution has put developers in a situation where they need to manually
    manage a large code base that remained uncovered in terms of automated testing.
    While our fellow Java, .NET, or Ruby developers have been safely writing and running
    their tests, JavaScript developers remained in an uncharted territory, with the
    burden of figuring out how to properly test their applications. Lately, this void
    has been filled with the formation of new tools and testing frameworks written
    by the talented JavaScript community members. In this chapter, we'll cover some
    of these popular tools, but keep in mind that this field is fairly new and is
    constantly changing, so you'll also have to keep an eye out for newly emerging
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discuss two major types of tests: unit tests and **end-to-end**(**E2E**)
    tests. Unit tests are written to validate the functionality of isolated units
    of code. This means a developer should aspire to write each unit test to cover
    the smallest testable part of the application. For example, a developer might
    write unit tests to validate that an ORM method works properly and gives the right
    validation errors as output. However, quite often a developer will choose to write
    unit tests that verify bigger code units, mostly because these units perform an
    isolated operation together. If a developer wants to test a process that includes
    many of the software components combined, he will write an E2E test. E2E tests
    are written to validate cross-application functionality. These tests often force
    the developer to use more than one tool and cover different parts of the application
    in the same test, including UI, server, and database components. An example would
    be an E2E test that validates the signup process. Identifying the right tests
    is one of the crucial steps to writing a proper test suite for your application.
    However, setting appropriate conventions for the development team can make this
    process much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin discussing JavaScript-specific tools, let's first look at a
    quick overview of the TDD paradigm and how it affects our daily development cycles.
  prefs: []
  type: TYPE_NORMAL
- en: TDD, BDD, and unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is a software-development paradigm developed
    by software engineer and agile methodology advocate Kent Beck. In TDD, the developer
    starts by writing a (initially failing) test, which defines what is expected from
    an isolated unit of code. The developer is then required to implement the minimum
    amount of code that passes the test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the test is successfully passed, the developer cleans up the code and
    verifies that all the tests are passing. The following diagram illustrates TDD
    cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TDD, BDD, and unit testing](img/B05071_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to remember that although TDD has become a popular approach
    in modern software development, it is very difficult to implement in its purest
    form. To ease this process and improve team communication, a new approach was
    developed on top of TDD, called **Behavior-Driven Development** (**BDD**). The
    BDD paradigm is a subset of TDD, created by Dan North, that helps developers identify
    the scope of their unit tests and express their test process in behavioral terminology.
    Basically, TDD provides the wireframe for writing tests, and BDD provides the
    vocabulary to shape the way tests are written. Usually, a BDD test framework provides
    the developer with a set of self-explanatory methods to describe the test process.
  prefs: []
  type: TYPE_NORMAL
- en: Although BDD provides us with a mechanism for writing tests, running these tests
    in a JavaScript environment is still a complicated task. Your application will
    probably run on different browsers and even different versions of the same browser.
    So, running the tests you wrote on a single browser will not provide you with
    proper coverage. To solve this issue, the JavaScript community has developed a
    diverse set of tools for writing, evaluating, and properly running tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you can start writing your tests using your own library, you'll soon
    find out that it is not very scalable and requires you to build a complex infrastructure.
    Fortunately, considerable effort has been put into solving this issue, which has
    resulted in several popular test frameworks that allow you to write your tests
    in a structured and common way. These test frameworks usually provide a set of
    methods to encapsulate tests. It is also very common for a test framework to provide
    some sort of API that enables you to run tests and integrate the results with
    other tools in your development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though test frameworks provide the developer with a way to create and organize
    tests, they often lack the ability to actually test a Boolean expression that
    represents the test result. For instance, the Mocha test framework, which we'll
    introduce in the next section, doesn't provide the developer with an assertion
    tool. For this purpose, the community has developed several assertion libraries,
    which allow you to examine a certain predicate. The developer uses assertion expressions
    to indicate a predicate that should be true in the test context. When running
    the test, the assertion is evaluated, and if it turns out to be false, the test
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Test runners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test runners are utilities that enable the developer to easily run and evaluate
    tests. A test runner usually uses a defined testing framework along with a set
    of preconfigured properties to evaluate test results in different contexts. For
    instance, a test runner can be configured to run tests with different environment
    variables or run the same test on different testing platforms (usually browsers).
    We will look at two different test runners in the *Testing your Angular application*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have an overview of a set of terms associated with testing, you
    can finally learn how to test the different parts of your MEAN application. Although
    your code is written entirely in JavaScript, it does run on different platforms
    with different scenarios. In order to mitigate the testing process, I''ve divided
    it into two different sections: testing Express components and testing Angular
    components. Let''s begin with testing your Express application components.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Express part of your MEAN application, your business logic is mostly
    encapsulated inside controllers; however, you also have Mongoose models that obfuscate
    many tasks, including data manipulation and validations. So, to properly cover
    your Express application code, you will need to write tests that cover both models
    and controllers. In order to do so, you will use Mocha as your test framework,
    the `Should.js` assertion library for your models, and the `SuperTest HTTP` assertion
    library for your controllers. You will also need to create a new test environment
    configuration file that will provide you with special configuration options for
    testing purposes, for example, a dedicated MongoDB connection string. By the end
    of this section, you will learn to use the Mocha command-line tool to run and
    evaluate your test results. We'll begin with presenting the Mocha test framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mocha is a versatile test framework developed by Express creator TJ Holowaychuk.
    It supports both BDD and TDD unit tests, uses Node.js to run the tests, and allows
    the developer to run both synchronous and asynchronous tests. Since Mocha is minimal
    by structure, it doesn't include a built-in assertion library; instead, it supports
    the integration of popular assertion frameworks. It comes packed with a set of
    different reporters to present the test results and includes many features, such
    as pending tests, excluding tests, and skipping tests. The main interaction with
    Mocha is done using the command-line tool provided, which lets you configure the
    way tests are executed and reported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BDD interface for Mocha tests includes several descriptive methods, which
    enable the developer to easily describe the test scenario. These methods are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describe(description, callback)`: This is the basic method that wraps each
    test suite with a description. The callback function is used to define test specifications
    or sub-suites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it(description, callback)`: This is the basic method that wraps each test
    specification with a description. The callback function is used to define the
    actual test logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before(callback)`: This is a hook function that is executed once before all
    the tests in a test suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach(callback)`: This is a hook function that is executed before each
    test specification in a test suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after(callback)`: This is a hook function that is executed once after all
    the tests in a test suite are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach(callback)`: This is a hook function that is executed after each
    test specification in a test suite is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these basic methods will allow you to define unit tests by utilizing the
    BDD paradigm. However, no test can be concluded without including an assertion
    expression that determines the developer's expectations from the covered code.
    To support assertions, you will need to use an assertion library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Mocha's features by visiting the official documentation
    at [https://github.com/mochajs/mocha](https://github.com/mochajs/mocha).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Should.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Should.js` library, also developed by TJ Holowaychuk, aims to help developers
    write readable and expressive assertion expressions. Using `Should.js`, you''ll
    be able to keep your test code better organized and produce useful error messages.
    The `Should.js` library extends `Object.prototype` with a non-enumerable getter
    that allows you to express how that object should behave. One of `Should.js''`
    powerful features is that every assertion returns a wrapped object, so assertions
    can be chained. This means that you can write readable expressions that pretty
    much describe the assertions associated with the tested object. For example, a
    chained assertion expression would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how each helper property returns a Should.js object, which can be chained
    using another helper property (`be`, `an`, `have`, and so on) or tested using
    assertion properties and methods (`Object`, `property()`). You can learn more
    about Should.js' features by reading the official documentation at [https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js).
  prefs: []
  type: TYPE_NORMAL
- en: While Should.js does an excellent job testing objects, it will not help you
    with testing your HTTP endpoints. To do this, you will need to use a different
    kind of assertion library. This is where the minimal modularity of Mocha comes
    in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SuperTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SuperTest is another assertion library developed by TJ Holowaychuk, which differs
    from other assertion libraries by providing developers with an abstraction layer
    that makes HTTP assertions. This means that instead of testing objects, it will
    help you create assertion expressions that test HTTP endpoints. In your case,
    it will help you test your controller endpoints, thus covering the code that''s
    exposed to the browser. To do so, it will make use of the Express application
    object and test the responses returned from your Express endpoints. An example
    SuperTest assertion expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how each method can be chained to another assertion expression. This
    will allow you to make several assertions on the same response using the `expect()`
    method. You can learn more about SuperTest's features by visiting the official
    documentation at [https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to leverage Mocha, Should.js, and SuperTest
    to test both your models and your controllers. Let's begin by installing these
    dependencies and properly configuring the test environment. The examples in this
    chapter will continue directly from those in previous chapters, so copy the final
    example from [Chapter 9](ch09.html "Chapter 9. Adding Real-time Functionality
    Using Socket.io"), *Adding Real-time Functionality Using Socket.io*, and let's
    take it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocha is basically a Node.js module that provides command-line capabilities
    to run tests. The easiest way to use Mocha is to first install it as a global
    node module using `npm`. To do so, just issue the following command in your command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As usual, this will install the latest version of Mocha in your global `node_modules`
    folder. When the installation process is successfully finished, you'll be able
    to use the Mocha utility from your command line. Next, you'll need to install
    the Should.js and SuperTest assertion libraries in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may experience some trouble installing global modules. This is usually a
    permission issue, so use `sudo` or `super user` when running the global install
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Should.js and SuperTest modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can start writing your tests, you will need to install both `Should.js`
    and `SuperTest` using `npm`. To do so, change your project''s `package.json` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To install your new dependencies, go to your application''s root folder and
    issue the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will install the specified versions of `Should.js` and `SuperTest` in your
    project's `node modules` folder. When the installation process is successfully
    finished, you will be able to use these modules in your tests. Next, you'll need
    to prepare your project for testing by creating a new environment configuration
    file and setting up your test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your test environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since you''re going to run tests that include database manipulation, it would
    be safer to use a different configuration file to run tests. Fortunately, your
    project is already configured to use different configuration files according to
    the `NODE_ENV` variable. While the application automatically uses the `config/env/development.js`
    file, when running in a test environment, we will make sure to set the `NODE_ENV`
    variable to test. All you need to do is create a new configuration file named
    `test.js` in the `config/env` folder. In this new file, paste the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can notice, we changed the `db` property to use a different MongoDB database.
    Other properties remain the same, but you can change them later to test different
    configurations of your application.
  prefs: []
  type: TYPE_NORMAL
- en: You'll now need to create a new folder for your test files. To do so, go to
    your app folder and create a new folder named `tests`. Once you're done setting
    up your environment, you can continue to the next section and write your first
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Mocha test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you begin writing your tests, you will first need to identify and break
    your Express application's components into testable units. Since most of your
    application logic is already divided into models and controllers, the obvious
    way to go about this would be to test each model and controller individually.
    The next step would be to break this component into logical units of code and
    test each unit separately. For instance, take each method in your controller and
    write a set of tests for each method. You can also decide to test a couple of
    your controller's methods together when each method doesn't perform any significant
    operation by itself. Another example would be to take your Mongoose model and
    test each model method.
  prefs: []
  type: TYPE_NORMAL
- en: In BDD, every test begins by describing the test's purpose in natural language.
    This is done using the `describe()` method, which lets you define the test scenario's
    description and functionality. Describe blocks can be nested, which enables you
    to further elaborate on each test. Once you have your test's descriptive structure
    ready, you will be able to define a test specification using the `it()` method.
    Each `it()` block will be regarded as a single unit test by the test framework.
    Each test will also include a single assertion expression or multiple assertion
    expressions. The assertion expressions will basically function as Boolean test
    indicators for your test assumptions. When an assertion expression fails, it will
    usually provide the test framework with a traceable error object.
  prefs: []
  type: TYPE_NORMAL
- en: While this pretty much explains most of the tests you'll encounter, you'll also
    be able to use supportive methods that execute certain functionality in context
    with your tests. These supportive methods can be configured to run before or after
    a set of tests and even before or after each test is executed.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, you'll learn to easily use each method to test the
    articles module that you created in [Chapter 8](ch08.html "Chapter 8. Creating
    a MEAN CRUD Module"), *Creating a MEAN CRUD Module*. For the sake of simplicity,
    we will only implement a basic test suite for each component. This test suite
    could and should be largely expanded to ultimately provide decent code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although TDD clearly states that tests should be written before you start coding
    features, the structure of this book forces us to write tests that examine existing
    code. If you wish to implement real TDD in your development process, you should
    be aware that development cycles should begin by first writing the appropriate
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Express model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the model''s test example, we''ll write two tests that verify the model
    `save` method. To begin testing your `Article` Mongoose model, you will need to
    create a new file named `article.server.model.tests.js` in your `app/tests` folder.
    In your new file, paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's start breaking down the test code. First, you required your module dependencies
    and defined your global variables. Then, you began your test using a `describe()`
    method, which informs the test tool that this test is going to examine the `Article`
    model. Inside the `describe` block, we began by creating new `user` and `article`
    objects using the `beforeEach()` method. The `beforeEach()` method is used to
    define a block of code that runs before each test is executed. You can also replace
    it with the `before()` method, which will only get executed once, before all the
    tests are executed. Notice how the `beforeEach()` method informs the test framework
    that it can continue with the test's execution by calling the `done()` callback.
    This will allow the database operations to be completed before actually executing
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you created a new `describe` block, indicating that you were about to
    test the model save method. In this block, you created two tests using the `it()`
    method. The first test used the `article` object to save a new article. Then,
    you used the `Should.js` assertion library to validate that no error occurred.
    The second test checked the `Article` model validation by assigning an invalid
    value to the `title` property. This time, the `Should.js` assertion library was
    used to validate that an error actually occurred when trying to save an invalid
    `article` object.
  prefs: []
  type: TYPE_NORMAL
- en: You finished your tests by cleaning up the `Article` and `User` collections
    using the `afterEach()` method. Like with the `beforeEach()` method, this code
    will run after each test is executed, and can also be replaced with an `after()`
    method. The `done()` method is also used here in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you created your first unit test! As we stated earlier, you
    can continue expanding this test suite to cover more of the model code, which
    you probably will when dealing with more complicated objects. Next, we'll see
    how you can write more advanced unit tests when covering your controller's code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the controller test example, we''ll write two tests to check the controller''s
    methods that retrieve articles. When setting out to write these tests, we have
    two options: either test the controller''s methods directly or use the defined
    controller''s Express routes in the tests. Although it is preferable to test each
    unit separately, we would choose to go with the second option since our routes''
    definitions are quite simple, so we can benefit from writing more inclusive tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin testing your articles controller, you will need to create a new file
    named `articles.server.controller.tests.js` in your `app/tests` folder. In your
    new file, paste the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just as with your model test, first you required your module dependencies and
    defined your global variables. Then, you started your test using a `describe()`
    method, which informs the test tool that this test is going to examine the `Articles`
    controller. Inside the `describe` block, we began by creating new `user` and `article`
    objects using the `beforeEach()` method. This time, we saved the article before
    initiating the tests, and then continued with test execution by calling the `done()`
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you created a new `describe` block indicating that you were about to test
    the controllers' `GET` methods. In this block, you created two tests using the
    `it()` method. The first test uses the `SuperTest` assertion library to issue
    an HTTP `GET` request at the endpoint that returns the list of articles. It then
    examines the HTTP response variables, including the `content-type` header and
    the HTTP response code. When it verifies the response is returned properly, it
    uses three `Should.js` assertion expressions to test the response body. The response
    body should be an array of articles that includes a single article which should
    be similar to the article you created in the `beforeEach()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The second test uses the `SuperTest` assertion library to issue an HTTP `GET`
    request at the endpoint that returns a single article. It then examines the HTTP
    response variables, including the `content-type` header and the HTTP response
    code. Once it verifies that the response is returned properly, it uses three `Should.js`
    assertion expressions to test the response body. The response body should be a
    single `article` object and should be similar to the article you created in the
    `beforeEach()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Just as before, you finished your tests by cleaning up the `Article` and `User`
    collections using the `afterEach()` method. Once you're done setting up the testing
    environment and creating your tests, all you have left to do is run them using
    Mocha's command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Mocha test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run your Mocha test, you need to use Mocha''s command-line utility, which
    you previously installed. To do so, use your command-line tool and navigate to
    your project''s base folder. Then, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users should first execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run Mocha using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will do a few things. First, it will set the `NODE_ENV`
    variable to `test`, forcing your MEAN application to use the test environment''s
    configuration file. Then, it will execute the Mocha command-line utility with
    the `--reporter` flag, telling Mocha to use the `spec` reporter and the path to
    your tests folder. The test results should be reported in your command-line tool
    and will be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running your Mocha test](img/B05071_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mocha's test results
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the test coverage of your Express application. You can use these
    methods to expand your test suite and dramatically improve application development.
    It is recommended that you set your test conventions from the beginning of your
    development process; otherwise, writing tests can become an overwhelming experience.
    Next, you'll learn to test your Angular components and write E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For years, testing frontend code was a complex task. Running tests across different
    browsers and platforms was complicated, and since most of the application code
    was unstructured, test tools mainly focused on UI E2E tests. However, the shift
    towards MVC frameworks allowed the community to create better test utilities,
    improving the way developers write both unit and E2E tests. In fact, the Angular
    team is so focused on testing that every feature developed by the team is designed
    with testability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, platform fragmentation also created a new layer of tools called
    test runners, which allow developers to easily run their tests in different contexts
    and platforms. In this section, we''ll focus on tools and frameworks associated
    with Angular applications, explaining how to best use them to write and run both
    unit and E2E tests. We''ll start with the test framework that will serve us in
    both cases: the Jasmine test framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we can use Mocha or any other test framework, using Jasmine is currently
    the easiest and most common approach when testing Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Jasmine framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jasmine is an opinionated BDD framework developed by the Pivotal organization.
    Conveniently, Jasmine uses the same terminology as Mocha''s BDD interface, including
    the `describe()`, `it()`, `beforeEach()`, and `afterEach()` methods. However,
    unlike Mocha, Jasmine comes prebundled with assertion capabilities, using the
    `expect()` method chained with assertion methods called **Matchers**. Matchers
    are basically functions that implement a Boolean comparison between an actual
    object and an expected value. For instance, a simple test using the `toBe()` matcher
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `toBe()` matcher uses the `===` operator to compare objects. Jasmine includes
    plenty of other matchers and even enables developers to add custom matchers. Jasmine
    also includes other robust features to allow more advanced test suites. In the
    next section, we'll focus on how to use Jasmine to easily test your Angular components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Jasmine's features by visiting the official documentation
    at [http://jasmine.github.io/2.5/introduction.html](http://jasmine.github.io/2.5/introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: Angular unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, web developers who wanted to write unit tests to cover their frontend
    code had to struggle with determining their test scope and properly organizing
    their test suite. However, the inherent separation of concerns in Angular forces
    the developer to write isolated units of code, making the testing process much
    simpler. Developers can now quickly identify the units they need to test, so components,
    services, directives, and any other Angular entities can be tested as standalone
    units. Furthermore, the extensive use of dependency injection in Angular enables
    developers to switch contexts and easily cover their code with an extensive test
    suite. However, before you begin writing tests for your Angular application, you
    will first need to prepare your test environment, beginning with the Karma test
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Karma test runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Karma test runner is a utility developed by the Angular team that helps
    developers execute tests in different browsers. It does so by starting a web server
    that runs source code with test code on selected browsers, reporting the tests
    result back to the command-line utility. Karma offers real test results for real
    devices and browsers, flow control for IDEs and the command line, and framework-agnostic
    testability. It also provides developers with a set of plugins that enables them
    to run tests with the most popular test frameworks. The team also provides special
    plugins called browser launchers that enable Karma to run tests on selected browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will use the Jasmine test framework along with a PhantomJS browser
    launcher. However, testing real applications will require you to expand Karma's
    configuration to include more launchers and execute tests on the browsers you
    intend to support.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PhantomJS is a headless WebKit browser often used in programmable scenarios
    where you don't need a visual output; that's why it works perfectly for testing
    purposes. You can learn more about PhantomJS by visiting the official documentation
    at [http://phantomjs.org/documentation/](http://phantomjs.org/documentation/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Karma command-line tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to start using Karma is to globally install the command-line
    tool provided using `npm`. To do so, just issue the following command in your
    command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will install the latest version of Karma's command-line utility in your
    global `node_modules` folder. When the installation process is successfully finished,
    you'll be able to use the Karma utility from your command line. Next, you'll need
    to install Karma's project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may experience some trouble installing global modules. This is usually a
    permission issue, so use `sudo` or super user when running the global install
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Karma's dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can start writing your tests, you will need to install Karma''s
    dependencies using `npm`. To do so, change your `package.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you added Karma and Jasmine core packages, Karma''s Jasmine
    plugin, and Karma''s PhantomJS launcher to your `devDependencies` property. To
    install your new dependencies, go to your application''s `root` folder and issue
    the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will install the specified version of Karma's core package, Karma's Jasmine
    plugin, and Karma's PhantomJS launcher in your project's `node_modules` folder.
    When the installation process is successfully finished, you will be able to use
    these modules to run your tests. Next, you'll need to configure Karma's execution
    by adding a Karma configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Karma test runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to control Karma''s test execution, you will need to configure Karma
    using a special configuration file placed at the `root` folder of your application.
    When executed, Karma will automatically look for the default configuration file,
    named `karma.conf.js`, in the application''s `root` folder. You can also indicate
    your configuration file''s name using a command-line flag, but for simplicity
    reasons, we''ll use the default filename. To start configuring Karma, create a
    new file in your application folder, and name it `karma.conf.js`. In your new
    file, paste the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Karma''s configuration file is used to set the way Karma executes
    tests. In this case, we used the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`basePath`: This tells Karma to use an empty base path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frameworks`: This tells Karma to use the Jasmine framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files`: This sets the list of files that Karma will include in its tests.
    Notice that you can use glob patterns to indicate file patterns. In this case,
    we included all of our library files and module files, excluding our test files.
    Moreover, we configured our application and library files to be served by the
    Karma server even though they''re not being included directly in the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reporters`: This sets the way Karma reports its test results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browsers`: This is a list of browsers Karma will test on. Note that we can
    only use the PhantomJS browser since we haven''t installed any other launcher
    plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`captureTimeout`: This sets the timeout for Karma test execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`singleRun`: This forces Karma to quit after it finishes the test execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties are project oriented, which means they will change according
    to your requirements. For instance, you'll probably include more browser launchers
    in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Karma's configuration by visiting the official documentation
    at [https://karma-runner.github.io/1.0/config/configuration-file.html](https://karma-runner.github.io/1.0/config/configuration-file.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two more things to do in order to finish with our Karma configuration.
    We''ll begin by modifying the `System.js` configuration. To do so, go to your
    `public`/s`ystemjs.config.js` file and change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we only told `System.js` to map our Angular testing modules
    to the right `UMD` module file. Next, we''ll need to create our karma "shim" file
    that actually loads our tests. To do so, create a new file named `karma.shim.js`
    in the `root` folder of your application. Inside your new file, paste the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our file basically stops Karma from running the tests automatically
    on startup by overriding the loaded hook. Then, it loads the `System.js` configuration
    file and imports our test files. Once it loads all the files, it tells Karma to
    run the tests by calling its start hook. That's it! All we have left to do is
    to start writing our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Angular unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you're done configuring your test environment, writing unit tests becomes
    an easy task. While the general structure is the same, each entity test is a bit
    different and involves subtle changes. In this section, you'll learn how to test
    the major Angular entities. Let's begin with testing a component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing a component can vary in complexity. A simple component is quite easy
    to test, while more complicated components can be a bit tricky. A good intermediate
    example would be to test our articles list component, since it uses a service
    and it renders a simple DOM for our articles. To test your component, go to your
    `public/app/articles/list` folder and create a file named `list.component.spec.ts`.
    In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over this example. We begin with importing all the necessary modules
    for our test. Next, we create the `MockArticlesService`, which will replace our
    `ArticlesService` in order to provide the `ListComponent` with a list of articles.
    This is an important step, because as we write our unit tests, it's very important
    to isolate each unit as much as possible. In this case, we want to avoid any connection
    to the real `ArticlesService`, so we'll provide our component with a static data
    source. Then, we create a mock `routerLink` so that our component test can render
    our links.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our test suite using the `describe` keyword, and we use Angular's
    `TestBed` object to configure our testing module. We provide the `configureTestingModule`
    method with the declarations and providers we need in our module and then use
    the `TestBed` object again to create a component fixture of our `ListComponent`.
    We then create our test using the `it` keyword and use the component fixture to
    get our `ListComponent` native element, so we'll be able to compare it with the
    data from the `MockArticlesService` using Jasmine's matchers. This is it! Next,
    we'll see how we test services, but before we can do so, we'll need to learn how
    to mock a backend data service.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking backend data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While testing an Angular application, it is recommended that unit tests execute
    quickly and separately from the backend server. This is because we want the unit
    tests to be as isolated as possible and work in a synchronous manner. This means
    we need to control the dependency-injection process and provide mock components
    that emulate real components' operation. For instance, most of the components
    that communicate with the backend server usually use the `http` service or some
    sort of abstraction layer. Furthermore, the `Http` service sends requests to the
    server using the `XHRBackend` service. This means that by injecting a different
    backend service, we can send fake HTTP requests that won't hit a real server.
    As we previously stated, the Angular team is very committed to testing, so they've
    already created these tools for us in the form of the `MockBackend` class. The
    `MockBackend` class allows developers to define mock responses to HTTP requests.
    This class can be injected into any service that uses the `Http` service and be
    configured to supply HTTP requests with predefined data. Let's see how it can
    be used to test our `ArticlesService`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing services is a bit different from testing components. As we previously
    discussed, we''ll need to use the `MockBackend` class in order to mock our service
    HTTP requests. Let''s see how this can be applied with our `ArticlesService`.
    To create a sample test suite of our service, go to your `public/app/articles`
    folder and create a file named `articles.service.spec.ts`. In your new file, paste
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over this example. We begin with importing all the necessary modules
    for our test. Next, we create our test suite using the `describe` keyword and
    utilize Angular's `TestBed` object to configure our testing module. We provide
    the `configureTestingModule` method with the `ArticlesService` provider and the
    `MockBackend` as our `XHRBackend` provider. We then inject it along with the HTTP
    service and create an instance of our `ArticlesService`. In our actual test, we
    create a mock response and tell our `MockBackend` instance to respond with our
    mock response by subscribing to its connections. We finish our test by calling
    the `create` method of our `ArticlesService` and expect it to respond with our
    mock article instance properties. That's it! We've just tested one of the methods
    of our `ArticlesService`; to complete the test suite, you'll need to test the
    others as well. Next, we'll learn how to test our Angular routes definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing routes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To test our routes, we will need to make sure our router can navigate to our
    application''s URLs. In our case, we can test the routes created in our `AppComponent`.
    To do so, go to your `public/app` folder and create a file named `app.routes.spec.ts`.
    In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can notice, testing routes is quite simple. We're just using Angular's
    `TestBed` object to create our testing module and import the `RouterTestingModule`.
    Next, we use our component injector to get the `location` instance. In our tests,
    we just use the `location.go` method and check whether the location path changed
    accordingly. Next, we'll learn how we can write unit tests for directives.
  prefs: []
  type: TYPE_NORMAL
- en: Testing directives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing directives in Angular 2 is basically testing the way structural and
    attribute directives affect the DOM. For instance, to test the `ngIf` directive,
    you can go to your `public/app` folder and create a file named `directive.spec.ts`.
    In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we created a `TestComponent` for our directive and then used the
    `TestBed` utility to generate our component instance and test the way the `ngIf`
    directive changes the rendering of the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pipes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with directives, we haven''t touched the subject of pipes enough. However,
    pipes are a very simple yet powerful component of Angular that help us easily
    transform data into readable format. The Angular pipes vary in functionality from
    simple case changing to date and internationalization, but most importantly, you
    can write your own pipes. Testing a pipe is very easy, since all you have to do
    is instantiate the `Pipe` class and provide it with input and expected output.
    For instance, to test Angular''s `LowerCasePipe` class, you will need to go to
    your `public/app` folder and create a file named `pipe.spec.ts`. In your new file,
    paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can notice, we just imported the `LowerCasePipe` class and used its transform
    method to check its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a few unit tests, let's see how you can execute it using Karma's
    command-line utility.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Angular unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run your Angular tests, you will need to use the Karma''s command-line utility
    you previously installed. Before you can do that, we''ll need to finish our test
    setup. To do so, go to your `public/app` folder and create a file named `bootstrap.spec.ts`.
    In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set the test environment for us with the proper platform modules.
    Now all you have left to do is to go to your project''s base folder and then issue
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile your TypeScript files, so you will now be able to run Karma
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users should first execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run your tests using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will do a few things. First, it will set the `NODE_ENV`
    variable to `test`, forcing your MEAN application to use the test environment
    configuration file. Then, it will execute the Karma command-line utility. The
    test results should be reported in your command-line tool, similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running your Angular unit tests](img/B05071_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Karma's test results
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the unit-test coverage of your Angular application. It is recommended
    that you use these methods to expand your test suite and include more tests. In
    the next subsection, you'll learn about Angular E2E testing and how to write and
    run a cross-application E2E test.
  prefs: []
  type: TYPE_NORMAL
- en: Angular E2E tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While unit tests serve as the first layer to keep our applications covered,
    it is sometimes necessary to write tests that involve several components together
    that react with a certain interface. The Angular team often refers to these tests
    as E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this better, let's say Bob is an excellent frontend developer
    who keeps his Angular code well tested. Alice is also an excellent developer,
    but she works on the backend code, making sure her Express controllers and models
    are all covered. In theory, this team of two does a superb job, but when they
    finish writing the login feature of their MEAN application, they suddenly discover
    it's failing. When they dig deeper, they find out that Bob's code is sending a
    certain `JSON` object, while Alice's backend controller is expecting a slightly
    different `JSON` object. The fact is that both of them did their job, but the
    code is still failing. You might say this is the team leader's fault, but we've
    all been there at some point or another, and while this is just a small example,
    modern applications tend to become very complex. This means that you cannot just
    trust manual testing or even unit tests. You will need to find a way to test features
    across the entire application, and this is why E2E tests are so important.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Protractor test runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute E2E tests, you will need some sort of tool that emulates user behavior.
    In the past, the Angular team advocated a tool called the **Angular scenario test
    runner**. However, they decided to abandon this tool and create a new test runner
    called **Protractor**. Protractor is a dedicated E2E test runner that simulates
    human interactions and runs tests using the Jasmine test framework. It is basically
    a Node.js tool that uses a neat library called **WebDriver**. WebDriver is an
    open source utility that allows programmable control over a web browser''s behavior.
    As I stated, Protractor uses Jasmine by default, so tests will look very similar
    to the unit tests you wrote before, but Protractor also provides you with several
    global objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`browser`: This is a `WebDriver` instance wrapper that allows you to communicate
    with the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`element`: This is a helper function to manipulate HTML elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`by`: This is a collection of element locator functions. You can use it to
    find an element by a CSS selector, its ID, or even by the model property it''s
    bound to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protractor`: This is a `WebDriver` namespace wrapper containing a set of static
    classes and variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these utilities, you'll be able to perform browser operations inside your
    tests' specifications. For instance, the `browser.get()` method will load a page
    for you to perform tests on. It is important to remember that Protractor is a
    dedicated tool for Angular applications, so the `browser.get()` method will throw
    an error if the page it tries to load doesn't include the Angular library. You'll
    write your first E2E test in a moment, but first, let's install Protractor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor is kind of a young tool, so things are bound to change rapidly. It
    is recommended that you learn more about Protractor by visiting the official repository
    page at [https://github.com/angular/protractor](https://github.com/angular/protractor).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Protractor test runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protractor is a command-line tool, so you''ll need to globally install it using
    `npm`. To do so, just issue the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will install the latest version of the Protractor command-line utilities
    in your global `node_modules` folder. When the installation process is successfully
    finished, you'll be able to use Protractor from your command line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may experience some trouble when installing global modules. This is usually
    a permission issue, so use `sudo` or `super user` when running the global install
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Protractor will need a working WebDriver server, you will either need
    to use a Selenium server or install a standalone WebDriver server. You can download
    and install a standalone server by issuing the following command in your command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will install the Selenium standalone server, which you'll later use to
    handle Protractor's tests. The next step would be to configure Protractor's execution
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about WebDriver by visiting the official project page at
    [http://www.seleniumhq.org/](http://www.seleniumhq.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Protractor test runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to control Protractor''s test execution, you will need to create a
    Protractor configuration file in the `root` folder of your application. When executed,
    Protractor will automatically look for a configuration file named `protractor.conf.js`
    in your application''s `root` folder. You can also indicate your configuration
    filename using a command-line flag, but for simplicity reasons, we''ll use the
    default filename. So begin by creating a new file named `protractor.conf.js` in
    your application''s `root` folder. In your new file, paste the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our Protractor configuration file is very basic. The `specs` property basically
    tells Protractor where to find the test files, and the `useAllAngular2AppRoots`
    property tells Protractor to go over all Angular apps available in the page. This
    configuration is project oriented, which means that it will change according to
    your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Protractor's configuration by going over the example
    configuration file at [https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts).
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first E2E test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since E2E tests are quite complicated to write and read, we''ll begin with
    a simple example. In our example, we''ll test the **Create Article** page and
    try to create a new article. Since we didn''t log in first, an error should occur
    and be presented to the user. To implement this test, go to your `public/tests`
    folder and create a new folder named `e2e`, inside this folder, create a new folder
    named `articles`. Inside the `articles` folder, create a new file named `articles.client.e2e.tests.js`.
    Finally, in your new file, paste the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The general test structure should already be familiar to you; however, the test
    itself is quite different. We began by requesting the **Create Article** page
    using the `browser.get()` method. Then, we used the `element()` and `by.css()`
    methods to submit the form. Finally, we found the error message element using
    `by.id()` and validated the error text. While this is a simple example, it nicely
    illustrates the way E2E tests work. Next we'll use Protractor to run this test.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Angular E2E tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Protractor is a bit different from using Karma and Mocha. Protractor
    needs your application to run so that it can access it just like a real user does.
    So let''s begin by running the application; navigate to your application''s `root`
    folder and use your command-line tool to start the MEAN application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users should first execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start your MEAN application using the test environment''s configuration
    file. Now, open a new command-line window and navigate to your application''s
    `root` folder. Then, start the Protractor test runner by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Protractor should run your tests and report the results in your command-line
    window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running your Angular E2E tests](img/B05071_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Protractor's test results
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now know how to cover your application code with E2E tests.
    It is recommended that you use these methods to expand your test suite and include
    extensive E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to test your MEAN application. You learned
    about testing in general and the common TDD/BDD testing paradigms. You then used
    the Mocha test framework and created controller and model unit tests, where you
    utilized different assertion libraries. Then, we discussed the methods of testing
    Angular, where you learned the difference between unit and E2E testing. We then
    proceeded to unit test your Angular application using the Jasmine test framework
    and the Karma test runner. Then, you learned how to create and run E2E tests using
    Protractor. Once you've built and tested your real-time MEAN application, in the
    next chapter, you'll learn how to improve your development-cycle time using some
    popular automation tools.
  prefs: []
  type: TYPE_NORMAL
