- en: '*Chapter 1*: Beginning Android and Java'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Android Programming for Beginners Third Edition*. In this first
    chapter, we won't waste any time getting started with developing Android apps.
    We will look at what is so great about Android, what exactly Android and Java
    are, how they work and complement each other, and what that means to us as future
    developers. Moving quickly on, we will set up the required software so we can
    build and deploy a simple first app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is my aim to keep this book up to date. Please check the following web page
    for any discussion and tips on any changes to Android Studio since the book was
    first printed: [http://gamecodeschool.com/books/android-programming-for-beginners-3rd-edition#android-studio-updates](http://gamecodeschool.com/books/android-programming-for-beginners-3rd-edition#android-studio-updates).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovered what is new in this third edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how Java and Android work together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up our development environment – Android Studio – which takes care of all
    the components involved in building the Android apps that we will learn about
    next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned about the **Java Development Kit** (**JDK**) and the Android **Application
    Programming Interface** (**API**) and how we use them through Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built our very first Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployed the app on an Android emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run our app on an Android emulator and a real device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a lot to get through, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are the official technical requirements for Android development
    with Android Studio and its related tools. However, these are the absolute bare
    minimum. Please see the *Setting up Android Studio* section for further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for Windows are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft® Windows® 7/8/10 (64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB RAM as a minimum; 8 GB RAM recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 GB of available disk space as a minimum; 4 GB recommended (500 MB for the
    **Integrated Development Environment** (**IDE**) + 1.5 GB for the Android **Software
    Development Kit** (**SDK**) and emulator system image)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,280 x 800 minimum screen resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The requirements for Mac are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mac® OS X® 10.10 (Yosemite) or higher, up to 10.14 (macOS Mojave)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB RAM as a minimum; 8 GB RAM recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 GB of available disk space as a minimum; 4 GB recommended (500 MB for the
    IDE + 1.5 GB for the Android SDK and emulator system image)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,280 x 800 minimum screen resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The requirements for Linux are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: GNOME or KDE desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tested on gLinux based on Debian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64-bit distribution capable of running 32-bit applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU C Library (glibc) 2.19 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB RAM as a minimum; 8 GB RAM recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 GB of available disk space as a minimum; 4 GB recommended (500 MB for the
    IDE + 1.5 GB for the Android SDK and emulator system image)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,280 x 800 minimum screen resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2001](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2001).
  prefs: []
  type: TYPE_NORMAL
- en: What's new in the third edition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second edition saw huge amounts of additional topics compared to the first
    edition. Unfortunately, there are only so many pages that can fit in a paperback
    book. Therefore, this edition focuses on improving the way that the Java, Android,
    and app development concepts are taught. We have rethought the way that topics
    are explained and made it more visual than before. In addition, I have managed
    to squeeze in about a dozen new mini topics. These are either Java fundamentals
    such as variable types not covered in earlier editions, new Android Studio features
    such as the profiler, or classic programming concepts such as method recursion
    and the live debugging of our code. Hopefully, this third edition will therefore
    make your Android and Java journeys smoother and more complete.
  prefs: []
  type: TYPE_NORMAL
- en: Why Java and Android?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Android first arrived in 2008, it was a bit drab compared to the much more
    stylish iOS on the Apple iPhone/iPad. But quite quickly, through diverse handset
    offerings that struck a chord with both the practical price-conscious as well
    as the fashion-conscious and tech-savvy, the Android user numbers exploded.
  prefs: []
  type: TYPE_NORMAL
- en: For many, myself included, developing for Android is the most rewarding pastime
    and business bar none.
  prefs: []
  type: TYPE_NORMAL
- en: Quickly putting together a prototype of an idea, refining it, and then deciding
    to run with it and wire it up into a fully fledged app is such an exciting and
    rewarding process. Any programming can be fun, and I have been programming all
    my life, but creating for Android is somehow extraordinarily rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: Defining exactly why this is the case is quite difficult. Perhaps it is the
    fact that the platform is free and open source. You can distribute your apps without
    needing the permission of a big, controlling corporation – nobody can stop you.
    At the same time, you have well-established, corporate-controlled mass markets
    such as Amazon Appstore and Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: More likely, the reason why developing for Android gives such a good feeling
    is the nature of the devices themselves. They are deeply personal. You can develop
    apps that interact with people's lives – educate, entertain, tell a story, and
    so on – and it is there in their pockets ready to go, in the home, in the workplace,
    or on holiday.
  prefs: []
  type: TYPE_NORMAL
- en: You can certainly build something bigger for the desktop. But knowing that thousands
    (or millions) of people are carrying your work in their pockets and sharing it
    with friends gives more than just a buzz.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, developing for Android is considered highly skillful and the most successful
    developers are hugely admired, even revered.
  prefs: []
  type: TYPE_NORMAL
- en: If all this fluffy and spiritual stuff doesn't mean anything to you, then that's
    fine too; developing for Android can make you a living or even make you wealthy.
    With the continued growth of device ownership, the ongoing increase in CPU and
    GPU power, and the non-stop evolution of the Android operating system itself,
    the need for professional app developers is only going to grow.
  prefs: []
  type: TYPE_NORMAL
- en: In short, the best Android developers – and, more importantly, the Android developers
    with the best ideas and most determination – are in greater demand than ever.
    Nobody knows who these future Android app developers are and they might not even
    have written their first line of Java yet.
  prefs: []
  type: TYPE_NORMAL
- en: So, why isn't everybody an Android developer? Obviously, not everybody will
    share my enthusiasm for the thrill of creating software that can help people make
    their lives better, but I am guessing that because you are reading this, you might!
  prefs: []
  type: TYPE_NORMAL
- en: The beginner's first stumbling block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, for those that do share my enthusiasm, there is a kind of glass
    wall on the path of progress that frustrates many aspiring Android developers.
  prefs: []
  type: TYPE_NORMAL
- en: Android uses Java to make apps. Every Android book, even those aimed at so-called
    beginners, assumes readers have at least an intermediate level of Java knowledge,
    and most need an advanced level. So, good-to-excellent Java knowledge *was* a
    prerequisite for learning Android.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, learning Java in a completely different context to Android can
    sometimes be a little dull and much of what you learn is not directly transferable
    to the world of Android anyway. You can see why beginners to Android and Java
    are often put off from starting.
  prefs: []
  type: TYPE_NORMAL
- en: But it doesn't need to be like this. In this book, I have carefully placed all
    the Java topics you would learn in a thick and weighty Java-only beginner's tome
    and reworked them into four multi-chapter apps and more than a dozen quick mini-apps,
    starting from a simple memo app and then progressing to a cool drawing app, a
    database app, and a playable game (available online).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to become a professional Android developer or just want to have
    more fun when learning Java and Android, this book will help.
  prefs: []
  type: TYPE_NORMAL
- en: How Java and Android work together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start our Android quest, we need to understand how Android and Java
    work together. Android is a complex system, but you do not need to understand
    it in depth to be able to make amazing apps.
  prefs: []
  type: TYPE_NORMAL
- en: After we write a program in Java for Android, we click a button and our code
    is transformed into another form, the form that is understood by Android. This
    other form is called **bytecode** and the transformation process is called **compiling**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when the user installs our application, the bytecode is translated by
    another process known as the **Android Runtime** (**ART**) into machine code.
    This is the fastest possible execution format. So, if you have ever heard people
    saying that you shouldn't use Java because it is slow, then you know they are
    mistaken. Java is fast for the programmer to program and is then, upon installation,
    changed to machine code that is fast for the device. What could be better?
  prefs: []
  type: TYPE_NORMAL
- en: Not only does ART enable super-fast execution of our apps, but it also lowers
    battery use. Furthermore, the ART system doesn't just create the machine code
    and then sit back and relax; it provides hooks into our application that enhance
    memory management while the application is running. This makes our app run more
    efficiently and, as we will see in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*, easier to write by handling
    critical aspects of memory management.
  prefs: []
  type: TYPE_NORMAL
- en: The ART itself is a software system written in another language that runs on
    a specially adapted version of the Linux operating system. So, what the user sees
    of Android is itself just an app running on yet another operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Android is a collection of sub-systems. The typical Android user doesn't see
    the Linux operating system or know anything of the presence of ART but they are
    both there making things tick.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the Linux part of the system is to hide the complexity and diversity
    of the hardware and software that Android runs on, but at the same time exposing
    all its useful features. This exposing of features works in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the system itself must have access to the hardware, which it does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, this access must be programmer-friendly and easy to use – and this is
    because of the Android **API**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue by talking more about the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This book is about learning Java and building Android apps from scratch, so
    I won''t go any deeper than I have into how Android works. If, however, you want
    to know more, then the Wikipedia page is a good reference: [https://en.wikipedia.org/wiki/Android_(operating_system](https://en.wikipedia.org/wiki/Android_(operating_system)).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Android API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android API is code that makes it easy to do exceptional things. A simple
    analogy could be drawn with a machine, perhaps a car. When you press on the accelerator,
    a whole bunch of things happen under the hood. We don''t need to understand combustion
    or fuel pumps because some smart engineer has made an **interface** for us – in
    this case, a mechanical interface: the accelerator pedal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following line of Java code probably looks a little intimidating
    at this stage in the book, but it serves as a good example of how the Android
    API helps us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you learn that this single line of code searches for available satellites
    in space, and then communicates with them in their orbits around the Earth, then
    retrieves your precise latitude and longitude on the surface of the planet, it
    becomes easy to begin to glimpse the power and depth of the Android API in conjunction
    with the compiled bytecode and ART.
  prefs: []
  type: TYPE_NORMAL
- en: For sure, that code does look a little challenging – even mind-boggling at this
    stage of the book – but imagine trying to talk to a satellite some other way!
  prefs: []
  type: TYPE_NORMAL
- en: The Android API has a whole bunch of Java code that has already been written
    for us to use as we like.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many different estimates of the number of lines of code that have
    gone into Android. Some estimates are as low as 1 million, while some are as high
    as 20 million. What might seem surprising is that despite this vast amount of
    code, Android is known in programming circles for being "lightweight."
  prefs: []
  type: TYPE_NORMAL
- en: 'The question we must ask and the one this book tries to answer is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we use all this code to do cool stuff? Or to frame the question to fit
    the earlier analogy, how do we find and manipulate the pedals, steering wheel,
    and sunroof of the Android API?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question is the Java programming language and the fact that
    Java was designed to help programmers handle complexity. Let's talk a bit about
    Java and **Object-Oriented Programming** (**OOP**).
  prefs: []
  type: TYPE_NORMAL
- en: Java is object-oriented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java is a programming language that has been around a lot longer than Android.
    It is an **object-oriented** language. This means it uses the concept of reusable
    programming objects. If this sounds like technical jargon, another analogy will
    help. Java enables us and others (such as the Android development team) to write
    Java code that can be structured based on real-world things, and here is the important
    part: it can be **reused**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, using the car analogy, we could ask the question: if a manufacturer makes
    more than one car in a day, do they redesign every part for each and every car?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer, of course, is no. They get highly skilled engineers to develop exactly
    the right components, honed, refined, and improved over years. Then, that same
    component is reused again and again as well as being occasionally improved.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to be fussy about my analogy, then you can point out that each
    of the car's components still has to be built from the raw materials using real-life
    engineers or robots and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This is true. What software engineers do when they write their code is build
    a blueprint for an object. We then create an object from their blueprint using
    Java code and once we have that object, we can configure it, use it, combine it
    with other objects, and more besides.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as well as this, we can design blueprints ourselves and make objects
    from them as well. The compiler then transforms (manufactures) our bespoke creation
    into bytecode. Hey, presto! We have an Android app.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a blueprint is called a **class**. When a class is transformed into
    a real working "thing," we call it an **object** or an **instance** of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Objects concisely
  prefs: []
  type: TYPE_NORMAL
- en: We could go on making analogies all day long. All we care about at this point,
    however, is the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java is a language that allows us to write code once that can then be used
    repeatedly. This is very useful because it saves us time and allows us to use
    other people''s code to perform tasks we might otherwise not have the time or
    knowledge to write ourselves. Most of the time, we do not even need to see this
    code or even know how it works! One last analogy: we just need to know how to
    use the code just as we need to learn how to drive a car.'
  prefs: []
  type: TYPE_NORMAL
- en: So, some smart software engineer up at Android HQ writes a desperately complex
    Java program that can talk to satellites. They then consider how they can make
    this code useful to all the Android programmers who want to make amazing apps
    that use the user's location to do cool things. One of the things they will do
    is make features such as getting the device's location in the world a simple one-line
    task.
  prefs: []
  type: TYPE_NORMAL
- en: So, the one line of code we saw previously sets in action many more lines of
    code that we don't see and don't need to see. This is an example of using somebody
    else's code to make our code infinitely simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the fact that you don't have to see all the code is a disappointment to you,
    then I understand how you feel. Some of us, when we learn about something, want
    to learn every intricate detail. If you are like this, then be reassured that
    the best place to start learning how the Android API works internally is to use
    it as the API programmers intended. Throughout the book, I will regularly point
    out further learning opportunities where you can find out about the inner workings
    of the Android API. Also, we will be writing classes that are themselves reusable,
    kind of like our own API, except that our classes will focus on what we want our
    app to do.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to the world of **object-oriented programming** – **OOP**. I will constantly
    refer to OOP in every chapter and there is the big reveal of how it works in [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187), *Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Run that by me again – what exactly is Android?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get things done on Android, we write Java code of our own, which also uses
    the Java code of the Android API. This is then compiled into bytecode and translated
    by ART when installed by the user into machine code, which in turn has connections
    to an underlying operating system called Linux, which handles the complex and
    extremely diverse range of hardware that are the different Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: The manufacturers of the Android devices and the individual hardware components
    obviously know this too and they write advanced software called **drivers**, which
    ensure that their hardware (CPU, GPU, GPS receivers, memory chips, hardware interfaces,
    and so on) can run on the underlying Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The bytecode (along with some other resources) is placed in a bundle of files
    called an **Android Application Package** (**APK**) and this is what ART needs
    to run to prepare our app for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to remember the details of the steps that our code goes
    through when it interacts with the hardware. It is enough just to understand that
    our Java code goes through some automated processes to become the apps that we
    will publish to the Google Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is "where exactly does all this Java coding and compiling
    into bytecode along with APK packaging take place?". Let's look at the development
    environment we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **development environment** is a term that refers to having everything you
    need to develop, set up, and be ready to go in one place. We need two things to
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: We talked a fair bit about compiling our Java code, as well as other people's
    Java code, into bytecode that in turn will be converted into executable machine
    code on the user's Android device. To use Java code, we need some free software
    called the **JDK**. The JDK includes even more of other people's code, which is
    separate from the Android API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an entire range of tools needed to develop for Android, and we also
    need the Android API, of course. This whole suite of requirements is collectively
    known as the Android **SDK**. Fortunately, downloading and installing a single
    application will give us these things all bundled together. The application is
    called **Android Studio**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio is an **IDE** that will take care of all the complexities of
    compiling our code and linking with the JDK and the Android API. Once we have
    installed Android Studio, we can do everything we need inside this single application
    and put to the back of our minds many of the complexities we have been discussing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Over time, these complexities will become second nature. It is not necessary
    to master them to make further progress.
  prefs: []
  type: TYPE_NORMAL
- en: So, we had better get hands-on with Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up Android Studio is quite straightforward if a little lengthy. Grab
    some refreshments and get started with the following steps. This tutorial will
    install Android Studio to the D drive. I chose the D drive because it is a big
    install, around 12 GB once we have everything downloaded, and the D drive on many
    PCs is typically larger and has more free space than the C drive. Should you wish
    to install on the C drive (or any other drive), then these instructions should
    be easy to adjust:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://developer.android.com/studio](https://developer.android.com/studio)
    and click the **Download Android Studio** button. This will begin the download
    of the latest stable version for Windows. You will need to accept the terms and
    conditions to commence the download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While you are waiting for the download to complete, create a new folder on the
    root of your D drive called `Android`. Inside the `Android` folder, create another
    new folder called `Android Studio`. Navigate back to the `Android` folder and
    create another new folder named `Projects`. This is where we will keep all the
    project files we will create throughout the book. Create another new folder called
    `Sdk`, which is where we will ask the installer program to install the Android
    SDK. You should now have a `D:\Android` folder that looks like this:![Figure 1.1
    – D:\Android folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.01_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – D:\Android folder
  prefs: []
  type: TYPE_NORMAL
- en: Once the download is complete, find the downloaded file. It will be called `android-studio-ide....`.
    Double-left-click the file to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be asked to grant the installer program administrative privileges,
    then you can left-click **Next** to begin the installation. On the **Choose Components**
    screen, make sure that both the **Android Studio** and **Android Virtual Device**
    options are checked, and then left-click the **Next** button:![Figure 1.2 – Choose
    Components screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Choose Components screen
  prefs: []
  type: TYPE_NORMAL
- en: On the `D:\Android\Android Studio`, and then left-click the **OK** button:![Figure
    1.3 – Configuration Settings window](img/Figure_1.03_B16773.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 1.3 – Configuration Settings window
  prefs: []
  type: TYPE_NORMAL
- en: Left-click the **Next** button shown in the preceding screenshot. On the **Choose
    Start Menu Folder** window, left-click **Install** to accept the default option.
    The first part of the installation will now proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you get the **Installation Complete** message, left-click the **Next**
    button. You can then left-click the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio should start automatically. If it doesn't, you can find and start
    the Android Studio app from your Windows start menu.
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted that you have a missing SDK (unless this is not the first
    time you have used Android Studio). Left-click **Next** to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `D:\Android\Sdk`, as shown in the following screenshot:![Figure 1.4 –
    SDK Components Setup screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.04_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – SDK Components Setup screen
  prefs: []
  type: TYPE_NORMAL
- en: Left-click the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Verify Settings** window, left-click the **Finish** button. Android
    Studio will now download some more files and complete the installation. It could
    take a few minutes or more and you might again be prompted to allow access to
    your PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the process is over, left-click the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be greeted with the Android Studio welcome screen, shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Android Studio welcome screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.05_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Android Studio welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: If you are carrying straight on with the next section, then leave this screen
    up. If you want, you can close it down and run Android Studio from the Windows
    start menu, just like any other app, when you are ready to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about all the different things that an Android app comprises.
  prefs: []
  type: TYPE_NORMAL
- en: What makes an Android app?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that we will write Java code that will itself use other people's
    Java code and will be compiled into bytecode that is converted into machine code
    on our users' Android devices. In addition to this, we will also be adding and
    editing other files that are included in the final APK as well. These files are
    known as **Android resources**.
  prefs: []
  type: TYPE_NORMAL
- en: Android resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our app will include resources such as images, sound, and **User Interface**
    (**UI**) layouts, which are kept in separate files from the Java code. We will
    slowly introduce ourselves to them over the course of the book.
  prefs: []
  type: TYPE_NORMAL
- en: It will also include files that have the textual content of our app. It is the
    convention to refer to the text in our app through separate files because it makes
    them easy to change and easy to create apps that work for different languages
    and geographical regions.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the actual UI layout of our apps, despite the option to implement
    them with a visual designer, is actually read from text-based files by Android.
  prefs: []
  type: TYPE_NORMAL
- en: Android (or any computer), of course, cannot read and recognize text in the
    same way that a human can. Therefore, we must present our resources in a highly
    organized and predefined manner. To do so, we will use `.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to memorize this as we will constantly be returning to this
    concept throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of Android's Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to these resources, it is worth noting that Java as used in Android
    has a structure to its code. There are many millions of lines of code that we
    can take advantage of. This code will obviously need to be organized in a way
    that makes it easy to find and refer to. It is organized into **packages** that
    are specific to Android.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we create a new Android app, we will choose a unique name known as
    a **package**. We will see how we do this in the *Building our first Android app*
    section. Packages are often separated into **sub-packages**, so they can be grouped
    together with other similar packages. We can simply think of this as folders and
    sub-folders, which is almost exactly what it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of all the packages that the Android API makes available to us
    as code from a code library. Some common Android packages we will use include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.graphics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.database`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.view.animation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, they are arranged and named to make what is in them as obvious
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get an idea of the sheer depth and breadth of the Android API,
    then look at the Android package index: [https://developer.android.com/reference/packages](https://developer.android.com/reference/packages).'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we learned that the reusable code blueprints that we can transform
    into objects are called `.java` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java (and therefore Android), we further break up our classes into sections
    that perform the different actions of our class. We call these action-oriented
    sections **methods**. It is most often the methods of the class that we will use
    to access the functionality provided within all those millions of lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to read the code. We just need to know which class has what we
    need, which package it is in, and which methods from within the class give us
    precisely the result we are after.
  prefs: []
  type: TYPE_NORMAL
- en: The next diagram shows a representation of the Android API. The structure of
    the code we will be writing will be similar to the way this example is structured,
    although we will usually have just one package per app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, because of the object-oriented nature of Java, we will only be using
    selected parts from this API. Notice also that each class has its own distinct
    data. Typically, if you want access to the data in a class, you need to have an
    object of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – A representation of the Android API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.06_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – A representation of the Android API
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to memorize this as we will constantly be returning to this
    concept throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have imported multiple packages, as well
    as dozens of classes from them, and we will have used many of their methods as
    well. By the end of [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer*, we will have even written our
    very own methods. Now we can get started with the first app.'
  prefs: []
  type: TYPE_NORMAL
- en: Building our first Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming, it is tradition for the first app of a new student to use whatever
    language/operating system they are using to say hello to the world. We will quickly
    build an app that does just that and in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer*, we will go beyond that and add
    some buttons that respond to the user when they are pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The complete code as it stands at the end of this chapter is in the download
    bundle in the [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014) folder for
    your reference. You can't simply copy and paste this code, however! You still
    need to go through the project creation phase explained in this chapter (and at
    the beginning of all the projects) as Android Studio does lots of work behind
    the scenes. Once you become familiar with these steps and understand which code
    is typed by you the programmer and which code/files are generated by Android Studio,
    you will then be able to save time and typing by copy and pasting the files I
    supply in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to start the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Android Studio in the same way you run any other app. On Windows 10, for
    example, the launch icon appears in the start menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are prompted with **Import Studio settings from…**, choose **Do not import
    settings**.
  prefs: []
  type: TYPE_NORMAL
- en: You will be greeted with the Android Studio welcome screen, as shown in the
    following screenshot. Locate the start a new Android Studio project option and
    left-click it:![Figure 1.7 – Android Studio welcome screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.07_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Android Studio welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: The window that follows is **Select a Project Template**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are some useful project templates that Android Studio can generate for
    you depending on the type of app you are going to develop. We will use the **Basic
    Activity** option. Android Studio will auto-generate a small amount of code and
    a selection of resources to get our project started. We will discuss the code
    and the resources in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Basic Activity**. Here is a picture of the **Select a Project Template**
    window with the **Basic Activity** option selected:![Figure 1.8 – Select a Project
    Template window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.08_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Select a Project Template window
  prefs: []
  type: TYPE_NORMAL
- en: Make sure **Basic Activity** is selected as it is in the preceding screenshot,
    and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, Android Studio will bring up the `Hello World` and the location
    for the files will be your `Projects` folder that we created in the *Setting up
    Android Studio* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package name can be almost anything you like. If you have a website, you
    could use the format `com.yourdomainname`. If not, feel free to use my domain
    name, `com.gamecodeschool.helloworld`, or something that you just make up yourself.
    It is only important when you come to publish.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be clear, in case you can''t see the details in the following screenshot
    clearly, here are the values I used. Remember that yours might vary depending
    upon your choices for package name and project location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_1.Table_1_B16773.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that the application name has a space between `Hello` and `World` but the
    project location does not and will not work if it does.
  prefs: []
  type: TYPE_NORMAL
- en: The next screenshot shows the **Configure Your Project** screen once you have
    entered all the information:![Figure 1.9 – Configure Your Project screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.09_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – Configure Your Project screen
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see that Android Studio has auto-generated
    a package name based on the information entered. Mine is **com.gamecodeschool.helloworld**.
    Yours might be the same or not; it doesn't matter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can write Android apps in a few different languages, including C++ and Kotlin.
    There are various advantages and disadvantages to each compared to using Java.
    Learning Java will be a great introduction to other languages and Java is also
    an official language of Android. Most top apps and games on the Play Store are
    currently written in Java.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see the **Minimum SDK** option. Leave this at the default but note
    that the default might be different for you at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the Android SDK is the collection of packages of code that
    we will be using to develop our apps. Like any good SDK, the Android SDK is regularly
    updated and each time it gets a significant update, the version number is increased.
    Simply put, the higher the version number, the newer the features you get to use;
    the lower the version number, the more devices our app will work on. For now,
    Android Jelly Bean will give us lots of great features and near-100% compatibility
    with the Android devices currently in use. If at the time of reading Android Studio
    is suggesting a newer API and Android version, then go with that.
  prefs: []
  type: TYPE_NORMAL
- en: If you are reading this some years in the future, then the **Minimum SDK** option
    will probably default to something different but the code in this book will still
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Finish** button and we will run the app to see what we have achieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The first time you create a new project, Android Studio will initiate another
    download. Android Studio will set up the Gradle build system that it uses to manage
    project configuration and deployment. This will only happen for the first project.
    No knowledge of Gradle is required for the book but if you are curious, a simple
    web search will reveal more.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at our app in action.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the app so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we explore any of the code and learn our first bit of Java, you might
    be surprised to learn that we can already run our project. It will just be a fairly
    featureless app but as we will be running the app as often as possible to check
    our progress, let''s see how to do that now. You have three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the app on the emulator on your PC (part of Android Studio) in debug mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the app on a real Android device in USB debugging mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export the app as a full Android project that can be uploaded to the Play Store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option (debug mode) is the easiest to set up because we did it as
    part of setting up Android Studio. If you have a powerful PC, you will hardly
    notice the difference between the emulator and a real device. However, screen
    touches are emulated by mouse clicks and proper testing of the user's experience
    is not possible in some of the later apps we will create, such as the drawing
    app. Furthermore, you might just prefer to test out your creations on a real device
    occasionally – I know I do.
  prefs: []
  type: TYPE_NORMAL
- en: The second option, using a real device, has a couple more steps but once set
    up is as good as option 1 and the screen touches are for real.
  prefs: []
  type: TYPE_NORMAL
- en: The final option takes about 5 minutes (at least) to prepare, and then you need
    to manually put the created package onto a real device and install it every time
    you make a change to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the best way is to use the emulator to quickly test and debug minor
    increments in your code, and then fairly regularly use USB debugging mode on a
    real device to make sure things are still as expected. Only occasionally will
    you want to export an actual deployable package.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, we will now go through how to run the app using the emulator
    and USB debugging on a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Running and debugging the app on an Android emulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these simple steps to run the app on the default Android emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Android Studio menu bar, select **Tools** | **AVD Manager**. **AVD**
    stands for **Android Virtual Device** (an emulator). You will see the following
    window:![Figure 1.10 – AVD Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.10_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – AVD Manager
  prefs: []
  type: TYPE_NORMAL
- en: Notice there is an emulator on the list. In my case, it is **Pixel_3a_API_30_x….**
    If you are following this sometime in the future, it may be a different emulator
    that was installed by default. It won't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The emulator should have been installed by the steps we have performed previously.
    I noticed while testing with one pre-release version that it wasn't installed
    by default. In the event that there is no emulator listed on the **Your Virtual
    Devices** screen, select **Tools** | **AVD Manager** | **Create Virtual Device…**
    | **Next**| **R Download** | **Accept** | **Next** and a default emulator will
    be downloaded and installed. When the installation is done, click **Finish** followed
    by **Next** and finally **Finish** again. Now you can refer to the previous step
    to run the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Click the green play icon (to the right) shown in the next screenshot and wait
    as the emulator boots up:![Figure 1.11 – Play icon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.11_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – Play icon
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can click the play icon on the Android Studio quick launch bar as shown
    in the next screenshot, and if prompted, choose **Pixel_3a_API_30_x…** (or whatever
    your emulator is called) and the app will launch on the emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Play icon on the Android Studio quick launch bar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.12_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – Play icon on the Android Studio quick launch bar
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re done. Here is what the app looks like so far in the emulator. Remember
    that you might (probably do) have a different emulator – that''s fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – What the app looks like so far'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.13_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – What the app looks like so far
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we have more work to do before we move to Silicon Valley and look for
    financial backing, but it is a good start. The message on the screen is **Hello
    first fragment**. A **fragment** is a building block of many Android apps and
    we will explore them further throughout the book. If you click on the **Next**
    button, you will see a new empty layout, and if you then click on the **Previous**
    button, you will see the **Hello first fragment** screen again. Not bad considering
    we haven't written any code yet.
  prefs: []
  type: TYPE_NORMAL
- en: We need to test and debug our apps often throughout development to check for
    any errors, crashes, or anything else unintended.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will see how we get errors and other feedback for debugging from our apps
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to make sure it looks good and runs correctly on every
    device type/size that you want to target. Obviously, we do not own one of each
    of the many thousands of Android devices. This is where emulators come in.
  prefs: []
  type: TYPE_NORMAL
- en: Emulators, however, are sometimes a bit slow and cumbersome, although they have
    improved a lot recently. If you want to get a genuine feel for the experience
    your users will get, then you can't beat deploying to a real device. So, we will
    want to use both real devices and emulators while developing our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning on using the emulator again soon, then leave it running
    to avoid having to wait for it to start again.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try out your app on a tablet, you're going to need a different
    emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new emulator
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create an emulator for a different Android device, this is simple.
    From the main menu, select **Tools** | **AVD Manager**. In the AVD Manager window,
    left-click **Create Virtual Device**. Now, left-click on the type of device you
    want to create, **TV**, **Phone**, **Wear OS**, or **Tablet**. Now, simply left-click
    **Next** and follow the instructions to create your new AVD. Next time you run
    your app, the new AVD will appear as an option to run the app on. We will create
    a new tablet emulator step by step in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can look at how to get our app onto a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app on a real device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do is to visit your device manufacturer's website and obtain
    and install any drivers that are needed for your device and operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Most newer devices won't need a driver. So, you may want to just try the following
    steps first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few steps will set up the Android device for debugging. Note that
    different manufacturers structure the menu options slightly differently from others.
    But the following sequence is probably very close, if not exactly the same, for
    enabling debugging on most devices:'
  prefs: []
  type: TYPE_NORMAL
- en: Tap the **Settings** menu option or the **Settings** app on your phone/tablet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This next step will vary slightly for different versions of Android. The **Developer
    options** menu is hidden away so as not to trouble regular users. You must perform
    a slightly odd task to unlock the menu option. Tap the **About device** or **About
    Phone** option. Find the **Build Number** option and repeatedly tap it until you
    get a message informing you that **You are now a developer!**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some manufacturers have different and obscure methods for achieving this step.
    If this step doesn't work, do a web search for your device and "unlocking developer
    options."
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the **Settings** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap **Developer options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the checkbox for **USB Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your Android device to the USB port of your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click anywhere on Android Studio to get Android Studio to detect that your device
    has been connected. You should now find an **Allow USB debugging?** prompt on
    your device; hit **Allow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the play icon from the Android Studio toolbar, as shown in the next screenshot:![Figure
    1.14 – Play icon from the Android Studio toolbar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.14_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – Play icon from the Android Studio toolbar
  prefs: []
  type: TYPE_NORMAL
- en: When prompted, click **OK** to run the app on your chosen device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to learn some Java and add our own Java code to the Hello World
    project, which we will cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, is Android not really an operating system, just a virtual machine, and are
    all the phones and tablets really Linux machines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, all the different sub-systems of an Android device, which include Linux,
    the ART, and the libraries and drivers, are together what make up the Android
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: I still don't understand all these technical terms, such as ART, object-oriented,
    APK, and so on. Should I re-read this chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No, that isn''t necessary as we just needed to introduce this jargon and we
    will be revisiting it all as well as clarifying it as the book progresses. If
    you understand the following, you are ready to proceed to [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer*:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be writing Java code and creating other resources in Android Point Studio,
    which, with the help of the JDK, will turn this code and resources into real Android
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have set up our Android development environment, created a new Android
    app, and deployed our app to both an emulator and a real device. If you still
    have unanswered questions (and you probably have more than you did at the start
    of the chapter), don't worry because as we dig deeper into the world of Android
    and Java, things will become clearer.
  prefs: []
  type: TYPE_NORMAL
- en: As the chapters progress, you will build a very rounded understanding of how
    everything fits together, and then success will just be a matter of practice and
    digging even deeper into the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will edit the UI using the visual designer and raw XML
    code, as well as writing our first Java methods and getting to use some of the
    methods provided for us by the Android API.
  prefs: []
  type: TYPE_NORMAL
