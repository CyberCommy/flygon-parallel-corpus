- en: Chapter 5. Gaming and Java Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。游戏和Java基础知识
- en: In this chapter, we will cover a diverse and interesting range of topics. We
    will learn about Java arrays, which allow us to manipulate a potentially huge
    amount of data in an organized and efficient manner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖各种有趣的主题。我们将学习Java数组，它允许我们以有组织和高效的方式操纵潜在的大量数据。
- en: Then, we will look at the role threads can play in games, in order to do more
    than one thing apparently simultaneously.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将研究线程在游戏中的作用，以便看起来可以同时做更多事情。
- en: If you thought that our math game was a bit on the quiet side, then we will
    look at adding sound effects to our games as well as introducing a cool open source
    app to generate authentic sound effects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为我们的数学游戏有点安静，那么我们将研究如何为我们的游戏添加声音效果，以及介绍一个很酷的开源应用程序来生成真实的声音效果。
- en: The last new thing we will learn will be persistence. This is what happens when
    the player quits our game or even turns off their Android device. What happens
    to the score then? How will we load the right level the next time they play?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习的最后一件新事情将是持久性。这是当玩家退出我们的游戏甚至关闭他们的Android设备时会发生的情况。那时分数会怎么样？下次他们玩时我们将如何加载正确的级别？
- en: Once we have done all this, we will use all the new techniques and knowledge
    along with what we already know to create a neat memory game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有这些，我们将使用所有新的技术和知识以及我们已经知道的内容来创建一个整洁的记忆游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Java arrays—an array of variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java数组-一组变量的数组
- en: Timing with threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程定时
- en: Creating and using beeps 'n' buzzes—Android sound
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用蜂鸣声和嗡嗡声-Android声音
- en: A look at life after destruction—persistence
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毁灭后的生活展望-坚持
- en: Building the memory game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建记忆游戏
- en: Java arrays – an array of variables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java数组-一组变量的数组
- en: 'You might be wondering what happens when we have a game with lots of variables
    to keep track of. How about a table of high scores with the top 100 scores? We
    could declare and initialize 100 separate variables like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道当我们有很多要跟踪的变量的游戏时会发生什么。如何处理一个包含前100名得分的高分榜？我们可以声明并初始化100个单独的变量，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Straightaway, this can seem unwieldy, and what about the case when someone
    gets a new top score and we have to shift the scores in every variable down one
    place? A nightmare begins:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能立即显得笨拙，那么当有人获得新的最高分时，我们需要将每个变量中的分数向下移动一个位置，会发生什么？噩梦开始：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There must be a better way to update the scores. When we have a large set of
    variables, what we need is a Java **array**. An array is a reference variable
    that holds up to a fixed maximum number of elements. Each element is a variable
    with a consistent type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更新分数必须有更好的方法。当我们有一大堆变量时，我们需要的是一个Java **数组**。数组是一个引用变量，最多可以容纳固定数量的元素。每个元素都是具有一致类型的变量。
- en: 'The following line of code declares an array that can hold `int` type variables,
    even a high score table perhaps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行声明了一个可以容纳`int`类型变量的数组，甚至可能是一个高分表：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also declare arrays of other types, like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明其他类型的数组，如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each of these arrays would need to have a fixed maximum amount of storage space
    allocated before it is used, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组中的每一个都需要在使用之前分配固定的最大存储空间，如下所示：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding line of code allocates up to a maximum of 100 integer-sized storage
    spaces. Think of a long aisle of 100 consecutive storage spaces in our variable
    warehouse. The spaces would probably be labeled `intArray[0]`, `intArray[1]`,
    `intArray[2]`, and so on, with each space holding a single `int` value. Perhaps
    the slightly surprising thing here is that the storage spaces start off at 0,
    not 1\. Therefore, in an array of size 100, the storage spaces would run from
    0 to 99.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行分配了最多100个整数大小的存储空间。想象一下我们的变量仓库中有100个连续存储空间的长过道。空间可能标有`intArray[0]`，`intArray[1]`，`intArray[2]`等，每个空间都包含一个单个的`int`值。也许这里稍微令人惊讶的是，存储空间从0开始，而不是1。因此，在大小为100的数组中，存储空间将从0到99。
- en: 'We can actually initialize some of these storage spaces like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以像这样初始化一些存储空间：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that we can only put the declared type into an array and the type that
    an array holds can never change:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只能将声明的类型放入数组中，数组保存的类型永远不会改变：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So when we have an array of `int` types, what are each of the `int` variables
    called? The array notation syntax replaces the name. We can do anything with a
    variable in an array that we could do with a regular variable with a name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们有一个`int`类型的数组时，每个`int`变量被称为什么？数组表示法语法替换了名称。我们可以对数组中的变量做任何我们可以用名称对常规变量做的事情：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is another example of array variables being used like normal variables:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数组变量被用作普通变量的另一个例子：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also assign a value from an array to a regular variable of the same
    type, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数组中的值分配给相同类型的常规变量，如下所示：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note, however, that `myNamedInt` is a separate and distinct primitive variable,
    so any changes made to it do not affect the value stored in the `intArray` reference.
    It has its own space in the warehouse and is not connected to the array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，`myNamedInt`是一个单独且独立的基本变量，因此对它所做的任何更改都不会影响存储在`intArray`引用中的值。它在仓库中有自己的空间，并且与数组没有关联。
- en: Arrays are objects
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是对象
- en: We said that arrays are reference variables. Think of an array variable as an
    address to a group of variables of a given type. Perhaps, using the warehouse
    analogy, `someArray` is an aisle number. So each of `someArray[0]`, `someArray[1]`,
    and so on is the aisle number followed by the position number in the aisle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说数组是引用变量。将数组变量视为给定类型的一组变量的地址。也许，使用仓库类比，`someArray`是一个过道编号。因此，`someArray[0]`，`someArray[1]`等都是过道编号，后跟过道中的位置编号。
- en: 'Arrays are also objects. This means that they have methods and properties that
    we can use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也是对象。这意味着它们有我们可以使用的方法和属性：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous line of code, we assigned the length of `someArray` to the `int`
    variable called `lengthOfSomeArray`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行代码中，我们将`someArray`的长度分配给了名为`lengthOfSomeArray`的`int`变量。
- en: 'We can even declare an array of arrays. This is an array that, in each of its
    elements, stores another array, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以声明一个数组的数组。这是一个数组，每个元素中存储另一个数组，就像这样：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding array, we could hold a list of cities within each country.
    Let''s not go array-crazy just yet. Just remember that an array holds up to a
    predetermined number of variables of any predetermined type and their values are
    accessed using this syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，我们可以保存每个国家内的城市列表。现在先不要太疯狂地使用数组。只需记住，数组最多可以保存预定数量的任何类型的变量，并且可以使用以下语法访问它们的值：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's actually use some arrays to try and get an understanding of how to use
    them in real code and what we might use them for.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际使用一些数组来尝试并了解如何在实际代码中使用它们以及我们可能用它们做什么。
- en: A simple example of an array
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个数组的简单示例
- en: 'Let''s write a really simple working example of an array by performing the
    following steps. You can get the complete code for this example in the downloadable
    code bundle. It''s at `Chapter5/SimpleArrayExample/MainActivity.java`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤编写一个真正简单的数组工作示例。您可以在可下载的代码包中找到此示例的完整代码。它在`Chapter5/SimpleArrayExample/MainActivity.java`中：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这并非必要。
- en: 'First, we declare our array, allocate five spaces, and initialize some values
    to each of the elements:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的数组，分配五个空间，并为每个元素初始化一些值：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We output each of the values to the **logcat** console. Notice that when we
    add the array elements together, we are doing so over multiple lines. This is
    fine because we have omitted a semicolon until the last operation, so the Java
    compiler treats the lines as one statement:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个值输出到**logcat**控制台。请注意，当我们将数组元素相加时，我们是在多行上这样做的。这没问题，因为我们在最后一个操作之前省略了分号，所以Java编译器将这些行视为一个语句：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the example on an emulator.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。
- en: 'Remember that nothing will happen on the emulator display because the entire
    output will be sent to our **logcat** console window in Android Studio. Here is
    the output of the preceding code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在模拟器显示上不会发生任何事情，因为整个输出将被发送到我们在Android Studio中的**logcat**控制台窗口。以下是前面代码的输出：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In step 2, we declared an array called `ourArray` to hold `int` variables, and
    allocated space for up to five variables of that type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们声明了一个名为`ourArray`的数组，以保存`int`变量，并为该类型的最多五个变量分配了空间。
- en: Next, we assigned a value to each of the five spaces in our array. Remember
    that the first space is `ourArray[0]` and the last space is `ourArray[4]`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为数组中的五个空间中的每一个分配了一个值。请记住，第一个空间是`ourArray[0]`，最后一个空间是`ourArray[4]`。
- en: In step 3, we simply printed the value in each array location to the console.
    From the output, we can see that they hold the value we initialized in the previous
    step. Then we added each of the elements in `ourArray` and initialized their value
    to the `answer` variable. We then printed `answer` to the console and saw that
    all the values where added together, just as if they were plain old `int` types
    stored in a slightly different manner, which is exactly what they are.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步，我们简单地将每个数组位置的值打印到控制台。从输出中，我们可以看到它们保存了我们在上一步中初始化的值。然后我们将`ourArray`中的每个元素相加，并将它们的值初始化为`answer`变量。然后我们将`answer`打印到控制台，并看到所有的值都被加在一起，就像它们是存储在稍微不同方式的普通旧`int`类型中一样，这正是它们的本质。
- en: Getting dynamic with arrays
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数组一起变得动态起来
- en: As we discussed at the beginning of all this array stuff, if we need to declare
    and initialize each element of an array individually, there isn't a huge amount
    of benefit in an array over regular variables. Let's look at an example of declaring
    and initializing arrays dynamically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在所有这些数组内容的开头讨论的那样，如果我们需要单独声明和初始化数组的每个元素，那么数组与常规变量相比并没有太大的好处。让我们看一个动态声明和初始化数组的例子。
- en: Dynamic array example
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态数组示例
- en: 'Let''s make a really simple dynamic array by performing the following steps.
    You can find the working project for this example in the download bundle. It is
    at `Chapter5/DynamicArrayExample/MainActivity.java`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤创建一个真正简单的动态数组。您可以在下载包中找到此示例的工作项目。它在`Chapter5/DynamicArrayExample/MainActivity.java`中：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"),*Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这并非必要。
- en: 'Type the following between the opening and closing curly braces of `onCreate`.
    See if you can work out what the output will be before we discuss it and analyze
    the code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`的大括号之间键入以下内容。在我们讨论并分析代码之前，看看您能否弄清楚输出将是什么：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the example on an emulator. Remember that nothing will happen on the emulator
    display because the entire output will be sent to our **logcat** console window
    in Android Studio. Here is the output of the preceding code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。请记住，在模拟器显示上不会发生任何事情，因为整个输出将被发送到我们在Android Studio中的**logcat**控制台窗口。以下是前面代码的输出：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I have removed 994 iterations of the loop for brevity:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经删除了循环的994次迭代以简洁起见：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All the action happened in step 2\. We declared and allocated an array called
    `ourArray` to hold up to 1,000 `int` values. This time, however, we did the two
    steps in one line of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都发生在第2步。我们声明并分配了一个名为`ourArray`的数组，以容纳最多1,000个`int`值。然而，这一次，我们在一行代码中完成了这两个步骤：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we used a `for` loop that was set to loop 1,000 times:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了一个`for`循环，设置为循环1,000次：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We initialized the spaces in the array from 0 to 999 with the value of `i`
    multiplied by `5`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`i`乘以`5`的值初始化了数组中从0到999的空间，如下所示：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To demonstrate the value of `i` and the value held in each position of the
    array, we output the value of `i` followed by the value held in the corresponding
    position in the array as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`i`的值以及数组中每个位置上保存的值的价值，我们按如下方式输出`i`的值，然后是数组中相应位置上保存的值：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All of this happened 1,000 times, producing the output we saw.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生了1,000次，产生了我们看到的输出。
- en: Entering the nth dimension with arrays
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入数组的第n维
- en: We very briefly mentioned that an array can even hold other arrays at each of
    its positions. Now, if an array holds lots of arrays that hold lots of some other
    type, how do we access the values in the contained arrays? And why would we ever
    need this anyway? Take a look at the next example of where multidimensional arrays
    can be useful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常简要地提到数组甚至可以在每个位置上容纳其他数组。现在，如果一个数组包含许多包含其他类型的数组，我们如何访问包含的数组中的值？为什么我们需要这个？看看多维数组何时有用的下一个示例。
- en: An example of a multidimensional array
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组的一个示例
- en: 'Let''s create a really simple multidimensional array by performing the following
    steps. You can find the working project for this example in the download bundle.
    It is at `Chapter5/MultidimensionalArrayExample/MainActivity.java`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建一个非常简单的多维数组。您可以在下载包中找到此示例的工作项目。它位于`Chapter5/MultidimensionalArrayExample/MainActivity.java`：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary methods, but this isn't essential.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始Android")中所做的那样，*开始Android*。同时，通过删除不必要的方法来清理代码，但这并非必需。
- en: 'After the call to `setContentView`, declare and initialize a two-dimensional
    array, like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`setContentView`之后，声明并初始化一个二维数组，如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we output the contents of the array using a `for` loop and a `Random` class
    object. Note how we ensure that although the question is random, we can always
    pick the correct answer:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`for`循环和`Random`类对象输出数组的内容。请注意，尽管问题是随机的，但我们始终可以选择正确的答案：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the example on an emulator. Once again, nothing will happen on the emulator
    display because the output will be sent to our **logcat** console window in Android
    Studio. Here is the output of the previous code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。再次强调，模拟器显示屏上不会发生任何事情，因为输出将发送到我们在Android Studio中的**logcat**控制台窗口。这是先前代码的输出：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What just happened? Let's go through this chunk by chunk so that we know exactly
    what is going on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？让我们一块一块地过一遍，这样我们就知道到底发生了什么。
- en: 'We make a new object of the `Random` type, called `randInt`, ready to generate
    random numbers later in the program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Random`类型的新对象，称为`randInt`，准备在程序后面生成随机数：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We declare a simple `int` variable to hold a question number:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个简单的`int`变量来保存问题编号：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we declare `countriesAndCities`, our array of arrays. The outer array
    holds arrays:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明`countriesAndCities`，我们的数组数组。外部数组保存数组：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we allocate space within our arrays. The first outer array will be able
    to hold five arrays and each of the inner arrays will be able to hold two strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在数组中分配空间。第一个外部数组将能够容纳五个数组，每个内部数组将能够容纳两个字符串：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we initialize our arrays to hold countries and their corresponding capital
    cities. Notice that with each pair of initializations, the outer array number
    stays the same, indicating that each country/capital pair is within one inner
    array (a string array). Of course, each of these inner arrays is held in one element
    of the outer array (which holds arrays):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化数组以保存国家及其对应的首都。请注意，每对初始化中，外部数组编号保持不变，表示每个国家/首都对在一个内部数组（字符串数组）中。当然，这些内部数组中的每一个都保存在外部数组的一个元素中（保存数组）：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make the upcoming `for` loop clearer, we declare and initialize `int` variables
    to represent the country and the capital from our arrays. If you glance back at
    the array initialization, all the countries are held in position `0` of the inner
    array and all the corresponding capital cities are held at position `1`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使即将到来的`for`循环更清晰，我们声明并初始化`int`变量来表示数组中的国家和首都。如果您回顾一下数组初始化，所有国家都保存在内部数组的位置`0`，所有对应的首都都保存在位置`1`：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we create a `for` loop that will run three times. Note that this number
    does not mean we access the first three elements of our array. It is rather the
    number of times we go through the loop. We could make it loop one time or a thousand
    times, but the example would still work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个`for`循环，将运行三次。请注意，这个数字并不意味着我们访问数组的前三个元素。这只是循环的次数。我们可以让它循环一次或一千次，但示例仍然有效：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we actually determine which question to ask, or more specifically, which
    element of our outer array. Remember that `randInt.nextInt(5)` returns a number
    between 0 and 4\. This is just what we need as we have an outer array with five
    elements, from 0 to 4:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实际确定要问什么问题，或者更具体地说，我们外部数组的哪个元素。请记住，`randInt.nextInt(5)`返回0到4之间的数字。这正是我们需要的，因为我们有一个包含五个元素的外部数组，从0到4：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we can ask a question by outputting the strings held in the inner array,
    which in turn is held by the outer array that was chosen in the previous line
    by the randomly generated number:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过输出内部数组中保存的字符串来提问，而内部数组又由前一行中随机生成的数字选择的外部数组保存：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For the record, we will not be using any multidimensional arrays in the rest
    of this book. So if there is still a little bit of murkiness around these arrays
    inside arrays, then that doesn't matter. You know they exist and what they can
    do, so you can revisit them if necessary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们在本书的其余部分将不再使用任何多维数组。因此，如果对这些数组内部的数组还有一点模糊，那也没关系。您知道它们存在以及它们能做什么，所以如果有必要，您可以重新访问它们。
- en: Array-out-of-bounds exceptions
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组越界异常
- en: 'An array-out-of-bounds exception occurs when we attempt to access an element
    of an array that does not exist. Whenever we try this, we get an error. Sometimes,
    the compiler will catch it to prevent the error from going into a working game,
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个不存在的数组元素时，就会发生数组越界异常。每当我们尝试这样做，就会出现错误。有时，编译器会捕捉到它，以防止错误进入工作中的游戏，就像这样：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Guess what happens if we write something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜如果我们写出这样的东西会发生什么：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only way we can avoid this problem is to know the rule. The rule is that
    arrays start at zero and go up to the number obtained by subtracting one from
    the allocated number. We can also use clear, readable code where it is easy to
    evaluate what we have done and spot the problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免这个问题的唯一方法是了解规则。规则是数组从零开始，一直到从分配的数字中减去一得到的数字。我们还可以使用清晰、可读的代码，在这种代码中很容易评估我们所做的事情并发现问题。
- en: Timing with threads
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的时间控制
- en: So what is a thread? You can think of threads in Java programming just like
    threads in a story. In one thread of a story, we have the primary character battling
    the enemy on the front line, and in another thread, the soldier's family are getting
    by, day to day. Of course, a story doesn't have to have just two threads. We could
    introduce a third thread. Perhaps the story also tells of the politicians and
    military commanders making decisions. These decisions subtly, or not so subtly,
    affect what happens in the other threads.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是线程呢？你可以把Java编程中的线程想象成故事中的线程。在故事的一个线程中，我们有主要角色在前线与敌人作战，而在另一个线程中，士兵的家人们日复一日地生活。当然，一个故事不一定只有两个线程。我们可以引入第三个线程。也许故事还讲述了政客和军事指挥官做出决策。这些决策会微妙地或者不那么微妙地影响其他线程中发生的事情。
- en: 'Threads in programming are just like this. We create parts/threads in our program
    and they control different aspects for us. We introduce threads to represent these
    different aspects because of the following reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的线程就是这样。我们在程序中创建部分/线程，它们为我们控制不同的方面。我们引入线程来代表这些不同的方面，是因为以下原因：
- en: They make sense from an organizational point of view
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组织的角度来看，它们是有意义的
- en: They are a proven way of structuring a program that works
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是一种经过验证的程序结构方式
- en: The nature of the system we are working on forces us to use them
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在工作的系统的性质迫使我们使用它们
- en: In Android, we use threads for all of these reasons simultaneously. It makes
    sense, it works, and we have to use it because of the design of the system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们同时出于以上所有原因使用线程。这是有道理的，它有效，而且我们必须使用它，因为系统的设计需要。
- en: In gaming, think about a thread that receives the player's button taps for "left",
    "right", and "shoot", a thread that represents the alien thinking where to move
    next, and yet another thread that draws all the graphics on the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，想象一下一个线程接收玩家的“左”、“右”和“射击”按钮点击，一个线程代表外星人思考下一步要移动到哪里，还有另一个线程在屏幕上绘制所有的图形。
- en: Programs with multiple threads can have problems. Like the threads of a story,
    if proper synchronization does not occur, then things go wrong. What if our soldier
    went into battle before the battle or even the war existed? Weird!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序可能会出现问题。就像故事的线程一样，如果适当的同步没有发生，事情就会出错。如果我们的士兵在战斗甚至战争存在之前就进入了战斗，会怎么样？奇怪！
- en: What if we have a variable, `int x`, that represents a key piece of data that
    say three threads of our program use? What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two? This problem is
    the problem of **correctness**, caused by multiple threads racing to completion,
    oblivious of each other—because they are just dumb code after all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个变量`int x`，代表着我们程序中三个线程使用的关键数据，会发生什么呢？如果一个线程稍微领先一些，使得数据对其他两个线程来说变得“错误”了，会发生什么？这个问题就是**正确性**的问题，由多个线程竞争完成而引起，它们互相不知道对方的存在，因为它们毕竟只是愚蠢的代码。
- en: The problem of correctness can be solved by close oversight of the threads and
    **locking**. Locking means temporarily preventing execution in one thread to ensure
    that things are working in a synchronized manner. It's like freezing the soldier
    from boarding a ship to war until the ship has actually docked and the plank has
    been lowered, avoiding an embarrassing splash.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性的问题可以通过密切监督线程和**锁定**来解决。锁定意味着暂时阻止一个线程的执行，以确保事情以同步的方式工作。这就像冻结士兵不让他登上战舰，直到战舰实际靠岸并放下了栈板，避免尴尬的溅水。
- en: The other problem with programs with multiple threads is the problem of **deadlock**,
    where one or more threads become locked, waiting for the right moment to access
    `x`, but that moment never comes and the entire program eventually grinds to a
    halt.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序的另一个问题是**死锁**的问题，其中一个或多个线程被锁住，等待合适的时机来访问`x`，但那个时机从未到来，整个程序最终停滞不前。
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock). Now consider all that we have
    just been discussing and mix it in with the Android Activity lifecycle. It's possible
    that you start to feel a little nauseous with the complexity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，第一个问题（正确性）的解决方案是导致第二个问题（死锁）的原因。现在考虑我们刚刚讨论的所有内容，并将其与Android Activity生命周期混合在一起。你可能开始感到这种复杂性有点令人恶心。
- en: Fortunately, the problem has been solved for us. Just as we use the `Activity`
    class and override its methods to interact with the Android lifecycle, we can
    also use other classes to create and manage our threads. Just as with `Activity`,
    we only need to know how to use them, not how they work.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题已经为我们解决了。就像我们使用`Activity`类并重写其方法与Android生命周期进行交互一样，我们也可以使用其他类来创建和管理我们的线程。就像使用`Activity`一样，我们只需要知道如何使用它们，而不需要知道它们是如何工作的。
- en: 'So why tell me all this stuff about threads when I didn''t need to know, you
    would rightly ask. It''s simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. We will have no sweat writing our Java
    code to create and work within our threads if we can do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么要告诉我所有这些关于线程的东西，当我不需要知道的时候，你可能会问。这只是因为我们将编写看起来不同并且结构不熟悉的代码。如果我们能做到以下几点，我们将毫不费力地编写我们的Java代码来创建和在我们的线程中工作：
- en: Accept that the new concepts we will introduce are what we need to work with
    in order to create an Android-specific solution to the problems related to working
    with threads
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受我们将介绍的新概念是我们需要处理的，以便为处理与线程相关的问题创建一个特定于Android的解决方案
- en: Understand the general concept of a thread, which is mostly the same as a story
    thread that happens almost simultaneously
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解线程的一般概念，这与几乎同时发生的故事线程大致相同
- en: Learn the few rules of using some of the Android thread classes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用一些Android线程类的几个规则
- en: Notice that I said classes, plural, in the third bullet. Different thread classes
    work best in different situations. You could write a whole book on just threads
    in Android. We will use two thread classes in this book. In this chapter, we will
    use `Handler`. In [Chapter 7](ch07.xhtml "Chapter 7. Retro Squash Game"), *Retro
    Squash Game*, and [Chapter 8](ch08.xhtml "Chapter 8. The Snake Game"), *The Snake
    Game*, we will use the `Runnable` class. All we need to remember is that we will
    be writing parts of our program that run at almost the same time as each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在第三个项目中说了类，复数。不同的线程类在不同的情况下效果最好。你可以写一整本关于Android线程的书。在本书中，我们将使用两个线程类。在本章中，我们将使用`Handler`。在[第7章](ch07.xhtml
    "第7章。复古乒乓球游戏")，*复古乒乓球游戏*，和[第8章](ch08.xhtml "第8章。贪吃蛇游戏")，*贪吃蛇游戏*中，我们将使用`Runnable`类。我们需要记住的是，我们将编写几乎同时运行的程序部分。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What do I mean by "almost"? What is actually happening is that the CPU switches
    between threads in turn. However, this happens so fast that we will not be able
    to perceive anything but simultaneity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的“几乎”是什么意思？实际上发生的是CPU轮流在线程之间切换。然而，这一切发生得如此之快，以至于我们除了同时性之外无法感知到任何东西。
- en: A simple thread timer example with the Handler class
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Handler类创建一个简单的线程计时器示例
- en: After this example, we can heave a sigh of relief when we realize that threads
    are not as complicated as first feared. When using threads in a real game, we
    will have to add a bit of extra code alongside the code in this simple example,
    but it's not much, and we will talk about it when we get to it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子之后，当我们意识到线程并不像最初害怕的那么复杂时，我们可以松一口气。在真正的游戏中使用线程时，我们将不得不在这个简单的例子中的代码旁边添加一些额外的代码，但这并不多，我们会在到达时讨论它。
- en: As usual, you can simply use the complete code from the download bundle. This
    project is located in `Chapter5`/`SimpleThreadTimer/MainActivity.java`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你可以直接使用下载包中的完整代码。这个项目位于`Chapter5`/`SimpleThreadTimer/MainActivity.java`。
- en: 'As the name suggests, we will be creating a timer—quite a useful feature in
    a lot of games:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，我们将创建一个计时器 - 在许多游戏中非常有用的功能：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这并不是必要的。
- en: 'Immediately after the class declaration, enter the three highlighted lines:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明之后，输入三行高亮显示的代码：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Enter this code inside the `onCreate` method. It will create a thread with
    something else going on in the `if(gameOn)` block:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码输入`onCreate`方法中。它将创建一个线程，同时在`if(gameOn)`块中进行其他操作：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the app. Quit with the home or back button on the emulator. Notice that
    it is still printing to the console. We will deal with this anomaly when we implement
    our memory game.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。在模拟器上使用主页或返回按钮退出。请注意，它仍然在控制台上打印。当我们实现我们的记忆游戏时，我们将处理这个异常。
- en: 'When you run the example on an emulator, remember that nothing will happen
    on the emulator display because all of the output will be sent to our **logcat**
    console window in Android Studio. Here is the output of the previous code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器上运行示例时，请记住模拟器显示屏上不会发生任何事情，因为所有的输出都将发送到我们在Android Studio中的**logcat**控制台窗口。这是先前代码的输出：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So what just happened? After 1-second intervals, the number of seconds elapsed
    was printed to the console. Let's learn how this happened.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那刚刚发生了什么？每隔1秒，经过的秒数被打印到控制台上。让我们学习一下这是如何发生的。
- en: 'First, we declare a new object, called `myHandler`, of the `Handler` type.
    We then declare a Boolean variable called `gameOn`. We will use this to keep track
    of when our game is running. Finally, the last line of this block of code declares
    a variable of the `long` type. You might remember the `long` type from [Chapter
    3](ch03.xhtml "Chapter 3. Speaking Java – Your First Game"), *Speaking Java –
    Your First Game*. We can use `long` variables to store very large whole numbers,
    and this is what we do here with `startTime`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个名为`myHandler`的`Handler`类型的新对象。然后我们声明一个名为`gameOn`的布尔变量。我们将使用这个变量来跟踪我们的游戏何时运行。最后，这段代码块的最后一行声明了一个`long`类型的变量。你可能还记得`long`类型来自[第3章](ch03.xhtml
    "第3章。说Java - 你的第一个游戏")，*说Java - 你的第一个游戏*。我们可以使用`long`变量来存储非常大的整数，这就是我们在这里使用`startTime`的方式：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, we initialized `startTime` using `currentTimeMillis`, a method of the
    `System` class. This method holds the number of milliseconds since January 1,
    1970\. We will see how we use this value in the next line of code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`System`类的`currentTimeMillis`方法初始化了`startTime`。这个方法保存了自1970年1月1日以来的毫秒数。我们将看到我们如何在下一行代码中使用这个值。
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next is the important code. Everything up to `if(gameOn)` marks the code to
    define our thread. Certainly, the code is a bit of a mouthful, but it is not as
    bad as it looks at first glance. Also, remember that we only need to use the threads;
    we don't need to understand every aspect of how they do their work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect the preceding code to demystify it a bit. The `myHandler = new
    Handler()` line simply initializes our `myHandler` object. What is different from
    what we have seen before is that we go on to customize the object immediately
    afterwards. We override the `handleMessage` method (which is where we put our
    code that runs in the thread) and then we call `super.handleMessage`, which calls
    the default version of `handleMessage` before it runs our custom code. This is
    much like we do for the `onCreate` method every time we call `super.onCreate`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the `if(gameOn)` block. Everything in that `if` block is the code
    that we want to run in the thread. The `if(gameOn)` block simply gives us a way
    to control whether we want to run our code at all. For example, we might want
    the thread up and running but only sometimes run our code. The `if` statement
    gives us the power to easily choose. Take a look at the code now. We will analyze
    what is happening in the `if` block later:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inside the `if` block, we declare and initialize another `long` variable called
    `seconds`, and do a little bit of math with it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First, we get the current number of milliseconds since January 1, 1970, and
    then subtract `startTime` from it. This gives us the number of milliseconds since
    we first initialized `startTime`. Then we divide the answer by 1000 and get a
    value in seconds. We print this value to the console with the following line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, just after our `if` block, we have this line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The previous line tells the Android system that we want to run the code in the
    `handleMessage` method once every 1000 milliseconds (once a second).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `onCreate`, after the closing curly braces of the `handleMessage` method
    and the `Handler` class, we finally set `gameOn` to `true` so that it is possible
    to run the code in the `if` block:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, this last line of the code starts the flow of messages between our thread
    and the Android system:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is worth pointing out that the code inside the `if` block can be as minimal
    or as extensive as we need. When we implement our memory game, we will see much
    more code in our `if` block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: All we really need to know is that the somewhat elaborate setup we have just
    seen allows us to run the contents of the `if` block in a new thread. That's it!
    Perhaps apart from brushing over that `System` class a bit quickly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System` class has many uses. In this case, we use it to get the number
    of milliseconds since January 1, 1970\. This is a common system used to measure
    time in a computer. It is known as Unix time, and the first millisecond of January
    1, 1970, is known as the Unix Epoch. We will bump into this concept a few more
    times throughout the book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Enough on threads, let's make some noise!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Beeps n buzzes – Android sound
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will be divided into two parts—creating and using sound FX. So
    let's get on with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Creating sound FX
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Years ago, whenever I made a game, I would spend many hours trawling websites
    offering royalty-free sound FX. Although there are many good ones out there, the
    really great ones are always costly, and no matter how much you pay, they are
    never exactly what you want. Then a friend pointed out a simple open source app
    called Bfxr, and I have never wasted another moment looking for sound effects
    since. We can make our own.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Here is a very fast guide to making your own sound effects using Bfxr. Grab
    a free copy of Bfxr from [www.bfxr.net](http://www.bfxr.net).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the simple instructions on the website to set it up. Try out a few of
    these examples to make cool sound effects:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a seriously condensed tutorial. You can do much more with Bfxr. To learn
    more, read the tips on the website at the previous URL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Run `bfxr.exe`:![Creating sound FX](img/8859OS_05_10.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out all the preset types, which generate a random sound of that type. When
    you have a sound that is close to what you want, move to the next step:![Creating
    sound FX](img/8859OS_05_11.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Creating sound FX](img/8859OS_05_12.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see, we can save in formats other than `.wav`.![Creating
    sound FX](img/8859OS_05_13.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file, use the `.ogg` extension on the end of whatever you decide to call it.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 5 as often as required.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every project in this book that requires sound samples comes with the sound
    samples provided, but as we have seen, it is much more fun to make our own samples.
    All you need to do is to save them with the same filename as the provided samples.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds in Android
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To complete this brief example, you will need three sound effects saved in
    the `.ogg` format. So if you don''t have them to hand, go back to the *Creating
    sound FX* section to make some. Alternatively, you can use the sounds provided
    in the `Chapter5/ PlayingSounds/assets` folder of the code bundle. As usual, you
    can view or use the already completed code at `Chapter5/PlayingSounds/java/MainActivity.java`
    and `Chapter5/PlayingSounds/layout/activity_main.xml`. Now perform the following
    steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, although this isn't essential.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three sound files and save them as `sample1.ogg`, `sample2.ogg`, and
    `sample3.ogg`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` folder in the Project Explorer window, we need to add a folder
    called `assets`. So in the Project Explorer window, right-click on the **main**
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy and paste the three sound files to the newly created `assets` folder.
    Alternatively, select the three files, right-click on them, and click on **Copy**.
    Then click on the **assets** folder in the Android Studio Project Explorer. Now
    right-click on the **assets** folder and click on **Paste**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor window and drag three button widgets
    onto your UI. It doesn't matter where they are or how they are aligned. When you
    look at the **id** property in the **Properties** window for any of our three
    new buttons, you will notice that they have automatically been assigned **id**
    properties. They are `button`, `button2`, and `button3`. As we will see, this
    is just what we need.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s enable our activity to listen to the buttons being clicked by implementing
    `onClickListener` as we have done in all our other examples with buttons. Open
    **MainActivity.java** in the editor window. Replace the `public class MainActivity
    extends Activity {` line with the following line of code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As before, we get an unsightly red underline on our new line of code. The last
    time this happened, we typed in the empty body of the `onClick` method that we
    must implement and all was well. This time, because we already know what is going
    on here, we will learn a shortcut. Hover your mouse cursor over the error and
    right-click on it. Now click on **Generate...** and then select **Implement methods...**.
    In the **Select** **Methods To Implement** dialog box, **onClick(View):void**
    will already be selected:![Playing sounds in Android](img/8859OS_05_03.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this option by clicking on **OK**. Now scroll to the bottom of your code
    and see that Android Studio has very kindly implemented the `onClick` method for
    you and the error is also gone.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**确定**来选择此选项。现在滚动到代码底部，看到Android Studio已经很好地为您实现了`onClick`方法，错误也已经消失。
- en: 'Type this code after the `MainActivity` declaration to declare some variables
    for our sound effects:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明之后键入此代码，以声明一些用于我们的音效的变量：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Type this code in the `onCreate` method to load our sounds into memory:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中键入此代码，将我们的声音加载到内存中：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now add the code to grab a reference to the buttons in our UI and listen to
    clicks on them:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加代码来获取对UI中按钮的引用并监听点击事件：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, type this code in the `onClick` method that we autogenerated:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们自动生成的`onClick`方法中键入此代码：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run the example on an emulator or on a real Android device. Notice that by clicking
    on a button, you can play any of your three sound samples at will. Of course,
    sounds can be played at almost any time, not just on button presses. Perhaps they
    can be played from a thread as well. We will see more sound samples when we implement
    the memory game later in the chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器或真实的Android设备上运行示例。注意，通过单击按钮，您可以随意播放三个声音样本中的任何一个。当然，几乎可以在任何时候播放声音，而不仅仅是在按下按钮时。也许它们也可以从一个线程中播放。在本章后面实现记忆游戏时，我们将看到更多的声音样本。
- en: This is how the code works. We started off by setting up a new project in the
    usual way. In steps 2 to 5, however, we created some sounds with Bfxr, created
    an `assets` folder, and placed the files within it. This is the folder where Android
    expects to find sound files. So when we write the code in the next steps that
    refers to the sound files, the Android system will be able to find them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理。我们首先按照通常的方式设置了一个新项目。然而，在步骤2到5中，我们使用Bfxr创建了一些声音，创建了一个`assets`文件夹，并将文件放在其中。这是Android期望找到声音文件的文件夹。因此，当我们在接下来的步骤中编写引用声音文件的代码时，Android系统将能够找到它们。
- en: In steps 6 to 8, we enabled our activity to listen to button clicks as we have
    done several times before. Only this time, we got Android Studio to autogenerate
    the `onClick` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤6到8中，我们使我们的活动能够监听按钮点击，就像我们以前做过好几次一样。只是这一次，我们让Android Studio自动生成了`onClick`方法。
- en: 'Then we saw this code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到了这段代码：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'First, we create an object of the `SoundPool` type, called `soundPool`. This
    object will be the key to making noises with our Android device. Next, we have
    this code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`soundPool`的`SoundPool`类型的对象。这个对象将是我们的Android设备发出声音的关键。接下来，我们有这段代码：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code is very simple; we declared three `int` variables. However,
    they serve a slightly deeper purpose than a regular `int` variable. As we will
    see in the next block of code we analyze, they will be used to hold a reference
    to a sound file that is loaded into memory. In other words, the Android system
    will assign a number to each variable that will refer to a place in memory where
    our sound file will reside.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常简单；我们声明了三个`int`变量。然而，它们的作用略微超出了普通的`int`变量。正如我们将在下一段代码中看到的，它们将用于保存加载到内存中的声音文件的引用。换句话说，Android系统将为每个变量分配一个数字，该数字将指向内存中我们的声音文件所在的位置。
- en: We can think of this as a location in our variable warehouse. So we know the
    name of the `int` variable, and contained within it is what Android needs to find
    our sound. Here is how we load our sounds into memory and use the references we've
    just been discussing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把这看作是我们变量仓库中的一个位置。所以我们知道`int`变量的名称，它包含的是Android需要找到我们的声音的内容。这是我们如何将声音加载到内存中并使用我们刚刚讨论过的引用的方法。
- en: 'Let''s break the code in step 10 into a few parts. Take a close look and then
    we will examine what is going on:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将步骤10中的代码分解成几个部分。仔细观察一下，然后我们将分析其中的内容：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we initialize our `soundPool` object and request up to 10 simultaneous
    streams of sound. We should be able to really mash the app buttons and get a sound
    every time. `AudioManager.STREAM_MUSIC` describes the type of stream. This is
    typical for applications of this type. Finally, the `0` argument indicates we
    would like default quality sound.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了我们的`soundPool`对象，并请求最多10个同时播放的声音流。我们应该能够真正地按下应用按钮，并在每次按下时听到声音。`AudioManager.STREAM_MUSIC`描述了流的类型。这对于这种类型的应用程序是典型的。最后，`0`参数表示我们希望获得默认质量的声音。
- en: Now we see something new. Notice that the next chunk of code is wrapped into
    two blocks, `try` and `catch`. This means that if the code in the `try` block
    fails, we want the code in the `catch` block to run. As you can see, there is
    nothing but a comment in the `catch` block.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了一些新的东西。注意到下一段代码被包裹在两个块`try`和`catch`中。这意味着如果`try`块中的代码失败，我们希望运行`catch`块中的代码。正如你所看到的，`catch`块中除了一个注释之外什么也没有。
- en: We must do this because of the way the `SoundPool` class is designed. If you
    try to write the code without the `try` and `catch` blocks, it won't work. This
    is typical of Java classes involved in reading from files. It is a fail-safe process
    to check whether the file is readable or even whether it exists. You could put
    a line of code to output to the console that an error has occurred.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须这样做是因为`SoundPool`类的设计方式。如果你尝试在没有`try`和`catch`块的情况下编写代码，它是行不通的。这是Java类在读取文件时的典型情况。这是一个安全失败的过程，用来检查文件是否可读，甚至是否存在。你可以放置一行代码输出到控制台，表示发生了错误。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to experiment with `try/catch`, then put a line of code to output
    a message in the `catch` block and remove one of the sound files from the assets
    folder. When you run the app, the loading will fail and the code in the `catch`
    block will be triggered.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试`try/catch`，那么在`catch`块中放置一行代码输出一条消息，并从`assets`文件夹中删除一个声音文件。当你运行应用程序时，加载将失败，并且`catch`块中的代码将被触发。
- en: 'We will throw caution to the wind because we are quite sure that the files
    will be there and will work . Let''s examine what is inside the `try` block. Take
    a close look at the following code and then we will dissect it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将放手一搏，因为我们非常确定文件会在那里并且会起作用。让我们仔细看看`try`块中的内容。仔细看一下下面的代码，然后我们将对其进行分析：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'First, we create an object called `assetManager` of the `AssetManager` type
    and an `AssetFileDescriptor` object called `descriptor`. We then use these two
    objects combined to load our first sound sample like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We now have a sound sample loaded in memory and its location saved in our `int`
    variable called `sample1`. The first sound file, `sample1.ogg`, is now ready to
    use. We perform the same procedure for `sample2` and `sample3` and we are ready
    to make some noise!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 11, we set up our buttons, which we have seen several times before.
    In step 12, we have our switch block ready to perform a different action depending
    upon which button is pressed. You can probably see that the single action each
    button takes is the playing of a sound. For example, **Button1** does this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This line of code plays the sound that is loaded in memory at the location referred
    to by `int sample1`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The arguments of the method from left to right define the following: the sample
    to play, left volume, right volume, priority over other playing sounds, loop or
    not, rate of playback. You can have some fun with these if you like. Try setting
    the loop argument to `3` and the rate argument to perhaps `1.5`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We handle each button in the same way. Now let's learn something serious.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Life after destruction – persistence
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, this is not as heavy as it sounds, but it is an important topic when making
    games. You have probably noticed that the slightest thing can reset our math game,
    such as an incoming phone call, a battery that ran flat, or even tilting the device
    to a different orientation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: When these events occur, we might like our game to remember the exact state
    it was in so that when the player comes back, it is in exactly the same place
    as they left off. If you were using a word-processing app, you would definitely
    expect this type of behavior.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go to that extent with our game, but as a bare minimum,
    shouldn't we at least remember the high score? This gives the player something
    to aim for, and most importantly, a reason to come back to our game.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: An example of persistence
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android and Java have many different ways to achieve persistence of data, from
    reading and writing to files to setting up and using whole databases through our
    code. However, the neatest, simplest, and most suitable way for the examples in
    this book is by using the `SharedPreferences` class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use the `SharedPreferences` class to save data. Actually,
    we will be reading and writing to files, but the class hides all of the complexity
    from us and allows us to focus on the game.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a somewhat abstract example of persistence so that we are familiar
    with the code before we use something similar to save the high score in our memory
    game. The complete code for this example can be found in the code bundle at `Chapter5/Persistence/java/MainActivity.java`
    and `Chapter5/Persistence/layout/activity_main.xml`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor window and click and drag one button
    from the palette to the design. The default ID of the button that is assigned
    is perfect for our uses, so no further work is required on the UI.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainActivity.java` in the editor window. Implement `View.onClickListener`
    and autogenerate the required `onClick` method, just as we did in steps 6 and
    7 of the *Playing sound in Android* example previously.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code just after the `MainActivity` declaration. This declares
    our two objects that will do all the complex stuff behind the scenes: a bunch
    of strings that will be useful and a button:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the next block of code to the `onCreate` method after the call to `setContentView`.
    We initialize our objects and set up our button. We will look closely at this
    code once the example is done:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now the action takes place in our `onClick` method. Add this code, which generates
    a random number and adds it to the end of `currentString`. Then it saves the string
    and sets the value of the string to the button as well:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Run the example on an emulator or a device. Notice that each time you press
    the button, a random number is appended to the text of the button. Now quit the
    app, or even shut down the device if you like. When you restart the app, our cool
    `SharedPreferences` class simply loads the last saved string.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the code works. There is nothing we haven''t seen several times
    before until step 4:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we declare two types of `SharedPreferences` objects called `prefs` and
    `editor`. We will see exactly how we use them in a minute.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the `dataName` and `stringName` strings. We do this because
    to use the facilities of `SharedPreferences`, we need to refer to our collection
    of data, as well as any individual pieces of data within it, using a consistent
    name. By initializing `dataName` and `stringName`, we can use them as a name for
    our data store as well as a specific item within that data store, respectively.
    The sad face in `defaultString` gets used any time the `SharedPreferences` object
    needs a default because either nothing has been previously saved or the loading
    process fails for some reason. The `currentString` variable will hold the value
    of the string we will be saving and loading as well as displaying to the user
    of our app. Our buttonis `button1`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In step 5, the real action starts with this code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The previous code does stuff that would take a lot more code if we didn't have
    the useful `SharedPreferences` class. The first two lines initialize the objects
    and the third loads the value from our data store item, whose name is contained
    in `stringName`, to our `currentString` variable. The first time this happens,
    it uses the `defaultString` value because nothing is stored there yet, but once
    there is a value stored, this single line of code that will load up our saved
    string.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of step 5, we set up our button as we have done many times before.
    Moving on to step 6 in the `onClick` method, there is no `switch` block because
    there is only one button. So if a click is detected, it must be our button. Here
    are the first three lines from `onClick`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We generate a random number and append it to the `currentString` variable.
    Next, still in `onClick`, we do this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is like the opposite of the code that loaded our string in `onCreate`.
    The first of the previous two lines identifies the place in the data store to
    write the value to (`stringName`) and the value to be written there (`currentString`).
    The next line, `editor.commit();`, simply says, "go ahead and do it."
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line displays `currentString` as text on our button so that we
    can see what is going on:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more on persistence, take a look at the second question of the *Self-test
    questions* section at the end of this chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The memory game
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in the memory game shouldn't challenge us too much because we have
    done the background research on threads, arrays, sound, and persistence. There
    will be some new-looking code and we will examine it in detail when it crops up.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of our finished game:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![The memory game](img/8859OS_05_15.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'This is the home screen. It shows the high score, which persists between play
    sessions and when the device is shut down. It also shows a **Play** button, which
    will take the player to the main game screen. Take a look at the following screenshot:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![The memory game](img/8859OS_05_16.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: The game screen itself will play a sequence of sounds and numbers. The corresponding
    button will *wobble* in time with the corresponding sound. Then the player will
    be able to interact with the buttons and attempt to copy the sequence. For every
    part of the sequence that the player gets right, they will be awarded points.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: If the sequence is copied in its entirety, then a new and longer sequence will
    be played and again the player will attempt to repeat the sequence. This continues
    until the player gets a part of a sequence wrong.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: As the score increases, it is displayed in the relevant TextView, and when a
    sequence is copied correctly, the level is increased and displayed below the score.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The player can start a new game by pressing the **Replay** button. If a high
    score is achieved, it will be saved to a file and displayed on the home screen.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the game is divided into five phases. The end of a phase
    would be a good place to take a break. Here are the different phases of the game:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 1**: This implements the UI and some basics.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 2**: This prepares our variables and presents the pattern (to be copied)
    to the player.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 3**: In this phase, we will handle the player''s response when they
    try to copy the pattern.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 4**: Here, we will use what we just learned about persistence to maintain
    the player''s high score when they quit the game or turn off their device.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 5**: At the end of phase 4, we will have a fully working memory game.
    However, to add to our repertoire of Android skills, after we have discussed Android
    UI animations near the end of this chapter, we will complete this phase, which
    will enhance our memory game.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the files containing the complete code and the sound files after all five
    stages can be found in the download bundle in the `Chapter5/MemoryGame` folder.
    In this project, however, there is a lot to be learned from going through each
    of the stages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1 – the UI and the basics
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will lay out a home menu screen UI and a UI for the game itself. We
    will also configure some IDs for some of the UI elements so that we can control
    them in our Java code later:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application called `Memory Game` and clean up the code if you wish.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we create a new activity and call it `GameActivity`. So right-click on the
    `java` folder in Project Explorer, navigate to **New** | **Activity**, then click
    on **Next**, name the activity as `GameActivity`, and click on **Finish**. For
    clarity, clean up this activity in the same way as we cleaned up all our others.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the game fullscreen and lock the orientation as we did in the *Going fullscreen
    and locking orientation* tutorial at the end of [Chapter 4](ch04.xhtml "Chapter 4. Discovering
    Loops and Methods"), *Discovering Loops and Methods*.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file from the `res/layout` folder.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s quickly create our home screen UI by performing the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the editor and delete the **Hello World** TextView.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag the following: **Large Text** to the top center (to create our
    title text), **Image** just below that, another **LargeText** below that (for
    our high score), and a **Button** (for our player to click to play). Your UI should
    look a bit like what is shown in the following screenshot:![Phase 1 – the UI and
    the basics](img/8859OS_05_04.jpg)'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the **text** properties of the two TextViews and the Button element to
    make it plain what each will be used for. As usual, you can replace the Android
    icon in the **ImageView** with any image you choose (as we did in [Chapter 4](ch04.xhtml
    "Chapter 4. Discovering Loops and Methods"), *Discovering Loops and Methods*,
    in the *Adding a custom image* tutorial).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tweak the sizes of the elements in the usual way to suit the emulator or device
    you will be running the game on.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make the ID for our **Hi Score** TextView more relevant to its purpose.
    Left-click to select the **Hi Score** TextView, find its **id** property in the
    **Properties** window, and change it to `textHiScore`. The IDs of the image and
    the title are not required, and the existing ID of the play button is `button`,
    which seems appropriate already. So there is nothing else to change here.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s wire up the **Play** button to create a link between the home and the
    game screens, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainActivity.java` in the editor.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `implements View.onClickListener` to the end of the `MainActivity` declaration
    so that it now looks like this:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method we must implement.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of our `onCreate` method, before the closing curly brace, enter
    the following code to get a reference to our **Play** button and listen to clicks:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Scroll down to our `onClick` method and enter the following code in its body
    to have the **Play** button take the player to our `GameActivity`, which we will
    design soon:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'At this point, the app will run and the player can click on the **Play** button
    to take them to our game screen. So let''s quickly create our game screen UI:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Open `activity_game.xml` in the editor and delete the **Hello World** TextView.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag three **Large Text** elements one below the other and center them horizontally.
    Below them, add four buttons stacked one on top of the other, and finally, add
    another button below that but offset it to the right-hand side so that it looks
    like what is shown in the next screenshot. I have also adjusted the text properties
    for the UI elements to make it clear what each will be used for, but this is optional
    because our Java code will do all of the work for us. You can also tweak the sizes
    of the elements in the usual way to suit the emulator or device you will be running
    the game on.![Phase 1 – the UI and the basics](img/8859OS_05_05.jpg)
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s assign some useful IDs to our UI elements so that we can do some
    Java magic with them in the next tutorial. Here is a table that matches the UI
    elements shown in the last screenshot with the **id** property value that you
    need to assign. Assign the following **id** property values to the corresponding
    UI elements:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Purpose | Default id property | New id to assign |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| Score indicator | textView | textScore |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| Difficulty indicator | textView2 | textDifficulty |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| Watch/go indicator | textView3 | textWatchGo |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| Button 1 | button | Leave at default |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| Button 2 | button2 | Leave at default |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| Button 3 | button3 | Leave at default |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| Button 4 | button4 | Leave at default |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| Replay button | button5 | buttonReplay |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: Now that we have our game menu and actual game UI ready to go, we can start
    to make it work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2 – preparing our variables and presenting the pattern
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will set up a whole load of variables and objects for us to use, both
    in this phase and in the later phases. We will also implement the parts of the
    code that present a pattern to the player. We will add code that enables the player
    to respond in a later phase:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Open `GameActivity.java` in the editor window.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I made the sounds by finding a pleasing one then slowly increasing the **Frequency**
    slider for each subsequent sample. You can use my sound from the `assets` folder
    in the `MemoryGame` project or create your own sound using Bfxr.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` folder in the project explorer window, we need to add a folder
    called `assets`. So in the project explorer window, right-click on the `main`
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now copy and paste the four sound files to the newly created `assets` folder.
    You can do so like this: select the files, right-click on them, and then click
    on **Copy**. Then click on the `assets` folder in the Android Studio project explorer.
    Now right-click on the `assets` folder and click on **Paste**.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s prepare `GameActivity` to listen to button clicks just as we did for
    `MainActivity`, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `implementsView.onClickListener` to the end of the `GameActivity` declaration
    so that it now looks like this:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method that we will use shortly.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s declare some objects that we need to reference our UI and our `int`
    references for the sound effects we will load soon. Write the code just after
    the declaration for `GameActivity`. By putting them here, they will be available
    to all parts of our code in `GameActivity.java`. Here is the code in context:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, after the last line of code from the previous step, enter the following
    code snippet, which will declare and initialize some variables for use in our
    thread. Notice that at the end, we also declare `myHandler`, which will be our
    thread, and `gameOn` to control whether our code within the thread is executed:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Just after our call to `setContentView` in the `onCreate` method, we make our
    sound effects ready to be played:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Just after the code in the last step and still within the `onCreate` method,
    we initialize our objects and set click listeners for the buttons:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, after the last line of the code from the previous step, enter the code
    that will create our thread. We will add the details in the next step within the
    `if(playSequence)` block. Notice that the thread is run every nine-tenths of a
    second (900 milliseconds). Notice that we start the thread but do not set `playSequence`
    to `true`. So it will not do anything yet:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Before we look at the code that will run in our thread, we need a way to generate
    a random sequence appropriate for the difficulty level. This situation sounds
    like a candidate for a method. Enter this method just before the closing curly
    brace of the `GameActivity` class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We also need a method to prepare and start our thread. Type the following method
    after the closing curly brace of `createSequence`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, the order of implementation of the methods is unimportant. However,
    following along in order will mean our code will look the same. Even if you are
    referring to the downloaded code, the order will be the same.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Just before we look at the details of the thread code, we need a method to
    tidy up our variables after the sequence has been played. Enter this method after
    the closing curly brace of `playASequence`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we will implement our thread. There is some new code in this part,
    which we will go through in detail after we finish this phase of the project.
    Enter this code between the opening and closing curly braces of the `if(playSequence){
    }` block:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just before the closing curly brace of `onCreate`, we could initiate a sequence
    by calling our `playASequence` method, like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We could then run our app, click on **Play** on the home screen, and watch as
    a sequence of four random buttons and their matching sounds begins, with the sounds
    being played. In the next phase, we will wire up the **Replay** button so that
    the player can start the sequence when they are ready.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Phew! That was a long one. Actually, there is not much new there, but we did
    cram in just about everything we ever learned about Java and Android into one
    place, and we used it in new ways too. So we will look at it step by step and
    give extra focus to the parts that might seem tricky.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each new piece of code in turn.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: From steps 1 to 7, we initialized our variables, set up our buttons, and loaded
    our sounds as we have done before. We also put in the outline of the code for
    our thread.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 8, we implemented the `createSequence` method. We used a `Random` object
    to generate a sequence of random numbers between 1 and 4\. We did this in a `for`
    loop, which loops until a sequence the length of `difficultyLevel` has been created.
    The sequence is stored in an array called `sequenceToCopy`, which we can later
    use to compare to the player''s response:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In step 9, we implemented `playASequence`. First, we call `createSequence`
    to load our `sequenceToCopy` array. Then we set `isResponding` to `false` because
    we don''t want the player to bash buttons while the sequence is still playing.
    We set `elementToPlay` to `0` as this is the first element of our array. We also
    set `playerResponses` to `0`, ready to count the player''s responses. Next, we
    set some text on the UI to `"WATCH!"` to make it clear to the player that the
    sequence is playing. Finally, we set `playSequence` to `true`, which allows the
    code in our thread to run once every 900 milliseconds. Here is the code we have
    just analyzed:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In step 10, we handle `sequenceFinished`. We set `playSequence` to `false`,
    which prevents the code in our thread from running. We set all the buttons back
    to visible because, as we will see in the thread code, we set them to invisible
    to emphasize which button comes next in the sequence. We set our UI text to **GO!**
    to make it clear. It is time for the player to try and copy the sequence. For
    the code in the `checkElement` method to run, we set `isResponding` to `true`.
    We will look at the code in the `checkElement` method in the next phase:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In step 11, we implement our thread. It''s quite long but not too complicated.
    First, we set all the buttons to visible as this is quicker than checking which
    one of them is currently invisible and setting just that one:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then we switch based on what number is next in our sequence, hide the appropriate
    button, and play the appropriate sound. Here is the first case in the `switch`
    block for reference. The other case elements perform the same function but on
    a different button and with a different sound:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we increment `elementToPlay`, ready to play the next part of the sequence
    when the thread runs again in approximately 900 milliseconds:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we check whether we have played the last part of the sequence. If we
    have, we call our `sequenceFinished` method to set things up for the player to
    attempt their answer:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we tell the thread when we would like to run our code again:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: When you ran a sequence (see the previous tip), did you notice an imperfection/bug
    with our game operation? This has to do with the way the last element of the sequence
    is animated. It is because our `sequenceFinished` method makes all the buttons
    visible so soon after the button has just been made invisible that looks like
    the button is never made invisible at all. We will solve the problem of the button
    that doesn't stay invisible long enough when we learn about UI animation in phase
    5.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Now let's handle the player's response.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Phase 3 – the player's response
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have an app that plays a random sequence of button flashes and matching
    sounds. It also stores that sequence in an array. So what we have to do now is
    enable the player to attempt to replicate the sequence and score points if successful.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: We can do all of this in two phases. First, we need to handle the button presses,
    which can pass all the hard work to a method that will do everything else.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the code and look at it as we go. Afterwards, we will closely
    examine the less obvious parts:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we handle the button presses. We have the empty body of the `switch`
    statement with an extra `if` statement that checks whether there is a sequence
    currently being played. If there is a sequence, then no input is accepted. We
    will start to fill the code in the empty body in the next step:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, here is the code that handles `button1`. Notice that it just plays the
    sound related to `button1` and then calls the `checkElement` method, passing a
    value of 1\. This is all we have to do for the buttons 1 through 4: play a sound
    and then tell our new method (`checkElement`) which numbered button was pressed,
    and `checkElement` will do the rest:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here is the near-identical code for buttons 2 through 4\. Notice that the value
    passed to `checkElement` and the sound sample that is played are the only differences
    from the previous step. Enter this code directly after the code in the previous
    step:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here is the last part of the code in our `onClick` method. This handles the
    **Restart** button. The code just resets the score and the difficulty level and
    then calls our `playASequence` method, which does the rest of the work of starting
    the game again. Enter this code directly after the code in the previous step:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, here is our do-everything method. This is quite a long method compared
    to most of our previous methods, but it helps to see its entire structure. We
    will break this down line by line in a minute. Enter the following code, after
    which you will actually be able to play the game and get a score:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We covered the methods fairly comprehensively as we went through the tutorial.
    The one elephant in the room, however, is the apparent sprawl of code in the `checkElement`
    method. So let's go through all of the code in step 6, line by line.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the method signature. Notice that it does not return a value
    but it receives an `int` value. Remember that it is the `onClick` method that
    calls this method and it passes a `1`, `2`, `3`, or `4`, depending upon which
    button was clicked:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we wrap the rest of this code into an `if` statement. Here is the `if`
    statement. We enter the block when the `isResponding` Boolean is `true`, and `isResponding`
    is set to `true` when the `sequenceFinnished` method completes, which is just
    what we need so that the player can''t mash the buttons until it is time to do
    so and our game is ready to listen:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here is what happens inside the `if` block. We increment the number of the
    player''s responses received in the `playerResponses` variable:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now we check whether the number passed to the `checkElement` method and stored
    in `thisElement` matches the appropriate part of the sequence the player is trying
    to copy. If it matches, we increase `playerScore` by an amount relative to the
    number of correctly matched parts of the sequence so far. Then we set the score
    on the screen. Notice that if the response does not match, there is an `else`
    block to go with this `if` block that we will explain soon:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, we have another `if` block. Note that this `if` block is nested inside
    the `if` block we just described. So it will only be tested and potentially run
    if the player''s response was correct. This `if` statement checks whether it is
    the last part of the sequence, like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If it is the last part of the sequence, it executes the following lines:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'What is happening inside the nested `if` statement, which checks whether the
    whole sequence has been correctly copied, is the following: It sets `isResponding`
    to `false`, so the player gets no response from the buttons. It then raises the
    difficulty level by 1 so that the sequence is a bit tougher next time. Finally,
    it calls the `playSequence` method to play another sequence and the whole process
    starts again.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `else` block, which runs if the player gets part of the sequence
    wrong:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, we set some text on the screen and set `isResponding` to `false`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Now let's use what we learned about the `SharedPreferences` class to preserve
    the high scores.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Phase 4 – preserving the high score
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This phase is nice and short. We will use what we learned earlier in the chapter
    to save the player''s score if it is a new high score, and then display the best
    score in the **hi-score** TextView in our `MainActivity`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainActivity.java` in the editor window.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we declare our objects used to read from a file just after the class declaration,
    like this:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, just after our call to `setContentView` in the `onCreate` method, we initialize
    our objects, read from our file, and set the result to our `hiScore` variable.
    We then display it to the player:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Next, we need to go back to the `GameActivity.java` file.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We declare our objects to edit our file, this time like this:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Just after the call to `setContentView` in the `onCreate` method, we instantiate
    our objects and assign a value to `hiScore`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The only thing that is different to what we have already learned is that we
    need to consider where we put the code to test for a high score and where to write
    to our file if appropriate. Consider this: eventually, every player must fail.
    Furthermore, the point at which they fail is the point when their score is at
    its highest, yet before it is reset when they try again. Place the following code
    in the `else` block, which handles a wrong answer from the player. The highlighted
    code is the new code; the rest is there to help you with the context:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Play the game and get a high score. Now quit the app or even restart the phone.
    When you come back to the app, your high score is still there.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The code we added in this phase is nearly the same as the code we wrote in our
    previous example of persistence, the only difference being that we wrote to the
    data store when a new high score was achieved instead of when a button was pressed.
    In addition, we used the `editor.putInt` method because we were saving an integer
    instead of `editor.putString` when we were saving a string.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Animating our game
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go ahead, let's just think about animation. What is it exactly? The
    word probably conjures up images of moving cartoon characters and in-game characters
    of a video game.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We need to animate our buttons (make them move) to make it clear when they are
    part of the sequence. We saw that simply making one disappear and then reappear
    was inadequate.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The thought of controlling the movement of UI elements might make us imagine
    complex `for` loops and per-pixel calculations.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android provides us with the `Animation` class, which allows us
    to animate UI objects without any such per-pixel awkwardness. Here is how it works.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, to fully control the shape and size of in-game objects, we must eventually
    learn to manipulate individual pixels and lines. We will do so from [Chapter 7](ch07.xhtml
    "Chapter 7. Retro Squash Game"), *Retro Squash Game*, onwards, when we make a
    retro pong-style squash game.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: UI animation in Android
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Animations in the Android UI can be divided into three phases:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Describing the animation in a file using a special syntax we will see shortly
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing that animation by creating an object of it in our Java code
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the animation to a UI element when the animation is required to run
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at some code that describes an animation. We will soon be
    reusing this same code in our memory game. The purpose of showing it is not so
    much that we understand each and every line of it. After all, learning Java should
    be enough of an accomplishment without mastering this too. Moreover, the purpose
    is to demonstrate that whatever animation you can describe can then be used in
    our games using the same Java.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly search the Web to find the code to perform the following:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Fading in and out
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliding
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding or shrinking
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphing color
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some code that causes a wobble effect. We will use it on a button,
    but you can also use it on any UI element or even the whole screen:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first line simply states that this is a file written in XML format. The
    next states that we will be performing a rotation. Then we state that the duration
    will be 100 milliseconds, the rotation will be from -5 degrees, the pivot will
    be on the *x* and *y* axes by 50 percent, repeat eight times, and reverse to positive
    5 degrees.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a mouthful, but the point is that it is easy to grab a template
    that works and then customize it to fit our situation. We could save the preceding
    code with a filename like `wobble.xml`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we could simply reference it as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now we can play the animation like this on our chosen UI object, in this case
    our `button1` object:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Phase 5 – animating the UI
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add an animation that causes a button to wobble when a button sound
    is played. At the same time, we can remove the code that makes the button invisible
    and the code that makes it reappear. That wasn''t the best way to do it, but it
    served a purpose while developing the game:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: We need to add a new folder to our project, called `anim`. So right-click on
    the `res` folder in the Project Explorer window. Navigate to **New** | **Android
    resource directory** and click on **OK** to create the new `anim` folder.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the `anim` folder and navigate to **New** | **Animation resource
    file**. Enter `wobble` in the **File name** field and click on **OK**. We now
    have a new file called **wobble.xml** open in the editor window.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace all but the first line of `wobble.xml` with this code:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now switch to `GameActivity.java`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code just after the declaration of our `GameActivity` class:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Just after the call to `setContentView` in our `onCreate` method, add this
    piece of code:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, near the start of our thread code, find the calls to make our buttons
    reappear. Comment them out like this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, directly after our code in the previous step, within each of the four
    `case` statements, we need to comment out the lines that call `setVisibility`
    and replace them with our wobble animation. The following code is slightly abbreviated
    but shows exactly where to comment and where to add the new lines:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, in our `sequenceFinished` method, we can comment out all the `setVisibility`
    calls, just as we did in our thread, like this:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: That was not too tough. We added the wobble animation to the `anim` folder,
    declared an animation object, and initialized it. Then we used it whenever it
    was required on the appropriate button.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: There are obviously loads of improvements we could make to this game, especially
    to its appearance. I'm sure you can think of more. And certainly, if this was
    to be your app, you were trying to make it big on the Play Store. That is exactly
    what you should do.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Constantly improve all aspects and strive to be the best in your genre. If you
    feel the urge, then why not improve upon it?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few self-test questions that look at ways we could do more with some
    of the examples from this chapter.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) Suppose that we want to have a quiz where the question could be to name
    the president as well as capital city. How can we do this with multidimensional
    arrays?
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Q2) In our *Persistence example* section, we saved a continually updating string
    to a file so that it persisted after the app had been shut down and restarted.
    This is like asking the user to click on a Save button. Summoning all your knowledge
    of [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it in the button click but just when the user quits the app?
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Q3) Other than increasing the difficulty level, how could we increase the challenge
    of our memory game for our players?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer and try and work out how
    we could quickly improve the visual appearance of our UI.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a bit of a hefty chapter, but we learned lots of new techniques such
    as storing and manipulating with arrays, creating and using sound effects, and
    saving important data such as a high score, in our game. We also took a very brief
    look at the powerful but simple-to-use `Animation` class.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a more theoretical approach, but we will
    have plenty of working samples too. We will finally be opening the black box of
    Java classes so that we can gain an understanding of what is going on when we
    declare and use objects of a class.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
