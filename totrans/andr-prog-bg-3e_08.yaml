- en: '*Chapter 8*: Java Decisions and Loops'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned about variables and we know how we can change the values
    that they hold with expressions, but how can we take a course of action dependent
    upon the value of a variable?
  prefs: []
  type: TYPE_NORMAL
- en: We can certainly add the number of new messages to the number of previously
    unread messages, but how might we, for example, trigger an action within our app
    when the user has read all their messages?
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that we need a way to test the value of a variable and
    then respond when the value falls within a range of values or is a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that is common in all forms of programming is that we need sections
    of our code to be executed a certain number of times (more than once or sometimes
    not at all) depending on the value of variables.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the first problem, we will look at making decisions in Java with `if`,
    `else`, and `switch`. To solve the latter, we will look at loops in Java with
    `while`, `do while`, `for`, and `break`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming up in this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions with `if`, `else`, `else if`, and `switch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` demo app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java `while` loops and `do while` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops demo app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn some more Java.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2008](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2008).
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Java code will constantly be making decisions. For example, we might need
    to know whether the user has new messages or whether they have a certain number
    of friends. We need to be able to test our variables to see whether they meet
    certain conditions and then execute a certain section of code depending upon whether
    they do or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, as our code gets more complicated, it helps to present it in
    a way that makes it more readable. Let's look at code indenting to make our discussion
    about decisions easier.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting code for clarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have probably noticed that the Java code in our projects is indented. For
    example, the first line of code inside the `MainActivity` class is indented by
    one tab. Also, the first line of code is indented inside each method. Here is
    an annotated screenshot to make this clear and as another quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Indented Java code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Indented Java code
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that when the indented block has ended, often with a closing curly
    brace, `}`,the `}` is indented to the same extent as the line of code that began
    the block.
  prefs: []
  type: TYPE_NORMAL
- en: We do this to make the code more readable. It is not part of the Java syntax,
    however, and the code will still compile if we don't do this.
  prefs: []
  type: TYPE_NORMAL
- en: As our code gets more complicated, indenting, along with comments, helps to
    keep the meaning and structure of our code clear. I mention this now because when
    we start to learn the syntax for making decisions in Java, indenting becomes especially
    useful and it is recommended that you indent your code the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Much of this indenting is done for us by Android Studio but not all of it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to present our code more clearly, let's learn about some more
    operators, and then we can really get to work with making decisions with Java.
  prefs: []
  type: TYPE_NORMAL
- en: More operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can already add (+), take away (-), multiply (*), divide (/), assign (=),
    increment (++), and decrement (--) with operators. Let's introduce some more useful
    operators, and then we will go straight into actually understanding how to use
    them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about memorizing every operator that follows. Glance over them and
    their explanations and then move quickly on to the next section. There, we will
    put some operators to use and they will become much clearer as we see a few examples
    of what they allow us to do. They are presented here in a list so they are more
    convenient to refer back to when not intermingled with the discussion about implementation
    that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use operators to create an expression that is either true or false. We wrap
    that expression in parentheses like this: `(expression goes here)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the comparison operator and it tests for equality; it is either true
    or false: `==`'
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `(10 == 9)`, for example, is false. 10 is obviously not
    equal to 9\. However, an expression such as `(2 + 2 == 4)` is obviously true.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Except in *1984* when 2 + 2 == 5 ([https://en.wikipedia.org/wiki/Nineteen_Eighty-Four](https://en.wikipedia.org/wiki/Nineteen_Eighty-Four)).
  prefs: []
  type: TYPE_NORMAL
- en: The logical NOT operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the logical NOT operator: `!`'
  prefs: []
  type: TYPE_NORMAL
- en: It is used to test the negation of an expression. Negation means if the expression
    is false, then the NOT operator causes the expression to be true. An example will
    help.
  prefs: []
  type: TYPE_NORMAL
- en: The expression `(!(2 + 2 == 5))` evaluates to true because 2 + 2 *is NOT* 5\.
    But a further example of `(!(2 + 2 = 4))` would be false. This is because 2 +
    2 obviously *is* 4.
  prefs: []
  type: TYPE_NORMAL
- en: The NOT equal operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the NOT equal operator and it is another comparison operator: `!=`'
  prefs: []
  type: TYPE_NORMAL
- en: The NOT equal operator tests whether something is NOT equal. For example, the
    expression `(10 != 9)` is true. 10 is not equal to 9\. On the other hand, `(10
    != 10)` is false because 10 clearly is equal to 10.
  prefs: []
  type: TYPE_NORMAL
- en: The greater than operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another comparison operator (and there are a few more as well) is the greater
    than operator. Here it is: `>`'
  prefs: []
  type: TYPE_NORMAL
- en: This operator tests whether something is greater than something else. The expression
    `(10 > 9)` is true but the expression `(9 > 10)` is false.
  prefs: []
  type: TYPE_NORMAL
- en: The less than operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can probably guess that this operator tests for values being less than
    others. This is what the operator looks like: `<`'
  prefs: []
  type: TYPE_NORMAL
- en: The expression `(10 < 9)` is false because 10 is not less than 9, while the
    expression `(9 < 10)` is true.
  prefs: []
  type: TYPE_NORMAL
- en: The greater than or equal to operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator tests whether one value is greater than or equal to another and
    if either is true, the result is true. This is what the operator looks like: `>=`'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the expression `(10 >= 9)` is true, the expression `(10 >= 10)`
    is also true, but the expression `(10 >= 11)` is false because 10 is neither greater
    than nor equal to 11.
  prefs: []
  type: TYPE_NORMAL
- en: The less than or equal to operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like the previous operator, this one tests for two conditions but this time
    less than or equal to. Look at the operator shown next and then we will see some
    examples: `<=`'
  prefs: []
  type: TYPE_NORMAL
- en: The expression `(10 <= 9)` is false, the expression `(10 <= 10)` is true, and
    the expression `(10 <= 11)` is also true.
  prefs: []
  type: TYPE_NORMAL
- en: The logical AND operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is known as logical AND. It tests two or more separate parts
    of an expression and all parts must be true for the entire expression to be true:
    `&&`'
  prefs: []
  type: TYPE_NORMAL
- en: Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression `((10 > 9) && (10 < 11))` is true because both
    parts are true. On the other hand, the expression `((10 > 9) &&` `(10 < 9))` is
    false because only one part of the expression is true, `(10 > 9)`, and the other
    is false, `(10 < 9)`.
  prefs: []
  type: TYPE_NORMAL
- en: The logical OR operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is called logical OR and it is just like logical AND except that
    only one of two or more parts of an expression needs to be true for the expression
    to be true: `||`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the last example we used for logical AND but switch the `&&` for
    `||`. The expression `((10 > 9) || (10 < 9))` is now true because at least one
    part of the expression is true.
  prefs: []
  type: TYPE_NORMAL
- en: The modulus operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This operator is called modulus (`%`). It returns the remainder of two numbers
    after dividing them. For example, the expression `(16 % 3 > 0)` is true because
    16 divided by 3 is 5 remainder 1 and 1 is, of course, greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing these operators in a more practical context in this chapter and throughout
    the rest of the book will help clarify the different uses. Now we know how to
    form expressions with operators, variables, and values. Next, we can look at a
    way of structuring and combining expressions to make some deep decisions.
  prefs: []
  type: TYPE_NORMAL
- en: How to use all these operators to test variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All these operators are virtually useless without a way of properly using them
    to make real decisions that affect real variables and code.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the information we need, we can look at a hypothetical situation,
    then actually see some code for decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Java if keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw, operators serve very little purpose on their own, but it was probably
    useful to see just part of the wide and varied range available to us. Now, when
    we look at putting the most common operator, `==`, to use, we can start to see
    the powerful yet fine control that operators offer us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the previous examples less abstract. Meet the Java `if` keyword.
    We will use `if` and a few conditional operators along with a small story to demonstrate
    their use. Next follows a made-up military situation that will hopefully be less
    abstract than the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Java program to convey his last orders after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements
    – but with a few rules that determine their actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command the captain wants to make sure his troops understand is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**If they come over the bridge, shoot them.**'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we simulate this situation in Java? We need a Boolean variable, `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized to either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use `if` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the `isComingOverBridge` Boolean is `true`, the code inside the opening and
    closing curly braces will execute. If `isComingOverBridge` is `false`, the program
    continues after the `if` block, without running the code within it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Else do this instead**'
  prefs: []
  type: TYPE_NORMAL
- en: The captain also wants to tell his troops what to do if the enemy is not coming
    over the bridge. In this situation, he wants them to stay where they are and wait.
  prefs: []
  type: TYPE_NORMAL
- en: Now we introduce another Java keyword, `else`. When we want to explicitly do
    something when `if` does not evaluate to true, we can use `else`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we could write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The captain then realizes that the problem isn't as simple as he first thought.
    What if the enemy comes over the bridge but has too many troops? His squad would
    be overrun and slaughtered.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, he comes up with this code (we''ll use some variables as well this time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has three possible paths of execution. The first is if the
    enemy is coming over the bridge and the friendly troops are greater in number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, the third and final possible outcome that will execute if neither of the
    others is true is captured by the final `else` without an `if` condition.
  prefs: []
  type: TYPE_NORMAL
- en: Reader challenge
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly
    and would therefore be handled by the final `else`, which is meant for when there
    are no enemy troops. I guess any self-respecting captain would expect his troops
    to fight in this situation and he could have changed the first `if` statement
    to accommodate this possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if(isComingOverBridge && friendlyTroops >= enemyTroops)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the captain''s last concern is that if the enemy comes over the bridge
    waving the white flag of surrender and is promptly slaughtered, then his men would
    end up as war criminals. The Java code needed is obvious. Using the `wavingWhiteFlag`
    Boolean variable, he writes this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But where to put this code is less clear. In the end, the captain opts for
    the following nested solution and changes the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that we can nest `if` and `else` statements inside of one
    another to create quite deep and detailed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We could go on making more and more complicated decisions with `if` and `else`
    but what we have seen is more than sufficient as an introduction.
  prefs: []
  type: TYPE_NORMAL
- en: It is probably worth pointing out that very often there is more than one way
    to arrive at a solution to a problem. The *right* way will usually be the way
    that solves the problem in the clearest and simplest manner.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some other ways to make decisions in Java, and then we can put
    them all together in an app.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to make decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the vast and virtually limitless possibilities of combining the
    Java operators with `if` and `else` statements. But sometimes a decision in Java
    can be better made in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: When we are deciding based on a clear list of possibilities that don't involve
    complex combinations, `switch` is usually the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start a `switch` decision like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `argument` could be an expression or a variable. Within
    the curly braces, `{}`, we can make decisions based on the argument with `case`
    and `break` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the previous example that each `case` states a possible result
    and each `break` denotes the end of that case, as well as the point at which no
    further `case` statements should be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The first `break` encountered breaks out of the `switch` block to proceed with
    the next line of code after the closing brace, `}`, of the entire `switch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `default` without a value to run some code in case none of
    the `case` statements evaluate to true, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's write a quick demo app that uses `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: The switch demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, create a new Android project called `Switch` `Demo`, use the
    `MainActivity.java` file by left-clicking on the **MainActivity.java** tab above
    the editor and we can start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend we are writing an old-fashioned text adventure game, the kind
    of game where the player types commands such as "Go East," "Go West," "Take Sword,"
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `switch` could handle that situation with something such as this
    example code and we could use `default` to handle the player typing a command
    that is not specifically handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the `onCreate` method just before the closing curly
    brace, `}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the app a few times. Each time, change the initialization of `command` to
    something new. Notice that when you initialize `command` to something that is
    explicitly handled by a `case` statement, we get the expected output. Otherwise,
    we get the default **Sorry I don't speak Elfish** message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had a lot of code to execute for `case`, we could contain it all in a
    method – perhaps like in this next piece of code, where I have highlighted the
    new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we would then need to write the new `goWest` method. Then, when `command`
    is initialized to `"go west"`, the `goWest` method would be executed, and when
    `goWest` completes, execution would return to the `break` statement, which would
    cause the code to continue after the `switch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one of the things this code seriously lacks is interaction with a
    UI. We have seen how we can call methods from button clicks but even that isn't
    enough to make this code worthwhile in a real app. We will see how we solve this
    problem in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218), *The Stack,
    the Heap, and the Garbage Collector*.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem we have is that after the code has been executed, that's it!
    We need it to continually ask the player for instructions, not just once but over
    and over. We will look at a solution to this problem next.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating code with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will learn how to repeatedly execute portions of our code in a controlled
    and precise way by looking at several types of `while` loops, `do while` loops,
    and `for` loops. We will also learn about the most appropriate situations to use
    the different types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: It would be completely reasonable to ask what loops have to do with programming.
    But they are exactly what the name implies. They are a way of repeating the same
    part of the code more than once – or looping over the same part of code although
    potentially for a different outcome each time.
  prefs: []
  type: TYPE_NORMAL
- en: This can simply mean doing the same thing until the code being looped over (`if`,
    `else`, and `switch`, loops are part of the Java **control flow statements**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that executes when a condition is true is known as the `do while`
    loop), can be illustrated by this simple diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The condition is tested when the loop is reached in the code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The condition is tested when the loop is reached in the code
  prefs: []
  type: TYPE_NORMAL
- en: This diagram illustrates that when the loop is reached in the code, the condition
    is tested. If the condition is true, the conditional code is executed. After the
    conditional code is executed, the condition is tested again. Any time the condition
    is false, the code continues after the loop. This could mean that the conditional
    code is never executed.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at all the major types of loops that Java offers us to control
    our code and we will use some of them to implement a working mini-app to make
    sure we understand them completely. Let's look at the first and simplest loop
    type in Java, called the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java `while` loops have the simplest syntax. Think back to the `if` statements
    for a moment. We could put virtually any combination of operators and variables
    in the conditional expression of the `if` statement. If the expression evaluates
    to true, then the code in the body of the `if` block is executed. With the `while`
    loop, we also use an expression that can evaluate to true or false. Look at this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens here is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the `while` loop, an `int` named `x` is declared and initialized
    to `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `while` loop begins. Its condition is `x > 0`. So, the `while` loop
    will execute the code in its body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code in its body will continue to execute until the condition evaluates
    to false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the previous code will execute 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: On the first pass, `x = 10`, on the second pass it equals `9`, then `8`, and
    so on. But once `x` is equal to `0`, it is of course no longer greater than 0\.
    At this point, the program will exit the `while` loop and continue with the first
    line of code after the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Look at this example where the code in the `while` loop will
    not execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, there is no limit to the complexity of the conditional expression
    or the amount of code that can go in the loop body. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `while` loop would continue to execute until both `newMessages`
    and `unreadMessages` are equal to or less than 0\. As the condition uses the logical
    OR operator, `||`, either one of those conditions being true will cause the `while`
    loop to continue executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete even if the expression evaluates to false partway through, as
    it is not tested again until the code tries to start another pass. Take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever! This perhaps unsurprisingly is called an infinite
    loop. Here is an example of an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Breaking out of a loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might use an infinite loop like this so that we can decide when to exit
    the loop from a test contained within its body. We would do this by using the
    `break` keyword when we are ready to leave the loop''s body. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have been able to guess that we can combine any of the decision-making
    tools such as `if`, `else`, and `switch` within our `while` loops and all the
    rest of the loops we will look at in a minute. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It would be simple to go on for many more pages demonstrating the versatility
    of `while` loops but at some point, we want to get back to doing some real programming.
    So here is one last concept combined with `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The continue keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `break` – up to a point. The `continue` keyword will break out of the loop
    body but will also check the condition expression afterward so the loop can run
    again. An example will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: do while loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `do while` loop is very much the same as `while` loops with the exception
    that a `do` `while` loop evaluates its expression *after* the body. Look at this
    modification of the previous figure that represents the flow of a `do while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – do while loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – do while loop
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that a `do while` loop will always execute the conditional code
    at least once before checking the loop condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the loop was executed even though the test was false because
    the test is done after the execution of the loop. The test did, however, prevent
    the loop body from being executed a second time. This caused `x` to be incremented
    once and `x` now equals `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that `break` and `continue` can also be used in `do while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The next type of loop we will cover is the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `for` loop has a slightly more complicated syntax than the `while` or `do
    while` loops as it takes three parts to initialize. Have a look at the code first,
    then we will break it apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The slightly more complicated form of the `for` loop is clearer when put like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To clarify further, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`declaration and initialization`: We create a new `int` variable, `i`,and initialize
    it to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`condition`: Just like the other loops, it refers to the condition that must
    evaluate to true for the loop to continue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`change after each pass through the loop`: In the example, `i++` means that
    1 is added/incremented to `i` on each pass. We could also use `i--` to reduce/decrement
    `i` at each pass:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that `break` and `continue` can also be used in `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop takes control of initialization, condition evaluation, and the
    modification of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Loops demo app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, create a new Android project called `Loops`, use the **Empty
    Activity** template, and leave all the other settings at their default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a few buttons to our UI to make this more fun. Switch to the `activity_main.xml`
    file and make sure you are on the **Design** tab, and then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a button onto the UI and center it horizontally near the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the properties window, change the `Count Up`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the properties window, change the `countUp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a new button just below the previous one and repeat *steps 2* and *3*
    but this time use `Count Down` for the `countDown` for the **onClick** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a new button just below the previous one and repeat *steps 2* and *3*
    but this time use **nested** for the **text** property and the **onClick** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Infer Constraints** button to constrain the three buttons in position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Looks are not important for this demo but run the app and check that the layout
    looks something like in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Buttons added to the UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Buttons added to the UI
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: I also deleted the "Hello World!" `TextView` but this is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What is important is that we have three buttons labeled **COUNT UP**, **COUNT
    DOWN**, and **NESTED**, which call methods named **countUp**, **countDown**, and
    **nested**, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `MainActivity.java` file by left-clicking the **MainActivity.java**
    tab above the editor and we can start coding our methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the closing curly brace of the `onCreate` method, add the `countUp` method
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Log` and `View` classes using your preferred method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.util.Log;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.View;`'
  prefs: []
  type: TYPE_NORMAL
- en: We will be able to call this method we have just written from the appropriately
    labeled button.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the closing curly brace of the `countUp` method, add the `countDown`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We will be able to call this method we have just written from the appropriately
    labeled button.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the closing curly brace of the `countDown` method, add the `nested` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will be able to call this method we have just written from the appropriately
    labeled button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the app and start tapping buttons. If you tap each of the buttons
    once from top to bottom, this is the console output you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `countUp` method does exactly that. The `int x` variable
    is initialized to `0`, an infinite `while` loop is entered, and `x` is incremented
    with the increment `++` operator. Fortunately, on each iteration of the loop,
    we test for `x` being equal to `3` with `if (x == 3)` and break when this is true.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `countDown` method, we do the same in reverse. The `int x` variable
    is initialized to `4`, an infinite `while` loop is entered, and `x` is decremented
    with the decrement `--` operator. This time, on each iteration of the loop, we
    test for `x` being equal to `1` with `if (x == 1)` and break when this is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we nest two `for` loops within each other. We can see from the output
    that each time `i` (which is controlled by the outer loop) is incremented, `j`
    (which is controlled by the inner loop) is decremented from `3` to `1`. Look carefully
    at this screenshot, which shows where the start and end of each `for` loop is,
    to help fully understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – for loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – for loop
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, keep tapping to observe each button's output for as long
    as you like. As an experiment, try making the loops longer, perhaps `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: With loops thoroughly learned and tested, let's look at the finer details of
    methods in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use `if`, `else`, and `switch` to make decisions
    with expressions and branch our code. We saw and practiced `while`, `for`, and
    `do while` to repeat parts of our code. Then we put it all together in two quick
    demo apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a much closer look at Java methods, which
    is where all our code will go.
  prefs: []
  type: TYPE_NORMAL
