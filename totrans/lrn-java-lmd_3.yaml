- en: Chapter 3. Lambdas in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll take a look at things in a little more detail and talk
    about some related topics, things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method and constructor references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope and effectively final variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between lambdas and closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we've talked about how lambdas aren't just syntactic sugar, we'll have a
    look at the bytecode lambdas produce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java treats lambdas as an instance of an interface type. It formalizes this
    into something it calls *functional interfaces*. A functional interface is just
    an interface with a single method. Java calls the method a "functional method"
    but the name "single abstract method" or SAM is often used.
  prefs: []
  type: TYPE_NORMAL
- en: All the existing single method interfaces like `Runnable` and `Callable` in
    the JDK are now functional interfaces and lambdas can be used anywhere a single
    abstract method interface is used. In fact, it's functional interfaces that allow
    for what's called *target typing*; they provide enough information for the compiler
    to infer argument and return types.
  prefs: []
  type: TYPE_NORMAL
- en: '@FunctionalInterface'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oracle have introduced a new annotation `@FunctionalInterface` to mark an interface
    as such. It's basically to communicate intent but also allows the compiler to
    do some additional checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this interface compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: but when you indicate that it should be a *functional interface* by adding the
    new annotation,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: the compiler will raise an error. It tells us "Example is not a functional interface"
    as "no abstract method was found". Often the IDE will also hint, [IntelliJ](http://www.jetbrains.com/idea/)
    will say something like "no target method was found". It's hinting that we left
    off the functional method. A "single abstract method" needs a single, `abstract`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: So what if we try and add a second method to the interface?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will error again, this time with a message along the lines of "multiple,
    non-overriding abstract methods were found". Functional interfaces can have only
    **one** method.
  prefs: []
  type: TYPE_NORMAL
- en: Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about the case of an interfaces that extends another interface?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new functional interface called `A` and another called `B`
    which extends `A`. The  `B` interface is still a functional interface. It inherits
    the parents `apply` method as you''d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to make this clearer, you can also override the functional method
    from the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can verify it works as a functional interface if we use it as a lambda. We'll
    implement a method to show that a lambda can be assigned to a type of A and a
    type of B below. The implementation just prints out `"A"` or `"B"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can't add a new `abstract` method to the extending interface (B) though,
    as the resulting type would have two `abstract` methods and the IDE would warn
    us and the compiler would error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, you can override methods from `Object` without causing problems.
    You can also add default methods (also new from Java 8 onward). As you'd probably
    expect, it doesn't make sense to try and mark an abstract class as a functional
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Other interface improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces generally have had some new features added, they include:'
  prefs: []
  type: TYPE_NORMAL
- en: Default methods (virtual extension methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static interface methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And a bunch of new functional interfaces in the `java.util.function` package;
    things like `Function` and `Predicate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we've talked about how any interface with a single method is
    now a "functional interface" and that the single method is often called a "functional
    method" or SAM (for single abstract method).
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the new annotation and saw a couple of examples of how existing
    JDK interfaces like `Runnable` and `Callable` have been retrofitted with the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced the idea of *target typing* which is how the compiler can
    use the signature of a functional method to help work out what lambdas can be
    used where. We skimmed over this a little as we're going to talk about it later
    in the type inference section.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed some examples of functional interfaces, how the compiler and IDE
    can help us out when we make mistakes and got a feel for the kinds of errors we
    might encounter. Things like adding more than one method to a functional interface.
    We also saw the exceptions to this rule, namely when we override methods from
    `Object` or implement default methods.
  prefs: []
  type: TYPE_NORMAL
- en: We had a quick look at interface inheritance and how that affects things and
    mentioned some of the other interface improvements that we'll be covering later.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to take away here is the idea that any place a functional
    interface is used, you can now use a lambda. Lambdas can be used in-lieu of anonymous
    implementations of the functional interface. Using a lambda instead of the anonymous
    class may seem like syntactic sugar, but they're actually quiet different. See
    the *Functions vs. classes* section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have been several type inference improvements in modern Java. To be able
    to support lambdas, the way the compiler infers things has been improved to use
    *target typing* extensively. This and other improvements over Java 7's inference
    were managed under the Open **JDK Enhancement Proposal** (**JEP**) 101.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into those, lets recap on the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference refers to the ability for a programming language to automatically
    deduce the type of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Statically typed languages know the types of things at *compile* time. Dynamically
    typed languages know the types at *runtime*. A statically typed language can use
    type inference and drop type information in source code and use the compiler to
    figure out what's missing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Type inference improvements](img/static_vs_dynamic.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So this means that type inference can be used by statically typed languages
    (like Scala) to "look" like dynamic languages (like JavaScript). At least at the
    source code level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a line of code in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to tell the compiler explicitly that the value is a string. It
    figures it out. You could write it out explicitly like this,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: but there's no need.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, Scala also tries to figure out when you've finished a statement
    or expression based on it's **abstract syntax tree** (**AST**). So often, you
    don't even need to add a terminating semi-colon.
  prefs: []
  type: TYPE_NORMAL
- en: Java type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type inference is a fairly broad topic, Java doesn''t support the type of inference.
    I''ve just been talking about, at least for things like dropping the type annotations
    for variables. We have to keep that in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So Java doesn't support type inference in the wider sense. It can't guess *everything*
    like some languages. Type inference for Java then typically refers to the way
    the compiler can work out types for generics. Java 7 improved this when it introduced
    the diamond operator (`<>`) but there are still lots of limitations in what Java
    *can* figure out.
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler was built with type erasure; it actively removes the type
    information during compilation. Because of type erasure, `List<String>` becomes
    `List<Object>` after compilation.
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, when generics were introduced in Java 5, the developers
    couldn't easily reverse the decision to use erasure. Java was left with the need
    to understand what types to substitute for a given generic type but no information
    how to do it because it had all been erased. Type inference was the solution.
  prefs: []
  type: TYPE_NORMAL
- en: All generic values are really of type `Object` behind the scenes but by using
    type inference, the compiler can check that all the source code usages are consistent
    with what it thinks the generic should be. At runtime, everything is going to
    get passed around as instances of `Object` with appropriate casting behind the
    scenes. Type inference just allows the compiler to check that the casts would
    be valid ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So type inference is about guessing the types, Java''s support for type inferences
    was due to be improved in a couple of ways with Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: Target-typing for lambdas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'and using generalized target-typing to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add support for parameter type inference in method calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add support for parameter type inference in chained calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lets have a look at the current problems and how modern Java addresses them.
  prefs: []
  type: TYPE_NORMAL
- en: Target-typing for lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general improvements to type inference in modern Java mean that lambdas
    can infer their type parameters; so rather than use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'you can drop the `Integer` type annotation and use the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is because the functional interface describes the types, it gives the compiler
    all the information it needs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we take an example functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When a lambda is used in-lieu of the interface, the first thing the compiler
    does is work out the *target* type of the lambda. So if we create a method `calculate`
    that takes the interface and two integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: and then create two lambdas; an addition and subtraction function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'and use them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The compiler understands that the lambdas addition and subtraction have a target
    type of Calculation (it's the only "shape" that will fit the method signature
    of calculate). It can then use the method signature to infer the types of the
    lambda's parameters. There's only one method on the interface, so there's no ambiguity,
    the argument types are obviously `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look at lots of examples of target typing so for now, just be
    aware that the mechanism Java uses to achieve lots of the lambda goodness relies
    on improvements to type inference and this idea of a *target* type.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters in method calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The were some situations prior to Java 8 where the compiler couldn't infer types.
    One of these was when calling methods with generic type parameters as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Collections` class has a generified method for producing
    an empty list. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java 7 this compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: as the Java 7 compiler can work out that the generic needed for the `emptyList`
    method is of type `String`. What it struggles with though is if the result of
    a generic method is passed as a parameter to another method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we had a method to process a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: and then call it with the empty list method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: it won't compile because the generic type of the parameter has been erased to
    `Object`. It really looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't match the `processList` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So it won't compile until we give it an extra hint using an explicit "type witness".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now the compiler knows enough about what generic type is being passed into the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The improvements in Java 8 include better support for this, so generally speaking
    where you would have needed a type witness, you no longer do.
  prefs: []
  type: TYPE_NORMAL
- en: Our example of calling the `processNames` now compiles!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Type parameters in chained method calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common problem with type inference is when methods are chained together.
    Lets suppose we have a `List` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: and we want to chain a call to add an element to the method creating an empty
    list. Type erasure rears it's head again; the type is erased and so can't be known
    by the next method in the chain. It doesn't compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This was due to be fixed in Java 8, but unfortunately it was dropped. So, at
    least for now, you'll still need to explicitly offer up a type to the compiler;
    you'll still need a type witness.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned earlier that method references are kind of like shortcuts to lambdas.
    They're a compact and convenient way to point to a method and allow that method
    to be used anywhere a lambda would be used.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a lambda, you create an anonymous function and supply the method
    body. When you use a method reference as a lambda, it's actually pointing to a
    *named* method that already exists; it already has a body.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of them as *transforming* a regular method into a functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'or, a more concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The part preceding the double colon is the target reference and after, the method
    name. So, in this case, we're targeting the `String` class and looking for a method
    called `valueOf`; we're referring to the `static` method on `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The double colon is called the *delimiter*. When we use it, we're not invoking
    the method, just *referencing* it. So remember not to add brackets on the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can't invoke method references directly, they can only be used in-lieu of
    a lambda. So anywhere a lambda is used, you can use a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This statement on it's own won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's because the method reference can't be transformed into a lambda as there's
    no context for the compiler to infer what type of lambda to create.
  prefs: []
  type: TYPE_NORMAL
- en: '*We* happen to know that this reference is equivalent to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: but the compiler doesn't know that yet. It can tell some things though. It knows,
    that as a lambda, the return value should be of type `String` because all methods
    called `valueOf` in `String` return a string. But it has no idea what to supply
    as a argument. We need to give it a little help and give it some more context.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a functional interface called `Conversion` that takes an integer
    and returns a string. This is going to be the target type of our lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to create a scenario where we use this as a lambda. So we create
    a little method to take in a functional interface and apply an integer to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, here's the thing. We've just given the compiler enough information to transform
    a method reference into the equivalent lambda.
  prefs: []
  type: TYPE_NORMAL
- en: When we call `convert` method, we can do so passing in a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And we can replace the lambda with a reference to the `valueOf` method. The
    compiler now knows we need a lambda that returns a string and takes an integer.
    It now knows that the `valueOf` method "fits" and can substitute the integer argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Another way to give the compiler the information it needs is just to assign
    the reference to a type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: and as a method reference
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: the "shapes" fit, so it can be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, we can assign the same lambda to any interface that requires
    the same "shape". For example, if we have another functional interface with the
    same "shape",
  prefs: []
  type: TYPE_NORMAL
- en: Here, `Example` returns a `String` and takes an `Object` so it has the same
    signature shape as `valueOf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: we can still assign the method reference (or lambda) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Method reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four types of method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And two types of instance method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two are a little confusing. The first is a method reference of a particular
    object and the second is a method reference of an *arbitrary* object *but* of
    a particular type. The difference is in how you want to use the method and if
    you have the instance ahead of time or not.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly then, lets have a look at constructor references.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A *target* type followed by the double colon then the `new` keyword. It's going
    to create a lambda that will call the zero argument constructor of the `String`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: It's equivalent to this lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Remember that method references never have the parentheses; they're not invoking
    methods, just referencing one. This example is referring to the constructor of
    the `String` class but *not* instantiating a string.
  prefs: []
  type: TYPE_NORMAL
- en: Lets have a look at how we might actually use a constructor reference.
  prefs: []
  type: TYPE_NORMAL
- en: If we create a list of objects we might want to populate that list say ten items.
    So we could create a loop and add a new object ten times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: but if we want to be able to reuse that initializing function, we could extract
    the code to a new method called `initialise` and then use a factory to create
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Factory` class is just a functional interface with a method called `create`
    that returns some object. We can then add the object it created to the list. Because
    it''s a functional interface, we can use a lambda to implement the factory to
    initialize the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Or we could swap in a constructor reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There's a couple of other things we could do here. If we add some generics to
    the `initialise` method we can reuse it when initializing lists of any type. For
    example, we can go back and change the type of the list to be `String` and use
    a constructor reference to initialize it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We've seen how it works for zero argument constructors, but what about the case
    when classes have multiple argument constructors?
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple constructors, you use the same syntax but the compiler
    figures out which constructor would be the best match. It does this based on the
    *target* type and inferring functional interfaces that it can use to create that
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the example of a `Person` class, it looks like this and you can see
    the constructor takes a bunch of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to our example from earlier and looking at the general purpose `initialise`
    method, we could use a lambda like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'but to be able to use a constructor reference, we''d need a lambda *with variable
    arguments* and that would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: but this doesn't translate to a constructor reference directly. If we were to
    try and use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: it won't compile as it doesn't know anything about the parameters. If you try
    and compile it, the error says you've created an invalid constructor reference
    that cannot be applied to the given types; it found no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we have to introduce some indirection to give the compiler enough information
    to find an appropriate constructor. We can create something that can be used as
    a functional interface *and* has the right types to slot into the appropriate
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new functional interface called `PersonFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, the arguments from `PersonFactory` match the available constructor on
    `Person`. Magically, this means we can go back and use it with a constructor reference
    of `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice I'm using the constructor reference from `Person`. The thing to note
    here is that a constructor reference can be assigned to a target functional interface
    even though we don't yet know the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem a bit strange that the type of the method reference is `PersonFactory`
    and not `Person`. This extra target type information helps the compiler to know
    it has to go via `PersonFactory` to create a `Person`. With this extra hint, the
    compiler is able to create a lambda based on the factory interface that will *later*
    create a `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing it out long hand, the compiler would generate this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'which could be used later like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, the compiler can do this for us once we've introduced the indirection.
  prefs: []
  type: TYPE_NORMAL
- en: It understands the target type to use is `PersonFactory` and it understands
    that it's single `abstract` method can be used in-lieu of a constructor. It's
    kind of like a two step process, firstly, to work out that the `abstract` method
    has the same argument list as a constructor and that it returns the right type,
    then apply it with colon colon new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To finish off the example, we need to tweak our `initialise` method to add the
    type information (replace the generics), add parameters to represent the person's
    details and actually invoke the factory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'and then we can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'or inline, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Static method reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method reference can point directly to a static method. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This time, the left hand side refers to the type where a static method, in this
    case `valueOf`, can be found. It's equivalent to this lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A more extended example would be where we sort a collection using a reference
    to a static method on the class `Comparators`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'where, the static method `ascending` might be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Instance method reference of particular object (in this case, a closure)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of an instance method reference of a specific instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `x` is a specific instance that we want to get at. It''s lambda equivalent
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The ability to reference the method of a specific instance also gives us a
    convenient way to convert between different functional interface types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Callable's functional method is call. When it's invoked the lambda will return
    `"Hello"`.
  prefs: []
  type: TYPE_NORMAL
- en: If we have another functional interface, `Factory`, we can convert the `Callable`
    using a method reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We could have just re-created the lambda but this trick is a useful way to get
    reuse out of predefined lambdas. Assign them to variables and reuse them to avoid
    duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of it in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is an example where the method reference is using a closure. It creates
    a lambda that will call the `toString` method on the instance `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature and implementation of function above looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Supplier` interface is a functional interface that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in our function, it provides a string value (via the call to `get`)
    and the only way it can do that is if the value has been supplied to it on construction.
    It''s equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that the lambda has no arguments (it uses the "hamburger" symbol).
    This shows that the value of `x` isn't available in the lambda's local scope and
    so can only be available from outside it's scope. It's a closure because must
    close over `x` (it will *capture* `x`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re interested in seeing the long hand, anonymous class equivalent,
    it''ll look like this. Notice again how `x` must be passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: All three of these are equivalent. Compare this to the lambda variation of an
    instance method reference where it doesn't have it's argument explicitly passed
    in from an outside scope.
  prefs: []
  type: TYPE_NORMAL
- en: Instance method reference of a arbitrary object whose instance is supplied later
    (lambda)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last case is for a method reference that points to an arbitrary object
    referred to by its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: So in this case, although it looks like the left hand side is pointing to a
    class (like the `static` method reference), it's actually pointing to an instance.
    The `toString` method is an instance method on `Object`, not a `static` method.
    The reason why you might not use the regular instance method syntax is because
    you may not yet have an instance to refer to.
  prefs: []
  type: TYPE_NORMAL
- en: So before, when we call `x` colon colon `toString`, we know the value of `x`.
    There are some situations where you don't have a value of `x` and in these cases,
    you can still pass around a reference to the method but supply a value later using
    this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the lambda equivalent doesn't have a bound value for `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: There difference between the two types of instance method reference is basically
    academic. Sometimes, you'll need to pass something in, other times, the usage
    of the lambda will supply it for you.
  prefs: []
  type: TYPE_NORMAL
- en: The example is similar to the regular method reference; it calls the `toString`
    method of a string only this time, the string is supplied to the function that's
    making use of the lambda and not passed in from an outside scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `String` part looks like it's referring to a class but it's actually referencing
    an instance. It's confusing, I know but to see things more clearly, we need to
    see the function that's making use of the lambda. It looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: So, the string value is passed directly to the function, it would look like
    this as a fully qualified lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: which Java can shortcut to look like `String::toString`; it's saying "supply
    the object instance" at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If you expand it fully to an anonymous interface, it looks like this. The `x`
    parameter is made available and not closed over. Hence it being a lambda rather
    than a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oracle describe the four kinds of method reference([http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html](http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html))
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Kind** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to a static method | `ContainingClass::staticMethodName` |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to an instance method of a particular object | `ContainingObject::instanceMethodName`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to an instance method of an arbitrary object of a particular type
    | `ContainingType::methodName` |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to a constructor | `ClassName::new` |'
  prefs: []
  type: TYPE_TB
- en: But the instance method descriptions are just plain confusing. What on earth
    is an instance method of an arbitrary object of a particular type? Aren't all
    objects *of a* particular type? Why is it important that the object is *arbitrary*?
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to think of the first as an instance method of a *specific* object
    known ahead of time and the second as an instance method of an arbitrary object
    that will be *supplied* later. Interestingly, this means the first is a *closure*
    and the second is a *lambda*. One is *bound* and the other *unbound*. The distinction
    between a method reference that closes over something (a closure) and one that
    doesn't (a lambda) may be a bit academic but at least it's a more formal definition
    than Oracle's unhelpful description.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Kind** | **Syntax** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to a static method | `Class::staticMethodName` | `String::valueOf`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to an instance method of a specific object | `object::instanceMethodName`
    | `x::toString` |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to an instance method of a arbitrary object supplied later | `Class::instanceMethodName`
    | `String::toString` |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to a constructor | `ClassName::new` | `String::new` |'
  prefs: []
  type: TYPE_TB
- en: 'or as equivalent lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Kind** | **Syntax** | **As Lambda** |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to a static method | `Class::staticMethodName` | `(s) -> String.valueOf(s)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to an instance method of a specific object | `object::instanceMethodName`
    | `() -> "hello".toString()` |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to an instance method of a arbitrary object supplied later | `Class::instanceMethodName`
    | `(s) -> s.toString()` |'
  prefs: []
  type: TYPE_TB
- en: '| Reference to a constructor | `ClassName::new` | `() -> new String()` |'
  prefs: []
  type: TYPE_TB
- en: Note that the syntax for a `static` method reference looks very similar to a
    reference to an instance method of a class. The compiler determines which to use
    by going through each applicable static method and each applicable instance method.
    If it were to find a match for both, the result would be a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the whole thing as a transformation from a method reference
    to a lambda. The compiler provides the *transformation* function that takes a
    method reference and target typing and can derive a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The good news with lambdas is that they don't introduce any new scoping. Using
    variables within a lambda will refer to variables residing in the enclosing environment.
  prefs: []
  type: TYPE_NORMAL
- en: This is what's called **lexical scoping**. It means that lambdas don't introduce
    a new level of scoping at all; you can directly access fields, methods and variables
    from the enclosing scope. It's also the case for the **this** and **super** keywords.
    So we don't have to worry about the crazy nested class syntax for resolving scope.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an example. We have an example class here, with a member
    variable `i` set to the value of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the `example` method, a lambda uses a variable called `i` and multiplies
    it by two.
  prefs: []
  type: TYPE_NORMAL
- en: Because lambdas are lexically scoped, `i` simply refers to the enclosing classes'
    variable. It's value at run-time will be 5\. Using this drives home the point;
    this within a lambda is the same as without.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the `anotherExample` method below, a method parameter is used which is also
    called `i`. The usual shadowing rules kick in here and `i` will refer to the method
    parameter and not the class member variable. The method variable *shadows* the
    class variable. It's value will be whatever is passed into the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If you wanted to refer to the class variable `i` and not the parameter `i` from
    within the body, you could make the variable explicit with this. For example,
    `Supplier<Integer> function = () -> i * 2;`.
  prefs: []
  type: TYPE_NORMAL
- en: The following example has a locally scoped variable defined within the `yetAnotherExample`
    method. Remember that lambdas use their enclosing scope as their own, so in this
    case, `i` within the lambda refers to the method's variable; `i` will be `15`
    and not `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see this for yourself, you could use a method like the following
    to print out the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: So, the first method prints `10`; 5 from the class variable multiplied by two.
    The second method prints `20` as the parameter value was 10 and was multiplied
    by two and the final method prints `30` as the local method variable was set to
    15 and again multiplied by two.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical scoping means deferring to the enclosing environment. Each example had
    a different enclosing environment or scope. You saw a variable defined as a class
    member, a method parameter and locally from within a method. In all cases, the
    lambda behaved consistently and referenced the variable from these enclosing scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda scoping should be intuitive if you're already familiar with basic Java
    scoping, there's really nothing new here.
  prefs: []
  type: TYPE_NORMAL
- en: Effectively final
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java 7, any variable passed into an anonymous class instance would need to
    be made final.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the compiler actually copies all the context or *environment*
    it needs into the instance of the anonymous class. If those values were to change
    under it, unexpected side effects could happen. So Java insists that the variable
    be final to ensure it doesn't change and the inner class can operate on them safely.
    By safely, I mean without race conditions or visibility problems between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an example. To start with, we'll use Java 7 and create
    a method called `filter` that takes a list of people and a predicate. We'll create
    a temporary list to contain any matches we find then enumerate each element testing
    to see if the predicate holds true for each person. If the test is positive, we'll
    add them to the temporary list before returning all matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Then we'll create a method that uses this to find all the people in a list that
    are eligible for retirement. We set a retirement age variable and then call the
    `filter` method with an arbitrary list of people and a new anonymous instance
    of a `Predicate` interface.
  prefs: []
  type: TYPE_NORMAL
- en: We'll implement this to return true if a person's age is greater than or equal
    to the retirement age variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: If you try and compile this, you'll get a compiler failure when accessing the
    variable. This is because the variable isn't final. We'd need to add `final` to
    make it compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passing the environment into an anonymous inner class like this is an example
    of a closure. The environment is what a closure "closes" over; it has to capture
    the variables it needs to do its job. The Java compiler achieves this using the
    copy trick rather than try and manage multiple changes to the same variable. In
    the context of closures, this is called *variable capture*.
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 introduced the idea of "effectively final" which means that if the compiler
    can work out that a particular variable is *never* changed, it can be used where
    ever a final variable would have be used. It interprets it as "effectively" final.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, if we switch to Java 8 and drop the `final` keyword. Things
    still compile. No need to make the variable final. Java knows that the variable
    doesn't change so it makes it effectively final.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it still compiles if you were to make it `final`.
  prefs: []
  type: TYPE_NORMAL
- en: But how about if we try and modify the variable after we've initialized it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The compiler spots the change and can no longer treat the variable as effectively
    final. We get the original compilation error asking us to make it final. Conversely,
    if adding the `final` keyword to a variable declaration doesn't cause a compiler
    error, then the variable is effectively final.
  prefs: []
  type: TYPE_NORMAL
- en: I've been demonstrating the point here with an anonymous class examples because
    the idea of effectively final isn't something specific to lambdas. It is of course
    applicable to lambdas though. You can convert this anonymous class above into
    a lambda and nothing changes. There's still no need to make the variable final.
  prefs: []
  type: TYPE_NORMAL
- en: Circumventing final
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can still get round the safety net by passing in final objects or arrays
    and then change their internals in your lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, taking our list of people, lets say we want to sum all their ages.
    We could create a method to loop and sum like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'where the sum count is maintained as the list is enumerated. As an alternative,
    we could try and abstract the looping behavior and pass in a function to be applied
    to each element. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'and to achieve the summing behavior, all we''d need to do is create a function
    that can sum. You could do this using an anonymous class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Where the functions method takes an integer and returns an integer. In the implementation,
    the sum variable is a class member variable and is mutated each time the function
    is applied. This kind of mutation is generally bad form when it comes to functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nether the less, we can pass this into our `forEach` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: and we'd get the sum of all peoples ages. This works because we're using the
    same instance of the function so the `sum` variable is reused and mutated during
    each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The bad news is that we can't convert this into a lambda directly; there's no
    equivalent to a member variable with lambdas, so there's nowhere to put the `sum`
    variable other than outside of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: but this highlights that the variable isn't effectively final (it's changed
    in the lambda's body) and so it must be made final.
  prefs: []
  type: TYPE_NORMAL
- en: But if we make it final
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: we can no longer modify it in the body! It's a chicken and egg situation.
  prefs: []
  type: TYPE_NORMAL
- en: The trick around this is to use a object or an array; it's reference can remain
    final but it's internals can be modified
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The array reference is indeed final here, but we can modify the array contents
    without reassigning the reference. However, this is generally bad form as it opens
    up to all the safety issues we talked about earlier. I mention it for illustration
    purposes but don't recommend you do this kind of thing often. It's generally better
    not to create functions with side effects and you can avoid the issues completely,
    if you use a more functional approach. A more idiomatic way to do this kind of
    summing is to use what's called a *fold* or in the Java vernacular *reduce*.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's no new syntax for exception handling in lambdas. Exceptions thrown in
    a lambda are propagated to the caller, just as you'd expect with a regular method
    call. There's nothing special about calling lambdas or handling their exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some subtleties that you need to be aware of. Firstly, as
    a caller of a lambda, you are potentially unaware of what exceptions might be
    thrown, if any and secondly, as the author of a lambda, you're potentially unaware
    what context your lambda will be run in.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a lambda, you typically give up responsibility of how that lambda
    will be executed to the method that you pass it to. For all you know, your lambda
    may be run in parallel or at some point in the future and so any exception you
    throw may not get handled as you might expect. You can't rely on exception handling
    as a way to control your program's flow.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, lets write some code to call two things, one after the
    other. We'll use `Runnable` as a convenient lambda type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If the first call to run were to throw an exception, the method would terminate
    and the second method would never be called. The caller is left to deal the exception.
    If we use this method to transfer money between two bank accounts, we might write
    two lambdas. One for the debit action and one for the credit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'we could then call our `runInSequence` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'any exceptions could be caught and dealt with by using a `try`/`catch` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the thing. As an author of the lambdas, I potentially have no idea
    how `runInSequence` is implemented. It may well be implemented to run asynchronously
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In which case any exception in the first call would terminate the thread, the
    exception would disappear to the default exception handler and our original client
    code wouldn't get the chance to deal with the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Using a callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incidentally, one way round the specific problem with raising an exception
    on a different thread than the caller can be addressed with a callback function.
    Firstly, you''d defend against exceptions in the `runInSequence` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then introduce an exception handler which can be called in the event of an
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Consumer is a functional interface (new in Java 8) that in this case takes the
    exception as an argument to it's `accept` method.
  prefs: []
  type: TYPE_NORMAL
- en: When we wire this up to the client, we can pass in a callback lambda to handle
    any exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This is a good example of deferred execution and so has it's own foibles. The
    exception handler method may (or may not) get executed at some later point in
    time. The `nonBlockingTransfer` method will have finished and the bank accounts
    themselves may be in some other state by the time it fires. You can't rely on
    the exception handler being called when it's convenient for you; we've opened
    up a whole can of concurrency worms.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with exceptions when writing lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at dealing with exceptions from the perspective of a lambda author,
    someone writing lambdas. After this, we'll look at dealing with exceptions when
    calling lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Lets look at it as if we wanted to implement the `transfer` method using lambdas
    but this time wanted to reuse an existing library that supplies the `runInSequence`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, let's take a look at the `BankAccount` class. You'll notice
    that this time, the `debit` and `credit` methods both throw a checked exception;
    `InsufficientFundsException`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Let's recreate the `transfer` method. We'll try to create the debit and credit
    lambdas and pass these into the `runInSequence` method. Remember that the `runInSequence`
    method was written by some library author and we can't see or modify it's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The debit and credit both throw a checked exception, so this time, you can see
    a compiler error. It makes no difference if we add this to the method signature;
    the exception would happen inside the lambda. Remember I said exceptions in lambdas
    are propagated to the caller? In our case, this will be the `runInSequence` method
    and not the point we define the lambda. The two aren't communicating between themselves
    that there could be an exception raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'So if we can''t force a checked exception to be *transparent* between the lambda
    and the caller, one option is to wrap the checked exception as a runtime exception
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: That gets us out of the compilation error but it's not the full story yet. It's
    very verbose and we still have to catch and deal with, what's now a runtime exception,
    around the call to `runInSequence`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: There's still one or two niggles though; we're throwing and catching a `RuntimeException`
    which is perhaps a little loose. We don't really know what other exceptions, if
    any, might be thrown in the `runInSequence` method. Perhaps it's better to be
    more explicit. Let's create a new sub-type of `RuntimeException` and use that
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: After we've modified the original lambda to throw the new exception, we can
    restrict the catch to deal with only exceptions we know about; namely the `InsufficientFundsRuntimeException`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement some kind of balance check and rollback functionality,
    confident that we understand all the scenarios that can cause it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The trouble with all this, is that the code has more exception handling boilerplate
    than actual business logic. Lambdas are supposed to make things less verbose but
    this is just full of noise. We can make things better if we generalize the wrapping
    of checked exceptions to runtime equivalents. We could create a functional interface
    that captures an exception type on the signature using generics.
  prefs: []
  type: TYPE_NORMAL
- en: Let's name it `Callable` and its single method; `call`. Don't confuse this with
    the class of the same name in the JDK; we're creating a new class to illustrate
    dealing with exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We'll change the old implementation of transfer and create lambdas to match
    the "shape" of the new functional interface. I've left off the type for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Remember from the type inference section that Java would be able to see this
    as a type of `Callable` as it has no parameters as does `Callable`, it has the
    same return type (none) and throws an exception of the same type as the interface.
    We just need to give the compiler a hint, so we can assign this to an instance
    of a `Callable`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Creating the lambdas like this doesn't cause a compilation error as the functional
    interface declares that it could be thrown. It doesn't need to warn us at the
    point we create the lambda, as the signature of the functional method will cause
    the compiler to error if required when we actually try and call it. Just like
    a regular method.
  prefs: []
  type: TYPE_NORMAL
- en: If we try and pass them into the `runInSequence` method, we'll get a compiler
    error though.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambdas are of the wrong type. We still need a lambda of type `Runnable`.
    We''ll have to write a method that can convert from a `Callable` to a `Runnable`.
    At the same time, we''ll wrap the checked exception to a run time one. Something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to do is wire it in for our lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Once we put the exception handling back in we're back to a more concise method
    body and have dealt with the potential exceptions in the same way as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The downside is this isn't a totally generalized solution; we'd still have to
    create variations of the unchecked method for different functions. We've also
    just hidden the verbose syntax away. The verbosity is still there its just been
    moved. Yes, we've got some reuse out of it but if exception handling were transparent
    or we didn't have checked exceptions, we wouldn't need to brush the issue under
    the carpet quite so much.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth pointing out that we'd probably end up doing something similar if
    we were in Java 7 and using anonymous classes instead of lambdas. A lot of this
    stuff can still be done pre-Java 8 and you'll end up creating helper methods to
    push the verbosity to one side.
  prefs: []
  type: TYPE_NORMAL
- en: It's certainly the case that lambdas offer more concise representations for
    small anonymous pieces of functionality but because of Java's checked exception
    model, dealing with exceptions in lambdas will often cause all the same verbosity
    problems we had before.
  prefs: []
  type: TYPE_NORMAL
- en: As a caller (dealing with exceptions when calling lambdas)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen things from the perspective of writing lambdas, now lets have a look
    at things when calling lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that now we're writing the library that offers the `runInSequence`
    method. We have more control this time and aren't limited to using `Runnable`
    as a lambda type. Because we don't want to force our clients to jump through hoops
    dealing with exceptions in their lambdas (or wrap them as runtime exceptions),
    we'll provide a functional interface that declares that a checked exception might
    be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call it `FinancialTransfer` with a `transfer` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: We're saying that whenever a banking transaction occurs, there's the possibility
    that insufficient funds are available. Then when we implement our `runInSequence`
    method, we accept lambdas of this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This means that when clients use the method, they're not forced to deal with
    exceptions within their lambdas. For example, writing a method like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This time there is no compiler error when creating the lambdas. There's no need
    to wrap the exceptions from `BankAccount` methods as runtime exceptions; the functional
    interface has already declared the exception. However, `runInSequence` would now
    throw a checked exception, so it's explicit that the client has to deal with the
    possibility and you'll see a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'So we need to wrap the call in a `try`/`catch` to make the compiler happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The end result is something like we saw previously but without the need for
    the unchecked method. As a library developer, we've made it easier for clients
    to integrate with our code.
  prefs: []
  type: TYPE_NORMAL
- en: But what about if we try something more exotic? Let's make the `runInSequence`
    method asynchronous again. There's no need to throw the exception from the method
    signature as it wouldn't propagate to the caller if it were thrown from a different
    thread. So this version of the `runInSequence` method doesn't include the throws
    clause and the `transfer` method is no longer forced to deal with it. However,
    the calls to `.transfer` will still throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: With the compiler errors still in the `runInSequence` method, we need another
    way to handle the exception. One technique is to pass in a function that will
    be called in the event of an exception. We can use this lambda to bridge the code
    running asynchronously back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we'll add the `catch` block back in and pass in a functional
    interface to use as the exception handler. I'll use the `Consumer` interface here,
    it's new in Java 8 and part of the `java.util.function` package. We then call
    the interface method in the catch block, passing in the cause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: To call it, we need to update the `transfer` method to pass in a lambda for
    the callback. The parameter, exception below, will be whatever is passed into
    the `accept` method in `runInSequence`. It will be an instance of `InsufficientFundsException`
    and the client can deal with it however they chose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: There we are. We've provided the client to our library with an alternative exception
    handling mechanism rather than forcing them to catch exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We've internalized the exception handling into the library code. It's a good
    example of deferred execution; should there be an exception, the client doesn't
    necessarily know when his exception handler would get invoked. For example, as
    we're running in another thread, the bank accounts themselves may have be altered
    by the time it executes. Again it highlights that using exceptions to control
    your program's flow is a flawed approach. You can't rely on the exception handler
    being called when it's convenient for you.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas vs closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terms *closure* and *lambda* are often used interchangeably but they are
    actually distinct. In this section we'll take a look at the differences so you
    can be clear about which is which.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is a table showing the release dates for each major version of Java.
    Java 5.0 came along in 2004 and included the first major language changes including
    things like generics support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambdas vs closures](img/timeline.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Around 2008 to 2010 there was a lot of work going on to introduce closures to
    Java. It was due to go in to Java 7 but didn't quite make it in time. Instead
    it evolved into lambda support in Java 8\. Unfortunately, around that time, people
    used the term "closures" and "lambdas" interchangeably and so it's been a little
    confusing for the Java community since. In fact, there's still a project page
    on the OpenJDK site for [closures](http://openjdk.java.net/projects/closures/) and
    one for [lambdas](http://openjdk.java.net/projects/lambda/).
  prefs: []
  type: TYPE_NORMAL
- en: From the OpenJDK project's perspective, they really should have been using "lambda"
    consistently from the start. In fact, the OpenJDK got it so wrong, they ignored
    the fact that Java *has had* closure support since version 1.1!
  prefs: []
  type: TYPE_NORMAL
- en: I'm being slightly pedantic here as although there are technical differences
    between closures and lambdas, the goals of the two projects were to achieve the
    same thing, even if they used the terminology inconsistently.
  prefs: []
  type: TYPE_NORMAL
- en: So what is the difference between lambdas and closures? Basically, a closure
    *is a* type of lambda but a lambda isn't necessarily a closure.
  prefs: []
  type: TYPE_NORMAL
- en: Basic differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like a lambda, a closure is effectively an anonymous block of functionality,
    but there are some important distinctions. A closure depends on external values
    (not just it's arguments) whereas a lambda depends only on it's arguments. A closure
    is said to "close over" the environment it requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: is a lambda, but this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: is a closure.
  prefs: []
  type: TYPE_NORMAL
- en: They both return a boolean indicating if some server is up but one uses it's
    argument and the other must get the variable from somewhere else. Both are lambdas;
    in the general sense, they are both anonymous blocks of functionality and in the
    Java language sense, they both use the new lambda syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The first example refers to a server variable passed into the lambda as an argument
    whereas the second example (the closure) gets the server variable from somewhere
    else; that is the environment. To get the instance of the variable, the lambda
    has to "close over" the environment or capture the value of server. We've seen
    this in action when we talked about `effectively final` before.
  prefs: []
  type: TYPE_NORMAL
- en: Let's expand the example to see things more clearly. Firstly, we'll create a
    method in a static class to perform a naive poll and wait. It'll check a functional
    interface on each poll to see if some condition has been met.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: We use `Predicate` (another new `java.util` interface) as our functional interface
    and test it, pausing for a short while if the condition is not satisfied. We can
    call this method with a simple lambda that checks if some HTTP server is running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The server parameter is supplied by our `waitFor` method and will be the instance
    of `HttpServer` we've just defined. It's a lambda as the compiler doesn't need
    to capture the server variable as we supply it manually at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Incidentally, we might have been able to use a method reference...  `waitFor(new
    HttpServer(), HttpServer::isRunning);`
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we re-implement this as a closure, it would look like this. Firstly,
    we have to add another `waitFor` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This time, with a simpler signature. We pass in a functional interface that
    requires no parameters. The `Condition` interface has a simple `isSatisfied` method
    with no argument which implies that we have to supply any values an implementation
    might need. It's already hinting that usages of it may result in closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using it, we''d write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The server instance is not passed as a parameter to the lambda here but accessed
    from the enclosing scope. We've defined the variable and the lambda uses it directly.
    This variable has to be captured, or copied by the compiler. The lambda "closes
    over" the server variable.
  prefs: []
  type: TYPE_NORMAL
- en: This expression to "close over" comes from the idea that a lambda expression
    with open bindings (or free variables) have been closed by (or bound in) the lexical
    environment or scope. The result is a *closed expression*. There are no unbound
    variables. To be more precise, closures close over *values* not *variables*.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen a closure being used to provide an anonymous block of functionality
    and the difference between an equivalent lambda but, there are still more useful
    distinctions we can make.
  prefs: []
  type: TYPE_NORMAL
- en: Other differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An anonymous function, is a function literal without a name, whilst a closure
    is an instance of a function. By definition, a lambda has no instance variables;
    it's not an instance. It's variables are supplied as arguments. A closure however,
    has instance's variables which are provided when the instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, a lambda will generally be more efficient than a closure
    as it only needs to evaluated once. Once you have the function, you can re-use
    it. As a closure closes over something not in it's local environment, it has to
    be evaluated every time it's called. An instance has to be newed up each time
    it's used.
  prefs: []
  type: TYPE_NORMAL
- en: All the issues we looked at in the functions vs classes section are relevant
    here too. There may be memory considerations to using closures over lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've talked about a lot here so let's summarize the differences briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas are just anonymous functions, similar to static methods in Java. Just
    like static methods, they can't reference variables outside their scope except
    for their arguments. A special type of lambda, called a closure, can capture variables
    outside their scope (or close over them) so they can use external variables or
    their arguments. So the simple rule is if a lambda uses a variable from outside
    it's scope, it's also a closure.
  prefs: []
  type: TYPE_NORMAL
- en: Closures can be seen as instances of functions. Which is kind of an odd concept
    for Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: A great example is the conventional anonymous class that we would pass around
    if we didn't have the new lambda syntax. These can "close over" variables and
    so are themselves closures. So we've had closure support in Java since 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at this example. The server variable has to be closed over by the
    compiler to be used in the anonymous instance of the `Condition` interface. This
    is both an anonymous class instance and a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Lambda's aren't always closures, but closures are always lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we'll explore how the compiler output differs when you compile
    anonymous classes to when you compile lambdas. First we'll remind ourselves about
    java bytecode and how to read it. Then we'll look at both anonymous classes and
    lambdas when they capture variables and when they don't. We'll compare pre-Java
    8 closures with lambdas and explore how lambdas are *not* just syntactic sugar
    but produce very different bytecode from the traditional approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, let's recap on what we know about bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: To get from source code to machine runnable code. The Java compiler produces
    bytecode. This is either interpreted by the JVM or re-compiled by the Just-in-time
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: When it's interpreted, the bytecode is turned into machine code on the fly and
    executed. This happens each time the bytecode is encountered but he JVM.
  prefs: []
  type: TYPE_NORMAL
- en: When it's Just-in-time compiled, the JVM compiles it directly into machine code
    the first time it's encountered and then goes on to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Both happen at run-time but Just-in-time compilation offer lots of optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: So, Java bytecode is the intermediate representation between source code and
    machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a quick side bar: Java''s JIT compiler has enjoyed a great reputation over
    the years. But going back full circle to our introduction, it was John McCarthy
    that first wrote about JIT compilation way back in 1960\. So it''s interesting
    to think that it''s not just lambda support that was influenced by LISP. ([Aycock
    2003, 2\. JIT Compilation Techniques, 2.1 Genesis, p. 98](http://user.it.uu.se/~kostis/Teaching/KT2-04/jit_survey.pdf)).'
  prefs: []
  type: TYPE_NORMAL
- en: The bytecode is the instruction set of the JVM. As it's name suggests, bytecode
    consists of single-byte instructions (called *opcodes*) along with associated
    bytes for parameters. There are therefore a possible 256 opcodes available although
    only about 200 are actually used.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM uses a [stack based computation model](http://en.wikipedia.org/wiki/Model_of_computation),
    if we want to increment a number, we have to do it using the stack. All instructions
    or opcodes work against the stack.
  prefs: []
  type: TYPE_NORMAL
- en: So for example, 5 + 1 becomes 5 1 + where 5 is pushed to the stack,
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/Push5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 1 is pushed then...
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/Push1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: the `+` operator is applied. Plus would pop the top two frames, add the numbers
    together and push the result back onto the stack. The result would look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/iadd6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each opcode works against the stack like this so we can translate our example
    into a sequence of Java bytecodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/Push5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `push 5` opcode becomes `iconst_5`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/iconst1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `push 1` opcode becomes `iconst_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/iconst_1_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and `add` becomes `iadd`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bytecode recap](img/iadd6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `iconst_x` opcode and `iadd` opcode are examples of opcodes. Opcodes often
    have prefixes and/or suffices to indicate the types they work on, `i` in these
    examples refers to integer, `x` is an opcode specific suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can group the opcodes into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Group** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| Stack manipulation | `aload_n`, `istore`, `swap`, `dup2` |'
  prefs: []
  type: TYPE_TB
- en: '| Control flow instructions | `goto`, `ifeq`, `iflt` |'
  prefs: []
  type: TYPE_TB
- en: '| Object interactions | `new`, `invokespecial`, `areturn` |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic, logic and type conversion | `iadd`, `fcmpl`, `i2b` |'
  prefs: []
  type: TYPE_TB
- en: Instructions concerned with stack manipulation, like `aload` and `istore`.
  prefs: []
  type: TYPE_NORMAL
- en: To control program flow with things like if and while, we use opcodes like `goto`
    and if equal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects and accessing methods use codes like `new` and `invokespecial`.
    We'll be particularly interested in this group when we look at the different opcodes
    used to invoke lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: The last group is about arithmetic, logic and type conversion and includes codes
    like `iadd`, float compare long (`fcmpl`) and integer to byte (`i2b`).
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opcodes will often use parameters, these look a little cryptic in the bytecode
    as they're usually referenced via lookup tables. Internally, Java uses what's
    called *descriptors* to describe these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: They describe types and signatures using a specific grammar you'll see throughout
    the bytecode. You'll often see the same grammar used in compiler or debug output,
    so it's useful to recap it here.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of a method signature descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: It's describing the constructor of a class called `$1`, which we happen to know
    is the JVM's name for the first anonymous class instance within another class.
    In this case `Example`. So we've got a constructor of an anonymous class that
    takes two parameters, an instance of the outer class `com.foo.Example` and an
    instance of `com.foo.Server`.
  prefs: []
  type: TYPE_NORMAL
- en: Being a constructor, the method doesn't return anything. The `V` symbol represents
    void.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at breakdown of the descriptor syntax below. If you see an uppercase
    `Z` in a descriptor, it's referring to a boolean, an uppercase `B` a byte and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Descriptors](img/descriptors.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A couple of ones to mention:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are described with an uppercase `L` followed by the fully qualified
    class name, followed by a semi-colon. The class name is separated with slashes
    rather than the dots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And arrays are described using an opening square bracket followed by a type
    from the list. No closing bracket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a method signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take the following method signature and turn it into a method descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The method returns a `long`, so we describe the fact that it is a method with
    brackets and that it returns a `long` with a uppercase `J`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is of type `int`, so we use an uppercase `I`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The next argument is an object, so we use `L` to describe it's an object, fully
    qualify the name and close it with a semi-colon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The last argument is an integer array so we drop in the array syntax followed
    by `int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: and we're done. A JVM method descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lets have a look at the bytecode produced for some examples.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look at the bytecode for four distinct blocks of functionality
    based on the example we looked at in `lambdas vs closures` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll explore:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple anonymous class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An anonymous class closing over some variable (an old style closure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lambda with no arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lambda with arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lambda closing over some variable (a new style closure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The example bytecode was generated using the `javap` command line tool. Only
    partial bytecode listings are shown in this section, for full source and bytecode
    listings, see `Appendix A`. Also, fully qualified class names have been shortened
    to better fit on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first example is a simple anonymous class instance passed into our `waitFor`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the bytecode below, the thing to notice is that an instance of
    the anonymous class is newed up at line 6\. The `#2` refers to a lookup, the result
    of which is shown in the comment. So it uses the `new` opcode with whatever is
    at `#2` in the constant pool, this happens to be the anonymous class `Example$1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Once created, the constructor is called using `invokespecial` on line 9\. This
    opcode is used to call constructor methods, private methods and accessible methods
    of a super class. You might notice the method descriptor includes a reference
    to `Example1`. All anonymous class instances have this implicit reference to the
    parent class.
  prefs: []
  type: TYPE_NORMAL
- en: The next step uses `invokestatic` to call our `waitFor` method passing in the
    anonymous class on line 10\. The  `invokestatic` opcode is used to call static
    methods and is very fast as it can direct dial a method rather than figure out
    which to call as would be the case in an object hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Example 2` class is another anonymous class but this time it closes over
    the server variable. It''s an old style closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The bytecode is similar to the previous except that an instance of the `Server`
    class is newed up (at line 3.) and it's constructor called at line 5\. The instance
    of the anonymous class `$1` is still constructed with `invokespecial` (at line
    11.) but this time it takes the instance of `Server` as an argument as well as
    the instance of the calling class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To close over the server variable, it''s passed directly into the anonymous
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Example 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Example 3` class uses a Java lambda with our `waitFor` method. The lambda
    doesn't do anything other than return true. It's equivalent to example 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The bytecode is super simple this time. It uses the `invokedynamic` opcode to
    create the lambda at line 3 which is then passed to the `invokestatic` opcode
    on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The descriptor for the `invokedynamic` call is targeting the `isSatisfied` method
    on the `Condition` interface (line 3.).
  prefs: []
  type: TYPE_NORMAL
- en: What we're not seeing here is the mechanics of `invokedynamic`. The `invokedynamic`
    opcode is a new opcode to Java 7, it was intended to provide better support for
    dynamic languages on the JVM. It does this by not linking the types to methods
    until run-time. The other "invoke" opcodes all resolve types at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: For lambdas, this means that placeholder method invocations can be put into
    the bytecode like we've just seen and working out the implementation can be done
    on the JVM at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at a more verbose bytecode that includes the constant pool we can
    dereference the lookups. For example, if we look up number 2, we can see it references
    `#0` and `#26`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The constant `0` is in a special lookup table for bootstrapping methods (line
    6). It refers to a static method call to the JDK `LambdaMetafactory` to create
    the lambda. This is where the heavy lifting goes on. All the target type inference
    to adapt types and any partial argument evaluation goes on here.
  prefs: []
  type: TYPE_NORMAL
- en: The actual lambda is shown as a method handle called `lambda$example$25` (line
    12) with no arguments, returning a boolean. It's invoked using `invokestatic`
    which shows that it's accessed as a genuine function; there's no object associated
    with it. There's also no implicit reference to a containing class unlike the anonymous
    examples before.
  prefs: []
  type: TYPE_NORMAL
- en: It's passed into the `LambdaMetafactory` and we know it's a method handle by
    looking it up in the constant pool. The number of the lambda is compiler assigned
    and just increments from zero for each lambda required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Example 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Example 4` class is another lambda but this time it takes an instance of
    `Server` as an argument. It's equivalent in functionality to example 2 but it
    doesn't close over the variable; it's not a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Just like example 2, the bytecode has to create the instance of server but this
    time, the `invokedynamic` opcode references the `test` method of type `Predicate`.
    If we were to follow the reference (`#4`) to the boostrap methods table, we would
    see the actual lambda requires an argument of type `HttpServer` and returns a
    `Z` which is a primitive boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: So the call to the lambda is still a static method call like before but this
    time takes the variable as a parameter when it's invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4 (with method reference)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interestingly, if we use a method reference instead, the functionality is exactly
    the same but we get different bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Via the call to `LambdaMetafactory` when the final execution occurs, `method_reference`
    results in a call to `invokevirtual` rather than `invokestatic`. The `invokevirtual`
    opcode is used to call public, protected an package protected methods so it implies
    an instance is required. The instance is supplied to the `metafactory` method
    and no lambda (or static function) is needed at all; there are no `lambda$` in
    this bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Example 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, example 5 uses a lambda but closes over the server instance. It's equivalent
    to example 2 and is a new style closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: It goes through the basics in the same way as the other lambdas but if we lookup
    the `metafactory` method in the bootstrap methods table, you'll notice that this
    time, the lambda's method handle has an argument of type `Server`. It's invoked
    using `invokestatic` (line 9) and the variable is passed directly into the lambda
    at invocation time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: So like the anonymous class in example 2, an argument is added by the compiler
    to capture the term although this time, it's a method argument rather than a constructor
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how using an anonymous class will create a new instance and call it's
    constructor with `invokespecial`.
  prefs: []
  type: TYPE_NORMAL
- en: We saw anonymous classes that close over variables have an extra argument on
    their constructor to capture that variable.
  prefs: []
  type: TYPE_NORMAL
- en: And we saw how Java lambdas use the `invokedynamic` instruction to defer binding
    of the types and that a special `lambda$` method handle is used to actually represent
    the lambda. This method handle has no arguments in this case and is invoked using
    `invokestatic` making it a genuine function.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda was created by the `LambdaMetafactory` class which itself was the
    target of the `invokedynamic` call.
  prefs: []
  type: TYPE_NORMAL
- en: When a lambda has arguments, we saw how the `LambdaMetafactory` describes the
    argument to be passed into the lambda. The `invokestatic` opcode is used to execute
    the lambda like before. But we also had a look at a method reference used in-lieu
    of a lambda. In this case, no `lambda$` method handle was created and `invokevirtual`
    was used to call the method directly.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at a lambda that closes over a variable. This one creates
    an argument on the `lambda$` method handle and again is called with `invokestatic`.
  prefs: []
  type: TYPE_NORMAL
