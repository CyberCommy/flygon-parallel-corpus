- en: Making the Move – Design, Plan, and Execute
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移 - 设计、计划和执行
- en: As web services get more and more complex, and software service companies grow
    in size, we require new ways of working to adapt and increase the speed of change,
    while setting a high quality standard. Microservices architecture has emerged
    as one of the best tools to control big software systems, enabled by new tools
    such as containers and orchestrators. We will start by presenting the differences
    between the traditional monolith architecture and the microservices architecture,
    as well as the advantages of moving to the latter. We will cover how to structure
    an architecture migration and how to plan to succeed in this difficult process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络服务变得越来越复杂，软件服务公司规模不断增长，我们需要新的工作方式来适应并加快变化速度，同时确保高质量标准。微服务架构已经成为控制大型软件系统的最佳工具之一，得益于容器和编排器等新工具的支持。我们将首先介绍传统单体架构和微服务架构之间的区别，以及迁移到后者的优势。我们将介绍如何构建架构迁移以及如何计划成功完成这一困难过程。
- en: In this book, we will deal with web server services, though some of the ideas
    can be used for other kinds of software applications, obviously by adapting them.
    The monolith/microservice architectures have some similarities with the monolithic/microkernel
    discussions in operating system design, including the famous debate ([https://www.oreilly.com/openbook/opensources/book/appa.html](https://www.oreilly.com/openbook/opensources/book/appa.html)) between
    Linus Torvalds and Andrew S. Tanenbaum, back in 1992\. This chapter is relatively
    agnostic about tools, while the following chapters will present specific ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将处理Web服务器服务，尽管一些想法也可以用于其他类型的软件应用，显然需要进行调整。单体/微服务架构与操作系统设计中的单体/微内核讨论有一些相似之处，包括1992年Linus
    Torvalds和Andrew S. Tanenbaum之间的著名辩论（[https://www.oreilly.com/openbook/opensources/book/appa.html](https://www.oreilly.com/openbook/opensources/book/appa.html)）。本章对工具相对中立，而接下来的章节将介绍具体的工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The traditional monolith approach and its problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统单体方法及其问题
- en: The characteristics of a microservices approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务方法的特点
- en: Parallel deployment and development speed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行部署和开发速度
- en: Challenges and red flags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战和红旗
- en: Analyzing the current system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析当前系统
- en: Preparing and adapting by measuring usage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测量使用情况进行准备和调整
- en: Strategic planning to break the monolith
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破单体的战略规划
- en: Executing the move
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行迁移
- en: At the end of the chapter, you'll be familiar with the basic concepts we will
    be using throughout the book, different strategies for how to proceed with and
    structure work during the migration to microservices, and a practical example
    that we will be working on in the remaining chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将熟悉我们将在整本书中使用的基本概念，以及在迁移到微服务过程中如何进行和组织工作的不同策略，以及我们将在剩余章节中进行的实际示例。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not focus on specific technologies, going for a more agnostic
    approach. We will discuss a Python Django application for our monolith example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不专注于特定技术，而是采用更中立的方法。我们将讨论一个Python Django应用程序作为我们单体示例。
- en: 'The monolith example can be found at: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith).
    Installation and running instructions can be found in its `README.md` file.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单体示例可以在以下位置找到：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith)。安装和运行说明可以在其`README.md`文件中找到。
- en: The traditional monolith approach and its problems
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的单体方法及其问题
- en: 'The traditional approach to the software when developing a system has been
    to create a monolith. This is a fancy word to say *a single element, containing
    everything*, and it is the way virtually every project starts. In the context
    of web applications, that means creating deployable code that can be replicated
    so that requests can be directed to any of the deployed copies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发系统时，传统的软件方法是创建一个单体。这是一个花哨的词，意思是*一个包含所有内容的单一元素*，这几乎是每个项目开始的方式。在Web应用程序的上下文中，这意味着创建可部署的代码，以便可以复制请求以指向任何已部署的副本。
- en: '![](assets/a6a73149-82f7-4880-9121-7b110bda40ad.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a6a73149-82f7-4880-9121-7b110bda40ad.png)'
- en: After all, every project will start off small. Making strict divisions early
    on is inconvenient and even doesn't make sense. A newly created project is small
    and probably handled by a single developer. While the design can fit in the head
    of a few people, making strict boundaries between parts of the system is counterproductive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，每个项目都会从小处开始。在早期进行严格的划分是不方便的，甚至没有意义。一个新创建的项目很小，可能由单个开发人员处理。虽然设计可以适应少数人的头脑，但在系统的各个部分之间建立严格的界限是适得其反的。
- en: There are a lot of options for running a web service, but one will typically
    consist of one or more servers (physical boxes, virtual machines, and cloud instances
    such as EC2 and more)  running a  web server application (such as NGINX or Apache)
    to direct requests directed to HTTP port `80` or HTTPS port `443` toward one or
    more Python workers (normally, through the WSGI protocol), run by `mod_wsgi`—[https://github.com/GrahamDumpleton/mod_wsgi](https://github.com/GrahamDumpleton/mod_wsgi) (Apache
    only), uWSGI, GNUnicorn, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Web服务有很多选择，但通常包括一个或多个服务器（物理服务器、虚拟机和云实例，如EC2等）运行Web服务器应用程序（如NGINX或Apache），以将请求指向HTTP端口`80`或HTTPS端口`443`，指向一个或多个Python工作进程（通常通过WSGI协议），由`mod_wsgi`（仅限Apache）、uWSGI、GNUnicorn等运行。
- en: If more than one server is used, there will be a load balancer to spread the
    load among them. We'll talk about them later in this chapter. The server (or load
    balancer) needs to be accessible on the internet, so it will have a dedicated
    DNS and a public IP address.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用多台服务器，将会有一个负载均衡器来在它们之间分配负载。我们将在本章后面讨论它们。服务器（或负载均衡器）需要在互联网上可访问，因此它将有专用的DNS和公共IP地址。
- en: 'In other programming languages, the structure will be similar: a frontend web
    server that exposes the port in HTTP/HTTPS, and a backend that runs the monolith
    code in a dedicated web worker.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，结构会类似：一个公开HTTP/HTTPS端口的前端Web服务器，以及在专用Web工作进程中运行单体代码的后端。
- en: But things change, successful software grows and, after some time, having a
    big ball of code is maybe not the best way of structuring a big project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情会改变，成功的软件会增长，一段时间后，拥有一大堆代码可能不是构建大型项目的最佳方式。
- en: Monoliths can have, in any case, internal structure, meaning they don't necessarily
    get into the realms of spaghetti code. It may be perfectly structured code. What
    defines a monolith is the requirement to deploy the system as a whole, without
    being able to make partial deployments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单体可能具有内部结构，这意味着它们不一定会陷入意大利面代码的境地。它可能是完全结构化的代码。定义单体的是需要将系统作为一个整体部署，而无法进行部分部署。
- en: Spaghetti code is a common way of referring to code that lacks any structure
    and is difficult to read and follow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码是指缺乏任何结构且难以阅读和跟踪的代码的常见说法。
- en: 'As the monolith grows, some of its limitations will start to show up:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着单体应用的增长，它的一些局限性将开始显现：
- en: '**The code will increase in size**: Without strict boundaries between modules,
    developers will start having problems understanding the whole code base. While
    good practices can help, the complexity naturally tends to increase, making it
    more difficult to change the code in certain ways and increasing subtle bugs.
    Running all tests will become slow, decreasing the speed of any Continuous Integration
    system.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将增加体积：没有模块之间的严格边界，开发人员将开始遇到理解整个代码库的问题。尽管良好的实践可以帮助，但复杂性自然倾向于增加，使得在某些方面更改代码变得更加困难，并增加微妙的错误。运行所有测试将变得缓慢，降低任何持续集成系统的速度。
- en: '**Inefficient utilization of resources**: Each individual deployed web worker
    will require all the resources required for the whole system to work, for example,
    the maximum amount of memory for any kind of request, even if a request that demands
    a lot of memory is rare and just a couple of workers will be sufficient. The same
    may happen with the CPU. If the monolith connects to a database, each individual
    worker will require a connection to it, whether that''s used regularly or not,
    and so on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用效率低下：每个部署的网络工作者都需要整个系统工作所需的所有资源，例如，任何类型的请求所需的最大内存，即使需要大量内存的请求很少，只需几个工作者就足够了。CPU也可能出现相同的情况。如果单体连接到数据库，每个工作者都需要连接到它，无论是否经常使用，依此类推。
- en: '**Issues with development scalability**: Even if the system is perfectly designed
    to be horizontally scalable (unlimited new workers can be added), as the system
    grows and the development team grows, development will be more and more difficult
    without stepping on each other''s toes. A small team can coordinate easily, but
    once several teams are working on the same code base, the probability of clashing
    will increase. Imposing boundaries for teams in terms of ownership and responsibility
    can also become blurry unless strict discipline is enforced. In any case, teams
    will need to be actively coordinated, which reduces their independence and speed.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可扩展性问题：即使系统被设计为水平扩展（可以添加无限数量的新工作者），随着系统和开发团队的增长，开发将变得越来越困难，而不会相互干扰。一个小团队可以轻松协调，但一旦有几个团队在同一个代码库上工作，冲突的可能性就会增加。除非严格执行纪律，否则对团队在所有权和责任方面施加限制也可能变得模糊。无论如何，团队都需要积极协调，这会降低他们的独立性和速度。
- en: '**Deployment limitations**: The deployment approach will need to be shared
    across teams, and teams can''t be individually responsible for each deployment,
    as deployment will probably involve work for multiple teams. A deployment problem
    will bring down the whole system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署限制：部署方法需要在团队之间共享，并且团队不能分别对每个部署负责，因为部署可能涉及多个团队的工作。部署问题将导致整个系统崩溃。
- en: '**Interdependency of technologies**: Any new tech needs to fit with the tech
    in use in the monolith. A new technology, for example, a tool that''s perfect
    for a particular problem, may be complicated to add to the monolith, due to a
    mismatch of technologies. Updating dependencies can also cause issues. For example,
    an update to a new version of Python (or a submodule) needs to operate with the
    whole code base. Some required maintenance tasks, such as a security patch, can
    cause a problem just because the monolith already uses a specific version of a
    library, which will break if changed. Adapting to these changes requires extra
    work too.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术的相互依赖性：任何新技术都需要与单体中使用的技术相匹配。例如，一个完美解决特定问题的工具可能很难添加到单体中，因为技术不匹配。更新依赖项也可能会导致问题。例如，更新到新版本的Python（或子模块）需要与整个代码库一起运行。一些必需的维护任务，如安全补丁，可能会导致问题，因为单体已经使用了特定版本的库，如果更改将会中断。适应这些变化也需要额外的工作。
- en: '**A bug in a small part of the system can bring down the whole service**: As
    the service is a whole, any critical issue that affects the stability affects
    everything, making it difficult to generate quality service strategies or causing
    degraded results.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统中的一小部分出现错误可能会导致整个服务崩溃**：由于服务是一个整体，任何影响稳定性的关键问题都会影响到一切，使得难以生成高质量的服务策略或导致结果下降。'
- en: As you can see in the examples, most of the monolith issues are growing issues.
    They are not really important unless the system has a sizeable code base. There
    are some things that work very well in monoliths, such as the fact that, because
    there are no boundaries in the code, the code can be changed very quickly and
    efficiently. But as teams grow and more and more developers are working in the
    system, boundaries help to define objectives and responsibilities. Too much flexibility
    becomes a problem in the long term.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在示例中所看到的，大多数单体结构问题都是不断增长的问题。除非系统有大量的代码库，否则它们并不重要。在单体结构中有一些工作得非常好的东西，比如因为代码中没有边界，所以代码可以被迅速高效地改变。但随着团队的壮大和越来越多的开发人员在系统中工作，边界有助于定义目标和责任。过度的灵活性在长期内会成为问题。
- en: The characteristics of a microservices approach
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务方法的特点
- en: The monolith approach works until the point it doesn't. But, what is the alternative?
    That's where the microservices architecture enters into the scene.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单体结构的工作方式一直有效，直到它不再有效。但是，替代方案是什么？这就是微服务架构进入场景的地方。
- en: 'A system following a microservices architecture *is a collection of loosely
    coupled specialized services that work in unison to provide a comprehensive service*.
    Let''s divide the definition a bit, in more specific terms:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循微服务架构的系统*是一组松散耦合的专门化服务，它们协同工作以提供全面的服务*。让我们将定义分解一下，更具体地说：
- en: A **collection of specialized services**, meaning that there are different,
    well-defined modules.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一组专门的服务**，意味着有不同的、明确定义的模块。'
- en: '**Loosely coupled**, meaning that each of the microservices can be independently
    deployed.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**松散耦合**，意味着每个微服务可以独立部署。'
- en: That **work in unison**—each microservice is capable of communicating with others.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们**协同工作**——每个微服务都能够与其他微服务进行通信。
- en: To provide a **comprehensive service**, because our microservice system will
    need to replicate the same functionalities that were available using a monolith
    approach. There is an intent behind its design.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供**全面的服务**，因为我们的微服务系统将需要复制使用单体结构时可用的相同功能。设计背后有一个意图。
- en: 'In contrast to the previous diagram, the microservice architecture will look
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的图表相比，微服务架构将如下所示：
- en: '![](assets/037b0910-8b4b-48af-b863-4c1ece183ba4.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/037b0910-8b4b-48af-b863-4c1ece183ba4.png)'
- en: Each of the external requests will be channeled to either **Microservice A**
    or **Microservice B**, each one specializing in a particular kind of requests.
    In certain cases, **Microservice B** communicates with **Microservice C**, not
    directly available externally. Note that there may be multiple workers per microservice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个外部请求都将被引导到**微服务A**或**微服务B**，每个微服务都专门处理特定类型的请求。在某些情况下，**微服务B**与**微服务C**进行通信，但对外部不直接可用。请注意，每个微服务可能有多个工作人员。
- en: 'There are several advantages and implications to this architecture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有几个优点和影响：
- en: If the communication between microservices is done through a standard protocol,
    each microservice can be programmed in different languages.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果微服务之间的通信是通过标准协议进行的，那么每个微服务可以用不同的语言编程。
- en: Throughout the book, we will use HTTP requests with data encoded in JSON to
    communicate between microservices. Though there are more options, this is definitively
    the most standard and widely-used option, as virtually every widely-used programming
    language has good support for it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用JSON编码的HTTP请求在微服务之间进行通信。虽然还有更多的选择，但这绝对是最标准和广泛使用的选项，因为几乎每种广泛使用的编程语言都对其有很好的支持。
- en: This is very useful in cases where a specialized language is ideal for a specialized
    problem, but limiting its use so that it is contained, not requiring a drastic
    change in the company.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，专门的语言非常适合解决专门的问题，但限制其使用，使其受控，而不需要公司进行 drastical 变更。
- en: Better resource utilization—if **Microservice A** requires more memory, we can
    reduce the number of worker copies. While on a monolith, each worker requires
    the maximum resource allocation, now each microservice uses only the resources
    required for its part of the whole system. Maybe some of them don't need to connect
    to the database, for example. Each individual element can be tweaked, potentially even at
    the hardware level.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的资源利用——如果**微服务A**需要更多内存，我们可以减少工作副本的数量。而在单体系统中，每个工作副本都需要最大的资源分配，现在每个微服务只使用其所需的整个系统部分的资源。也许其中一些不需要连接到数据库，例如。每个单独的元素都可以进行调整，甚至可能在硬件级别进行调整。
- en: Each individual service is smaller and can be dealt with independently. That
    means fewer lines of code to maintain, faster builds, and a simpler design, with
    less technical debt to maintain. There are no dependency issues between services,
    as each can define and move them at their own pace. Performing refactors can be
    done in a more controlled way, as they won't affect the totality of the system. Furthermore,
    each microservice can change the programming language it's written in, without
    affecting other microservices.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个单独的服务都更小，可以独立处理。这意味着更少的代码行需要维护，更快的构建，更简单的设计，更少的技术债务需要维护。服务之间没有依赖问题，因为每个服务都可以自行定义和移动它们的步伐。进行重构可以以更受控的方式进行，因为它们不会影响整个系统的完整性。此外，每个微服务都可以更改其编程语言，而不会影响其他微服务。
- en: 'From a certain point of view, the microservices architecture is similar to
    the UNIX philosophy, applied to web services: write each program (service) to
    do one thing and do it well, write programs (services) to work together and write
    programs (services) to handle text streams (HTTP calls), because that is a universal
    interface.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来看，微服务架构类似于UNIX哲学，应用于Web服务：编写每个程序（服务）来做一件事，并且做得很好，编写程序（服务）以便彼此协作，编写程序（服务）来处理文本流（HTTP调用），因为这是一个通用接口。
- en: Some services can be hidden from external access. For example, **Microservice
    C** is only called by other services, not externally. In some scenarios, that
    can improve security, reducing the attack surface area for sensitive data or services.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些服务可以隐藏不对外开放。例如，**微服务C**只能被其他服务调用，而不能被外部调用。在某些情况下，这可以提高安全性，减少对敏感数据或服务的攻击面。
- en: As the systems are independent, a stability problem in one won't completely
    stop the system. This reduces critical responses and limits the scope of a catastrophic
    failure.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于系统是独立的，一个系统中的稳定性问题不会完全停止整个系统。这减少了关键响应并限制了灾难性故障的范围。
- en: Each service can be maintained independently by different developers. This allows
    for parallel development and deployment, increasing the amount of work that can
    be done by the company. This requires the exposed APIs to be backward compatible,
    as we will describe later.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个服务可以由不同的开发人员独立维护。这允许并行开发和部署，增加了公司可以完成的工作量。这要求暴露的API是向后兼容的，我们稍后会描述。
- en: Docker containers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器
- en: The microservice architecture is pretty agnostic about the platform that supports
    it. It can be deployed on old physical boxes in a dedicated data center, in a
    public cloud, or in containerized form.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构对支持它的平台几乎没有偏好。它可以部署在旧的物理服务器上，也可以在专用数据中心、公共云或容器化形式中部署。
- en: There's a tendency, though, to use containers to deploy microservices. Containers
    are a packetized bundle of software that encapsulates everything that is required
    to run, including all dependencies. It only requires a compatible OS kernel to
    run autonomously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种倾向是使用容器来部署微服务。容器是软件的打包捆绑，封装了运行所需的一切，包括所有依赖项。它只需要兼容的操作系统内核就可以自主运行。
- en: Docker is the lead actor in containers for web applications. It has an extremely
    vibrant community supporting it as well as great tooling to work on all kinds
    of operations. We will learn how to work and operate using Docker.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是Web应用程序容器的主角。它有一个非常活跃的社区支持，以及用于处理各种操作的优秀工具。我们将学习如何使用Docker进行工作和操作。
- en: The first time that I worked with Docker containers, they looked like a sort
    of *light virtual machine* to me; a small operative system that didn't require
    simulating the hardware to run. But after a while, I realized that's not the correct
    approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用Docker容器时，它们对我来说看起来像一种*轻量级虚拟机*；一个不需要模拟硬件即可运行的小型操作系统。但过了一段时间，我意识到这不是正确的方法。
- en: The best way to describe a container is to think of *a process that's surrounded
    by its own filesystem*. You run one process (or a few related ones), and they
    *see* a whole filesystem, not shared by anyone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 描述容器的最佳方式是将其视为“被其自己的文件系统包围的进程”。您运行一个进程（或几个相关的进程），它们“看到”整个文件系统，不与任何人共享。
- en: This makes containers extremely portable, as they are detached from the underlying
    hardware and the platform that runs them; they are very lightweight, as a minimal
    amount of data needs to be included, and they are secure, as the exposed attack
    surface of a container is extremely small. You don't need applications to manage
    them in the same way you do on a traditional server, such as an `sshd` server,
    or a configuration tool such as Puppet. They are specialized and designed to be
    small and single-purpose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得容器非常易于移植，因为它们与运行它们的基础硬件和平台分离；它们非常轻量级，因为只需要包含最少量的数据，并且它们是安全的，因为容器的攻击面非常小。您不需要像在传统服务器上那样管理它们的应用程序，比如`sshd`服务器，或者像Puppet这样的配置工具。它们是专门设计为小而单一用途的。
- en: In particular, try to keep your containers small and single-purpose. If you
    end up adding several daemons and a lot of configuration, it's likely that you
    are trying to include too much; maybe you need to split it into several containers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，尽量保持容器小而单一用途。如果最终添加了多个守护程序和大量配置，那么您可能试图包含太多内容；也许您需要将其拆分为多个容器。
- en: Working with Docker containers has two steps. First, we build the container,
    executing layer after layer of changes on the filesystem, such as adding the software
    and configuration files that will be executed. Then, we execute it, launching
    its main command. We will see exactly how to do this in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Dockerizing the Service*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker容器有两个步骤。首先，我们构建容器，对文件系统执行一层又一层的更改，例如添加将要执行的软件和配置文件。然后，我们执行它，启动其主要命令。我们将在[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中看到如何做到这一点，*Dockerizing
    the Service*。
- en: The microservices architecture aligns very well with some of the characteristics
    of Docker containers—small, single-purpose elements that communicate through HTTP
    calls. That's why, even though it's not a hard requirement, they're typically
    presented together these days.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构与Docker容器的一些特性非常契合——小型、单一用途的元素，通过HTTP调用进行通信。这就是为什么即使这不是一个硬性要求，但它们通常一起呈现的原因。
- en: The Twelve-Factor App principles ([https://12factor.net/](https://12factor.net/)),
    which are a collection of practices that have been proven successful in developing
    web applications, are also very aligned with Docker containers and with the microservice
    architecture. Some of the principles are extremely easy to follow with Docker,
    and we will comment on them in depth later in the book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 《十二要素应用》原则（[https://12factor.net/](https://12factor.net/)）是一套在开发Web应用程序中被证明成功的实践集合，它们也与Docker容器和微服务架构非常契合。其中一些原则在Docker中非常容易遵循，我们将在本书的后面深入讨论它们。
- en: An important factor for dealing with containers is that containers should be
    stateless (Factor VI—[https://12factor.net/processes](https://12factor.net/processes)).
    Any state needs to be stored in a database and each container stores no persistent
    data. This is one of the key elements for scalable web servers that, when dealing
    with a couple of servers, may not be done. Be sure to keep it in mind.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 处理容器的一个重要因素是容器应该是无状态的（第六因素—[https://12factor.net/processes](https://12factor.net/processes)）。任何状态都需要存储在数据库中，每个容器都不存储持久数据。这是可扩展的Web服务器的关键要素之一，当处理一些服务器时，可能无法完成。一定要记住这一点。
- en: Another advantage of Docker is the availability of a lot of ready-to-use containers. Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)) is a public registry
    full of interesting containers to inherit or to use directly, either in development
    or production. This helps you to have examples for your own services, and to quickly
    create small services that require little configuration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的另一个优点是有很多现成的容器可用。Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）是一个公共注册表，里面有很多有趣的容器可以继承或直接使用，无论是在开发还是生产中。这有助于为您自己的服务提供示例，并快速创建需要很少配置的小型服务。
- en: Container orchestration and Kubernetes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排和Kubernetes
- en: Though Docker presents on how to deal with each of the individual microservices,
    we will need an orchestrator to handle the whole cluster of services. For that,
    we will use Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) throughout
    the book. This is the main orchestration project, and it has great support from
    the main cloud vendors. We will talk in detail about it in [Chapter 5](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml), *Using
    Kubernetes to Coordinate Microservices*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker提供了如何处理每个单独的微服务，但我们需要一个编排器来处理整个服务集群。因此，我们将在整本书中使用Kubernetes（[https://kubernetes.io/](https://kubernetes.io/)）。这是主要的编排项目，并且得到了主要云供应商的大力支持。我们将在第五章《使用Kubernetes协调微服务》中详细讨论它。
- en: Parallel deployment and development speed
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行部署和开发速度
- en: The single most important element is the capacity to deploy independently. Rule
    number one for creating a successful microservices system is to ensure that each
    microservice can operate as **independently** as possible from the rest. That
    includes development, testing, and deployment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的元素是能够独立部署。创建成功的微服务系统的第一条规则是确保每个微服务尽可能**独立**地运行。这包括开发、测试和部署。
- en: This is the key element that allows developing in parallel between different
    teams, allowing them to scale the work. This increases the speed of change in
    a complex system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许不同团队之间并行开发的关键因素，使它们能够扩展工作。这增加了复杂系统变更的速度。
- en: The team responsible for a specific microservice needs to be capable of deploying
    a new version of the microservice without interrupting any other teams or services.
    The objective is to increase the number of deployments and the speed of each of
    them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 负责特定微服务的团队需要能够在不中断其他团队或服务的情况下部署微服务的新版本。目标是增加部署次数和每次部署的速度。
- en: The microservice architecture is strongly related to Continuous Integration
    and Continuous Deployment principles. Small services are easy to keep up to date
    and to continuously build, as well as to deploy without interruption. In that
    regard, a CI/CD system tends to be microservices due to the increase in parallelization
    and the speed of delivery.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构与持续集成和持续部署原则密切相关。小型服务易于保持最新状态并进行持续构建，也易于在不中断的情况下部署。在这方面，CI/CD系统往往会变成微服务，因为它增加了并行化和交付速度。
- en: As deploying a microservice should be transparent for dependent services, special
    attention should be paid to backward compatibility. Some changes will need to
    be escalated and coordinated with other teams to remove old, incorrect functionality
    without interrupting the system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于部署微服务对依赖服务应该是透明的，因此需要特别注意向后兼容性。一些更改将需要升级并与其他团队协调，以删除旧的、不正确的功能，而不会中断系统。
- en: While, theoretically, it's possible to have totally disconnected services, that's
    not realistic in practice. Some services will have dependencies between them.
    A microservice system will force you to define strong boundaries between the services,
    and any feature that requires cross-service communication will carry some overhead,
    maybe even having to coordinate the work across different teams.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在理论上完全断开服务是可能的，但在实践中并不现实。一些服务之间会存在依赖关系。微服务系统将迫使您在服务之间定义明确的边界，任何需要跨服务通信的功能都会带来一些额外开销，甚至可能需要协调不同团队的工作。
- en: When moving to a microservices architecture, the move is not purely technical
    but also implies a big change in the way the company works. The development of
    microservices will require autonomy and structured communication, which requires
    extra effort up front in planning the general architecture of the system. In monolith
    systems, this may be ad hoc and could have evolved into a not-so-separated internal
    structure, increasing the risk of tangled code and technical debt.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向微服务架构时，这种转变不仅仅是技术上的，还意味着公司工作方式的重大变化。微服务的开发将需要自主性和结构化沟通，这需要在系统的总体架构规划中提前付出额外的努力。在单体系统中，这可能是临时的，可能已经演变成了一个不太分离的内部结构，增加了纠缠的代码和技术债务的风险。
- en: The need to clearly communicate and define owners cannot be stressed enough.
    Aim to allow each team to make their own decisions about their code and formalize
    and maintain the external APIs where other services depend on them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要清晰沟通和定义所有者的需求不言而喻。目标是允许每个团队就其代码做出自己的决定，并规范和维护其他服务依赖的外部API。
- en: This extra planning, though, increases long-term delivery bandwidth, as teams
    are empowered to make more autonomous decisions, including big ones such as which operating
    system to use, or which programming language, but also a myriad of smaller ones,
    such as using third-party packages, frameworks, or module structures. This increases
    the development pace in day-to-day operations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种额外的规划增加了长期交付带宽，团队有权做出更多自主决策，包括诸如使用哪种操作系统或编程语言等重大决策，也包括使用第三方包、框架或模块结构等许多较小的决策。这增加了日常运营中的开发速度。
- en: Microservices may also affect how the teams are structured in your organization.
    As a general rule, existing teams should be respected. There will be expertise
    in them that will be very useful, and causing a total revolution will disrupt
    that. But some tweaks may be necessary. Some concepts, such as understanding web
    services and RESTful interfaces will need to be present in every microservice,
    as well as knowledge on how to deploy its own service.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务还可能影响组织中团队的结构。一般规则是要尊重现有的团队。它们中会有非常有用的专业知识，而彻底革命会破坏这一点。但可能需要进行一些微调。一些概念，比如理解Web服务和RESTful接口，需要在每个微服务中存在，以及如何部署自己的服务的知识。
- en: A traditional way of dividing teams is to create an operations team that is
    in charge of infrastructure and any new deployments because they are the only
    ones allowed to have access to the production servers. The microservices approach
    interferes with this as it needs teams to be able to have control over their own
    deployments. In [Chapter 5](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml), *Using
    Kubernetes to Coordinate Microservices*, we'll see how using Kubernetes helps
    in this situation, detaching the maintenance of the infrastructure from the deployment
    of services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的团队划分方式是创建一个负责基础设施和任何新部署的运维团队，因为他们是唯一被允许访问生产服务器的人。微服务方法干扰了这一点，因为它需要团队能够控制自己的部署。在[第5章](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml)中，*使用Kubernetes协调微服务*，我们将看到如何使用Kubernetes在这种情况下有所帮助，将基础设施的维护与服务的部署分离开来。
- en: It also allows creating a big sense of ownership, as teams are encouraged to
    work in their own preferred way in their own kingdom, while they play the game
    with the rest of the teams within clearly defined and structured borders. Microservices
    architecture can allow experimentation and innovation in small parts of the system
    that, once proven, can be disseminated across the whole system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以产生强烈的所有权感，因为团队被鼓励以自己喜欢的方式在自己的王国内工作，同时与其他团队一起在明确定义和结构化的边界内进行游戏。微服务架构可以允许在系统的小部分进行实验和创新，一旦证明有效，就可以在整个系统中传播。
- en: Challenges and red flags
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战和红旗
- en: We've discussed a lot of advantages that the microservice architecture has over
    a monolith, but migrating is a massive undertaking that should not be underestimated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了微服务架构相对于单体架构的许多优势，但迁移是一项庞大的工程，不容小觑。
- en: Systems get started as monoliths, as it is simpler and allows for quicker iteration
    in a small code base. In any new company, pivoting and changing the code, searching
    for a successful business model is critical. This takes preference over clear
    structures and architecture separations—it is the way it should be.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统最初是作为单体应用启动的，因为它更简单，可以在小的代码库中进行快速迭代。在任何新公司中，转变和改变代码，寻找成功的商业模式至关重要。这比清晰的结构和架构分离更重要——这就是应该的。
- en: However, once the system matures, the company grows. As more and more developers
    get involved, the advantages of a monolith start to become less evident, and the
    need for long-term strategy and structure becomes more important. More structure
    doesn't necessarily mean moving toward a microservice architecture. A great deal
    can be achieved with a well-architected monolith.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦系统成熟，公司发展壮大。随着越来越多的开发人员参与其中，单体架构的优势开始变得不那么明显，长期战略和结构的需求变得更加重要。更多的结构并不一定意味着向微服务架构迈进。一个良好架构的单体应用也能取得很大成就。
- en: 'Moving to microservices also has its own problems. Some of them are the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到微服务也有自己的问题。其中一些如下：
- en: Migrating to microservices requires a lot of effort, actively changing the way
    an organization operates, and a big investment until it starts to pay off. The
    transition will probably be painful, as a pragmatic approach is required and compromises
    will need to be made. It will also involve a lot of designing documents and meetings
    to plan the migration—all while the business continues to operate. This requires
    full commitment and an understanding of what's involved.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移到微服务需要大量的努力，积极改变组织运作方式，并且需要大量投资才能开始收益。过渡可能会很痛苦，因为需要采取务实的方法，并且需要做出妥协。这还将涉及大量的设计文件和会议来规划迁移，同时业务仍在继续运作。这需要全力以赴，并且要理解其中的内容。
- en: Do not underestimate the cultural change—organizations are made of people, and
    people do not like change. A lot of the changes in microservices are related to
    different ways of operating and doing things in different ways. While this empowers
    different teams, it also forces them to clarify their interfaces and APIs and
    to formalize communication and boundaries. This can lead to frustration and resistance
    by members of the teams.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要低估文化变革——组织由人组成，人们不喜欢变化。微服务中的许多变化与不同的操作方式和不同的做事方式有关。虽然这赋予了不同的团队权力，但也迫使他们澄清他们的接口和API，并形式化沟通和边界。这可能导致团队成员的挫折和抵抗。
- en: There's an adage called Conway's law ([http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html))
    that states that *organizations which design systems are constrained to produce
    designs which are copies of the communication structures of these organizations.*
    For microservices, this means that divisions between teams should reflect the
    different services. Having multiple teams working in the same microservice will
    blur the interfaces. We will discuss Conway's law in detail in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml),
    *Collaborating and Communicating across Teams*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句格言叫康威定律（[http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html)），它说*设计系统的组织受限于产生这些组织沟通结构的设计副本*。对于微服务来说，这意味着团队之间的分工应该反映不同的服务。让多个团队在同一个微服务中工作会模糊接口。我们将在[第12章](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml)中详细讨论康威定律，*跨团队协作和沟通*。
- en: There's also a learning curve in learning the tools and procedures. Managing
    clusters is done differently than a single monolith, and developers will need
    to understand how to interoperate different services for testing locally. In the
    same way, that deployment will be different from traditional, local development
    as well. In particular, learning Docker takes some time to adapt. Plan accordingly
    and give support and training to everyone involved.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习工具和程序也需要时间。管理集群与单一的单体系统不同，开发人员需要了解如何在本地测试不同的服务之间的互操作性。同样，部署也会与传统的本地开发不同。特别是，学习Docker需要一些时间来适应。因此要做好计划，并为所有参与者提供支持和培训。
- en: Debugging a request that moves across services is more difficult than a monolithic
    system. Monitoring the life cycle of a request is important and some subtle bugs
    can be difficult to replicate and fix in development.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试跨服务的请求比单体系统更困难。监控请求的生命周期很重要，一些微妙的错误在开发中很难复制和修复。
- en: Splitting a monolith into different services requires careful consideration.
    A bad division line can make two services tightly coupled, not allowing independent
    deployment. A red flag in that means almost any change to one service requires
    a change in the other, even if, normally, it could be done independently. This
    creates duplication of work, as routinely working on a single feature requires
    changing and deploying multiple microservices. Microservices can be mutated later
    and boundaries redefined, but there's a cost associated with that. The same care
    should be taken when adding new services.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单体应用拆分为不同的服务需要仔细考虑。糟糕的划分线可能会使两个服务紧密耦合，无法独立部署。这意味着几乎任何对一个服务的更改都需要对另一个服务进行更改，即使通常情况下可以独立完成。这会导致工作重复，因为通常需要对单个功能进行常规工作，需要更改和部署多个微服务。微服务以后可以进行变异和边界重新定义，但与此相关的成本也是存在的。添加新服务时应该采取同样的谨慎。
- en: There's an overhead in creating microservices, as there's some work that gets
    replicated on each service. That overhead gets compensated by allowing independent
    and parallel development. But, to fully take advantage of that, you need numbers.
    A small development team of up to 10 people can coordinate and handle a monolith
    very efficiently. It's only when the size grows and independent teams are formed
    that migrating to microservices starts to make sense. The bigger the company,
    the more it makes sense.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建微服务存在一些开销，因为每个服务都需要复制一些工作。这种开销通过允许独立和并行开发来进行补偿。但是，要充分利用这一点，你需要数字。一个最多有10人的小型开发团队可以高效地协调和处理单体应用。只有当规模扩大并形成独立团队时，迁移到微服务才开始变得有意义。公司规模越大，这种做法就越有意义。
- en: A balance between freedom and allowing each team to make their own decisions
    and standardize some common elements and decisions is necessary. If teams have
    too little direction, they'll keep reinventing the wheel over and over. They'll
    also end up creating knowledge silos where the knowledge in a section of the company
    is totally nontransferable to another team, making it difficult to learn lessons
    collectively. Solid communication between teams is required to allow consensus
    and the reuse of common solutions. Allow controlled experimentation, label it
    as such, and get the lessons learned across the board so that the rest of the
    teams benefit. There will be tension between shared and reusable ideas and independent,
    multiple-implementation ideas.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自由和允许每个团队做出自己的决定之间取得平衡，并标准化一些共同的元素和决策是必要的。如果团队缺乏方向，他们将一遍又一遍地重新发明轮子。他们也会最终创建知识孤岛，公司某一部分的知识完全无法转移到另一个团队，这使得共同学习变得困难。团队之间的良好沟通是必要的，以允许达成共识并重复使用共同的解决方案。允许受控的实验，将其标记为这样，并让所有团队从中汲取经验教训。共享和可重复使用的想法与独立的、多实现的想法之间会存在紧张关系。
- en: Be careful when introducing shared code across services. If the code grows,
    it will make services dependent on each other. This can reduce the independence
    of the microservices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务之间引入共享代码时要小心。如果代码增长，它将使服务相互依赖。这可能会降低微服务的独立性。
- en: Following the Agile principles, we know that working software is more important
    than extensive documentation. However, in microservices, it's important to maximize
    the usability of each individual microservice to reduce the amount of support
    between teams. That involves some degree of documentation. The best approach is
    to create self-documenting services. We'll look at some examples later in the
    book on how to use tools to allow documenting how to use a service with minimal
    effort.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循敏捷原则，我们知道，可工作的软件比广泛的文档更重要。然而，在微服务中，最大化每个单独微服务的可用性以减少团队之间的支持量是很重要的。这涉及一定程度的文档编制。最好的方法是创建自我记录的服务。我们将在本书的后面看一些例子，说明如何使用工具来允许以最小的努力记录如何使用一个服务。
- en: Each call to another service, such as internal microservices calling each other,
    can increase the delay of responses, as multiple layers will have to be involved.
    This can produce latency problems, with external responses taking longer. They
    will also be affected by the performance and capacity of the internal network
    connecting the microservices.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次调用另一个服务，比如内部微服务相互调用，都会增加响应的延迟，因为将涉及多个层。这可能会产生延迟问题，导致外部响应时间变长。它们也会受到内部网络连接微服务的性能和容量的影响。
- en: A move to microservices should be taken with care and by carefully analyzing
    its pros and cons. It is possible that it will take years to complete the migration
    in a mature system. But for a big system, the resulting system will be much more
    agile and easy to change, allowing you to tackle technical debt effectively and
    to empower developers to take full ownership and innovate, structuring communication
    and delivering a high quality, reliable service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到微服务应该谨慎进行，并仔细分析其利弊。在一个成熟的系统中，完成迁移可能需要数年的时间。但对于一个大型系统来说，结果系统将更加灵活和易于更改，使您能够有效地处理技术债务，并赋予开发人员充分的所有权和创新，构建沟通并提供高质量、可靠的服务。
- en: Analyzing the current system
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析当前系统
- en: The very first step, as we defined before, to migrate from a monolith to a collection
    of microservices is understanding the current system. This stage should not be
    underestimated. It is highly likely that no single person has a good understanding
    of the different components of the monolith, especially if some parts are legacy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前定义的，从单体到一组微服务的迁移的第一步是了解当前系统。这个阶段不应被低估。很可能没有一个人对单体的不同组件有很好的理解，特别是如果一些部分是遗留的。
- en: The objective of this phase is to determine whether a change to microservices
    will actually be beneficial and to get an initial idea of what microservices will
    be the result of the migration. As we have discussed, making the move is a big
    investment and should not be taken lightly. Making a detailed estimation of the
    effort required won't be possible at this stage; uncertainty will be big at this
    point, but a thousand-mile journey starts with a single step.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的目标是确定微服务的变化是否真的有益，并初步了解迁移后微服务的结果会是什么样的。正如我们所讨论的，迁移是一项巨大的投资，不应轻率对待。在这个阶段，很难对所需的努力进行详细的估计；此时的不确定性会很大，但千里之行始于足下。
- en: The effort involved will vastly depend on how structured the monolith is. This
    may vary from a mess of spaghetti code that has grown organically without much
    direction, to a well-structured and modularized code base.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所涉及的努力将在很大程度上取决于单体结构的结构化程度。这可能从一个没有明确方向，有机生长的一团乱麻代码，到一个良好结构化和模块化的代码库。
- en: We will use an example application in this book—a micro-blogging site called
    MyThoughts, a simple service that will allow us to post and read short messages
    or thoughts. The website allows us to log in, post a new thought, see our thoughts,
    and search for thoughts in the system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中使用一个示例应用程序——一个名为MyThoughts的微博网站，这是一个简单的服务，允许我们发布和阅读短消息或想法。该网站允许我们登录、发布新想法、查看我们的想法，并在系统中搜索想法。
- en: '![](assets/9169859c-18ea-4693-8c23-c0d91fc9aaab.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9169859c-18ea-4693-8c23-c0d91fc9aaab.png)'
- en: As a first step, we will draw an architectural diagram of the monolith. Reduce
    the current system to a list of blocks that interact with each other.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将绘制单体架构图。将当前系统简化为相互交互的块列表。
- en: 'The code for our example is available here: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith).
    It is a Django application that uses Bootstrap for its HTML interface. See the
    `README` for instructions on how to run it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例的代码在这里可用：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith)。这是一个使用Bootstrap作为HTML界面的Django应用程序。查看`README`以获取运行它的说明。
- en: 'In our example, the MyThoughts model is described in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，MyThoughts模型在下图中描述：
- en: '![](assets/db5b3617-82b8-4ffd-b2fc-5e01ba308c01.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db5b3617-82b8-4ffd-b2fc-5e01ba308c01.png)'
- en: 'As you can see, the monolith seems to be following a Model View Controller
    structure ([https://www.codecademy.com/articles/mvc](https://www.codecademy.com/articles/mvc)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，单体似乎遵循着模型视图控制器结构（[https://www.codecademy.com/articles/mvc](https://www.codecademy.com/articles/mvc)）：
- en: Django uses a structure called Model Template View, which follows a similar
    pattern to the MVC one. Read the article at [https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f](https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f)
    for more information. Whether it's 100% MCV or not is debatable. Let's not get
    stuck on semantics, but use the definition as a starting point to describe the
    system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用一种称为模型模板视图的结构，它遵循与MVC类似的模式。阅读[https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f](https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f)中的文章以获取更多信息。它是否完全符合MVC是值得商榷的。让我们不要困在语义上，而是使用定义作为描述系统的起点。
- en: 'There are three entities stored in a database and accessed through the models:
    the user, the thoughts, and the session models. The session is used for keeping
    track of logins.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有三个实体存储在数据库中，并通过模型访问：用户、想法和会话模型。会话用于跟踪登录状态。
- en: A user can log in and out to access the site through the code in `login.py`.
    If the user logs in, a session is created that allows the user to see the rest
    of the website.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过`login.py`中的代码登录和退出以访问网站。如果用户登录，将创建一个会话，允许用户查看网站的其余部分。
- en: Please note that the handling of authentication and passwords in this example
    is for demonstration purposes only. Use the default mechanisms in Django for more
    secure access. It's the same for the session, where the native session management
    is not used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例中身份验证和密码处理仅用于演示目的。请使用Django中的默认机制以获得更安全的访问。会话也是一样，原生会话管理未被使用。
- en: A user can see their own thoughts. On the same page, there's a new form that
    creates a new thought. This is handled by the `thoughts.py` file, which retrieves
    and stores the thoughts through `ThoughtModel`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以查看自己的想法。在同一页上，有一个创建新想法的表单。这由`thoughts.py`文件处理，通过`ThoughtModel`检索和存储想法。
- en: To search other users' thoughts, there's a search bar that connects to the `search.py`
    module and returns the obtained values.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要搜索其他用户的想法，有一个搜索栏连接到`search.py`模块并返回获取的值。
- en: The HTML is rendered through the `login.html`, `search.html`, `list_thoughts.html`, and
    `base.html` templates.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML是通过`login.html`、`search.html`、`list_thoughts.html`和`base.html`模板呈现的。
- en: On top of that, there are static assets that style the website.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除此之外，还有样式网站的静态资产。
- en: 'This example is very simple, but we are able to see some of the interdependencies:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常简单，但我们能够看到一些相互依赖的情况：
- en: The static data is very isolated. It can be changed at any point without requiring
    any changes anywhere else (as long as the templates are compatible with Bootstrap).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态数据非常独立。它可以在任何时候更改，而无需在其他任何地方进行任何更改（只要模板与Bootstrap兼容）。
- en: The search functionality is strongly related to list down thoughts. The template
    is similar, and the information is displayed in the same way.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能与列出思想密切相关。模板类似，并且信息以相同的方式显示。
- en: Login and logout don't interact with `ThoughtModel`*.* They edit the session,
    but the rest of the application only reads the information there.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和登出不与`ThoughtModel`交互。它们编辑会话，但应用程序的其余部分只读取那里的信息。
- en: The `base.html` template generates the top bar and it's used for all pages.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.html`模板生成顶部栏，并且用于所有页面。'
- en: 'After this analysis, some ideas on how to proceed come to mind:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这项分析，一些关于如何继续的想法浮现在脑海中：
- en: Just leave it the way it is, investing in structuring it, but without splitting
    it into several services. It has a certain structure already, though some parts
    could be improved. For example, the handling of whether the user is logged in
    or not could be better. This is obviously a small example, and, in real life,
    splitting it into microservices would have a big overhead. Remember that sticking
    with a monolith may be a viable strategy, but if you do, please invest time in
    cleaning up code and paying technical debt.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只是保持现状，投资于对其进行结构化，但不将其拆分为多个服务。它已经有一定的结构，尽管有些部分可以改进。例如，处理用户是否已登录的方式可能会更好。这显然是一个小例子，在现实生活中，将其拆分为微服务将会有很大的开销。请记住，坚持使用单体架构可能是一种可行的策略，但如果这样做，请投入时间清理代码并偿还技术债务。
- en: Searching for thoughts is pretty basic. At the moment, we directly search the
    database. If there are millions of thoughts, this won't be a viable option. The
    code in `search.py` could call a specific search microservice, backed by a search
    engine such as Solr ([https://lucene.apache.org/solr/](https://lucene.apache.org/solr/)) or
    Elasticsearch ([https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)).
    This will scale the searches and could add capabilities like searching between
    dates or displaying the text matches. Search is also read-only, so it may be a
    good idea to detach calls creating new thoughts from calls searching them.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索思想非常基础。目前，我们直接搜索数据库。如果有数百万个想法，这将不是一个可行的选择。`search.py`中的代码可以调用特定的搜索微服务，由Solr（[https://lucene.apache.org/solr/](https://lucene.apache.org/solr/)）或Elasticsearch（[https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)）等搜索引擎支持。这将扩展搜索并可以添加诸如在日期之间搜索或显示文本匹配等功能。搜索也是只读的，因此可能会将创建新想法的调用与搜索它们的调用分离开来是一个好主意。
- en: Authentication is also a different problem from reading and writing thoughts.
    Splitting it will allow us to keep on track for new security issues and have a
    team specifically dealing with those issues. From the point of view of the rest
    of the application, it only requires you to have something available to check
    whether a user is logged or not, and that can be delegated in a module or package.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证也是一个不同的问题，不同于阅读和写入思想。拆分它将使我们能够跟踪新的安全问题，并有一个专门处理这些问题的团队。从应用的角度来看，它只需要有一个可用的检查用户是否已登录的功能，这可以委托给一个模块或包。
- en: The frontend is pretty static at the moment. Maybe we want to create a single-page
    application that calls a backend API to render the frontend in the client. To
    do that, a RESTful API microservice that is able to return elements for thoughts
    and searches will need to be created. The frontend could be coded in a JavaScript
    framework, such as Angular ([https://angular.io](https://angular.io)) or React
    ([https://reactjs.org/](https://reactjs.org/)). In this case, the new microservice
    will be the frontend, which will be served as static, precompiled code, and will
    pull from the backend.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端目前相当静态。也许我们想创建一个单页面应用，调用后端API在客户端渲染前端。为此，需要创建一个能够返回思想和搜索元素的RESTful API微服务。前端可以使用JavaScript框架编码，比如Angular（[https://angular.io](https://angular.io)）或React（[https://reactjs.org/](https://reactjs.org/)）。在这种情况下，新的微服务将成为前端，将作为静态的、预编译的代码提供，并从后端拉取。
- en: The RESTful API backend will also be available to allow external developers
    to create their own tools on top of the MyThoughts data, for example, to create
    a native phone app.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTful API后端也将可用，允许外部开发人员在MyThoughts数据的基础上创建自己的工具，例如创建原生手机应用。
- en: These are just some ideas, which will need to be discussed and evaluated. What
    are the specific pain points for your monolithic app? What is the roadmap and
    the strategic future? What are the most important points and features for the
    present or the future? Maybe, for one company, having strong security is a priority,
    and point 3 is critical, but for another, point 5 might be part of the expansion
    model to work with partners.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些想法，需要讨论和评估。你的单片应用有什么具体的痛点？路线图和战略未来是什么？现在或未来最重要的点和特性是什么？也许，对于一家公司来说，拥有强大的安全性是首要任务，第三点至关重要，但对另一家公司来说，第五点可能是与合作伙伴合作扩展模型的一部分。
- en: The team's structure is also important. Point 4 will require a team with good
    frontend and JavaScript skills, while point 2 may involve backend optimization
    and database work to allow an efficient search of millions of records.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 团队结构也很重要。第四点需要一个具有良好的前端和JavaScript技能的团队，而第二点可能涉及后端优化和数据库工作，以实现对数百万条记录的高效搜索。
- en: Do not jump too quickly to conclusions here; think about what capacity is viable
    and what your teams can achieve. As we discussed before, the change to microservices
    requires a certain way of working. Check with the people involved for their feedback
    and suggestions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不要过快地得出结论；考虑一下什么样的能力是可行的，你的团队能够实现什么。正如我们之前讨论过的，转向微服务需要一定的工作方式。与相关人员核实他们的反馈和建议。
- en: 'After some consideration, for our example, we propose the following potential
    architecture:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些考虑，对于我们的例子，我们提出以下潜在架构：
- en: '![](assets/e0b5fd45-46bf-49e7-ac45-ecfe9c6daca7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e0b5fd45-46bf-49e7-ac45-ecfe9c6daca7.png)'
- en: 'The system will be divided into the following modules:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将分为以下模块：
- en: '**Users backend:** This will have the responsibility for all authentication
    tasks and keep information about the users. It will store its data in the database.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户后端：** 这将负责所有认证任务，并保存用户信息。它将把数据存储在数据库中。'
- en: '**Thoughts backend:** This will create and store *thoughts*.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**想法后端**：这将创建和存储*想法*。'
- en: '**Search backend**: This will allow searching *thoughts*.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索后端**：这将允许搜索*想法*。'
- en: A proxy that will route any request to the proper backend. This needs to be
    externally accessible.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理将路由任何请求到适当的后端。这需要是外部可访问的。
- en: '**HTML frontend:** This will replicate the current functionality. This will
    ensure that we work in a backward-compatible way and that the transition can be
    made smoothly.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTML前端**：这将复制当前的功能。这将确保我们以向后兼容的方式工作，并且过渡可以顺利进行。'
- en: Allowing clients to access the backends will allow the creation of other clients
    than our HTML frontend. A dynamic frontend server will be created, and there are
    talks with an external company to create a mobile app.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许客户端访问后端将允许创建除我们的HTML前端之外的其他客户端。将创建一个动态前端服务器，并且正在与外部公司讨论创建移动应用的事宜。
- en: '**Static assets:** A web server capable of handling static files. This will
    serve the styling for the HTML frontend and the index files and JavaScript files
    for the dynamic frontend.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**静态资产**：能够处理静态文件的Web服务器。这将为HTML前端提供样式，并为动态前端提供索引文件和JavaScript文件。'
- en: This architecture will need to adapt to real-life usage; to validate it, we'll
    need to measure the existing usage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构将需要适应实际使用情况；为了验证它，我们需要测量现有的使用情况。
- en: Preparing and adapting by measuring usage
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过测量使用情况来准备和调整
- en: Obviously, any real-world system will be more complicated than our example.
    There's a limit to what a code analysis can discover just by looking at it carefully,
    and plans often don't survive contact with the real world.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，任何现实世界的系统都会比我们的示例更复杂。通过仔细观察，代码分析能够发现的内容是有限的，而计划往往在与现实世界接触时无法生存。
- en: Any division needs to be validated to ensure that it will have the expected
    result and that the effort will be worth it. So double-check that the system is
    working the way you think it is working.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何划分都需要经过验证，以确保它会产生预期的结果，并且付出的努力是值得的。因此，请仔细检查系统是否按您认为的方式运行。
- en: The ability to know how a live system is working is called **observability**.
    The main tools for it are metrics and logs. The problem you'll find is that they
    will normally be configured to reflect external requests and give no information
    about internal modules. We will talk about the observability of systems in depth
    in [Chapter 10](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml), *Monitoring Logs
    and Metrics*. You can refer to it for more information and apply the techniques
    described there at this stage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察到一个实时系统运行状况的能力被称为**可观测性**。其主要工具是指标和日志。你会发现的问题是，它们通常会被配置为反映外部请求，并且不提供有关内部模块的信息。我们将在[第10章](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml)中深入讨论系统的可观测性，*监控日志和指标*。您可以参考它以获取更多信息，并在此阶段应用那里描述的技术。
- en: If your system is a web service, by default, it will have activated its access
    log. This will log each HTTP request that comes into the system and store the
    URL, result, and time when it happens. Check with your team where these logs are
    located, as they will provide good information on what URLs are being called.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统是一个Web服务，默认情况下将激活其访问日志。这将记录进入系统的每个HTTP请求，并存储URL、结果和发生时间。与您的团队核实这些日志的位置，因为它们将提供关于调用哪些URL的良好信息。
- en: This analysis, though, will probably give only information about what the external
    endpoints being called are, but won't say much about internal modules that will
    be split into different microservices according to our plan. Remember that the
    most important element for the long-term success of the move to microservices
    is to allow teams to be independent. If you split across modules that constantly
    need to be changed in unison, deployments won't be truly independent, and, after
    the transition, you'll be forced to work with two tightly coupled services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这种分析可能只会提供有关被调用的外部端点的信息，但对于根据我们的计划拆分为不同微服务的内部模块并不会提供太多信息。请记住，对于迁移到微服务的长期成功来说，最重要的元素是允许团队独立。如果你跨模块进行拆分，而这些模块需要不断协同变化，部署就不会真正独立，在过渡后，你将被迫使用两个紧密耦合的服务。
- en: Be careful, in particular, about making a microservice that's a dependency for
    every other service. Unless the service is extremely stable, that will make frequent
    updates likely when any other service requires a new feature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要小心的是，不要创建一个对每个其他服务都是依赖的微服务。除非该服务非常稳定，否则当任何其他服务需要新功能时，就可能频繁更新。
- en: To verify that the new microservices won't be tightly coupled, make the teams
    aware of the divisions and how often they have to change the interfaces surrounding
    them. Monitor these changes for a few weeks to be sure that the division lines
    are stable and don't require constant change. If the interface between microservices
    is very actively being changed, any feature will require multiple changes in several
    services, and that will slow the pace of delivering new features.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证新的微服务不会紧密耦合，让团队意识到这些划分以及它们周围接口的变化频率。监控这些变化几周，确保划分线稳定且不需要不断变化。如果微服务之间的接口非常活跃地被更改，任何功能都将需要在多个服务中进行多次更改，这将减缓交付新功能的速度。
- en: 'In our example, after analyzing the proposed architecture, we decide to simplify
    the design, as shown in this diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，经过分析提出的架构后，我们决定简化设计，如图所示：
- en: '![](assets/82ea1d40-9fc8-4d9a-8452-84332c3e2780.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82ea1d40-9fc8-4d9a-8452-84332c3e2780.png)'
- en: 'Some changes have been decided after monitoring and talking with the teams:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控和与团队交谈后，做出了一些决定：
- en: The teams don't have good knowledge of JavaScript dynamic programming. The change
    to the frontend, at the same time as making the move to microservices, is seen
    as too risky.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队对JavaScript动态编程没有很好的了解。同时进行前端的变更，以及进行微服务的迁移，被认为是太冒险的。
- en: The external mobile application, on the other hand, is seen as a strategic move
    for the company, making the externally accessible API a desirable move.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，外部移动应用被视为公司的战略举措，使得外部可访问的API成为一个理想的举措。
- en: Analyzing the logs, it seems like the search functionality is not often used.
    The growth in the number of searches is small, and splitting search into its own
    service will require coordination with the Thoughts Backend, as it's an area of
    active development, with new fields being added. It is decided to keep search under
    the Thoughts Backend, as both work with the same thoughts.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分析日志，似乎搜索功能并不经常被使用。搜索数量的增长很小，将搜索拆分为自己的服务将需要与Thoughts后端进行协调，因为它是一个正在积极开发的领域，正在添加新字段。决定将搜索保留在Thoughts后端下，因为它们都处理相同的想法。
- en: The Users Backend has been received well. It will allow improving the security
    of authentication by having clear ownership of who's responsible for patching
    security vulnerabilities and improving the services. The rest of the microservices
    will have to work independently with verification by the Users Backend, which
    means the team responsible for this microservice will need to create and maintain
    a package with information on how to validate a request.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户后端受到了良好的接待。它将允许通过明确负责修补安全漏洞和改进服务的所有者来改善身份验证的安全性。其余的微服务将必须独立工作，并由用户后端进行验证，这意味着负责该微服务的团队将需要创建和维护一个包含验证请求信息的包。
- en: Once we've decided on the final state, we still have to decide how are we going
    to move from one state to another.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了最终状态，我们仍然必须决定如何从一个状态转移到另一个状态。
- en: Strategic planning to break the monolith
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破单体的战略规划
- en: As we've discussed previously, moving from the initial state to the desired
    one will be a slow process. Not only because it involves new ways of doing things,
    but also because it will happen in parallel with other features and developments
    that are "business as usual." Being realistic, the company's business activities
    will not stop. That's why a plan should be in place to allow a smooth transition
    between one state and the other.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，从初始状态到期望状态的转变将是一个缓慢的过程。不仅因为它涉及到新的做事方式，而且因为它将与其他“业务如常”的特性和发展并行发生。实际上，公司的业务活动不会停止。这就是为什么应该制定一个计划，以便在一个状态和另一个状态之间实现平稳过渡。
- en: This is known as the **strangler pattern** ([https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler](https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler))—replacing
    parts of a system gradually until the old system is "strangled" and can be removed
    safely.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**窒息模式**（[https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler](https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler)）-逐渐替换系统的部分，直到旧系统被“窒息”并可以安全地移除。
- en: 'There are a few alternatives as to what technical approach to take to make
    the move and how to divide each of the elements to migrate to the new system:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选择可以采取什么技术方法来进行转变，以及如何划分每个元素以迁移到新系统：
- en: The replacement approach, which replaces the older code with new code written
    from scratch the new service
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换方法，用全新编写的新代码替换旧代码
- en: The divide approach, which cherry-picks existing code and moves it into its
    own new service
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割方法是挑选现有代码并将其移入自己的新服务
- en: A combination of the two
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者的结合
- en: Let's take a better look at them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一看它们。
- en: The replacement approach
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换方法
- en: Services are replaced in big chunks, only taking into account their external
    interfaces or effects. This black-box approach completely replaces existing functionality
    coding with an alternative from scratch. Once the new code is ready, it gets activated
    and the functionality in the old system is deprecated.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务以大块替换，只考虑它们的外部接口或影响。这种黑盒方法完全用全新的替代功能编码来替换现有功能。一旦新代码准备就绪，它就会被激活，旧系统中的功能就会被弃用。
- en: Note that this does not refer to a single deployment that replaces the whole
    system. This can be done partially, chunk by chunk. The basis of this approach
    is that it creates a new external service that aims to replace the old system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不是指替换整个系统的单个部署。这可以部分地、一块一块地完成。这种方法的基础是创建一个旨在替换旧系统的新外部服务。
- en: The pros of this approach are that it greatly helps in structuring the new service,
    as it doesn't inherit the technical debt, and allows for a fresh look at an old
    problem, with hindsight.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是它极大地帮助了新服务的结构化，因为它不会继承技术债务，并且可以重新审视旧问题，具有远见。
- en: The new service can also use new tools and doesn't need to continue with any
    old stack that is not aligned with the strategic views on the future direction
    of the technology in the company.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 新服务也可以使用新工具，并且不需要继续使用与公司技术未来方向不一致的旧堆栈。
- en: The problem with this approach is that it can be costly and can take a long
    time. For old services that are undocumented, replacing them could take a lot
    of effort. Also, this approach can only be applied to modules that are stable;
    if they are developed actively, trying to replace them with something else is
    moving the goalposts all the time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于成本高昂，可能需要很长时间。对于未经记录的旧服务，替换它们可能需要大量的工作。此外，这种方法只能应用于稳定的模块；如果它们在积极开发，试图用其他东西替换它们就会不断改变目标。
- en: This approach makes the most sense for old legacy systems that are small, or
    at least have a small part that performs limited functionality, and are developed
    in an old tech stack that's difficult or is no longer considered desirable to
    maintain.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于旧的遗留系统来说是最有意义的，这些系统很小，或者至少有一小部分执行有限的功能，并且是用难以维护或不再被认为是理想的技术堆栈开发的。
- en: The divide approach
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割方法
- en: If the system is well structured, maybe some parts of it can be cleanly split
    into its own system, maintaining the same code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统结构良好，也许它的一些部分可以干净地分割成自己的系统，保持相同的代码。
- en: In this case, creating a new service is more an exercise of copy-pasting and
    wrapping it around with the minimal amount of code to allow it to be executed
    independently and to interoperate with other systems, in other words, to structure
    its API around HTTP requests to have a standard interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建一个新的服务更多地是一个复制粘贴的练习，并用最少量的代码将其包装起来，以使其能够独立执行并与其他系统进行交互，换句话说，以围绕HTTP请求构建其API，以实现标准接口。
- en: If this approach can be used, it means that the code was already quite structured,
    which is fantastic news.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以使用这种方法，这意味着代码已经相当结构化，这是一个很棒的消息。
- en: 'The systems that are called to this part will also have to be adapted to make
    the call, not to internal code, but through HTTP calls. The good part is that
    this can be done in a few steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调用到这一部分的系统也必须进行调整，不是通过内部代码，而是通过HTTP调用。好处是这可以分几个步骤完成：
- en: Copy the code into its own microservice and deploy it.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码复制到自己的微服务中并部署它。
- en: The old calling system is using the old embedded code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧的调用系统正在使用旧的嵌入式代码。
- en: Migrate a call and check that the system is working fine.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移一个调用并检查系统是否正常工作。
- en: Iterate until all old calls are migrated to the new system.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代直到所有旧调用都迁移到新系统。
- en: Delete the divided code from the old system.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除旧系统中的分割代码。
- en: If the code is not so cleanly structured, we will need to change it first.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码结构不够清晰，我们需要先进行更改。
- en: Change and structured approach
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改和结构化方法
- en: If the monolith has been growing organically, it's not likely that all its modules
    will be cleanly structured. Some structures may exist, but maybe they're not the
    correct ones for our desired microservices division.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单体系统是有机增长的，那么它的所有模块都不太可能都是结构良好的。可能存在一些结构，但也许它们并不是我们期望的微服务划分的正确结构。
- en: To adapt the service, we will need to make some internal changes. These internal
    changes could be done iteratively until the service can be cleanly divided.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应服务，我们需要进行一些内部更改。这些内部更改可以通过迭代方式进行，直到服务可以干净地分割。
- en: These three approaches can be combined to generate full migration. The effort
    involved in each is not the same, as an easily divisible service will be able
    to make the move faster than a replacement of badly-documented legacy code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法可以结合起来生成完整的迁移。每种方法所涉及的工作量并不相同，因为一个容易分割的服务将能够比替换文档不好的遗留代码更快地进行迁移。
- en: 'In this phase of the project, the objective is to have a clear roadmap, that
    should analyze the following elements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的这个阶段，目标是拥有一个清晰的路线图，应该分析以下元素：
- en: An ordered plan of what microservices will be available first, taking into account
    how to deal with dependencies.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有序的微服务计划首先可用，考虑如何处理依赖关系。
- en: An idea of what the biggest pain points are, and whether working on them is
    a priority. Pain points are the elements that are worked with frequently and the
    current way of dealing with the monolith makes them difficult.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的痛点是什么，以及是否解决它们是一个优先事项。痛点是经常使用的元素，目前处理单体的方式使它们变得困难。
- en: What are the difficult points and the cans of worms? It's likely that there'll
    be some. Acknowledge that they exist and minimize their impact on other services.
    Note that they may be the same as the pain points, or not. The difficult points
    may be old systems that are very stable.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些困难点和问题？很可能会有一些。承认它们的存在，并将它们对其他服务的影响最小化。请注意，它们可能与痛点相同，也可能不同。困难点可能是非常稳定的旧系统。
- en: A couple of quick wins that will keep the momentum of the project going. Show
    the advantages to your teams and stakeholders quickly! This will also allow everyone
    to understand the new mode of operation you want to move to and start working
    that way.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些快速的胜利将保持项目的动力。 快速向您的团队和利益相关者展示优势！这也将使每个人都能理解您想要转移到的新操作模式，并开始以这种方式工作。
- en: An idea of the training that teams will require and what the new elements are
    that you want to introduce. Also, whether there are any skills lacking in your
    team – it's possible that you may plan to hire.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队需要的培训和您想要引入的新元素的概念。此外，您的团队是否缺乏任何技能 - 您可能计划招聘。
- en: Any team changes and ownership of the new services. It's important to consider
    feedback from the teams, so they can express their concerns over any oversights
    during the creation of the plan.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何团队变动和新服务的所有权。重要的是要考虑团队的反馈，这样他们就可以对计划的制定过程中的任何疏忽提出关切。
- en: 'For our specific example, the resulting plan will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的具体示例，结果计划将如下：
- en: As a prerequisite, a load balancer will need to be in front of the operation.
    This will be responsible for channeling requests to the proper microservice. Then,
    changing the configuration of this element, we will be able to route the requests
    toward the old monolith or any new microservice.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为先决条件，负载均衡器需要位于操作的前面。这将负责将请求引导到适当的微服务。然后，更改这个元素的配置，我们将能够将请求路由到旧的单体或任何新的微服务。
- en: After that, the static files will be served through their own independent service,
    which is an easy change. A static web server is enough, though it will be deployed
    as an independent microservice. This project will help in understanding the move
    to Docker.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，静态文件将通过它们自己的独立服务提供，这是一个简单的改变。一个静态的Web服务器就足够了，尽管它将部署为一个独立的微服务。这个项目将有助于理解转移到Docker。
- en: 'The code for authentication will be replicated in a new service. It will use
    a RESTful API to log in and generate a session, and to log out. The service will
    be responsible for checking whether a user exists or not, as well as adding them
    and removing them:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证的代码将被复制到一个新的服务中。它将使用RESTful API来登录和生成会话，以及退出登录。该服务将负责检查用户是否存在，以及添加和删除他们：
- en: The first idea was to check each session retrieved against the service, but,
    given that checking a session is a very common operation, we decided to generate
    a package, shared across the externally faced microservices, which will allow
    checking to see whether a session has been generated with our own service. This
    will be achieved by signing the session cryptographically and sharing the secret
    across our services. This module is expected not to change often, as it's a dependency
    for all the microservices. This makes the session one that does not need to be
    stored.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初的想法是对每个检索到的会话进行检查，但是，鉴于检查会话是一个非常常见的操作，我们决定生成一个包，在外部面向的微服务之间共享，这将允许检查会话是否已经使用我们自己的服务生成。这将通过对会话进行加密签名并在我们的服务之间共享密钥来实现。这个模块预计不会经常更改，因为它是所有微服务的依赖项。这使得会话不需要被存储。
- en: The Users Backend needs to be able to allow authentication using OAuth 2.0 schema,
    which will allow other external services, not based on web browsers, to authenticate
    and operate, for example, a mobile app.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户后端需要能够使用OAuth 2.0模式进行身份验证，这将允许其他不基于Web浏览器的外部服务进行身份验证和操作，例如移动应用程序。
- en: The Thoughts Backend will also be replicated as a RESTful API. This backend
    is quite simple at the moment, and it will include the search functionality.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thoughts后端也将被复制为一个RESTful API。目前，这个后端非常简单，它将包括搜索功能。
- en: After both backends are available, the current monolith will be changed, from
    calling the database directly, to use the RESTful APIs of the backends. After
    this is successfully done, the old deployment will be replaced with a Docker build
    and added to the load balancer.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个后端都可用之后，当前的单体架构将被更改，从直接调用数据库，改为使用后端的RESTful API。成功完成后，旧的部署将被Docker构建替换，并添加到负载均衡器中。
- en: The new API will be added externally to the load balancer and promoted as externally
    accessible. The company making the mobile app will then start integrating their
    clients.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的API将被外部添加到负载均衡器，并作为外部可访问的。制作移动应用程序的公司将开始集成他们的客户端。
- en: 'Our new architecture schema is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新架构图如下：
- en: '![](assets/4eebde2f-2787-40c3-855e-855bb045daf0.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4eebde2f-2787-40c3-855e-855bb045daf0.png)'
- en: Note that the HTML frontend will use the same APIs that are available externally.
    This will validate that the calls are useful, as we will use them first for our
    own client.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HTML前端将使用外部可用的相同API。这将验证调用是否有用，因为我们将首先为我们自己的客户端使用它们。
- en: 'This action plan can have measurable times and a schedule. Some technology
    options can be taken as well—in our case, the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行动计划可以有可衡量的时间和时间表。也可以采取一些技术选项——在我们的情况下，以下是：
- en: Each of the microservices will be deployed in its own Docker container ([https://www.docker.com/](https://www.docker.com/)).
    We will set up a Kubernetes cluster to orchestrate the different services.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务将部署在自己的Docker容器中（[https://www.docker.com/](https://www.docker.com/)）。我们将建立一个Kubernetes集群来编排不同的服务。
- en: We decided to make the new backend services in Flask ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)),
    using Flask-RESTPlus ([https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/))
    to generate a well-documented RESTful app and connect to the existing database
    with SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)).
    These tools are Python, but take a lighter approach than Django.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们决定使用Flask（[https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)）制作新的后端服务，使用Flask-RESTPlus（[https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)）生成一个文档完备的RESTful应用，并使用SQLAlchemy（[https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)）连接到现有的数据库。这些工具都是Python的，但比Django更轻量级。
- en: The backend services will be served using the uWSGI server ([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端服务将使用uWSGI服务器提供（[https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)）。
- en: The static files will be served using NGINX ([https://www.nginx.com/](https://www.nginx.com/)).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态文件将使用NGINX（[https://www.nginx.com/](https://www.nginx.com/)）提供。
- en: NGINX will also be used as a load balancer to control the inputs.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX也将被用作负载均衡器来控制输入。
- en: HTML frontend will continue to use Django ([https://www.djangoproject.com/](https://www.djangoproject.com/)).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML前端将继续使用Django（[https://www.djangoproject.com/](https://www.djangoproject.com/)）。
- en: The teams are OK with proceeding with these tech stacks, and are looking forward
    to learning some new tricks!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 团队们同意继续使用这些技术栈，并期待学习一些新的技巧！
- en: Executing the move
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行转移
- en: The final step is to execute the carefully devised plan to start moving from
    the outdated monolith to the new promised land of microservices!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是执行精心设计的计划，开始从过时的单体架构转移到微服务的新天堂！
- en: But this stage of the trip can actually be the longest and most difficult—especially
    if we want to keep the services running and not have outages that interrupt our
    business.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个阶段的旅程实际上可能是最漫长和最困难的，特别是如果我们想保持服务运行而不会出现中断业务的情况。
- en: The single most important idea during this phase is **backward compatibility**.
    This means that the system is still behaving as the old system was from an external
    point of view. If we are able to behave like that, we can transparently change
    our internal operation while our customers are able to continue their operations
    uninterrupted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段最重要的想法是**向后兼容性**。这意味着系统在外部观点上仍然像旧系统一样运行。如果我们能够做到这一点，我们就可以在客户继续操作的同时透明地改变我们的内部操作。
- en: That's obviously more easy to say than to do and sometimes has been referred
    to as starting a race with a Ford T and ending it with a Ferrari, changing every
    single piece of it without stopping. The good news is that software is so absolutely
    flexible and malleable that it is actually possible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然更容易说而不易做，有时被称为用福特T型车开始比赛，最后用法拉利结束，在不停车的情况下更换每一个部件。好消息是，软件是如此灵活和可塑的，实际上是可能的。
- en: Web services' best friend – the load balancer
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务的好朋友-负载均衡器
- en: A load balancer is a tool that allows distributing HTTP requests (or other kinds
    of network requests) among several backend resources.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器是一种工具，允许在多个后端资源之间分发HTTP请求（或其他类型的网络请求）。
- en: 'The main operation of a load balancer is to allow traffic to be directed to
    a single address to be distributed among several identical backend servers that
    can spread the load and achieve better throughput. Typically, the traffic will
    be distributed through round-robin, that is, sequentially across all of them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器的主要操作是允许将流量定向到单个地址，然后分发到几个相同的后端服务器，以分担负载并实现更好的吞吐量。通常，流量将通过轮询分发，即依次分布在所有服务器上：
- en: '![](assets/a75b18b4-6475-4d39-b42c-3db3a565acf2.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a75b18b4-6475-4d39-b42c-3db3a565acf2.png)'
- en: 'First one worker, then the other, consecutively:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先一个工作人员，然后另一个，依次进行：
- en: '![](assets/67724773-c5dd-4193-8803-14b43fd27f9b.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67724773-c5dd-4193-8803-14b43fd27f9b.png)'
- en: That's the normal operation. But it can also be used to replace services. The
    load balancer ensures that each request goes cleanly to one worker or another.
    The services in the pool of workers can be different, so we can use it to cleanly
    make the transition between one version of the web service and another.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常操作。但它也可以用来替换服务。负载均衡器确保每个请求都干净地发送到一个工作人员或另一个工作人员。工作人员池中的服务可以是不同的，因此我们可以使用它来干净地在Web服务的一个版本和另一个版本之间进行过渡。
- en: For our purposes, a group of old web services that are behind a load balancer
    can add one or more replacement services that are backward compatible, without
    interrupting the operation. The new service replacing the old one will be added
    in small numbers (maybe one or two workers) to split the traffic in a reasonable
    configuration, and ensure that everything is working as expected. After the verification,
    replace it completely by stopping sending new requests to the old services, draining
    them, and leaving only the new servers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，位于负载均衡器后面的一组旧的Web服务可以添加一个或多个向后兼容的替代服务，而不会中断操作。替换旧服务的新服务将以较小的数量（也许是一个或两个工作人员）添加到合理的配置中，确保一切都按预期工作。验证后，通过停止向旧服务发送新请求、排空它们，只留下新服务器来完全替换它。
- en: If done in a quick movement, like when deploying a new version of a service,
    this is called a rolling update, so the workers are replaced one by one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以快速的方式进行，比如部署服务的新版本，这被称为滚动更新，因此工作人员逐个替换。
- en: But for migrating from the old monolith to the new microservices, a slower pace
    is wiser. A service can live for days in a split of 5%/95% so any unexpected error
    will appear only a twentieth of the time, before moving to 33/66, then 50/50,
    then 100% migrated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于从旧的单体架构迁移到新的微服务，更慢的步伐更明智。一个服务可以在5%/95%的分裂中生存几天，因此任何意外错误只会出现五分之一的时间，然后转移到33/66，然后50/50，然后100%迁移。
- en: A highly loaded system with good observability will be able to detect problems
    very quickly and may only need to wait minutes before proceeding. Most legacy
    systems will likely not fall into this category, though.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 具有良好可观测性的高负载系统将能够非常快速地检测问题，并且可能只需要等待几分钟就可以继续。大多数传统系统可能不会属于这一类别。
- en: Any web server capable of acting in reverse proxy mode, such as NGINX, is capable
    of working as a load balancer, but, for this task, probably the most complete
    option is HAProxy ([http://www.haproxy.org/](http://www.haproxy.org/)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 任何能够以反向代理模式工作的Web服务器，如NGINX，都能够作为负载均衡器工作，但对于这个任务，可能最完整的选项是HAProxy（[http://www.haproxy.org/](http://www.haproxy.org/)）。
- en: HAProxy is specialized in acting as a load balancer in situations of high availability
    and high demand. It's very configurable and accepts traffic from HTTP to lower-level
    TCP connection if necessary. It also has a fantastic status page that will help
    to monitor the traffic going through it, as well as taking fast action such as
    disabling a failing worker.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy专门用于在高可用性和高需求的情况下充当负载均衡器。它非常易于配置，并且在必要时接受从HTTP到更低级别的TCP连接的流量。它还有一个出色的状态页面，可以帮助监视通过它的流量，并采取快速行动，如禁用失败的工作人员。
- en: Cloud providers such as AWS or Google also offer integrated load balancer products.
    They are very interesting to work from the edge of our network, as their stability
    makes them great, but they won't be as configurable and easy to integrate into
    your operating system as HAProxy. For example, the offering by Amazon Web Services
    is called **Elastic Load Balancing** (**ELB**)—[https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商如AWS或Google也提供集成的负载均衡器产品。它们非常适合从我们网络的边缘工作，因为它们的稳定性使它们非常出色，但它们不会像HAProxy那样易于配置和集成到您的操作系统中。例如，亚马逊网络服务提供的产品称为弹性负载均衡（ELB）-
    [https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/)。
- en: 'To migrate from a traditional server with an external IP referenced by DNS
    and put a load balancer in the front, you need to follow the following procedure:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要从具有由DNS引用的外部IP的传统服务器迁移到前端的负载均衡器，您需要遵循以下程序：
- en: Create a new DNS to access the current system. This will allow you to refer
    to the old system independently when the transition is done.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的DNS来访问当前系统。这将允许你在过渡完成后独立地引用旧系统。
- en: Deploy your load balancer, configured to serve the traffic to your old system
    on the old DNS. This way, accessing either the load balancer or the old system,
    the request will ultimately be delivered in the same place. Create a DNS just
    for the load balancer, to allow referring specifically to it.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署你的负载均衡器，配置为在旧DNS上为你的旧系统提供流量服务。这样，无论是访问负载均衡器还是旧系统，请求最终都将在同一个地方交付。创建一个专门用于负载均衡器的DNS，以便特别引用它。
- en: 'Test that sending a request to the load balancer directed to the host of the
    old DNS works as expected. You can send a request using the following `curl` command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试向负载均衡器发送请求，指向旧DNS主机是否按预期工作。你可以使用以下`curl`命令发送请求：
- en: '[PRE0]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Change the DNS to point to the load balancer IP. Changing DNS registries takes
    time, as caches will be involved. During that time, no matter where the request
    is received, it will be processed in the same way. Leave this state for a day
    or two, to be totally sure that every possible cache is outdated and uses the
    new IP value.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改DNS指向负载均衡器IP。更改DNS注册表需要时间，因为会涉及缓存。在此期间，无论请求从何处接收，都将以相同的方式处理。保持这种状态一两天，以确保每个可能的缓存都已过时并使用新的IP值。
- en: The old IP is no longer in use. The server can (and should) be removed from
    the externally facing network, leaving only the load balancer to connect. Any
    request that needs to go to the old server can use its specific new DNS.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧IP不再使用。服务器可以（也应该）从外部网络中删除，只留下负载均衡器连接。需要前往旧服务器的任何请求都可以使用其特定的新DNS。
- en: Note that a load balancer like HAProxy can work with URL paths, meaning it can
    direct different paths to different microservices, something extremely useful
    in the migration from a monolith.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像HAProxy这样的负载均衡器可以使用URL路径工作，这意味着它可以将不同的路径指向不同的微服务，在从单体架构迁移中非常有用。
- en: Because a load balancer is a single point of failure, you'll need to load balance
    your load balancer. The easiest way of doing it is creating several identical
    copies of HAProxy, as you'd do with any other web service, and adding a cloud
    provider load balancer on top.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为负载均衡器是单点故障，你需要对负载均衡器进行负载均衡。最简单的方法是创建几个相同的HAProxy副本，就像你对任何其他网络服务所做的那样，并在顶部添加一个云提供商的负载均衡器。
- en: Because HAProxy is so versatile and fast, when properly configured, you can
    use it as a central point to redirect your requests—in true microservices fashion!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HAProxy如此灵活和快速，当正确配置时，你可以将其用作重定向请求的中心点——以真正的微服务方式！
- en: Keeping the balance between new and old
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持新旧之间的平衡
- en: Plans are just plans, and a move to microservices is something to do for internal
    benefits, as it requires investment until external improvements can be shown in
    the shape of a better pace of innovation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 计划只是计划，而转向微服务是为了内部利益而做的事情，因为它需要投资，直到外部改进可以以更好的创新速度的形式显示出来。
- en: This means that there'll be external pressure on the development team to add
    new features and requirements on top of the normal operation of the company. Even
    if we make this migration to move faster, there's an initial stage where you'll
    move slower. After all, changing things is difficult and you will need to overcome
    the initial inertia.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着开发团队将面临外部压力，要求他们在公司正常运营的基础上添加新功能和要求。即使我们进行这次迁移以加快速度，也会有一个初始阶段，你会移动得更慢。毕竟，改变是困难的，你需要克服最初的惯性。
- en: The migration will take three rough phases.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移将经历三个大致阶段。
- en: The pilot phase – setting up the first couple of microservices
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试点阶段——设置前两个微服务
- en: 'A lot of infrastructures may be required before seeing the first deployment.
    This phase can be difficult to overcome and it''s the one that needs the biggest
    push. A good strategy for that is to put together a dedicated team of **enthusiasts**
    in the new microservice architecture and allow them to lead the development. They
    can be people that have been involved in the design, or maybe they like the new
    technologies or have worked with Docker and Kubernetes on side projects. Not every
    developer in your team will be excited about changing the way you operate, but
    some of them will be. Use their passion to start the project and take care of
    it in its initial steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到第一个部署之前可能需要大量基础设施。这个阶段可能难以克服，也是需要最大推动力的阶段。一个好的策略是组建一个专门的新微服务架构的热情团队，并允许他们领导开发。他们可以是参与设计的人，或者他们喜欢新技术，或者他们在副业项目中使用过Docker和Kubernetes。你团队中的每个开发人员都不会对改变运营方式感到兴奋，但其中一些人会。利用他们的热情来启动项目，并在其初步阶段加以照顾。
- en: Start **small**—there'll be enough work to set up the infrastructure. The objective
    in this phase is to learn the tools, set up the platform, and adjust how to work
    with the new system. The aspect of teamwork and coordination is important and
    starting with a small team allows us to test a couple of approaches and iterate
    to be sure that they work.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从小处着手——建立基础设施将会有足够的工作量。这个阶段的目标是学习工具，建立平台，并调整如何使用新系统。团队合作和协调的方面很重要，从一个小团队开始可以让我们测试几种方法，并迭代确保它们有效。
- en: Choose **non-critical services**. At this stage, there are a lot of things that
    can go wrong. Be sure that a problem does not have a huge impact on operations
    or revenue.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择非关键服务。在这个阶段，有很多事情可能会出错。确保问题不会对运营或收入产生巨大影响。
- en: Be sure to maintain **backward compatibility**. Substitute parts of the monolith
    with new services, but do not try to change the behavior at the same time, unless
    they are obvious bugs.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保保持向后兼容性。用新服务替换单体的部分，但不要试图同时改变行为，除非它们是明显的错误。
- en: If there's a new feature that can be implemented as a new microservice, take
    the chance to go straight for the new approach, but be sure that the risk in extra
    time to deliver, or bugs, is worth it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个新功能可以作为新的微服务实现，抓住机会直接采用新方法，但确保额外花费的时间或错误的风险是值得的。
- en: The consolidation phase – steady migration to microservices
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巩固阶段——稳步迁移到微服务
- en: After the initial setup, other teams start working with the microservices approach.
    This expands the number of people dealing with containers and new deployments,
    so the initial team will need to give them support and training.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始设置之后，其他团队开始采用微服务方法。这扩大了处理容器和新部署的人数，因此初始团队需要给予他们支持和培训。
- en: Training will be a critical part of the migration project—be sure to allocate
    enough time. While training events such as workshops and courses can be very useful
    to kickstart the process, constant support from experienced developers is invaluable.
    Appoint developers as a point of contact for questions, and tell them explicitly
    that their job is to ensure that they answer questions and help other developers.
    Make the supporting team meet up regularly to share concerns and improvements
    on the knowledge transfer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 培训将是迁移项目的关键部分——确保分配足够的时间。虽然培训活动如研讨会和课程对于启动过程非常有用，但来自经验丰富的开发人员的持续支持是无价的。指定开发人员作为问题的联系点，并明确告诉他们，他们的工作是确保他们回答问题并帮助其他开发人员。让支持团队定期会面，分享对知识转移的关注和改进。
- en: 'Spreading knowledge is one of the main focuses in this phase, but there are
    another two: clarify and standardize the process and maintain an adequate pace
    of migrating the microservices.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，传播知识是主要关注的之一，但还有另外两个：澄清和标准化流程以及保持适当的微服务迁移速度。
- en: Documenting standards will be helpful to give clarity and direction. Create
    checkpoints to make very explicit requirements across the board, so it's very
    clear when a microservice is ready for production. Create adequate channels for
    feedback, to be sure that the process can be improved.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化文档将有助于明确和指导。创建检查点，使各种要求非常明确，这样就很清楚微服务何时可以投入生产。创建充分的反馈渠道，以确保流程可以得到改进。
- en: During this time, the pace of migration can be increased because a lot of uncertainties
    and problems have already been ironed out; and because the development will be
    done in parallel. You should try to work on any new feature in a microservice
    way, though compromises may need to be taken. Be sure to keep the motivation and
    follow the plan.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，迁移的速度可以加快，因为许多不确定性和问题已经得到解决；并且开发将同时进行。您应该尝试以微服务的方式处理任何新功能，尽管可能需要做出妥协。一定要保持动力并遵循计划。
- en: The final phase – the microservices shop
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后阶段 - 微服务商店
- en: The monolith has been split, and the architecture is now microservices. There
    may be remains of the monolith that are deemed to have lower priority. Any new
    feature is implemented in the microservices style.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用已经拆分，架构现在是微服务。可能会有被视为优先级较低的单体应用的残余部分。任何新功能都是以微服务方式实现的。
- en: While desirable, it may not be realistic to migrate absolutely everything from
    the monolith. Some parts may take a long time to migrate because they are especially
    difficult to migrate or they deal with strange corners of your company. If that's
    the case, at least clearly define the boundaries and limit their action radius.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然希望如此，但可能不现实将一切都从单体应用迁移过来。一些部分可能需要很长时间才能迁移，因为它们特别难以迁移，或者涉及公司的奇怪角落。如果是这种情况，至少要明确定义边界并限制其行动范围。
- en: This phase is where the teams can take full ownership of their microservices
    and start making tests and innovations such as changing the programming language.
    Architecture can change as well, and microservices can be split or joined. Have
    clear boundaries defining what the agreed requirements for microservices are,
    but allow freedom within them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段是团队可以完全拥有他们的微服务并开始进行测试和创新，比如改变编程语言。架构也可以改变，微服务可以拆分或合并。明确定义微服务的约定要求的边界，但允许在其中自由发挥。
- en: Teams will be well-established and the process will run smoothly. Keep an eye
    on good ideas coming from different teams and be sure to spread the word.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 团队将得到很好的建立，并且流程将顺利进行。留意来自不同团队的好主意，并确保传播开去。
- en: Congratulations! You did it!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你做到了！
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw what the differences are between the traditional monolith
    approach and microservices architecture, and how microservices allow us to scale
    development across several teams and improve the delivery of quality software.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了传统的单体应用方法和微服务架构之间的区别，以及微服务如何使我们能够跨多个团队扩展开发，并改善高质量软件的交付。
- en: 'We discussed the main challenges that are faced during a transition from a
    monolith to microservices and how to perform the change in different stages: analyzing
    the current system, measuring to validate our assumptions, creating a plan to
    split the monolith in a controlled way, and tactics to successfully perform the
    move.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了从单体应用到微服务过渡中面临的主要挑战，以及如何在不同阶段执行变更：分析当前系统，测量以验证我们的假设，创建以受控方式拆分单体应用的计划，以及成功执行迁移的策略。
- en: Though this chapter was written in a technology-agnostic way, we've learned
    why Docker containers are a great way of implementing microservices, something
    that will be explored in the following chapters. You also now know how using a
    load balancer helps to maintain backward compatibility and deploy new services
    in an uninterrupted way.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章是以技术中立的方式编写的，但我们已经了解了为什么Docker容器是实现微服务的一种很好的方式，这将在接下来的章节中探讨。您现在也知道使用负载均衡器如何帮助维护向后兼容性并以不间断的方式部署新服务。
- en: You learned how to structure a plan to divide a monolith into smaller microservices.
    We described an example of such a process and an example of a monolith and how
    it will be divided. We'll see how to do this in detail in the following chapters.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何制定计划将单体架构划分为更小的微服务。我们描述了这样一个过程的示例以及单体架构的示例以及如何进行划分。我们将在接下来的章节中详细了解如何做到这一点。
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a monolith?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单体架构？
- en: What are some of the problems of monoliths?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体架构存在哪些问题？
- en: Describe the microservice architecture.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述微服务架构。
- en: Which is the most important property of microservices?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构最重要的特性是什么？
- en: What are the main challenges to overcome in a migration from a monolith to microservices?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单体架构迁移到微服务架构的主要挑战是什么？
- en: What are the basic steps to make such a migration?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行这样的迁移的基本步骤是什么？
- en: Describe how to use a load balancer to migrate from an old server to a new one
    without interrupting the system.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何使用负载均衡器将旧服务器迁移到新服务器，而不会中断系统。
- en: Further reading
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can learn more about systems architecture and how to divide and structure
    complex systems in the books *Architectural Patterns* ([https://www.packtpub.com/application-development/architectural-patterns](https://www.packtpub.com/application-development/architectural-patterns))
    and *Software Architect's Handbook* ([https://www.packtpub.com/application-development/software-architects-handbook](https://www.packtpub.com/application-development/software-architects-handbook))[.](https://prod.packtpub.com/application-development/architectural-patterns)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍《Architectural Patterns》（[https://www.packtpub.com/application-development/architectural-patterns](https://www.packtpub.com/application-development/architectural-patterns)）和《Software
    Architect's Handbook》（[https://www.packtpub.com/application-development/software-architects-handbook](https://www.packtpub.com/application-development/software-architects-handbook)）中了解更多关于系统架构以及如何划分和构建复杂系统的知识。
