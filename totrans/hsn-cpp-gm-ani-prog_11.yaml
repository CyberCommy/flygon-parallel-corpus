- en: '*Chapter 11*: Optimizing the Animation Pipeline'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have written an entire animation system that can load a standard
    file format, gLTF, and perform skinning on either the CPU or GPU. The animation
    system performs well enough for most simple animations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will explore the ways to optimize the animation system
    to make it faster and less resource-intensive. This involves exploring alternative
    ways to perform skinning, improving the speed of sample animation clips, and revisiting
    how matrix palettes are generated.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these topics is explored on its own, and you can choose to implement
    as few or as many of these optimizations as you wish. All of them are simple and
    can be used to replace a less optimal version of the pipeline with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-generating the skin matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the skin pallette in a texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster sampling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pose palette generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring `Pose::GetGlobalTransform`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-generating the skin matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the bigger problems with `mat4` object takes up four uniform slots and
    the skinned vertex shader currently has two matrix arrays that have 120 elements
    each. That comes to a total of 960 uniform slots, which is excessive.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens with those two matrix arrays in the vertex shader? They get multiplied
    together, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One easy optimization here is to combine the `pose * invBindPose` multiplication
    so that the shader only needs one array. This does mean that some of the skinning
    process is moved back to the CPU, but this change clears up 480 uniform slots.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the skin matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating the skin matrix doesn't need an API call—it's simple. Generate a
    matrix palette from the current animated pose using the `GetMatrixPalette` function
    of the `Pose` class. Then, multiply each matrix in the palette by the inverse
    bind pose matrix of the same index.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the responsibility of the code that displays the mesh to calculate these
    matrices. For example, a simple update loop might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, an animation clip was sampled into a pose. The
    pose was converted into a vector of matrices. Each matrix in that vector was then
    multiplied by the inverse bind pose matrix of the same index. The resulting vector
    of matrices is the combined skin matrix.
  prefs: []
  type: TYPE_NORMAL
- en: If the mesh is CPU skinned, this is a good place to call the `CPUSkin` function.
    This function needs to be re-implemented to work with a combined skin matrix.
    If the mesh is GPU skinned, the shader needs to be edited so that it only uses
    one matrix array, and the rendering code needs to be updated to only pass one
    uniform array.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will explore how to re-implement the `CPUSkin`
    function so that it works with the combined skin matrix. This will speed up the
    CPU skinning process a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: CPU skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a new skinning method that respects the pre-multiplied skin matrix.
    This function takes a reference to a vector of matrices. Each position is transformed
    by the combined skin matrix of all four of the bones that affect it. Those four
    results are then scaled and added together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following CPU skinning function to `Mesh.cpp`. Don''t forget to add
    the function declaration to `Mesh.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start implementing the `CPUSkin` function by making sure the mesh is valid.
    A valid mesh has at least one vertex. Make sure that the `mSkinnedPosition` and
    `mSkinnedNormal` vectors are large enough to hold all the vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, loop through every vertex in the mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform each vertex by the animated pose four times—once for each joint that
    influences the vertex. To find the skinned vertex, scale each of the transformed
    vertices by the appropriate weight and add together the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the skinned normal of the vertex in the same way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish off the function by uploading the skinned vertex positions and the skinned
    vertex normals to the position and normal attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The core skinning algorithm remains the same; the only thing that changes is
    how the transformed position is generated. Instead of having to combine the animated
    pose and the inverse bind pose, this function can now just use the already-combined
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will explore how to move this skinning function into
    a vertex shader. Combining the animated and inverse bind poses is still done on
    the CPU, but skinning the actual vertices can be implemented in a vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: GPU skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing pre-multiplied skin-matrix skinning in a vertex shader is simple.
    Replace the input uniforms for the pose and inverse bind pose with the new pre-multiplied
    skin pose. Generate the skin matrix using this new uniform array. That's all there
    is to it—the rest of the skinning pipeline remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `preskinned.vert`, to implement the new pre-skinned vertex
    shader in. Copy the contents of `skinned.vert` into this new file. Follow these
    steps to modify the new shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The old skinned vertex shader has uniforms for pose and inverse bind pose.
    Both uniforms are arrays of matrices. Remove these uniforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace them with the new `animated` uniform. This is a single array of matrices
    and each element in the array contains the `animated` pose and the inverse bind
    pose matrices multiplied together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find where the skin matrix is generated. The code for generating the
    skin matrix looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with the new `animated` uniform. For each joint that affects the
    vertex, scale the `animated` uniform matrix by the appropriate weight and sum
    the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the shader stays the same. The only thing you need to update is
    the uniforms that the shader takes and how the `skin` matrix is generated. When
    rendering, the `animated` matrix can be set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the CPU skinning implementation and the GPU skinning
    implementation are different. The CPU implementation transforms the vertex four
    times, then scales and sums the results. The GPU implementation scales and sums
    the matrices and only transforms the vertex once. Both implementations are valid
    and they both produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will explore how to avoid using uniform matrix
    arrays for skinning.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the skin palette in a texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pre-generating the skin matrix cuts the number of uniform slots that the skinned
    shader needs in half, but it's possible to reduce the number of uniform slots
    needed to just one. This can be done by encoding the pre-generated skin matrix
    in a texture and reading that texture in the vertex shader instead of in a uniform
    array.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this book, you have only dealt with the `RGB24` and `RGBA32` textures.
    In these formats, the three or four components of a pixel are encoded using 8
    bits per component. This can only hold 256 unique values. These textures do not
    provide the amount of precision needed to store floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There is another texture format that can be useful here—a `FLOAT32` texture.
    With this texture format, each component of a vector gets a full 32-bit floating-point
    number to back it, giving you full precision. This texture can be sampled with
    a special sampler function that doesn't normalize the data. The `FLOAT32` texture
    can be treated as a buffer that the CPU can write to and the GPU can read from.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this method is that the number of required uniform slots becomes
    just one—the uniform slot that is needed is the sampler for the `FLOAT32` texture.
    The downside is speed. Having to sample a texture for every vertex is more expensive
    than a quick uniform array lookup. Remember, each of these sample lookups needs
    to return several 32-bit floating-point numbers. That is a lot of data to transfer.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover the implementation of a texture to store the skin matrices
    here, as there is a large section dedicated to that topic in *Chapter 15*, *Rendering
    Large Crowds with Instancing*, which includes the full code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Faster sampling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current animation-clip sampling code performs well, so long as each animation
    lasts under 1 second. With multiple minute-long animation clips, such as a cutscene,
    the animation system''s performance starts to suffer. Why does the performance
    worsen with longer animations? The culprit is the following bit of code in the
    `Track::FrameIndex` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The presented loop goes through every frame in the track. If an animation has
    a lot of frames, the performance starts to get worse. Remember, this bit of code
    is executed for each animated component of each animated bone in an animation
    clip.
  prefs: []
  type: TYPE_NORMAL
- en: This function currently does a linear search, but it can be optimized with a
    more efficient search. Since time only ever increases, performing a binary search
    is a natural optimization to use here. However, binary search isn't the best optimization.
    It's possible to turn this loop into a constant lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Sampled animations have a uniform cost to play back, regardless of length. They
    time every frame at a known sampling interval, and finding the correct frame index
    is just a matter of normalizing the provided time and moving it into the sampled
    interval range. Unfortunately, sampling an animation such as this takes up a lot
    of memory.
  prefs: []
  type: TYPE_NORMAL
- en: What if you still sampled the animation track at given intervals, but instead
    of containing a full pose, each interval points to the keyframes that are to its
    left and right? With this approach, the additional memory overhead is minimal
    and finding the correct frame is constant.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the Track class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to handle optimizing the `Track` class. You can either create
    a new class that has most of the `Track` class's functionality and maintains a
    lookup table for known sample times or extend the `Track` class. This section
    takes the latter approach—we will extend the `Track` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `FastTrack` subclass contains a vector of unsigned integers. The `Track`
    class is sampled at uniform time intervals. For each time interval, the frame
    on the left of the play head (the frame right before time) is recorded into this
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'All new code is added to the existing `Track.h` and `Track.cpp` files. Follow
    these steps to implement the `FastTrack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `FrameIndex` member function of the `Track` class and mark it as `virtual`.
    This change allows the new subclass to re-implement the `FrameIndex` function.
    The updated declaration should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class, `FastTrack`, that inherits from `Track`. The `FastTrack`
    class contains a vector of unsigned integers—the overloaded `FrameIndex` function
    and a function to populate the vector of unsigned integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `FastTrack` class easier to work with, use typedef to create aliases
    for scalar, vector and quaternion types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the .`cpp` file, add a template declaration for the scalar, vector, and
    quaternion fast tracks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the `FastTrack` class is a subclass of `Track`, the existing APIs all
    work unchanged. The performance gain from implementing track sampling this way
    is greater when the animation in question has more frames. In the next section,
    you will learn how to build the index lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UpdateIndexLookupTable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UpdateIndexLookupTable` function is responsible for populating the `mSampledFrames`
    vector. This function needs to sample the animation at fixed time intervals and
    record the frame before the animation time for each interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many samples should the `FastTrack` class contain? This question is very
    context-dependent as different games have different requirements. For the context
    of this book, 60 samples per second should be enough:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start implementing the `UpdateIndexLookupTable` function by making sure that
    the track is valid. A valid track will have at least two frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find the number of samples that are needed. Since the class has `60`
    samples for every second of animation, multiply the duration by `60`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For each sample, find the time of the sample along the track. To find the time,
    multiply the normalized iterator by the animation duration and add the start time
    of the animation to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s time to find the frame index for each given time. Find the frame
    that comes before the sampling time for this iteration and record it in the `mSampledFrames`
    vector. If the sampled frame is the last frame, return the index right before
    the last index. Remember, the `FrameIndex` function should never return the last
    frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateIndexLookupTable` function is intended to be called at load time.
    It could be optimized to be faster by remembering the last used index of the inner
    `j` loop since, on each `i` iteration, the frame index only increases. In the
    next section, you will learn how to implement `FrameIndex` to use the `mSampledFrames`
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FrameIndex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FrameIndex` function is responsible for finding the frame right before
    a given time. The optimized `FastTrack` class uses a lookup array instead of looping
    through every frame of the track. All input times have a very similar performance
    cost. Follow these steps to override the `FrameIndex` function in the `FastTrack`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start implementing the `FrameIndex` function by making sure that the track
    is valid. A valid track must have at least two or more frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make sure the requested sample time falls between the start and end times
    of the track. If the track is looping, use `fmodf` to keep it in a valid range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the track is not looping, clamp to the first or next to last frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the normalized sample time and frame index. The frame index is the normalized
    sample time scaled by the number of samples. If the index is invalid, return `-1`;
    otherwise, return the frame that the index points to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `FrameIndex` function is almost always called with a valid time since it's
    a protected helper function. This means the time it takes to find the index of
    a frame is uniform, regardless of the number of frames in the track. In the next
    section, you will learn how to convert an unoptimized `Track` class into an optimized
    `FastTrack` class.
  prefs: []
  type: TYPE_NORMAL
- en: Converting tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that `FastTrack` exists, how do you create it? You could either create
    a new load function that loads a `FastTrack` class instead of `Track`. Alternatively,
    you could create a function that converts an existing `Track` class into a `FastTrack`
    class. This chapter takes the latter approach. Follow these steps to create a
    function that converts the `Track` objects into the `FastTrack` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `OptimizeTrack` function in `FastTrack.h`. The function is templated.
    It takes the same template types as `Track`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the template specializations of the `OptimizeTrack` function for all
    three types that track to `FastTrack.cpp`. This means declaring specializations
    that work with the scalar, vector 3, and quaternion tracks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `OptimizeTrack` function, resize the resulting track so that
    it is the same size as the input track and match the interpolation. The overloaded
    `[]` operator function can be used to copy the per-frame data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It's not enough to just optimize the `Track` class into `FastTrack`. The `TransformTrack`
    class needs to change as well. It needs to contain the new, optimized `FastTrack`
    class. In the next section, you will change the `TransformTrack` class so that
    it is templated and can contain either `Track` or `FastTrack`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating FastTransformTrack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-level structures that use the `Track` class, such as `TransformTrack`,
    need to accommodate for the new `FastTrack` subclass. The `FastTrack` class has
    the same signature as the `Track` class. Because the signature of the class is
    the same, it's easy to template the `TransformTrack` class so that it can use
    either of these classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will rename the `TransformTrack` class to `TTransformTrack`
    and template the class. Then, you will `typedef` template specializations as `TransformTrack`
    and `FastTransformTrack`. This way, the `TransformTrack` class stays the same
    and the optimized transform track uses all the same code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the name of the `TransformTrack` class to `TTransformTrack` and template
    the class. The template takes two arguments—the type of vector track and the type
    of quaternion track to use. Update the `mPosition`, `mRotation`, and `mScale`
    tracks to use the new templated types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Typedef this class into `TransformTrack`, with `VectorTrack` and `QuaternionTrack`
    for arguments. Typedef it again into `FastTransformTrack`, with `FastVectorTrack`
    and `FastQuaternionTrack` as template arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the optimization function that converts `TransformTrack` into `FastTransformTrack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add template specifications for both `typedef` functions in `TransformTrack.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `OptimizeTransformTrack` function. Copy the track ID, then copy
    the individual tracks by value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because `OptimizeTransformTrack` copies the actual track data by value, it can
    be a little slow. This function is intended to be called during initialization.
    In the next section, you will template the `Clip` class, similar to how you did
    with the `Transform` class, to create `FastClip`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating FastClip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user of this animation system interacts with the `Clip` objects. To accommodate
    the new `FastTrack` class, the `Clip` class is similarly templated and split into
    `Clip` and `FastClip`. You will implement a function to convert the `Clip` objects
    into the `FastClip` objects. Follow these steps to template the `Clip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the name of the `Clip` class to `TClip` and template the class. The
    template only takes one type—the type of transform track that the `TClip` class
    contains. Change the type of `mTracks` and the return type of `[] operator` so
    that it is the template type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Typedef  `TClip` with a `TransformTrack` type as `Clip`. Typedef `TClip` with
    a `FastTransformTrack` type as `FastClip`. This way, the `Clip` class doesn''t
    change and the `FastClip` class can reuse all the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a function to convert a `Clip` object into a `FastClip` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare template specializations of these typedefed classes in `Clip.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `OptimizeClip` function, copy the name and looping value of
    the input clip. For each joint in the clip, call the `OptimizeTransformTrack`
    function on its track. Don''t forget to calculate the duration of the new `FastClip`
    object before returning a copy of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As with the rest of the conversion functions, `OptimizeClip` is only intended
    to be called at initialization time. In the following section, you will explore
    how to optimize the `Pose` palette generation.
  prefs: []
  type: TYPE_NORMAL
- en: The Pose palette generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final optimization you should think about is the process of generating
    a matrix palette from `Pose`. If you look at the `Pose` class, the following bit
    of code converts a pose into a linear array of matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By itself, this function isn't too bad, but the `GetGlobalTransform` function
    loops through every joint all the way up the specified joints transform chain
    until the root joint. This means the function wastes a considerable amount of
    time finding matrices for transforms that it has already found the matrices for
    during a previous iteration.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, you need to make sure that the order of the joints in the `Pose`
    class is ascending. That is, all the parent joints must have a lower index than
    their child joints in the `mJoints` array.
  prefs: []
  type: TYPE_NORMAL
- en: Once this order is set, you can iterate through all the joints and know that
    the parent matrix of the joint at the current index has already been found. This
    is because all the parent elements have a lower index than their children. To
    combine the local matrix of this joint with the global matrix of its parent joint,
    you just have to multiply the previously found world matrix and local matrix together.
  prefs: []
  type: TYPE_NORMAL
- en: There is no guarantee that the input data can be trusted to have the joints
    listed in this specific order. To fix this, you need to write some code to re-arrange
    the joints of a `Pose` class. In the next section, you will learn how to improve
    the `GetMatrixPalette` function so that it uses the optimized method if it can
    and falls back to the unoptimized method if it can't.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the GetMatrixPalette function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will modify the `GetMatrixPalette` function to pre-cache
    global matrices if the parent index of the current joint is lower than the joint.
    If this assumption is ever broken, the function needs to fall back into the slower
    calculation mode.
  prefs: []
  type: TYPE_NORMAL
- en: There will be two loops in the `GetMatrixPalette` function. The first loop finds
    and stores the global matrix of a transform. If the joint parent has a smaller
    index than the joint, the optimized method is used. If the joint's parent isn't
    smaller, the first loop breaks out and gives the second loop a chance to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this second loop, each joint falls back to calling the slow `GetWorldTransform`
    function to find its world transforms. This loop is the fallback code used if
    the optimized loop fails. If the optimized loop executes all the way, this second
    loop isn''t executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This change adds very minimal overhead to the `GetMatrixPalette` function but
    quickly makes up for that. It makes the matrix palette calculations run fast,
    if possible, but still execute if not possible. In the following section, you
    will learn how to re-arrange the joints of a loaded model to make the `GetMatrixPalette`
    function always take the fast path.
  prefs: []
  type: TYPE_NORMAL
- en: Reordering joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all models will be well formatted; because of this, they won't all be able
    to take advantage of the optimized `GetMatrixPalette` function. In this section,
    you will learn how to re-arrange the bones of a model so that it can take advantage
    of the optimized `GetMatrixPalette` function.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `RearrangeBones.h`. Use a dictionary whose keyvalue pairs
    are bone indices to remapped bone indices. The `RearrangeSkeleton` function generates
    this dictionary and rearranges the bind, inverse bind, and rest poses in the skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `RearrangeSkeleton` function has generated `BoneMap`, you can use
    it to process any meshes or animation clips that affect the current skeleton.
    Follow these steps to re-order the joints so that a skeleton can always take advantage
    of the optimized `GetMatrixPalette` path:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function declarations to the `RearrangeBones.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin implementing the `RearrangeSkeleton` function in a new file, `ReearrangeBones.cpp`.
    First, create references to the rest and bind poses, then make sure that the skeleton
    that you are re-arranging isn''t empty. If it is empty, just return an empty dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a two-dimensional integer array (a vector of vectors of integers).
    Each element of the outer vector represents one bone and the indices of this vector
    and the `mJoints` array in the bind or rest poses are parallel. The inner vector
    represents all the children that the joint at the index of the outer vector contains.
    Loop through every joint in the rest pose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If a joint has a parent, add the index of the joint to the parent''s vector
    of children nodes. If a node is a root node (so it has no parent), add it directly
    to the process list. This list will be used later to traverse the map depth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To figure out how to re-order bones, you need to keep two maps—one that maps
    from the old configuration to the new one and one that maps from the new configuration
    back to the old one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For each element, if it contains children, add the children to the process
    list. This way, all the joints are processed and the joints higher up in the transform
    hierarchy are processed first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the current index of the forward map to the index of the joint that is
    being processed. The current index of the forward map is an atomic counter. Do
    the same thing for the backward map, but switch the key-value pair around. Don''t
    forget to add the null node (`-1`) to both maps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the maps are filled in, you need to build new rest and bind poses
    whose bones are in the correct order. Loop through every joint in the original
    rest and bind poses and copy their local transforms to the new poses. Do the same
    thing for the joint names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding the new parent joint ID for each joint requires two mapping steps.
    First, map the current index to the bone in the original skeleton. This returns
    the parent of the original skeleton. Map this parent index back to the new skeleton.
    This is why there are two dictionaries, to make this mapping fast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the new rest and bind poses are found and the joint names have been re-arranged
    accordingly, write this data back to the skeleton by calling the public `Set`
    method. The `Set` method of the skeleton also calculates the inverse bind pose
    matrix palette:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `RearrangeSkeleton` function re-arranges the bones in a skeleton so that
    the skeleton can take advantage of the optimized version of `GetMatrixPalette`.
    Rearranging the skeleton is not enough. Since the joint indices moved, any clips
    or meshes that reference this skeleton are now broken. In the next section, you
    will implement helper functions to re-arrange the joints in a clip.
  prefs: []
  type: TYPE_NORMAL
- en: Reordering clips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To rearrange an animation clip, loop through all the tracks in the clip. For
    each track, find the joint ID, then convert that joint ID using the (backward)
    bone map that was returned by the `RearrangeSkeleton` function. Write the modified
    joint ID back into the tack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you have implemented the `FastClip` optimization from earlier in this chapter,
    the `RearrangeClip` function should still work since it is a subclass of `Clip`.
    In the next section, you will learn how to re-arrange the joints in a mesh, which
    will be the last step needed to use this optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Reordering meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To rearrange the joints that affect the skinning of a mesh, loop through every
    vertex of the mesh and remap all four of the joint indices stored in the influences
    attribute of that vertex. The weights of the joint don't need to be edited since
    the joint itself didn't change; only its index in the array changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the mesh in this way only edits the CPU copy of the mesh. Call `UpdateOpenGLBuffers`
    to upload the new attribute to the GPU as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With the `RearrangeMesh` function implemented, you can load a skeleton, then
    call the `RearrangeSkeleton` function and store the bone map it returns. Using
    this bone map, you can also fix any meshes or animation clips that reference the
    skeleton with the `RearrangeClip` and `RearrangeMesh` functions. After an asset
    is processed in this way, `GetMatrixPalette` always takes the optimized path.
    In the next section, you will explore caching transforms in a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Pose::GetGlobalTransform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that makes the `GetGlobalTransform` function of the `Pose`
    class is that it always calculates the world transform. Consider a situation where
    you request the world transform of a node, then immediately after, the world transform
    of its parent node. The original request calculates and uses the world transform
    of the parent node, but as soon as the next request is made, that same transform
    is calculated again.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this is to add two new arrays to the `Pose` class. One is a
    vector of world space transforms and the other contains dirty flags. Any time
    a joint's local transform is set, the dirty flag of the joint needs to be set
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When a world transform is requested, the dirty flag of the transform and all
    its parents is checked. If there is a dirty transform in that chain, the world
    transform is re-calculated. If the dirty flag is not set, the cached world transform
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: You will not implement this optimization in this chapter. This optimization
    adds a significant amount of memory to each instance of the `Pose` class. Except
    for cases of inverse kinematics, the `GetGlobalTransform` function is rarely used.
    For skinning, the `GetMatrixPalette` function is used to retrieve world space
    matrices and that function is already optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored how to optimize an animation system for several
    scenarios. These optimizations reduce the number of uniforms that a vertex skinning
    shader requires, speeding up the sampling of animations with many keyframes and
    generating the matrix palette of a pose faster.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there is no one-size-fits-all solution. If all the animations
    in a game have a few keyframes, the added overhead of optimizing animation sampling
    with a lookup table might not be worth the additional memory. However, changing
    the sampling function to use a binary search might be worth it. Similar pros and
    cons exist for each optimization strategy; you must pick what makes sense for
    your particular use case.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the sample code for this chapter, `Chapter11/Sample00` contains
    the code for this chapter in its entirety. `Chapter11/Sample01` shows how to use
    pre-skinned meshes, `Chapter11/Sample02` shows how to use the `FastTrack` class
    for faster sampling, and `Chapter11/Sample03` shows how to rearrange bones for
    faster palette generation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore how to blend animations to switch between
    two animations smoothly. The chapter will also explore the blending techniques
    for modifying existing animations by additive blending.
  prefs: []
  type: TYPE_NORMAL
