- en: '*Chapter 5*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test Computed Properties and Watchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties and watchers are the reactive parts of the logic of Vue.js
    components. They each serve totally different purposes, that is, one is synchronous
    and the other is asynchronous, which makes them behave slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll go through the process of testing them, and we'll see
    what different cases we can find along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Computed Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computed properties are simple reactive functions that return data in another
    form. They behave exactly like the language-standard `get/set` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re using plain objects, then it''d be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even add the `set` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Testing Computed Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing a computed property is very simple. Sometimes, you probably won't test
    a computed property exclusively, but instead, you'll test it as part of other
    tests. However, most of the time it's good to have a test for it; whether that
    computed property is cleaning up an input or combining data, we want to make sure
    things work as intended. So, let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a `Form.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It will show an input and, next to it, you'll see the same string but reversed.
    It's just a silly example, but enough to test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add it to `App.vue`, then put it after the `MessageList` component, and
    remember to import it and include it within the `components` component option.
    Then, create a `test/Form.test.js` file with the usual bare bones we''ve used
    in other tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a test suite with two test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can access the component instance within `cmp.vm` so that we can access the
    internal state, computed properties, and methods. Then, to test it is just about
    changing the value and making sure it returns the same string when `reversed`
    is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second case, it is almost the same, with the only difference being
    that we must set the `reversed` property to `true`. We could navigate through
    `cmp.vm...` to change it, but `vue-test-utils` give us a helper method, `setProps({
    property: value, ... })`, that makes it very easy.'
  prefs: []
  type: TYPE_NORMAL
- en: That's it; depending on the computed property, it may need more test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honestly, I haven't come across any test case where I really need to use watchers
    that my computed properties couldn't solve. I've seen them misused as well, leading
    to a very unclear data workflow among components and messing everything up. So,
    don't rush into using them, and think beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the **Vue.js docs** ([https://vuejs.org/v2/guide/computed.html#Watchers](https://vuejs.org/v2/guide/computed.html#Watchers)),
    watchers are often used to react to data changes and perform asynchronous operations,
    such as performing an ajax request.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Watchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that we want to do something when the `inputValue` from the state
    change. We could perform an ajax request, but since that''s more complicated (and
    we''ll cover it in more detail in the next lesson), let''s just use a `console.log
    function`. Add a `watch` property to the `Form.vue` component options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `inputValue` watch function matches the state variable name. By convention,
    Vue will look it up in both the `properties` and `data` states by using the watch
    function name, in this case, `inputValue`, and since it will find it in `data`,
    it will add the watcher there.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a watch function takes the new value as the first parameter and the
    old one as the second. In this case, we've chosen to log only when it's not empty
    and the values are different. Usually, we'd like to write a test for each case,
    depending on the time you have and how critical that code is.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what should we test about the watch function? Well, that''s something we''ll
    also discuss further in the next lesson when we talk about testing methods, but
    let''s say we just want to know that it calls `console.log` when it should. So,
    let''s add the bare-bones of the Watchers test suite within `Form.test.js`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using a spy on the `console.log` method, initializing it before
    starting any test, and then resetting its state after each of them so that they
    start from a clean spy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test a watch function, we just need to change the value of what''s being
    watched, in this case, the `inputValue` state. But there is something curious...
    let''s start from the last test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we changed the `inputValue`, so the `console.log` spy should be called,
    right? Well, it won''t. But wait, there is an explanation for this: unlike computed
    properties, watchers are *deferred to the next update cycle* that Vue uses to
    look for changes. So, basically, what''s happening here is that `console.log`
    is indeed called, but after the test has finished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we''re changing `inputValue` in the *raw* way by accessing the
    `vm` property. If we wanted to do it this way, we''d need to use the `vm.$nextTick`
    ([https://vuejs.org/v2/api/#vm-nextTick](https://vuejs.org/v2/api/#vm-nextTick))
    function to defer code to the next update cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Notice here that we called a* `done` *function that we received as a parameter.
    That''s* **one way Jest** *(*[https://jestjs.io/docs/en/asynchronous.html](https://jestjs.io/docs/en/asynchronous.html)*)
    can test asynchronous code.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a **much better way**. The methods that `vue-test-utils`
    give us, such as `emitted` or `setData`, take care of that under the hood. This
    means that the last test can be written in a cleaner way just by using `setData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply the same strategy for the next one, with the only difference
    being that the spy shouldn''t be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, testing that it *is not called if the values are the same* is a bit
    more complex. The default internal state is empty; so, first, we need to change
    it, wait for the next tick, then clear the mock to reset the call count, and change
    it again. Then, after the second tick, we can check the spy and finish the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be much simpler if we recreated the component at the beginning,
    overriding the `data` property. Remember, we can override any component option
    by using the second parameter of the `mount` or `shallowMount` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ve learned how to test part of the logic of Vue components:
    computed properties and watchers. We''ve gone through different example test cases
    that we could come across while testing both of them. You''ve also learned about
    some of the Vue internals, such as the `nextTick` update cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter on **GitHub** ([https://github.com/alexjoverm/vue-testing-series/tree/Test-State-Computed-Properties-and-Methods-in-Vue-js-Components-with-Jest](https://github.com/alexjoverm/vue-testing-series/tree/Test-State-Computed-Properties-and-Methods-in-Vue-js-Components-with-Jest)).
  prefs: []
  type: TYPE_NORMAL
