- en: Chapter 5. Extracting Data Physically from Android Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will be covering physical data extraction using free and open
    source tools wherever possible. The majority of the material covered in this chapter
    will use the ADB methods previously discussed in this book. By the end of this
    chapter, the reader should be familiar with the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: What physical extraction means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What data to expect from physical extractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical data extractions using the `dd` and `nanddump` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM imaging and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SD card acquisitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JTAG and chip-off methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical extraction overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In digital forensics, a physical extraction is an exact bit-for-bit image of
    the electronic media, and this definition remains true for mobile devices too.
    In traditional computer forensics, this typically involves removing the evidence
    drive from the suspect's computer and imaging it via a write blocker without ever
    booting the drive, resulting in an image file containing an exact copy of the
    suspect's drive. The output is frequently referred to as a **raw image**, or simply
    a **bin** (binary) file. Physical extractions differ from logical, in that, they
    are an exact copy of the device's memory, and include unallocated space, file
    slack, volume slack, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In mobile forensics, the result is the same; an exact bit-for-bit image of the
    device, but the methods are somewhat different. For example, removing the flash
    memory from the device to image can be both time-consuming and expensive, and
    requires a lot of specialized knowledge (though it can be done as discussed in
    the chip-off section later in the chapter). Furthermore, short of using advanced
    **Joint Test Action Group** (**JTAG**) or chip-off methods, the device must be
    booted to some degree (and written to in many cases) in order to access the data.
    Finally, finding a tool that can even parse the final image file can be very difficult.
    Hard drive images and file systems have long been documented and studied, while
    mobile images and file systems change frequently; in some cases mobile file systems
    are even unique to a specific manufacturer. Knowing what to do with the image
    after it is acquired can be just as challenging as acquiring the image in the
    first place!
  prefs: []
  type: TYPE_NORMAL
- en: Many of the techniques discussed in [Chapter 4](part0031.xhtml "Chapter 4. Extracting
    Data Logically from Android Devices"), *Extracting Data Logically from Android
    Devices*, will still apply here. Booting into a custom recovery is still the most
    forensically sound process; physically acquiring a live device should be avoided
    if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: What data can be acquired physically?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The short answer is: *everything*. As a physical acquisition is an exact image
    of the device, every bit of data on the device is in the image file. As mentioned
    previously, with a physical extraction, an examiner is usually only limited by
    their ability to find the relevant data. Generally, this is due to a lack of good
    image analysis tools in the mobile forensics space. To further compound the matter,
    applications have been known to encode or otherwise obfuscate user data, so simply
    browsing through the image in a hex editor will frequently miss valuable evidence.
    This chapter will show various methods to mount or otherwise view the filesystem
    of a physical extraction, while [Chapter 7](part0053.xhtml "Chapter 7. Forensic
    Analysis of Android Applications"), *Forensic Analysis of Android Applications*,
    will focus on analyzing data from specific applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Root access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, just as in logical extractions, root access is going to be a critically
    important aspect of physical extractions. To manually image a device, we are going
    to have to execute commands on the device from the ADB shell, and these will require
    root permissions. If root access cannot be obtained, the SD card can generally
    still be imaged. The only recourse beyond that is JTAG or chip-off methods.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data physically with dd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dd` command should be familiar to any examiner who has done traditional
    hard drive forensics. The `dd` command is a Linux command-line utility used by
    definition to convert and copy files, but is frequently used in forensics to create
    bit-by-bit images of entire drives. Many variations of the `dd` commands also
    exist and are commonly used, such as `dcfldd`, `dc3dd`, `ddrescue`, and `dd_rescue`.
    As the `dd` command is built for Linux-based systems, it is frequently included
    on Android platforms. This means that a method for creating an image of the device
    often already exists on the device!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dd` command has many options that can be set, of which only forensically
    important options are listed here. The format of the `dd` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`if`: This option specifies the path of the input file to read from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of`: This option specifies the path of the output file to write to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bs`: This option specifies the block size. Data is read and written in the
    size of the block specified, defaults to 512 bytes if not specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conv`: This option specifies the conversion options as its attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notrunc`: This option does not truncate the output file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noerror`: This option continues imaging if an error is encountered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: In conjunction with the `noerror` option, this option writes `\x00`
    for blocks with an error. This is important for maintaining file offsets within
    the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not mix up the `if` and `of` flags, this could result in overwriting the
    target device!
  prefs: []
  type: TYPE_NORMAL
- en: A full list of command options can be found at [http://man7.org/linux/man-pages/man1/dd.1.html](http://man7.org/linux/man-pages/man1/dd.1.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is an important correlation between the block size and the
    `noerror` and `sync` flags: if an error is encountered, `\x00` will be written
    for the entire block that was read (as determined by the block size). Thus, smaller
    block sizes result in less data being missed in the event of an error. The downside
    is that, typically, smaller block sizes result in a slower transfer rate. An examiner
    will have to decide whether a timely or more accurate acquisition is preferred.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, booting into recovery mode for the imaging
    process is the most forensically sound method.
  prefs: []
  type: TYPE_NORMAL
- en: Determining what to image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When imaging a computer, an examiner must first find what the drive is mounted
    as; `/dev/sda`, for example. The same is true when imaging an Android device.
    The first step is to launch the ADB shell and view the `/proc/partitions` file
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show all partitions on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining what to image](img/image00359.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the output shown in the preceding screenshot, `mmcblk0` is the entirety of
    the flash memory on the device. To image the entire flash memory, we could use
    `/dev/blk/mmcblk0` as the input file flag (`if`) for the `dd` command. Everything
    following it, indicated by `p1`- `p29`, is a partition of the flash memory. The
    size is shown in blocks, in this case the block size is 1024 bytes for a total
    internal storage size of approximately 32 GB. To obtain a full image of the device's
    internal memory, we would run the `dd` command with `mmcblk0` as the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we know from previous chapters that most of these partitions are unlikely
    to be forensically interesting; we''re most likely only interested in a few of
    them. To view the corresponding names for each partition, we can look in the device''s
    `by-name` directory. This does *not* exist on every device, and is sometimes in
    a different path, but for this device it is found at `/dev/block/msm_sdcc.1/by-name`.
    By navigating to that directory and running the `ls -al` command, we can see to
    where each block is symbolically linked as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining what to image](img/image00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If our investigation was only interested in the `userdata` partition, we now
    know that it is `mmcblk0p28`, and could use that as the input file to the `dd`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: If the `by-name` directory does not exist on the device, it may not be possible
    to identify every partition on the device. However, many of them can still be
    found by using the `mount` command within the ADB shell. Note that the following
    screenshot is from a different device that does not contain a `by-name` directory,
    so the data partition is not `mmcblk0p28`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining what to image](img/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On this device, the data partition is `mmcblk0p34`. If the `mount` command does
    not work, the same information can be found using the `cat /proc/mounts` command.
    Other options to identify partitions depending on the device are the `cat /proc/mtd`
    or `cat /proc/yaffs` commands; these may work on older devices. Newer devices
    may include an `fstab` file in the root directory (typically called `fstab.<device>`)
    that will list mountable partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to an SD card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The output file of the `dd` command can be written to the device's SD card.
    This should only be done if the suspect SD card can be removed and replaced with
    a forensically sterile SD to ensure that the `dd` command's output is not overwriting
    evidence. Obviously, if writing to an SD card, ensure that the SD card is larger
    than the partition being imaged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On newer devices, the `/sdcard` partition is actually a symbolic link to `/data/media`.
    In this case, using the `dd` command to copy the `/data` partition to the SD card
    won't work, and could corrupt the device because the input file is essentially
    being written to itself.
  prefs: []
  type: TYPE_NORMAL
- en: To determine where the SD card is symbolically linked to, simply open the ADB
    shell and run the `ls -al` command. If the SD card partition is not shown, the
    SD likely needs to be mounted in recovery mode using the steps shown in [Chapter
    4](part0031.xhtml "Chapter 4. Extracting Data Logically from Android Devices"),
    *Extracting Data Logically from Android Devices*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, `/sdcard` is symbolically linked to `/data/media`.
    This indicates that the `dd` command's output should not be written to the SD
    card.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing to an SD card](img/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example that follows, the `/sdcard` is not a symbolic link to `/data`,
    so the `dd` command''s output can be used to write the `/data` partition image
    to the SD card:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing to an SD card](img/image00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On older devices, the SD card may not even be symbolically linked.
  prefs: []
  type: TYPE_NORMAL
- en: 'After determining which block to read and to where the SD card is symbolically
    linked, image the `/data` partition to the `/sdcard`, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Writing to an SD card](img/image00364.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, an image of the `/data` partition exists on the SD card. It can be pulled
    to the examiner's machine with the ADB `pull` command, or simply read from the
    SD card.
  prefs: []
  type: TYPE_NORMAL
- en: Writing directly to an examiner's computer with netcat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the image cannot be written to the SD card, an examiner can use **netcat**
    to write the image directly to their machine. The netcat tool is a Linux-based
    tool used for transferring data over a network connection. We recommend using
    a Linux or a Mac computer for using netcat as it is built-in, though Windows versions
    do exist. The examples below were done on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Installing netcat on the device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Very few Android devices, if any, come with netcat installed. To check, simply
    open the ADB shell and type `nc`. If it returns saying `nc is not found`, netcat
    will have to be installed manually on the device. Netcat compiled for Android
    can be found at many places online. We have shared the version we used at [http://sourceforge.net/projects/androidforensics-netcat/files/](http://sourceforge.net/projects/androidforensics-netcat/files/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the results from our `mount` command in the previous section,
    we can see that the `/dev` partition is mounted as `tmpfs`. The Linux term `tmpfs`
    means that the partition is meant to appear as an actual filesystem on the device,
    but is truly only stored in RAM. This means we can `push` netcat here without
    making any permanent changes to the device using the following command on the
    examiner''s computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should have created the `Examiner_Folder` in `/dev`, and `nc` should
    be in it. This can be verified by running the following command in the ADB shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using netcat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the netcat binary is on the device, we need to give it permission
    to execute from the ADB shell. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will need two terminal windows open with the ADB shell open in one of them.
    The other will be used to listen to the data being sent from the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to enable port forwarding over ADB from the examiner''s computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`9999` is the port we chose to use for netcat; it can be any arbitrary port
    number between 1023 and 65535 on a Linux or Mac system (1023 and below are reserved
    for system processes, and require root permission to use). Windows will allow
    *any* port to be assigned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal window with ADB shell, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`mmcblk0p34` is the user data partition on this device, however, the entire
    flash memory or any other partition could also be imaged with this method. In
    most cases, it is best practice to image the entirety of the flash memory in order
    to acquire all possible data from the device. Some commercial forensic tools may
    also require the entire memory image, and may not properly handle an image of
    a single partition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the other terminal window, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `data_partition.img` file should now be created in the current directory
    of the examiner's computer. When the data is finished transferring, netcat in
    both terminals will terminate and return to the command prompt. The process can
    take a significant amount of time depending on the size of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data physically with nanddump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all of the preceding examples, the partitions were all **Multimedia Card**
    (**MMC**) blocks, which is typically seen in newer devices. Older devices, however,
    are far more likely to consist of **Memory Technology Device** (**MTD**) blocks.
    We have seen cases in the past where the `dd` command was unable to properly image
    an MTD block, although more often than not, it works fine. If `dd` fails, there
    is a widely distributed utility called `MTD-Utils` used to read and write from
    MTD blocks; the `nanddump` command is a part of `MTD-Utils`, and can be used similarly
    to `dd` in order to read from an MTD block. In those cases where `dd` failed,
    `nanddump` was always successful.
  prefs: []
  type: TYPE_NORMAL
- en: Versions of `nanddump` compiled for Android can be found in many places online;
    we used the one found at [https://github.com/jakev/android-binaries/blob/master/nanddump](https://github.com/jakev/android-binaries/blob/master/nanddump).
  prefs: []
  type: TYPE_NORMAL
- en: 'The process to put `nanddump` on the device is the same as the one used previously
    for netcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `dd`, the `nanddump` command can be used to write either to an SD
    card or the examiner''s computer via netcat. From a terminal window, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From a separate terminal window within the ADB shell, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first terminal window where the `adb forward` command was used, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Verifying a full physical image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Verifying whether an image file is identical to the device is a critical step
    in traditional digital forensics. On Android devices, it can be a little trickier,
    if not impossible. The image created can be hashed using whatever tool the examiner
    typically uses. Verifying the memory on the device can be done through the ADB
    shell using the following command, where the path given is the block or partition
    that was imaged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, the `md5sum` command is not included on all Android devices. If it
    is not included, an examiner may be able to find a version compiled for their
    device online, and push it to the device in a `tmpfs` partition as shown previously
    with netcat and `nanddump`.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that if the image was acquired live, i.e. not in recovery mode
    as discussed in the previous chapter, it is a virtual certainty that the MD5 hashes
    will *not* match, as data is constantly changing on the device (even if it is
    **radio frequency** (**RF**) shielded or in Airplane mode). In this case, an examiner
    would have to document that the device was live when acquired and explain that
    the hashes are not expected to match.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a full physical image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an image has been obtained using one of the discussed methods, an examiner
    could conceivably go through the image manually and extract each partition, but
    would probably prefer to avoid doing that. Luckily, there is a wide variety of
    mobile forensic tools that can ingest a physical image, such as Cellebrite, XRY,
    Mobile Phone Examiner, and many others. Unfortunately, none of these are free
    or open source. By far the most popular analysis tool that is free and open source
    is Autopsy by Brian Carrier.
  prefs: []
  type: TYPE_NORMAL
- en: Autopsy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sleuth Kit began as a set of Linux-based command line tools for forensics;
    eventually, a browser-based GUI named Autopsy was added. Recently, Autopsy has
    been released as a stand-alone platform on Windows, and includes support for analyzing
    Android images. Version 3.1.1 is shown in the following screenshots. The full
    process for loading and analyzing an image will be covered in [Chapter 8](part0076.xhtml
    "Chapter 8. Android Forensic Tools Overview"), *Forensic Analysis of Android Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Autopsy can be downloaded at [http://www.sleuthkit.org/](http://www.sleuthkit.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been loaded, expanding the image will show all the volumes
    that Autopsy found, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy](img/image00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Far more volumes were found than the number of partitions on the device. They
    may either be false positives created by the tool, or a result of wear-leveling
    on the device.
  prefs: []
  type: TYPE_NORMAL
- en: One of these volumes will be the data partition, seen as follows:.
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy](img/image00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the media directory seen above is the SD card, as it was symbolically
    linked to the `data` partition. The `data` folder within the `data` partition
    will contain application data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy](img/image00367.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As each application is installed, a directory is created for it. The directories
    shown in the preceding screenshot with a red cross on the folder icon were deleted,
    indicating that the application was removed from the device.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Autopsy does a good job pulling out some data automatically for an
    examiner, but as with all forensic tools, this information should be verified
    manually, as seen in [Chapter 7](part0053.xhtml "Chapter 7. Forensic Analysis
    of Android Applications"), *Forensic Analysis of Android Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy](img/image00368.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Issues with analyzing physical dumps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common problem we see on many forensic forums and email lists is examiners
    obtaining a physical dump and then not being able to load that dump into a tool
    that claims to support the device. Most of the time, this is because the examiner
    fails to account for the **Out-of-Band** (**OOB**) area.
  prefs: []
  type: TYPE_NORMAL
- en: The OOB area, sometimes called the spare area, is a small section of the flash
    memory reserved for metadata. The metadata usually consists of **error correcting
    code** (**ECC**), information about bad blocks, and in some cases, information
    about the filesystem. This causes an issue for examiners because most mobile forensic
    tools do not account for the OOB area; they expect it to not be included in the
    image. When presenting the tool with an image containing the spare area, the tool
    frequently does not know what to do and fails to parse the data properly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that tools fail to account for the OOB area is that it is *not* included
    in `dd` images, which is what most tools use to create their images. The OOB area
    may be included when using the `nanddump` command, though depending on the binary
    used, there may be an option to exclude it. The OOB area is included with chip-off
    and JTAG images.
  prefs: []
  type: TYPE_NORMAL
- en: To properly load the image into forensic tools, the OOB area will need to be
    removed first. A general rule of thumb is that the OOB size is based on the page
    size of the device; for every 512 bytes of page size there will be 16 bytes of
    OOB area. For example, a device with 2048 byte page sizes would likely have 64
    bytes of OOB area at the end of each page. However, this is completely up to the
    memory manufacturer. Before attempting to remove the OOB area, an examiner should
    find the datasheet for the specific memory chip to confirm the page and OOB area
    sizes. This can generally be done by finding the memory chip on the phone's circuit
    board and searching for the model number of the chip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some sample code for a Python script that will remove the
    OOB area from an image. Just as in the last chapter, we don''t claim to be Python
    experts and we''re sure there are better, more efficient ways to do this, but
    this one does work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This file, if named `OOB_Remover.py`, would be executed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output file, with no OOB area, would be named `file_out.bin` in the directory
    where the script was executed. The original is not edited or modified in anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code as it is written assumes a page size of 2048 and an OOB size
    of 64; these two numbers would have to be edited for the specific sizes of the
    memory chip the image was taken from. The output should then be able to be loaded
    into commercial mobile forensic tools.
  prefs: []
  type: TYPE_NORMAL
- en: Imaging and analyzing Android RAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pulling Android memory is not applicable in a very large number of cases due
    to the fact that it requires root access. Most public root processes involve rebooting
    the phone, which erases volatile RAM, meaning that by the time an examiner gains
    root to image the RAM, it's too late because the RAM has been erased. Because
    of this and possibly other reasons, there is not great support for Android RAM
    imaging and analysis in the commercial forensic world. However, there are cases
    where imaging RAM is applicable, and may prove invaluable. If a device is already
    rooted when it is seized, imaging the RAM should be a mandatory step in the seizure
    process. As powering the phone off will erase the RAM, the device should be placed
    in Airplane mode (any other network connections such as Wi-Fi and Bluetooth disabled),
    and the RAM should be imaged immediately to avoid the device battery dying before
    the RAM can be pulled.
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge when it comes to RAM is the analysis. RAM is completely raw,
    unstructured data; there is no filesystem. When viewed in a hex editor, RAM appears
    to just be a giant blob of data with very little rhyme or reason to help examiners
    figure out what they are looking at. This difficulty is compounded by the fact
    that modern devices commonly have gigabytes worth of RAM. RAM can easily be searched
    for keywords using traditional forensic tools and methods, but that presumes an
    examiner knows exactly what they are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: What can be found in RAM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any data that is written to the flash memory *must* pass through RAM, there
    is no other way for the processor to communicate with the flash memory. This means
    that almost anything done on the device may be found in the contents of a RAM
    dump. Depending on the amount of device usage, data may remain in RAM indefinitely,
    until it needs to be overwritten. RAM dumps frequently contain text typed on the
    device, including usernames and passwords, and application data that is not stored
    permanently on the device. For example, older versions of the Facebook application
    stored the contents of a user's News Feed in a database in its application folder;
    newer versions do not save the user's News Feed, but it exists in RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Imaging RAM with LiME
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common tool for Android RAM acquisition is the **Linux Memory Extractor**
    (**LiME**), previously known as DMD. LiME is free and open source, but isn't highly
    user-friendly as it requires the user to compile it from the source code, which
    can only be done on a Linux system. The compilation process must also be done
    for each specific version of Android for each device being examined, which somewhat
    limits its usability in the field. This is necessary because LiME is not a binary
    (as were the netcat and nanddump tools we used before); instead it is a kernel
    module that must be built specifically for each kernel it will be loaded into.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to ensure the proper kernel source code is downloaded, we will need
    to determine the model and software version for a device, which can be done by
    scrolling through the phone menu to **Setting** | **About Phone**. Alternatively,
    this information can be found in the ADB shell by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The software version in the model should be in the first few lines at the top
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, most Android manufacturers do release their kernel source code; a
    quick Google search can usually turn up source code for each model and software
    version. The following are the open source release sites for a few major manufacturers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Samsung**: [http://opensource.samsung.com/reception.do](http://opensource.samsung.com/reception.do)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motorola**: [http://sourceforge.net/motorola/](http://sourceforge.net/motorola/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTC**: [http://www.htcdev.com/devcenter](http://www.htcdev.com/devcenter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Nexus**: [https://source.android.com/source/building-kernels.html](https://source.android.com/source/building-kernels.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The correct model and version source must be used. Using the wrong kernel source
    to compile LiME will, at the very least, not work on the device. Loading an incompatible
    kernel module could also crash the device.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the source code for LiME, navigate to [https://github.com/504ensicsLabs/LiME](https://github.com/504ensicsLabs/LiME)
    and choose the **Download ZIP** option, then extract the zip.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many excellent resources online explaining how to compile LiME for
    a specific kernel, and also how to create a custom `Volatility` plugin to examine
    the resulting RAM dump, so we won''t detail them here. A couple of them are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lime-forensics.googlecode.com/files/LiME_Documentation_1.1.pdf](http://lime-forensics.googlecode.com/files/LiME_Documentation_1.1.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/volatility/wiki/AndroidMemoryForensics](https://code.google.com/p/volatility/wiki/AndroidMemoryForensics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One point missing from these sources is that the step that uses ADB `pull` to
    obtain the `/proc/config.gz` file may not work on all devices. If the file does
    not exist, the correct config file can be found in the source code, usually in
    the `/arch/arm/configs` folder. It is usually named after the processor model,
    for example, `apq8064_defconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Imaging RAM with mem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in the preceding section, using LiME is not for the faint-hearted;
    it is a very daunting process fraught with complications. It seems unlikely that
    an examiner in the field will download and compile kernel source code. The **mem**
    tool was developed by James Nuttall to address these issues. Rather than a kernel
    module that needs to be compiled on a device-specific basis, mem is a binary similar
    to the netcat and nanddump examples used previously in this chapter. The mem tool
    can be downloaded at [http://sourceforge.net/projects/androidforensics-mem/files/](http://sourceforge.net/projects/androidforensics-mem/files/).
  prefs: []
  type: TYPE_NORMAL
- en: Mem is an executable binary that needs to be pushed to the device and executed
    using the exact procedures detailed previously for netcat and nanddump. It may
    seem counter-intuitive to push something to RAM in order to read the RAM, but
    this is an accepted necessity in computer forensics. In our opinion, it is better
    to overwrite a small portion of RAM than to actually push it to the device and
    overwrite evidentiary user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mem has the capability to read the entire RAM, or to target specific, forensically-interesting
    processes (applications). Assuming that mem is pushed to the same location on
    the device used for netcat above, the format for running mem is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`PID` is the ID of the process to read; if it is set to 0, all of RAM will
    be imaged. To view the list of processes within the ADB shell, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see that `PID` is the second column of
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Imaging RAM with mem](img/image00369.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The output can be quite large, though interesting processes can be found by
    simply reading through the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Imaging RAM with mem](img/image00370.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the above screenshot, we can see that Kik, Facebook, Calendar, and Gmail
    are all running. An alternative to reading the entire output is to search for
    known applications using `grep`. For example, to find Facebook in the output we
    could run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of which would show only the entry for Facebook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Imaging RAM with mem](img/image00371.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the PID of Facebook is `2252`. To avoid overwriting data on
    the device, mem is written to be used in conjunction with netcat just as shown
    in the *Writing directly to an examiner''s computer with netcat* section of this
    chapter. So, capturing the RAM used by Facebook requires the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal on the examiner''s computer, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal window within ADB shell, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the terminal window on the examiner''s computer run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When mem has finished running, there should be a file called `FB_RAM.bin` in
    the working directory of the examiner's computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output from mem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, there aren''t many good ways to examine RAM because
    there is no filesystem; the output is just a blob of data. This is still true
    for data acquired with mem; the output from the Facebook RAM pulled above is a
    550 MB unstructured blob of data. The following screenshot can be viewed as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from mem](img/image00372.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We suggest using strings or some other search function to narrow down the data
    to hopefully find useful user data. The file can also be loaded into computer
    forensic tools like EnCase or FTK in order to search for keywords, and carving
    tools can be used to locate images.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with enough patience and dedication, useful information can be found,
    such as this post from a user''s news feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from mem](img/image00373.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Eventually, the mem developers hope to work on a volatility profile to help
    with analyzing the output.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring Android SD cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed above and in previous chapters, the SD card can refer to a physical,
    external SD card or a partition within the flash memory. A removable external
    SD card can be imaged separately from the device through a write-blocker with
    typical computer forensics tools, or using the `dd`/`nanddump` techniques shown
    in the previous section, although the former is usually faster as it does not
    need to write data over netcat.
  prefs: []
  type: TYPE_NORMAL
- en: Physically imaging an SD card is very similar to the physical imaging discussed
    above; in fact, if the SD card is symbolically linked to the `/data` partition,
    it would be acquired as part of the `/data` partition as seen in the Autopsy screenshots.
    The only difference in the process is that if the SD card is being imaged, the
    output file cannot be written to the SD card! This means using the netcat methods
    covered previously is the best option for physically imaging an internal SD card.
  prefs: []
  type: TYPE_NORMAL
- en: What can be found on an SD card?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the SD card is typically used to store large files, including downloaded
    items and pictures taken with the device. Many applications will also create their
    own directory on the SD card for storing data such as images sent or received
    through chat applications. In some cases, as will be seen in [Chapter 8](part0076.xhtml
    "Chapter 8. Android Forensic Tools Overview"), *Android Forensic Tools Overview*,
    there even are applications that will routinely perform a backup of all their
    data to the SD card. This is especially useful to forensic examiners because they
    may not be able to access the internal memory due to security settings or the
    inability to obtain root, but may be able to access the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common SD card locations of interest include, but of course are not limited
    to, the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/DCIM`: This location includes pictures taken on the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Pictures/Screenshots`: This location contains screenshots taken on the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Download`: This location contains downloaded files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Android/data`: This is the storage location for many applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/AppName`: This is the storage location for many applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `/Android/data` and `/AppName` folders may persist even if the app has been
    deleted. Contents of the folders will be deleted, but the folders may remain;
    which is an indication that the application was previously installed on the device.
  prefs: []
  type: TYPE_NORMAL
- en: These are just common default locations. If a device is rooted, the user could
    place any data from the internal memory onto the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: SD card security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In older versions of Android, simply plugging a phone into a computer would
    logically mount the SD card and allow an examiner access to its data. In some
    version of Android (possibly 3.0) this changed, although the exact version could
    not be found in the various change logs that we examined. Newer versions of Android
    will not automatically allow access to the SD card from a computer if a screen
    lock is in use, meaning the screen lock will have to be bypassed in order to gain
    access to the SD card. The obvious exception to this is a physical, external SD
    card can still be removed and analyzed with traditional computer forensic methods.
  prefs: []
  type: TYPE_NORMAL
- en: SD cards can also be encrypted, either through the device full-disk encryption
    if it is an internal SD card, or through third-party applications if it is external.
    In some cases, activating the full-disk encryption will leave the SD card unencrypted,
    though this varies depending upon the device manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full-disk encryption in Android Lollipop also encrypts the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced forensic methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the methods discussed in the previous chapters, there are also
    more advanced, specialized methods available. JTAG and chip-off methods are both
    highly useful tools in many common situations, but require advanced training (and
    a lot of practice before working on live evidence!). The final advanced method,
    a cold boot attack to recover encryption keys, is far more theoretical.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JTAG is a standard developed by the **Institute of Electrical and Electronics
    Engineers** (**IEEE**). During the device production process, it is used to communicate
    with the processor through a specialized interface for testing purposes. Luckily
    for forensic examiners, it also allows them to communicate directly with the processor
    and retrieve a full physical image of the flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a JTAG extraction, the device must be taken apart down to the circuit
    board. The circuit board will contain multiple taps (physical contacts on the
    device circuit board), though they are commonly unlabelled and there are usually
    far more taps than required for JTAG. To determine the correct taps, an examiner
    would have to either find a pin-out online (or included with their tool of choice),
    or use electronic test equipment to determine what each tap is. The examiner will
    then have to solder a wire to each tap, or use adapters (sometimes called jigs)
    that are commercially available, and connect to their JTAG box through a provided
    adapter as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JTAG](img/image00374.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTC Evo before and after being hooked up for JTAG (courtesy of http://lowcostwin4n6.blogspot.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'JTAG may sound complicated (perhaps it is), but it serves many useful purposes
    and two advantages are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It does not require the device to be powered on and so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can be successful even if the device is damaged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no RF-shielding concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require root, ADB, or USB debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can be used to recover device PINs/passwords and so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can image the entire flash memory and recover/crack password files as shown
    in Chapter 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many manufacturers make JTAG tools; many of the common ones used for mobile
    forensics can be found at [http://teeltech.com/mobile-device-forensic-tools/jtag-equipment/](http://teeltech.com/mobile-device-forensic-tools/jtag-equipment/).
    The RIFF box listed on the site is probably the most frequently used for mobile
    forensics, as it comes with support (including pin-outs) for a wide variety of
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG is not always successful, or even possible. Though the interface is almost
    always on the circuit board, the manufacturer can choose to disable it after the
    device is manufactured.
  prefs: []
  type: TYPE_NORMAL
- en: Chip-off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chip-off involves heating the device's circuit board until the solder holding
    the components to the board melts, and then removing the flash memory chip. The
    memory chip can then be read using commercial tools, resulting in a full physical
    image. Chip-off techniques, like JTAG, stem from the commercial electronic production
    process. The process of melting the solder (commonly called reflow or rework)
    is used to place and remove components from a circuit board, and the readers used
    to acquire the memory are used to both read and write to memory chips, often in
    bulk quantities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Chip-off](img/image00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A memory chip being removed from a damaged phone (courtesy of www.binaryintel.com/services/jtag-chip-off-forensics/chip-off_forensics/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Chip-off has the same benefits as JTAG: it does not require the device to power
    on, and can be used to acquire the PIN/password from a locked device; though acquiring
    the PIN/password is generally a moot point, chip-off is normally considered to
    be a destructive process. While the memory chip can be replaced on the device,
    it is a technically demanding process and requires further training. But, as a
    last resort, chip-off is an excellent alternative for devices that would otherwise
    be impossible to examine.'
  prefs: []
  type: TYPE_NORMAL
- en: Chip-off is significantly more expensive than JTAG, as a specialized rework
    station and commercial memory reader is required. There are dozens of rework stations
    available and they all provide essentially the same functionality. There is also
    a wide range of memory readers, though we have had great success with this reasonably
    priced model at [http://www.dataman.com/programmers/universal/dataman-48pro2-super-fast-universal-isp-programmer.html](http://www.dataman.com/programmers/universal/dataman-48pro2-super-fast-universal-isp-programmer.html).
    A rework station and reader aren't the only costs associated with chip-off; most
    readers will also require a specific adapter for each model of chip to be read.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Android full-disk encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going any further, please note that this section is *highly* impractical.
    However, we present it here in the hopes that some aspiring forensic developer
    will see it and decide it is a worthy enough cause to make it more widely applicable
    (and also because it's really neat).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cold boot attacks have been demonstrated and used many times, but until recently
    could not be used effectively against Android devices. A cold boot attack is based
    on the idea that RAM is less volatile at lower temperatures (the data remains
    longer), so freezing a device can allow an examiner to access RAM and find the
    key needed to decrypt the device. This was recently demonstrated successfully
    by a team of researchers whose paper and research can be found here: [https://www1.informatik.uni-erlangen.de/frost](https://www1.informatik.uni-erlangen.de/frost).'
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that these techniques were only validated against one device (the
    Galaxy Nexus), and their tool is a loadable kernel module, much like LiME, and
    relies on a custom recovery image that would have to be created for each device
    it is used against.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discussed several techniques used for physically imaging internal
    memory or SD cards and some of the common problems associated with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technique | Problems associated |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| dd |'
  prefs: []
  type: TYPE_TB
- en: Usually pre-installed on device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May not work on MTD blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not obtain Out-of-Band area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| nanddump |'
  prefs: []
  type: TYPE_TB
- en: Not commonly found on the device, must be pushed to device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works well with MTD blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May obtain Out-of-Band area, based on options in the binary used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, each imaging technique can be used to either save the image on
    the device (typically on the SD card), or used with netcat to write the file to
    the examiner''s computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technique | Features |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Writing to SD card |'
  prefs: []
  type: TYPE_TB
- en: Easy, doesn't require additional binaries to be pushed to the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiar to most examiners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot be used if SD card is symbolically linked to the partition being imaged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot be used if the entire memory is being imaged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Using netcat |'
  prefs: []
  type: TYPE_TB
- en: Usually requires yet another binary to be pushed to the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Somewhat complicated, must follow steps exactly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works no matter what is being imaged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May be more time consuming than writing to the SD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple tools used for RAM imaging were also demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool | Features |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LiME |'
  prefs: []
  type: TYPE_TB
- en: Must be compiled for each device being examined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very complicated process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Known, well-documented procedures for analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output is a dump of all RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mem |'
  prefs: []
  type: TYPE_TB
- en: Can be used on any device with no additional steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New tool, not as widely used and documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output is one file for each process running on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we briefly discussed chip-off and JTAG techniques on an introductory
    level.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will demonstrate the recovery of deleted data from physical
    images like the ones created in this chapter.
  prefs: []
  type: TYPE_NORMAL
