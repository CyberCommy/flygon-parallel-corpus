- en: Data Encoding Using Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will show you how to use the more common encoding for exchanging
    data in an application. Encoding is the process of transforming data, and it can
    be used when an application has to communicate with another—using the same encoding
    will allow the two programs to understand each other. This chapter will explain
    how to handle text-based protocols such as JSON, first of all, and then how to
    use binary protocols such as `gob`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using text-based encoding such as JSON and XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about binary encoding such as `gob` and `protobuf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, please refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the protocol buffer, you will need to install the `protobuf`
    library. Instructions are available at [https://github.com/golang/protobuf](https://github.com/golang/protobuf).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding text-based encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most human-readable data serialization format is the text-based format.
    In this section, we will analyze some of the most used text-based encoding—CSV,
    JSON, XML, and YAML.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Comma-separated values** (**CSV**) is a type of text encoding that stores
    data in a tabular form. Each line is a table entry and values of a line are separated
    by a special character, which is usually a comma—hence, the name CSV. Each record
    of the CSV file must have the same value count and the first record can be used
    as a header to describe each record field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: String values can be quoted in order to permit the use of the comma.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go allows users to create a CSV reader from any `io.Reader`. It is possible
    to read records one by one using the `Read` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A full example of the preceding code is available at [https://play.golang.org/p/wZgVzMqAN_K](https://play.golang.org/p/wZgVzMqAN_K).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that each record is a string slice and the reader is expecting the length
    of each row to be consistent. If a row has more or fewer entries than the first,
    this will result in an error. It is also possible to read all records at once
    using `ReadAll`. The same example from before using such a method will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A full example of the preceding code is available at [https://play.golang.org/p/RJ-wxBB5fs6](https://play.golang.org/p/RJ-wxBB5fs6).
  prefs: []
  type: TYPE_NORMAL
- en: Encoding values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A CSV writer can be created using any `io.Writer`. The resulting writer will
    be buffered, so, in order to not lose data, it is necessary to call its method, `Flush`:
    this will ensure that the buffer gets drained and all content goes to the writer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Write` method receives a string slice and encodes it in CSV format. Let''s
    see how it works in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A full example of the preceding code is available at [https://play.golang.org/p/qwaz3xCJhQT](https://play.golang.org/p/qwaz3xCJhQT).
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens, for the reader, there is a method for writing more than one
    record at once. It is known as `WriteAll`, and we can see it in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A full example of the preceding code is available at [https://play.golang.org/p/lt_GBOLvUfk](https://play.golang.org/p/lt_GBOLvUfk).
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between `Write` and `WriteAll` is that the second operation
    uses more resources and it requires us to convert the records into a slice of
    string slices before calling it.
  prefs: []
  type: TYPE_NORMAL
- en: Custom options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both reader and writer have some options that can be changed after creation.
    Both structures share the `Comma` field, which is the character used for separating
    fields. Another important field that belongs to the writer only is `FieldsPerRecord`,
    which is an integer that determines how many fields the reader should expect for
    each record:'
  prefs: []
  type: TYPE_NORMAL
- en: If greater than `0`, it will be the number of field required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If equal to `0` it will set to the number of field of the first record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If negative, all checks on the field count will be skipped, allowing for the
    reading of inconsistent sets of records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a practical example of a reader that is not checking for consistency
    and uses a space as a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A full example of the preceding code is available at [https://play.golang.org/p/KPHXRW5OxXT](https://play.golang.org/p/KPHXRW5OxXT).
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a lightweight, text-based data
    interchange format. Its nature enables humans to read and write it easily, and
    its small overhead makes it very suitable for web-based applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of entities that compose JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collections of name/value pairs**: The name/value is represented as an object,
    structure, or dictionary in various programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordered lists of values**: These are lists of collections or values, which
    are usually represented as arrays or lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objects are enclosed in braces with each key separated by a colon, and each
    value is comma separated from the next key/value. Lists are enclosed in brackets
    and elements are comma separated. These two types can be combined, so a list can
    also be a value, and objects can be elements in a list. Spaces, newlines, and
    tabs that are outside names and values are ignored and are used to indent the
    data and make it easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this sample JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be compressed into one line, removing the indentation, as this is
    a good practice when the data length matters—such as in a web server or a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In Go, the default types associated to JSON dictionaries and lists are `map[string]interface{}`
    and `[]interface{}`. These two types (being so generic) are capable of hosting
    any JSON data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Field tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `struct` can also host a specific set of JSON data; all of the exported keys
    will have names identical to the respective fields. In order to customize the
    keys, Go enables us to follow field declarations in a struct with a string that
    should contain metadata about the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tags take the form of colon separated keys/values. The value is a quoted
    string, which can contain additional information added using commas (such as `job,omitempty`).
    If there is more than one tag, spaces are used to separate them. Let''s see a
    practical example that uses struct tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how two different tags can be used for the same field (we
    have both `json` and `foo`), and it shows how to specify a particular JSON key
    and introduce the `omitempty` tag that is used for output purposes to avoid marshaling
    the field if it has a zero value.
  prefs: []
  type: TYPE_NORMAL
- en: Decoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There two ways of decoding data in JSON—the first is the `json.Unmarshal` function that
    uses a byte slice as input, and the second is the `json.Decoder` type that uses
    a generic `io.Reader` to get the encoded content. We will use the latter in our
    examples because it will enable us to work with structs such as `strings.Reader`.
    Another advantage of the decoder is the customization that can be done with the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DisallowUnknownFields`: The decode will return an error if a field that is
    unknown to the receiving data structure is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseNumber`: Numbers will be stored as `json.Number` instead of `float64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a practical example of data decoding using the `json.Decoder` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/a-qt5Mk9E_J](https://play.golang.org/p/a-qt5Mk9E_J).
  prefs: []
  type: TYPE_NORMAL
- en: Encoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data encoding works in a similar fashion, with a `json.Marshal` function that
    takes a byte slice and the `json.Encoder` type that uses `io.Writer` instead.
    The latter is better for the obvious reasons of flexibility and customization.
    It allows us to change the output with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetEscapeHTML`: If true, it specifies whether a problematic HTML character should
    be escaped inside JSON quoted strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetIndent`: This allows us to specify a prefix at the beginning of each line,
    and what string will be used to indent the output JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example uses an encore to marshal a data structure to standard
    output using tabs for indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is where we can see the utility of the `omitempty` tag in the `Job` field.
    Since the value is an empty string, its encoding is skipped. If the tag was absent,
    there would have been the `"job":"",` line after the surname.
  prefs: []
  type: TYPE_NORMAL
- en: Marshaler and unmarshaler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encoding and decoding are normally done using the reflection package, which
    is pretty slow. Before resorting to it, the encoder and decoder will check whether
    the data type implements the `json.Marshaller` and `json.Unmarshaller` interfaces
    and use the respective methods instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Implementing this interface allows for a generally faster encoding and decoding,
    and it grants the ability to execute other kinds of actions that would not be
    possible otherwise, such as reading from or writing to unexported fields; it can
    also embed some operations such as running checks on the data.
  prefs: []
  type: TYPE_NORMAL
- en: If the goal is just to wrap the default behavior, it is necessary to define
    another type with the same data structure, so that it loses all methods. Otherwise,
    calling `Marshal` or `Unmarshal` inside the methods will result in a recursive
    call and, finally, a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this practical example, we are defining a custom `Unmarshal` method to set
    a default value for the `Job` field when it''s empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/4BjFKiMiVHO](https://play.golang.org/p/4BjFKiMiVHO).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UnmarshalJSON` method needs a pointer receiver because it has to actually
    modify the value of the data type, but for the `MarshalJSON` method, there''s
    no real need for it, and it is a good practice to have a value receiver—unless
    the data type should do something different while `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/Q-q-9y6v6u-](https://play.golang.org/p/Q-q-9y6v6u-).
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with interface types, the encoding part is really straightforward
    because the application knows which data structure is stored within the interface
    and will proceed with the marshaling. Doing the opposite operation is not quite
    as straightforward because the application received has an interface rather than
    a data structure and does not know what to do and, therefore, ends up doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A strategy that works really well (even if it involves a little boilerplate)
    is using a concrete type container, which will permit us to handle the interface
    in the `UnmarshalJSON` method. Let''s create a quick example by defining an interface
    and some different implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a type that wraps the interface and has a `Type` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s populate the `Type` field before encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The decoding method is the more important one: it uses `json.RawMessage`, which
    is a special type of byte slice used for lazy decoding. We will first get the
    type from the string field and leave the value in the raw format, in order to
    use the correct data structure for its decoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/GXMK_hC8Bpv](https://play.golang.org/p/GXMK_hC8Bpv).
  prefs: []
  type: TYPE_NORMAL
- en: Generating structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a very useful application that, when given a JSON string, generates
    a Go type automatically trying to infer field types. You can find one deployed
    at this address: [https://mholt.github.io/json-to-go/](https://mholt.github.io/json-to-go/).
  prefs: []
  type: TYPE_NORMAL
- en: It saves some time and most of the time the data structure is already correct
    after a simple conversion. Sometimes, it needs some changes such as number types,
    for instance, if you want a field to be `float`, but your sample JSON has an integer.
  prefs: []
  type: TYPE_NORMAL
- en: JSON schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A JSON schema is a vocabulary that describes JSON data and enables the verification
    of data validity. It can be used for testing and it can be used as documentation.
    The schema specifies the type of an element and can add additional checks on its
    value. If the type is an array, it can also specify the type and details of each
    element. If the type is an object, it describes its fields. Let''s see a JSON
    schema for the `Character` struct that we used in the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that it specifies an object with all of its fields and indicates
    which fields are mandatory. There are some third-party Go packages that permit
    us to verify JSON against schema very easily such as [github.com/xeipuuv/gojsonschema](https://github.com/xeipuuv/gojsonschema).
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extensible Markup Language** (**XML**) is another widely used data encoding
    format. It''s human and machine readable, like JSON, and it was defined by **World
    Wide Web Consortium** (**W3C**) in 1996\. It focuses on simplicity, usability,
    and generality, and it is actually used as a base for many formats including RSS
    or XHTML.'
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each XML file starts with a declaration statement that specifies the version
    and encoding used in the file and whether the file is standalone (schema used
    is internal). This is a sample XML declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration is followed by a tree of XML elements, which are delimited
    by tags that have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<tag>`: Opening tag, defines the start of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`</tag>`: Closing tag, defines the end of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tag/>`: Self-closing tag, defines an element with no content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usually, elements are nested so that there are tags inside other tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element can have additional information in the form of attributes, which
    are space-separated key/value pairs found inside an opening or self-closing tag.
    The key and value are separated by an equals sign, and the value is delimited
    by double quotes. The following are examples of elements with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Document Type Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Document Type Definition** (**DTD**) is an XML document that defines the
    structure and constraints of other XML documents. It can be used to verify the
    validity of XML if its content is what is expected. An XML can and should specify
    its own schema, to ease the validation process. The elements of a DTD are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema**: This represents the root of the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex type**: It allows an element to have content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence**: This specifies the child elements that must appear in the described
    sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element**: This represents an XML element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: This represents an XML attribute for the parent tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a sample schema declaration for the `Character` struct we are using
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see that it is a schema with an element (character) that is a complex
    type composed by a sequence of other elements.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already saw for JSON, data decoding and encoding can be achieved in two
    different ways: by providing or returning a byte slice using `xml.Unmarshal` and `xml.Marshal` or
    by using `io.Reader` or `io.Writer` with the `xml.Decoder` and `xml.Encoder` types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it by replacing the `json` tag from the `Character` struct with `xml` or
    by simply adding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use `xml.Decoder` to unmarshal the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/esopq0SMhG_T](https://play.golang.org/p/esopq0SMhG_T).
  prefs: []
  type: TYPE_NORMAL
- en: 'When encoding, the `xml` package will get the name of the root node from the
    data type used. If the data structure has a field named `XMLName`, the relative
    XML `struct` tag will be used for the root node. So, the data structure becomes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The encoding operation is also pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/YgZzdPDoaLX](https://play.golang.org/p/YgZzdPDoaLX).
  prefs: []
  type: TYPE_NORMAL
- en: Field tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The name of the root tag can be changed using the `XMLName` field in a data
    structure. There are some other features of field tags that can be really useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Tags with `-` are omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tag with the `attr` option becomes an attribute of the parent element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tag with the `innerxml` option is written verbatim, useful for lazy decoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `omitempty` option works the same as it does for JSON; it will not produce
    a tag for zero values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tag can contain a path in the XML using `>` as a separator, as `a > b >
    c`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous struct fields are treated as if the fields of its value were in the
    outer struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a practical example that uses some of these features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure produces the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/6zdl9__M0zF](https://play.golang.org/p/6zdl9__M0zF).
  prefs: []
  type: TYPE_NORMAL
- en: Marshaler and unmarshaler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have also seen for JSON, the `xml` package offers some interfaces to
    customize the behavior of a type during encoding and decoding operations—this
    can avoid the use of reflection or can be used to establish a different behavior.
    The interfaces that are offered by the package to obtain this behavior are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two pairs of functions—one is used when decoding or encoding the
    type as an element, while the others are used when it''s an attribute. Let''s
    see that in action. First, we define a `MarshalXMLAttr` method for a custom type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we marshal some data, and we will see that the attribute name is replaced
    with `codename`, and its value is uppercase, as specified by the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/XwJrMozQ6RY](https://play.golang.org/p/XwJrMozQ6RY).
  prefs: []
  type: TYPE_NORMAL
- en: Generating structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen for JSON, there is a third-party package that can generate Go structures
    from encoded files. For XML we have [https://github.com/miku/zek](https://github.com/miku/zek).
  prefs: []
  type: TYPE_NORMAL
- en: It takes care of any type of XML data including elements with their attributes,
    spacing between elements, or comments.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML** is a recursive acronym that stands for **YAML Ain''t Markup Language**
    and it''s the name of another widely used encoding format for data. Part of its
    success is due to it being easier to write than JSON and XML, its lightweight
    nature, and its flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'YAML uses indentation for scope and newlines to separate entities. Elements
    in a sequence start with a dash followed by a space. The key and value are separated
    by a color, and a hash sign is used for comments. This is what a sample YAML file
    can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: One of the more important differences between JSON and YAML is that, while the
    first can only use strings as keys, the latter can use any kind of scalar value
    (strings, numbers, and Booleans).
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: YAML is not included in the Go standard library but there are many third-party
    libraries available. The package that is more commonly used to handle this format
    is the `go-yaml` package ([https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is built using the following standard encoding packages structure:'
  prefs: []
  type: TYPE_NORMAL
- en: There are encoders and decoders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are `Marshal`/`Unmarshal` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows `struct` tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The behavior of types can be customized by implementing the methods of the interfaces
    defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface is slightly different—the `Unmarshaler` receives the default
    marshaling function as arguments that can then be used with a data struct that
    is different to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `struct` tags in the same way as JSON tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use them to encode a data structure or, in this case, a list of
    structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Decoding works in the same way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see that all it takes to create `Decoder` is `io.Reader` and the receiving
    struct to execute the decode.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about binary encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary encoding protocols use bytes, so their string representation is not human
    friendly. They are usually not readable as strings and they are difficult to write,
    but they are of a smaller size, resulting in faster communication between applications.
  prefs: []
  type: TYPE_NORMAL
- en: BSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BSON is the binary version of JSON. It is used by MongoDB and has support for
    some data types that are not available in JSON, such as date and binary.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few packages that implement BSON encoding and decoding, and two
    of them are very widespread. One is inside the official MongoDB Golang driver,
    `github.com/mongodb/mongo-go-driver`. The other is not official, but has been
    around since the beginning of Go and it's part of an unofficial MongoDB driver,
    `gopkg.in/mgo.v2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is very similar to the JSON package in both interfaces and functions.
    The interfaces are called getter and setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetBSON` returns the actual data structure that would be encoded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetBSON` receives `bson.Raw`, which is a wrapper for `[]byte` that can be
    used with `bson.Unmarshal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A use case for these getters and setters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BSON is a format made for documents/entities; therefore, the data structure
    used for encoding and decoding should be a structure or a map, but not a slice
    or an array. The `mgo` version of `bson` does not offer the usual encoder but
    only the marshal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same thing applies to the `Unmarshal` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: gob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`gob` encoding is another type of binary encoding that is built into the standard
    library, and it''s actually introduced by Go itself. It is a stream of data items,
    each one preceded by a type declaration, and it does not allow pointers. It uses
    their value, forbidding the use of `nil` pointers (since they have no value).
    The package also has problems with types that have pointers that create a recursive
    structure and this could lead to unwanted behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers have arbitrary precision and they can be a float, signed, or unsigned.
    Signed integers can be stored in any signed integer type, unsigned integers into
    any unsigned integer type, and floating-point values may be received into any
    floating-point variable. However, if the variable can't represent the value (overflow,
    for instance), the decode will fail. Strings and byte slices are stored with a
    very efficient representation that tries to reuse the same underlying array. Structs
    will decode only the exported fields, so functions and channels will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The interface that `gob` uses to replace the default marshal and unmarshal
    behaviors are found in the `encoding` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: During the decoding phase, any struct fields that are not present are ignored,
    since the field name is also part of the serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to encode a structure using `gob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decoding data is also very easy; it works in the same way as the other encoding
    packages we have already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to decode the same data in different structures—the original
    one and some with extra or missing fields. We will do this to see how the package
    behaves. Let''s define a general decode function and pass different type of structs
    to the decoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to change the order of the fields in the struct to see whether the
    `gob` decoder still works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove some fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put a field in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the package keeps working even if we scramble, add, or remove
    the fields. But if we try to change the type of an existing field into another,
    it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another note about this package is that if you are working with interfaces,
    their implementation should be registered first, using the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the package aware of the specified types and it will enable
    us to call decode on the interface type. Let''s start by defining an interface
    and its implementation for our struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run the following code without the `gob.Register` function, it
    returns an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we register the type, it works like a charm. Note that the data has
    been obtained by encoding a pointer to `Greeter` containing the `Character` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Proto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A protocol buffer is a serialization protocol made by Google. It is language-
    and platform-neutral, with little overhead, and it is very efficient. The idea
    behind it is to define how the data is structured once, then use some tools to
    generate the source code for the target language of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main file that is needed in order to generate the code is the `.proto` file,
    which uses a specific syntax. We will focus on the latest version of the protocol
    syntax, `proto3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify which version of the syntax of the file is to be used in the first
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitions from other files can be used, with the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the file contains definitions of messages (that are data types)
    and services. A service is an interface used to define RPC services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Messages are made up by their fields, and services by their methods. Field types
    are divided between scalars (which includes various integers, signed integers,
    float, strings, and Booleans) and other messages. Each field has a number associated
    to it that is its identifier, which should not be changed once selected, so as
    to maintain compatibility with the older version of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `reserved` keyword allows us to prevent some fields or IDs from being
    reused, as this is very useful to avoid bugs or problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to generate the code from a `.proto` file, you need the `protoc` application
    and the official proto generation package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The installed package comes with the `protoc-gen-go` command; this enables
    the `protoc` command to use the `--go_out` flag to produce Go source files in
    the desired folders. Version 1.4 of Go can specify special comments for automatic
    generation of code with its `go generate` command, and these comments start with
    `//go:generate` followed by the command, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It enables us to specify a source path for import lookup, output directory,
    and a source file. The paths are relative to the package directory where the comment
    is found and it can be invoked with the `go generate $pkg` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple `.proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s create a Go source file in the same folder with the comment for
    generating the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can generate the `go` command that will produce a file with the same
    name as the `.proto` file and the `.pb.go` extension. The file will contain Go
    sources for the types and services defined in the `.proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This package permits us to use the `proto.Buffer` type to encode `pb.Message`
    values. The types created by `protoc` implement the interface defined so the `Character`
    type can be used directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The resulting encoded data has almost no overhead compared to other encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decode operation also needs to be executed using the `proto.Buffer` methods
    and the generated type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: gRPC protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google uses protocol buffer encoding to build a web protocol called **gRPC**.
    It is a type of remote procedure call that uses HTTP/2 to establish connections
    and protocol buffers to marshal and unmarshal data.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is generating code related to the server in the target language.
    This will produce a server interface and a client working implementation. Next,
    a server implementation needs to be created manually, and finally, the target
    language will enable the implementation to be used in a gRPC server and then use
    the client to connect and interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different examples in the `go-grpc` package, including a client/server
    pair. The client uses the generated code, which only needs a working gRPC connection
    to the server, and then it can use the methods specified in the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go](https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_client/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is an implementation of the client interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface implementation can be passed to the generated register function, `RegisterGreeterServer`,
    together with a valid gRPC server, and it can serve incoming connections using
    a TCP listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go](https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the encoding methods offered by the Go standard
    package and third-party libraries. They can be divided into two main categories.
    The first is the textual-based encoding methods, which are easy to read and write
    for both human and machines. However, they have more overhead and tend to be much
    slower than their counterpart, binary-based encoding. Binary-based encoding methods
    have little overhead but are not human readable.
  prefs: []
  type: TYPE_NORMAL
- en: In text-based encoding, we find JSON, XML, and YAML. The first two are handled
    by the standard library, the last needs an external dependency. We explored how
    Go allows us to specify structure tags to change the default encoding and decoding
    behaviors, and how to use these tags in these operations. Then, we checked and
    implemented the interfaces that define custom behavior during the marshal and
    unmarshal operations. There are some third-party tools that allow us to generate
    the data structures from a JSON file or JSON schemas, which are JSON files used
    to define the structure of other JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: XML is another widely used text format that HTML is based on. We checked the
    XML syntax and composing elements and then we showed a specific type of document
    called DTD, which is used for defining the content of other XML files. We learned
    how encoding and decoding works in XML, and the differences to JSON regarding
    `struct` tags that allow us to define nested XML elements for a type or to store
    or load a field from an attribute. We concluded with the text-based encoding with the
    third-party YAML package.
  prefs: []
  type: TYPE_NORMAL
- en: The first binary-based encoding we showed was BSON, a binary version of JSON
    that is used by MongoDB (which is handled by third-party packages). `gob` is another
    binary encoding method but it's part of the Go standard library. We learned that
    both encoding and decoding, together with the involved interfaces, work in the
    standard package fashion—similar to JSON and XML.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the protocol buffer encoding, how to write a `.proto`
    file and its Go code generation usage and how to use it encode and decode data.
    We also introduced a practical example of the gRPC encoding, which takes advantage
    of this encoding to create client/server applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start digging into Go's concurrency model, starting
    with the built-in types—channels and goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the trade-off between text and binary encodings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Go behave with data structure by default?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can this behavior be changed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a structure field get encoded in an XML attribute?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What operation is needed to decode a `gob` interface value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the protocol buffer encoding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
