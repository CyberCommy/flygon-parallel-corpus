- en: Securing User Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing users is one of the more challenging aspects of IT administration.
    You need to make sure that users can always access their stuff and that they can
    perform the required tasks to do their jobs. You also need to ensure that users'
    stuff is always secure from unauthorized users and that users can't perform any
    tasks that don't fit their job description. It's a tall order, but we aim to show
    that it's doable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The dangers of logging in as the root user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of using sudo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up sudo privileges for full administrative users and for users with
    only certain delegated privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced tips and tricks to use sudo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking down users' home directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing strong password criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and enforcing password and account expiration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing brute-force password attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up security banners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dangers of logging in as the root user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A huge advantage that Unix and Linux operating systems have over Windows is
    that Unix and Linux do a much better job of keeping privileged administrative
    accounts separated from normal user accounts. Indeed, one reason that older versions
    of Windows were so susceptible to security issues, such as **drive-by** virus
    infections, was the common practice of setting up user accounts with administrative
    privileges, without having the protection of the **User Access Control** that's
    in newer versions of Windows. (Even with User Access Control, Windows systems
    still do get infected, just not quite as often.)  With Unix and Linux, it's a
    lot harder to infect a properly configured system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You likely already know that the all-powerful administrator account on a Unix
    or Linux system is the root account. If you''re logged in as the root user, you
    can do anything you want to do to that system. So you may think, "*Yeah, that''s
    handy, so that''s what I''ll do.*" However, always logging in as the root user
    can present a whole load of security problems. Consider the following. Logging
    in as the root user can:'
  prefs: []
  type: TYPE_NORMAL
- en: Make it easier for you to accidentally perform an action that causes damage
    to the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it easier for someone else to perform an action that causes damage to the
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So if you always log on as the root user or even if you just make the root user
    account readily accessible, you could say that you're doing a big part of attackers'
    and intruders' work for them. Also, imagine if you were the head Linux administrator
    at a large corporation, and the only way to allow users to perform admin tasks
    was to give them all the root password. What would happen if one of those users
    were to leave the company? You wouldn't want for that person to still have the
    ability to log in to the systems, so you'd have to change the password and distribute
    the new one to all of the other users. And, what if you just want for users to
    have admin privileges for only certain tasks, instead of having full root privileges?
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a mechanism that allows users to perform administrative tasks
    without incurring the risk of having them always log on as the root user and that
    would also allow users to have only the admin privileges they really need to perform
    a certain job. In Linux and Unix, we have that mechanism in the form of the sudo
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Used properly, the sudo utility can greatly enhance the security of your systems,
    and it can make an administrator''s job much easier. With sudo, you can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign certain users full administrative privileges, while assigning other users
    only the privileges they need to perform tasks that are directly related to their
    respective jobs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to perform administrative tasks by entering their own normal user
    passwords so that you don't have to distribute the root password to everybody
    and his brother.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it harder for intruders to break into your systems. If you implement sudo
    and disable the root user account, would-be intruders won't know which account
    to attack because they won't know which one has admin privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create sudo policies that you can deploy across an entire enterprise network
    even if that network has a mix of Unix, BSD, and Linux machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your auditing capabilities because you'll be able to see what users
    are doing with their admin privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In regards to that last bullet point, consider the following snippet from the
    `secure` log of my CentOS 7 virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that I used `su -` to log in to the root command prompt and that
    I then logged back out. While I was logged in, I did several things that require
    root privileges, but none of that got recorded. What did get recorded though is
    something that I did with sudo. That is, because the root account is disabled
    on this machine, I used my sudo privilege to get `su -` to work for me. Let''s
    look at another snippet to show a bit more detail about how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This time, I used my sudo privilege to open a log file, to view my hard drive
    configuration, to perform a system update, to check the status of the Secure Shell
    daemon, and to once again view a log file. So, if you were the security administrator
    at my company, you'd be able to see whether or not I'm abusing my sudo power.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you're asking, "*What's to prevent a person from just doing a sudo su -
    to prevent his or her misdeeds from being detected?*" That's easy. Just don't
    give people the power to go to the root command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up sudo privileges for full administrative users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at how to limit what users can do, let's first look at how to
    allow a user to do everything, including logging into the root command prompt.
    There are a couple of methods for doing that.
  prefs: []
  type: TYPE_NORMAL
- en: Method 1 – adding users to a predefined admin group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first method, which is the simplest, is to add users to a predefined administrators
    group and then, if it hasn't already been done, to configure the sudo policy to
    allow that group to do its job. It's simple enough to do except that different
    Linux distro families use different admin groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Unix, BSD, and most Linux systems, you would add users to the `wheel` group.
    (Members of the Red Hat family, including CentOS, fall into this category.) When
    I do the `groups` command on my CentOS machine, I get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that I''m a member of the wheel group. By doing `sudo visudo`, I''ll
    open the sudo policy file. Scrolling down, we''ll see the line that gives the
    wheel group its awesome power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The percent sign indicates that we''re working with a group. The three ALLs
    mean that members of that group can perform any command, as any user, on any machine
    in the network on which this policy is deployed. The only slight catch is that
    group members will be prompted to enter their own normal user account passwords
    in order to perform a sudo task. Scroll down a bit more, and you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we were to comment out the `%wheel` line in the former snippet and remove
    the comment symbol from in front of the `%wheel` line in this snippet, then members
    of the `wheel` group would be able to perform all of their sudo tasks without
    ever having to enter any password. That's something that I really don't recommend,
    even for home use. In a business setting, allowing people to have passwordless
    sudo privileges is a definite no-no.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an existing user to the `wheel` group, use `usermod` with the `-G` option.
    You might also want to use the `-a` option as well, in order to prevent removing
    the user from other groups to which he or she belongs. For our example, let''s
    add Maggie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add a user account to the `wheel` group as you create it. Let''s
    do that now for Frank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that with my usage of `useradd`, I''m assuming that we''re working with
    a member of the Red Hat family, which comes with predefined default settings to
    create user accounts. For non-Red Hat-type distros that use the `wheel` group,
    you''d need to either reconfigure the default settings or use extra option switches
    in order to create the user''s home directory and to assign the correct shell.
    Your command then would look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`sudo useradd -G wheel -m -d /home/frank -s /bin/bash frank`**'
  prefs: []
  type: TYPE_NORMAL
- en: For members of the Debian family, including Ubuntu, the procedure is the same,
    except that you would use the `sudo` group instead of the `wheel` group. (This
    kind of figures, considering that the Debian folk have pretty much always marched
    to the beat of a different drummer.)
  prefs: []
  type: TYPE_NORMAL
- en: One way in which this technique would come in handy is whenever you need to
    create a virtual private server on a cloud service, such as Rackspace, DigitalOcean,
    or Vultr. When you log in to one of those services and initially create your virtual
    machine, the cloud service will have you log in to that virtual machine as the
    root user. (This even happens with Ubuntu, even though the root user account is
    disabled whenever you do a local installation of Ubuntu.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that you''ll want to do in this scenario is to create a normal
    user account for yourself and give it full sudo privileges. Then, log out of the
    root account and log back in with your normal user account. You''ll then want
    to disable the root account with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`sudo passwd -l root`**'
  prefs: []
  type: TYPE_NORMAL
- en: You'll also want to do some additional configuration to lock down Secure Shell
    access, but we'll cover that in [Chapter 4](081f4a65-5141-48fb-a865-0c23c96019c3.xhtml),
    *Encrypting and SSH Hardening*.
  prefs: []
  type: TYPE_NORMAL
- en: Method 2 – creating an entry in the sudo policy file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, adding users to either the `wheel` group or the `sudo` group works great
    if you''re either just working with a single machine or if you''re deploying a
    sudo policy across a network that uses just one of these two admin groups. But
    what if you want to deploy a sudo policy across a network with a mixed group of
    both Red Hat and Ubuntu machines? Or what if you don''t want to go around to each
    machine to add users to an admin group? Then, just create an entry in the sudo
    policy file. You can either create an entry for an individual user or create a
    user alias. If you do `sudo visudo` on your CentOS virtual machine, you''ll see
    a commented-out example of a user alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can uncomment this line and add your own set of usernames, or you can just
    add a line with your own user alias. To give members of the user alias full sudo
    power, add another line that would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to add a `visudo` entry for just a single user, and you
    might need to do that under very special circumstances. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But for ease of management, it's best to go with either a user group or a user
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: The sudo policy file is the `/etc/sudoers` file. I always hesitate to tell students
    that because every once in a while I have a student try to edit it in a regular
    text editor. That doesn't work though, so please don't try it. Always edit `sudoers`
    with the command, `sudo visudo`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up sudo for users with only certain delegated privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic tenet of IT security philosophy is to give network users enough privileges
    so that they can get their jobs done, but no privileges beyond that. So, you'll
    want as few people as possible to have full sudo privileges. (If you have the
    root user account enabled, you'll want even fewer people to know the root password.)
    You'll also want a way to delegate privileges to people according to what their
    specific jobs are. Backup admins will need to be able to perform backup tasks,
    help desk personnel will need to perform user management tasks, and so on. With
    sudo, you can delegate these privileges and disallow users from doing any other
    administrative jobs that don't fit their job description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to explain this is to have you open `visudo` on your CentOS virtual
    machine. So, go ahead and start the CentOS VM and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike Ubuntu, CentOS has a fully commented and well-documented `sudoers` file.
    I''ve already shown you the line that creates the `ADMIN` user alias, and you
    can create other user aliases for other purposes. You can, for example, create
    a `BACKUPADMINS` user alias for backup administrators, a `WEBADMINS` user alias
    for web server administrators, or whatever else you desire. So, you could add
    a line that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That's good, except that Vicky and Cleopatra still can't do anything. You'll
    need to assign some duties to the user alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the example user alias mentioned later, you''ll see a list of
    example `Command Aliases`. One of these examples just happens to be `SOFTWARE`,
    which contains the commands that an admin would need to either install or remove
    software or to update the system. It''s commented out, as are all of the other
    example command aliases, so you''ll need to remove the hash symbol from the beginning
    of the line before you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s just a simple matter of assigning the `SOFTWARE` command alias to
    the `SOFTWAREADMINS` user alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Vicky and Cleopatra, both members of the `SOFTWAREADMINS` user alias, can now
    run the `rpm`, `up2date`, and `yum` commands with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'All but one of these predefined command aliases are ready to use after you
    uncomment them and assign them to either a user, group, or user alias. The one
    exception is the `SERVICES` command alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this `SERVICES` alias is that it also lists the different
    subcommands for the `systemctl` command. The way sudo works is that if a command
    is listed by itself, then the assigned user can use that command with any subcommands,
    options, or arguments. So, in the `SOFTWARE` example, members of the `SOFTWARE`
    user alias can run a command such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But, when a command is listed in the command alias with a subcommand, option,
    or argument, that''s all anyone who''s assigned to the command alias can run.
    With the `SERVICES` command alias in its current configuration, the `systemctl`
    commands just won''t work. To see why, let''s set Charlie and Lionel up in the
    `SERVICESADMINS` user alias and then uncomment the `SERVICES` command alias, as
    we''ve already done earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, watch what happens when Lionel tries to check the status of the Secure
    Shell service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so Lionel can run `sudo systemctl status`, which is pretty much useless,
    but he can''t do anything meaningful, like specifying the service that he wants
    to check. That''s a bit of a problem. There are two ways to fix this, but there''s
    only one way that you want to use. You could just eliminate all of the `systemctl`
    subcommands and make the `SERVICES` alias look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if you do that, Lionel and Charlie will also be able to shut down or reboot
    the system, edit the services files, or change the machine from one systemd target
    to another. That''s probably not what you want. Because the `systemctl` command
    covers a lot of different functions, you have to be careful not to allow delegated
    users to access too many of those functions. A better solution would be to add
    a wildcard to each of the `systemctl` subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Lionel and Charlie can perform any of the `systemctl` functions that are
    listed in this command alias, for any service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that you''re not limited to using user aliases and command aliases.
    You can also assign privileges to either a Linux group or to an individual user.
    You can also assign individual commands to a user alias, Linux group, or individual
    user. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Katelyn can now do all of the commands in the `STORAGE` command alias, whereas
    Gunther can only use `fdisk` to look at the partition tables. The members of the
    `backup_admins` Linux group can do commands in the `BACKUP` command alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we''ll look at for this topic is the host aliases examples that
    you see preceding the user alias example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each host alias consists of a list of server hostnames. This is what allows
    you to create one `sudoers` file on one machine, and deploy it across the network.
    For example, you could create a `WEBSERVERS` host alias, a `WEBADMINS` user alias,
    and a `WEBCOMMANDS` command alias with the appropriate commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your configuration would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, when a user types a command into a server on the network, sudo will first
    look at the hostname of that server. If the user is authorized to perform that
    command on that server, then sudo allows it. Otherwise, sudo denies it. In a small
    to medium-sized business, it would probably work just fine to manually copy the
    master `sudoers` file to all the servers on the network. But, in a large enterprise,
    you'll want to streamline and automate the process. For this, you could use something
    like Puppet, Chef, or Ansible. (These three technologies are beyond the scope
    of this book, but you'll find plenty of books and video courses about all three
    of them at the Packt website.)
  prefs: []
  type: TYPE_NORMAL
- en: All of these techniques will work on your Ubuntu VM as well as on the CentOS
    VM. The only catch is, Ubuntu doesn't come with any predefined command aliases,
    so you'll have to type them in yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, I know that you're tired of reading, so let's do some work.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for assigning limited sudo privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lab, you'll create some users and assign them different levels of privileges.
    To simplify things, we'll use the CentOS virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the CentOS virtual machine and create user accounts for Lionel, Katelyn,
    and Maggie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `visudo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Find the `STORAGE` command alias and remove the comment symbol from in front
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the end of the file, using tabs to separate the
    columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit `visudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save time, we''ll use `su` to log into the different user accounts. You
    won''t need to log out of your own account to perform these steps. First, log
    in to Lionel''s account and verify that he has full sudo privileges by running
    several root-level commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This time, log in as Katelyn and try to run some root-level commands. (Don't
    be too disappointed if they don't all work, though.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, log in as Maggie, and run the same set of commands that you ran for
    Katelyn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that although we only had three individual users for this lab,
    you could just as easily have handled more users by setting them up in user aliases
    or Linux groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since sudo is such a great security tool, you would think that everyone would
    use it, right? Sadly, that's not the case. Pretty much any time you look at either
    a Linux tutorial website or a Linux tutorial YouTube channel, you'll see the person
    who's doing the demo logged in at the root user command prompt. In some cases,
    I've seen the person remotely logged in as the root user on a cloud-based virtual
    machine. Now, if logging in as the root user is already a bad idea, then logging
    in across the internet as the root user is an even worse idea. In any case, seeing
    everybody do these tutorial demos from the root user's shell drives me absolutely
    crazy.
  prefs: []
  type: TYPE_NORMAL
- en: Having said all this, there are some things that don't work with sudo. Bash
    shell internal commands, such as `cd` don't work with it, and injecting kernel
    values into the `/proc` filesystem also doesn't work with it. For tasks such as
    these, a person would have to go to the root command prompt. Still though, make
    sure that only users who absolutely have to use the root user command prompt have
    access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced tips and tricks for using sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at the basics of setting up a good sudo configuration,
    we're confronted with a bit of a paradox. That is, even though sudo is a security
    tool, certain things that you can do with it can make your system even more insecure
    than it was. Let's see how to avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: The sudo timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the sudo timer is set for 5 minutes. This means that once a user
    performs one `sudo` command and enters a password, he or she can perform another
    `sudo` command within 5 minutes without having to enter the password again. Although
    this is obviously handy, it can also be problematic if users were to walk away
    from their desks with a command terminal still open. If the 5 minute timer hasn't
    yet expired, someone else could come along and perform some root-level task. If
    your security needs require it, you can easily disable this timer by adding a
    line to the `Defaults` section of the `sudoers` file. This way, users will have
    to enter their passwords every time they run a `sudo` command. You can make this
    a global setting for all users, or you can just set it for certain individual
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for disabling the sudo timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this lab, you'll disable the sudo timer on your CentOS VM.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the same CentOS virtual machine that you used for the previous lab.
    We'll be using the user accounts that you've already created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At your own user account command-prompt, enter the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You'll see that you only needed to enter the password once to do all three commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `visudo` with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Defaults` specification section of the file, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit `visudo`.
  prefs: []
  type: TYPE_NORMAL
- en: Perform the commands that you performed in *Step 2*. This time, you should see
    that you have to enter a password every time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `visudo` and modify the line that you added so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit `visudo`.
  prefs: []
  type: TYPE_NORMAL
- en: From your own account shell, repeat the commands that you performed in *Step
    2*. Then, log in as Lionel and perform the commands again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this same procedure also works for Ubuntu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preventing users from having root shell access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you want to set up a user with limited sudo privileges, but
    you did so by adding a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I'm sorry to say that you haven't limited Maggie's access at all. You effectively
    gave her full sudo privileges with both the Bash shell and the Zsh shell. So,
    don't add lines like this to your `sudoers` because it will get you into trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing users from using shell escapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Certain programs, especially text editors and pagers, have a handy *shell escape*
    feature. This allows a user to run a shell command without having to exit the
    program first. For example, from the command mode of the Vi and Vim editors, someone
    could run the `ls` command by doing `:!ls`. Executing the command would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that you want Frank to be able to edit the `sshd_config` file
    and only that file. You might be tempted to add a line to your sudo configuration
    that would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like it would work, right? Well, it doesn''t because once Frank
    has opened the `sshd_config` file with his sudo privilege, he can then use Vim''s
    shell escape feature to perform other root-level commands, which would include
    being able to edit other configuration files. You can fix this problem by having
    Frank use `sudoedit` instead of vim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`sudoedit` has no shell escape feature, so you can safely allow Frank to use
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other programs that have a shell escape feature include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: emacs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing users from using other dangerous programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some programs that don''t have shell escapes can still be dangerous if you
    give users unrestricted privileges to use them. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: cat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: awk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you must give someone sudo privileges to use one of these programs, it's
    best to limit their use to only specific files. And, that brings us to our next
    tip.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the user's actions with commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you create a sudo rule so that Sylvester can use the `systemctl`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows Sylvester to have full use of the `systemctl` features. He can
    control daemons, edit service files, shutdown or reboot, and every other function
    that `systemctl` does. That''s probably not what you want. It would be better
    to specify what `systemctl` functions that Sylvester is allowed to do. Let''s
    say that you want him to be able to control just the Secure Shell service. You
    can make the line look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Sylvester can now do everything he needs to do with the Secure Shell service,
    but he can''t shut down or reboot the system, edit service files, or change systemd
    targets. But, what if you want Sylvester to do only certain specific actions with
    the Secure Shell service? Then, you''ll have to omit the wild card and specify
    all of the actions that you want for Sylvester to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, Sylvester can only restart the Secure Shell service or check its status.
  prefs: []
  type: TYPE_NORMAL
- en: When writing sudo policies, you'll want to be aware of the differences between
    the different Linux and Unix distros on your network. For example, on Red Hat
    7 and CentOS 7 systems, the `systemctl` binary file is located in the `/usr/bin`
    directory. On Debian/Ubuntu systems, it's located in the `/bin` directory. If
    you have to roll out a `sudoers` file to a large enterprise network with mixed
    operating systems, you can use host aliases to ensure that servers will only allow
    the execution of commands that are appropriate for their operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Also, be aware that some system services have different names on different Linux
    distros. On Red Hat and CentOS systems, the Secure Shell service is `sshd`. On
    Debian/Ubuntu systems, it's just plain `ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: Letting users run as other users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following line, `(ALL)` means that Sylvester can run the `systemctl`
    commands as any user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This effectively gives Sylvester root privileges for these commands because
    the root user is definitely any user. You could, if desired, change that `(ALL)`
    to `(root)` in order to specify that Sylvester can only run these commands as
    the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, there''s probably not much point in that because nothing changes. Sylvester
    had root privileges for these `systemct`l commands before, and he still has them
    now. But, there are more practical uses for this feature. Let''s say that Vicky
    is a database admin, and you want her to run as the `database` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Vicky could then run the command as the `database` user by entering the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is one of those features that you might not use that often, but keep it
    in mind anyway. You never know when it might come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this wraps it up for our discussion of sudo. Let's now turn our attention
    to ensuring the security of our regular users.
  prefs: []
  type: TYPE_NORMAL
- en: Locking down users' home directories the Red Hat or CentOS way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another area where different Linux distro families do business differently
    from each other. As we shall see, each distro family comes with different default
    security settings. A security administrator who oversees a mixed environment of
    different Linux distros will need to take this into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'One beautiful thing about Red Hat Enterprise Linux and all of its offspring,
    such as CentOS, is that they have better out-of-the-box security than any other
    Linux distro. This makes it quicker and easier to harden Red Hat-type systems
    because much of the work has already been done. One thing that''s already been
    done for us is locking down users'' home directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `useradd` utility on Red Hat-type systems creates user home
    directories with a permissions setting of `700`. This means that only the user
    who owns the home directory can access it. All other normal users are locked out.
    We can see why by looking at the `/etc/login.defs` file. Scroll down towards the
    bottom of the file, and you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `login.defs` file is one of two files where default settings for `useradd`
    are configured. This `UMASK` line is what determines the permissions values on
    home directories as they get created. Red Hat-type distros have it configured
    with the `077` value, which removes all permissions from the *group* and *others*.
    This `UMASK` line is in the `login.defs` file for all Linux distros, but Red Hat-type
    distros are the only ones that have `UMASK` set to such a restrictive value by
    default. Non-Red Hat distros usually have a `UMASK` value of `022`, which creates
    home directories with a permissions value of `755`. This allows everybody to enter
    everybody else's home directories and access each others' files.
  prefs: []
  type: TYPE_NORMAL
- en: Locking down users' home directories the Debian/Ubuntu way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debian and its offspring, such as Ubuntu, have two user creation utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useradd` on Debian/Ubuntu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adduser` on Debian/Ubuntu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: useradd on Debian/Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `useradd` utility is there, but Debian and Ubuntu don''t come with the
    handy preconfigured defaults as Red Hat and CentOS do. If you were to just do
    `sudo useradd frank` on a default Debian/Ubuntu machine, Frank would have no home
    directory and would be assigned the wrong default shell. So, to create a user
    account with `useradd` on a Debian or Ubuntu system, the command would look something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-m` creates the home directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d` specifies the home directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s` specifies Frank''s default shell. (Without the `-s`, Debian/Ubuntu would
    assign to Frank the `/bin/sh` shell.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you look at the home directories, you''ll see that they''re wide open,
    with execute and read privileges for everybody:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Frank and I can get into each other''s stuff. (And no, I don''t
    want Frank getting into my stuff.) Each user could change the permissions on his
    or her own directory, but how many of your users would know how to do that? So,
    let''s fix that ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we have now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: That looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the default permissions setting for home directories, open `/etc/login.defs`
    for editing. Look for the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, new users' home directories will get locked down on creation, just as they
    do with Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: adduser on Debian/Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `adduser` utility is an interactive way to create user accounts and passwords
    with a single command, which is unique to the Debian family of Linux distros.
    Most of the default settings that are missing from the Debian implementation of
    `useradd` are already set for `adduser`. The only thing wrong with the default
    settings is that it creates user home directories with the wide-open `755` permissions
    value. Fortunately, that's easy to change. (We'll see how in just a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `adduser` is handy for just casual creation of user accounts, it doesn''t
    offer the flexibility of `useradd` and it isn''t suitable for use in shell scripting.
    One thing that `adduser` will do that `useradd` won''t is to automatically encrypt
    a user''s home directory as you create the account. To make it work, you''ll first
    have to install the `ecryptfs-utils` package. So, to create an account with an
    encrypted home directory for Cleopatra, you do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time that Cleopatra logs in, she''ll need to run the `ecryptfs-unwrap-passphrase`
    command that''s mentioned in the preceding output. She''ll then want to write
    her passphrase down and store it in a safe place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at the whole encryption thing more in detail when we get to the encryption
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for configuring adduser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this lab, we''ll be working with the `adduser` utility, which is peculiar
    to Debian/Ubuntu systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On your Ubuntu virtual machine, open the `/etc/adduser.conf` file for editing.
    Find the line that says:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `ecryptfs-utils` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a user account with encrypted home directory for Cleopatra and then
    view the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in as Cleopatra and run the `ecryptfs-unwrap-passphrase` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that some of the information that `adduser` asks for is optional, and you
    can just hit the *Enter* key for those items.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing strong password criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You wouldn''t think that a benign-sounding topic such as *strong password criteria*
    would be so controversial, but it is. The conventional wisdom that you''ve undoubtedly
    heard for your entire computer career says:'
  prefs: []
  type: TYPE_NORMAL
- en: Make passwords of a certain minimum length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make passwords that consist of a combination of uppercase letters, lowercase
    letters, numbers, and special characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that passwords don't contain any words that are found in the dictionary
    or that are based on the users' own personal data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force users to change their passwords on a regular basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, using your favorite search engine, you'll see that different experts disagree
    on the details of these criteria. For example, you'll see disagreements about
    whether passwords should be changed every 30, 60, or 90 days, disagreements about
    whether all four types of characters need to be in a password, and even disagreements
    on what the minimum length of a password should be.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting controversy of all comes from—of all places—the guy who
    invented the preceding criteria to begin with. He now says that it's all bunk
    and regrets having come up with it. He now says that we should be using passphrases
    that are long, yet easy to remember. He also says that they should be changed
    only if they've been breached.
  prefs: []
  type: TYPE_NORMAL
- en: Bill Burr, the former National Institutes of Standards and Technology engineer
    who created the strong password criteria that I've outlined earlier, shares his
    thoughts about why he now disavows his own work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to: [https://www.pcmag.com/news/355496/you-might-not-need-complex-alphanumeric-passwords-after-all](https://www.pcmag.com/news/355496/you-might-not-need-complex-alphanumeric-passwords-after-all).'
  prefs: []
  type: TYPE_NORMAL
- en: However, having said all that, there is the reality that most organizations
    are still wedded to the idea of using complex passwords that regularly expire,
    and you'll have to abide by their rules if you can't convince them otherwise.
    And besides, if you are using traditional passwords, you do want them to be strong
    enough to resist any sort of password attack. So now, we'll take a look at the
    mechanics of enforcing strong password criteria on a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: I have to confess that I had never before thought to try creating a passphrase
    to use in place of a password on a Linux system. So, I just now tried it on my
    CentOS virtual machine to see if it would work.
  prefs: []
  type: TYPE_NORMAL
- en: I created an account for Maggie, my black-and-white tuxedo kitty. For her password,
    I entered the passphrase, `I like other kitty cats`. You may think, "*Oh, that's
    terrible. This doesn't meet any complexity criteria, and it uses dictionary words.
    How is that secure?*" But, the fact that it's a phrase with distinct words separated
    by blank spaces does make it secure and very difficult to brute-force.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in real life, I would never create a passphrase that expresses my love
    for cats because it's not hard to find out that I really do love cats. Rather,
    I would choose a passphrase about some more obscure part of my life that nobody
    but me knows about.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, there are two advantages of passphrases over passwords. They're
    more difficult to crack than traditional passwords, yet they're easier for users
    to remember. For extra security though, just don't create passphrases about a
    fact of your life that everybody knows about.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring pwquality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using the `pwquality` module for **PAM** (**Pluggable Authentication
    Module**). This is a newer technology that has replaced the old `cracklib` module.
    On a Red Hat 7 or CentOS 7 system, `pwquality` is installed by default, even if
    you do a minimal installation. If you `cd` into the `/etc/pam.d` directory, you
    can do a `grep` operation to see that the PAM configuration files are already
    set up. The `retry=3` means that a user will only have three tries to get the
    password right when logging into the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For your Ubuntu system, you''ll need to install `pwquality` yourself. You''ll
    do that with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now `cd` into the `/etc/pam.d` directory and perform the same `grep`
    command that we did before. We''ll see that installing the `libpam-pwquality`
    modules automatically updates the PAM configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the procedure is the same for both operating systems and consists
    of just editing the `/etc/security/pwquality.conf` file. When you open this file
    in your text editor, you'll see that everything is commented out, which means
    that no password complexity criteria are in effect. You'll also see that it's
    very well-documented because every setting has its own explanatory comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set password complexity criteria however you want just by uncommenting
    the appropriate lines and setting the proper values. Let''s take a look at just
    one setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The minimum length setting works on a credit system. This means that for every
    different type of character class in the password, the minimum required password
    length will be reduced by one character. For example, let''s set the `minlen`
    to a value of `19` and try to assign Katelyn the password, `turkeylips`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the lowercase characters in `turkeylips` count as credit for one type
    of character class, we''re only required to have 18 characters instead of 19\.
    If we try this again with `TurkeyLips`, we''ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This time, the uppercase `T` and uppercase `L` count as a second character class,
    so we only need to have 17 characters in the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below the `minlen` line, you''ll see the credit lines. Let''s say that
    you don''t want lowercase letters to count toward your credits. You would find
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you would change the `1` to a `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, try assigning Katelyn `turkeylips` as a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This time, the `pwquality` really does want 19 characters. If we set a credit
    value to something higher than one, we would get credit for multiple characters
    of the same class type up to that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set the credit values to negative numbers in order to require a
    certain number of characters types in a password. We have the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This would require at least three digits in a password. However, it''s a really
    a bad idea to use this feature because someone who''s doing a password attack
    would soon find the patterns that you require, which would help the attacker to
    more precisely direct the attack. If you need to require that a password has multiple
    character types, it would be better to use the `minclass` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: It's already set to a value of three, which would require characters from three
    different classes. To use this value, all you have to do is to remove the comment
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the parameters in `pwquality.conf` work pretty much the same way,
    and each one has a well-written comment to explain what it does.
  prefs: []
  type: TYPE_NORMAL
- en: If you use your sudo privilege to set someone else's password, the system will
    complain if you create a password that doesn't meet complexity criteria, but it
    will let you do it. If a normal user were to try to change his or her own password
    without sudo privileges, the system would not allow a password that doesn't meet
    complexity criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for setting password complexity criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this lab, you can use either the CentOS or Ubuntu virtual machine, as desired.
    The only difference is that you won''t perform *Step 1* for CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ubuntu only, install the `libpam-pwquality` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `/etc/security/pwquality.conf` file in your preferred text editor.
    Remove the comment symbol from in front of the `minlen` line and change the value
    to `19`. It should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Create a user account for Goldie and attempt to assign her the passwords, `turkeylips`,
    `TurkeyLips`, and `Turkey93Lips`. Note the change in each warning message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `pwquality.conf` file, comment out the `minlen` line. Uncomment the
    `minclass` line and the `maxclassrepeat` line. Change the `maxclassrepeat` value
    to `5`. The lines should now look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Try assigning various passwords that don't meet the complexity criteria that
    you've set to Goldie's account and view the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `/etc/login.defs` file on your CentOS machine, you''ll see the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PASS_MIN_LEN    5`'
  prefs: []
  type: TYPE_NORMAL
- en: Supposedly, this is to set the minimum password length, but in reality, `pwquality`
    overrides it. So, you could set this value to anything at all, and it would have
    no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and enforcing password and account expiration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something you never want is to have unused user accounts remain active. There
    have been incidents where an administrator set up user accounts for temporary
    usage, such as for a conference, and then just forgot about them after the accounts
    were no longer needed. Another example would be if your company were to hire contract
    workers whose contract expires on a specific date. Allowing those accounts to
    remain active and accessible after the temporary employees leave the company would
    be a huge security problem. In cases like these, you want a way to ensure that
    temporary user accounts aren't forgotten about when they're no longer needed.
    If your employer subscribes to the conventional wisdom that users should change
    their passwords on a regular basis, then you'll also want to ensure that it gets
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Password expiration data and account expiration data are two different things.
    They can be set either separately or together. When someone's password expires,
    he or she can change it, and everything will be all good. If somebody's account
    expires, only someone with the proper admin privileges can unlock it.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, take a look at the expiry data for your own account. (Note that
    you won't need sudo privileges to look at your own data, but you will still need
    to specify your own username.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here that no expiration data have been set. Everything here is
    set according to the out-of-box system default values. Other than the obvious
    items, here''s a breakdown of what you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password inactive**: If this were set to a positive number, I would have
    that many days to change an expired password before the system would lock out
    my account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum number of days between password change**: Because this is set to
    `0`, I can change my password as often as I like. If it were set to a positive
    number, I would have to wait that number of days after changing my password before
    I could change it again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum number of days between password change**: This is set to the default
    value of `99999`, meaning that my password will never expire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of days warning before password expires**: The default value is `7`,
    but that''s rather meaningless when the password is set to never expire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `chage` utility, you can either set password and account expiration
    data for other users or you use the `-l` option to view expiration data. Any unprivileged
    user can use `chage -l` without sudo to view his or her own data. To either set
    data or view someone else's data, you need sudo. We'll take a closer look at `chage`
    a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at how to change expiration data, let''s first look at where
    the default settings are stored. We''ll first look at the `/etc/login.defs` file.
    The three relevant lines are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can edit these values to fit your organization's needs. For example, changing
    `PASS_MAX_DAYS` to a value of `30` would cause all new user passwords from that
    point on to have a 30 day expiration data. (By the way, setting the default password
    expiry data in `login.defs` works for both Red Hat or CentOS and Debian/Ubuntu.)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring default expiry data for useradd – for Red Hat or CentOS only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `/etc/default/useradd` file has the rest of the default settings. In this
    case, we'll look at the one from the CentOS machine.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu also has this same `useradd` configuration file, but it doesn't work.
    No matter how you configure it, the Ubuntu version of `useradd` just won't read
    it. So, the write-up about this file only applies to Red Hat or CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EXPIRE=` line sets the default expiration date for new user accounts.
    By default, there is no default expiration date. `INACTIVE=-1` means that user
    accounts won''t be automatically locked out after the users'' passwords expire.
    If we set this to a positive number, then any new users will have that many days
    to change an expired password before the account gets locked. To change the defaults
    in the `useradd` file, you can either hand-edit the file or use `useradd -D` with
    the appropriate option switch for the item that you want to change. For example,
    to set a default expiration date of December 31, 2019, the command would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the new configuration, you can either open the `useradd` file or just
    do `sudo useradd -D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve now set it so that any new user accounts that get created will have
    the same expiration date. You can do the same thing with either the `INACTIVE`
    setting or the `SHELL` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now, any new user accounts that get created will have the Zsh shell set as the
    default shell and will have to have expired passwords changed within five days
    to prevent having the account automatically locked out.
  prefs: []
  type: TYPE_NORMAL
- en: '`useradd` doesn''t do any safety checks to ensure that the default shell that
    you''ve assigned is installed on the system. In our case, Zsh isn''t installed,
    but `useradd` will still allow you to create accounts with Zsh as the default
    shell.'
  prefs: []
  type: TYPE_NORMAL
- en: So, just how useful is this `useradd` configuration feature in real life? Probably
    not that much, unless you need to create a whole bunch of user accounts at once
    with the same settings. Even so, a savvy admin would just automate the process
    with a shell script, rather than messing around with this configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting expiry data on a per-account basis, with useradd and usermod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might find it useful to set the default password expiry data in `login.defs`,
    but you probably won't find it too useful to configure the `useradd` configuration
    file. Really, what are the chances that you'll want to create all user accounts
    with the same account expiration date? Setting password expiry data in `login.defs`
    is more useful because you'll just be saying that you want new passwords to expire
    within a certain number of days, rather than to have them all expire on a specific
    date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most likely, you''ll want to set account expiry data on a per-account basis,
    depending on whether you know that the accounts will no longer be needed as of
    a specific date. There are three ways that you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `useradd` with the appropriate option switches to set expiry data as you
    create the accounts. (If you need to create a whole bunch of accounts at once
    with the same expiry data, you can automate the process with a shell script.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `usermod` to modify expiry data on existing accounts. (The beautiful thing
    about `usermod` is that it uses the same option switches as `useradd`.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `chage` to modify expiry data on existing accounts. (This one uses a whole
    different set of option switches.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use `useradd` and `usermod` to set account expiry data, but not for
    setting password expiry data. The only two option switches that affect account
    expiry data are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`: Use this to set an expiration date for the account, in the form YYYY-MM-DD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: Use this to set the number of days after the user''s password expires
    that you want for his or her account to get locked out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say that you want to create an account for Charlie that will expire
    at the end of 2020\. On a Red Hat or CentOS machine, you could enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'On a non-Red Hat or CentOS machine, you''d have to add the option switches
    that create the home directory and assign the correct default shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `chage -l` to verify what you''ve entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that Charlie''s contract has been extended, and you need to
    change his account expiration to the end of January, 2021\. You''ll use `usermod`
    the same way on any Linux distro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, verify that everything is correct with `chage -l`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can set the number of days before an account with an expired
    password will get locked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: But, if you were to do that now, you wouldn't see any difference in the `chage
    -l` output because we still haven't set an expiration data for Charlie's password.
  prefs: []
  type: TYPE_NORMAL
- en: Setting expiry data on a per-account basis, with chage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You would only use `chage` to modify existing accounts, and you would use it
    for setting either an account expiration or a password expiration. Here are the
    relevant option switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-d` | If you use the `-d 0` option on someone''s account, you''ll force
    the user to change his or her password on their next login. |'
  prefs: []
  type: TYPE_TB
- en: '| `-E` | This is equivalent to the lower-case `-e` for `useradd` or `usermod`.
    It sets the expiration date for the user account. |'
  prefs: []
  type: TYPE_TB
- en: '| `-I` | This is equivalent to `-f` for `useradd` or `usermod`. It sets the
    number of days before an account with an expired password will be locked out.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-m` | This sets the minimum number of days between password changes. In
    other words, if Charlie changes his password today, a `-m 5` option will force
    him to wait five days before he can change his password again. |'
  prefs: []
  type: TYPE_TB
- en: '| `-M` | This sets the maximum number of days before a password expires. (Be
    aware though that if Charlie last set his password 89 days ago, using a `-M 90`
    option on his account will cause his password to expire tomorrow, not 90 days
    from now.) |'
  prefs: []
  type: TYPE_TB
- en: '| `-W` | This will set the number of warning days for passwords that are about
    to expire. |'
  prefs: []
  type: TYPE_TB
- en: 'You can set just one of these data items at a time or you can set them all
    at once. In fact, to avoid frustrating you with a different demo for each individual
    item, let''s set them all at once, except for the `-d 0`, and then we''ll see
    what we''ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: All expiration data have now been set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our final example, let''s say that you''ve just created a new account for
    Samson, and you want to force him to change his password the first time he logs
    in. There are two ways to do that. Either way, you would do it after you''ve set
    his password initially. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Hands-on lab for setting account and password expiry data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lab, you'll create a couple of new user accounts, set expiration data,
    and view the results. You can do this lab on either the CentOS or the Ubuntu virtual
    machine. (The only difference will be with the `useradd` commands.)
  prefs: []
  type: TYPE_NORMAL
- en: Create a user account for Samson with the expiration date of June 30, 2023,
    and view the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `usermod` to change Samson''s account expiration date to July 31, 2023:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign a password to Samson''s account, then force him to change his password
    on his first login. Log in as Samson, change his password, then log back out to
    your own account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `chage` to set a 5 day waiting period for changing passwords, a password
    expiration period of 90 days, an inactivity period of 2 days, and a warning period
    of 5 days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Keep this account because you'll be using it for the lab in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preventing brute-force password attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazingly enough, this is another topic that engenders a bit of controversy.
    I mean, nobody denies the wisdom of automatically locking out user accounts that
    are under attack. The controversial part concerns the number of failed login attempts
    that we should allow before locking the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the stone age of computing, so long ago that I still had a full head
    of hair, the early Unix operating systems only allowed users to create a password
    with a maximum of eight lowercase letters. So in those days, it was possible for
    early man to brute-force someone else''s password just by sitting down at the
    keyboard and typing in random passwords. That''s when the philosophy started of
    having user accounts get locked out after only three failed login attempts. Nowadays,
    with strong passwords, or better yet, a strong passphrase, setting a lockout value
    of three failed login attempts will do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: It will unnecessarily frustrate users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will cause extra work for help desk personnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an account really is under attack, it will lock the account before you've
    had a chance to gather information about the attacker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the lockout value to something more realistic, like 100 failed login
    attempts, will still provide good security, while still giving you enough time
    to gather information about the attackers. Just as importantly, you won't cause
    undue frustration to users and help desk personnel.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, regardless of how many failed login attempts your employer allows you
    to allow, you'll still need to know how to set it all up. So, let's dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the pam_tally2 PAM module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make this magic work, we''ll rely on our good friend, the PAM module. The
    `pam_tally2` module comes already installed on both CentOS and Ubuntu, but it
    isn''t configured. For both of our virtual machines, we''ll be editing the `/etc/pam.d/login`
    file. Figuring out how to configure it is easy because there''s an example at
    the bottom of the `pam_tally2` man page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second line of the example, we see that `pam_tally2` is set with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deny=4`: This means that the user account under attack will get locked out
    after only four failed login attempts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`even_deny_root`: This means that even the root user account will get locked
    if it''s under attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock_time=1200`: The account will get automatically unlocked after 1200
    seconds or 20 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, if you look at the actual `login` file on either of your virtual machines,
    you'll see that they don't look exactly like this example login file that's in
    both of their man pages. That's okay, we'll still make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve configured the `login` file and have had a failed login, you''ll
    see a new file created in the `/var/log` directory. You''ll view information from
    that file with the `pam_tally2` utility. You can also use `pam_tally2` to manually
    unlock a locked account if you don''t want to wait for the timeout period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note how after I did the reset on Charlie's account, I received no output from
    doing another query.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for configuring pam_tally2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring `pam_tally2` is super easy because it only requires adding one line
    to the `/etc/pam.d/login` file. To make things even easier, you can just copy
    and paste that line from the example in the `pam_tally2` man page. In spite of
    what I said earlier about bumping the number of failed logins up to 100, we'll
    keep that number at `4` for now. (I know that you don't want to have to do 100
    failed logins in order to demo this.)
  prefs: []
  type: TYPE_NORMAL
- en: On either the CentOS or the Ubuntu virtual machine, open the `/etc/pam.d/login` file
    for editing. Look for the line that invokes the `pam_securetty` module. (That
    should be around line 32 on Ubuntu and around line 2 on CentOS.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Beneath that line, insert the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit the editor.
  prefs: []
  type: TYPE_NORMAL
- en: For this step, you'll need to log out of your own account because `pam_tally2`
    doesn't work with `su`. So, log out, and while purposely using the wrong password,
    attempt to log in to the `samson` account that you created in the previous lab.
    Keep doing that until you see the message that the account is locked. Note that
    when the `deny` value is set to `4`, it will actually take five failed login attempts
    to lock Samson out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log back in to your own user account. Run this command and note the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'For this step, you''ll simulate that you''re a help desk worker, and Samson
    has just called to request that you unlock his account. After verifying that you
    really are talking to the real Samson, enter the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now that you've seen how this works, open the `/etc/pam.d/login` file for editing,
    and change the `deny=` parameter from `4` to `100` and save the file.  (This will
    make your configuration a bit more realistic in terms of modern security philosophy.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locking user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, you''ve just seen how to have Linux automatically lock user accounts
    that are under attack. There will also be times when you''ll want to be able to
    manually lock out user accounts. Let us look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user goes on vacation and you want to ensure that nobody monkeys around
    with that user's account while he or she is gone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user is under investigation for questionable activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user leaves the company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In regard to the last point, you may be asking yourself, "*Why can't we just
    delete the accounts of people who are no working here?*" And, you certainly can,
    easily enough. However, before you do so, you'll need to check with your local
    laws to make sure that you don't get yourself into deep trouble. Here in the United
    States, for example, we have the Sarbanes-Oxley law, which restricts what files
    that publicly traded companies can delete from their computers. If you were to
    delete a user account, along with that user's home directory and mail spool, you
    just might be running afoul of Sarbanes-Oxley or whatever you may have as the
    equivalent law in your own home country.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, there are two utilities that you can use to temporarily lock a user
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `usermod` to lock a user account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `passwd` to lock user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using usermod to lock a user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that Katelyn has gone on maternity leave and will be gone for at
    least several weeks. We can lock her account with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'When you look at Katelyn''s entry in the `/etc/shadow` file, you''ll now see
    an exclamation point in front of her password hash, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This exclamation point prevents the system from being able to read her password,
    which effectively locks her out of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unlock her account, just follow this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: You'll see that the exclamation point has been removed so that she can now log
    in to her account.
  prefs: []
  type: TYPE_NORMAL
- en: Using passwd to lock user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You could also lock Katelyn''s account with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This does the same job as `usermod -L`, but in a slightly different manner.
    For one thing, `passwd -l` will give you some feedback about what''s going on,
    where `usermod -L` gives you no feedback at all. On Ubuntu, the feedback looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS, the feedback looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Also, on the CentOS machine, you'll see that `passwd -l` places two exclamation
    points in front of the password hash, instead of just one. Either way, the effect
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unlock Katelyn''s account, just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In versions of Red Hat or CentOS prior to version 7, `usermod -U` would remove
    only one of the exclamation points that `passwd -l` places in front of the shadow
    file password hash, thus leaving the account still locked. No big deal, though,
    because running `usermod -U` again would remove the second exclamation point.
  prefs: []
  type: TYPE_NORMAL
- en: In Red Hat or CentOS 7, it has been fixed. The `passwd -l` command still places
    two exclamation points in the shadow file, but `usermod -U` now removes both of
    them. (That's a shame, really, because it ruined a perfectly good demo that I
    like to do for my students.)
  prefs: []
  type: TYPE_NORMAL
- en: Locking the root user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cloud is big business nowadays, and it''s now quite common to rent a virtual
    private server from companies such as Rackspace, DigitalOcean, or Microsoft Azure.
    These can serve a variety of purposes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can run your own website, where you install your own server software instead
    of letting a hosting service do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set up a web-based app for other people to access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently, I saw a YouTube demo on a crypto-mining channel that showed how to
    set up a Proof of Stake master node on a rented virtual private server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing that these cloud services have in common is that when you first set
    up your account and the provider sets up a virtual machine for you, they'll have
    you log in to the root user account. (It even happens with Ubuntu, even though
    the root account is disabled on a local installation of Ubuntu.)
  prefs: []
  type: TYPE_NORMAL
- en: I know that there are some folk who just keep logging in to the root account
    of these cloud-based servers and think nothing of it, but that's really a horrible
    idea. There are botnets, such as the Hail Mary botnet, that continuously scan
    the internet for servers that have their Secure Shell port exposed to the internet.
    When the botnets find one, they'll do a brute-force password attack against the
    root user account of that server. And yes, the botnets sometimes are successful
    in breaking in, especially if the root account is set with a weak password.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing that you want to do when you set up a cloud-based server
    is to create a normal user account for yourself and set it up with full sudo privileges.
    Then, log out of the root user account, log into your new account, and do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: I mean, really, why take the chance of getting your root account compromised?
  prefs: []
  type: TYPE_NORMAL
- en: Setting up security banners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that you really, really don't want is to have a login banner that
    says something to the effect, "*Welcome to our network*". I say that because quite
    a few years ago, I attended a mentored SANS course on incident handling. Our instructor
    told us the story about how a company took a suspected network intruder to court,
    only to get the case thrown out. The reason? The alleged intruder said, "*Well,
    I saw the message that said 'Welcome to the network', so I thought that I really
    was welcome there.*" Yeah, supposedly, that was enough to get the case thrown
    out.
  prefs: []
  type: TYPE_NORMAL
- en: A few years later, I related that story to the students in one of my Linux admin
    classes. One student said, "*That makes no sense. We all have welcome mats at
    our front doors, but that doesn't mean that burglars are welcome to come in.*"
    I have to confess that he had a good point, and I now have to wonder about the
    veracity of the story.
  prefs: []
  type: TYPE_NORMAL
- en: At any rate, just to be on the safe side, you do want to set up login messages
    that make clear that only authorized users are allowed to access the system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the motd file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/etc/motd` file will present a message banner to anyone who logs in to
    a system through Secure Shell. On your CentOS machine, an empty `motd` file is
    already there. On your Ubuntu machine, the `motd` file isn''t there, but it''s
    a simple matter to create one. Either way, open the file in your text editor and
    create your message. Save the file and test it by remotely logging in through
    Secure Shell. You should see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`motd` stands for Message of the Day.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the issue file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The issue file, also found in the `/etc` directory, shows a message on the
    local terminal, just above the login prompt. A default issue file would just contain
    macro code that would show information about the machine. Look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, on a CentOS machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'On an Ubuntu machine, the banner would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17b9b93c-b66b-41ee-92ab-b5c7b8d075f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On a CentOS machine, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98ec685f-3936-4ff7-874f-d1a0f255274b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You could put a security message in the issue file, and it would show up after
    a reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f5d8a0a-0649-4a5a-81ff-edf844876f80.png)'
  prefs: []
  type: TYPE_IMG
- en: In reality, is there really any point in placing a security message in the issue
    file? If your servers are properly locked away in a server room with controlled
    access, then probably not.
  prefs: []
  type: TYPE_NORMAL
- en: Using the issue.net file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just don't. It's for telnet logins, and anyone who has telnet enabled on their
    servers is seriously screwing up. However, for some strange reason, the `issue.net`
    file still hangs around in the `/etc` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter, and hopefully you found some suggestions
    that you can actually use. We started out with showing you the dangers of always
    logging in as the root user and how you should use sudo, instead. In addition
    to showing you the basics of sudo usage, we also looked at some good sudo tips
    and tricks. We moved on to user management, by looking at how to lock down users'
    home directories, how to enforce strong password policies, and how to enforce
    account and password expiration policies. Then, we talked about a way to prevent
    brute-force password attacks, how to manually lockout user accounts, and set up
    security banners.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to work with various firewall utilities.
    I'll see you there.
  prefs: []
  type: TYPE_NORMAL
