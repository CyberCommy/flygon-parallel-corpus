- en: Testing, Debugging, and Documenting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've written some microservice implementations ([Chapter 4](2dd92134-2db3-4427-8565-1be5bb13be1f.xhtml), *Beginning
    Your Microservice Journey*); set up a single point of contact, API Gateway ([Chapter
    5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding API Gateway*);
    added a registry where each service can log their status ([Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml), *Service
    Registry and Discovery*); set up collaboration between microservices ([Chapter
    7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service State and Interservice
    Communication*); and written some implementations of them. The implementations
    seem fine from a developer's point of view, but these days nothing is accepted
    without testing. This is the age of behavior-driven development and test-driven
    development. As we write more and more microservices, developing systems without
    automated test cases and documentation becomes unmanageable and painful.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start with understanding the testing pyramid, with an in-depth
    description of all the different kinds of tests involved in microservices. We
    will understand the testing frameworks and understand basic unit testing terminology.
    We will then learn the art of debugging microservices and then, finally, learn
    how to document our microservices using Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing good automated test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the testing pyramid and applying it to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing microservices from the outside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The art of debugging microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting microservices using tools such as Swagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a fundamental aspect of any software development. No matter how good
    the development team is, there is always scope for improvement or something has
    been left out of their training. Testing is usually a time-consuming activity
    that does not get the required attention at all. This has led to the prevalence
    of behavior-driven development, where developers write unit test cases, then write
    code, and then run a coverage report to know the status of the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: What and how to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As microservices are totally distributed, the main question that comes to mind
    is what to test and how to test. First, let''s have a quick look at the major
    characteristics that define microservices and need to be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent deployment**: Whenever any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: small or a safe change has been deployed to a microservice, the microservice
    is ready to be deployed to production. But how do we know whether the change is
    safe or not? This is where automation test cases and code coverage come into the
    picture. There are several activities, such as code reviews, code analysis, and
    backward compatibility design, that can come into play, but testing is the activity
    that gives full confidence in adapting to change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replaceable at will**: A good set of tests always helps to understand whether
    the new implementation is equivalent to the old implementation or not. Any new
    implementation should be tested against an equivalent implementation with a normal
    workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ownership by a small team**: Microservices are small and focused on an individual
    team to meet a single business requirement. We can write tests that cover all
    aspects of microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process of testing has to be fast and repeatable, and should be automated.
    The next questions are how to test and what to focus on when testing. Typically,
    all tests are divided into the following four segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding users**: The primary mode of testing is where the goal is to
    discover what users need and what problems they are having.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functionality check**: The goal of this mode of testing is to ensure that
    the functionality is correct and matches the specifications. It involves activities
    such as user testing, automated tests, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventing undesired changes**: The goal of this test is to prevent undesired
    changes in the system. Whenever a new change is deployed, several automated tests
    are run, a code coverage report is generated, and a code coverage level can be
    decided on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection against runtime behavior**: The goal of this test is to check
    what operational problems the system has. Here, we protect the system by doing
    stress testing, load testing, and monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will talk about the testing pyramid in microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid – what to test?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The testing pyramid is a tool to guide us through what kinds of tests can be
    written and at what levels. Tests at the top of the pyramid indicate fewer tests
    are needed, whereas more testing is required at the bottom of the pyramid. It
    illustrates what we should aim for and is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7763e9e7-69e4-4955-8c0b-8b30f1384c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing pyramid consists of four levels, as explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System tests (top level)**: These tests span across the complete distributed
    microservice system and are usually implemented through the GUI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service tests (middle level)**: These tests checks the complete execution
    of the business capability of the system. They check whether a particular business
    requirement has been fulfilled or not. They are not concerned with how many services
    behind the scenes are needed to fulfill the requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract tests (lower level)**: These tests are carried out on the boundary
    of an external service to verify if meets the contract that is expected by a consuming
    service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests (bottom level)**: These are tests that carry out a very small
    piece of functionality in a microservice. Several lower-level unit tests combine
    to form a microservice. Unit tests involve only a small aspect inside the microservice,
    or we can say that they operate at the macroscopic level. For example, our product
    catalog service has many services. Writing a unit test for it would involve passing
    a product ID and ensuring that I get the right product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at all these levels in greater detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: System tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sitting at the top of the pyramid are the system tests or E2E tests. They have
    a very broad scope, or we can say they have a 50,000-foot scope, and they try
    to cover a lot of things in very few tests. They don't go down the macroscopic
    level. Whenever a system test fails, it is difficult to identify where the problem
    is because of its large scope. The test covers the entire distributed system,
    so the problem can be anywhere, in any component.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a system test in our shopping cart microservices would be the
    complete checkout process. It uses the web UI of the add to cart system, where
    we add a number of items, generate an invoice, apply a discount code, and pay
    using a test credit card. If the test passes, we can assert that the discount
    code can be applied and payments can be received. If the assertion fails, anything
    could have caused the failure, such as a wrong price for an item, maybe an extra
    charge was added, or maybe a payment service failed. To resolve this issue, we
    need to test all microservices to find the exact culprit.
  prefs: []
  type: TYPE_NORMAL
- en: Covering a huge number of services and a broader area, system tests usually
    tend to be slow and imprecise (as we can't determine the exact service that is
    failing). Real service requests are made rather than a mocking system, things
    are written to real data stores, and even real event feeds are polled to monitor
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important question that comes to mind is regarding the number of system
    tests that need to be run. System tests, when successful, give a great deal of
    confidence, but they are also slow and imprecise; we can write system-level tests
    for only the most important use cases. This can give us coverage of the success
    paths of all important business capabilities in the system. For complete E2E tests,
    we can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Test our API using JSON requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the UI using Selenium, which emulates clicks on the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use behavior-driven development, where use cases are mapped into actions in
    our application and are later executed on the application that we have built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My recommendation is writing only business facing an important business capabilities
    system testing, as this exercises much of the fully deployed system and involves
    utilizing all the components in the ecosystem, such as the load balancer, API
    Gateway, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Service tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These tests are in the middle level of the test pyramid and they focus on interacting
    with one microservice in its entirety, and in isolation. The collaboration of
    this microservice with the outside world is replaced by mock JSON. Service-level
    tests test scenarios, rather than making a single request. They make a sequence
    of requests that together form a complete picture. These are real HTTP requests
    and responses, rather than mocked responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a service-level test for a credits program can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Send a command to trigger a user in the credits category (the command here follows
    the CQRS pattern seen in [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking
    Microservices*. CQRS follows a synchronous pattern of communication, so, its testing
    code would be the same). We send a command to trigger the other service to fulfill
    our service test criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide the best loyalty offer based on the user's monthly spending. This can
    be hardcoded, as it is a different microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record the offer sent to the user, and send back a response to check the functionality
    of the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all these aspects pass, we can assert that the credits program microservice
    works successfully and if any one of the functionalities fails, we know for sure
    that the issue is in the credits program microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Service-level tests are much more precise than system-level tests as they cover
    only a single microservice. If such a test fails, we can with certainty assert
    that the problem lies within the microservice, assuming that the API Gateway is
    not buggy and it delivers the exact same response as written in the mocks. On
    the other hand, service-level tests are still slow, as they need to interact with
    the microservice being tested over HTTP and with a real database.
  prefs: []
  type: TYPE_NORMAL
- en: My recommendation is that these tests should be written for the most important
    viable failure scenarios, keeping in mind that writing service-level tests is
    expensive as they use all the endpoints in the microservice and involve an event-based
    subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Contract tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a lot of collaboration going on between microservices in a distributed
    system. Collaborations need to be implemented as requests from one microservice
    to another. Any change in an endpoint can break all the microservices calling
    that particular endpoint. This is where contract tests come into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'When any microservices communicate, the one that makes a request to another
    has some expectations about how the other microservice will act. This is how the
    collaboration would work out: the calling microservice expects the called microservice
    to implement a certain fixed contract. A contract test is a test for the purpose
    of checking whether the called microservice implements the contract as per the
    calling microservice''s expectation.'
  prefs: []
  type: TYPE_NORMAL
- en: Although contract tests are part of the code base of the caller microservice,
    they also test things in other microservices. As they run against the complete
    system, it is beneficial to run them against a QA or staging environment and to
    configure to run contract tests automatically on each deployment. When a contract
    fails, it implies that we need to update our test doubles or change our code to
    take in the new changes the contract has made. These tests should be run based
    on the number of changes in external service. Any failure in a contract test won't
    break the build in the same way a normal test failure would do if it failed. It's
    an indicator that the consumer needs to keep up with changes. We need to update
    the tests and code to bring everything into sync. It will trigger a conversation
    will the producer service about how that change is affecting others.
  prefs: []
  type: TYPE_NORMAL
- en: My conclusion is that contract tests are very similar to service tests, but
    the difference is contract tests focus on fulfilling the prerequisites for communicating
    with a service. Contract tests do not set up mock collaborators and actually make
    real HTTP requests to the microservice being tested. Therefore, they should be
    written against each microservice if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the tests at the bottom of the test pyramid. These tests also deal
    with a single microservice, but unlike service tests, they don''t focus on the
    entire microservice, nor do they work over HTTP. Unit tests interact with the
    parts/units of the microservice being tested directly or through in-memory calls.
    Testing in unit testing looks exactly like you are making real HTTP requests,
    except that you are dealing with mocks and playing with assertions. There are
    usually two kinds of unit testing involved: one that involves making database
    calls and another that involves playing directly with in-memory calls. A test
    can be termed a unit test if its scope is a very small piece of functionality,
    and if the test code and the production code in the microservice run in the same
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests have a very narrow scope, making them very precise when identifying
    the problem. This helps in handling failures and errors effectively. Sometimes,
    you can have an even narrower scope of microservices by directly instantiating
    objects and then testing them.
  prefs: []
  type: TYPE_NORMAL
- en: For our credit program, we need several unit tests to test the endpoints and
    business capabilities. We need to test the user setup with both valid and invalid
    data. We need tests to read both existing and non-existing users to check our
    loyalty and monthly benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'My recommendation is that we should decide how narrow the narrowest unit test
    can be. Start with what the test should cover and then gradually add finer details.
    In general, there are two styles of unit testing that we can use: classic (state-based
    behavior testing) or mocking (interaction testing supported by mocking actual
    behavior).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see all the kinds of test applied to a microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ac4fe7b-1a39-4f63-b333-7a7c0364be9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Types of testing
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about all the kinds of tests needed at the microservice level,
    it is time to look at our microservice testing frameworks. In the next section,
    we will look at hands-on implementations of different kinds of testing and carry
    out the code coverage level of a microservice. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to get our hands dirty with microservice testing frameworks.
    In this section, we will look at testing basics and then carry on to write some
    unit tests, contract tests, and service-level tests. Writing tests has great advantages.
    We are forced to think through breaking the code into sub-functions and writing
    code based on the principle of single responsibility. Comprehensive test coverage
    with good tests makes us understand how the application works. In this section,
    we will be using some famous toolsets: Mocha, Chai, Sinon, and Ava. Ava will be
    our test runner, Chai will be our assertion library, and Sinon will be our mocking
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: Our libraries and test tool types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test tools can be divided into various functionalities. In order to get the
    best out of them, we always use a combination of them. Let''s look at the best
    tools available based on their functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide a testing base: Mocha, Jasmine, Jest, Cucumber'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Give assertion functions: Chai, Jasmine, Jest, Unexpected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate, display and observe test results: Mocha, Jasmine, Jest, Karma'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate and compare snapshots of component and data structures: Jest, Ava'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide mocks, spies, and stubs: Sinon, Jasmine, Enzyme, Jest, test double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate code coverage reports: Istanbul, Jest, Blanket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E2E tests: Casper, Nightwatch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will quickly go through Ava, Chai, Mocha, and Sinon, and
    get to know what they have to offer to us.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Mocha is a standard library, I have selected Ava because it is very
    fast compared to Mocha and it runs each test as a separate Node.js process, thereby
    saving CPU usage and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a fundamental assertion library following TDD/BDD that can be used in
    conjunction with any other libraries in order to have superior-quality tests.
    An assertion i
  prefs: []
  type: TYPE_NORMAL
- en: s any statement that has to be fulfilled, or else an error should be thrown
    and the test should be stopped. This is a very powerful tool to write easy-to-understand
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides the following three interfaces to make test cases more readable
    and powerful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`should`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with these three interfaces, we can use various natural language words.
    The full list can be found at [http://www.chaijs.com/api/bdd/](http://www.chaijs.com/api/bdd/).
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering what the difference is between `should` and `expect`.
    Well, it is a natural question. Although `should` and `expect` do the same thing,
    the fundamental difference is that the `assert` and `expect` interfaces do not
    modify `Object.prototype`, while `should` does.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most famous and widely used libraries, Mocha follows behavior-driven
    development testing. Here, the test describes the use case of any service, and
    it uses assertions from another library to verify the outcome of the executed
    code. Mocha is a test runner. It is used t
  prefs: []
  type: TYPE_NORMAL
- en: 'o organize and run tests through `describe` and its operators. Mocha provides
    various features, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeEach()`: It is called once before each spec in describe in the test
    file from which the test runs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach()`: It is called once after each spec in describe in the test file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before ()`: This runs code prior to any tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after()`: This runs code after all tests have run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ava, like Mocha, is a test runner. Ava takes advantage of the parallel and asynchronous
    nature of Node.js and runs test files in parallel processing through a separate
    process. As per the stats, switching from Mocha to Ava in `pageres` (a plugin
    that captures screenshots), brought test time down from 31 seconds to 11 seconds
    ([https://github.com/avajs/ava/blob/master/readme.md](https://github.com/avajs/ava/blob/master/readme.md)).
    It has various options, such as fail fast, live watch (tests are rerun in watch
    mode when files are changed), storing snapshots, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ava is designed for the future and is completely written in ES6\. Test run
    concurrently here with option of going synchronous or asynchronous with the tests.
    Tests are considered synchronous by default unless they return a promise or an
    observable. They heavily use async function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It has a wide range of options such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Reports (beautiful reports showing test coverage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing fast (stops after the first failed test case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futuristic tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, microservices need to call other microservices, but we don't want
    to call the actual microservice; we just want to focus on whether the method was
    called
  prefs: []
  type: TYPE_NORMAL
- en: 'or not. For this, we have Sinon, a framework that gives us the options of mocks
    and spies, which fulfill our purpose by providing mock responses or creating a
    spy service. It provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stub**: A stub is a dummy object with a prerecorded and specific response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spy**: A spy is a kind of hybrid between the real object and the mock. Some
    methods are shadowed by the spy object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mock**: A mock is a dummy object replacing the actual object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Istanbul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a code coverage tool that covers tracking statements, branches, and
    functional coverage. The module loader hooks to instrument code on the fly without
    the need for configuration. It offers multiple report formats, such as HTML, LCOV,
    and so on. It can also be used on command lines. It can be used as a server-side
    code coverage tool for Node.js by embedding it as custom middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Contract tests using Pact.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each microservice has its own independent implementation; let's say our categories
    service(product-catalog service). It has an endpoint for fetching a list of categories,
    getting the list of products associated with those categories, adding any new
    categories, and so on. Now our shopping cart microservices (consumer) utilizes
    this service, but at any point in time, the categories microservice (provider)
    may change.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: The provider might change the endpoint `/categories/list` to `/categories`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider might change several things in the payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider might add new mandatory parameters or may introduce a new authentication
    mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider might remove endpoints that are needed by the consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any of these conditions may lead to a potential catastrophe! These kinds of
    test would not be handled by unit tests and the traditional approach is to use
    integration tests. But, however, we can see potential drawbacks of integration
    tests, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are slow. They require setting up integration environments
    where dependencies for both providers and consumers are fulfilled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are brittle and can fail due to other reasons, such as infrastructure.
    A failed integration test doesn't necessarily mean a problem with the code. Due
    to the high scope of integration tests, it becomes very painful to find out the
    actual problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, we need to go for contract tests.
  prefs: []
  type: TYPE_NORMAL
- en: What is consumer-driven contract testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contract testing means that we check our API against a set of expectations (what
    we define as contracts) which are meant to be fulfilled. This means that we want
    to check whether, upon receiving any API request call, our API server will return
    the data we specified in the documentation or not. We often miss out precise information
    regarding the needs of our API customers. To overcome this problem, consumers
    can define their set of expectations as mocks, which they use in unit tests, thus
    creating contracts that they expect us to fulfill. We collect these mocks and
    check that our provider returns the same or any similar data or not when they
    get called the same way as mocks are set up, thereby testing the service boundary.
    This complete approach is called consumer-driven contract testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of consumer-driven contracts is just to formalize any or all of the
    interactions between a consumer and a provider. The consumer creates a contract,
    which is just an agreement between the consumer and provider on the amount of
    interaction that will take place between them or simply stating what the consumer
    expects from the provider. Once the provider has agreed to the contract, both
    the consumer and provider can take a copy of the contract and use tests to verify
    that contract violation doesn''t occur on any end of the system. The major advantage
    of these kinds of tests is they can be run independently and locally and they
    are super fast and can be run without any hassle. Similarly, if a provider has
    several consumers, we will need to verify several contracts: one for each consumer.
    This will help us to ensure that changes to the provider do not break any consumer
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: Pact is one of the famous open source frameworks that enable consumer-driven
    contract testing. There are various implementations for Pact for various platforms,
    such as Ruby, JVM, and NET. We will be using the JavaScript version Pact JS. So
    Let's get started. Let's start our journey with Pact.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pact.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be utilizing the `pact` module ([https://www.npmjs.com/package/pact](https://www.npmjs.com/package/pact))
    available in NPM. The overall process would be as follows, where we would n
  prefs: []
  type: TYPE_NORMAL
- en: need to do operations at both the consumer and the provider levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be dividing our implementation into two parts. We will set up a provider
    as well as a client to test whether the services are communicating with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On the consumer side**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a mock web server that will act as a service provider rather
    than making an actual call. Pact.js provides this functionality out of the box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For any request that we want to check, we will define the expected response
    that the mock service needs to return to check whether there are any sudden changes.
    In Pact language, we call these interactions; that is, for a given request what
    does the consumer want the provider to return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We next create unit tests where we will run our service client against the mock
    provider to check whether the client returns these expected values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will create a `pact` file containing the consumer expectations as
    a contract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**On the provider side**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider side gets the pact file from the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs to verify that it doesn't violate the expected interactions of the
    consumer. `Pact.js` will read the `pact` file, execute the request for each interaction,
    and confirm whether the service returns the payload expected by the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By checking that the provider does not violate any of its consumer's contracts,
    we can be sure that the latest changes to the provider's code don't break any
    consumer code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, we can avoid integration testing and still be confident of our system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After understanding the process, let''s now implement it. We will follow the
    preceding steps regarding the consumer and provider, one at a time. The complete
    example can be found in `chapter-8/pact-typescript`. Our example project is the
    categories microservice and we will be playing around with it. So, let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a provider. We will create a service that returns some animals
    and a specific animal service that gives me an animal on passing an ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the code from the provider by adding `provider.ts`, `providerService.ts`, `repository.ts` from `packt-typescript/src/provider` and `data.json` from `pact-typescript/data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create a consumer. The consumer consumes files from providers.
    We will create a Pact server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We define our expectations next, where we will say:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write our usual tests, but before adding the tests, we add these interactions
    in Pact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, w write the usual tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the mock server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are done on the provider side, we need to verify our provider.
    Start the `provider` service and in its test file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Bonus (containerizing pact broker)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In dynamic environments, we need to share Pacts across applications rather
    than working in a single application. To do so, we will leverage the functionality
    of the Pact broker. You can simply download it from [https://hub.docker.com/r/dius/pact-broker/](https://hub.docker.com/r/dius/pact-broker/).
    You can download it through Docker using `docker pull dius/pact-broker`. Once
    started, you can access the broker with `curl -v http://localhost/9292 #`, which
    you can visit in your browser too! You can configure it with a database and run
    a combined `docker-compose.yml` file too. A demo configuration for pact-broker
    configured with Postgres can be found at [https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml](https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml).
    Once configured by executing the `docker-compose up` command, the `pact` broker
    can be accessed on port 80 or port 443 depending on whether SSL is enabled or
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting testing key points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recall our key points on testing before moving on to the next section
    in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid indicates the number of tests required for each kind of
    test. Tests at the top of the pyramid should be fewer in number than the level
    below them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to their broader scope, system-level tests are meant to be slow and imprecise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System-level tests should only be used to provide some test coverage for important
    business capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service-level tests are faster and more precise then system-level tests, as
    they have to deal with a reduced scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practice should be followed to write service-level tests for success and important
    failure scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract tests are important, as they verify the assumption one microservice
    makes about the API and behavior of another microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are meant to be fast and should be kept fast by only including a
    single unit or using the principle of single responsibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have wider test coverage, always write service tests first and write unit
    tests later when it becomes unmanageable to write service tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use Sinon, Ava, Chai, and Istanbul for testing our microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To write service level tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write mocked endpoints of the microservice under test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write scenarios that interact with the microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make assertions both on a response from the microservice and the requests it
    makes to collaborators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Pact, you can write contract-level tests, thus avoiding integration
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract tests are very helpful as they make sure that a microservice adheres
    to its prefixed contracts and any sudden change in a service does not break any
    business capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced:** Sometimes you may need to try out snippets of code in a real-time
    environment, either to reproduce a problem or to try the code in a realistic environment.
    Telepresence ([http://telepresence.io/](http://telepresence.io/)) is a tool that
    allows you to swap out running code in Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced:** Ambassador ([https://www.getambassador.io/](https://www.getambassador.io/))
    is an API Gateway allowing microservices to easily register their public endpoints.
    It has a variety of options, such as statistics about traffic, monitoring, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced:** Hoverfly ([https://hoverfly.io/](https://hoverfly.io/)) is a
    way to achieve microservices virtualization. We can simulate latency and failures
    in APIs through it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After going through the testing process, it is now time to solve problems on
    the fly with debugging. We will learn about debugging and profiling microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging is one of the most important aspects in the development of any system.
    Debugging, or the art of solving problems, is crucial in software development
    as it helps us to identify issues, profile the system, and identify the culprits
    responsible for taking down the system. There are some classic definitions of
    debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Debugging is like solving a murder mystery in which you are the murderer.
    If debugging is the process of removing bugs, then software development is the
    process of putting these bugs in it"'
  prefs: []
  type: TYPE_NORMAL
- en: – Edsgar Dijkstra.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a TypeScript microservice is very similar to debugging any web application.
    Going for open source free alternatives, we will go for node-inspector, as it
    also provides very useful profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw debugging through VS Code in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to profile and debug our application
    using node-inspector. We will look at various aspects of remote debugging and
    how to build a proxy in between a service to debug our microservices. So, let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Building a proxy in between to debug our microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices are distributed based on business capabilities. From the end-user
    they may seem a single functionality say for instance: buying a product, but behind
    the scenes, there are many microservices involved, such as the payment service,
    add to cart service, shipping service, inventory service, and so on. Now, all
    of these services should not reside inside a single server. They are spread and
    distributed as per design and infrastructure. Scenarios occur where two servers
    collaborate with each other and bad behavior may occur at any level if these services
    are not monitored. It is a very common problem in microservices, which we are
    going to solve using `http-proxy` and tunneling. We are going to create a very
    simple example that will log the raw headers of any request. This information
    can give us valuable information about what is actually going on in the network.
    This concept is very similar to what we used in the API Gateway. Normally, the
    API Gateway is a proxy for all requests; it queries the service registry to dynamically
    fetch the location of a microservice. This proxy layer, our gateway, has various
    advantages, which we saw in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding
    API Gateway*. We will be using the node module `http-proxy` ([https://www.npmjs.com/package/http-proxy](https://www.npmjs.com/package/http-proxy))
    and log the request headers there. Initialize one Node.js project, add the `src`, `dist`,
    and `tsconfig.json` folders, and add the `http-proxy` module and its typings.
    Then, enter the following code in index.ts to create a proxy server. The full
    code can be found under the extracted source at `Chapter 8/ts-http-proxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, when you hit `localhost:4000`, it will print all the raw headers, which
    you can check in the source code and see the response of the service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will have a look at the Chrome debugging extension and
    profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling is a key process these days when it comes to analyzing a service for
    performance. There are native tools available for Node.js that can profile any
    running V8 process. These are just snapshots with effective summaries that include
    statistics on how V8 treats the process when compiling, and the actions and decisions
    it makes while optimizing the hot code it ran against the V8 engine.
  prefs: []
  type: TYPE_NORMAL
- en: We can have a v8 log generated in any process simply by passing the `--prof` flag. `prof` stands
    for a profile. An example is `node --prof index.js`. That won't be much of a readable
    format. To create a more readable format, run the `node --prof-process <v8.logfilename>.log
    >` command's profile.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at how to profile using profile logs, take heap
    snapshots, and utilize Chrome's CPU profiling for microservices. So, let's get
    started. You can process the logs of any file using `node --prof <file_name>.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A heap is a huge memory allocation. When we talk about our case, it is the
    memory allocated to the V8 process (time to recall how Node.js works—the Event
    Loop and the memory allocation).  By checking the memory usage, you can track
    down things such as memory leaks or just check which part of the service has the
    most consumption, based on which you can adjust the code accordingly. We have
    a very fine `npm` module ([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump)),
    which take a dump that can be used later for inspection. Let''s get familiar with
    reading the dump process and when to take a dump, though the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We install Heap Dump and create a dump ready to be used. Open up any project,
    and install the `heapdump` module with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the following lines of code in any process where you want to create
    the snapshot. I have kept them in `Application.ts` just as an example. You can
    follow the code in `chapter8/heapdump_demo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run the program, you can find the snapshot in the directory from
    which we ran the preceding lines of code. You will find output like dump written
    to `/home/parth/chapter 8/heapdump_demo/../<timestamp>.heapsnapshot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must have something like `<current_date_in_millis>.heapsnapshot`. It will
    be in a non-readable format, but that''s where we will be utilizing Chrome''s
    DevTools. Open Chrome DevTools and go to the Memory | Select profiling type | Load option.
    Open the snapshot file and you will be able to see the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac3665aa-d69e-495b-a3dc-822e9b8f0d74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Statistics and you will be able to see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dcca964f-77ed-4cb6-9560-a07abd7b8b84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can go through the following links to get in-depth knowledge about profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101](https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101)[h](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ttps://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can periodically take dumps or take dumps in the event of errors, which would
    be very helpful in order to find the issue in a microservice. Next, we will see
    how to do CPU profiling.
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chrome Developer Tools has some very nice options that are not just limited
    to debugging. We can also leverage memory allocation, CPU profiling, and so on.
    Let''s dig deep into CPU profiling. For the sake of understanding the tool, we
    will spin up a program that consumes heavy CPU usage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create any express app and create one random route, which basically iterates
    100 times and allocates a buffer 10⁸ in the memory. You can follow the code in `chapter
    8/cpu-profiling-demo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to run the Node.js process in Chrome DevTools. To do so, just
    add the `--inspect` flag in `node --inspect ./dist/bin/www.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Chrome debugging protocol is included in the Node.js core module and we
    do not need to include it in every project.
  prefs: []
  type: TYPE_NORMAL
- en: Open `chrome://inspect` and we will be able to see our process under it. Click
    on inspect and we are ready to debug the Node.js application just like a standard
    web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Profiler, which is where we will debug the CPU behavior. Click on Start,
    open any tab, and hit `localhost:3000/check-mem`. Come back to our tab. Click
    on Stop when you are able to see I am done. You should be able to see something
    like this like in the figure profiling and profiling detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/628ae1c9-2bd5-432a-aa8e-2bbcf22065b9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Profiling
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, hover over a single row and you will be able to see a detailed view like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/afa6e1d0-7a44-4b3b-a4fa-e3d20b84da25.png)'
  prefs: []
  type: TYPE_IMG
- en: Profiling detail
  prefs: []
  type: TYPE_NORMAL
- en: Live Debugging/Remote Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The penultimate and important feature is to debug a problem live. With the
    introduction of the inspector protocol inside Node.js, this becomes a piece of cake as
    all we have to do is create an `--inspect` version of running the process. This
    will print the URL of the process on which debug is open, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install the Chrome extension Node.js V8 --inspector Manager (NiM),
    from [https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj) for
    debugging remote applications or you can even spawn a process for debugging and
    specify a port with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can find other options here: [https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options](https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options).
    When any process is started with the `--inspect` switch, Node.js listens to it
    via sockets for diagnostics commands uniquely identified by the host and the port.
    Each process is assigned a unique UUID for tracking. Node-Inspector also provides
    an HTTP endpoint to serve metadata about debugger, including its WebSocket URL,
    UUID, and Chrome DevTools URL. We can get this information by hitting `<host:port>/json/list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging is great, but we should make sure that it does not come with a side
    effect. Debugging means opening up a port, which will have security implications.
    The following points should be taken care of with utmost precautions:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the debug port publicly is not safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local applications running inside have full access to the application inspector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same origin policy should be maintained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our debugging and profiling session. In the next section, we
    will revisit key points before moving on to documenting.
  prefs: []
  type: TYPE_NORMAL
- en: Key points for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we saw debugging and core aspects involved in profiling. We
    learned how to diagnose a leak or observe heap dump memory to analyze a service
    request. We saw how a proxy can often help, even if it increases a network hop:'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid overloading, we have a module providing as in, code `503` middleware.
    Refer to [https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection) for
    implementation details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome Inspector is a very useful tool for debugging Node.js microservices,
    as it not only provides a debugging interface, but also heap snapshots and CPU
    profiling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code is also a very user-friendly tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js embraced node-inspector and included it in the core module, thus making
    remote debugging very easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know the fundamental aspects of debugging, let''s move on to the
    final part of making a developer''s life easy. Yes, you guessed it correct: proper
    documentation, which always saves the day not just for the technical team but
    also non-technical persons.'
  prefs: []
  type: TYPE_NORMAL
- en: Documenting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Documenting** is a contract between the backend and the frontend that takes
    care of dependency management between the two sides. If the API changes, the document
    needs to adapt to it quickly. One of the easiest fails in development can be the
    lack of visibility or lack of awareness about other people''s work. Often, the
    traditional approach is to write service specification documents or use some static
    service registries that maintain different things. No matter how hard we try,
    documentation always goes out of date.'
  prefs: []
  type: TYPE_NORMAL
- en: Need of Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Documentation of development and organizational understanding of the system
    increases developers, skill and speed while dealing with two of the most common
    challenges that come with microservice adoption—technical and organizational change.
    The importance of thorough, updated documentation cannot be underestimated. Whenever
    we ask someone about problems they face while doing anything new, the answer is
    the same. We all face the same issue: we don''t know how this thing works, it''s
    a new black box and the documentation given is worthless.'
  prefs: []
  type: TYPE_NORMAL
- en: Poor documentation of dependencies or internal tools makes developer's lives
    a nightmare and slows down their ability and the production readiness of a service.
    It wastes countless hours because the only way that remains is re-engineering
    the system until we have the resolution. Edison did indeed say, *I have found
    2000 ways of how not to make the light bulb,* but I would like to spend my time
    rather on 2000 ways to get more out of me. Poor documentation of a service also
    hurts the productivity of the developers who are contributing to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of production-ready documentation is to make and organize a centralized
    repository of knowledge about the service. Sharing this piece of information has
    two aspects: the fundamental parts of the service and where the service contributes
    to achieving what piece of functionality.  Solving these two problems requires
    standardizing a documentation approach to sharing microservice understanding.
    We can summarize the following documentation points:'
  prefs: []
  type: TYPE_NORMAL
- en: Any service should have comprehensive and detailed documentation (should include
    what the service is and to what it is contributing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation should be updated regularly (all the new methods and maintained
    version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be understood by all and not just the technical team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its architecture is reviewed and audited every fixed interval of time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When approaching microservices, the pain increases exponentially as we divide
    each business capability into a different service. We need a more generic approach
    to documenting microservices. Swagger is currently the forerunner in documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swagger, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: No inconsistent API descriptions anymore. These will be updated with complete
    contract details and parameter information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You won't need to write any more documentation; it will be auto-generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, of course, there will be no more arguments regarding poor documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section will explore how to use Swagger, understand its core tools, its
    advantages, and working implementations. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger is a powerful representation of your microservices or, in fact, any
    RESTful API. Thousands of developers are supporting Swagger in almost every programming
    language and environment. With a Swagger-enabled environment, we get interactive
    documentation, client SDK generation, discoverability, and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swagger is a part of the Open API Initiative (a committee standardizing how
    REST APIs should be described). It provides a set of tools to describe and document
    a RESTful API.  Swagger, which began as an API documentation tool, can now also
    generate boilerplate code via **Swagger Codegen** ([https://github.com/wcandillon/swagger-js-codegen](https://github.com/wcandillon/swagger-js-codegen)).
    Swagger has a large ecosystem of tools, but primarily we will be using the following
    set of tools. We will understand how to integrate Swagger with an existing application
    or write an API specific to Swagger standards, through which our documentation
    will be auto-generated. The overall process involved can be understood from the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef59d39a-761c-4b99-90c2-6d431f32d76f.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger_workflow
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at the overall tools involved in the process to get a thorough
    understanding of all the aspects involved in it.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Editor and Descriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Descriptor takes a page from design-driven development. Here, we design
    our endpoints' behavior by describing them in a YML/YAML file or a JSON file.
    (Of course, as a developer I am too lazy to even write this file and I would prefer
    this to be autogenerated, which we will look at in a further section.) This is
    the most important section as it is the contextual information about the service.
  prefs: []
  type: TYPE_NORMAL
- en: Check out `Chapter 8/hello_world_swagger.yaml` to get an idea of the descriptor
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Key points for Swagger  and Descriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your URL route, parameter, and description is defined inside the `.yaml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a parameter is required or not, you can pass using the required true,
    which will validate that parameter while testing it out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also return response codes and their descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger reads this `.yaml` file to generate its Swagger UI and test services
    using the Swagger inspector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Editor is an online tool that helps y
  prefs: []
  type: TYPE_NORMAL
- en: ou to edit Swagger API specifications in your browser by previewing the documentation
    in real time as per Swagger API specifications. This way, we can see how the documentation
    will look after applying the most recent changes on the fly. The editor has a
    clean interface and is easy to use with lots of features to design and document
    various microservices. It is available online at [https://editor2.swagger.io/#!/](https://editor2.swagger.io/#!/).
    By just writing or importing a `swagger.yaml` file, we can view the Swagger UI
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get our hands dirty with Swagger Editor and Swagger Descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up [https://editor2.swagger.io](https://editor2.swagger.io) and enter our
    previous descriptor (`hello_world_swagger.yaml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be able to see live documentation on the right side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fcdb4dcf-b65d-45f6-bdd2-7d48398895c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger Editor
  prefs: []
  type: TYPE_NORMAL
- en: Try inserting more code in the descriptor file and check out the interactive
    documentation. Also, try running Try this operation. It will give a description
    of the HTTP request along with all the headers and responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swagger Codegen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Codegen is a scaffolding engine that gives us the option to generate
    interactive documentation, API clients, and server stubs from Swagger definitions.
    The previous options that we saw in Swagger Editor (generating a server and generating
    a client) resemble the implementation of Swagger Codegen. It has support for a
    lot of languages.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side scaffolding tool that includes support for languages such as TypeScript
    Angular, TypeScript Node, JavaScript, Python, HTML, Java, and C#. Server-side
    scaffolding tool supports languages such as Haskell, Node.js, Go language, and
    Spring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger CodeGen** ([https://swagger.io/swagger-codegen/](https://swagger.io/swagger-codegen/))
    helps us to build APIs quicker and improve the quality by adhering to OpenAPI-defined
    specifications. It generates server stubs and client SDKs so we can rather focus
    on API implementation and business logic rather than code creation and adopt standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of Swagger CodeGen**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It generates server code, client code, and documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for faster changes of API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code generated is open source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages of Swagger CodeGen**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an increase in project complexity by adding extra tools and libraries
    and the added complexity of managing those
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can generate a lot of code that the user might not be able to digest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check `Chapter 8/typescript-node-client/api.ts` to see the auto generated
    code based on our initial Swagger descriptor definition.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swagger UI allows us to visualize a RESTful API. Visualizations are automatically
    generated from Swagger specifications. The Swagger UI takes in a Swagger descriptor
    file and creates documentation with the Swagger inspector in the UI. The Swagger
    UI is what we saw in the preceding screenshot on the right-hand side. Furthermore,
    this can be given access based on privileges. The Swagger UI is a collection of
    HTML, JavaScript, andCSS assets that dynamically generate beautiful documentation
    from a Swagger-compliant API.  We will generate documentation for our product
    catalog microservice and use Swagger UI components in it.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a pain-free way to generate documentation based on the OpenAPI specification.
    Once you have checked SWAGGER inspector with its working, then you can create
    documentation and share it with the world. We can easily autogenerate documentation
    by selecting the previously tested endpoints from the history and then issuing
    the command for CREATE API DEFINITION. It is much like Postman on the web. You
    can download Swagger inspector as a Chrome extension. It has these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a7c8ecd-ebe5-47a5-a01b-327fe63702dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger inspector
  prefs: []
  type: TYPE_NORMAL
- en: Now that we got ourself acquainted with Swagger, let's look at how to use Swagger
    in our microservices to generate beautiful documentation for us. The next section
    talks about possible approaches in which we can integrate swagger.
  prefs: []
  type: TYPE_NORMAL
- en: Possible strategies to use Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swagger is mostly used for documenting services and testing services out. There
    are two fundamental approaches in implementing Swagger. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-down or design-first approach: **Here, Swagger Editor is used to create
    Swagger definitions and then Swagger Code-gen is used to generate code for the
    client as well as the server. Swagger will be used to design the API and source
    before any of the code has been written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottom-up approach: **Here, for any of the existing APIs, Swagger is used
    to generate documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at both of the approaches along with the best practices available
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Top-down or design-first Approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, generating a valid Swagger file and documentation via just adding a
    few lines of code seems like a good idea. We have written all the code and then we remember:
    *Oh my goodness, how will I explain this to others? Will I need to document each
    and every API?* On the fly generation of documentation at such time simply by
    adding an annotation seems to be a dream come true in such situations.   TSOA ([https://www.npmjs.com/package/tsoa](https://www.npmjs.com/package/tsoa))
    is designed on such a principle. Based on TSOA README file, it generates a valid
    Swagger spec from a written controller and models that include the following.
    This essentially is a bottom-up approach where we already have an existing REST
    API and we leverage Swagger to document the existing API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TSOA generates a valid Swagger `spec` file from controllers and models that
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Paths to various REST URLs (example: `Get users :- server_host/users/get_users`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definitions based on TypeScript interfaces (these are the model files or attribute
    descriptors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters types; that is, model properties are marked as required or optionally
    based on TypeScript syntax (for example, `productDescription?: string` is marked
    as optional in the Swagger specs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jsDoc support for object descriptions (most other metadata can be inferred from
    TypeScript types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like routing-controllers, routes are generated for any middleware of our choice.
    Options include Express, Hapi, and Koa. Similar to routing-controllers, TSOA has
    a class validator inbuilt. TSOA minimizes boilerplate code as much as possible
    and it has plenty of annotations available. You can check the documentation in
    `npm` for a detailed understanding of the various options available. We will be
    mainly concerned with the `@Route` annotation, which will generate the Swagger
    doc for us. In the example, we will use TSOA and generate the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Please see extracted source for top-down approach, the example is pretty straight
    forward strictly adhering to the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! After going through a top-down approach, it seems like the perfect plan.
    But what about when we have already developed the project and now we want to generate
    our documentation. We are left in a conundrum. What should we do? Luckily, we
    have just the solution. We will leverage `swagger-ui-express` ([https://www.npmjs.com/package/swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express))
    to generate the documentation. It has more than 45,000 downloads a week. It is
    a community-driven package that enables a middleware for your express application,
    which serves the Swagger UI based on the Swagger documentation file. We will need
    to add one route, which will host the Swagger UI. Documentation is good and everything
    is there—whatever we need. So, let's get started. You can follow along with the
    source code in the `Chapter 8/bottom-up-swagger` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the module from `npm` as a dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need to add a route, which will host the Swagger UI. We need to
    generate the Swagger definition and update it on each deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have two options to generate the Swagger documentation. Either we add comments
    in each of our route handlers or we use the Swagger inspector to test all the
    REST APIs, club those, and generate a definition file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whatever route we go for, our objective remains the same: to generate the `swagger.json`
    file. Going with the first approach, we will use `swagger-jsdoc` ([https://www.npmjs.com/package/swagger-jsdoc](https://www.npmjs.com/package/swagger-jsdoc)).
    Download the module as a dependency with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started with our configuration. First of all, we need to initialize
    Swagger JS Doc on Express startup. Create one class, `SwaggerSpec`, and inside
    it add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialized the JSDoc and stored the `swagger.json` inside variable
    private static `swaggerJSON:any` so it can be used when we want to serve the JSON.
    We kept the usual configurations inside the `JSDoc` object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, on express startup, we need to initialize the `setUpSwaggerJSDoc` method,
    so we can fill up the JSON at the start of the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Controller`, which gives us `swagger.json` as an HTTP endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Hit `http://localhost:8081/swagger/swagger.json` to see the initial Swagger
    JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to add JSDoc-style comments to each route to generate the Swagger
    spec and add comments in YAML to route handlers. Adding appropriate comments like
    this will populate our `swagger.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to generate the documentation using Swagger inspector. Now
    that we are done with Swagger generation, we need to generate the Swagger UI.
    Add these in `Express.ts` this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Swagger is a great documentation tool and fulfills all our purposes. Whether
    we use it from the start or after development, it is a good fit to fulfill our
    documentation needs. The `./api/v1` file will give you generated Swagger documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a project from a Swagger definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now we were generating swagger definition from our source code. The other
    way round also holds true. We can easily generate a project from a Swagger definition
    and type of language (we saw something similar in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml),
    *Service State and Interservice Communication*. Rings a bell? That is correct.
    rPC and code generation). Let''s download swagger-code-generate and create our
    project out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the updated `hello_world_swagger.yml` in the extracted src `chapter
    8/swagger-code-gen`. It has one more added route/endpoint of the API to update
    the product information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next step is to download swagger-code-gen from at [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen),
    so we can even configure it in automation or use it as required, rather than going
    to the online Swagger editor every time. You can also find swagger-code-gen in
    the extracted source of this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since its a project that runs on JVM, we build the project so we can run it.
    Hit the command `mvn package` to build the JAR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will generate the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can explore `typescript-nodejs` inside `chapter-8/swagger-code-gen` to understand
    the generated structure and play around with it. Similarly, you can go for any
    other language. Further documentation can be found here [https://github.com/swagger-api/swagger-codegen/blob/master/README.md](https://github.com/swagger-api/swagger-codegen/blob/master/README.md).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swagger is a wonderful utility to generate documentation on-demand. The documentation
    generated is comprehensible even for product managers or partners, human-readable,
    and easily adjustable. It makes our lives not only easy, but it makes the API
    more consumable and manageable, as it adheres to OpenAPI specs. Swagger is widely
    used by leading companies such as Netflix, Yelp, Twitter, and GitHub. In this
    section, we saw its varied uses along with its cycle and various approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at testing, debugging, and documenting. We looked
    at some fundamental aspects of testing. We looked at the testing pyramid and at
    how to do unit testing, integration testing, and E2E tests. We looked at contract
    testing using Pact. Then, we had a look at the debugging and profiling process,
    which is very helpful in solving critical issues. We saw how to perform debugging
    in the event of critical failures. Finally, we looked at the documention tool
    Swagger, which helps to keep central documentation, and we examined strategies
    to introduce Swagger our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at deployment. We will see how to deploy our
    microservices, get introduced to Docker, and learn about the fundamentals of Docker.
    We will then see some monitoring tools and logging options. We will integrate
    ELK stacks for logs.
  prefs: []
  type: TYPE_NORMAL
