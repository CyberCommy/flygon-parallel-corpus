- en: Testing, Debugging, and Documenting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've written some microservice implementations ([Chapter 4](2dd92134-2db3-4427-8565-1be5bb13be1f.xhtml), *Beginning
    Your Microservice Journey*); set up a single point of contact, API Gateway ([Chapter
    5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding API Gateway*);
    added a registry where each service can log their status ([Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml), *Service
    Registry and Discovery*); set up collaboration between microservices ([Chapter
    7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service State and Interservice
    Communication*); and written some implementations of them. The implementations
    seem fine from a developer's point of view, but these days nothing is accepted
    without testing. This is the age of behavior-driven development and test-driven
    development. As we write more and more microservices, developing systems without
    automated test cases and documentation becomes unmanageable and painful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start with understanding the testing pyramid, with an in-depth
    description of all the different kinds of tests involved in microservices. We
    will understand the testing frameworks and understand basic unit testing terminology.
    We will then learn the art of debugging microservices and then, finally, learn
    how to document our microservices using Swagger.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Writing good automated test cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the testing pyramid and applying it to microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing microservices from the outside
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The art of debugging microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting microservices using tools such as Swagger
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a fundamental aspect of any software development. No matter how good
    the development team is, there is always scope for improvement or something has
    been left out of their training. Testing is usually a time-consuming activity
    that does not get the required attention at all. This has led to the prevalence
    of behavior-driven development, where developers write unit test cases, then write
    code, and then run a coverage report to know the status of the test cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: What and how to test
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As microservices are totally distributed, the main question that comes to mind
    is what to test and how to test. First, let''s have a quick look at the major
    characteristics that define microservices and need to be tested:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent deployment**: Whenever any'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: small or a safe change has been deployed to a microservice, the microservice
    is ready to be deployed to production. But how do we know whether the change is
    safe or not? This is where automation test cases and code coverage come into the
    picture. There are several activities, such as code reviews, code analysis, and
    backward compatibility design, that can come into play, but testing is the activity
    that gives full confidence in adapting to change.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replaceable at will**: A good set of tests always helps to understand whether
    the new implementation is equivalent to the old implementation or not. Any new
    implementation should be tested against an equivalent implementation with a normal
    workflow.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ownership by a small team**: Microservices are small and focused on an individual
    team to meet a single business requirement. We can write tests that cover all
    aspects of microservices.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process of testing has to be fast and repeatable, and should be automated.
    The next questions are how to test and what to focus on when testing. Typically,
    all tests are divided into the following four segments:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding users**: The primary mode of testing is where the goal is to
    discover what users need and what problems they are having.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functionality check**: The goal of this mode of testing is to ensure that
    the functionality is correct and matches the specifications. It involves activities
    such as user testing, automated tests, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventing undesired changes**: The goal of this test is to prevent undesired
    changes in the system. Whenever a new change is deployed, several automated tests
    are run, a code coverage report is generated, and a code coverage level can be
    decided on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection against runtime behavior**: The goal of this test is to check
    what operational problems the system has. Here, we protect the system by doing
    stress testing, load testing, and monitoring.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will talk about the testing pyramid in microservices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid – what to test?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The testing pyramid is a tool to guide us through what kinds of tests can be
    written and at what levels. Tests at the top of the pyramid indicate fewer tests
    are needed, whereas more testing is required at the bottom of the pyramid. It
    illustrates what we should aim for and is shown in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7763e9e7-69e4-4955-8c0b-8b30f1384c3d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Testing pyramid
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing pyramid consists of four levels, as explained here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**System tests (top level)**: These tests span across the complete distributed
    microservice system and are usually implemented through the GUI.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service tests (middle level)**: These tests checks the complete execution
    of the business capability of the system. They check whether a particular business
    requirement has been fulfilled or not. They are not concerned with how many services
    behind the scenes are needed to fulfill the requirement.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract tests (lower level)**: These tests are carried out on the boundary
    of an external service to verify if meets the contract that is expected by a consuming
    service.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests (bottom level)**: These are tests that carry out a very small
    piece of functionality in a microservice. Several lower-level unit tests combine
    to form a microservice. Unit tests involve only a small aspect inside the microservice,
    or we can say that they operate at the macroscopic level. For example, our product
    catalog service has many services. Writing a unit test for it would involve passing
    a product ID and ensuring that I get the right product.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at all these levels in greater detail in the following sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: System tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sitting at the top of the pyramid are the system tests or E2E tests. They have
    a very broad scope, or we can say they have a 50,000-foot scope, and they try
    to cover a lot of things in very few tests. They don't go down the macroscopic
    level. Whenever a system test fails, it is difficult to identify where the problem
    is because of its large scope. The test covers the entire distributed system,
    so the problem can be anywhere, in any component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: An example of a system test in our shopping cart microservices would be the
    complete checkout process. It uses the web UI of the add to cart system, where
    we add a number of items, generate an invoice, apply a discount code, and pay
    using a test credit card. If the test passes, we can assert that the discount
    code can be applied and payments can be received. If the assertion fails, anything
    could have caused the failure, such as a wrong price for an item, maybe an extra
    charge was added, or maybe a payment service failed. To resolve this issue, we
    need to test all microservices to find the exact culprit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Covering a huge number of services and a broader area, system tests usually
    tend to be slow and imprecise (as we can't determine the exact service that is
    failing). Real service requests are made rather than a mocking system, things
    are written to real data stores, and even real event feeds are polled to monitor
    the system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'An important question that comes to mind is regarding the number of system
    tests that need to be run. System tests, when successful, give a great deal of
    confidence, but they are also slow and imprecise; we can write system-level tests
    for only the most important use cases. This can give us coverage of the success
    paths of all important business capabilities in the system. For complete E2E tests,
    we can do one of the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Test our API using JSON requests
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON请求测试我们的API
- en: Test the UI using Selenium, which emulates clicks on the DOM
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Selenium测试UI，模拟对DOM的点击。
- en: Use behavior-driven development, where use cases are mapped into actions in
    our application and are later executed on the application that we have built
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为驱动开发，将用例映射到我们应用程序中的操作，并在我们构建的应用程序上执行
- en: My recommendation is writing only business facing an important business capabilities
    system testing, as this exercises much of the fully deployed system and involves
    utilizing all the components in the ecosystem, such as the load balancer, API
    Gateway, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是只编写面向业务的重要业务能力系统测试，因为这样可以对完全部署的系统进行大量练习，并涉及利用生态系统中的所有组件，如负载均衡器、API网关等。
- en: Service tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务测试
- en: These tests are in the middle level of the test pyramid and they focus on interacting
    with one microservice in its entirety, and in isolation. The collaboration of
    this microservice with the outside world is replaced by mock JSON. Service-level
    tests test scenarios, rather than making a single request. They make a sequence
    of requests that together form a complete picture. These are real HTTP requests
    and responses, rather than mocked responses.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试处于测试金字塔的中间层，它们专注于与一个微服务的完整交互，并且是独立的。这个微服务与外部世界的协作被模拟JSON所取代。服务级测试测试场景，而不是进行单个请求。它们进行一系列请求，共同形成一个完整的图片。这些是真正的HTTP请求和响应，而不是模拟的响应。
- en: 'For example, a service-level test for a credits program can do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，信用计划的服务级测试可以执行以下操作：
- en: Send a command to trigger a user in the credits category (the command here follows
    the CQRS pattern seen in [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking
    Microservices*. CQRS follows a synchronous pattern of communication, so, its testing
    code would be the same). We send a command to trigger the other service to fulfill
    our service test criteria.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送命令以触发信用类别中的用户（这里的命令遵循CQRS模式，见[第1章](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml)，“揭秘微服务”）。CQRS遵循同步通信模式，因此，它的测试代码是相同的。我们发送命令以触发其他服务来满足我们的服务测试标准。
- en: Decide the best loyalty offer based on the user's monthly spending. This can
    be hardcoded, as it is a different microservice.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户的月度消费决定最佳的忠诚度优惠。这可以是硬编码的，因为它是一个不同的微服务。
- en: Record the offer sent to the user, and send back a response to check the functionality
    of the service.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录发送给用户的优惠，并发送响应以检查服务的功能。
- en: When all these aspects pass, we can assert that the credits program microservice
    works successfully and if any one of the functionalities fails, we know for sure
    that the issue is in the credits program microservice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些方面都通过时，我们可以断言信用计划微服务成功运行，如果任何一个功能失败，我们可以肯定问题出在信用计划微服务中。
- en: Service-level tests are much more precise than system-level tests as they cover
    only a single microservice. If such a test fails, we can with certainty assert
    that the problem lies within the microservice, assuming that the API Gateway is
    not buggy and it delivers the exact same response as written in the mocks. On
    the other hand, service-level tests are still slow, as they need to interact with
    the microservice being tested over HTTP and with a real database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务级测试比系统级测试更精确，因为它们只涵盖一个单一的微服务。如果这样的测试失败，我们可以肯定地断言问题出在微服务内部，假设API网关没有错误，并且它提供了与模拟中写的完全相同的响应。另一方面，服务级测试仍然很慢，因为它们需要通过HTTP与被测试的微服务进行交互，并且需要与真实数据库进行交互。
- en: My recommendation is that these tests should be written for the most important
    viable failure scenarios, keeping in mind that writing service-level tests is
    expensive as they use all the endpoints in the microservice and involve an event-based
    subscription.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，应该为最重要的可行故障场景编写这些测试，要牢记编写服务级测试是昂贵的，因为它们使用微服务中的所有端点，并涉及基于事件的订阅。
- en: Contract tests
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同测试
- en: There is a lot of collaboration going on between microservices in a distributed
    system. Collaborations need to be implemented as requests from one microservice
    to another. Any change in an endpoint can break all the microservices calling
    that particular endpoint. This is where contract tests come into the picture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，微服务之间有很多协作。协作需要作为一个微服务对另一个微服务的请求来实现。端点的任何更改都可能破坏调用该特定端点的所有微服务。这就是合同测试的作用所在。
- en: 'When any microservices communicate, the one that makes a request to another
    has some expectations about how the other microservice will act. This is how the
    collaboration would work out: the calling microservice expects the called microservice
    to implement a certain fixed contract. A contract test is a test for the purpose
    of checking whether the called microservice implements the contract as per the
    calling microservice''s expectation.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何微服务进行通信时，发出请求的微服务对另一个微服务的行为有一些期望。这就是协作的工作方式：调用微服务期望被调用的微服务实现某个固定的合同。合同测试是为了检查被调用的微服务是否按照调用微服务的期望实现了合同的测试。
- en: Although contract tests are part of the code base of the caller microservice,
    they also test things in other microservices. As they run against the complete
    system, it is beneficial to run them against a QA or staging environment and to
    configure to run contract tests automatically on each deployment. When a contract
    fails, it implies that we need to update our test doubles or change our code to
    take in the new changes the contract has made. These tests should be run based
    on the number of changes in external service. Any failure in a contract test won't
    break the build in the same way a normal test failure would do if it failed. It's
    an indicator that the consumer needs to keep up with changes. We need to update
    the tests and code to bring everything into sync. It will trigger a conversation
    will the producer service about how that change is affecting others.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: My conclusion is that contract tests are very similar to service tests, but
    the difference is contract tests focus on fulfilling the prerequisites for communicating
    with a service. Contract tests do not set up mock collaborators and actually make
    real HTTP requests to the microservice being tested. Therefore, they should be
    written against each microservice if possible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the tests at the bottom of the test pyramid. These tests also deal
    with a single microservice, but unlike service tests, they don''t focus on the
    entire microservice, nor do they work over HTTP. Unit tests interact with the
    parts/units of the microservice being tested directly or through in-memory calls.
    Testing in unit testing looks exactly like you are making real HTTP requests,
    except that you are dealing with mocks and playing with assertions. There are
    usually two kinds of unit testing involved: one that involves making database
    calls and another that involves playing directly with in-memory calls. A test
    can be termed a unit test if its scope is a very small piece of functionality,
    and if the test code and the production code in the microservice run in the same
    process.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests have a very narrow scope, making them very precise when identifying
    the problem. This helps in handling failures and errors effectively. Sometimes,
    you can have an even narrower scope of microservices by directly instantiating
    objects and then testing them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: For our credit program, we need several unit tests to test the endpoints and
    business capabilities. We need to test the user setup with both valid and invalid
    data. We need tests to read both existing and non-existing users to check our
    loyalty and monthly benefits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'My recommendation is that we should decide how narrow the narrowest unit test
    can be. Start with what the test should cover and then gradually add finer details.
    In general, there are two styles of unit testing that we can use: classic (state-based
    behavior testing) or mocking (interaction testing supported by mocking actual
    behavior).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see all the kinds of test applied to a microservice:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ac4fe7b-1a39-4f63-b333-7a7c0364be9c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Types of testing
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about all the kinds of tests needed at the microservice level,
    it is time to look at our microservice testing frameworks. In the next section,
    we will look at hands-on implementations of different kinds of testing and carry
    out the code coverage level of a microservice. Let's get started.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on testing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to get our hands dirty with microservice testing frameworks.
    In this section, we will look at testing basics and then carry on to write some
    unit tests, contract tests, and service-level tests. Writing tests has great advantages.
    We are forced to think through breaking the code into sub-functions and writing
    code based on the principle of single responsibility. Comprehensive test coverage
    with good tests makes us understand how the application works. In this section,
    we will be using some famous toolsets: Mocha, Chai, Sinon, and Ava. Ava will be
    our test runner, Chai will be our assertion library, and Sinon will be our mocking
    library.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Our libraries and test tool types
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test tools can be divided into various functionalities. In order to get the
    best out of them, we always use a combination of them. Let''s look at the best
    tools available based on their functionalities:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide a testing base: Mocha, Jasmine, Jest, Cucumber'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Give assertion functions: Chai, Jasmine, Jest, Unexpected'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate, display and observe test results: Mocha, Jasmine, Jest, Karma'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate and compare snapshots of component and data structures: Jest, Ava'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide mocks, spies, and stubs: Sinon, Jasmine, Enzyme, Jest, test double'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate code coverage reports: Istanbul, Jest, Blanket'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E2E tests: Casper, Nightwatch'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will quickly go through Ava, Chai, Mocha, and Sinon, and
    get to know what they have to offer to us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Even though Mocha is a standard library, I have selected Ava because it is very
    fast compared to Mocha and it runs each test as a separate Node.js process, thereby
    saving CPU usage and memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a fundamental assertion library following TDD/BDD that can be used in
    conjunction with any other libraries in order to have superior-quality tests.
    An assertion i
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: s any statement that has to be fulfilled, or else an error should be thrown
    and the test should be stopped. This is a very powerful tool to write easy-to-understand
    test cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides the following three interfaces to make test cases more readable
    and powerful:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`should`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with these three interfaces, we can use various natural language words.
    The full list can be found at [http://www.chaijs.com/api/bdd/](http://www.chaijs.com/api/bdd/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering what the difference is between `should` and `expect`.
    Well, it is a natural question. Although `should` and `expect` do the same thing,
    the fundamental difference is that the `assert` and `expect` interfaces do not
    modify `Object.prototype`, while `should` does.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most famous and widely used libraries, Mocha follows behavior-driven
    development testing. Here, the test describes the use case of any service, and
    it uses assertions from another library to verify the outcome of the executed
    code. Mocha is a test runner. It is used t
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'o organize and run tests through `describe` and its operators. Mocha provides
    various features, such as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeEach()`: It is called once before each spec in describe in the test
    file from which the test runs'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach()`: It is called once after each spec in describe in the test file'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before ()`: This runs code prior to any tests'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after()`: This runs code after all tests have run'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ava
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ava, like Mocha, is a test runner. Ava takes advantage of the parallel and asynchronous
    nature of Node.js and runs test files in parallel processing through a separate
    process. As per the stats, switching from Mocha to Ava in `pageres` (a plugin
    that captures screenshots), brought test time down from 31 seconds to 11 seconds
    ([https://github.com/avajs/ava/blob/master/readme.md](https://github.com/avajs/ava/blob/master/readme.md)).
    It has various options, such as fail fast, live watch (tests are rerun in watch
    mode when files are changed), storing snapshots, and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Ava is designed for the future and is completely written in ES6\. Test run
    concurrently here with option of going synchronous or asynchronous with the tests.
    Tests are considered synchronous by default unless they return a promise or an
    observable. They heavily use async function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ava是为未来设计的，完全使用ES6编写。测试可以并行运行，可以选择同步或异步进行测试。默认情况下，测试被认为是同步的，除非它们返回一个promise或一个observable。它们大量使用异步函数：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It has a wide range of options such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它有各种选项，如：
- en: Reports (beautiful reports showing test coverage)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告（显示测试覆盖率的美观报告）
- en: Failing fast (stops after the first failed test case)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速失败（在第一个失败的测试用例后停止）
- en: Skipping tests
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过测试
- en: Futuristic tests
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来的测试
- en: Sinon
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sinon
- en: Quite often, microservices need to call other microservices, but we don't want
    to call the actual microservice; we just want to focus on whether the method was
    called
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务需要调用其他微服务，但我们不想调用实际的微服务；我们只想关注方法是否被调用
- en: 'or not. For this, we have Sinon, a framework that gives us the options of mocks
    and spies, which fulfill our purpose by providing mock responses or creating a
    spy service. It provides the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者不。为此，我们有Sinon，一个框架，它给我们提供了模拟和间谍的选项，通过提供模拟响应或创建间谍服务来实现我们的目的。它提供以下功能：
- en: '**Stub**: A stub is a dummy object with a prerecorded and specific response.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stub**：存根是一个带有预先记录和特定响应的虚拟对象。'
- en: '**Spy**: A spy is a kind of hybrid between the real object and the mock. Some
    methods are shadowed by the spy object.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spy**：间谍是真实对象和模拟对象之间的混合体。一些方法被间谍对象遮蔽。'
- en: '**Mock**: A mock is a dummy object replacing the actual object.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mock**：模拟是替换实际对象的虚拟对象。'
- en: Istanbul
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伊斯坦布尔
- en: This is a code coverage tool that covers tracking statements, branches, and
    functional coverage. The module loader hooks to instrument code on the fly without
    the need for configuration. It offers multiple report formats, such as HTML, LCOV,
    and so on. It can also be used on command lines. It can be used as a server-side
    code coverage tool for Node.js by embedding it as custom middleware.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码覆盖工具，用于跟踪语句、分支和功能覆盖。模块加载器可以在不需要配置的情况下即时对代码进行检测。它提供多种报告格式，如HTML、LCOV等。它也可以用于命令行。通过将其嵌入为自定义中间件，它可以用作Node.js的服务器端代码覆盖工具。
- en: Contract tests using Pact.js
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pact.js进行合同测试
- en: Each microservice has its own independent implementation; let's say our categories
    service(product-catalog service). It has an endpoint for fetching a list of categories,
    getting the list of products associated with those categories, adding any new
    categories, and so on. Now our shopping cart microservices (consumer) utilizes
    this service, but at any point in time, the categories microservice (provider)
    may change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己独立的实现；比如我们的类别服务（产品目录服务）。它有一个用于获取类别列表、获取与这些类别相关的产品列表、添加任何新类别等的端点。现在我们的购物车微服务（消费者）利用这个服务，但在任何时候，类别微服务（提供者）可能会发生变化。
- en: 'At any point in time:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候：
- en: The provider might change the endpoint `/categories/list` to `/categories`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会将端点“/categories/list”更改为“/categories”
- en: The provider might change several things in the payload
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会更改有效负载中的几个内容
- en: The provider might add new mandatory parameters or may introduce a new authentication
    mechanism
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会添加新的强制参数或引入新的身份验证机制
- en: The provider might remove endpoints that are needed by the consumer
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会删除消费者所需的端点
- en: 'Any of these conditions may lead to a potential catastrophe! These kinds of
    test would not be handled by unit tests and the traditional approach is to use
    integration tests. But, however, we can see potential drawbacks of integration
    tests, such as the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些情况都可能导致潜在的灾难！这些类型的测试不会被单元测试处理，传统方法是使用集成测试。但是，我们可以看到集成测试的潜在缺点，例如以下内容：
- en: Integration tests are slow. They require setting up integration environments
    where dependencies for both providers and consumers are fulfilled.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试很慢。它们需要设置集成环境，满足提供者和消费者的依赖关系。
- en: They are brittle and can fail due to other reasons, such as infrastructure.
    A failed integration test doesn't necessarily mean a problem with the code. Due
    to the high scope of integration tests, it becomes very painful to find out the
    actual problem.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很脆弱，可能因其他原因而失败，比如基础设施。集成测试的失败并不一定意味着代码有问题。由于集成测试的范围很广，要找出实际问题变得非常痛苦。
- en: Hence, we need to go for contract tests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要进行合同测试。
- en: What is consumer-driven contract testing?
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是消费者驱动的合同测试？
- en: Contract testing means that we check our API against a set of expectations (what
    we define as contracts) which are meant to be fulfilled. This means that we want
    to check whether, upon receiving any API request call, our API server will return
    the data we specified in the documentation or not. We often miss out precise information
    regarding the needs of our API customers. To overcome this problem, consumers
    can define their set of expectations as mocks, which they use in unit tests, thus
    creating contracts that they expect us to fulfill. We collect these mocks and
    check that our provider returns the same or any similar data or not when they
    get called the same way as mocks are set up, thereby testing the service boundary.
    This complete approach is called consumer-driven contract testing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试意味着我们根据一组期望（我们定义为合同的内容）来检查我们的API，这些期望是要实现的。这意味着我们想要检查，当收到任何API请求时，我们的API服务器是否会返回我们在文档中指定的数据。我们经常忽略关于我们的API客户需求的精确信息。为了解决这个问题，消费者可以定义他们的期望集作为模拟，在单元测试中使用，从而创建他们期望我们实现的合同。我们收集这些模拟，并检查我们的提供者在以与模拟设置相同的方式调用时是否返回相同或类似的数据，从而测试服务边界。这种完整的方法被称为消费者驱动的合同测试。
- en: 'The idea of consumer-driven contracts is just to formalize any or all of the
    interactions between a consumer and a provider. The consumer creates a contract,
    which is just an agreement between the consumer and provider on the amount of
    interaction that will take place between them or simply stating what the consumer
    expects from the provider. Once the provider has agreed to the contract, both
    the consumer and provider can take a copy of the contract and use tests to verify
    that contract violation doesn''t occur on any end of the system. The major advantage
    of these kinds of tests is they can be run independently and locally and they
    are super fast and can be run without any hassle. Similarly, if a provider has
    several consumers, we will need to verify several contracts: one for each consumer.
    This will help us to ensure that changes to the provider do not break any consumer
    services.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Pact is one of the famous open source frameworks that enable consumer-driven
    contract testing. There are various implementations for Pact for various platforms,
    such as Ruby, JVM, and NET. We will be using the JavaScript version Pact JS. So
    Let's get started. Let's start our journey with Pact.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pact.js
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be utilizing the `pact` module ([https://www.npmjs.com/package/pact](https://www.npmjs.com/package/pact))
    available in NPM. The overall process would be as follows, where we would n
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: need to do operations at both the consumer and the provider levels.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be dividing our implementation into two parts. We will set up a provider
    as well as a client to test whether the services are communicating with one another:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**On the consumer side**:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a mock web server that will act as a service provider rather
    than making an actual call. Pact.js provides this functionality out of the box.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For any request that we want to check, we will define the expected response
    that the mock service needs to return to check whether there are any sudden changes.
    In Pact language, we call these interactions; that is, for a given request what
    does the consumer want the provider to return?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We next create unit tests where we will run our service client against the mock
    provider to check whether the client returns these expected values.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will create a `pact` file containing the consumer expectations as
    a contract.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**On the provider side**:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider side gets the pact file from the consumer.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs to verify that it doesn't violate the expected interactions of the
    consumer. `Pact.js` will read the `pact` file, execute the request for each interaction,
    and confirm whether the service returns the payload expected by the consumer.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By checking that the provider does not violate any of its consumer's contracts,
    we can be sure that the latest changes to the provider's code don't break any
    consumer code.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, we can avoid integration testing and still be confident of our system.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After understanding the process, let''s now implement it. We will follow the
    preceding steps regarding the consumer and provider, one at a time. The complete
    example can be found in `chapter-8/pact-typescript`. Our example project is the
    categories microservice and we will be playing around with it. So, let''s get
    started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We first create a provider. We will create a service that returns some animals
    and a specific animal service that gives me an animal on passing an ID.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the code from the provider by adding `provider.ts`, `providerService.ts`, `repository.ts` from `packt-typescript/src/provider` and `data.json` from `pact-typescript/data`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dependencies:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we will create a consumer. The consumer consumes files from providers.
    We will create a Pact server:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define our expectations next, where we will say:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we write our usual tests, but before adding the tests, we add these interactions
    in Pact:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, w write the usual tests:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shut down the mock server:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we are done on the provider side, we need to verify our provider.
    Start the `provider` service and in its test file, add the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了提供者方面的工作，我们需要验证我们的提供者。启动`provider`服务，并在其测试文件中添加以下代码：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bonus (containerizing pact broker)
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励（容器化pact broker）
- en: 'In dynamic environments, we need to share Pacts across applications rather
    than working in a single application. To do so, we will leverage the functionality
    of the Pact broker. You can simply download it from [https://hub.docker.com/r/dius/pact-broker/](https://hub.docker.com/r/dius/pact-broker/).
    You can download it through Docker using `docker pull dius/pact-broker`. Once
    started, you can access the broker with `curl -v http://localhost/9292 #`, which
    you can visit in your browser too! You can configure it with a database and run
    a combined `docker-compose.yml` file too. A demo configuration for pact-broker
    configured with Postgres can be found at [https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml](https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml).
    Once configured by executing the `docker-compose up` command, the `pact` broker
    can be accessed on port 80 or port 443 depending on whether SSL is enabled or
    not.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '在动态环境中，我们需要跨应用程序共享Pacts，而不是在单个应用程序中工作。为此，我们将利用Pact broker的功能。您可以从[https://hub.docker.com/r/dius/pact-broker/](https://hub.docker.com/r/dius/pact-broker/)简单地下载它。您可以使用`docker
    pull dius/pact-broker`通过Docker下载它。一旦启动，您可以使用`curl -v http://localhost/9292 #`访问经纪人，您也可以在浏览器中访问！您还可以使用数据库配置它，并运行一个组合的`docker-compose.yml`文件。可以在[https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml](https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml)找到配置为Postgres的pact-broker的演示配置。通过执行`docker-compose
    up`命令配置后，可以在端口80或端口443上访问`pact` broker，具体取决于是否启用了SSL。'
- en: Revisiting testing key points
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视测试关键点
- en: 'Let''s recall our key points on testing before moving on to the next section
    in the book:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本书的下一部分之前，让我们回顾一下测试的关键点：
- en: The testing pyramid indicates the number of tests required for each kind of
    test. Tests at the top of the pyramid should be fewer in number than the level
    below them.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔表示每种测试所需的测试数量。金字塔顶部的测试数量应该比它们下面的级别少。
- en: Due to their broader scope, system-level tests are meant to be slow and imprecise.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其更广泛的范围，系统级测试应该是缓慢和不精确的。
- en: System-level tests should only be used to provide some test coverage for important
    business capabilities.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统级测试应该只用于为重要的业务功能提供一些测试覆盖。
- en: Service-level tests are faster and more precise then system-level tests, as
    they have to deal with a reduced scope.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务级测试比系统级测试更快，更精确，因为它们只需处理较小的范围。
- en: A practice should be followed to write service-level tests for success and important
    failure scenarios.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该遵循一种实践，即为成功和重要的失败场景编写服务级测试。
- en: Contract tests are important, as they verify the assumption one microservice
    makes about the API and behavior of another microservice.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同测试很重要，因为它们验证一个微服务对另一个微服务的API和行为的假设。
- en: Unit tests are meant to be fast and should be kept fast by only including a
    single unit or using the principle of single responsibility.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该快速，并且通过只包括一个单元或使用单一职责原则来保持快速。
- en: To have wider test coverage, always write service tests first and write unit
    tests later when it becomes unmanageable to write service tests.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了拥有更广泛的测试覆盖范围，总是先编写服务测试，当编写服务测试变得难以管理时再编写单元测试。
- en: We use Sinon, Ava, Chai, and Istanbul for testing our microservices.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Sinon，Ava，Chai和Istanbul来测试我们的微服务。
- en: 'To write service level tests:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编写服务级测试：
- en: Write mocked endpoints of the microservice under test
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写被测试微服务的模拟端点
- en: Write scenarios that interact with the microservice
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写与微服务交互的场景
- en: Make assertions both on a response from the microservice and the requests it
    makes to collaborators
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对来自微服务的响应和它对协作者的请求进行断言
- en: By using Pact, you can write contract-level tests, thus avoiding integration
    tests.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Pact，您可以编写合同级别的测试，从而避免集成测试。
- en: Contract tests are very helpful as they make sure that a microservice adheres
    to its prefixed contracts and any sudden change in a service does not break any
    business capabilities.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同测试非常有帮助，因为它们确保微服务遵守其预先制定的合同，并且服务的任何突然变化都不会破坏任何业务功能。
- en: '**Advanced:** Sometimes you may need to try out snippets of code in a real-time
    environment, either to reproduce a problem or to try the code in a realistic environment.
    Telepresence ([http://telepresence.io/](http://telepresence.io/)) is a tool that
    allows you to swap out running code in Kubernetes.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级：** 有时您可能需要在实时环境中尝试代码片段，无论是为了重现问题还是在真实环境中尝试代码。Telepresence ([http://telepresence.io/](http://telepresence.io/))
    是一个工具，允许您在Kubernetes中交换运行的代码。'
- en: '**Advanced:** Ambassador ([https://www.getambassador.io/](https://www.getambassador.io/))
    is an API Gateway allowing microservices to easily register their public endpoints.
    It has a variety of options, such as statistics about traffic, monitoring, and
    so on.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级：** Ambassador ([https://www.getambassador.io/](https://www.getambassador.io/))
    是一个API网关，允许微服务轻松注册其公共端点。它有各种选项，例如有关流量的统计信息，监控等。'
- en: '**Advanced:** Hoverfly ([https://hoverfly.io/](https://hoverfly.io/)) is a
    way to achieve microservices virtualization. We can simulate latency and failures
    in APIs through it.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级：** Hoverfly ([https://hoverfly.io/](https://hoverfly.io/)) 是实现微服务虚拟化的一种方式。我们可以通过它模拟API中的延迟和故障。'
- en: After going through the testing process, it is now time to solve problems on
    the fly with debugging. We will learn about debugging and profiling microservices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 经过测试流程后，现在是时候通过调试解决问题了。我们将学习有关调试和分析微服务的内容。
- en: Debugging
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'Debugging is one of the most important aspects in the development of any system.
    Debugging, or the art of solving problems, is crucial in software development
    as it helps us to identify issues, profile the system, and identify the culprits
    responsible for taking down the system. There are some classic definitions of
    debugging:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是任何系统开发中最重要的方面之一。调试或解决问题的艺术在软件开发中至关重要，因为它帮助我们识别问题、对系统进行分析，并确定导致系统崩溃的罪魁祸首。有一些关于调试的经典定义：
- en: '"Debugging is like solving a murder mystery in which you are the murderer.
    If debugging is the process of removing bugs, then software development is the
    process of putting these bugs in it"'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “调试就像解决一起谋杀案，而你是凶手。如果调试是消除错误的过程，那么软件开发就是将这些错误放入其中的过程”
- en: – Edsgar Dijkstra.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- Edsgar Dijkstra。'
- en: Debugging a TypeScript microservice is very similar to debugging any web application.
    Going for open source free alternatives, we will go for node-inspector, as it
    also provides very useful profiling tools.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 调试TypeScript微服务与调试任何Web应用程序非常相似。在选择开源免费替代方案时，我们将选择node-inspector，因为它还提供非常有用的分析工具。
- en: We already saw debugging through VS Code in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第2章《为旅程做准备》中通过VS Code进行了调试。
- en: In the next section, we will learn how to profile and debug our application
    using node-inspector. We will look at various aspects of remote debugging and
    how to build a proxy in between a service to debug our microservices. So, let's
    get started.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用node-inspector对我们的应用程序进行分析和调试。我们将看看远程调试的各个方面，以及如何构建一个代理来调试我们的微服务。所以，让我们开始吧。
- en: Building a proxy in between to debug our microservices
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个代理来调试我们的微服务
- en: 'Microservices are distributed based on business capabilities. From the end-user
    they may seem a single functionality say for instance: buying a product, but behind
    the scenes, there are many microservices involved, such as the payment service,
    add to cart service, shipping service, inventory service, and so on. Now, all
    of these services should not reside inside a single server. They are spread and
    distributed as per design and infrastructure. Scenarios occur where two servers
    collaborate with each other and bad behavior may occur at any level if these services
    are not monitored. It is a very common problem in microservices, which we are
    going to solve using `http-proxy` and tunneling. We are going to create a very
    simple example that will log the raw headers of any request. This information
    can give us valuable information about what is actually going on in the network.
    This concept is very similar to what we used in the API Gateway. Normally, the
    API Gateway is a proxy for all requests; it queries the service registry to dynamically
    fetch the location of a microservice. This proxy layer, our gateway, has various
    advantages, which we saw in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding
    API Gateway*. We will be using the node module `http-proxy` ([https://www.npmjs.com/package/http-proxy](https://www.npmjs.com/package/http-proxy))
    and log the request headers there. Initialize one Node.js project, add the `src`, `dist`,
    and `tsconfig.json` folders, and add the `http-proxy` module and its typings.
    Then, enter the following code in index.ts to create a proxy server. The full
    code can be found under the extracted source at `Chapter 8/ts-http-proxy`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是基于业务能力分布的。对于最终用户来说，它们可能看起来像是单一功能，比如购买产品，但在幕后，涉及到许多微服务，比如支付服务、加入购物车服务、运输服务、库存服务等等。现在，所有这些服务不应该驻留在单个服务器内。它们根据设计和基础设施进行分布和分发。在某些情况下，两个服务器会相互协作，如果这些服务没有受到监控，就可能在任何级别出现不良行为。这是微服务中一个非常常见的问题，我们将使用`http-proxy`和隧道来解决。我们将创建一个非常简单的示例，记录任何请求的原始标头。这些信息可以为我们提供有关网络实际发生了什么的宝贵信息。这个概念与我们在API网关中使用的非常相似。通常，API网关是所有请求的代理；它查询服务注册表动态获取微服务的位置。这个代理层，我们的网关，有各种优势，我们在第5章《理解API网关》中看到了。我们将使用node模块`http-proxy`（[https://www.npmjs.com/package/http-proxy](https://www.npmjs.com/package/http-proxy)）并在那里记录请求标头。初始化一个Node.js项目，添加`src`、`dist`和`tsconfig.json`文件夹，添加`http-proxy`模块及其类型。然后，在index.ts中输入以下代码以创建代理服务器。完整的代码可以在提取的源代码中找到，位于`第8章/ts-http-proxy`下：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, when you hit `localhost:4000`, it will print all the raw headers, which
    you can check in the source code and see the response of the service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当您访问`localhost:4000`时，它将打印所有原始标头，您可以在源代码中检查并查看服务的响应。
- en: In the next section, we will have a look at the Chrome debugging extension and
    profiling tools.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看Chrome调试扩展和分析工具。
- en: Profiling process
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析过程
- en: Profiling is a key process these days when it comes to analyzing a service for
    performance. There are native tools available for Node.js that can profile any
    running V8 process. These are just snapshots with effective summaries that include
    statistics on how V8 treats the process when compiling, and the actions and decisions
    it makes while optimizing the hot code it ran against the V8 engine.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析服务性能方面，分析是一个关键过程。Node.js有一些原生工具可以对任何正在运行的V8进程进行分析。这些只是包含有关V8处理过程的统计信息的有效摘要的快照，以及V8在编译时如何处理该过程以及在优化运行热代码时所做的操作和决策。
- en: We can have a v8 log generated in any process simply by passing the `--prof` flag. `prof` stands
    for a profile. An example is `node --prof index.js`. That won't be much of a readable
    format. To create a more readable format, run the `node --prof-process <v8.logfilename>.log
    >` command's profile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递`--prof`标志在任何进程中生成v8日志。`prof`代表配置文件。例如`node --prof index.js`。那不会是一个可读的格式。要创建一个更可读的格式，运行`node
    --prof-process <v8.logfilename>.log >`命令的配置文件。
- en: In this section, we will look at how to profile using profile logs, take heap
    snapshots, and utilize Chrome's CPU profiling for microservices. So, let's get
    started. You can process the logs of any file using `node --prof <file_name>.js`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Dumping heap
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A heap is a huge memory allocation. When we talk about our case, it is the
    memory allocated to the V8 process (time to recall how Node.js works—the Event
    Loop and the memory allocation).  By checking the memory usage, you can track
    down things such as memory leaks or just check which part of the service has the
    most consumption, based on which you can adjust the code accordingly. We have
    a very fine `npm` module ([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump)),
    which take a dump that can be used later for inspection. Let''s get familiar with
    reading the dump process and when to take a dump, though the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'We install Heap Dump and create a dump ready to be used. Open up any project,
    and install the `heapdump` module with:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, copy the following lines of code in any process where you want to create
    the snapshot. I have kept them in `Application.ts` just as an example. You can
    follow the code in `chapter8/heapdump_demo`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, when you run the program, you can find the snapshot in the directory from
    which we ran the preceding lines of code. You will find output like dump written
    to `/home/parth/chapter 8/heapdump_demo/../<timestamp>.heapsnapshot`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must have something like `<current_date_in_millis>.heapsnapshot`. It will
    be in a non-readable format, but that''s where we will be utilizing Chrome''s
    DevTools. Open Chrome DevTools and go to the Memory | Select profiling type | Load option.
    Open the snapshot file and you will be able to see the following screenshot:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac3665aa-d69e-495b-a3dc-822e9b8f0d74.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Click on Statistics and you will be able to see this:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dcca964f-77ed-4cb6-9560-a07abd7b8b84.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'You can go through the following links to get in-depth knowledge about profiling:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101](https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101)[h](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ttps://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can periodically take dumps or take dumps in the event of errors, which would
    be very helpful in order to find the issue in a microservice. Next, we will see
    how to do CPU profiling.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chrome Developer Tools has some very nice options that are not just limited
    to debugging. We can also leverage memory allocation, CPU profiling, and so on.
    Let''s dig deep into CPU profiling. For the sake of understanding the tool, we
    will spin up a program that consumes heavy CPU usage:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Create any express app and create one random route, which basically iterates
    100 times and allocates a buffer 10⁸ in the memory. You can follow the code in `chapter
    8/cpu-profiling-demo`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next step is to run the Node.js process in Chrome DevTools. To do so, just
    add the `--inspect` flag in `node --inspect ./dist/bin/www.js`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Chrome debugging protocol is included in the Node.js core module and we
    do not need to include it in every project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Open `chrome://inspect` and we will be able to see our process under it. Click
    on inspect and we are ready to debug the Node.js application just like a standard
    web application.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Profiler, which is where we will debug the CPU behavior. Click on Start,
    open any tab, and hit `localhost:3000/check-mem`. Come back to our tab. Click
    on Stop when you are able to see I am done. You should be able to see something
    like this like in the figure profiling and profiling detail:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/628ae1c9-2bd5-432a-aa8e-2bbcf22065b9.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Profiling
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, hover over a single row and you will be able to see a detailed view like
    this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/afa6e1d0-7a44-4b3b-a4fa-e3d20b84da25.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Profiling detail
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Live Debugging/Remote Debugging
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The penultimate and important feature is to debug a problem live. With the
    introduction of the inspector protocol inside Node.js, this becomes a piece of cake as
    all we have to do is create an `--inspect` version of running the process. This
    will print the URL of the process on which debug is open, something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can install the Chrome extension Node.js V8 --inspector Manager (NiM),
    from [https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj) for
    debugging remote applications or you can even spawn a process for debugging and
    specify a port with:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can find other options here: [https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options](https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options).
    When any process is started with the `--inspect` switch, Node.js listens to it
    via sockets for diagnostics commands uniquely identified by the host and the port.
    Each process is assigned a unique UUID for tracking. Node-Inspector also provides
    an HTTP endpoint to serve metadata about debugger, including its WebSocket URL,
    UUID, and Chrome DevTools URL. We can get this information by hitting `<host:port>/json/list`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging is great, but we should make sure that it does not come with a side
    effect. Debugging means opening up a port, which will have security implications.
    The following points should be taken care of with utmost precautions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the debug port publicly is not safe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local applications running inside have full access to the application inspector
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same origin policy should be maintained
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our debugging and profiling session. In the next section, we
    will revisit key points before moving on to documenting.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Key points for debugging
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we saw debugging and core aspects involved in profiling. We
    learned how to diagnose a leak or observe heap dump memory to analyze a service
    request. We saw how a proxy can often help, even if it increases a network hop:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: To avoid overloading, we have a module providing as in, code `503` middleware.
    Refer to [https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection) for
    implementation details.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome Inspector is a very useful tool for debugging Node.js microservices,
    as it not only provides a debugging interface, but also heap snapshots and CPU
    profiling.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code is also a very user-friendly tool.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js embraced node-inspector and included it in the core module, thus making
    remote debugging very easy.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know the fundamental aspects of debugging, let''s move on to the
    final part of making a developer''s life easy. Yes, you guessed it correct: proper
    documentation, which always saves the day not just for the technical team but
    also non-technical persons.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Documenting
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Documenting** is a contract between the backend and the frontend that takes
    care of dependency management between the two sides. If the API changes, the document
    needs to adapt to it quickly. One of the easiest fails in development can be the
    lack of visibility or lack of awareness about other people''s work. Often, the
    traditional approach is to write service specification documents or use some static
    service registries that maintain different things. No matter how hard we try,
    documentation always goes out of date.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Need of Documentation
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Documentation of development and organizational understanding of the system
    increases developers, skill and speed while dealing with two of the most common
    challenges that come with microservice adoption—technical and organizational change.
    The importance of thorough, updated documentation cannot be underestimated. Whenever
    we ask someone about problems they face while doing anything new, the answer is
    the same. We all face the same issue: we don''t know how this thing works, it''s
    a new black box and the documentation given is worthless.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Poor documentation of dependencies or internal tools makes developer's lives
    a nightmare and slows down their ability and the production readiness of a service.
    It wastes countless hours because the only way that remains is re-engineering
    the system until we have the resolution. Edison did indeed say, *I have found
    2000 ways of how not to make the light bulb,* but I would like to spend my time
    rather on 2000 ways to get more out of me. Poor documentation of a service also
    hurts the productivity of the developers who are contributing to it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of production-ready documentation is to make and organize a centralized
    repository of knowledge about the service. Sharing this piece of information has
    two aspects: the fundamental parts of the service and where the service contributes
    to achieving what piece of functionality.  Solving these two problems requires
    standardizing a documentation approach to sharing microservice understanding.
    We can summarize the following documentation points:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Any service should have comprehensive and detailed documentation (should include
    what the service is and to what it is contributing)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation should be updated regularly (all the new methods and maintained
    version)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be understood by all and not just the technical team
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its architecture is reviewed and audited every fixed interval of time
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When approaching microservices, the pain increases exponentially as we divide
    each business capability into a different service. We need a more generic approach
    to documenting microservices. Swagger is currently the forerunner in documentation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swagger, you will get the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: No inconsistent API descriptions anymore. These will be updated with complete
    contract details and parameter information.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You won't need to write any more documentation; it will be auto-generated.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, of course, there will be no more arguments regarding poor documentation.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section will explore how to use Swagger, understand its core tools, its
    advantages, and working implementations. So, let's get started.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Swagger 101
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger is a powerful representation of your microservices or, in fact, any
    RESTful API. Thousands of developers are supporting Swagger in almost every programming
    language and environment. With a Swagger-enabled environment, we get interactive
    documentation, client SDK generation, discoverability, and testing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Swagger is a part of the Open API Initiative (a committee standardizing how
    REST APIs should be described). It provides a set of tools to describe and document
    a RESTful API.  Swagger, which began as an API documentation tool, can now also
    generate boilerplate code via **Swagger Codegen** ([https://github.com/wcandillon/swagger-js-codegen](https://github.com/wcandillon/swagger-js-codegen)).
    Swagger has a large ecosystem of tools, but primarily we will be using the following
    set of tools. We will understand how to integrate Swagger with an existing application
    or write an API specific to Swagger standards, through which our documentation
    will be auto-generated. The overall process involved can be understood from the
    following diagram:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef59d39a-761c-4b99-90c2-6d431f32d76f.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Swagger_workflow
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at the overall tools involved in the process to get a thorough
    understanding of all the aspects involved in it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Editor and Descriptor
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Descriptor takes a page from design-driven development. Here, we design
    our endpoints' behavior by describing them in a YML/YAML file or a JSON file.
    (Of course, as a developer I am too lazy to even write this file and I would prefer
    this to be autogenerated, which we will look at in a further section.) This is
    the most important section as it is the contextual information about the service.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Check out `Chapter 8/hello_world_swagger.yaml` to get an idea of the descriptor
    file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Key points for Swagger  and Descriptor
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your URL route, parameter, and description is defined inside the `.yaml` file.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a parameter is required or not, you can pass using the required true,
    which will validate that parameter while testing it out
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also return response codes and their descriptions
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger reads this `.yaml` file to generate its Swagger UI and test services
    using the Swagger inspector
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger Editor
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Editor is an online tool that helps y
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: ou to edit Swagger API specifications in your browser by previewing the documentation
    in real time as per Swagger API specifications. This way, we can see how the documentation
    will look after applying the most recent changes on the fly. The editor has a
    clean interface and is easy to use with lots of features to design and document
    various microservices. It is available online at [https://editor2.swagger.io/#!/](https://editor2.swagger.io/#!/).
    By just writing or importing a `swagger.yaml` file, we can view the Swagger UI
    in real time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get our hands dirty with Swagger Editor and Swagger Descriptor:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Open up [https://editor2.swagger.io](https://editor2.swagger.io) and enter our
    previous descriptor (`hello_world_swagger.yaml`).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be able to see live documentation on the right side:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fcdb4dcf-b65d-45f6-bdd2-7d48398895c4.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: Swagger Editor
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Try inserting more code in the descriptor file and check out the interactive
    documentation. Also, try running Try this operation. It will give a description
    of the HTTP request along with all the headers and responses.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swagger Codegen
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Codegen is a scaffolding engine that gives us the option to generate
    interactive documentation, API clients, and server stubs from Swagger definitions.
    The previous options that we saw in Swagger Editor (generating a server and generating
    a client) resemble the implementation of Swagger Codegen. It has support for a
    lot of languages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Client-side scaffolding tool that includes support for languages such as TypeScript
    Angular, TypeScript Node, JavaScript, Python, HTML, Java, and C#. Server-side
    scaffolding tool supports languages such as Haskell, Node.js, Go language, and
    Spring.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger CodeGen** ([https://swagger.io/swagger-codegen/](https://swagger.io/swagger-codegen/))
    helps us to build APIs quicker and improve the quality by adhering to OpenAPI-defined
    specifications. It generates server stubs and client SDKs so we can rather focus
    on API implementation and business logic rather than code creation and adopt standards:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of Swagger CodeGen**:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It generates server code, client code, and documentation
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for faster changes of API
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code generated is open source
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages of Swagger CodeGen**:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an increase in project complexity by adding extra tools and libraries
    and the added complexity of managing those
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can generate a lot of code that the user might not be able to digest
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check `Chapter 8/typescript-node-client/api.ts` to see the auto generated
    code based on our initial Swagger descriptor definition.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swagger UI allows us to visualize a RESTful API. Visualizations are automatically
    generated from Swagger specifications. The Swagger UI takes in a Swagger descriptor
    file and creates documentation with the Swagger inspector in the UI. The Swagger
    UI is what we saw in the preceding screenshot on the right-hand side. Furthermore,
    this can be given access based on privileges. The Swagger UI is a collection of
    HTML, JavaScript, andCSS assets that dynamically generate beautiful documentation
    from a Swagger-compliant API.  We will generate documentation for our product
    catalog microservice and use Swagger UI components in it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Inspector
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a pain-free way to generate documentation based on the OpenAPI specification.
    Once you have checked SWAGGER inspector with its working, then you can create
    documentation and share it with the world. We can easily autogenerate documentation
    by selecting the previously tested endpoints from the history and then issuing
    the command for CREATE API DEFINITION. It is much like Postman on the web. You
    can download Swagger inspector as a Chrome extension. It has these options:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a7c8ecd-ebe5-47a5-a01b-327fe63702dc.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: Swagger inspector
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Now that we got ourself acquainted with Swagger, let's look at how to use Swagger
    in our microservices to generate beautiful documentation for us. The next section
    talks about possible approaches in which we can integrate swagger.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Possible strategies to use Swagger
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swagger is mostly used for documenting services and testing services out. There
    are two fundamental approaches in implementing Swagger. They are as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-down or design-first approach: **Here, Swagger Editor is used to create
    Swagger definitions and then Swagger Code-gen is used to generate code for the
    client as well as the server. Swagger will be used to design the API and source
    before any of the code has been written.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottom-up approach: **Here, for any of the existing APIs, Swagger is used
    to generate documentation.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at both of the approaches along with the best practices available
    for us.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Top-down or design-first Approach
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, generating a valid Swagger file and documentation via just adding a
    few lines of code seems like a good idea. We have written all the code and then we remember:
    *Oh my goodness, how will I explain this to others? Will I need to document each
    and every API?* On the fly generation of documentation at such time simply by
    adding an annotation seems to be a dream come true in such situations.   TSOA ([https://www.npmjs.com/package/tsoa](https://www.npmjs.com/package/tsoa))
    is designed on such a principle. Based on TSOA README file, it generates a valid
    Swagger spec from a written controller and models that include the following.
    This essentially is a bottom-up approach where we already have an existing REST
    API and we leverage Swagger to document the existing API.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'TSOA generates a valid Swagger `spec` file from controllers and models that
    include:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Paths to various REST URLs (example: `Get users :- server_host/users/get_users`)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definitions based on TypeScript interfaces (these are the model files or attribute
    descriptors)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters types; that is, model properties are marked as required or optionally
    based on TypeScript syntax (for example, `productDescription?: string` is marked
    as optional in the Swagger specs)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jsDoc support for object descriptions (most other metadata can be inferred from
    TypeScript types)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like routing-controllers, routes are generated for any middleware of our choice.
    Options include Express, Hapi, and Koa. Similar to routing-controllers, TSOA has
    a class validator inbuilt. TSOA minimizes boilerplate code as much as possible
    and it has plenty of annotations available. You can check the documentation in
    `npm` for a detailed understanding of the various options available. We will be
    mainly concerned with the `@Route` annotation, which will generate the Swagger
    doc for us. In the example, we will use TSOA and generate the documentation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Please see extracted source for top-down approach, the example is pretty straight
    forward strictly adhering to the documentation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up approach
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! After going through a top-down approach, it seems like the perfect plan.
    But what about when we have already developed the project and now we want to generate
    our documentation. We are left in a conundrum. What should we do? Luckily, we
    have just the solution. We will leverage `swagger-ui-express` ([https://www.npmjs.com/package/swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express))
    to generate the documentation. It has more than 45,000 downloads a week. It is
    a community-driven package that enables a middleware for your express application,
    which serves the Swagger UI based on the Swagger documentation file. We will need
    to add one route, which will host the Swagger UI. Documentation is good and everything
    is there—whatever we need. So, let's get started. You can follow along with the
    source code in the `Chapter 8/bottom-up-swagger` folder.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the module from `npm` as a dependency:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we will need to add a route, which will host the Swagger UI. We need to
    generate the Swagger definition and update it on each deployment.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have two options to generate the Swagger documentation. Either we add comments
    in each of our route handlers or we use the Swagger inspector to test all the
    REST APIs, club those, and generate a definition file.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whatever route we go for, our objective remains the same: to generate the `swagger.json`
    file. Going with the first approach, we will use `swagger-jsdoc` ([https://www.npmjs.com/package/swagger-jsdoc](https://www.npmjs.com/package/swagger-jsdoc)).
    Download the module as a dependency with:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s get started with our configuration. First of all, we need to initialize
    Swagger JS Doc on Express startup. Create one class, `SwaggerSpec`, and inside
    it add the following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we initialized the JSDoc and stored the `swagger.json` inside variable
    private static `swaggerJSON:any` so it can be used when we want to serve the JSON.
    We kept the usual configurations inside the `JSDoc` object.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Next, on express startup, we need to initialize the `setUpSwaggerJSDoc` method,
    so we can fill up the JSON at the start of the server.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Controller`, which gives us `swagger.json` as an HTTP endpoint.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hit `http://localhost:8081/swagger/swagger.json` to see the initial Swagger
    JSON.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to add JSDoc-style comments to each route to generate the Swagger
    spec and add comments in YAML to route handlers. Adding appropriate comments like
    this will populate our `swagger.json`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another option is to generate the documentation using Swagger inspector. Now
    that we are done with Swagger generation, we need to generate the Swagger UI.
    Add these in `Express.ts` this:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Swagger is a great documentation tool and fulfills all our purposes. Whether
    we use it from the start or after development, it is a good fit to fulfill our
    documentation needs. The `./api/v1` file will give you generated Swagger documentation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Generating a project from a Swagger definition
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now we were generating swagger definition from our source code. The other
    way round also holds true. We can easily generate a project from a Swagger definition
    and type of language (we saw something similar in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml),
    *Service State and Interservice Communication*. Rings a bell? That is correct.
    rPC and code generation). Let''s download swagger-code-generate and create our
    project out of it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Check out the updated `hello_world_swagger.yml` in the extracted src `chapter
    8/swagger-code-gen`. It has one more added route/endpoint of the API to update
    the product information.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next step is to download swagger-code-gen from at [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen),
    so we can even configure it in automation or use it as required, rather than going
    to the online Swagger editor every time. You can also find swagger-code-gen in
    the extracted source of this book.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since its a project that runs on JVM, we build the project so we can run it.
    Hit the command `mvn package` to build the JAR.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will generate the source code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can explore `typescript-nodejs` inside `chapter-8/swagger-code-gen` to understand
    the generated structure and play around with it. Similarly, you can go for any
    other language. Further documentation can be found here [https://github.com/swagger-api/swagger-codegen/blob/master/README.md](https://github.com/swagger-api/swagger-codegen/blob/master/README.md).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swagger is a wonderful utility to generate documentation on-demand. The documentation
    generated is comprehensible even for product managers or partners, human-readable,
    and easily adjustable. It makes our lives not only easy, but it makes the API
    more consumable and manageable, as it adheres to OpenAPI specs. Swagger is widely
    used by leading companies such as Netflix, Yelp, Twitter, and GitHub. In this
    section, we saw its varied uses along with its cycle and various approaches.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at testing, debugging, and documenting. We looked
    at some fundamental aspects of testing. We looked at the testing pyramid and at
    how to do unit testing, integration testing, and E2E tests. We looked at contract
    testing using Pact. Then, we had a look at the debugging and profiling process,
    which is very helpful in solving critical issues. We saw how to perform debugging
    in the event of critical failures. Finally, we looked at the documention tool
    Swagger, which helps to keep central documentation, and we examined strategies
    to introduce Swagger our microservices.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at deployment. We will see how to deploy our
    microservices, get introduced to Docker, and learn about the fundamentals of Docker.
    We will then see some monitoring tools and logging options. We will integrate
    ELK stacks for logs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
