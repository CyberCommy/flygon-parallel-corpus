- en: Adding Vue Components
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Vue组件
- en: As we stated in the previous chapter, Vue components are an **optional part**
    of the Nuxt view. You've already learned about various constituents of the Nuxt
    view: app template, HTML head, layout, and page.However, we haven't covered the
    smallest unit in Nuxt -** the Vue component**. So, in this chapter, you will learn
    how it works and how to make use of `/components/` for creating custom components. You
    will then learn how to create global and local components, as well as basic and
    global mixins, and get to know some of the naming conventions for developing Vue
    or Nuxt apps. Most excitingly, you will discover how to pass data down from a parent
    component to a child component, as well as emit data up to the parent from the
    child.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所述，Vue组件是Nuxt视图的**可选部分**。您已经了解了Nuxt视图的各种组成部分：应用程序模板、HTML头部、布局和页面。但是，我们还没有涵盖Nuxt中最小的单位-**Vue组件**。因此，在本章中，您将学习它的工作原理以及如何利用`/components/`创建自定义组件。然后，您将学习如何创建全局和本地组件，以及基本和全局mixin，并了解一些用于开发Vue或Nuxt应用程序的命名约定。最令人兴奋的是，您将发现如何将数据从父组件传递到子组件，以及如何从子组件向父组件发出数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Vue components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Vue组件
- en: Creating single-file Vue components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单文件Vue组件
- en: Registering global and local components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册全局和本地组件
- en: Writing basic and global mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基本和全局mixin
- en: Defining component names and using naming conventions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件名称并使用命名约定
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Understanding Vue components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vue组件
- en: 'We covered the `/components/` directory briefly in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt,* but we haven''t got hands-on with it yet. All we
    know so far is there is a `Logo.vue` component in this directory if you install
    your Nuxt project with the Nuxt scaffolding tool. All the components in this directory
    are **Vue components**, just like the page components in the `/pages/` directory.
    The main difference is that there is no `asyncData` method supported in these
    components in the `/components/` directory. Let''s take the `copyright.vue` component
    in `/chapter-4/nuxt-universal/sample-website/` as an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml)中简要介绍了`/components/`目录，*开始使用Nuxt*，但我们还没有亲自动手。到目前为止，我们知道如果使用Nuxt脚手架工具安装Nuxt项目，则该目录中有一个`Logo.vue`组件。该目录中的所有组件都是**Vue组件**，就像`/pages/`目录中的页面组件一样。主要区别在于`/components/`目录中的这些组件不支持`asyncData`方法。让我们以`/chapter-4/nuxt-universal/sample-website/`中的`copyright.vue`组件为例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s try replacing the `data` function in the preceding code with the `asyncData`
    function, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用`asyncData`函数替换前面代码中的`data`函数，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get a warning error stating Property or method "copyright" is not
    defined... on your browser''s console. So, how can we get the data for copyright
    purposes dynamically? We can request data using the `fetch` method in the component
    directly with an HTTP client (for example, `axios`), as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到警告错误，浏览器控制台上会显示“属性或方法“copyright”未定义...”。那么，我们如何动态获取版权目的的数据呢？我们可以使用`fetch`方法直接在组件中使用HTTP客户端（例如`axios`）请求数据，如下所示：
- en: 'Install the `axios` package via npm in the project directory:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中通过npm安装`axios`包：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import `axios` and request the data in the `fetch` method, as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`axios`并在`fetch`方法中请求数据，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method works fine, but it is not ideal to use an HTTP request to get a
    small piece of data from a payload, which is better off being requested once and
    then passing the pieces of data from a parent scope into its child components,
    like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以正常工作，但是最好不要使用HTTP请求从有效负载中获取少量数据，最好是请求一次，然后将数据从父作用域传递到其子组件中，如下所示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, the child component is the `copyright.vue` file in
    the `/components/` directory. The magic in this solution is just using the `props`
    property in the component. It's simpler and neater, thus making it an elegant
    solution! But if we are going to understand how it works and how we can use it,
    we need to understand Vue's component system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，子组件是“/components/”目录中的“copyright.vue”文件。这个解决方案的奥妙就在于在组件中使用“props”属性。这样更简单、更整洁，因此是一个优雅的解决方案！但是，如果我们要理解它是如何工作的，以及如何使用它，我们需要了解Vue的组件系统。
- en: What is a component?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是组件？
- en: 'Components are single, self-contained, and reusable **Vue instances** with
    a custom name. We define components by using the Vue `component` method. For example,
    if we want to define a component called `post-item`, we would do this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是单一的、自包含的、可重用的Vue实例，具有自定义名称。我们使用Vue的“component”方法来定义组件。例如，如果我们想定义一个名为“post-item”的组件，我们会这样做：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After doing this, we can use this component as `<post-item>` inside the HTML
    document when the root Vue instance is created with the `new` statement, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些之后，当使用“new”语句创建根Vue实例时，我们可以在HTML文档中将此组件用作“<post-item>”，如下所示：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All components are essentially Vue instances. This means they possess the same
    options (`data`, `computed`, `watch`, `methods`, and so on) as `new Vue`, except
    a few root-specific options such as `el`. Also, components can be nested inside
    other components and become tree-like components eventually. However, when this
    happens, passing data around them becomes tricky. So, fetching the data directly
    in the specific component using the `fetch` method might be more suitable for
    this situation. Alternatively, you can use Vuex store, which you will discover
    in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件本质上都是Vue实例。这意味着它们具有与“new Vue”相同的选项（“data”、“computed”、“watch”、“methods”等），只是少了一些根特定的选项，比如“el”。此外，组件可以嵌套在其他组件中，并最终成为类似树状的组件。然而，当这种情况发生时，传递数据变得棘手。因此，在特定组件中直接使用“fetch”方法获取数据可能更适合这种情况。或者，您可以使用Vuex存储，您将在[第10章](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml)中发现它，“添加Vuex存储”。
- en: However, we will put aside deeply nested components for a moment and focus on
    simple parent-child components in this chapter and learn how to pass data around
    them. Data can be passed either from the parent components to their children or
    from their children to the parents. But how can we do this? First, let's find
    out how we can pass data to the child components from their parents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将暂时搁置深度嵌套的组件，专注于本章中简单的父子组件，并学习如何在它们之间传递数据。数据可以从父组件传递到它们的子组件，也可以从子组件传递到父组件。但是我们如何做到这一点呢？首先，让我们找出如何从父组件向子组件传递数据。
- en: Passing data to child components with props
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用props将数据传递给子组件
- en: 'Let''s create a small Vue app by starting with a child component called `user-item`,
    as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为“user-item”的子组件来创建一个小型的Vue应用，如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see that it is just a static component and doesn''t do much; you can''t
    abstract or reuse it at all. It only becomes reusable if we can pass data into
    the template dynamically, inside the `template` property. This can be done with
    a `props` property. Let''s refactor the component, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它只是一个静态组件，没有太多功能；你根本无法抽象或重用它。只有在我们可以动态地将数据传递到模板内部的“template”属性中时，它才变得可重用。这可以通过“props”属性来实现。让我们对组件进行重构，如下所示：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In a sense, `props` behave like variables and we set the data for them with
    the `v-bind` directive, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，“props”的行为类似于变量，我们可以使用“v-bind”指令为它们设置数据，如下所示：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this refactored component, we use a `v-bind` directive to bind `item.name`
    to `name`, as in `v-bind:name`. The props inside the component must accept `name`
    as the property for this component. However, in a more complex app, it is likely
    we will need to pass more data, and writing multiple props for every piece of
    data can be counter-productive. So, let''s refactor the `<user-item>` component
    so that it accepts a single prop called `user` instead:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构的组件中，我们使用`v-bind`指令将`item.name`绑定到`name`，如`v-bind:name`。组件内的props必须接受`name`作为该组件的属性。然而，在一个更复杂的应用程序中，我们可能需要传递更多的数据，为每个数据写多个props可能会适得其反。因此，让我们重构`<user-item>`组件，使其接受一个名为`user`的单个prop：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we should refactor the component code once more, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次重构组件代码，如下所示：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s put what we''ve done here into a single page HTML so that you can see
    the bigger picture:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们在这里所做的事情放到一个单页HTML中，这样您就可以看到更大的图片：
- en: 'Include the following CDN link in the `<head>` block:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<head>`块中包含以下CDN链接：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the following markups in the `<body>` block:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<body>`块中创建以下标记：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code to the `<script>` block:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`<script>`块中：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we have broken down the app into smaller units: a child and
    a parent. However, they are bound through the `props` property. Now, we can further
    refine them without the fear of them interfering with each other.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将应用程序分解成了更小的单元：一个子组件和一个父组件。然而，它们通过`props`属性进行绑定。现在，我们可以进一步完善它们，而不用担心它们相互干扰。
- en: You can find this example code in `/chapter-5/vue/component/basic.html` in this
    book's GitHub repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/basic.html`中找到这个示例代码。
- en: However, in a real and complex app, we should divide this app into separate
    files (single-file components) that are more manageable. We will show you how
    to create them in the *Creating single-file Vue components* section. But for now,
    let's discover how we can pass the data up to the parent from the child component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一个真实而复杂的应用程序中，我们应该将这个应用程序分成更可管理的单独文件（单文件组件）。我们将在*创建单文件Vue组件*部分向您展示如何创建它们。但现在，让我们发现如何从子组件将数据传递给父组件。
- en: Listening to child component events
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听子组件事件
- en: 'So far, you''ve learned how to pass data down to child components from the
    parent using the `props` property. But what about passing data up to the parent
    from the child component? We can achieve this by using the `$emit` method with
    a custom event, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了如何使用`props`属性将数据传递给子组件。但是如何从子组件将数据传递给父组件呢？我们可以通过使用`$emit`方法和自定义事件来实现这一点，如下所示：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can choose any name for the custom event in the child component to be broadcasted.
    Then, the parent component can listen to this broadcasted event using the `v-on`
    directive and decide what to do next in this format:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择任何名称作为要在子组件中广播的自定义事件的名称。然后，父组件可以使用`v-on`指令来监听这个广播事件，并决定接下来要做什么。
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, if you are emitting a custom event called `done`, then the parent will
    be listing to this `done` event with the `v-on` directive as `v-on:done`, followed
    by an event handler. This event handler can be a plain JavaScript function, such
    as `v-on:done=handleDone`. Let''s create a simple app to demonstrate this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您正在发出一个名为`done`的自定义事件，那么父组件将使用`v-on:done`指令来监听这个`done`事件，然后是一个事件处理程序。这个事件处理程序可以是一个简单的JavaScript函数，比如`v-on:done=handleDone`。让我们创建一个简单的应用程序来演示这一点：
- en: 'Create the app''s markups, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序的标记，如下所示：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a child component, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子组件，如下所示：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a Vue root instance as the parent:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Vue根实例作为父级：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the child component will emit a `completed` event when the
    `clicked` method in it is triggered. Here, the parent receives the event via `v-on`
    and then triggers the `handleCompleted` method on its side.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`clicked`方法在子组件中触发时，子组件将发出一个`completed`事件。在这里，父组件通过`v-on`接收事件，然后在其端触发`handleCompleted`方法。
- en: You can find this example in `/chapter-5/vue/component/emit/emit-basic.html` in
    this book's GitHub repository.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/emit/emit-basic.html`中找到这个例子。
- en: Emitting a value with an event
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过事件发出值
- en: 'However, emitting just an event is not enough sometimes. In some cases, it''s
    more useful to emit the event with a value. We can do that by using the second
    parameter in the `$emit` method, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时仅仅发出一个事件是不够的。在某些情况下，使用带有值的事件更有用。我们可以通过在`$emit`方法中使用第二个参数来实现这一点，如下所示：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, when the parent is listening to the event, it can access the emitted
    event''s value with `$event` in this format:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当父组件监听事件时，可以以以下格式使用`$event`访问发出的事件的值：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the event handler is a method, then the value will be the first parameter
    for that method in this format:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件处理程序是一个方法，那么该值将是该方法的第一个参数，格式如下：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, now, we can simply modify the previous app, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们可以简单地修改前面的应用程序，如下所示：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can see that it is fun and easy to pass the data down or up between
    the parent and child components. But if you have an `<input>` element in your
    child component, how can you pass the value in the input field up to the parent
    in a two-way data binding? This isn't as hard as it seems if we understand what
    is going on "under" the two-way data binding in Vue. We'll learn about this in
    the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到在父组件和子组件之间传递数据是有趣且容易的。但是，如果您的子组件中有一个`<input>`元素，如何将输入字段中的值传递给父组件进行双向数据绑定呢？如果我们了解Vue中双向数据绑定的“底层”发生了什么，这并不难。我们将在下一节中学习这个知识点。
- en: You can find a simple example of this in `/chapter-5/vue/component/emit/value.html` and
    a more complex example in `/chapter-5/vue/component/emit/emit-value-with-props.html`,
    both of which can be found in this book's GitHub repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/emit/value.html`中找到这个简单的例子，以及在`/chapter-5/vue/component/emit/emit-value-with-props.html`中找到更复杂的例子。
- en: Creating custom input components with v-model
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用v-model创建自定义输入组件
- en: 'We also can use a component to create custom two-way binding inputs that work
    the same as a `v-model` directive for emitting events to the parent. Let''s create
    a basic custom input component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用组件创建自定义的双向绑定输入，其工作方式与`v-model`指令相同，用于向父组件发出事件。让我们创建一个基本的自定义输入组件：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How does it work? To understand this, we need to understand how `v-model` works
    under the hood. Let''s use a simple `v-model` input:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？要理解这一点，我们需要了解`v-model`在幕后是如何工作的。让我们使用一个简单的`v-model`输入：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding `<input>` element is shorthand for the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`<input>`元素是以下内容的简写：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, writing `v-model="newTodoText"` in our custom input is shorthand for the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的自定义输入中编写`v-model="newTodoText"`是以下内容的简写：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means the component underneath this shorthand must have the `value` attribute
    in the `props` property to let the data be passed down from the top. It must emit
    an `input` event with `$event.target.value` in order to pass the data up to the
    top.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个简写下面的组件必须在`props`属性中具有`value`属性，以便让数据从顶部传递下来。它必须发出一个带有`$event.target.value`的`input`事件，以便将数据传递到顶部。
- en: 'So, in this example, we emit the value when the user types in the `custom-input`
    child component, while the parent listens to the change via `v-model="newTodoText"`
    and updates the value of `newTodoText` in the `data` object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，当用户在`custom-input`子组件中输入时，我们发出值，而父组件通过`v-model="newTodoText"`监听更改，并更新`data`对象中`newTodoText`的值：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This makes perfect sense when you know the mechanism underneath the two-way
    data binding in Vue – the `v-model` directive – doesn't it? But what about the
    checkbox input and radio button elements, if you don't want to use their default
    values? In this situation, you'd want to send the custom ones to the parent component
    instead. We'll learn how to do this in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: You can find this simple example in `/chapter-5/vue/component/custom-inputs/basic.html`
    and a more complex example in `/chapter-5/vue/component/custom-inputs/props.html`,
    both of which can be found in this book's GitHub repository.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the model in custom input components
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the model in a custom input component uses the `value` property
    as the prop and `input` as the event. Using the `custom-input` component from
    our previous example, this can be written as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we don't need to specify the `prop` and `event` properties
    since they are the default behavior in this component's model. But this becomes
    useful when we don't want to use these defaults for some input types, such as
    checkboxes and radio buttons.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to use the `value` attribute in these inputs for a different purpose,
    such as sending a specific value along with the checkbox''s `name` to the server
    in the submitted data, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we want to send these two pieces of data to the server:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also do this in JSON format after performing serialization with `JSON.stringify`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, let''s say we don''t set the following custom model in this component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this case, we can only send the following default data to the server:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can find this example in `/chapter-5/vue/component/custom-inputs/checkbox.html` in
    this book's GitHub repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Again, it makes sense when you know what is underneath a Vue component as it
    can be customized with a bit of effort. The Vue components in the `/components/` directory
    work the same as the components you have just learned about. But before diving
    into writing the components for a Nuxt app, you should understand why the `key` attribute
    is important when using the `v-for` directive. Let's find out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the key attribute in v-for loops
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many of this book''s previous examples and exercises, you probably noticed
    a `key` attribute in all our `v-for` loops, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You may be wondering what it is and what it is for. The `key` attribute is
    a unique identity of each DOM node so that Vue can track their changes, and thus
    reuse and reorder existing elements. Tracking by the index is the default behavior
    of Vue to track nodes with `v-for`, so using `index` for the key attribute like
    so is redundant:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Hence, if we want Vue to track each item''s identity accurately, we must bind
    each key attribute with a unique value by using the `v-bind` directive, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use a shorthand `:key` to bind the unique value, as shown in the previous
    example. Also, bear in mind that `key` is a reserved attribute. This means it
    cannot be used as a component prop:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using `key` in the `props` property will result in the following error in the
    browser''s console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `key` attribute is always required when using `v-for` with a component.
    Thus, it is good practice to use `key` explicitly with `v-for` whenever possible,
    whether you're using it with a component or not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this issue, let''s create a Vue app where we''ll be using an `index` as
    our `key`, along with a little help from jQuery:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required CDN links in the `<head>` block, along with some CSS styles:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the required app HTML markup in the `<body>` block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the required component in the `<script>` block:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the required list of todo tasks, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we added a new todo task to the top of the list as a result
    of an `unshift` occurring on our `todos` array. We remove a todo task by adding
    a `removed` class name to the `li` element. Then, we use CSS to add a strike-through to
    the removed todo task and hide the Remove button.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove `Do the dishes`. You will see the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, add a new task called `Feed the cat`. You will see the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is because `Feed the cat` has now taken over the index of `Do the dishes`,
    which is 0\. Vue is just reusing the element instead of rendering a new one. In
    other words, whenever any changes are made to the items, Vue will just update
    the DOM elements according to their indexes in the array. This means we get an
    unintended outcome.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/component/key/using-index.html` in
    this book's GitHub repository. Run it on your browser to see the issue for yourself.
    Then, compare it with the one using `id` as a key in `/chapter-5/vue/component/key/using-id.html`.
    You will see that you get the correct behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue of using an index as a key can also be explained by the following
    pseudo-code, in which a list of numbers is being generated with `index` set as
    the key for each of them:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This looks great and works fine at first glance. But if you add number 4, the
    index information becomes useless. This is because each number now gets a new
    index:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see 1, 2, and 3 have lost their states and have to be rerendered.
    This is why using a unique key is required for cases like this. It is important
    for each item to keep its index number and not be reassigned on every change:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As a rule of thumb, whenever you manipulate a list in a way that results in
    a change of indexes, use a key so that Vue can update the DOM correctly afterward.
    These manipulations include the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item to an array, in any position other than the end of the array
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an item from an array, from any position other than the end of the
    array
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reordering the array in any way
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your list is never changed during the lifetime of your component, or you
    only append items with a push function instead of the `unshift` function, as in
    the previous example, it is fine to use indexes as keys. But if you try and keep
    track of where you need one and where you don't, you will eventually end up with
    "bugs" as you may misinterpret what Vue does.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure whether to use indexes as keys or not, then it probably better
    to use the `key` attribute with an immutable ID in the `v-for` loop. Using the `key` attribute
    with a unique value is not only important with the `v-for` directive but also
    in the `<input>` elements in an HTML form. We'll look at this in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Controlling reusable elements with key attributes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of providing better performance, we have discovered that Vue always reuses DOM
    nodes instead of rendering anew, and this can have some undesirable results, as
    demonstrated in the previous section. Here is another example without `v-for` to
    demonstrate why having the key attribute is rather important:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, if you type in the name of a fruit and switch the type, you
    will still see the name you just entered in the `vegetables` input field. This
    is because Vue is trying to reuse the same `<input>` element as best as it can
    to get the fastest result. But this isn''t always desirable. You can tell Vue not to
    reuse the same `<input>` element by adding the `key` attribute to each `<input>` element,
    along with a unique value, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, if you refresh the page and test it again, the input fields should now work
    as expected, without "reusing" each other when you toggle them. This doesn't count
    for the `<label>` elements because there is no `key` attribute in them. However,
    visually, this is not a problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example code in the `toggle-with-key.html` and `toggle-without-key.html` files
    inside the `/chapter-5/vue/component/key/` directory of this book's GitHub repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: That's all you need to know about the basic nature of the Vue component. So,
    by now, you should have enough essential knowledge to get started with the next
    level of creating Vue components by using single-file components. Let's get going!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more about Vue components and more in-depth parts of
    Vue components, such as slots, please visit [https://vuejs.org/v2/guide/components.html](https://vuejs.org/v2/guide/components.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating single-file Vue components
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been writing Vue apps using single HTML pages for quickness and getting
    the outcomes we wanted to see. But in a real development project in Vue or Nuxt,
    we wouldn''t want to write something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we have created two Vue components using JavaScript
    objects in one place (for example, in a single HTML page), but it is better to
    separate them and create each component in a separate `.js` file, like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This can work very well for a simple component, where the HTML layout is simple.
    However, in more complex layouts that involve more complicated HTML markups, we
    would want to avoid coding our HTML inside a JavaScript file. This issue can be
    solved by single-file components with a `.vue` extension, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: However, we can't just run that file on the browser without compiling it with
    build tools such as webpack or rollup. In this book, we're using webpack. This
    means that, from now on, we will no longer be using CDN or single HTML pages to
    create complex Vue apps. Instead, we will be using `.vue` and `.js` files with
    only one `.html` file to create our Vue apps. We will guide you through how to
    use webpack to help us to do that in the following section. Let's dive in.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Compiling single-file components with webpack
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile `.vue` components, we need to install `vue-loader` and `vue-template-compiler` into
    the webpack build process. But before that, we must create a `package.json` file in
    our project directory that lists the Node.js packages our project relies on. You
    can check the details of the `package.json` fields at [https://docs.npmjs.com/creating-a-package-json-file](https://docs.npmjs.com/creating-a-package-json-file).
    The most basic and required are the `name` and `version` fields. Let''s get started:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `package.json` file in your project directory with the following required
    fields and values:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open a terminal, change the directory to your project, and install `vue-loader` and `vue-template-compiler`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see a warning on your terminal since the Node.js packages you installed
    here require other Node.js packages, the most notable of which is the webpack
    package. In this book, we have set up a basic build process with webpack in `/chapter-5/vue/component-webpack/basic/`
    in this book''s GitHub repository. We will be using this setup for most of our
    upcoming Vue apps. We have separated the webpack configuration file into three
    smaller config files:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.common.js` contains common webpack plugins and configurations that
    are shared in the development and production process.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack.dev.js` contains plugins and configurations for the development process
    only.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack.prod.js` contains plugins and configurations for the production process
    only.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how we use these files in `script` commands, respectively:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that in this book, we are assuming that you already know how to use webpack
    to compile JavaScript modules in general. If you are new to webpack, please visit [https://webpack.js.org/](https://webpack.js.org/) for
    more information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after installing `vue-loader` and `vue-template-compiler`, we will need
    to configure `module.rules` in `webpack.common.js` (or `webpack.config.js`, if
    you are using a single config file), as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can then use the following commands we set in `package.json` to see our
    app in action:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm run start` for live reloading and development at `localhost:8080`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ npm run watch` for development at `/path/to/your/project/dist/`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ npm run build` for compiling our code at `/path/to/your/project/dist/`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it. You now have a basic build process to develop Vue apps with webpack.
    So, from now on, in more complex apps, we will be writing single-file components and
    using this method to compile them. We'll create a simple Vue app in the following
    section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Passing data and listening to events in single-file components
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have been using a single HTML page for our "todo" demonstrations.
    This time, we''ll use single-file components with a simple "todo" grocery list.
    Let''s begin:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.html` file with a `"todos"` ID in the `<div>` element for
    Vue to run the Vue instance:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a `/src/` directory in your project root and an `entry.js` file in it
    as the file entry point to indicate which modules webpack should use to start
    building out our app internal dependency graph. webpack will also use this file
    to figure out what other modules and libraries the entry point depends on (directly
    and indirectly):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a parent component that provides dummy data with a list of items in
    the `<script>` block:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we simply `import` the child component as a `TodoItem`
    and generate a list of them from the data in `groceryList` with `v-for`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following methods to the `methods` object in order to add and delete
    items. Then, add a method to the `computed` object that sums up the total cost
    of the items in the shopping cart:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a child component that displays the item being passed down from the
    parent via `props`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this component, we also have a `checkbox` button. This is used to emit the
    `delete-item` or `add-item` event and pass the item data up to the parent. Now,
    if you run the app with `$ npm run start`, you should see it load at `localhost:8080`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have managed to build a Vue app with single-file components using
    webpack, which is what Nuxt uses behind the scene to compile and build your Nuxt
    app. It is always useful to know what is running beneath an established system.
    When you know how to use webpack, you can use the webpack build setup that you
    just learned about for various JavaScript and CSS related projects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/component-webpack/todo/` in this
    book's GitHub repository.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll apply what we learned in the previous sections to
    the sample website in `/chapter-5/nuxt-universal/local-components/sample-website/`,
    which can be found in this book's GitHub repository.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Adding Vue components in Nuxt
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only two `.vue` files in the sample website that we can improve with
    Vue components: `/layouts/default.vue` and `/pages/work/index.vue`. First, we
    should improve `/layouts/default.vue`. There are only three things we need to
    improve in this file: the navigation, the social media links, and the copyright.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring n**avigation** and **social links**
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will begin by refactoring the navigation and social media links:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a navigation component in the `/components/` directory, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a social links component in the `/components/` directory as well, as
    follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Import them into the `<script>` block in the layout, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that you can skip this step if you have the `components` option set to
    `true` in your Nuxt config file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing navigation and social links blocks from the `<template>`
    block:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Replace them with the imported `Nav` and `Social` components, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: And with that, you're done!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the **copyright component**
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now refactor the copyright component that we already have in the `/components/` directory.
    Let''s get started:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `data` function from the `<script>` block in the `/components/base-copyright.vue`
    file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Replace the preceding `data` function with the `props` property, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the copyright data in the `<script>` block to `/layouts/default.vue` instead:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Remove the existing `<Copyright />` component in the `<template>` block:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add a new `<Copyright />` component with the copyright data bound to it:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With that, you should have managed to pass the data down to the components
    (the children) from the default page (the parent) where you kept your data. Well
    done! That''s it for `/layouts/default.vue`. We can also improve the work pages,
    which we have already done for you in `/chapter-5/nuxt-universal/local-components/sample-website/`,
    which can be found in this book''s GitHub repository. If you install this sample
    website and run it on your local machine, you will see that we have finally applied
    our components beautifully. With this, you can see how easy it is to abstract
    the elements in layouts so that they become components once you have understood
    how Vue component system works. But what about passing the data up to the parent
    components? For this, we have created an example app with child components emitting
    events to the parent components in `/chapter-5/nuxt-universal/local-components/emit-events/`,
    which can be found in this book''s GitHub repository. We have also added custom
    input and checkbox components to the app, so please check it out. The following
    is an example snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, you can see that the component code we used in the Nuxt app is the same
    as what we wrote in the Vue app. These kinds of components are nested components.
    The `props` property and the `$emit` method are used to pass the data up and down
    between the parent and the child components. These nested components also are
    local because they are only available in the scope of the component (parent) that
    imports them. So, from another perspective, Vue components can be categorized
    into local components and global components. You''ve been learning about global
    components ever since the *What is a component?* section. However, you''ve only
    learned how to use them in a Vue app. In the next section, we will look at how
    to register global components for Nuxt apps. But before jumping into that, let''s
    revisit Vue components from a holistic view: global components and local components.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Registering global and local components
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created many components either using `Vue.component()`, plain JavaScript
    objects, or single-file components engines. Some of the components we've created
    have been global components, while some of them have been local components. For
    example, all the refactored components you just created in the `/components/`
    directory in the previous section are local ones, while the components you created
    in the *What is a component? *section are global ones. Whether they are local
    or global components, they have to be registered if you want to use them. Some
    of them are registered at the time of their creation, while some of them are registered
    manually. In the following sections, you will learn how to register them globally
    and locally. You will also learn about the two types of registration that will
    affect your app. We will be looking at registering Vue components, instead of
    passing around them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Registering global components in Vue
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Global components, just as their name suggests, are available globally throughout
    your application. They are globally registered when you create them using `Vue.component()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Global components must be registered before the instantiation of the root Vue
    instance. After they''ve been registered, they can be used in the template of
    the root Vue instance, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, you can see that it is very easy to register global components – you might
    not even realize the registration process while creating them. We will look into
    this type of registration for Nuxt shortly in the *Registering global components
    in Nuxt *section. But now, we'll learn how to register local components.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Registering local components in Vue/Nuxt
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen and used local components in the Vue and Nuxt apps in this chapter.
    These components are created by using plain JavaScript objects, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, they can be registered through the `components` option, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Remember the Vue app we created at the beginning of the *Passing data to child
    components with props* section, in the `/chapter-5/vue/component/basic.html` file
    in this book''s GitHub repository? The `user-item` component in that app is a
    global component. Now, let''s refactor it and turn it into a local component:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following global component:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Replace it with a local component, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Register the local component using the `components` options:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The app will work the same way as it did previously. The only difference is
    that `user-item` is no longer available globally. This means it is not available
    in any other sub-components. For instance, if you want to make `ComponentX` available
    in `ComponentZ`, then you have to "attach" it manually:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you are writing ES2015 modules using babel and webpack, you can make `ComponentX` a
    single-file component and then import it, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You also can omit `component-x` from the `components` option and use the `ComponentX`
    variable directly inside it, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using variables such as `ComponentX` in a JavaScript object in ES2015+ is short
    form for `ComponentX: ComponentX`. Since `component-x` is never registered, so
    instead of using the component as `<component-x>`, you will need to use `<ComponentX>`
    in the template instead:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Writing ES2015 in the preceding single-file component is the same as how we
    write `.vue` files in Nuxt. So by now, you should have realized that we have been
    writing local components in our Nuxt apps, such as `/components/copyright.vue`
    and `/components/nav.vue`. But how do we write global components in Nuxt apps?
    That's where the `/plugins/` directory comes in. In the next section, you'll learn
    how to do this in Nuxt.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding app in `/chapter-5/vue/component/registering-local-components.html`,
    in this book's GitHub repository.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Registering global components in Nuxt
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned about the directory structure in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*, and that the `/plugins/` directory is where we can
    create JavaScript files that we want to run before instantiating the root Vue
    app. Hence, this is the best place to register our global components.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first global component:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple Vue component in the `/plugins/` directory, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a `.js` file in the `/plugins/` directory and import the preceding component,
    as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can also create a second global component directly in `/plugins/global-components.js`,
    like this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Tell Nuxt to run them first before instantiating the root app in the Nuxt config
    file, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that this component will be available on both the client and server sides
    of your Nuxt app. If you want to run this component on a specific side only, such
    as only on the client-side, then you can register it, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, this component will only be available on the client-side. But if you just
    want to run it on the server side, simply use `server` in the preceding `mode`
    option.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these global components anywhere we like without having to import
    them again manually, as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run the app on your browser. You should get the following output:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: That's it! This is how you can register global components in Nuxt by involving
    various files. The bottom line of global registration is using `Vue.component`,
    just like we do in the Vue app. However, global registration is not often ideal,
    just like its "cousin", global mixins, which we will cover in the next section.
    For instance, globally registering components but not needing them in most cases
    can be unnecessary for both server and client sides. Now, let's move on and take
    a look at what mixins are and how to write them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/nuxt-universal/global-components/` in
    this book's GitHub repository.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic and global mixins
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mixin is just a JavaScript object that can be used to contain any component
    option, such as `created`, `methods`, `mounted`, and so on. They can be used to
    make these options reusable. We can do this by importing them into a component
    and "mixing" them with the other options in that component.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Using mixins can be useful in some situations, such as in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*. We know that when Vue Loader compiles the `<template>`
    blocks in single-file components, it converts any encountered asset URLs into
    webpack module requests, like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding image will be converted into the following JavaScript code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This isn''t difficult if you insert the image manually. But in most cases,
    we''ll want to insert images dynamically, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In this example, you will get a 404 error for the image on your console because
    Vue Loader never compiles it when it is used with a `:src` directive, and so webpack
    never compiles the image in the build process. To resolve this problem, we need
    to insert the module request into the `:sr` directive manually:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'However, this is no good either because a dynamic image solution is preferred.
    So, the solution here is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this solution, we write a reusable `loadAssetImage` function so that it can
    be called in any Vue component where it is needed. Hence, mixins are what we need
    in this situation. There are a few ways of using mixins. We'll have a look at
    some common ways in the following sections.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic mixins/non-global mixins
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a non-single-file component Vue app, we can we define a mixin object like
    so:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, we can "attach" it to a component using `Vue.extend()`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this example, we only attached this mixin to `Foo`, so you will only see
    that `console.log` message when this component is called.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/mixins/basic.html` in this book's
    GitHub repository.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'For Nuxt apps, we create and keep the mixin object in the `/plugins/` directory,
    in a `.js` file. Let''s demonstrate this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `mixin-basic.js` file in the `/plugins/` directory with a function
    that prints a message on the browser console when the Vue instance is created:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Import it whenever and wherever we need it, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In this example, you will only get the `console.log` message when you are on
    the `/about` route. This is how we create and use a non-global mixin. But in some
    cases, we need global mixins for all the components in our app. Let's take a look
    at how we can do that.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/nuxt-universal/mixins/basic/` in this
    book's GitHub repository.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Creating global mixins
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create and apply a mixin globally by using `Vue.mixin()`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Global mixins must be defined before you instantiate the Vue instance:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, every component you create will be affected and show that message. You
    can find this example in `/chapter-5/vue/mixins/global.html` in this book''s GitHub
    repository. If you run it on your browser, you will see the `console.log` message
    appear on every route as it spreads across all the route components. In this way,
    we can see the potential harm that could be done if it''s misused. In Nuxt, we
    create global mixins in the same way; that is, by using `Vue.mixin()`. Let''s
    take a look:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `mixin-utils.js` file in the `/plugins/` directory, along with the
    function for loading images from the `/assets/` directory:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Include the preceding global mixin path in the Nuxt config file:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, you can use the `loadAssetImage` function anywhere you like in your component,
    as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note that we don't need to import global mixins like we import basic mixins
    because we already injected them globally through `nuxt.config.js`. But again,
    use them sparsely and carefully.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: You can find this mixin example in `/chapter-5/nuxt-universal/mixins/global/` in
    this book's GitHub repository.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Mixins are useful. Global mixins such as global Vue components are hard to manage
    when there are too many of them, thus making your app hard to predict and debug.
    So, use them wisely and sparsely. We hope that you now know how Vue components
    work and how to write them. However, knowing how they work and how to write them
    is not enough – we should know about the standard rules we need to comply with
    when writing them for readability and future manageability. Therefore, before
    we end this chapter, we will look at some of these rules.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Defining component names and using naming conventions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen and created many components in this and the previous chapters.
    The more components we make, the more we need to follow naming conventions for
    our components. Otherwise, we will inevitably get confused and come across errors,
    bikeshedding, and anti-patterns. Our components will inevitably conflict with
    each other – even with the HTML elements. Luckily, there is an official Vue style
    guide that we can comply with to improve our app's readability. In this section,
    we'll go through a few that are specific to this book.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Multi-word component names
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our existing and future HTML elements are single words (for example, `article`,
    `main`, `body`, and so on), so to prevent conflicts from occurring, we should
    use multi-words when naming our components (except for the root app components).
    For example, the following is considered bad practice:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The component''s name should be written as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Component data
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should always use the `data` function instead of the `data` property for
    our component data, except in the root Vue instance. For example, this is considered
    bad practice:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The data in the preceding components should be written as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: But why? This is because when Vue initiates data, it creates a reference of
    `data` from `vm.$options.data`. So, if the data is an object and when there are
    many instances of a component, they will all use the same `data`. Changing the
    data in an instance will affect the other instances. This is not what we want.
    So, if `data` is a function, Vue will use a `getData` method to return a new object
    that only belongs to the current instance that you are initializing. Hence, the
    data in the root instance is shared across all the other components' instances,
    which contain their own data. You can access the root data from any component's
    instance by using `this.$root.$data`. You can check out some examples in `/chapter-5/vue/component-webpack/data/` and
    `/chapter-5/vue/data/basic.html`, both of which can be found in this book's GitHub
    repository.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the Vue source code on how data is initiated at [https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Prop definitions
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should define properties in the `props` property so that they''re as detailed
    as possible by specifying their types (at a minimum). It is only okay to not have
    detailed definitions when you''re prototyping. For example, this is considered
    bad practice:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This should be written as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Or, even better, it should be written as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Component files
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should always comply with the one file one component "policy"; that is,
    writing only one component in one file. This means that you should not have more
    than one component in a file. For example, this is considered bad practice:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'They should be split into multiple files, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This should be done as follows if you are writing the components in `.vue`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Single-file component filename casing
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should only use PascalCase or kebab-case for the filenames for single-file
    components. For example, these are considered bad practice:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'They should be written as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Self-closing components
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should use the self-closing format when there''s no content in our single-file
    components, unless they are used in a DOM template. For example, these are considered
    bad practice:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'They should be written as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: These are only a few essential rules. There are more, such as rules for writing multi-attribute
    elements, directive shorthands, quoted attribute values, and so on. But the selected
    rules that we've highlighted here should be enough for you to complete this book.
    You can find the other rules and the full style guide at [https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! In this chapter, you learned about the differences between global
    and local Vue components, how to register global components in Nuxt apps, and
    how to create local and global mixins. You also learned how to pass data to child
    components from the parent component using the `props` property, how to emit data
    to the parent from the child component using the `$emit` method, and how to create
    custom input components. You then learned the importance of using the `key` attribute
    for components. After that, you learned how to write single-file components with
    webpack. Last but not least, you were introduced to some rules that should be
    followed in Nuxt and Vue app development.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore the use of the `/plugins/` directory
    further for extending a Nuxt app by writing custom plugins in Vue and importing
    them. We'll also look at importing external Vue plugins from the Vue community,
    creating global functions by injecting them into Nuxt's `$root` and `context` components,
    writing basic/async modules and module snippets, and using external Nuxt modules
    from the Nuxt community. We will guide you through these thoroughly, so stay tuned!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
