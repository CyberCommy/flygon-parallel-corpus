- en: Adding Vue Components
  prefs: []
  type: TYPE_NORMAL
- en: As we stated in the previous chapter, Vue components are an **optional part**
    of the Nuxt view. You've already learned about various constituents of the Nuxt
    view: app template, HTML head, layout, and page.However, we haven't covered the
    smallest unit in Nuxt -** the Vue component**. So, in this chapter, you will learn
    how it works and how to make use of `/components/` for creating custom components. You
    will then learn how to create global and local components, as well as basic and
    global mixins, and get to know some of the naming conventions for developing Vue
    or Nuxt apps. Most excitingly, you will discover how to pass data down from a parent
    component to a child component, as well as emit data up to the parent from the
    child.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating single-file Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering global and local components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing basic and global mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining component names and using naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vue components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered the `/components/` directory briefly in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt,* but we haven''t got hands-on with it yet. All we
    know so far is there is a `Logo.vue` component in this directory if you install
    your Nuxt project with the Nuxt scaffolding tool. All the components in this directory
    are **Vue components**, just like the page components in the `/pages/` directory.
    The main difference is that there is no `asyncData` method supported in these
    components in the `/components/` directory. Let''s take the `copyright.vue` component
    in `/chapter-4/nuxt-universal/sample-website/` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try replacing the `data` function in the preceding code with the `asyncData`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a warning error stating Property or method "copyright" is not
    defined... on your browser''s console. So, how can we get the data for copyright
    purposes dynamically? We can request data using the `fetch` method in the component
    directly with an HTTP client (for example, `axios`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `axios` package via npm in the project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `axios` and request the data in the `fetch` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This method works fine, but it is not ideal to use an HTTP request to get a
    small piece of data from a payload, which is better off being requested once and
    then passing the pieces of data from a parent scope into its child components,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the child component is the `copyright.vue` file in
    the `/components/` directory. The magic in this solution is just using the `props`
    property in the component. It's simpler and neater, thus making it an elegant
    solution! But if we are going to understand how it works and how we can use it,
    we need to understand Vue's component system.
  prefs: []
  type: TYPE_NORMAL
- en: What is a component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Components are single, self-contained, and reusable **Vue instances** with
    a custom name. We define components by using the Vue `component` method. For example,
    if we want to define a component called `post-item`, we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, we can use this component as `<post-item>` inside the HTML
    document when the root Vue instance is created with the `new` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All components are essentially Vue instances. This means they possess the same
    options (`data`, `computed`, `watch`, `methods`, and so on) as `new Vue`, except
    a few root-specific options such as `el`. Also, components can be nested inside
    other components and become tree-like components eventually. However, when this
    happens, passing data around them becomes tricky. So, fetching the data directly
    in the specific component using the `fetch` method might be more suitable for
    this situation. Alternatively, you can use Vuex store, which you will discover
    in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will put aside deeply nested components for a moment and focus on
    simple parent-child components in this chapter and learn how to pass data around
    them. Data can be passed either from the parent components to their children or
    from their children to the parents. But how can we do this? First, let's find
    out how we can pass data to the child components from their parents.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to child components with props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a small Vue app by starting with a child component called `user-item`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that it is just a static component and doesn''t do much; you can''t
    abstract or reuse it at all. It only becomes reusable if we can pass data into
    the template dynamically, inside the `template` property. This can be done with
    a `props` property. Let''s refactor the component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In a sense, `props` behave like variables and we set the data for them with
    the `v-bind` directive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this refactored component, we use a `v-bind` directive to bind `item.name`
    to `name`, as in `v-bind:name`. The props inside the component must accept `name`
    as the property for this component. However, in a more complex app, it is likely
    we will need to pass more data, and writing multiple props for every piece of
    data can be counter-productive. So, let''s refactor the `<user-item>` component
    so that it accepts a single prop called `user` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should refactor the component code once more, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put what we''ve done here into a single page HTML so that you can see
    the bigger picture:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following CDN link in the `<head>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following markups in the `<body>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `<script>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have broken down the app into smaller units: a child and
    a parent. However, they are bound through the `props` property. Now, we can further
    refine them without the fear of them interfering with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example code in `/chapter-5/vue/component/basic.html` in this
    book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a real and complex app, we should divide this app into separate
    files (single-file components) that are more manageable. We will show you how
    to create them in the *Creating single-file Vue components* section. But for now,
    let's discover how we can pass the data up to the parent from the child component.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to child component events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, you''ve learned how to pass data down to child components from the
    parent using the `props` property. But what about passing data up to the parent
    from the child component? We can achieve this by using the `$emit` method with
    a custom event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can choose any name for the custom event in the child component to be broadcasted.
    Then, the parent component can listen to this broadcasted event using the `v-on`
    directive and decide what to do next in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you are emitting a custom event called `done`, then the parent will
    be listing to this `done` event with the `v-on` directive as `v-on:done`, followed
    by an event handler. This event handler can be a plain JavaScript function, such
    as `v-on:done=handleDone`. Let''s create a simple app to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the app''s markups, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a child component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Vue root instance as the parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the child component will emit a `completed` event when the
    `clicked` method in it is triggered. Here, the parent receives the event via `v-on`
    and then triggers the `handleCompleted` method on its side.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/component/emit/emit-basic.html` in
    this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting a value with an event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, emitting just an event is not enough sometimes. In some cases, it''s
    more useful to emit the event with a value. We can do that by using the second
    parameter in the `$emit` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when the parent is listening to the event, it can access the emitted
    event''s value with `$event` in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the event handler is a method, then the value will be the first parameter
    for that method in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, we can simply modify the previous app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that it is fun and easy to pass the data down or up between
    the parent and child components. But if you have an `<input>` element in your
    child component, how can you pass the value in the input field up to the parent
    in a two-way data binding? This isn't as hard as it seems if we understand what
    is going on "under" the two-way data binding in Vue. We'll learn about this in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a simple example of this in `/chapter-5/vue/component/emit/value.html` and
    a more complex example in `/chapter-5/vue/component/emit/emit-value-with-props.html`,
    both of which can be found in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom input components with v-model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also can use a component to create custom two-way binding inputs that work
    the same as a `v-model` directive for emitting events to the parent. Let''s create
    a basic custom input component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'How does it work? To understand this, we need to understand how `v-model` works
    under the hood. Let''s use a simple `v-model` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `<input>` element is shorthand for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So, writing `v-model="newTodoText"` in our custom input is shorthand for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means the component underneath this shorthand must have the `value` attribute
    in the `props` property to let the data be passed down from the top. It must emit
    an `input` event with `$event.target.value` in order to pass the data up to the
    top.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this example, we emit the value when the user types in the `custom-input`
    child component, while the parent listens to the change via `v-model="newTodoText"`
    and updates the value of `newTodoText` in the `data` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This makes perfect sense when you know the mechanism underneath the two-way
    data binding in Vue – the `v-model` directive – doesn't it? But what about the
    checkbox input and radio button elements, if you don't want to use their default
    values? In this situation, you'd want to send the custom ones to the parent component
    instead. We'll learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this simple example in `/chapter-5/vue/component/custom-inputs/basic.html`
    and a more complex example in `/chapter-5/vue/component/custom-inputs/props.html`,
    both of which can be found in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the model in custom input components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the model in a custom input component uses the `value` property
    as the prop and `input` as the event. Using the `custom-input` component from
    our previous example, this can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we don't need to specify the `prop` and `event` properties
    since they are the default behavior in this component's model. But this becomes
    useful when we don't want to use these defaults for some input types, such as
    checkboxes and radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to use the `value` attribute in these inputs for a different purpose,
    such as sending a specific value along with the checkbox''s `name` to the server
    in the submitted data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we want to send these two pieces of data to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do this in JSON format after performing serialization with `JSON.stringify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s say we don''t set the following custom model in this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can only send the following default data to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can find this example in `/chapter-5/vue/component/custom-inputs/checkbox.html` in
    this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it makes sense when you know what is underneath a Vue component as it
    can be customized with a bit of effort. The Vue components in the `/components/` directory
    work the same as the components you have just learned about. But before diving
    into writing the components for a Nuxt app, you should understand why the `key` attribute
    is important when using the `v-for` directive. Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the key attribute in v-for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many of this book''s previous examples and exercises, you probably noticed
    a `key` attribute in all our `v-for` loops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be wondering what it is and what it is for. The `key` attribute is
    a unique identity of each DOM node so that Vue can track their changes, and thus
    reuse and reorder existing elements. Tracking by the index is the default behavior
    of Vue to track nodes with `v-for`, so using `index` for the key attribute like
    so is redundant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, if we want Vue to track each item''s identity accurately, we must bind
    each key attribute with a unique value by using the `v-bind` directive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a shorthand `:key` to bind the unique value, as shown in the previous
    example. Also, bear in mind that `key` is a reserved attribute. This means it
    cannot be used as a component prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `key` in the `props` property will result in the following error in the
    browser''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `key` attribute is always required when using `v-for` with a component.
    Thus, it is good practice to use `key` explicitly with `v-for` whenever possible,
    whether you're using it with a component or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this issue, let''s create a Vue app where we''ll be using an `index` as
    our `key`, along with a little help from jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required CDN links in the `<head>` block, along with some CSS styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the required app HTML markup in the `<body>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the required component in the `<script>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the required list of todo tasks, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we added a new todo task to the top of the list as a result
    of an `unshift` occurring on our `todos` array. We remove a todo task by adding
    a `removed` class name to the `li` element. Then, we use CSS to add a strike-through to
    the removed todo task and hide the Remove button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove `Do the dishes`. You will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a new task called `Feed the cat`. You will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is because `Feed the cat` has now taken over the index of `Do the dishes`,
    which is 0\. Vue is just reusing the element instead of rendering a new one. In
    other words, whenever any changes are made to the items, Vue will just update
    the DOM elements according to their indexes in the array. This means we get an
    unintended outcome.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/component/key/using-index.html` in
    this book's GitHub repository. Run it on your browser to see the issue for yourself.
    Then, compare it with the one using `id` as a key in `/chapter-5/vue/component/key/using-id.html`.
    You will see that you get the correct behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue of using an index as a key can also be explained by the following
    pseudo-code, in which a list of numbers is being generated with `index` set as
    the key for each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks great and works fine at first glance. But if you add number 4, the
    index information becomes useless. This is because each number now gets a new
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see 1, 2, and 3 have lost their states and have to be rerendered.
    This is why using a unique key is required for cases like this. It is important
    for each item to keep its index number and not be reassigned on every change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As a rule of thumb, whenever you manipulate a list in a way that results in
    a change of indexes, use a key so that Vue can update the DOM correctly afterward.
    These manipulations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item to an array, in any position other than the end of the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an item from an array, from any position other than the end of the
    array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reordering the array in any way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your list is never changed during the lifetime of your component, or you
    only append items with a push function instead of the `unshift` function, as in
    the previous example, it is fine to use indexes as keys. But if you try and keep
    track of where you need one and where you don't, you will eventually end up with
    "bugs" as you may misinterpret what Vue does.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure whether to use indexes as keys or not, then it probably better
    to use the `key` attribute with an immutable ID in the `v-for` loop. Using the `key` attribute
    with a unique value is not only important with the `v-for` directive but also
    in the `<input>` elements in an HTML form. We'll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling reusable elements with key attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of providing better performance, we have discovered that Vue always reuses DOM
    nodes instead of rendering anew, and this can have some undesirable results, as
    demonstrated in the previous section. Here is another example without `v-for` to
    demonstrate why having the key attribute is rather important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, if you type in the name of a fruit and switch the type, you
    will still see the name you just entered in the `vegetables` input field. This
    is because Vue is trying to reuse the same `<input>` element as best as it can
    to get the fastest result. But this isn''t always desirable. You can tell Vue not to
    reuse the same `<input>` element by adding the `key` attribute to each `<input>` element,
    along with a unique value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So, if you refresh the page and test it again, the input fields should now work
    as expected, without "reusing" each other when you toggle them. This doesn't count
    for the `<label>` elements because there is no `key` attribute in them. However,
    visually, this is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example code in the `toggle-with-key.html` and `toggle-without-key.html` files
    inside the `/chapter-5/vue/component/key/` directory of this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: That's all you need to know about the basic nature of the Vue component. So,
    by now, you should have enough essential knowledge to get started with the next
    level of creating Vue components by using single-file components. Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more about Vue components and more in-depth parts of
    Vue components, such as slots, please visit [https://vuejs.org/v2/guide/components.html](https://vuejs.org/v2/guide/components.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating single-file Vue components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been writing Vue apps using single HTML pages for quickness and getting
    the outcomes we wanted to see. But in a real development project in Vue or Nuxt,
    we wouldn''t want to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created two Vue components using JavaScript
    objects in one place (for example, in a single HTML page), but it is better to
    separate them and create each component in a separate `.js` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This can work very well for a simple component, where the HTML layout is simple.
    However, in more complex layouts that involve more complicated HTML markups, we
    would want to avoid coding our HTML inside a JavaScript file. This issue can be
    solved by single-file components with a `.vue` extension, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: However, we can't just run that file on the browser without compiling it with
    build tools such as webpack or rollup. In this book, we're using webpack. This
    means that, from now on, we will no longer be using CDN or single HTML pages to
    create complex Vue apps. Instead, we will be using `.vue` and `.js` files with
    only one `.html` file to create our Vue apps. We will guide you through how to
    use webpack to help us to do that in the following section. Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling single-file components with webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile `.vue` components, we need to install `vue-loader` and `vue-template-compiler` into
    the webpack build process. But before that, we must create a `package.json` file in
    our project directory that lists the Node.js packages our project relies on. You
    can check the details of the `package.json` fields at [https://docs.npmjs.com/creating-a-package-json-file](https://docs.npmjs.com/creating-a-package-json-file).
    The most basic and required are the `name` and `version` fields. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `package.json` file in your project directory with the following required
    fields and values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a terminal, change the directory to your project, and install `vue-loader` and `vue-template-compiler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a warning on your terminal since the Node.js packages you installed
    here require other Node.js packages, the most notable of which is the webpack
    package. In this book, we have set up a basic build process with webpack in `/chapter-5/vue/component-webpack/basic/`
    in this book''s GitHub repository. We will be using this setup for most of our
    upcoming Vue apps. We have separated the webpack configuration file into three
    smaller config files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.common.js` contains common webpack plugins and configurations that
    are shared in the development and production process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack.dev.js` contains plugins and configurations for the development process
    only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack.prod.js` contains plugins and configurations for the production process
    only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how we use these files in `script` commands, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this book, we are assuming that you already know how to use webpack
    to compile JavaScript modules in general. If you are new to webpack, please visit [https://webpack.js.org/](https://webpack.js.org/) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after installing `vue-loader` and `vue-template-compiler`, we will need
    to configure `module.rules` in `webpack.common.js` (or `webpack.config.js`, if
    you are using a single config file), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the following commands we set in `package.json` to see our
    app in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm run start` for live reloading and development at `localhost:8080`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ npm run watch` for development at `/path/to/your/project/dist/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ npm run build` for compiling our code at `/path/to/your/project/dist/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it. You now have a basic build process to develop Vue apps with webpack.
    So, from now on, in more complex apps, we will be writing single-file components and
    using this method to compile them. We'll create a simple Vue app in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data and listening to events in single-file components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have been using a single HTML page for our "todo" demonstrations.
    This time, we''ll use single-file components with a simple "todo" grocery list.
    Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.html` file with a `"todos"` ID in the `<div>` element for
    Vue to run the Vue instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `/src/` directory in your project root and an `entry.js` file in it
    as the file entry point to indicate which modules webpack should use to start
    building out our app internal dependency graph. webpack will also use this file
    to figure out what other modules and libraries the entry point depends on (directly
    and indirectly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a parent component that provides dummy data with a list of items in
    the `<script>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we simply `import` the child component as a `TodoItem`
    and generate a list of them from the data in `groceryList` with `v-for`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following methods to the `methods` object in order to add and delete
    items. Then, add a method to the `computed` object that sums up the total cost
    of the items in the shopping cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a child component that displays the item being passed down from the
    parent via `props`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this component, we also have a `checkbox` button. This is used to emit the
    `delete-item` or `add-item` event and pass the item data up to the parent. Now,
    if you run the app with `$ npm run start`, you should see it load at `localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have managed to build a Vue app with single-file components using
    webpack, which is what Nuxt uses behind the scene to compile and build your Nuxt
    app. It is always useful to know what is running beneath an established system.
    When you know how to use webpack, you can use the webpack build setup that you
    just learned about for various JavaScript and CSS related projects.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/component-webpack/todo/` in this
    book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll apply what we learned in the previous sections to
    the sample website in `/chapter-5/nuxt-universal/local-components/sample-website/`,
    which can be found in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Vue components in Nuxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only two `.vue` files in the sample website that we can improve with
    Vue components: `/layouts/default.vue` and `/pages/work/index.vue`. First, we
    should improve `/layouts/default.vue`. There are only three things we need to
    improve in this file: the navigation, the social media links, and the copyright.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring n**avigation** and **social links**
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will begin by refactoring the navigation and social media links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a navigation component in the `/components/` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a social links component in the `/components/` directory as well, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Import them into the `<script>` block in the layout, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can skip this step if you have the `components` option set to
    `true` in your Nuxt config file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing navigation and social links blocks from the `<template>`
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace them with the imported `Nav` and `Social` components, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: And with that, you're done!
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the **copyright component**
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now refactor the copyright component that we already have in the `/components/` directory.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `data` function from the `<script>` block in the `/components/base-copyright.vue`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding `data` function with the `props` property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the copyright data in the `<script>` block to `/layouts/default.vue` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the existing `<Copyright />` component in the `<template>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `<Copyright />` component with the copyright data bound to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, you should have managed to pass the data down to the components
    (the children) from the default page (the parent) where you kept your data. Well
    done! That''s it for `/layouts/default.vue`. We can also improve the work pages,
    which we have already done for you in `/chapter-5/nuxt-universal/local-components/sample-website/`,
    which can be found in this book''s GitHub repository. If you install this sample
    website and run it on your local machine, you will see that we have finally applied
    our components beautifully. With this, you can see how easy it is to abstract
    the elements in layouts so that they become components once you have understood
    how Vue component system works. But what about passing the data up to the parent
    components? For this, we have created an example app with child components emitting
    events to the parent components in `/chapter-5/nuxt-universal/local-components/emit-events/`,
    which can be found in this book''s GitHub repository. We have also added custom
    input and checkbox components to the app, so please check it out. The following
    is an example snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that the component code we used in the Nuxt app is the same
    as what we wrote in the Vue app. These kinds of components are nested components.
    The `props` property and the `$emit` method are used to pass the data up and down
    between the parent and the child components. These nested components also are
    local because they are only available in the scope of the component (parent) that
    imports them. So, from another perspective, Vue components can be categorized
    into local components and global components. You''ve been learning about global
    components ever since the *What is a component?* section. However, you''ve only
    learned how to use them in a Vue app. In the next section, we will look at how
    to register global components for Nuxt apps. But before jumping into that, let''s
    revisit Vue components from a holistic view: global components and local components.'
  prefs: []
  type: TYPE_NORMAL
- en: Registering global and local components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created many components either using `Vue.component()`, plain JavaScript
    objects, or single-file components engines. Some of the components we've created
    have been global components, while some of them have been local components. For
    example, all the refactored components you just created in the `/components/`
    directory in the previous section are local ones, while the components you created
    in the *What is a component? *section are global ones. Whether they are local
    or global components, they have to be registered if you want to use them. Some
    of them are registered at the time of their creation, while some of them are registered
    manually. In the following sections, you will learn how to register them globally
    and locally. You will also learn about the two types of registration that will
    affect your app. We will be looking at registering Vue components, instead of
    passing around them.
  prefs: []
  type: TYPE_NORMAL
- en: Registering global components in Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Global components, just as their name suggests, are available globally throughout
    your application. They are globally registered when you create them using `Vue.component()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Global components must be registered before the instantiation of the root Vue
    instance. After they''ve been registered, they can be used in the template of
    the root Vue instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that it is very easy to register global components – you might
    not even realize the registration process while creating them. We will look into
    this type of registration for Nuxt shortly in the *Registering global components
    in Nuxt *section. But now, we'll learn how to register local components.
  prefs: []
  type: TYPE_NORMAL
- en: Registering local components in Vue/Nuxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen and used local components in the Vue and Nuxt apps in this chapter.
    These components are created by using plain JavaScript objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, they can be registered through the `components` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the Vue app we created at the beginning of the *Passing data to child
    components with props* section, in the `/chapter-5/vue/component/basic.html` file
    in this book''s GitHub repository? The `user-item` component in that app is a
    global component. Now, let''s refactor it and turn it into a local component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following global component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with a local component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the local component using the `components` options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The app will work the same way as it did previously. The only difference is
    that `user-item` is no longer available globally. This means it is not available
    in any other sub-components. For instance, if you want to make `ComponentX` available
    in `ComponentZ`, then you have to "attach" it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are writing ES2015 modules using babel and webpack, you can make `ComponentX` a
    single-file component and then import it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can omit `component-x` from the `components` option and use the `ComponentX`
    variable directly inside it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Using variables such as `ComponentX` in a JavaScript object in ES2015+ is short
    form for `ComponentX: ComponentX`. Since `component-x` is never registered, so
    instead of using the component as `<component-x>`, you will need to use `<ComponentX>`
    in the template instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Writing ES2015 in the preceding single-file component is the same as how we
    write `.vue` files in Nuxt. So by now, you should have realized that we have been
    writing local components in our Nuxt apps, such as `/components/copyright.vue`
    and `/components/nav.vue`. But how do we write global components in Nuxt apps?
    That's where the `/plugins/` directory comes in. In the next section, you'll learn
    how to do this in Nuxt.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding app in `/chapter-5/vue/component/registering-local-components.html`,
    in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Registering global components in Nuxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned about the directory structure in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*, and that the `/plugins/` directory is where we can
    create JavaScript files that we want to run before instantiating the root Vue
    app. Hence, this is the best place to register our global components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first global component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple Vue component in the `/plugins/` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `.js` file in the `/plugins/` directory and import the preceding component,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a second global component directly in `/plugins/global-components.js`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Tell Nuxt to run them first before instantiating the root app in the Nuxt config
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this component will be available on both the client and server sides
    of your Nuxt app. If you want to run this component on a specific side only, such
    as only on the client-side, then you can register it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now, this component will only be available on the client-side. But if you just
    want to run it on the server side, simply use `server` in the preceding `mode`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these global components anywhere we like without having to import
    them again manually, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app on your browser. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: That's it! This is how you can register global components in Nuxt by involving
    various files. The bottom line of global registration is using `Vue.component`,
    just like we do in the Vue app. However, global registration is not often ideal,
    just like its "cousin", global mixins, which we will cover in the next section.
    For instance, globally registering components but not needing them in most cases
    can be unnecessary for both server and client sides. Now, let's move on and take
    a look at what mixins are and how to write them.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/nuxt-universal/global-components/` in
    this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic and global mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mixin is just a JavaScript object that can be used to contain any component
    option, such as `created`, `methods`, `mounted`, and so on. They can be used to
    make these options reusable. We can do this by importing them into a component
    and "mixing" them with the other options in that component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using mixins can be useful in some situations, such as in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*. We know that when Vue Loader compiles the `<template>`
    blocks in single-file components, it converts any encountered asset URLs into
    webpack module requests, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding image will be converted into the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t difficult if you insert the image manually. But in most cases,
    we''ll want to insert images dynamically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, you will get a 404 error for the image on your console because
    Vue Loader never compiles it when it is used with a `:src` directive, and so webpack
    never compiles the image in the build process. To resolve this problem, we need
    to insert the module request into the `:sr` directive manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is no good either because a dynamic image solution is preferred.
    So, the solution here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In this solution, we write a reusable `loadAssetImage` function so that it can
    be called in any Vue component where it is needed. Hence, mixins are what we need
    in this situation. There are a few ways of using mixins. We'll have a look at
    some common ways in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic mixins/non-global mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a non-single-file component Vue app, we can we define a mixin object like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can "attach" it to a component using `Vue.extend()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we only attached this mixin to `Foo`, so you will only see
    that `console.log` message when this component is called.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/vue/mixins/basic.html` in this book's
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Nuxt apps, we create and keep the mixin object in the `/plugins/` directory,
    in a `.js` file. Let''s demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `mixin-basic.js` file in the `/plugins/` directory with a function
    that prints a message on the browser console when the Vue instance is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Import it whenever and wherever we need it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you will only get the `console.log` message when you are on
    the `/about` route. This is how we create and use a non-global mixin. But in some
    cases, we need global mixins for all the components in our app. Let's take a look
    at how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in `/chapter-5/nuxt-universal/mixins/basic/` in this
    book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating global mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create and apply a mixin globally by using `Vue.mixin()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Global mixins must be defined before you instantiate the Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every component you create will be affected and show that message. You
    can find this example in `/chapter-5/vue/mixins/global.html` in this book''s GitHub
    repository. If you run it on your browser, you will see the `console.log` message
    appear on every route as it spreads across all the route components. In this way,
    we can see the potential harm that could be done if it''s misused. In Nuxt, we
    create global mixins in the same way; that is, by using `Vue.mixin()`. Let''s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `mixin-utils.js` file in the `/plugins/` directory, along with the
    function for loading images from the `/assets/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the preceding global mixin path in the Nuxt config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the `loadAssetImage` function anywhere you like in your component,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need to import global mixins like we import basic mixins
    because we already injected them globally through `nuxt.config.js`. But again,
    use them sparsely and carefully.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this mixin example in `/chapter-5/nuxt-universal/mixins/global/` in
    this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins are useful. Global mixins such as global Vue components are hard to manage
    when there are too many of them, thus making your app hard to predict and debug.
    So, use them wisely and sparsely. We hope that you now know how Vue components
    work and how to write them. However, knowing how they work and how to write them
    is not enough – we should know about the standard rules we need to comply with
    when writing them for readability and future manageability. Therefore, before
    we end this chapter, we will look at some of these rules.
  prefs: []
  type: TYPE_NORMAL
- en: Defining component names and using naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen and created many components in this and the previous chapters.
    The more components we make, the more we need to follow naming conventions for
    our components. Otherwise, we will inevitably get confused and come across errors,
    bikeshedding, and anti-patterns. Our components will inevitably conflict with
    each other – even with the HTML elements. Luckily, there is an official Vue style
    guide that we can comply with to improve our app's readability. In this section,
    we'll go through a few that are specific to this book.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-word component names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our existing and future HTML elements are single words (for example, `article`,
    `main`, `body`, and so on), so to prevent conflicts from occurring, we should
    use multi-words when naming our components (except for the root app components).
    For example, the following is considered bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The component''s name should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Component data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should always use the `data` function instead of the `data` property for
    our component data, except in the root Vue instance. For example, this is considered
    bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The data in the preceding components should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: But why? This is because when Vue initiates data, it creates a reference of
    `data` from `vm.$options.data`. So, if the data is an object and when there are
    many instances of a component, they will all use the same `data`. Changing the
    data in an instance will affect the other instances. This is not what we want.
    So, if `data` is a function, Vue will use a `getData` method to return a new object
    that only belongs to the current instance that you are initializing. Hence, the
    data in the root instance is shared across all the other components' instances,
    which contain their own data. You can access the root data from any component's
    instance by using `this.$root.$data`. You can check out some examples in `/chapter-5/vue/component-webpack/data/` and
    `/chapter-5/vue/data/basic.html`, both of which can be found in this book's GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the Vue source code on how data is initiated at [https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112).
  prefs: []
  type: TYPE_NORMAL
- en: Prop definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should define properties in the `props` property so that they''re as detailed
    as possible by specifying their types (at a minimum). It is only okay to not have
    detailed definitions when you''re prototyping. For example, this is considered
    bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, even better, it should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Component files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should always comply with the one file one component "policy"; that is,
    writing only one component in one file. This means that you should not have more
    than one component in a file. For example, this is considered bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'They should be split into multiple files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be done as follows if you are writing the components in `.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Single-file component filename casing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should only use PascalCase or kebab-case for the filenames for single-file
    components. For example, these are considered bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'They should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Self-closing components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should use the self-closing format when there''s no content in our single-file
    components, unless they are used in a DOM template. For example, these are considered
    bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'They should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: These are only a few essential rules. There are more, such as rules for writing multi-attribute
    elements, directive shorthands, quoted attribute values, and so on. But the selected
    rules that we've highlighted here should be enough for you to complete this book.
    You can find the other rules and the full style guide at [https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! In this chapter, you learned about the differences between global
    and local Vue components, how to register global components in Nuxt apps, and
    how to create local and global mixins. You also learned how to pass data to child
    components from the parent component using the `props` property, how to emit data
    to the parent from the child component using the `$emit` method, and how to create
    custom input components. You then learned the importance of using the `key` attribute
    for components. After that, you learned how to write single-file components with
    webpack. Last but not least, you were introduced to some rules that should be
    followed in Nuxt and Vue app development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore the use of the `/plugins/` directory
    further for extending a Nuxt app by writing custom plugins in Vue and importing
    them. We'll also look at importing external Vue plugins from the Vue community,
    creating global functions by injecting them into Nuxt's `$root` and `context` components,
    writing basic/async modules and module snippets, and using external Nuxt modules
    from the Nuxt community. We will guide you through these thoroughly, so stay tuned!
  prefs: []
  type: TYPE_NORMAL
