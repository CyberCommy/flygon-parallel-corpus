- en: '*Chapter 11*: Using Computational Thinking and Python in Simple Challenges'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look again at the computational thinking process
    and apply it to design algorithms that help us solve various scenarios and problems.
    As we wrap up *Section 2*, *Applying Python and Computational Thinking*, of this
    book, we will combine some of the knowledge about Python capabilities with the
    computational thinking process to solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing the problem and using Python functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing the problem and planning Python algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and testing the algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to design algorithms that best
    fit the scenarios presented. You will also be able to identify Python functions
    that best align with the problems presented and generalize your solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to install the latest version of Python to run the code in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code used in this chapter can be found in the GitHub repository
    here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to dive into our first scenario. You are launching a campaign
    for a product you''ve designed. You''re looking for investments that add up to
    $100,000 in pledges. You want to create an algorithm that saves information on
    the pledges made for you, while also providing information about the products
    each pledge provides. There are some things you need to identify before you write
    an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*How many types of pledges will you run in your campaign?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Will there be a donation-only pledge?* *Do donations get anything at all,
    such as a sticker, electronic certificate, or other product swag?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What will each of the pledges give the person pledging?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these questions will help us plan. But we also have to take into account
    other things, such as what we need from the algorithm. *Is it simply to list the
    number of pledges or will it also be used to check against an inventory or to
    create that inventory?* *Will it count down from a set number of pledges available
    for each level? Will it automatically update every time someone makes a pledge?*
  prefs: []
  type: TYPE_NORMAL
- en: As you know, when we are presented with a problem, it is critical that we identify
    what the problem really is. We need to set our parameters for the problem in order
    to provide a solution. In this section, we're going to want to answer a lot of
    these questions first. In order to do that, we need to decompose the problem and
    identify which functionalities in Python would help us solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing the problem and using Python functionalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create an algorithm that is used to design those pledges. We'd be designing
    an algorithm that tells us how many items we need of each type based on a set
    number of pledges.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have three tiers of pledges and a donation-only pledge.
    For the highest tier, let''s call that **Tier 1**, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Double the item you are selling at a 20% discount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accessories bundle for the item, which includes four items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A carrying case for the item and accessories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 1-year membership for the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The middle tier, or **Tier 2**, gets you the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: The item you are selling at a 20% discount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A carrying case for the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 6-month membership for the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The lowest tier, or **Tier 3**, gets you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The item you are selling at a 20% discount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A carrying case for the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's say we want an algorithm that will give us the number of items we'd need
    depending on how many pledges we allow for each tier. The **fourth tier**, which
    is donation only, would not affect our algorithm, since this algorithm would be
    used simply to determine how many of each item we'd need depending on the number
    of pledges.
  prefs: []
  type: TYPE_NORMAL
- en: But things aren't as simple as just the numbers. Let's say that you need $100,000
    in pledges, as mentioned earlier in this chapter. Then you'd need to figure out
    how much you'd charge for the tiers and put a price point on them. You'd need
    to make enough pledges available to at least reach that goal of $100,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have identified the retail price of your item as $800\. Here are the costs
    for each of the items:'
  prefs: []
  type: TYPE_NORMAL
- en: $640 for the item itself (given a 20% discount, and only applicable to Tiers
    1, 2, and 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $100 in accessories (Tier 1 only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $40 carrying case (applicable to Tiers 1, 2, and 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Membership costs will be passed at $10 a month (let's say the original cost
    is $35 a month)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Tier 1, the pledge would need to be a minimum of $1,540:'
  prefs: []
  type: TYPE_NORMAL
- en: 640 × 2 = 1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 × 10 = 120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1280 + 120 + 100 + 40 = 1540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Tier 2, the pledge would need to be a minimum of $740:'
  prefs: []
  type: TYPE_NORMAL
- en: 640 + 40 = 680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 × 10 = 60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 680 + 60 = 740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Tier 3, the pledge would need to be a minimum of $680, that is, 640 + 40
    = 680.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to figure out how many of each tier would be available for purchase.
    But first, let''s round out some of these numbers: Tier 1 will be $1,600, Tier
    2 will be $800, and Tier 3 will be $700.'
  prefs: []
  type: TYPE_NORMAL
- en: We can write an algorithm to let us know how many pledges we need for each tier.
    But before we do, let's talk about Python and the functionalities that we could
    use. We can create the Tier-3 pledge first, making it a parent group. Then we
    can create two child classes, Tiers 1 and 2, that have slightly different characteristics
    and costs. The question we ask ourselves is whether we need to be that detailed
    on the algorithm or can we just add each tier's cost/value.
  prefs: []
  type: TYPE_NORMAL
- en: That's a good question. And the answer is that it depends on what you need this
    algorithm for. If you're looking to do the early yet simple calculations and need
    an algorithm you can run every so often based on current sales/pledges, then you
    can create something simple with a dictionary or a function. But if you want to
    use the algorithm for multiple purposes or need to be able to adjust some costs
    later on, then you may want to code that into the algorithm with all the details.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why would you need that?* Take some of the successful campaigns available.
    Oftentimes, the original pledges sell out for those campaigns. New pledge tiers
    then become available and you may want to adjust the price point of those tiers.
    For example, rather than a 20% discount on the item, the pledge may be for a 15%
    discount. Other changes may happen, such as selling swag instead of the accessories
    due to inventory limitations and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The more detailed your algorithm is, the more you can do with it in the long
    run. But if you do not need all that information, then you may not want to spend
    as much time creating the algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to work on this algorithm. Take a look at the snippet shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ch11_pledgesA.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at some of the things we used in the preceding snippet. We
    had to import the `math` module so we could use the `math.ceil()` math function.
    We used this function in order to round the number of Tier-1 pledges needed up.
    That's because if we rounded down, we would not be able to cover the desired percentage.
    By doing this, we are finding the smallest integer we'll need to cover the percentage.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we used the `%s` placeholders in our `print` statement to call
    our strings, then stated the strings to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run that program, this is what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our `print` statement uses the percentage entered by the user,
    in part to ensure that the information matches what was expected. For 45% of the
    funding to come from Tier-1 pledges, we''d need to sell at least 29 Tier-1 pledges.
    If we run the math just to verify that this is correct, we see that this information
    is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Formula_B15413_11_001.jpg)![](image/Formula_B15413_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if we sell 29 Tier-1 pledges, we'll make slightly more than
    45% of 100,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s say that you also want the algorithm to tell you how many items
    you need based on the number of Tier-1 pledges. Let''s take a look at the adjusted
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch11_pledgesB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I only added one more `print` statement. There are pros and cons
    to using this algorithm in this way. In this case, I'm only outputting the numbers
    for each of the tiers. I'm not saving how many items I need anywhere in the algorithm.
    If we want to do that for future reference, we'll need to adjust how we get that
    information and how we save it in the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this algorithm, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we got the information we wanted. We'll need `58` `items`, `29`
    `accessories kits`, `29` `carrying` `cases`, and `29` `year-long` `memberships`.
    Again, this would be helpful if we were doing a one-off thing or if we didn't
    expect any changes. But let's be clear, that's almost never the case. We'll want
    to make changes. We'll also need to know information based on Tier-2 and Tier-3
    selections. *So what can we do?*
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll want to save our numbers. So, we''ll need to add some variables
    for the items, the accessories kits, the carrying cases, and two variables for
    the memberships, one for the year-long and one for the 6-month-long memberships.
    We''ll also need to make a decision about how we want the rest of the pledges
    broken up. *Do we want the other percentage equally split between Tiers 2 and
    3?* *Do we want one-third of what''s left to be Tier 2 and two-thirds to be Tier
    3?* Let''s go with those numbers. Here''s where we stand now:'
  prefs: []
  type: TYPE_NORMAL
- en: The Tier-1 percentage is chosen by the user as the program is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tier-2 percentage will be one-third of the remaining percentage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tier 3 will be two-thirds of the remaining percentage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s teach this to the algorithm. The following file contains the full, uninterrupted
    code. We added some text to explain certain sections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ch11_pledgesC.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the following snippet we are adding some variables, such as `totalTier1`,
    `itemsTier1`, `accTier1`, and `cases1`. These variables will help us save the
    numbers of each tier ordered. We''ll do the same for Tiers 2 and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While we haven''t printed the details yet for the number of total items or
    the total cases, we now have them saved into variables. This is what our output
    looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We should note that we exceed our funding goal because we've always been rounding
    up. That is, rather than using $1,540 for Tier 1, we used $1,600\. For the percentage,
    we've been rounding up. All of these will add up to give us a total above $100,000\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the algorithm a little more. The following is only the new snippet
    from the algorithm we''ve already seen, which contains the total for the items
    we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can now call those variables we added in our `print` function
    to get the counts we need for our inventory. We would not be able to get those
    details if we had not defined those items in our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that in our previous snippet, some of the items have the exact same
    value. However, we still defined them with different variables. Take a look, for
    example, at `cases2 = totalTier2` and `sixMemb = totalTier2`. Although both have
    the same values, we want to identify them separately. And maybe that's not important
    now, but later on, maybe we'll run out of cases. Then we'd only want to change
    the value for the cases and not the 6-month memberships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since they''re already split, we can change one without affecting the other.
    Let''s take a look at what the output looks like for the new `print` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this, you may realize that you only get one carrying case but two
    items in Tier 1, which is why there's a different count for those. The accessories
    and year-long memberships only happen in Tier 1, so it makes sense that those
    two numbers are the same. The 6-month memberships are only for Tier 2, so that
    number matches the number of Tier-2 pledges.
  prefs: []
  type: TYPE_NORMAL
- en: As we consider this problem further, we may realize that we may want to save
    information differently. Maybe rather than asking the user for the percentage
    of Tier-1 pledges they want, we could ask how many total items they have and then
    break down the tiers based on that. All of that is possible, so how we define
    the problem is critical. How we save the information or request input from the
    user is also just as important. Decomposing a problem is just part of the process
    of creating and designing the algorithms we need.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to address problems with multiple solutions
    depending on our goals. As we define our problems, we are often also identifying
    the variables we'll need and determining what kinds of functions are most useful
    depending on what we'll want to get out of the algorithm. Unless we have a very
    simple and straightforward problem, the decomposition and definition of the problem
    are critical in order to successfully define an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at generalizing the problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing the problem and planning Python algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we were working with an algorithm designed for use
    in a funding campaign. The algorithm we looked at was problem-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try to generalize this problem and understand how we could potentially
    design a different algorithm. *Why would we need that?* Think of it as a template.
    If you run multiple funding campaigns for start-ups, you may want to create a
    general algorithm that you can then adapt based on the needs of each campaign
    rather than having to start each campaign over.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would need to set up some clear parameters and make some decisions. In
    order to keep this scenario manageable for the book''s purposes, we''re going
    to limit our choices a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: Every campaign will have between 3 and 5 tiers of pledges, not including donation-only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every tier will ask for the items needed for each tier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each tier option will have a set percentage built in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are three tiers, Tier 1 will be 50% of pledges, Tier 2 will be 30%,
    and Tier 3 will be 20%. If there are four tiers, Tier 1 will be 40% of pledges,
    Tier 2 will be 30%, Tier 3 will be 20%, and Tier 4 will be 10%. If there are five
    tiers, Tier 1 will be 40% of pledges, Tier 2 will be 30%, Tier 3 will be 15%,
    Tier 4 will be 10%, and Tier 5 will be 5%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram, which shows the breakdown of the tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Tier percentage breakdown'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.1_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Tier percentage breakdown
  prefs: []
  type: TYPE_NORMAL
- en: Because we are using one algorithm for many possible scenarios, we'll break
    down that algorithm piece by piece. The full algorithm can be found in the `ch11_pledgesTemplate.py`
    file on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first snippet, we ask for the initial input, then save our percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are three conditions after we ask for input. Notice that
    we converted the input to an integer. This is important, otherwise the conditions
    will run but the `else` condition will also run.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet won't give us any output except for asking for that input.
    So, we'll show more output after our next snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of comments in this code. Because of the length of the code,
    we'll be using comments in order to find spots in our code where we need to edit
    it. It is always a good idea to use comments in all code, but especially in lengthy
    code. Otherwise, finding the particular lines we want to change can be very tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the number of tiers, we''ll need to know the number of items in
    each tier. We''ll need to ask how many items are chosen for each tier. Let''s
    take a look at the continuation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're only showing the conditions for when the tiers are 3 or 4\.
    The code file will also have the information for the 5 tiers, but it follows what
    is shown in the preceding code. Notice that the algorithm asks for input for each
    of the tiers. This will be important when we need to work with numbers and percentages.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can include an `else` statement that allows us to ask the questions
    again if there is an error in the input. You can add these kinds of conditions
    to the existing template if you wish. For now, we're going to continue with the
    next pieces of information we'll need to get from the user, such as the price
    point for each tier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s think back to what we could need. We''ll need price points for each
    tier, which will also be the input requests for a template kind of algorithm.
    Since each of those will be different for each campaign, we''ll need to leave
    that up to the user to enter. The input lines will look very similar to the previously
    shown snippets. Here is what it looks like for 3 tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, notice that we're using comments to separate each section of the code.
    As you can see, we are adding information about how much we are charging for each
    pledge level. The code then continues to do this for the number of tiers, 3, 4,
    or 5.
  prefs: []
  type: TYPE_NORMAL
- en: As was previously discussed, you may also want to test for errors or provide
    an alternative to continue running the code after an error is added by the user.
    We are not addressing those errors in this code but they can certainly be added
    to improve the user experience with this algorithm. As you can see, we've started
    working on how to generalize this algorithm for multiple scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're generalizing for multiple uses. But we've used a lot of
    algorithms and seen a lot of scenarios in this book where the generalization of
    the patterns is much simpler. Generalization can be something as simple as writing
    an equation with one variable. Or it can be creating an algorithm for a number
    of circumstances and conditions. That's why it's important to identify what our
    problem is and what exactly we want to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how and when to get input from the user. We also
    worked through defining variables in order to store the input and use it in our
    equations for the algorithm to output the necessary information.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the algorithm, we'll go to the next section, which is focused on
    the design and testing of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and testing the algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we got a lot of input from the user because we were
    creating an algorithm that was used as a template for many campaigns. Now we need
    to use that input in a variety of ways. Here''s what we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of tiers of pledges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The percentage breakdown of the tiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of items for each tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of each tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can do something with all that information. First, let's talk about what
    we could want. We could want to test how much we'd make selling a specific quantity
    of the tiers. We could also break down how many of each tier we'd need based on
    a funding goal, much as we did in the first part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*What would be most helpful?* Well, that really depends on what you need. I''m
    going to say that I want the breakdown based on the funding goal. I want to know
    how many of each pledge type I will need to make available. So now I have to figure
    out how I''m going to get that information from the variables I''ve already defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to have three conditions here as well. And because the variable
    and how many there are of each variable differs per tier type, we''ll need to
    make sure we''re accounting for that information. Let''s think about three tiers
    first. Given the funding goal, here are some of the outputs that can be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of each tier of pledges to be made available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of items per tier that will need to be in inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*So how do we figure that out?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we had $50,000 as our funding goal and let''s assume that the
    Tier-1 cost is $500\. Then, we can take the following steps to find the number
    of Tier-1 pledges needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiply the funding goal by the percentage, that is, 50,000 × 0.50 = 25,000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide the resulting number by the cost of the pledge, that is, 25,000 ÷ 500
    = 50.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That means that we'll need to post 50 pledges for Tier 1\. Now let's assume
    that the user entered that there were `3` items in Tier 1\. Then, this means 50
    × 3 = 150 items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see that in our code. Remember, this is the same file as the previous
    snippets (`ch11_pledgesTemplate.py`). We''re continuing with the discussion using
    pieces of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we have a `print` function with the number of pledges
    for each tier, but they''re also saved as functions in our conditional statement.
    Notice that we''ll now have some output here. We''ll get the number of pledges
    we''ll need from this snippet, but not the number of items per tier. We''ll add
    that shortly. For now, here''s what that output looks like when we run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we now know that we need to list 50 Tier-1 pledges at $500,
    38 Tier-2 pledges at $400, and 29 Tier-3 pledges at $350 to reach our funding
    goal. Now we have to figure out how many items we need for each tier given the
    number of items per tier provided. Here''s what that code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, now we have another three math equations and a `print` statement
    that breaks down the information for us. We'll get the number of pledges for each
    tier as well as the number of items we'll need for each of the tiers. If you wanted
    even more information from this template, you could include pieces from the first
    example in this chapter, where we broke down the types of items per pledge. We'll
    leave that up to you as a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, here''s what our final output would look like for three tiers and
    a funding goal of $50,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we not only have the information we needed, but we also have
    variables set up to use if we need to adapt this information. Thinking back to
    previous chapters and notes that we've been discussing, let's try to determine
    how else we could now save the information.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that comes to mind is that we could create a dictionary that
    stores the information for us. If we did that, then we could recall the information
    we needed from that dictionary, such as the number of items for one tier, for
    example. We could also adjust the key-value pairs if we needed to without having
    to enter the entire thing all over again. Say our initial cost for Tier 1 was
    $500 but we now need it to be $600, yet the other tiers wouldn't change. Then
    we could just adjust that one value.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario would allow you to explore many of the functionalities of the
    Python programming language we've discussed. Take some time to study the code,
    then make some adjustments and try to use some of your knowledge to improve upon
    it based on different conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we are always given problem situations that can be interpreted in
    different ways. It is up to us to write algorithms that meet our needs and the
    needs of our clients. Sometimes, we'll get clarification from our stakeholders
    directly. Other times, we'll have to ask for that clarification and/or make some
    of the assumptions ourselves. What is critical is that we design the algorithms
    and document our progress so that we can adjust, adapt, and change pieces of our
    work without having to start over if we don't get what we need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over the computational thinking process one more time
    by working through a more complex scenario and interpretations of that scenario.
    We learned how to decompose the problem provided, then identify the patterns,
    generalize them, and design the algorithms. We used some of what we've learned
    throughout the book to write an algorithm that provided the information we needed.
  prefs: []
  type: TYPE_NORMAL
- en: The computational thinking process helps us develop skills that make our algorithm
    planning much easier. By walking through that process, we learn more about what
    Python capabilities and functions may help us in particular scenarios. We also
    learned how to generalize patterns, sometimes in simple equations for a problem,
    but other times in creating algorithms that can help us in multiple scenarios
    without having to recreate them each time. As we got to learn more about Python,
    we got more comfortable with the computational thinking process in this last chapter
    of *Section 2*, *Applying Python and Computational Thinking*.
  prefs: []
  type: TYPE_NORMAL
- en: In *Section 3*, *Data Processing, Analysis, and Applications Using Computational
    Thinking and Python*, we will move on to other capabilities of Python in order
    to deal with data processing, analysis, and applications using computational thinking
    elements. In the next chapter, we'll start to look at data and how we can use
    Python to analyze data, create visual representations, and write algorithms that
    work with experimental data.
  prefs: []
  type: TYPE_NORMAL
