- en: Chapter 6. Marshalling and Object-XML Mapping (OXM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling with JAXB2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marshalling with XMLBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marshalling with JiBX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marshalling with XStream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marshalling with MooseXML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom marshaller using XPath for conditional XML parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Object/XML Mapping (OXM) terminology, marshalling (serializing) converts
    the object representation of data into the XML format and unmarshalling converts
    XML into the corresponding object.
  prefs: []
  type: TYPE_NORMAL
- en: Spring's OXM simplifies OXM operations by using rich aspects of the Spring framework.
    For example, the dependency injection feature can be used to instantiate different
    OXM technologies into objects to use them, and Spring can use annotations to map
    a class or a class's field to XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring-WS benefits from Spring''s OXM for converting a Payload message into
    objects or vice versa. For example, set JAXB as the OXM framework using the following
    configuration in the application context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition, marshalling frameworks could be changed by changing the `marshaller`
    bean in the configuration file, while keeping the implementation of Web-Services
    unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: There are many implementations of marshalling frameworks available. JAXB (Java
    Architecture for XML Binding), JiBX, XMLBeans, Castor, and so on are examples.
    For some of the OXM frameworks, tools are provided to convert schema into POJO
    classes and generate mapping data within these classes, or in a separate external
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides recipes to illustrate the usage of different frameworks
    for Object/XML mapping.
  prefs: []
  type: TYPE_NORMAL
- en: For simplification, most of the recipes in this chapter use projects used in
    the *Integration testing using Spring-JUnit support* recipe, discussed in [Chapter
    3](ch03.html "Chapter 3. Testing and Monitoring Web-Services"), *Testing and Monitoring
    Web-Services*, to set up a server and send and receive messages by client. However,
    in the recipe *Marshalling with XStream*, projects from the *Creating Web-Service
    client for WS-Addressing endpoint* recipe, discussed in [Chapter 2](ch02.html
    "Chapter 2. Building Clients for SOAP Web-Services"), *Building Clients for SOAP
    Web-Services*, are used for the server and client sides.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling with JAXB2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Architecture for XML Binding ([http://jaxb.java.net/tutorial/](http://jaxb.java.net/tutorial/))
    is an API that allows developers to bind Java objects to XML representations.
    JAXB implementation is a part of the project Metro ([http://metro.java.net/](http://metro.java.net/)),
    which is a high-performance, extensible, and easy-to-use Web-Service stack. The
    main functionality of JAXB is to marshall Java objects into XML equivalents and
    unmarshall them back to the Java object (which can be called Object/XML binding
    or marshalling) as needed. JAXB is particularly useful when the specification
    is complex and changing.
  prefs: []
  type: TYPE_NORMAL
- en: JAXB provides many extensions and tools that make the Object/XML binding an
    easy job. Its annotation support allows developers to mark the O/X binding within
    the existing classes in order to generate the XML at runtime. Its Maven tool plugin
    `(maven-jaxb2-plugin)` enables the generation of Java classes from a given XML
    Schema file.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe illustrates how to set up a marshalling end point and build a client
    program using JAXB2 as the marshalling library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contains a server `(LiveRestaurant_R-6.1)` and a client `(LiveRestaurant_R-6.1-Client)`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.1` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.1-Client` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe uses `maven-jaxb2-plugin` to generate classes from a schema.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register the JAXB marshaller inside the server/client-side configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `maven-jaxb2-plugin` inside server/client-side POM files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the server and run the client (it also generates classes from a schema):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Client project-root: `mvn clean package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server project-root: `mvn clean package tomcat:run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the client-side output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main player in this marshalling business is `GenericMarshallingMethodEndpointAdapter`,
    which utilizes a marshaller to perform the Object/XML marshalling process. The
    marshaller used here is `org.springframework.oxm.jaxb.Jaxb2Marshaller`, which
    performs O/X marshalling, utilizing the JAXB2 framework. If you examine the Java
    classes generated by the Maven plugin tool, you can see the JAXB annotations such
    as `@XmlType, @XmlRootElement, @XmlElement`, and so on. These annotations are
    the instructions to the JAXB engine that determines the structure of the XML to
    be generated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The following section in the POM files generates JAXB classes from the schema
    `(OrderService.xsd)` in the folder `src\main\webapp\WEB-INF` (set by `schemaDirectory)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GeneratePackage` set the package includes the generated classes and `generateDirectory`
    set the folder host `generatedPackage:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderServiceEndPoint`, which is annotated as an `@Endpoint`, maps the Web-Service
    request, with a payload-root, `placeOrderRequest`, to the method `getOrder`, recognizing
    the annotation `@PayloadRoot`. While the marshaller marshalls the incoming XML
    into an instance of `PlaceOrderRequest`, the method `getOrder` returns `PlaceOrderResponse`.
    The same thing happens to the method `cancelOrder:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following section in `spring-ws-servlet.xml` in the server sets the marshaller
    in the endpoint (OrderServiceEndpoint) to `Jaxb2Marshaller`. The setting `contextPath`
    in the `marshaller` bean registers all beans included in the package `com.packtpub.liverestaurant.domain`
    to be marshalled/unmarshalled by `Jaxb2Marshaller:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The same things happen in the client. The only difference is that the marshaller
    is set for `WebServiceTemplate:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `MessageDispatcherServlet`, with the help of the `Jaxb2Marshaller`, detects
    the O/X mapping annotations as well as the reflection and delegates the final
    marshalling process to the JAXB framework.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling with XMLBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XMLBeans ([http://xmlbeans.apache.org/](http://xmlbeans.apache.org/)) is a technology
    for accessing XML by binding it to Java types. The library comes from the Apache
    Foundation and is a part of the Apache XML project. Known for its Java-friendliness,
    XMLBeans allows the developers to take advantage of the richness and features
    of XML and XML Schema and have these features mapped as naturally as possible
    to the equivalent Java language and typing constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two major features that make XMLBeans unique from other XML-Java binding options
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full XML Schema support:** XMLBeans fully supports (built-in) XML Schema
    and the corresponding Java classes provide constructs for all of the major functionality
    of XML Schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full XML infoset fidelity:** While unmarshalling XML data, the full XML infoset
    is available to the developer. The XMLBeans provides many extensions and tools
    that make the Object/XML binding an easy job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contains a server (`LiveRestaurant_R-6.2`) and a client (`LiveRestaurant_R-6.2-Client`)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.2` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlbeans-2.4.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.2-Client` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlbeans-2.4.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe uses `xmlbeans-maven-plugin` to generate classes and bind files
    from a schema.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register the XMLBean marshaller inside the server/client-side configuration
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `xmlbeans-maven-plugin` inside the server/client-side POM files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the server and run the client (it also generates classes from a schema):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server project-root: `mvn clean package tomcat:run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client project-root: `mvn clean package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the client-side output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe works exactly the same way as the first one, *Marshalling with JAXB2*,
    except that it is using a different marshaller, `XMLBeansMarshaller`. The scomp
    (Schema Compiler) tool used here generates the Java XMLBeans classes from the
    XML schema `(OrderService.xsd)`. Besides the domain classes, it generates the
    classes representing the document root element, for example, `CancelOrderRequestDocument`.
    All the generated classes contain the `Factory` methods to instantiate them.
  prefs: []
  type: TYPE_NORMAL
- en: As can be noticed easily, the two main differences in the code are in `OrderServiceEndPoint`
    and `spring-ws-servlet.xml`. Unlike that of the previous recipe, the method `getOrder`
    returns an instance of `OrderResponseDocument` and it accepts `OrderRequestDocument`
    as an input argument. The same description is true about the method `cancelOrderDoc:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The marshaller used in `spring-ws-servlet.xml` is the `XMLBeansMarshaller`,
    which marshalls and unmarshalls between XML and Java using the XMLBeans library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The contract between the `@Endpoint` class and `XMLBeansMarshaller` is that
    the `@PayloadRoot` methods should accept and return instances of `org.apache.xmlbeans.XmlObject`.
    Then it dynamically finds out the corresponding classes, and using their `Factory`
    methods, it creates instances and binds to the XML at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Same as the previous recipe, a plugin in the POM files generates `XMLBean` classes
    from the schema `(OrderService.xsd)` in the folder `src\main\webapp\WEB-INF` (set
    by `schemaDirectory):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `MessageDispatcherServlet`, with the help of `XMLBeansMarshaller`, detects
    the O/X mapping annotations and the marshaller configuration, and delegates the
    final marshalling process to the XMLBeans framework.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XMLBeans come with a set of built-in powerful tools to add much more functionality
    than merely marshalling between XML and Java. The recipe utilized just one such
    tool, `scomp`, the Schema Compiler that generates Java classes/compressed JAR
    files out of an XML Schema `(.xsd)` file. A few other tools that may be helpful
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inst2xsd` (Instance to Schema Tool): Generates XML schema from XML instance
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scopy` (Schema Copier): Copies the XML schema at the specified URL to the
    specified file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate` (Instance Validator): Validates an instance against a schema'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xpretty` (XML Pretty Printer): Pretty prints the specified XML to the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xsd2inst` (Schema to Instance Tool): Prints an XML instance from the specified
    global element using the specified schema'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xsdtree` (Schema Type Hierarchy Printer): Prints an inheritance hierarchy
    of the types defined in a schema'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlbean Ant task:` Compiles a set of XSD and/or WSDL files into XMLBeans types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `xmlbean Ant task` is a nice way to automate the generation of Java classes
    in integration with your build scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling with JiBX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JiBX ([http://jibx.sourceforge.net/](http://jibx.sourceforge.net/)) is another
    tool and library for binding XML data to Java objects. JiBX is known to be the
    best for speed performance as well as flexibility. However, it has also been known
    for its complexity of binding, especially for a complex data model.
  prefs: []
  type: TYPE_NORMAL
- en: From version 1.2 onwards, JiBX has addressed these bottlenecks and now it has
    easy-to-use marshalling tools and framework. Using the JiBX tool, a user can generate
    a schema from existing Java code or generate Java code and binding files from
    an existing schema. JiBX library at runtime binds Java classes to XML data and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the JiBX tool `(jibx-maven-plugin)` is used to generate POJO
    classes and bind a definition file from an existing schema, and then a Web-Service
    client and server will be built upon the JiBX libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contains a server `(LiveRestaurant_R-6.3)` and a client `(LiveRestaurant_R-6.3-Client)`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.3` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-expression-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jibx-run-1.2.3.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jibx-extras-1.2.3.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jibx-ws-0.9.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.3-Client` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-expression-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jibx-run-1.2.3.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jibx-extras-1.2.3.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jibx-ws-0.9.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register the JiBX marshaller inside the server/client-side configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `xmlbeans-maven-plugin` inside the server/client-side POM files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the server and run the client (it also generates classes from a schema):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server project root: `mvn clean package` (it also generates classes from schema).
    Copy the WAR file into the Tomcat `webapp` folder and run Tomcat (apache-tomcat-6.0.18)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client project-root: `mvn clean package` (it also generate classes from schema)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the client-side output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained in the previous recipe, the application context for the server/client
    uses a customized marshaller (`org.springframework.oxm.jibx.JibxMarshaller`) to
    perform the Object/XML marshalling process. This Spring marshaller uses JiBX libraries
    for binding and marshalling processes. The following POM plugin setting (goal:
    `schema-codegen)` generates POJO classes from a schema `(OrderService.xsd)` into
    a package `(com.packtpub.liverestaurant.domain)` and it also generates a binding
    file (goal: `bind):`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As described in the earlier recipes, this setting in the server and client
    Spring context file causes the client and server to use a customized marshaller
    `(JibxMarshaller)` for marshalling/unmarshalling POJO classes to/from XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`JibxMarshaller` uses mapping the `binding.xml` file for the marshalling task.
    As it is shown in the mapping file, JiBX supports for simple data binding (<value
    `style="element" name="fName"...)` as well as complex data binding known as structure
    (<structure `map-as="tns:Address"...)`. This feature makes JiBX the most flexibility-binding
    framework among the others.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderServiceEndPoint`, which is annotated as an `@Endpoint`, is almost
    the same as earlier recipes (Marshalling *with JAXB2)*; only the implementation
    is slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JiBX provides more flexibility by letting users create their own customized
    marshaller. It means instead of using a generated binding file, a custom binding
    file and custom marshaller classes to marshal any kind of data structure inside
    an XML document.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling with XStream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XStream** ([http://xstream.codehaus.org/](http://xstream.codehaus.org/))
    is a simple library for marshalling/unmarshalling objects to/from XML data. The
    following major features make this library different from others:'
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't need a mapping file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't need to change POJO (no need for a setter/getter and default constructor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative output format (JSON support and morphing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XStream does not have a tool to generate a schema from existing Java code or
    to generate Java code from an existing schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XStream does not support namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, a Web-Service client and server are created that use XStream
    libraries as a marshaller. Since XStream is not using any namespace in XML data
    (payload), a web address style of Web-Service is set up.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contains a server (`LiveRestaurant_R-6.4`) and a client (`LiveRestaurant_R-6.4-Client`)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.4` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-expression-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jxstream-1.3.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.4-Client` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jxstream-1.3.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register XStream marshaller inside the server/client-side configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate domain classes with the `Xstream` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the server and run the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server project-root: `mvn clean package tomcat:run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client project-root: `mvn clean package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the client-side output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained in the previous recipe, the application context for server/client
    uses a customized marshaller (`org.springframework.oxm.xstream.XStreamMarshaller`)
    to perform the Object/XML marshalling process. This spring marshaller uses XStream
    libraries for the marshalling process. The beans that are input and output parameters
    of the method in the endpoint (`OrderServiceEndPoint.java`) have to be registered
    in `XstreamMarshaller. autodetectAnnotations` is set to detect annotating within
    POJO classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`XStreamMarshaller` uses annotation in POJO classes (instead of the binding
    file) for the marshalling task. `@XstreamAlias` tells the marshaller that this
    class will be serialized/deserialized as ''name''. There is other annotation that
    is optional, but it tells marshaller how to serialize/deserialize the field of
    a class `(@XStreamAsAttribute, @XStreamImplicit`, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OrderServiceEndPoint`, which is annotated as an `@Endpoint` is the same
    as JiBX recipes that " the endpoint method''s input and and return parameters
    are POJO `(PlaceOrderResponse, PlaceOrderRequest`, and so on) that is mapped to
    the schema. The only difference is that the endpoint uses web addressing for method
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Marshalling with MooseXML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Moose** ([http://quigley.com/moose/](http://quigley.com/moose/)) is a lightweight
    framework for marshalling/unmarshalling objects to/from XML data. The schema generator
    of Moose is what makes this framework different from others. Moose is able to
    generate schema directly from annotated POJO classes. This is what is required
    to develop contract-last Web-Service development.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, Moose is used to marshall/unmarshall objects to/from XML data
    in the Web-Service client and server communications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contains a server (`LiveRestaurant_R-6.5`) and a client (`LiveRestaurant_R-6.5-Client`)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.5` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moose-0.4.6.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.5-Client` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moose-0.4.6.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Register Moose marshaller inside the server/client-side configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate domain classes with the `@XML` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the server and run the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server project-root: `mvn clean package tomcat:run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client project-root: `mvn clean package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the client-side output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the previous recipe, the application context for the server/client
    uses a customized marshaller (`com.quigley.moose.spring.MooseMarshaller`) to perform
    the Object/XML marshalling process. A mapping provider is injected into this custom
    marshaller. The mapping provider is to set the namespace and `xmlPrefix` when
    the object is being marshalled into XML and when the XML data is being converted
    into an object. The mapping provider gets the list of registered POJO classes
    from `com.quigley.moose.mapping.provider.annotation.StaticClassesProvider:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`MooseMarshaller`, just like `XStreamMarshaller`, uses annotation in POJO classes
    for marshalling tasks. `@XML` tells the marshaller that this class will be serialized/deserialized
    as ''name''. `@XMLField` is the tag that should be placed for each class field.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderServiceEndPoint`, which is annotated as an `@Endpoint`, is the same
    as the JiBX recipes that passing and return parameter is mapped POJO `(PlaceOrderResponse,
    PlaceOrderRequest`, and so on) that is mapped to the schema.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom marshaller using XPath for conditional XML parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the existing marshaller frameworks (JAXB, JiBX, and so on) is always the
    easiest way to handle a marshalling task. However, eventually you may need to
    write a customized marshaller. For example, you may get an XML input data, which
    is in a different format from the one that is generally is being used by the recognized
    marshaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring lets you define a customized marshaller and inject it into your endpoint
    marshaller as existing marshaller frameworks. In this recipe, the client sends/receives
    this data to/from the server in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the XML input that can be mapped to/from the server''s POJO is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, a customized marshaller is used to map the incoming XML data
    to the server's POJO and the unmarshalling server response to the client format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contains a server (`LiveRestaurant_R-6.6`) and a client (`LiveRestaurant_R-6.6-Client`)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.6` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dom4j-1.6.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveRestaurant_R-6.6-Client` has the following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dom4j-1.6.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a customized marshaller class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the new marshaller inside the server-side configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the server and run the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server project-root: `mvn clean package tomcat:run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client project-root: `mvn clean package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the server-side output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to work as an endpoint marshaller, a customized marshaller (`ServerCustomMarshaller`)
    should implement `Marshaller` and `Unmarshaller` interfaces. The method `supports`
    is for verifying if the POJO class is registered with this marshaller. The value
    of the registered POJO comes from the Spring context file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `unmarshal` will be called by the endpoint when the Web-Service
    calls the endpoint method (`handleOrderRequest`) to build the passing parameter
    (`PlaceOrderRequest`). In the `unmarshal` method, DOM4j and XPath are used to
    fetch a value from the incoming XML data. These values will populate the POJO
    class and return it back to the endpoint. The method `marshal` will be called
    by the endpoint when the endpoint method (`handleOrderRequest`) returns the response
    (`PlaceOrderResponse`). Inside the `marshal` method, `XMLStreamWriter` is used
    to return the desired format XML data to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As explained in the previous recipe, the application context for the server/client
    uses this customized marshaller (`ServerCustomMarshaller`) to perform the Object/XML
    marshalling process. `RegisteredClassNames` is for registering the POJO classes
    eligible for marshalling/unmarshalling via the customized marshaller (`ServerCustomMarshaller`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderEndPoint`, which is annotated as an `@Endpoint`, is the same as the
    JiBX recipes that the endpoint method's input and and return parameters are POJO
    `(PlaceOrderResponse, PlaceOrderRequest`, and so on) that is mapped to the schema.
  prefs: []
  type: TYPE_NORMAL
