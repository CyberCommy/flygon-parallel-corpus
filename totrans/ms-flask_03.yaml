- en: Chapter 3. Creating Views with Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our data in an easily accessible format, displaying the information
    in a web page becomes much easier. In this chapter, we will use the included templating
    language for Flask Jinja, to dynamically create HTML from our SQLAlchemy models.
    We will also examine Jinja's methods to automate the creation of HTML and modify
    data for presentation inside a template. Then, the chapter will end with automatically
    creating and validating HTML forms with Jinja.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja's syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jinja** is a templating language written in Python. A **templating language**
    is a simple format that is designed to help automate the creation of documents.
    In any templating language, variables passed to the template replace predefined
    locations in the template. In Jinja, variable substitutions are defined by `{{
    }}`. The `{{ }}` syntax is called a **variable block**. There are also **control
    blocks** defined by `{% %}`, which declare language functions, such as **loops**
    or `if` statements. For example, when the `Post` model from the previous chapter
    is passed to it, we have the following Jinja code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables displayed in a Jinja template can be any Python type or object,
    as long as they can be converted into a string via the Python function `str()`.
    For example, a dictionary or a list passed to a template can have its attributes
    displayed via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Many programmers prefer to use JavaScript to template and dynamically create
    their HTML documents to take the HTML rendering load off of the server. This will
    not be covered in this chapter as it is an advanced JavaScript topic. However,
    many JavaScript templating engines use the `{{ }}` syntax as well. If you choose
    to combine Jinja and your JavaScript templates defined in your HTML files, then
    wrap the JavaScript templates in the `raw` control block to tell Jinja to ignore
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s a common mistake to believe that Jinja and Python''s syntax is the same
    because of their similarity. However, there is a lot of differences. As you will
    see in this section, normal Python functions do not really exist. Instead, in
    Jinja, variables can be passed to built-in functions that modify the variables
    for display purposes. These functions, named filters, are called in the variable
    block with the pipe character `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if no arguments are passed to the filter, the parentheses can be
    omitted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Filters can also be called control blocks to apply them to blocks of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are many filters in Jinja; this book will cover only the most useful filters.
    For the sake of brevity, in each example, the output of each filter will be listed
    directly beneath the filter itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a full list of all the default filters in Jinja, visit [http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters).
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the passed variable is `None`, then replace it with a default value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to replace the variable with the default value and if the variable
    evaluates to `False`, then pass `True` to the optional second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: escape
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the passed variable is a string of HTML, the `&`, `<`, `>`, `''`, and `"`
    characters will be printed as HTML escape sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This converts the passed value to a floating point number with the Python `float()`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: int
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This converts the passed value to an integer with the Python `int()` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a filter that joins elements of a list with a string and works exactly
    same as the `list` method of the same name. It is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a filter that fills the same role as the Python `len()` function. It
    is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: round
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This rounds off a float to the specified precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also specify how you want the number to be rounded off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `common` option rounds like a person would: anything at or above 0.5 is
    rounded up, and anything less than 0.5 is rounded down. The `floor` option always
    rounds the number down, and the `ceil` option always rounds up, regardless of
    the decimal.'
  prefs: []
  type: TYPE_NORMAL
- en: safe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you try to insert HTML into your page from a variable, for example, when
    you wish to display a blog post, Jinja will automatically try to add HTML escape
    sequences to the output. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a necessary security feature. When an application has inputs that allow
    users to submit arbitrary text, it allows a malicious user to input HTML code.
    For example, if a user were to submit a script tag as a comment and Jinja didn't
    have this feature, the script would be executed on all the browsers that visited
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we still need a way to display HTML that we know is safe to show,
    such as the HTML of our blog posts. We can achieve this using the `safe` filter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: title
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We capitalize a string using title case format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: tojson
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can pass the variable to the Python `json.dumps` function. Remember that
    your passed object must be serializable by the `json` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature is most commonly used to pass SQLAlchemy models to JavaScript
    MVC frameworks on page load rather than waiting for an AJAX request. If you use
    `tojson` in this way, remember to pass the result to the `safe` filter as well
    to make sure that you don''t get HTML escape sequences in your JavaScript. Here
    is an example with a `Backbone.js`, a popular JavaScript MVC framework, collection
    of models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: truncate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This takes a long string and returns a string cutoff at the specified length
    in characters and appends an ellipses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, any words that are cut in the middle are discarded. To disable
    this, pass `True` as an extra parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Custom filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding your own filter into Jinja is as simple as writing a Python function.
    To understand custom filters, we will look at an example. Our simple filter will
    count the number of occurrences of a substring in a string and return it. Look
    at the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define our filter as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To add this function to the list of available filters, we have to manually
    add it to the `filters` dictionary of the `jinja_env` object in our `main.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments in the template are defined by `{# #}`, will be ignored by Jinja,
    and will not be in the returned HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`if` statements in Jinja are similar to Python''s `if` statements. Anything
    that returns, or is, a Boolean determines the flow of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Filters can also be used in `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use loops in Jinja to iterate over any list or generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Loops and `if` statements can be combined to mimic the `break` functionality
    in Python loops. In this example, the loop will only use the post `if post.text`
    is not `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, you have access to a special variable named `loop`, which
    gives you access to information about the `for` loop. For example, if we want
    to know the current index of the current loop to emulate the `enumerate` function
    in Python, we may use the index variable of the loop variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'All the variables and functions that the `loop` object exposes are listed in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.index` | The current iteration of the loop (1 indexed) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.index0` | The current iteration of the loop (0 indexed) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.revindex` | The number of iterations from the end of the loop (1 indexed)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.revindex0` | The number of iterations from the end of the loop (0 indexed)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.first` | True if the current item is first in the iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.last` | True if the current item is last in the iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.length` | The number of items in the iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.cycle` | The helper function to cycle between the items in the iterator,
    which is explained later |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.depth` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 1) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.depth0` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 0) |'
  prefs: []
  type: TYPE_TB
- en: 'The `cycle` function is a function that goes through an iterator one item at
    a time at every loop. We may use the previous example to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **macro** is best understood as a function in Jinja that returns a template
    or HTML string. This is used to avoid code that is repeated over and over again
    and reduce it to one function call. For example, the following is a macro to add
    a Bootstrap CSS input and a label to your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to quickly add an input to a form in any template, call your macro using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Flask-specific variables and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask makes several functions and objects available to you by default in your
    template.
  prefs: []
  type: TYPE_NORMAL
- en: config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flask makes the current `config` object available in templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the Flask `request` object for the current request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Flask `session` object is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: url_for()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `url_for` function returns the URL of a route by giving the route function
    name as a parameter. This allows URLs to be changed without worrying about where
    links will break.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had a route that had positional arguments in the URL, we pass them as
    `kwargs`. They will be filled in for us in the resulting URL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: get_flashed_messages()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a list of all the messages passed through the `flash()` function
    in Flask. The `flash` function is a simple function that queues messages, which
    are just Python strings, for the `get_flashed_messages` function to consume.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Creating our views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we need to create a new folder named `templates`, in our project
    directory. This folder will store all of our Jinja files, which are just HTML
    files with Jinja syntax mixed in. Our first template will be our home page, which
    will be a list of the first 10 posts with summaries. There will also be a view
    for a post that will just show the post content, comments on the page, links to
    the author user page, and links to tag pages. There will also be user and tag
    pages that show all the posts by a user and all the posts with a specific tag.
    Each page will also have a sidebar showing the five most recent posts and the
    top five most used tags.
  prefs: []
  type: TYPE_NORMAL
- en: The view function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because each page will have the same sidebar information, we can break that
    into a separate function to simplify our code. In the `main.py` file, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The most recent posts query is straight forward, but the most popular tags query
    looks somewhat familiar, yet a little odd. This is a bit beyond the scope of this
    book, but using the SQLAlchemy `func` library to return a count, we are able to
    order our tags by the most used tags. The `func` function is explained in detail
    at [http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func](http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func).
  prefs: []
  type: TYPE_NORMAL
- en: 'The home page function in `main.py` will need all the posts in a pagination
    object and the sidebar information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we finally see how Flask and Jinja tie together. The Flask function `render_template`
    takes the name of a file in the folder templates and passes all the `kwargs` to
    the template as variables. Also, our `home` function now has multiple routes to
    handle pagination and will default to the first page if there is nothing after
    the slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have all the pieces of knowledge that you need to write view functions,
    I challenge you to try to write the rest of the view functions based on the preceding
    descriptions. After you have tried, compare your results to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After all of your views are written, the only thing left to do is to write the
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the templates and inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because this book does not focus on interface design, we will use the CSS library
    Bootstrap and avoid writing custom CSS. If you have never used it before, **Bootstrap**
    is a set of default CSS rules that make your website work well across all browsers
    and has tools that allow you to easily control the layout of your website. To
    download Bootstrap, go to [http://getbootstrap.com/](http://getbootstrap.com/)
    and hit the button that says **Download Bootstrap**. Hit another button that says
    **Download Bootstrap** and you will start to download a Zip file. Unzip this file
    into your project directory and rename the folder to `static`. The `static` folder
    must be at the same directory level as the `main.py` file for Flask to automatically
    find the files. From now on, this is where we will keep our CSS, font, images,
    and JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because every route will have a template assigned to it, each template will
    need the requisite HTML **boilerplate** code with our meta information, style
    sheets, common JavaScript libraries, and so on. To keep our templates **DRY**
    (**Don''t Repeat Yourself**), we will use one of the most powerful features of
    Jinja, template inheritance. **Template inheritance** is when a child template
    can import a base template as a starting point and only replace marked sections
    in the base. To start our base template, we need a basic HTML skeleton as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `base.html` in your `templates` directory. The `block` control
    block is used in inheritance to mark sections to be replaceable by the child template.
    Because we will use pagination in several different pages, let''s create a macro
    to render a pagination widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This macro takes a Flask SQLAlchemy pagination object and a view function name
    and constructs a Bootstrap list of page links. Add this to the top of `base.html`
    so that all the pages that inherit from it will have access to it.
  prefs: []
  type: TYPE_NORMAL
- en: The home page template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To inherit a template, the `extends` control block is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This template will use all the HTML `base.html` but replace the data in the
    `title` block. If we do not declare a `title` block, the content in `base.html`
    would remain unchanged. Save this template as `index.html`. Now we can see this
    in action. Open `http://127.0.0.1:5000/` on your browser and you should see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The home page template](img/B03929_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, it is easier to develop and mock UIs if you have representative
    fake data. Because we only have two posts and manually adding a large amount of
    models from the command line is tedious (which we shall fix in [Chapter 10](ch10.html
    "Chapter 10. Useful Flask Extensions"), *Useful Flash Extensions*), let''s use
    the following script to add 100 example posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This script is simple for loop that sets all the attributes of a new post and
    randomizes what tags the post has. Now, to begin developing our templates in earnest,
    we will start by adding the following to the home page: summaries of our blog
    posts with links, the most recent blog posts, and the most commonly used tags.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add our content to `home.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: All the other pages will take this general form of content in the middle with
    a sidebar of links to popular content.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the other templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know the ins and outs of inheritance and you know which data is
    going to go to each template, I will pose the same challenge as the previous section.
    Try to write the content sections of the remaining templates. After finishing
    it, you should be able to freely navigate around your blog, click on posts, and
    view user pages. There is one final bit of functionality to add in this chapter—the
    ability for readers to add comments.
  prefs: []
  type: TYPE_NORMAL
- en: Flask WTForms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding forms in your application seems to be an easy task, but when you start
    coding the server-side code, the task of validating user input grows bigger and
    bigger as the form becomes more complex. Security is paramount as the data is
    from an untrustworthy source and is going to be entered in the database. **WTForms**
    is a library that handles server form validation for you by checking input against
    common form types. Flask WTForms is a Flask extension on top of WTForms that add
    features, such as Jinja HTML rendering, and protects you against attacks, such
    as **SQL injection** and **cross-site request forgery**. To install Flask WTForms
    and WTForms, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protecting yourself against SQL injection and cross-site request forgery is
    extremely important, as these are the most common forms of attacks your website
    will receive. To learn more about these attacks, visit [https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)
    and [https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    for SQL injection and cross-site request forgery, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have Flask WTForms'' security measures working properly, we will need a
    secret key. A **secret key** is a random string of characters that will be used
    to cryptographically sign anything that needs to be tested for its authenticity.
    This cannot be any string; it must be randomized to avoid weakening the strength
    of the security protections. To generate a random string, type the following into
    Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Mac, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the output in `config.py` on the `Config` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: WTForms basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main parts of WTForms—**forms**, **fields**, and **validators**.
    Fields are representations of input fields and do rudimentary type checking, and
    validators are functions attached to fields that make sure that the data submitted
    in the form is within our constraints. The form is a class that contains fields
    and validators and validates itself on a `POST` request. Let''s see this in action
    to get a better idea. In the `main.py` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a class that inherits from Flask WTForm''s `Form` object and defines
    inputs with class variables that equal WTForm fields. The fields take an optional
    parameter `validators`, a list of WTForm validators that will be applied to our
    data. The most commonly used fields are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.DateField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This represents a Python `Date` object and takes an optional parameter format
    that takes a `stftime` format string to translate the data.
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.IntegerField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This attempts to coerce passed data to an integer and is rendered in the template
    as a number input.
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.FloatField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This attempts to coerce passed data to a float and is rendered in the template
    as a number input.
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.RadioField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This represents a set of radio inputs and takes a parameter `choices`, that
    is, a list of tuples that act as the displayed value and the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.SelectField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with `SelectMultipleField`, it represents a set of radio inputs. Takes
    a parameter `choices`, that is, a list of tuples that act as the displayed and
    returned values.
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.StringField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This represents a normal text input and will attempt to coerce the returned
    data to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a full list of validators and fields, visit the WTForms documentation at
    [http://wtforms.readthedocs.org](http://wtforms.readthedocs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common validators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validators.DataRequired()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Email()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Length(min=-1, max=-1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.NumberRange(min=None, max=None)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Optional()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Regexp(regex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.URL()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these validations follows the Pythonic naming scheme. Therefore, they
    are rather straight forward on what they do. All validators take an optional parameter
    named `message`, which is the error message that will be returned if the validator
    fails. If message is not set, it uses same defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a custom validation function is very simple. All that is required is
    to write a function that takes the `form` object and the `field` object as parameters
    and raises a WTForm.`ValidationError` if the data does not pass the test. Here
    is an example of a custom e-mail validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To use this function, just add it to the list of validators for your field.
  prefs: []
  type: TYPE_NORMAL
- en: Posting comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our comment form and we understand how to build it, we need
    to add it to the start of our post view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we add the `POST` method to the list of allowed method to our view.
    Then, a new instance of our form object is created. The `validate_on_submit()`
    method then checks whether the Flask request is a `POST` request. If it is a `POST`
    request, it sends the request form data to the form object. If the data is validated,
    then `validate_on_submit()` returns `True` and adds the data to the `form` object.
    We then take the data from each field, populate a new comment, and add it to the
    database. Finally, we add the form to the variable to be sent to the template,
    so we can add the form to our `post.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: There are several new things happing here. First, the `form.hidden_tag()` method
    adds an anti-cross-site request forgery measure automatically. Second, the `field.errors`
    list is used to render any messages that our validators send if validation fails.
    Third, calling the field itself as a method will render the HTML code of that
    field. Finally, calling `field.label` will automatically create an HTML label
    for our input. Now, adding information to the fields and pressing the submit button
    should add your comment!
  prefs: []
  type: TYPE_NORMAL
- en: 'This would look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Posting comments](img/B03929_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One final challenge for the reader is to make a macro that takes a `form` object
    and an endpoint to send the `POST` request to and autogenerate HTML for the entire
    form tag. Refer to the WTForms documents if you get stuck. It's tricky, but not
    too difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, after only three chapters, you already have a fully functional blog. This
    is where a lot of books on web development technologies would end. However, there
    are still 10 more chapters to go to turn your utilitarian blog into something
    that a user would actually use for their website. In the next chapter, we will
    focus on structuring Flask apps to accommodate long-term development and larger
    scale projects.
  prefs: []
  type: TYPE_NORMAL
