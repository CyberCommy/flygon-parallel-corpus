- en: Chapter 9. Introducing WebGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebGL wrapper to simplify the WebGL API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a triangular plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating a triangular plane in 3D space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rotating cube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding textures and lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 3D world that you can explore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Originally, when I first started writing this book, I had intended on only covering
    the 2D context of the HTML5 canvas (I strongly believe that most people who use
    canvas will be working with this context). I had also originally intended on covering
    techniques for rendering 3D shapes in the 2D context using 3D projection methods
    and vector operations. People were already busy creating some pretty incredible
    3D JavaScript libraries for the 2D context, including Kevin Roast's K3D library
    (one of the reviewers of this book), and also Dean McNamee's Pre3d library.
  prefs: []
  type: TYPE_NORMAL
- en: As I neared writing this chapter, WebGL—a true 3D context—began to dominate
    3D canvas demos across the Web. WebGL stands for **Web-Based Graphics Library**,
    and it's based on OpenGL ES 2.0 which provides an API for 3D graphics. Because
    WebGL leverages hardware acceleration by pushing buffers directly onto the graphics
    card to render 3D models, it performs much better than its 2D context, 3D projection
    library counterparts. Moreover, it exposes years of work already done with OpenGL.
    As you've probably already figured out by now, I decided to cover WebGL instead
    of covering 3D projection libraries with the 2D context because I very much believe
    that WebGL will be the standard for 3D applications in the near future. WebGL
    is of particular interest for people who want to create 3D games or 3D models
    on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will get you started with the basics of WebGL by covering concepts
    such as buffers, shaders, perspective and model-view matrices, normals, textures,
    lighting, camera handling, and much more. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebGL wrapper to simplify the WebGL API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've already looked ahead and peeked at the code for this recipe, and you're
    not very familiar with OpenGL or WebGL, you're probably feeling pretty overwhelmed,
    and for good reason. WebGL, although extremely powerful, has quite a steep learning
    curve when diving into it for the first time. Frankly speaking, it takes many
    lines of code to perform simple tasks. Therefore, I've found it extremely convenient
    to work with a WebGL wrapper that essentially shrink wraps blocks of tedious code
    into simple methods. This recipe provides steps for creating a simple WebGL wrapper
    that will be used for all of the recipes in this chapter. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the WebGL wrapper is quite complex, you might consider grabbing the WebGL
    wrapper code from the online resources for this book at [http://www.html5canvastutorials.com/cookbook/](http://www.html5canvastutorials.com/cookbook/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a WebGL wrapper object to simplify the WebGL API,
    or go to [http://www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook)
    and download `WebGL.js` from the resources section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin defining the WebGL constructor by initializing the canvas context and
    defining the animation properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use *Paul Irish''s* `requestAnimFrame` shim to create a cross-browser `requestAnimationFrame`
    function which enables the browser to handle the FPS for our animations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As *Brandon Jones''s* `glMatrix` uses global variables, we can encapsulate
    them so that the variables can''t be altered outside of the wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Define shader type constants and initialize the model-view matrix, the perspective
    matrix, and the viewport dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the depth test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define getter methods for the context and canvas attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a `clear()` method which clears the WebGL viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setStage()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `isAnimating()` method which returns whether or not the animation
    is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getFrame()` method which returns the current frame number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `start()` method which starts the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stopAnimation()` method which stops the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getTimeInterval()` method which returns the time in milliseconds
    that has passed since the last frame was rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getTime()` method which returns the number of milliseconds that
    have passed since the animation was started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getFps()` method which returns the current FPS value determined
    by the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `animationLoop()` method which is responsible for updating the animation
    properties, drawing the stage, and requesting a new animation frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `save()` method which saves the model-view matrix state by pushing
    the current state onto the model-view matrix stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `restore()` method which restores the previous model-view state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getFragmentShaderGLSL()` method which gets **GLSL** (**GL Shader
    Language**) fragment code based on the shader type argument. Essentially, this
    method contains four different stand alone GLSL fragment shader programs that
    are selected with a `case` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getVertexShaderGLSL()` method which gets GLSL vertex code based
    on the shader type argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initShaders()` method which initializes the appropriate shaders
    based on the shader type argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setShaderProgram()` method which sets the shader program based
    on the shader type argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `perspective()` method which wraps the glMatrix `perspective()`
    method that operates on the perspective matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `identity()` method which wraps the glMatrix `identity()` method
    that operates on the model-view matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `translate()` method which wraps the glMatrix `translate()` method
    that operates on the model-view matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `rotate()` method which wraps the glMatrix `rotate()` method that
    operates on the model-view matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initPositionShader()` method which initializes the position shader
    to be used with position buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initColorShader()` method which initializes the color shader to
    be used with color buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initTextureShader()` method which initializes the texture shader
    to be used with texture buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initNormalShader()` method which initializes the normal shader
    to be used with normal buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initLightingShader()` method which initializes ambient and directional
    lighting shaders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initTexture()` method which wraps the WebGL API code necessary
    to initialize a WebGL texture object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `createArrayBuffer()` method which wraps the WebGL API code necessary
    to create an array buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `createElementArrayBuffer()` method which wraps the WebGL API code
    necessary to create an element array buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `pushPositionBuffer()` method which pushes a position buffer onto
    the graphics card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `pushColorBuffer()` method which pushes a color buffer onto the
    graphics card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `pushTextureBuffer()` method which pushes a texture buffer onto
    the graphics card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `pushIndexBuffer()` method which pushes an index buffer onto the
    graphics card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `pushNormalBuffer()` method which pushes a normal buffer onto the
    graphics card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setMatrixUniforms()` method which wraps the WebGL API code required
    to set the matrix uniforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawElements()` method which wraps the WebGL API code that draws
    non-triangular position buffers based on the index buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawArrays()` method which wraps the WebGL API code required to
    draw triangular position buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `enableLighting()` method which wraps the WebGL API code required
    to enable lighting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setAmbientLighting()` method which wraps the WebGL API code required
    for setting ambient lighting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setDirectionalLighting()` method which wraps the WebGL API code
    required for setting directional lighting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of the WebGL wrapper object is to handle some of the things that the
    WebGL API doesn't provide and to wrap tedious blocks of code that are required
    to do straightforward things.
  prefs: []
  type: TYPE_NORMAL
- en: There are two major components of WebGL that aren't built into the API—matrix
    transformation math and shader programs. In this chapter, we'll be using a handy
    matrix library built specifically for WebGL by *Brandon Jones*, called glMatrix,
    to handle all of the vector operations. As for the missing support for shader
    programs, our WebGL wrapper object includes pre-built GLSL shader programs. Shader
    programs are written in GLSL, which is short for OpenGL Shading Language, and
    is used to programmatically define how vertices and fragments should be rendered.
    Vertex shaders operate on every vertex that makes up the shape of our 3D models,
    and fragment shaders operate on every fragment which is produced by rasterization.
    To use shader programs , we'll actually have to pass in strings of GLSL code into
    the WebGL API.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the wrapper methods, the WebGL wrapper object also includes the
    animation methods that we put together in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation"), *Bringing the Canvas to Life with Animation*.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the remaining methods in our WebGL wrapper object simply wrap
    blocks of code necessary to push buffers onto the graphics card and then draw
    the result. In the next five recipes, we'll dive deeper into each of these buffer
    types, including position buffers, color buffers, index buffers, texture buffers,
    and normal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a more in-depth exploration of WebGL and OpenGL, check out these two awesome
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://learningwebgl.com/](http://learningwebgl.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nehe.gamedev.net/](http://nehe.gamedev.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Appendix A](apa.html "Appendix A. Detecting Canvas Support"), *Detecting Canvas
    Support*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a triangular plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our WebGL wrapper set up, let's create our first WebGL application
    by drawing a simple triangle on the screen. It will serve as a good foundation
    for the typical steps that are required to create more complex 3D models. In this
    recipe, we'll introduce the concept of position buffers, which are simply arrays
    of vertices used to define the position and shape of a 3D model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a triangular plane](img/1369_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to render a 2D triangle with WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initBuffers()` function which initializes the position buffers
    for our triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` function which sets the perspective matrix, sets the model-view
    matrix to the identity matrix, translates the model-view matrix back -5 units
    in the z direction, pushes the position buffer onto the graphics card, and then
    draws the triangle using `drawArrays()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, create a new instance of the WebGL wrapper object, set
    the shader program to `"BLUE_COLOR"`, initialize the triangle buffers, and then
    draw the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the loads, the first thing we need to do is to initialize the WebGL wrapper
    object using the `experimental-webgl` context. At the time of writing, the `experimental-webgl`
    context is the only canvas context that's supported across all of the major browsers
    that support WebGL, including Google Chrome, Firefox, and Safari.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can set the shader program to `"BLUE_COLOR"`, which will use a pre-built
    GLSL program to render blue vertices and fragments. Once the shader program is
    set, we need to initialize our buffers. Buffers are an array of vertices that
    are used to define our 3D models. For this recipe, we'll only be using a position
    buffer, which defines the vertex positions of our triangle. In future recipes,
    we'll introduce other buffer types, including index buffers, texture buffers,
    and normal buffers. For this recipe, the position buffer contains nine elements
    which represent three vertices (each vertex has an x, y, and z component).
  prefs: []
  type: TYPE_NORMAL
- en: Once the triangle buffers have been initialized, we can draw the stage. The
    `stage()` function first clears the canvas and then sets the perspective matrix.
    The `perspective()` method of our WebGL wrapper object takes in three parameters,
    a viewing angle, a minimum visible distance, and a maximum visible distance. In
    this recipe, we've set the minimum visible distance to 0.1 units, and the maximum
    visible distance to 100 units. Any objects closer than 0.1 units will be invisible,
    and any objects further than 100 units will also be invisible. If our stage were
    to contain a lot of complex models spread throughout space, then having a large
    maximum visible distance could potentially cause performance problems because
    too much is being rendered on the screen at once.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can set the model-view matrix to the identity matrix using the `identity()`
    function , and then translate the model-view matrix to (0, 0, -5). This means
    that we've simply moved our model -5 units in the z direction which is 5 units
    away from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can push the position buffer onto the graphics card using the `pushPositionBuffer()`
    method and then draw the triangle using `drawArrays()`.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating a triangular plane in 3D space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can draw a 2D triangle in 3D space, let's try spinning it about
    the y-axis using the animation methods we added to the WebGL wrapper object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotating a triangular plane in 3D space](img/1369_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to rotate a triangle about the y-axis with WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initBuffers()` function which initializes the position buffers
    for our triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` function which sets the perspective, sets the model-view
    matrix to the identity matrix, translates the triangle, rotates the triangle about
    the y-axis, pushes the position buffer onto the graphics card, and draws the triangle
    using `drawArrays()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, initialize the WebGL wrapper object, set the shader program,
    initialize the buffers, set the `stage` function for the animation, and then start
    the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To rotate our triangle about the y-axis, we first need to set up an animation
    stage by setting the `stage()` function of the WebGL wrapper object (similar to
    what we did in [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas to Life with
    Animation") with the `Animation` object ), and then start the animation with `start()`.
    For each animation frame, we can increase the angle of the triangle about the
    y-axis by rotating the model-view matrix with the `rotate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rotating cube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, now the fun really begins. In this recipe, we'll create a rotating 3D
    cube with differently colored faces. To do so, we'll introduce two new kinds of
    buffers—color buffers and index buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a rotating cube](img/1369_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a rotating cube with WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initBuffers()` function which initializes the position buffers,
    color buffers, and the index buffers for our cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` function which sets the perspective, sets the model-view
    matrix to the identity matrix, translates the cube, rotates the cube, pushes the
    position buffer, the color buffer, and the index buffer onto the graphics card,
    and finally draws the cube using `drawElements()` since the faces of our model
    aren''t triangular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, initialize the WebGL wrapper object, set the shader program
    to `"VARYING_COLOR"` as the color of each face is variable and dependent on the
    color buffers, initialize the buffers, set the `stage` function for the animation,
    and then start the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe introduces the concept of index buffers and color buffers. In the
    previous two recipes, we created a triangular plane because models with triangular
    faces are the easiest to implement with WebGL because only one buffer is required—the
    position buffer. When we want to create a 3D model with non-triangular faces,
    such as a cube, it's a bit more complex because we need a way to represent the
    cube as a set of triangular faces. We can accomplish this by creating an index
    buffer that maps triangles to the vertices of the position buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the index buffer vertices in the proceeding code. You'll notice
    that the first six elements are `[0, 1, 2, 0, 2, 3]`. The first three elements,
    `[0, 1, 2]` refer to the 0th, 1st, and 2nd vertices of the position buffer, which
    form a triangle that covers half of the front face of the cube. The second set
    of elements, `[0, 2, 3]` correspond to the 0th, 2nd, and 3rd vertices of the position
    buffer and form a second triangle that covers the other half of the front face
    of the cube. Together, these two triangles form a solid face for the front face
    of the cube. When the index buffer is complete, it will contain a mapping of position
    buffer vertices that form triangular faces that cover the six faces of the cube.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to index buffers, this recipe also requires the use of color buffers.
    Color buffers are used to define the colors of model faces. In this recipe, the
    color buffer will define six different colors for the six faces of our cube. Similar
    to index buffers, color buffers are used to map a color to each vertex in the
    position buffer. Each color is defined by four elements, [red, green, blue, alpha].
    As defined by the position buffer, our cube is made up of six faces, each with
    four vertices. Therefore, our color buffer array should contain (6 faces) * (4
    vertices per face) * (4 elements per color) = 96 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our position buffer, color buffer, and index buffer defined, all
    that's left for us to do is to push each buffer onto the graphics card and render
    the model. Unlike the previous two recipes where we used the `drawArrays()` method
    to directly render the triangle, in this recipe we'll have to use the `drawElements()`
    method because our model is made up of non-triangular faces and requires an index
    buffer to map triangular faces to the square faces of our model.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding textures and lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create a simple 3D model using position buffers and
    index buffers, let's make a wooden crate by wrapping our model with a crate texture
    and then adding some ambient and directional lighting to create shaded surfaces.
    This recipe introduces texture buffers to create textures and normal buffers which
    are required to handle lighting effects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding textures and lighting](img/1369_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a rotating crate with lihting in WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initBuffers()` function which initializes the position buffer,
    normal buffer, texture buffer, and the index buffer for our cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` function which sets the perspective, sets the model-view
    matrix to the identity matrix, translates the cube, rotates the cube, enables
    lighting, sets the ambient lighting, sets the directional lighting, pushes the
    position buffer, the normal buffer, the texture buffer, and the index buffer onto
    the graphics card, and finally draws the cube using `drawElements()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `init()` method which initializes the crate texture, sets the the
    `stage()` function, and starts the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `loadTexture()` function which creates a new texture object, creates
    a new image object, initializes the texture and starts the animation once the
    texture image has loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, initialize the WebGL wrapper object, set the shader program
    to `"TEXTURE_DIRECTIONAL_LIGHTING"`, and load the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe introduces the concept of texture buffers and normal buffers. Texture
    buffers allow us to define the orientation and scale of a texture image for each
    face of a 3D model. To define the texture buffer of our wooden crate, we need
    to map the four corners of the texture image to the four corners of each face
    of the cube.
  prefs: []
  type: TYPE_NORMAL
- en: In order to handle lighting effects with WebGL, we need to define the normals
    of the faces that make up our cube with normal buffers. Normals are vectors that
    are perpendicular to a surface. For example, the normal of a floor points straight
    up, and the normal of the ceiling points straight down. Once our normals have
    been defined, we are now in a position to set up ambient and directional lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are many other kinds of lighting effects that can be achieved
    with WebGL, this recipe focuses on the two most common—ambient and directional
    lighting , which can be used together or independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ambient lighting** refers to the general lighting of a room or world, and
    is defined with RGB. A room with an ambient lighting value of `[0,0,0]` would
    be completely dark, and a room with an ambient lighting value of `[1,1,1]` would
    be completely lit. Also, if we had a room with an ambient lighting value of `[1,0,0]`
    for example, the room would be illuminated with a red light.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directional lighting** causes the faces of 3D models that are facing towards
    the light to be lighter, and the faces of 3D models that are facing away from
    the light to be darker. Directional lighting is typically used to simulate very
    strong light sources hat are far away, such as the sun.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use both textures and directional lighting, we can set the shader program
    to `TEXTURE_DIRECTIONAL_LIGHTING` with the `setShaderProgram()` method and we
    can enable lighting with the `enableLighting()` method . Finally, we can set the
    ambient lighting of our world with the `setAmbientLighting()` method and set the
    directional lighting using the `setDirectionalLighting()` method .
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 3D world that you can explore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create some basic 3D models with textures and lighting,
    we are now in a position to create our own 3D world. In this recipe, we'll create
    three sets of buffers—cube buffers, wall buffers, and floor buffers. We can use
    the cube buffers to render randomly placed crates throughout our world, the wall
    buffers to create four walls, and the floor buffers to create a floor and a ceiling
    (we can reuse the floor buffers for the ceiling buffers since they are the same
    shape). Next, we'll add keyboard event listeners to the document so that we can
    explore the world with the arrow keys and the mouse. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a 3D world that you can explore](img/1369_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a 3D world full of randomly placed crates that
    you can explore with the keyboard and mouse in WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `glMatrix` library and the WebGL wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `Controller` constructor which initializes the view, the WebGL wrapper
    object, and the model, attaches keyboard event listeners, and loads the world
    textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `loadTextures()` method which loads the world textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getMousePos()` method which gets the mouse position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `handleMouseDown()` method which captures the start mouse position,
    camera pitch, and camera yaw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `handleMouseMove()` method which updates the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `handleKeyDown()` method which controls the user movement through
    the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `handleKeyUp()` method which sets the user side movement to `STILL`
    if the left or right arrow key has been released, and sets the user straight movement
    to `STILL` if the up or down arrow key has been released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `attachListeners()` method which attaches listeners to the canvas
    and document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `Model` constructor which initializes the camera and the buffers
    for the crates, the floor, and the wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initCratePositions()` method which generates 20 crates with random
    positions in the world and also randomly stacks crates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initCubeBuffers()` method which initializes the cube buffers for
    the crates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initFloorBuffers()` method which initializes the floor buffers
    (these buffers will be used for the ceiling as well):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initWallBuffers()` method which initializes the wall buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `initBuffers()` method which initializes the cube, floor, and wall
    buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateCameraPos()` method which is used to update the camera position
    for each animation frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `View` constructor which sets the canvas dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawFloor()` method which draws the floor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawCeiling()` method which draws the ceiling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawCrates()` method which draws the crates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawWalls()` method which draws the walls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` method which updates the camera position, clears the canvas,
    positions the world relative to the camera position, and then draws the floor,
    the walls, the ceiling, and the crates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, initialize the `Controller`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses an MVC (model, view, controller) design pattern to separate
    the drawing logic from the data logic.
  prefs: []
  type: TYPE_NORMAL
- en: The `Controller` class is responsible for directing the model and the view,
    and also manages user actions. It handles arrow key events with the `handleKeyDown()`
    and `handleKeyUp()` method s, and it also handles screen dragging with the `handleMouseDown()`
    and `handleMouseMove()` method s. In addition, the controller is also responsible
    for pre-loading all of the textures before the simulation begins.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the model is responsible for handling all of the data-setting logic. The
    data for our simulation includes the cube, floor, and wall buffers, the textures,
    the crate positions, the camera position, pitch, and yaw, and also the user movements.
    The crate positions are initialized with the `initCratePositions()` method , the
    buffers for the world are initialized with the `initCubeBuffers()` , `initFloorBuffers()`
    , and the `initWallBuffers()` methods , and the camera position, pitch, and yaw
    is updated with the `updateCameraPos()` method .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the view is responsible for rendering the 3D world using the model
    data. Buffers are pushed to the graphics card and rendered with the `drawFloor()`
    , `drawCeiling()`, `drawCrates()` , and the `drawWalls()` method s. For each animation
    frame, the `stage()` method is called which updates the camera position, clears
    the canvas, sets the lighting, and draws the scene with the aforementioned drawing
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some more ideas if you want to extend this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Add boundary conditions so that the player can't run through crates and walls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the player to jump, and perhaps even jump on top of crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create doorways to other rooms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create staircases so that the player can explore other floors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add walking sounds with the HTML5 canvas audio tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you're able to create 3D models with textures and lighting and put
    them together to form segments of a 3D world, the only thing standing between
    you and a real-life Tron is your own imagination. Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Animation class* in [Chapter 5](ch05.html "Chapter 5. Bringing
    the Canvas to Life with Animation")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
