- en: '*Chapter 5*: Linux Security Standards with Real-Life Examples'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore the reasons why Linux hosts, like any hosts,
    need some care after initial installation – and in fact, throughout their life
    – to further secure them. Along the way, we'll cover various topics to build toward
    a final "big picture" of securing your Linux hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do I need to secure my Linux hosts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-specific security considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly encountered industry-specific security standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Center for Internet Security critical controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Center for Internet Security benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux and AppArmor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be covering a number of topics, but the technical nuts
    and bolts will focus on hardening the SSH service, using our current Linux host
    or virtual machine. As in the last chapter, you may find that a second host is
    useful to test your changes as you go, but this isn't necessary to follow the
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Why do I need to secure my Linux hosts?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like almost every other operating system, the Linux install is streamlined to
    make the installation easy, with as few hiccups during and after the installation
    as possible. As we saw in earlier chapters, this often means an installation with
    no firewall enabled. In addition, the operating system version and package version
    will of course match the install media, rather than the latest version of each.
    In this chapter, we'll discuss how default settings in Linux are often not set
    to what most would consider secure, and how as an industry, we remedy this with
    legislation, regulations, and recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the initial installation being out of date, luckily, most Linux distributions
    have an auto-update process enabled. This is governed by two lines in the `/etc/apt/apt.conf.d/20auto-upgrades`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both settings are set to `1` (enabled) by default. The lines are self-explanatory
    – the first line governs whether the package lists are updated, the second turns
    true auto-update on or off. This default is not a bad setting for a desktop or
    a server that might be on the "cruise control" method of management. Note though
    that the `Unattended-Upgrade` line only enables security updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most well-managed environments, rather than unattended upgrades, you would
    expect to see scheduled maintenance windows, with upgrades and testing happening
    first on less critical servers before being deployed on more important hosts.
    In these situations, you''ll want the auto-update settings set to `0`, and to
    use manual or scripted update processes. For Ubuntu, the manual update process
    involves two commands, executed in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_05_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These can be combined in one line (see the next line of code), but you will
    have a few "Yes/No" prompts to answer during the upgrade step – first, to approve
    the entire process and volume of data. Also, you''ll be asked for decisions if
    any of your packages have changed their default behavior between versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `&&` operator executes the commands in sequence. The second command only
    executes if the first completes successfully (with a return code of zero).
  prefs: []
  type: TYPE_NORMAL
- en: But wait, you say, some of my hosts are in the cloud – what about them? In the
    next section, you'll find that Linux is Linux no matter where you install it,
    and in some cases, your cloud instances might be less secure than your "in the
    data center" server template. No matter what your operating system or where you
    deploy, updates will be a key piece of your security program.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-specific security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are spinning up virtual machines in any of the major clouds with their
    default images, there are a few things to consider from a security point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: Some clouds have auto-updates enabled; some do not. However, everyone's image
    for every OS is always somewhat out of date. After you spin up a VM, you will
    need to update it, the same as you would a standalone host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most cloud service images also have a host firewall, enabled in some restrictive
    mode. What these two firewall issues mean for you is, when you bring up your first,
    fresh Linux VM, don't expect to be able to "ping" it until you've had a peek at
    the host firewall configuration (remember from the last chapter – be sure to check
    both `iptables` and `nftables`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many cloud service images will by default allow remote access directly for administrative
    access from the public internet. In the case of Linux, this means SSH over `tcp/22`.
    While this default setting for access is less common than in the earlier days
    of the various cloud service providers, it's still wise to check that you don't
    have SSH (`tcp/22`) open to the entire internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often you may be using a cloud "service" rather than an actual server instance.
    For instance, a serverless database instance is common, where you have full access
    and control of your database, but the server hosting it is not visible to your
    users or application. The underlying server may be dedicated to your instance,
    but more likely, it will be shared across multiple organizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've discussed some differences between on-premise and cloud Linux
    deploys, let's discuss some differences in security requirements between industries.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly encountered industry-specific security standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many industry-specific guidance and regulatory requirements, some
    of which you may be familiar with even if you're not in that industry. As they
    are industry-specific, we'll describe each at a high level – if any of these apply
    to you, you'll know that each of these is worthy of a book (or several books)
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_05_Table_02a.jpg)![](img/B16336_05_Table_02b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While each of these standards and regulatory or legal requirements have an industry-specific
    focus, many of the underlying recommendations and requirements are very similar.
    The **Center for Internet Security** (**CIS**) "critical controls" are often used
    when there is no set of regulations that provide good security guidance. In fact,
    these controls are often used in conjunction with regulatory requirements to provide
    a better overall security posture.
  prefs: []
  type: TYPE_NORMAL
- en: The Center for Internet Security critical controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While CIS' critical controls aren't standards for compliance, they are certainly
    an excellent foundation and a good working model for any organization. The critical
    controls are very practical in nature – rather than being compliance-driven, they
    are focused on real-world attacks and defending against them. The understanding
    is that if you focus on the controls, in particular, if you focus on them in order,
    then your organization will be well defended against the more common attacks seen
    "in the wild." For instance, just by looking at the order, it's apparent that
    you can't secure your hosts (**#3**) unless you know what hosts are on your network
    (**#1**). Similarly, logging (**#8**) isn't effective without an inventory of
    hosts and applications (**#2** and **#3**). As an organization works its way down
    the list, it quickly reaches the objective of not being the "slowest gazelle in
    the herd."
  prefs: []
  type: TYPE_NORMAL
- en: As with the CIS benchmarks, the critical controls are authored and maintained
    by volunteers. They are also revised over time – this is key as the world changes
    as time, operating systems, and attacks march on. While the threats of 10 years
    ago are still mostly with us, we now have new threats, we have new tools, and
    malware and attackers use different methods than we saw 10 years ago. This section
    describes version 8 of the critical controls (released in 2021), but be sure to
    reference the most current version if you are using the controls to make decisions
    in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The critical controls (version 8) are broken into three implementation groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation group 1 (IG1) – basic controls**'
  prefs: []
  type: TYPE_NORMAL
- en: These controls are where organizations normally start. If these are all in place,
    then you can have some assurance that your organization is no longer *the slowest
    gazelle in the herd*. These controls are targeted toward smaller IT groups and
    commercial/off-the-shelf hardware and software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation group 2 (IG2) – medium-sized enterprises**'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation group 2 controls expand on the IG1 controls, adding technical
    guidance for more specific configurations and technical processes that should
    be in place. This group of controls targets larger organizations, where there
    is a single person or a small group who has responsibility for information security,
    or who has regulatory compliance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation group 3 (IG3) – larger enterprises**'
  prefs: []
  type: TYPE_NORMAL
- en: These controls target larger environments with established security teams and
    processes. Many of these controls have more to do with the organization – working
    with staff and vendors and having policies and procedures for incident response,
    incident management, penetration tests, and red team exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Each implementation group is a super-set of the previous, so IG3 includes both
    groups 1 and 2\. Each control has several sub-sections, and it is these sub-sections
    that are classified by the implementation group. For a full description of each
    control and implementation group, the source document for the critical controls
    is freely downloadable at [https://www.cisecurity.org/controls/cis-controls-list/](https://www.cisecurity.org/controls/cis-controls-list/),
    with both a click-through for descriptions as well as detailed PDF and Excel documents.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_05_Table_03a.jpg)![](img/B16336_05_Table_03b.jpg)![](img/B16336_05_Table_03c.jpg)![](img/B16336_05_Table_03d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've discussed the critical controls, how does that translate to securing
    a Linux host or a Linux-based infrastructure that you might see in your organization?
    Let's look at some specific examples, starting with critical controls number 1
    and 2 (hardware and software inventory).
  prefs: []
  type: TYPE_NORMAL
- en: Getting a start on CIS critical security controls 1 and 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An accurate inventory of both hosts on the network and software running on each
    of those hosts is a key part of almost every security framework – the thinking
    being that you can't secure something if you don't know that it's there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how we might do that for our Linux host with a zero-budget approach,
    using critical controls 1 and 2 as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Critical control 1 – hardware inventory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's use the native Linux commands to explore critical controls 1 and 2 – hardware
    and software inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardware inventory is easily obtainable – many system parameters are easily
    available as files, located in the `/proc` directory. The `proc` filesystem is
    virtual. The files in `/proc` are not real files; they reflect the operating characteristics
    of the machine. For instance, you can get the CPU (only the first CPU is shown
    in this output) just by looking at the correct files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Memory information is easy to find as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Digging deeper into the `/proc` filesystem, we can find the settings on various
    IP or TCP parameters in many separate, discrete files in `/proc/sys/net/ipv4`
    (this listing is complete and formatted for easier viewing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Going past the hardware, there are multiple methods for getting the operating
    system version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Most organizations choose to put the operating system information into the hardware
    inventory, though it's certainly just as correct to place it in the software inventory
    for that machine. In almost every operating system though, the installed applications
    will update at a more frequent cadence than the operating system, which is why
    the hardware inventory is so frequently the choice that is made. The important
    thing is that it's recorded in one inventory or the other. In most systems, the
    hardware and software inventory systems are the same system anyway, so that settles
    the discussion nicely.
  prefs: []
  type: TYPE_NORMAL
- en: The `lshw` command is a nice "give me everything" command for a hardware inventory
    – the man page for `lshw` gives us additional options to dig deeper or be more
    selective in the display of this command. This command can collect too much information
    though – you'll want to be selective!
  prefs: []
  type: TYPE_NORMAL
- en: 'Organizations often find a good compromise by writing a script to collect exactly
    what they need for their hardware inventory – for instance, the short script that
    follows is useful for basic hardware and OS inventory. It takes several files
    and commands we''ve used so far and expands on them by using a few new commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fdisk` for disk information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg` and `dmidecode` for system information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for your lab Ubuntu VM might look something like this (this example
    is a virtual machine). Note that we''re using `sudo` (mostly for the `fdisk` command,
    which needs those rights):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the information needed to populate our hardware inventory, let's look at
    our inventory of software next.
  prefs: []
  type: TYPE_NORMAL
- en: Critical control 2 – software inventory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To inventory all installed packages, the `apt` or `dpkg` commands can be used.
    We''ll use this command to get a list of installed packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that with this many packages, it's best to either know what you are looking
    for and make a specific request (maybe by using the `grep` command), or to collect
    everything for multiple hosts, then use a database to find hosts that don't match
    on one thing or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dpkg` command will give us similar information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the files included in a package, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To list all installed packages in most Red Hat distribution variants, use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information on a specific package, use `rpm -qi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For more information, on all packages (perhaps too much information), use `rpm
    -qia`.
  prefs: []
  type: TYPE_NORMAL
- en: These lists, as you can see, are very granular and complete. You may choose
    to inventory everything – even a complete text listing (with no database) can
    be valuable. If you have two similar hosts, you can use the `diff` command to
    see differences between two similar workstations (one working, one not).
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are troubleshooting, it's common to check installed versions against
    known bugs, or file dates against known install dates, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory approaches discussed to date are all native to Linux but are not
    well suited to managing a fleet of hosts, or really even to managing one host
    well. Let's explore OSQuery, a management package that simplifies making progress
    on many of the critical controls and/or any regulatory frameworks you may need
    to comply with.
  prefs: []
  type: TYPE_NORMAL
- en: OSQuery – critical controls 1 and 2, adding in controls 10 and 17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than maintaining thousands of lines of text files as an inventory, a
    more common approach is to use an actual application or platform to maintain your
    inventory – either live on the hosts, in a database, or in some combination. OSQuery
    is a common platform for this. It gives administrators a database-like interface
    to the live information on the target hosts.
  prefs: []
  type: TYPE_NORMAL
- en: OSQuery is a common choice because it handles the most popular Linux and Unix
    variants, macOS, and Windows in one interface. Let's dive into the Linux side
    of this popular platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to install OSQuery, we''ll need to add the correct repository. For Ubuntu,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import the repository''s signing keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the package list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can install `osquery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'OSQuery has three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_05_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the installation done, let''s explore the interactive shell. Note that
    without setting up the daemon and "connecting" your various hosts, we''re using
    a virtual database and only looking at our local host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s take a look at the database tables that we have available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are dozens of tables that keep track of all kinds of system parameters.
    Let''s look at the OS version, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, to collect the local interface IP and subnet mask, excluding the loopback,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, to retrieve the local ARP cache, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, list the installed packages (note that this output is capped at 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also query running processes (display is capped at 10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can add additional information to our process list. Let's add the `SHA256`
    hash value for each process. A hash is a mathematical function that uniquely identifies
    data. For instance, if you have two files with different names but the same hash,
    they are very likely identical. While there's always a small possibility that
    you'll get a hash "collision" (the same hash for two non-identical files), hashing
    them again with a different algorithm removes any uncertainty. Hashing data artifacts
    is used extensively in forensics – in particular, in gathering evidence to prove
    the integrity of the chain of custody.
  prefs: []
  type: TYPE_NORMAL
- en: Even in forensic analysis though, a single hash value is usually enough to establish
    uniqueness (or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this mean for running processes? If your malware uses a random name
    in each instance to evade detection, hashing the process in RAM for all Linux
    hosts allows you to find identical processes on different hosts, running with
    different names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This tool can be particularly effective in an incident response situation. With
    just the queries we've listed in these few pages, we can quickly find hosts with
    specific OS or software versions – in other words, we can find hosts that are
    vulnerable to a specific attack. In addition, we can collect the hash values of
    all running processes, to find malware that might be masquerading as a benign
    process. All of this can be accomplished with just a few queries.
  prefs: []
  type: TYPE_NORMAL
- en: This last section took the high-level directives in the critical controls and
    translated them to "nuts-and-bolts" commands in Linux to achieve those goals.
    Let's see how that differs from more prescriptive and operating system or application-specific
    security guidance – in this case, applying a CIS benchmark to a host implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The Center for Internet Security benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CIS publishes security benchmarks that describe the security configuration of
    any number of infrastructure components. This includes all facets of several different
    Linux distributions, as well as many applications that might be deployed on Linux.
    These benchmarks are very "prescriptive" – each recommendation in a benchmark
    describes the problem, how to resolve it using OS commands or configurations,
    and how to audit for the current state of the setting.
  prefs: []
  type: TYPE_NORMAL
- en: A very attractive feature of the CIS benchmarks is that they are written and
    maintained by groups of industry experts who volunteer their time to make the
    internet a safer place. While vendors do participate in developing these documents,
    they are group efforts and the final recommendations need the consensus of the
    group. The end result is a vendor-agnostic, consensus- and community-driven document
    with very specific recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: The CIS benchmarks are created both to build a better platform (whatever the
    platform is) and to be audited against, so each recommendation has both a remediation
    and an audit section. The detailed explanations on each benchmark are key, so
    that the administrator has a good idea of not only what they are changing but
    why. This is important as not all recommendations might apply to every situation,
    and in fact, sometimes recommendations will conflict with each other, or result
    in specific things not working on the target system. These situations are described
    in the documents as they come up, but this emphasizes the importance of not implementing
    all recommendations to their maximum potential! It also makes it clear in an audit
    situation that striving for "100%" is not in anyone's best interest.
  prefs: []
  type: TYPE_NORMAL
- en: Another key feature of these benchmarks is that they are usually two benchmarks
    in one – there will be recommendations for "regular" organizations, as well as
    more stringent recommendations for higher-security environments.
  prefs: []
  type: TYPE_NORMAL
- en: CIS does maintain an auditing application **CIS-CAT** (**Configuration Assessment
    Tool**) that will assess infrastructure against its benchmarks, but many industry-standard
    tools such as security scanners (such as Nessus) and automation tools (such as
    Ansible, Puppet, or Chef) will assess target infrastructure against the applicable
    CIS benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what the benchmarks are meant to accomplish, let's take
    a look at a Linux benchmark, in particular, one set of recommendations in that
    benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a CIS benchmark – securing SSH on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When securing a server, workstation, or infrastructure platform, it's helpful
    to have a list of things that you'd like to secure, and how to accomplish that.
    This is what the CIS benchmarks are for. As discussed, you likely will never completely
    implement all recommendations in any CIS benchmark on any one host – security
    recommendations will often impair or disable services you might need, and sometimes
    recommendations will conflict with each other. This means that benchmarks are
    often evaluated carefully, and used as a primary input for an organization-specific
    build document.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the CIS benchmark for Ubuntu 20.04 to secure the SSH service on our
    host. SSH is the main method of remotely connecting to and administering Linux
    hosts. This makes securing the SSH server on your Linux host an important task,
    and often the first configuration task after the network connection is established.
  prefs: []
  type: TYPE_NORMAL
- en: First, download the benchmark – the benchmark documents for all platforms are
    located at [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
    If you aren't running Ubuntu 20.04, download the benchmark that is the closest
    match to your distribution. You'll find that SSH is such a common service that
    the recommendations for securing the SSH service are pretty consistent between
    distros, and often have matching recommendations on non-Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, update the repo list and upgrade the OS packages – note again
    how we''re running two commands at once. Using a single `&` terminator on a command
    runs it in the background, but using `&&` runs two commands in sequence, the second
    one executing when the first one completes successfully (that is, if it has a
    "return value" of zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about this on the `bash man` page (execute `man bash`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the OS components are updated, let''s install the SSH daemon, as it''s
    not installed by default on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In a modern Linux distro, this installs the SSH server, then does a basic configuration
    and starts the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get to securing this. Looking in the Ubuntu benchmark, in the SSH
    section, we see 22 separate recommendations for a wide variety of configuration
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Configure the SSH Server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.1 Ensure permissions on `/etc/ssh/sshd_config` are configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.2 Ensure permissions on SSH private host key files are configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.3 Ensure permissions on SSH public host key files are configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.4 Ensure SSH `LogLevel` is appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.5 Ensure SSH X11 forwarding is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.6 Ensure SSH `MaxAuthTries` is set to `4` or less.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.7 Ensure SSH `IgnoreRhosts` is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.8 Ensure SSH `HostbasedAuthentication` is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.9 Ensure SSH root login is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.10 Ensure SSH `PermitEmptyPasswords` is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.11 Ensure SSH `PermitUserEnvironment` is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.12 Ensure only strong ciphers are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.13 Ensure only strong MAC algorithms are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.14 Ensure only strong key exchange algorithms are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.15 Ensure an SSH idle timeout interval is configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.16 Ensure SSH `LoginGraceTime` is set to one minute or less.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.17 Ensure SSH access is limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.18 Ensure an SSH warning banner is configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.19 Ensure SSH PAM is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.20 Ensure SSH `AllowTcpForwarding` is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.21 Ensure SSH `MaxStartups` is configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.22 Ensure SSH `MaxSessions` is limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate how these work, let's look in more detail at two recommendations
    – disabling direct login of the root user (5.2.9) and ensuring that our encryption
    ciphers are strings (5.2.12).
  prefs: []
  type: TYPE_NORMAL
- en: Ensure SSH root login is disabled (5.2.9)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recommendation is to ensure that users all log in with their named accounts
    – the user "root" should never log in directly. This ensures that any log entries
    that might indicate a configuration error or malicious activity will have a real
    person's name attached to them.
  prefs: []
  type: TYPE_NORMAL
- en: The term for this is "non-repudiation" – if everyone has their own named accounts,
    and there are no "shared" accounts, then in the event of an incident, nobody can
    claim "everyone knows that password, it wasn't me."
  prefs: []
  type: TYPE_NORMAL
- en: 'The audit command for this is to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This default setting is non-compliant. We want this to be "no." The `without-password`
    value indicates that you can log in as root using non-password methods (such as
    using certificates).
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we''ll look in the remediation section. This tells us to edit
    the `/etc/ssh/sshd_config` file, and add the line `PermitRootLogin no`. `PermitRootLogin`
    is commented out (with a `#` character), so we''ll either uncomment that out or,
    better yet, add our change directly under the commented value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Edits made to the sshd_config file to deny root login over SSH'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_05_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Edits made to the sshd_config file to deny root login over SSH
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll rerun our audit check, and we''ll see that we''re now in compliance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With that recommendation implemented, let's look at our situation on SSH ciphers
    (CIS benchmark recommendation 5.2.12).
  prefs: []
  type: TYPE_NORMAL
- en: Ensure only strong ciphers are used (5.2.12)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This check ensures that only strong ciphers are used to encrypt the actual
    SSH traffic. The audit check indicates that we should run `sshd –T` again, and
    look for the "ciphers" line. We want to ensure that we only have known string
    ciphers enabled, which at this time is a short list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aes256-ctr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aes192-ctr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aes128-ctr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, known weak ciphers for SSH include any `DES` or `3DES` algorithm,
    or any block cipher (appended with `cbc`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check our current settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While we have the known compliant ciphers in the list, we also have some non-compliant
    ones. This means that an attacker could, with the right placement, "downgrade"
    the negotiated cipher to a less secure one as the session is established.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the remediation section, we''re instructed to look at the same file and
    update the "ciphers" line. Looking in the file, there is no "Ciphers" line at
    all, just a `Ciphers and keyring` section. This means that we''ll need to add
    that line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Keep the comment as is. So, for instance, if keyrings are needed later, the
    placeholder for them is there to find. It's always advisable to keep or add as
    many comments as possible – keeping configurations as "self-documenting" as possible
    is a great way to make things easy for the next person who may need to troubleshoot
    the change you just made. In particular, if years have passed and that next person
    is a future version of yourself!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll reload the `sshd` daemon to ensure that all of our changes are
    live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, rerun our audit check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: 'How else could we check cipher support on our host? This cipher change is an
    important setting that will likely need to be set on many systems, some of which
    might not have a Linux command line or `sshd_config` file that we can directly
    edit. Think back one chapter. We''ll check this setting from a remote system using
    `nmap`, with the `ssh2-enum-algos.nse` script. We''ll be looking at the `Encryption
    Algorithms` script output section for the ciphers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using a second tool to verify your configuration is an important habit to cultivate
    – while Linux is a reliable server and workstation platform, bugs do crop up.
    Plus, it's an easy slip of the finger to make your changes, then exit, but accidentally
    not save the configuration change – a double-check using another tool is a great
    way to ensure that things are as they should be!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you are ever audited, arrange for a penetration test, or have actual
    malware on your network, it's likely that in each of these situations a network
    scan will be done to look for weak algorithms (or worse yet, Telnet or `rsh`,
    both of which are in cleartext). If you use the same tools and methods as your
    attacker (or auditor), you are more likely to catch that one host that got missed
    or that one group of hosts with the SSH bug you weren't expecting!
  prefs: []
  type: TYPE_NORMAL
- en: 'What other key things should you check? While all of the settings for SSH are
    worth checking, a few of the others are key in every situation and environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Check your **SSH logging level**, so that you know who logged in from what IP
    address (5.2.4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **key exchange** and **MAC algorithms** checks are in the same vein as the
    ciphers check; they strengthen the protocol itself (5.2.13 and 5.2.14).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll want to set an **idle timeout** (5.2.15). This is key because an unattended
    admin login can be a dangerous thing, for instance, if an administrator forgets
    to lock their screen. Also, if you have a person who is in the habit of closing
    their SSH window instead of logging out, on many platforms those sessions do not
    close. If you reach the maximum number of sessions (after a few months of this),
    the next connection attempt will fail. To resolve this, you'll need to get to
    the physical screen and keyboard to resolve this (restarting SSHD, for instance)
    or reload the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll want to set the **MaxSessions limit** (5.2.22). Especially if your host
    faces a hostile network (which is every network these days), an attack that simply
    starts hundreds of SSH sessions could exhaust resources on the host, impacting
    the memory and CPU available to other users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As discussed though, each recommendation in each section of the benchmarks should
    be reviewed and assessed to see how suitable it will be for your environment.
    It's common in this process to create a build document for your environment, a
    "gold image" host that you can then use as a template to clone production hosts
    going forward, and an audit script or a hardening script to help in maintaining
    your hosts once they are running.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux and AppArmor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux has two commonly used **Linux Security Modules** (**LSMs**) that add additional
    security policies, controls, and changes to default behavior to the system. In
    many cases, they modify the Linux kernel itself. Both are available for most Linux
    distributions, and both carry some degree of risk in implementation – you'll want
    to do some preparation before implementing to gauge what the impact of implementing
    one or the other might be. It's not recommended to implement both, as they are
    likely to conflict.
  prefs: []
  type: TYPE_NORMAL
- en: '**SELinux** is arguably more complete and is definitely more complex to administer.
    It''s a set of kernel modifications and tools that are added to the base install.
    At a high level, it separates the configuration of security policies and the enforcement
    of those policies. Controls include **Mandatory Access Control**, **Mandatory
    Integrity Control**, **Role-Based Access Control** (**RBAC**), and **type enforcement**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Separating the definition of security policies from the enforcement of those
    policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-defined interfaces to policies (via tools and APIs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing applications to query for the policy definition or specific access
    controls. A common example would be allowing `crond` to run scheduled jobs in
    the correct context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for modifying default policies or creating entirely new custom policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measures for protecting system integrity (domain integrity) and data confidentiality
    (multilevel security).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controls over process initialization, execution, and inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional security controls over filesystems, directories, files, and open
    file descriptors (for example, pipes or sockets).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security controls for sockets, messages, and network interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controls over the use of "capabilities" (RBAC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where possible, anything not permitted in a policy is denied. This "default
    deny" approach is one of the root design tenets of SELinux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AppArmor** has many of the same features as SELinux, but it works with file
    paths instead of applying labels to files. It also implements mandatory access
    controls. You can assign a security profile to any application, including filesystem
    access, network permissions, and execution rules. This list also nicely outlines
    that AppArmor also enforces RBAC.'
  prefs: []
  type: TYPE_NORMAL
- en: Since AppArmor doesn't use file labels, this makes it agnostic as far as the
    filesystem is concerned, making it the only option if a filesystem doesn't support
    security labels. On the other hand, it also means that this architecture decision
    limits it from matching all of the capabilities of SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: 'AppArmor features include restrictions on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: File access controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control of library loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control of process execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coarse-grained controls over network protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coarse owner checks on objects (requires Linux kernel 2.6.31 or newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both LVMs have a learning option:'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux has a permissive mode, which means that the policies are enabled but
    not enforced. This mode allows you to test applications, then check the SELinux
    logs to see how your application might be affected when policies are enforced.
    The SELinux mode can be controlled by editing the `/etc/selinux/config` file,
    and changing the `selinux` line to **enforcing**, **permissive**, or **disabled**.
    A system reboot is required after making this change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AppArmor's learning mode is called `aa-complain`. To activate this for all profiled
    applications, the command is `aa-complain/etc/apparmor.d/*`. After activating
    learning mode, then testing an application, you can see how it might be affected
    by AppArmor with the `aa-logprof` command (you'll need the full path to the profiles
    and logs for this command for this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check the status of either LVM, the commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For SELinux, the command is `getenforce`, or for more verbose output, `sestatus`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For AppArmor, the analogous commands are `apparmor status` and `aa-status`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, AppArmor and SELinux are both complex systems. SELinux is considered
    to be much more complex, but also more complete. If you embark on the path of
    either approach, you'll want to kick the tires on a test system first. It is also
    wise to test and build your production configuration as much as possible on a
    clone of your production hosts before deploying for real. Both solutions can significantly
    increase the security posture of your hosts and applications, but both require
    a significant setup effort, as well as an ongoing effort to keep your hosts and
    applications running as they should, as they change over time.
  prefs: []
  type: TYPE_NORMAL
- en: A more complete explanation of these two systems is beyond the scope of this
    book – both have several books dedicated to them if you wish to explore either
    more fully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The end goal of everything we've discussed – the regulatory frameworks, the
    critical controls, and the security benchmarks – is to make it easier to better
    secure your hosts and data centers. The key in each of these guidance constructs
    is to give you enough direction to get you where you need to go, without having
    to be a security expert. Each in turn gets more and more specific. The regulatory
    frameworks are generally very broad, leaving a fair amount of discretion in how
    things are accomplished. The critical controls are more specific, but still allow
    a fair amount of leeway in what solutions are deployed and how the end goal is
    accomplished. The CIS benchmarks are very specific, giving you the exact commands
    and configuration changes needed to accomplish your goal.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that with the journey we've taken in this chapter, you have a good idea
    of how these various sets of guidance approaches can be combined in your organization
    to better secure your Linux infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss implementing DNS services on Linux. If you
    feel like you'd like to continue with more specifics on securing your host, don't
    worry – you'll find that this security discussion comes up again and again as
    we implement new services.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: What US legislation is used to define privacy requirements in IT implementations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you be audited against the CIS critical controls?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you routinely use multiple methods to check one security setting –
    for instance, encryption algorithms for SSH?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can check out
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'PCIDSS: [https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HIPAA: [https://www.hhs.gov/hipaa/index.html](https://www.hhs.gov/hipaa/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NIST: [https://csrc.nist.gov/publications/sp800](https://csrc.nist.gov/publications/sp800)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FEDRAMP: [https://www.fedramp.gov/](https://www.fedramp.gov/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DISA STIGs: [https://public.cyber.mil/stigs/](https://public.cyber.mil/stigs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GDPR: [https://gdpr-info.eu/](https://gdpr-info.eu/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PIPEDA: [https://www.priv.gc.ca/en/privacy-topics/privacy-laws-in-canada/the-personal-information-protection-and-electronic-documents-act-pipeda/](https://www.priv.gc.ca/en/privacy-topics/privacy-laws-in-canada/the-personal-information-protection-and-electronic-documents-act-pipeda/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CIS: [https://www.cisecurity.org/controls/](https://www.cisecurity.org/controls/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://isc.sans.edu/forums/diary/Critical+Control+2+Inventory+of+Authorized+and+Unauthorized+Software/11728/](https://isc.sans.edu/forums/diary/Critical+Control+2+Inventory+of+Authorized+and+Unauthorized+Software/11728/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'CIS benchmarks: [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OSQuery: [https://osquery.readthedocs.io/en/stable/](https://osquery.readthedocs.io/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SELinux: [http://www.selinuxproject.org/page/Main_Page](http://www.selinuxproject.org/page/Main_Page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AppArmor: [https://apparmor.net/](https://apparmor.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
