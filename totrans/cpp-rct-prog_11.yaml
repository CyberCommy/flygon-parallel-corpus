- en: Design Patterns and Idioms for C++ Rx Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered quite a bit of ground in using reactive programming model with
    C++. So far, we have learned about the RxCpp library and its programming model,
    key elements of the RxCpp library, reactive GUI programming and the topic of writing 
    custom Operators. Now, to take the matter to the next level, we will cover some
    Design patterns and Idioms which help us in advanced software development tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to patterns and the pattern movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOF design patterns and reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some reactive programming patterns and idioms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OOP and Design patterns movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Object Oriented Programming** (**OOP**)  reached critical mass in early
    90s when the C++ programming language began to make inroads into  areas where
    C programming language  was the primary programming language.  After the advent
    of Microsoft C++ compiler in the year 1992 ,  followed by Microsoft Foundation
    Class (MFC)  library, the C++ programming became mainstream under Microsoft Windows.
    In the  POSIX world,  C++ GUI toolkits like WxWidgets, and Qt,signaled the arrival
    of OOP.   The early pioneers of the  OOP movement wrote articles in various magazines
    like Dr. Dobb's Journal , C++ Report  ,Microsoft Systems Journal and so on., to
    propagate their ideas.
  prefs: []
  type: TYPE_NORMAL
- en: James Coplien published an influential book titled *Advanced C++ Styles and
    Idioms*, which dealt with the low-level patterns (idioms) associated with usage
    of the C++ programming language. Even though it is not widely cited, authors of
    this  book consider it as a  notable book for cataloging best practices and techniques
    of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Erich Gamma began to work on a pattern catalog as part of his Ph.D. thesis,
    getting inspiration from  Christopher Alexander''s *A Pattern of Towns and building* 
    book.  While working on the thesis, people with similar thoughts, namely Ralph
    Johnson, John Vlissides, and Richard Helm, joined hands with Erich Gamma to create
    a catalog of 23 Design patterns, now known as **Gang of Four** (**GOF**) Design
    patterns. The Addison Wesley published the book *Design Patterns : Elements of
    Reusable Object-Oriented Software* in the year  1994, based on their work. This
    soon became a great reference for programmers, and fueled pattern oriented software
    development. The GOF catalog was mostly focused on software design and soon pattern
    catalogs began to appear in areas like architecture,enterprise application integration,
    enterprise application architecture and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, a group of engineers from Siemens published the book, *Pattern Oriented
    Software Architecture (POSA)*, which mainly focused on architectural aspects of
    building a system. The entire POSA pattern catalog was documented in five books,
    published by John Wiley and Sons. A flood of activity followed the two preceding
    initiatives. Other notable  pattern catalogs are given below
  prefs: []
  type: TYPE_NORMAL
- en: '*Patterns of Enterprise Application Architecture*, by Martin Fowler, et al.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enterprise Integration Patterns*, by Gregor Hope and Boby Wulf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Core J2EE Patterns*, by Deepak Alur, et al.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain Driven Design*, by Eric Evans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Enterprise Patterns and the MDA*, by Jim Arlow and Illa Neustadt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though these books were significant in their own right, they were skewed
    towards the then-burgeoning area of enterprise software development. For C++ developers,
    the GOF catalog and POSA catalog are the most important.
  prefs: []
  type: TYPE_NORMAL
- en: Key Pattern catalogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pattern is a named solution for a commonly occurring problem in software design.
    Patterns are most often cataloged in some kind of repository. Some of them are
    published as books. The most popular and widely used pattern catalog is GOF.
  prefs: []
  type: TYPE_NORMAL
- en: The GOF catalog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Gang of Four (GOF), named after creators of the catalog, started the pattern
    movement. The creators were mostly focused on design and architecture of  object
    oriented software. The ideas of Christopher Alexander were borrowed from building
    architecture and applied   to software engineering .Soon, people began pattern
    initiatives in  the area of  application architecture, concurrency, security,
    and so on. The Gang Of Four divided the catalog into structural, creational, and
    behavioral patterns. The original book used C++ and Smalltalk for explaining the
    concepts. These patterns have been ported and leveraged in most of the OOP languages
    that exist  today. The table below lists patterns from the GOF catalog.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sl. No.** | **Pattern Type** | **Patterns** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Creational patterns | Abstract Factory, Builder, Factory Method, Prototype,
    Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Structural patterns | Adapter, Bridge, Composite, Decorator, Facade,
    Flyweight, Proxy |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Behavioral patterns | Chain of Responsibility, Command, Interpreter,
    Iterator, Mediator, Memento, Observer , State, Strategy, Template Method, Visitor
    |'
  prefs: []
  type: TYPE_TB
- en: We believe that a good understanding of GOF patterns is necessary for any programmer.
    These patterns occur everywhere, regardless of the application domain. GOF patterns
    help us to communicate and reason about  software systems in a language agnostic
    manner. They are widely implemented in the C++, .NET and Java worlds. The Qt framework
    leverages patterns in the GOF repository extensively, for giving an intuitive
    programming model in the C++ programming language., primarily for writing GUI
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The POSA catalog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Patterns of Software Architecture* (five volumes) is an influential book series,
    which covers most of the applicable patterns for developing mission critical systems.
    The catalog is good for people who write mission critical sub-systems of large
    software, especially database engines, distributed systems, middleware systems,
    and so on. Another advantage of the catalog is that it is well suited for C++
    programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: The catalog, which spans five published volumes, is worthy of independent study.
    This catalog is quite handy if we want to write Industrial strength middleware
    software like web server, protocol servers ,database servers and so on.    The
    following table contains a list of pattern types and associated patterns
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sl. No.** | **Pattern Type** | **Patterns** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Architectural | Layers, Pipes and Filters, Blackboard, Broker, MVC, Presentation-Abstraction-Control,
    Microkernel, Reflection |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Design | Whole-Part, Mater-Slave, Proxy, Command Processor, View Handler,
    Forwarder-Receiver, Client-Dispatcher-Server, Publisher-Subscriber |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Service access and configuration patterns | Wrapper Façade, Component
    Configurator, Interceptor, Extension Interface |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Event handling patterns | Reactor, Proactor, Asynchronous Completion
    Token, Acceptor-Connector |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Synchronization patterns | Scoped Locking, Strategized Locking, Thread-Safe
    Interface, Double-Checked Locking Optimization |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Concurrency patterns | Active Object, Monitor Object, Half-Sync/Half-Async,
    Leader/Followers, Thread-Specific Storage |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Resource acquisition patterns | Lookup, Lazy Acquisition, Eager Acquisition,
    Partial Acquisition |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Resource lifecycle | Caching, Pooling, Coordinator, Resource Lifecycle
    Manager |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Resource release patterns | Leasing, Evictor |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | A pattern language for distributive computing | Rather than introducing
    new patterns , a consolidation of patterns from different catalogs, in being done
    in the context of distributed programming |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | On patterns and pattern languages | This last volume gives some meta-information
    about patterns, pattern languages, and usage |'
  prefs: []
  type: TYPE_TB
- en: The POSA catalog needs to be studied to gain deep insights into the architectural
    underpinnings of large-scale systems, which are deployed across the world. We
    believe that, despite its importance, this catalog has not received the attention,
    it deserves.
  prefs: []
  type: TYPE_NORMAL
- en: The Design pattern redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GOF pattern and reactive programming do have a deeper connection than that
    is obvious from the surface. The GOF pattern is mostly concerned with writing
    OOP-based software . Reactive programming is a combination of functional programming,
    stream programming, and concurrent programming. We already learned that reactive
    programming rectifies some deficiencies in the classic GOF Observer pattern(in
    the first section of [Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml),
    *Introduction to Observables*, we covered this issue).
  prefs: []
  type: TYPE_NORMAL
- en: Writing OOP software is basically about modeling hierarchies, and from the pattern
    world, the Composite pattern is the way to model Part/Whole hierarchies. Wherever
    there is a Composite (which models a structure), a collection of Visitor pattern
    implementations (to model behavior ) will follow suit. The primary purpose of
    Visitor pattern is processing Composites. In other words, the Composite-Visitor
    duo is the canonical model  for writing object oriented systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor implementations should possess some awareness about the structure
    of Ccmposites. Behavioral processing using the Visitor pattern becomes difficult,
    as the number of Visitors for a given Composite proliferates. Moreover, adding
    transformations and filters to the processing layer  further complicates the matter.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the Iterator pattern, which is good for the navigation of a sequence,,
    or list of items. Using object/functional programming constructs, we can filter
    and transform sequences very easily. Microsoft's  LINQ  and  processing collection
    classes using lambdas in Java (8 and above) are good examples of the Iterator
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how will we transform hierarchical data into a linear structure? Most
    hierarchies can be flattened into a list for further processing. Recently, people
    have started doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling their hierarchies using the Composite pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening the hierarchy into a sequence by using a Visitor meant for the purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating those sequences using the Iterator pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a series of transformations and filters to sequences before performing
    actions on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding method is called the `pull` method of programming. Consumers
    or Clients pull data from the event or data source to process it. This scheme
    suffers from the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The data is unnecessarily pulled into the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transformations and filters are applied on the event sink (client) side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event sink can block the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The style is not good for asynchronous processing, where data varies over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good solution to the problem is to reverse the gaze, where data is pushed
    from the server asynchronously as a Stream, and the event sink will react to the
    Stream. Another advantage of this kind of system is the placement of transformations
    and filters on the event source side. This leads to a scenario where (only) data
    that is absolutely essential ,needs to be processed on the sink side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheme is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The data is treated as streams, which are called Observables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can apply a series of Operators, or higher order Operators, to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Operator always takes an Observable and returns another Observable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can subscribe to an Observable for notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observers have standard mechanisms to process them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned how OOP patterns and reactive programming are closely
    related. Judicious mixing of both paradigms produces high quality, maintainable
    code. We also discussed how OOP design patterns (Composite/Visitor) can be transformed
    (flattening the structure) to leverage Iterator pattern. We discussed how the
    scheme of iteration can be improved with a slight nudge (a fire and forget idiom
    on the event source side).to arrive at Observables.  In the next section, we will
    demonstrate the whole technique by writing code.
  prefs: []
  type: TYPE_NORMAL
- en: From Design patterns to Reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though the design pattern movement is aligned with OOP, and reactive programming
    is aligned towards FP, there are close similarities between them. In a previous
    chapter([Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml), *Introduction
    to Observables)*, we learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The OOP model is good for modeling the structural aspects of a system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FP model is good for modeling the behavioral aspects of a system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the connection between OOP and reactive programming, we will write
    a program that will traverse directories to enumerate files and sub-folders within
    a given folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a composite structure that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `FileNode` (inherits from the abstract class  `EntryNode`) that models file
    information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `DirectoryNode` (inherits from the abstract class  `EntryNode`) that models
    folder information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining the preceding Composites, we will define Visitors for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Printing filenames and folder names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a composite hierarchy to a list of filenames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without further ado, let''s get into meat of the stuff. Take a look at this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding forward declarations are undertaken to silence the compiler from
    issuing errors and warnings while compiling the program. The `FileNode` stores
    a filename and its size as an instance variable. The `DirectoryNode` stores a
    folder name and a list of `FileNode`, to indicate files and folders within a directory.
    The `FileNode`/`DirectoryNode` hierarchy is processed by the `IFileFolderVisitor`
    interface. Now, let us the declaration for these data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we create a Composite, we need to create a node class that acts as a base
    class for all members of the hierarchy. In our case, the `EntryNode` class does
    that. We store the file or folder name, the size, and so on, in the base class.
    Other than the three virtual functions, which should be implemented by the derived
    class, we have a virtual destructor, as well. The presence of a virtual destructor
    makes sure that destructors are applied properly, to avoid resource leaks. Now,
    let us see the Visitor base class declaration given below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we define a hierarchy using a Composite pattern style implementation,
    we define a Visitor interface to process nodes in the Composite. For each node
    in the Composite, there will be a corresponding  `visit` method for it in the
    Visitor interface. Every node in the class hierarchy of the Composite will have
    an `accept` method, and the Visitor interface, during traversal of the Composite,
    dispatches call to the respective node''s `accept` method. The `accept` method
    dispatches the call back to the correct `visit` method in the Visitor. This process
    is called **double dispatch**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileNode` class just stores the name and the size of the file. The class
    also implements all virtual methods declared in the base class (`EntryNode`).
    The `accept` method redirects the call to the correct Visitor level method, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `DirectoryNode` class models a folder with a list of files and sub-folders.
    We are using smart pointers to store the entry. As usual, we have also implemented
    all virtual functions associated with the `EntryNode` class. The methods `AddFile`
    and `AddDirectory` are meant to populate the list. While traversing the directory
    using the OS specific functions, we populate contents of  a `DirectoryNode`  object
    with the preceding two methods:  Let us see prototype of the directory traversal
    helper function. We have omitted the full  listing of the source code (available
    online )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `DirHelper` logic varies between Windows and GNU Linux/macOS X. We have
    omitted source code of the implementation, from the book. The associated website
    contains full source code for the preceding class. Basically, the code recursively
    traverses directories  to populate the data structure.  Now, we will move to the
    topic of traversing the Composite created above. The following code shows how
    we can traverse the Composite using  a Visitor class, which implements the IFileFolderVisitor
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `PrintFolderVisitor` class is a Visitor implementation that displays the
    file and folder information to the console. The class demonstrates how a basic
    Visitor can be implemented for a Composite. In our case, the Composite has only
    two nodes, and it is very easy to write the Visitor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain cases, the number of node types in a hierarchy are numerous, and
    writing a Visitor implementation is not trivial. Writing filters and transformations
    for Visitors can be difficult, and the logic is ad hoc. Let''s write a program
    to print the contents of a folder. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function recursively traverses a directory and creates a Composite
    (`DirectoryNode *`). We use `PrintFolderVisitor` to print the contents of the
    folder, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Flattening the hierarchy to navigate through it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Visitor implementation has to posses some idea of the structure of the
    Composite. In some instances of Composite implementation, there will be scores
    of Visitors  needs to be implemented. Moreover, applying transformations and filters
    on nodes are bit difficult in the case of Visitor interfaces. The GOF pattern
    catalog has an Iterator pattern that can be used to navigate a sequence of items.
    The problem is: How can we linearize a hierarchy for processing using the Iterator
    pattern? Most hierarchies can be flattened to a list, sequence, or stream by writing
    a Visitor implementation for that purpose. Let us write a flattening Visitor for
    the said task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FlattenVisitor` class collects files and folders in a STL list. For each
    directory, we iterate through the list of files and issue the `accept` method,using
    the familiar double dispatch.  Let us write a function that returns a list of
    `FileInformation` for us to iterate through. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `FlattenVisitor` class traverses the `DirectoryNode` hierarchy and collects
    the fully expanded pathname into a STL list container. Once we have linearized
    the hierarchy into a list, we can iterate over it.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to model a hierarchy as a Composite, and eventually flatten
    it to a form that is suitable for navigation with the Iterator pattern. In the
    next section, we will learn how Iterators can be transformed into Observables.
    We will use RxCpp to implement the Observables by using a fire and forget model,
    pushing values from the event source to the event sink.
  prefs: []
  type: TYPE_NORMAL
- en: From Iterators to Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Iterator pattern is the standard mechanism to pull data from STL containers,
    generators, and streams. They are well suited for data that has been aggregated
    in the space. Essentially, this means that we know ahead of time how much data
    is supposed to be retrieved, or that the data has already been captured. There
    are scenarios where the data arrives asynchronously and the consumers are not
    aware of how much data there is or when the data arrives. In such cases, Iterators
    need to wait, or we need to resort to timeout strategies to handle the scenario.
    In such a scenario, a push-based approach seems to be a better option. Using the
    Subject construct of Rx, we can use a fire and forget strategy. Let''s write a
    class that emits the contents of a directory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `DirectoryEmitter` class uses modern C++'s `packaged_task` construct to
    make asynchronous calls in a fire and forget manner. In the preceding listing,
    we were waiting for the result (using `std::future<T>`). We can comment a line
    in the above code listing  (see the inline comment in the listing ) to return
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The Cell pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned that reactive programming is all about processing values
    that vary over time. The reactive programming model is centered on the notion
    of Observables. There are two variants of Observables, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cells: A cell is an entity (a variable, or a memory location) where values
    are regularly updated over time. They are also called properties or behaviors,
    in some contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Streams: A stream represents a series of events. They are data that is often
    associated with actions. When people think of Observables, they have got stream
    variant of Observables in their mind.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement a toy version of a Cell programming pattern. We will only
    focus on implementing basic functionality. The code needs tidying up for production
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation can be optimized, if we are implementing a a controller
    class called Cell controller. . Then, the Cell controller class ( which contains
    a single Rx Subject for all cells)  can receive notifications from all cells (to
    a central place) and update dependencies by evaluating expressions. Here, we have
    attached  Subjects with every Cell.  This implementation shows how the Cell pattern
    is a viable mechanism for dependent computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cell class makes an assumption that each cell has two parent dependencies
    (to make the implementation simple), and whenever there is a change in value of
    parents, the cell''s value will be recalculated. We have only  implemented an
    addition operator (to keep listings small). The `recalculate` method implements
    the logic, as shown above: Let us write a main program to put everything together.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The main program demonstrates how we can use the Cell pattern to propagate changes
    down into the dependencies. By changing values in cless, we force the re-computation
    of values in the dependent cells.
  prefs: []
  type: TYPE_NORMAL
- en: The Active object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Active object is a class that decouples method invocations and method executions,
    and is well suited for fire and forget asynchronous calls. A scheduler attached
    to the class handles the execution requests. The pattern consists of six elements,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A proxy, which provides an interface for clients with publicly accessible methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface that defines the method request on an Active object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of pending requests from clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Scheduler, which decides which request to execute next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the Active object method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback or variable, for the client to receive the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will dissect an implementation of the Active object pattern. This program
    is written for elucidation; for production use, we need to use a bit more sophistication.
    Attempting a production quality implementation would make the code considerably
    longer. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation declares an instance of the `subject<T>` class,
    to act as a notification mechanism. The `FireNForget` method places the value
    into the subject by invoking the `get_subscriber` method. The method immediately
    returns, and the subscription method will retrieve the value and call the `Execute`
    method. The class is supposed to be overridden by a concrete implementation. Let''s
    take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet calls the `FireNForget` method, with a double value.
    On the console, we can see the value being displayed. The overridden `Execute`
    method is automatically invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The Resource Loan pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Loan pattern, as the  name suggest, loans a resource to a function  In
    the example given below, a file handle is loaned to consumers of the class. It
    performs following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a resource that you can use (a file handle )
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It loans the resource (file handle ) to functions  (lambdas) that will use it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function is passed by the caller and executed by the resource holder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource (file handle ) is closed or destroyed  by the resource holder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code implements the Resource Loan pattern for resource management.
    The pattern helps to avoid resource leakage when writing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Resource Loan pattern is suitable for avoiding resource leakage. The holder
    of the resource never hands over   handle or pointer of the resource to its consumers.
    The main program demonstrates how we can consume the implementation. The ResourceLoan
    class never allows its consumer to access the file handle directly.
  prefs: []
  type: TYPE_NORMAL
- en: The Event bus pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Event bus acts as a intermediary between event sources and event sinks.
    An event source, or producer, emits the events to a bus, and classes that have
    subscribed to events (consumers) will get notified. The pattern could be an instance
    of the Mediator design pattern. In an Event bus implementation, we have the following
    archetypes
  prefs: []
  type: TYPE_NORMAL
- en: '**Producers**: Classes which produce events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumers**: Classes which consume events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: Classes which act as producers and consumers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the implementation that follows, we have omitted the implementation of Controllers.
    The following code implements a toy version of an Event bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EVENT_INFO` struct models an event, and it has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id`: Event ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err_code`: Error code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: Description of the events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the code is fairly obvious; here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of the Producer class is fairly simple. The skeleton implementation
    is rather trivial. The `Fire` method takes a compatible `EventBus<T>` as a parameter
    and calls the `FireEvent` method of the `EventBus<T>` class. A production implementation
    requires some bells and whistles. Let's take a look at the code for the Consumer
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The functionality of `Consumer<T>` is pretty obvious. The `Connect` method
    does the work of subscribing to the Observable side of the Subject in the `EventBus<T>`
    class. Each time a new connection request comes in, the existing subscription
    is unsubscribed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `EventBus<T>` class acts as a conduit between the Producers and Consumers.
    We are using a `replaysubject` under the hood, to notify the Consumers. Now that,
    we have finished writing Producer and Consumer class, let us see how we can utilize
    the code written above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we are performing the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance of the `EventBus<T>`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an instance of Producers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an instance of Consumers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dispatching events to the bus
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have only covered a subset of the design patterns that are suitable for writing
    reactive programs. Primarily, our focus has been on bridging from GOF design patterns
    to the reactive programming world. In fact, authors of this book believe that
    the reactive programming model is an enhanced implementation of classic GOF design
    patterns. The enhancement is possible due to the functional programming constructs
    added to modern programming languages. In fact, object/functional programming
    is a good approach for writing modern C++ code. This chapter was largely based
    on the very idea.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the wonderful world of design patterns/idioms
    associated with C++ programming and reactive programming. Starting with GOF design
    patterns, we moved on to reactive programming patterns and  gradual transition
    from OOP to reactive programming is a highlight of this chapter.  Later,we covered
    reactive programming patterns such as Cell, Active object, Resource loan, and
    Event bus. Bridging from GOF patterns to reactive programming helps you to look
    at reactive programming in a broader sense.In the next chapter, we will learn
    about micro-service development using C++.
  prefs: []
  type: TYPE_NORMAL
