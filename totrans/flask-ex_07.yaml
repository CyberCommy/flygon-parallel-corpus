- en: Chapter 7. Adding Google Maps to Our Crime Map Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we set up a database and discussed how to add and remove
    data from it through Flask. With a web application that can do input and output
    with long-term storage, we now have the building blocks needed for nearly all
    web applications and are limited only by the power of our imagination.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add more features than the text-only interface from
    the previous chapter; we'll add embedded Google Maps that will allow a user to
    view and select geographic coordinates in an intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: Google Maps is written in JavaScript, and we'll need to write some JavaScript
    code to adapt Google Maps to our needs. As always, we'll do a whirlwind tutorial
    for readers who haven't ever used JavaScript before, but if you're interested
    in solidifying your all-inclusive web application knowledge, now is a good time
    to quickly go through a couple of JavaScript-specific tutorials. If you've never
    seen any JavaScript code before, an easy introduction that is similar to the HTML
    and CSS tutorials we provided links to before can be found at [http://www.w3schools.com/js/default.asp](http://www.w3schools.com/js/default.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguably, the most important part of a crime map is the map itself. We''ll
    use the Google Maps API, which is simple and powerful for developers and intuitive
    for users. As a first step, we''ll just add a basic map that loads to an area
    and zoom level that we choose. Once we''ve seen to this, we''ll add functionality
    to allow for markers. Markers will serve two purposes for our map: first, we''ll
    display a marker on the map in the location of every crime we have saved in our
    database; second, when the user clicks on the map, it''ll add a new marker and
    allow the user to submit a new crime report (eventually by adding a description
    and date in form fields).'
  prefs: []
  type: TYPE_NORMAL
- en: However, first we need to be able to run our application locally again for development
    and debugging. Having linked it to the database, this is a bit tricky; so, we'll
    look at how to solve this common problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running a database application locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an embedded Google Map widget to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an input form for new crimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying existing crimes on our map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a database application locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to develop and debug locally, we need to be able to run the application.
    However, at the moment, this is not possible as MySQL is only installed on our
    VPS. There are three main options to develop our database application locally:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database on our VPS even when running Flask on our local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MySQL on our local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a "mock" of our database in memory using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While any could work, we'll go with the third option. Connecting to our production
    database would cause us to be affected by latency if we develop in a location
    far from our VPS, and this would also mean that we'd run test code against our
    production database, which is never a good idea. The second option would limit
    the portability of our development environment, increase setup time if we switch
    to a new development environment, and in the worst case scenario, use up a significant
    amount of local resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mock of our database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you try to run the `crimemap.py` file locally, the first error you will see
    is `ImportError` because of the `dbconfig.py` file that we don't have. In the
    previous chapter, we created this file directly on our VPS and didn't check it
    into git as it contained sensitive database credentials. We'll create a local
    copy of `dbconfig.py`, which indicates that our application should use a mock
    database. We'll update the `dbconfig.py` file on our VPS to indicate that the
    real database should be used when the app is run from there. We'll do this with
    a simple Boolean flag.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your local `crimemap` directory, create a new `dbconfig.py` file and add
    a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, SSH into your VPS and add the flag to the production configuration as
    well; although, here, the value should be set to `False`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, type *Ctrl* + *X* followed by *Y* to save and quit the file
  prefs: []
  type: TYPE_NORMAL
- en: Now, exit the SSH session. This will solve `ImportError` (the `dbconfig.py`
    file now exists on our VPS and locally), and our application is now aware of whether
    it is running in test or production.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the mock code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our flag doesn''t actually do anything yet though, and we don''t want to trigger
    all the exceptions when we test our app. Instead, we''ll write a "mock" of our
    database code (the code in the `dbhelper.py` file) that''ll return basic static
    data or `None`. When our application runs, it will be able to call database functions
    normally, but there will be no actual database. Instead, we''ll have a few lines
    of Python to emulate a very basic database. Create the `mockdbhelper.py` file
    in your `crimemap` directory and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can note, the methods we used for our basic database application all
    exist but don''t do anything. The `get_all_inputs()` method returns an empty list,
    which we can still pass to our template. Now, we just need to tell our app to
    use this instead of the real `DBHelper` class if we are in a testing environment.
    Add the following code to the end of the imports section in `crimemap.py`, making
    sure to remove the existing `import` for `DBHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use our test flag in `dbconfig` to specify whether or not to import the real
    `DBHelper` (which relies on having a connection to MySQL) or to import the mock
    `DBHelper` (which does not need database connection). If we import the mock helper,
    we can change the name so that the rest of the code can continue to run without
    conditional checks for the test flag.
  prefs: []
  type: TYPE_NORMAL
- en: Validating our expectations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, you should be able to run the code locally, just as before we added a
    database dependency. In your terminal, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, visit `localhost:5000` in your browser to take a look at your app loading.
    Check the output of the terminal to make sure that no exceptions are triggered
    (as would be the case if you attempted to run the real `DBHelper` code instead
    of the mock ones we just made). Although our application no longer "works", we
    can at least run it to test our code that doesn't involve the database. Then,
    when we deploy to production, everything should work exactly as in our tests,
    but with a real database plugged in.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an embedded Google Maps widget to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want to add a map view to our app instead of the basic input box. Google
    Maps allows you to create a map without registration, but you will only be able
    to make a limited number of API calls. If you create this project, publish a link
    on the Web, and it goes viral, you stand a chance of hitting the limit (which
    is currently 2,500 map loads per day). If you think this will be a limiting factor,
    you can register for the maps API and have the option of paying Google for more
    capacity. However, the free version will be more than adequate for development
    and even production if your app isn't too popular.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the map to our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to display a map on the main page of our app, so this means editing
    the code in the `home.html` file in our `templates` directory. Remove all the
    existing code and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Introducing JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take a look at what happened here. The first line told our user's browser
    that we're using HTML5\. Lines 4 to 6 include the map resources we need in our
    page. Note that this is between `<script>` tags, indicating that it's JavaScript.
    In this particular case, we did not actually write the JavaScript code – we simply
    linked to where it's hosted on Google's servers. Think of this a bit as a Python
    `import` statement, except we don't even have to install the package locally;
    it's simply "imported" at runtime by your user's browser.
  prefs: []
  type: TYPE_NORMAL
- en: Directly following this is our setup script to display a basic map. Again, this
    is between `<script>` tags to indicate that it's JavaScript instead of HTML. This
    time, we actually wrote the JavaScript code ourselves though. The syntax is similar
    to Java in terms of brackets, braces, and `for` loops. Apart from this and its
    name, there is little relation between it and Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of our JavaScript code is a function definition; similar to
    Python''s "`def`" we use the `function` keyword to define a new function named
    `initialise()`. We declared a variable with `var mapOptions =` and assigned a
    new JavaScript object to this variable that looks similar to a Python dictionary.
    We define a location with a latitude-longitude tuple-like object, which we have
    access to because of Lines 4 to 6, and the object also contains a "`zoom`" level.
    These options describe our initial map: which area should be displayed and at
    what zoom level.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created a new variable, `map`, and initialized a Google map object,
    passing in the ID of an HTML element (which we'll explain in more detail in the
    following section) and the map options we just defined. We then reached the end
    of our JavaScript code, so we closed the `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The body of our HTML code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although our `<body>` section is only a couple of lines, it has some subtleties.
    The first line opens the `<body>` tag and also defines the `onload` parameter.
    This parameter takes the name of a JavaScript function that will be called automatically
    when the page is loaded. Note that the function name ("`initialize`", in our case,
    as this is the function we just wrote and want to be run automatically in order
    to create our map) is enclosed in inverted commas. This might be counterintuitive
    if you think of Python, in which inverted commas are used mainly for string literals.
    Think of it as passing the function *name* to the body block but note the fact
    that we still use the open-close brackets as part of the name.
  prefs: []
  type: TYPE_NORMAL
- en: The next line creates a `<div>` element. Normally, `<div>` does nothing except
    enclose more HTML, but this doesn't mean that an empty `<div>` block, as we have
    here, is pointless. Note the ID, `map-canvas`, that we give our `<div>`. This
    matches the name in our JavaScript code; that is, the JavaScript function will
    look for an HTML element called `map-canvas` (using `document.getElementById()`)
    and transform this into Google Maps widget. Therefore, it makes sense to use a
    `<div>` element as we want an empty element for our JavaScript code to use.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our `<div>` element also includes some inline CSS. We can define the
    width and height of our map (which is a requirement of the Google Maps API) using
    CSS's `height` and `width` attributes. In this case, we defined the map to a constant
    `height` value of `500` pixels and a `width` value of `80%` of the page. The percentage
    for the width is useful as the scrolling functionality is often overloaded with
    the zoom functionality. That is, if the user wants to scroll down on our page
    using a touchpad or mouse wheel and his or her cursor is over the map, the map
    will zoom in instead of the page scrolling down. The 20 percent "blank" space
    on the right-hand side, therefore, provides the user with somewhere to move the
    mouse to while scrolling. Similarly, for touchscreens, the user would "*pan*"
    around the map while trying to scroll, but can use this space to put his or her
    finger while scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should now be able to run our web app locally and see the embedded Google
    Map. If your app is not already running, use your terminal to start it up again
    and navigate to `localhost:5000` in your browser. As we don't store the code for
    Google Maps locally, this needs to be fetched from Google's servers, so we need
    our local machine to be online for this to work (similar to fetching the data
    we needed for our Headlines application).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging JavaScript code is a bit tricky as any errors won't be registered
    by Flask and will therefore not be seen in your app output. If your web page is
    blank or does anything unexpected, the first place to look is your browser's developer
    console. This is a developer's tool that can be found in all the major browsers,
    normally by pressing *Ctrl* + *Shift* + *C* and navigating to the "**Console**"
    tab in the window or sidebar that appears. Here, you'll note any JavaScript errors
    or warnings that your code has triggered, so this tool is invaluable in debugging
    a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the console should report line numbers along with errors, it can sometimes
    be difficult to track down exactly what is going wrong. JavaScript is a dynamically
    typed language and is infamous for having some pretty quirky and counterintuitive
    behavior. If necessary, you can also add JavaScript lines between the `<script>`
    tags in your HTML that do nothing but log in to the developer tools console. To
    do this, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to a Python `print` statement, and you can pass variables and
    most objects to see a string representation of them logged to the output. Use
    the `+` symbol to concatenate. For example, if you have a variable named "`a`"
    and you want to see its value at a specific point in code, you could add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For a more sophisticated approach to debugging, take a look at the **Debugger**
    tab of the developer tools window (or its equivalent in your browser) and play
    around with setting breakpoints in JavaScript. The developer tools are generally
    a powerful suite of tools and their full functionality is unfortunately beyond
    the scope of this book. The following screenshot shows the Mozilla Firefox developer
    console with a breakpoint set just before the map loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and debugging](img/B04312_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once all the bugs are squashed (or straight-away if you are meticulous and
    lucky), you should see a page in your browser containing an embedded Google Map
    centered on **Grahamstown**, South Africa. Play around with the zoom level and
    coordinates set by the `mapOptions` variable in your JavaScript code to get the
    initial map of your choice. Clicking and holding on the map will allow "panning"
    or moving around the world. Zooming is done by scrolling with your middle mouse
    wheel, using your touchpad, or "pinch zooming" on touchscreen. The result should
    look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and debugging](img/B04312_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now move on to making our map more interactive and useful.
  prefs: []
  type: TYPE_NORMAL
- en: Making our map interactive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first functionality we'll add to our app will allow the user to place a
    marker on the map. This will eventually allow the user to add a crime report by
    indicating where the crime took place, thus adding to our crowd-sourced database
    of crimes. We'll implement the marker functionality in JavaScript, as well, using
    a "listener".
  prefs: []
  type: TYPE_NORMAL
- en: Adding markers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is *event-driven*. Actions such as a mouse move or mouse click are
    events, and we can react to these events by setting up an event listener. The
    listener simply runs in the background, waiting for a specific event, and then
    triggers a specified action if it detects the event. We'll set up a listener for
    a mouse click, and if detected, we'll place a map marker at the location of the
    mouse when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Google Map API, this can be achieved in a few lines of code. First,
    we'll make our `map` variable global. Then, we'll create a `placeMarker()` function
    that will reference our `map` variable and place a marker on it when called. In
    our existing `initalise()` function, we'll add a click listener that will call
    the `placeMarker()` function when triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full JavaScript code can be seen here with the modified lines highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note specifically the change from `var map = new google.maps.Map` to `map =
    new google.maps.Map`. We removed the `var` declaration, which means that we assigned
    our new map to our global `map` variable instead of creating a new local variable.
  prefs: []
  type: TYPE_NORMAL
- en: The next line makes a call to `addListener()`, which might look a little odd.
    The `addListener()` function takes a `map`, `event`, and `function` to be called
    when the listener is triggered. As in Python, JavaScript has first-class functions,
    which means that we can pass functions as arguments to other functions. Unlike
    Python, we don't need to use the `lambda` keyword to create an anonymous function;
    we can simply declare the function we want to pass in place of the argument. In
    this case, we created an anonymous function that takes an `event` argument and
    in turn calls our `placeMarker()` function, passing it the `latLng` property of
    `event`. In our case, `event` is the mouse click that is picked up by the listener,
    and the `latLng` property is the location of the mouse click.
  prefs: []
  type: TYPE_NORMAL
- en: In our `placeMarker()` function, we accepted a location and created a new `Marker`
    object, placing it at the passed-in location on our map (this is why we made the
    map global; now we can refer to it in this new function).
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, when the page loads, we will add a listener that hangs around in
    the background, waiting for a click. When a click is detected, the listener makes
    a call to `placeMarker()`, passing in the coordinates of the click it detected.
    The `placeMarker()` function then adds a marker at the specified coordinates,
    meaning that the user sees a marker appear on the map as he or she clicks on the
    map. Give it a try, using the console and debugger in your browser, as we did
    before, if things don''t go as expected. You should see a new marker placed on
    the map for every click and be able to generate maps that look similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding markers](img/B04312_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using a single marker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a new marker for every click is not ideal. We actually want the user
    to be able to move the marker with each click instead of creating a new one. Adding
    more than one crime at a time would be overcomplicated and not overly useful.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, create another global `marker` variable under the existing
    global `map` variable. Then, add a simple condition to the `placeMarker()` function
    that creates a new marker only if there isn't one already and moves the location
    of the existing one otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code, again with the modified lines highlighted, is shown as follows.
    Again, note that we removed `var` from the line where we created a new `marker`
    variable, thus using the global variable instead of creating a local one. With
    these changes, each click on the map should move the marker instead of creating
    a new one. Try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding an input form for new crimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want the user to be able to specify more information than simply a location.
    The next step is to create a form that the user can use to add date, category,
    and description data to a crime submission. Each of these pieces of information
    will be stored in the database columns we created in the previous chapter. Creating
    web forms is a common enough task that there are many frameworks and plugins to
    help automate as much of the process as possible, as most forms need a pretty
    frontend, which includes error messages if the user puts in unexpected input,
    as well as backend logic to process the data and do a more thorough validation
    to prevent malformed or incorrect data from polluting the database.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the spirit of learning, we'll now create the backend and frontend
    of a web form from scratch. In our next project, we'll take a look at how to do
    something similar using various tools to make the process less laborious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to have a number of input fields to the right of our map, which
    allows the user to specify details about a witnessed or experienced crime and
    submit it to be included with our existing data. The form should have the following
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Category**: A drop-down menu that allows the user to select which category
    the crime falls into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date**: A calendar that allows the user to easily enter the date and time
    of the crime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A larger text box that allows the user to describe the crime
    in free-form text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latitude and Longitude**: Text boxes that are automatically populated based
    on the location selected using the marker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After filling the preceding fields, the user should be able to click on a **Submit**
    button and view the crime he or she just submitted appear on the map.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML code for the form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML code needed for our form is very similar to the forms created in our
    earlier project, but it has some new elements as well, namely `<textarea>` and
    `<label>` and an input with `type= "date"`. The `<textarea>` element is very similar
    to the standard text fields we noted before but appears as a larger square to
    encourage the user to enter more text. Label elements can define a `for` attribute
    to specify what we are labeling. The text between the opening and closing `label`
    tags is then shown close to the element to be labeled.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for our form as we can prompt the user about what data to enter
    in each field. The date field will provide a nice calendar drop-down menu to select
    a date. Unfortunately, it's a fairly recent addition to HTML and is not supported
    in all browsers. In unsupported browsers (including Firefox), this will be identical
    to a text input, so we'll look at how to handle dates input by the user at the
    end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we put the form inside a `<div>` element to make it easier
    to style and position on the page (we''ll also do this later). The full `<body>`
    element of our HTML page now looks as follows (note that we added a heading and
    paragraph above the map, while the form is added below the map). Take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh your page to see the form below the map. You''ll notice that it looks
    pretty terrible with different-sized fields and a horizontal layout, as in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTML code for the form](img/B04312_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's add some CSS to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding external CSS to our web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the form appear to the right of our map, we'll use CSS. We already have
    some CSS for our map, and we could add more CSS in a similar way. However, refer
    to our discussion of inline, internal, and external CSS from [Chapter 5](ch05.html
    "Chapter 5. Improving the User Experience of Our Headlines Project"), *Improving
    the User Experience of Our Headlines Project*, in the *Adding CSS to our Headlines
    application* section, and remember that having all CSS in a separate file is best
    practice. Therefore, we'll create a `style.css` file and consider how to link
    it to our Flask app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CSS file in our directory structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default in Flask, our static files should be kept in a directory called
    `static`. We''ll want to keep various kinds of files in here eventually, such
    as images, JavaScript, and CSS, so we''ll create a subdirectory called `CSS` and
    create our `style.css` file inside this. Navigate to your project directory in
    your terminal and run the following to add this directory structure and file to
    our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Adding CSS code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Insert the following CSS code into this new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll probably notice the similarities with the CSS code that we used for
    our Headlines project. However, there are still some important points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined the `width` and `height` of any element with the ID of `map-canvas`
    here (in the second-last block), so we can remove the inline style from our `body.html`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used CSS's float functionality to display our form to the right of our map
    instead of below it. The map takes up `70%` of the `width` of the page, and the
    form takes up `25%` (with the last 5% left so that the map and form have some
    space between them. Our map floats to the left of the page, while the form floats
    to the right. Because they take up less than 100% of the width combined, they'll
    be displayed side by side in the browser.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Flask to use CSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally in HTML pages, we can link to external CSS files simply by giving
    a relative path to the stylesheet. As we''re using Flask, we need to configure
    our application to return the CSS file as a static one. By default, Flask serves
    files from a directory named `static` in the route of the project, which is why
    it''s important to place the CSS file here, as described earlier. Flask can generate
    a URL for the CSS file we need to link to using the `url_for` function. In the
    `home.html` template, add the following line to the top of the `<head>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a link between our HTML and CSS. We used attributes to describe
    the link as being to a `text/css` file and that it is a stylesheet. We then gave
    its location with `href` using the `url_for()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add a line of JavaScript code to populate the location input
    automatically whenever the marker on the map is created or moved. This is achieved
    by adding the lines highlighted in the following to the `placeMarker()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These lines simply find the latitude and longitude boxes (identified by their
    `id` attribute) and insert the location used to place the marker. When we `POST`
    the form to the server, we'll be able to read these values on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, remove the inline CSS that we added earlier as this functionality
    is now the responsibility of our external stylesheet. Take a look at the following
    line in the `home.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line can be modified to instead be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reload the page in your browser to view the result. Remember that CSS and JavaScript
    are often cached by your browser, so hit *Ctrl* + *R* for a hard refresh if you
    see unexpected behavior. If *Ctrl* + *R* does not work, try hitting *Ctrl* + *Shift*
    + *Delete* and select the **cache** option in the browser's menu and clear the
    browsing data before refreshing again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The styled map with the form should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the result](img/B04312_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that clicking on the map now populates the latitude and longitude boxes
    with the coordinates of the marker.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have the form, the map, and some CSS, so now is a good time to push the result
    to our VPS so that we can see what it looks like on different devices or ask people
    for feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push our changes, fire up a terminal, change the directory to the root folder,
    and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, SSH into your VPS and pull the new code by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Visit the IP of your VPS to check whether the page worked and looks right. As
    usual, look at `/var/log/apache2/error.log` if anything unexpected happens.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the form to the backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's all very well to have a pretty form to accept user input, but at the moment,
    we're just throwing away any submitted data. Instead of processing input in real
    time, as we did in our headlines application, we want to capture the input and
    store it in our database. Let's take a look at how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the URL to collect POST data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As in our Headlines project, the first step is to set up a URL on our server
    to which the data can be posted. In the HTML form we created, we set this URL
    to be `/submitcrime`, so let''s create this as a route in our Flask app. In `crimemap.py`,
    add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply grabbed all the data the user entered and passed it to our database
    helper. We used the `DB.add_crime()` function in the preceding code, but this
    does not yet exist. We need it to really add the new data to our database for
    our real `DBHelper`, and we also need a stub of this function for `MockDBHelper`.
    Let's take a look at how to add these.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the database methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `MockDBHelper.py`, the function is simple. It needs to take the same arguments
    and then not do anything. Add the following to `mockdbhelper.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The real function needs to be added to `dbhelper.py` and is a bit more involved.
    It looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing we haven't seen before here. We used placeholder values and
    only populated them within the `cursor.execute()` statement to avoid SQL injection,
    and we closed our connection in a `finally` block to make sure it always happens.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code on the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is another good point to commit all the changes to the repository and
    do a quick check for bugs. Once the new code runs on your VPS, try adding a crime
    to the database by visiting your IP address and filling in the form we made. On
    your VPS, you can check to make sure the data was successfully added by running
    the following commands. Note that this fires up a live SQL shell—a direct connection
    to your database that should be used with care. A mistyped command can result
    in data being irretrievably lost or corrupted. Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see that MySQL prints a nice ASCII table that shows a summary of the
    data in your database, as in the following screenshot (in this case, all the records
    and columns from the `crimes` table of the `crimemap` database are shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the code on the server](img/B04312_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying existing crimes on our map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the user can add new crimes to our crime database, but we want the map
    to display crimes that are already added as well. To achieve this, whenever the
    page is loaded, our app needs to make a call to the database to get the latest
    crime data. We then need to pass this data to our template file, loop through
    each crime, and place a marker in the correct place on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our data is stored in a MySQL database. We will access it using Python
    on the server side, and we want to display it using JavaScript on the client side;
    so, we'll need to spend a bit of time on converting our data to the appropriate
    format. When we access the data through our Python `pymysql` driver, we will receive
    it as a tuple. To display the data using JavaScript, we want it in JSON. JSON,
    you might remember from our Headlines project, is JavaScript Object Notation,
    a structured data format that JavaScript can easily read and manipulate. As with
    our previous project, we'll take advantage of the fact that Python dictionaries
    are very similar to JSON. We'll create a Python dictionary from the tuple we get
    out of our database, convert this to a JSON string, and pass it to our template,
    which will use JavaScript to display the data as markers on our map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start in our `DBHelper` class—adding a method to return the fields we
    need for each crime in our database. Add the following method to your `dbhelper.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the new `import` we need for the `datetime` module to the top of
    `dbhelper.py` via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We ignored the `id` and `updated_at` fields as the user is not interested in
    these using the `SELECT` operator to choose all our other fields. As we have no
    `WHERE` clause, this query will return all the crimes we have in our database.
    Once we have all the crimes, we could simply return them in their default representation
    of a tuple of tuples. However, this makes the maintenance of our application difficult.
    We don't want to have to remember that `latitude` is the first element of our
    tuple, `longitude` is the second, and so on. This would make developing the JavaScript
    part of our application a pain, as we'd have to keep referring back to our `DBHelper`
    to find out how exactly to grab, for example, just the `category` element of our
    data. If we wanted to make changes to our application in the future, it would
    probably require the same changes to be made here and in our JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will create a dictionary from each of our records and return the
    dictionaries. This has two advantages: firstly, it''s much easier to develop as
    we can refer to the elements of our data by name instead of by index, and secondly,
    we can easily convert our dictionary to JSON to be used in our JavaScript code.
    For most of the items in our dictionary, we will simply use the database column
    name as a key and the data itself as the value. The exception is the date; our
    database driver returns this as a Python `datetime` object, but we want to display
    it as a string for our user, so we will format it as "yyyy-mm-dd" before storing
    it in our dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: We can add a stub of this method to our `MockDBHelper` so that we can continue
    to run our code locally without a database. In this case, instead of just returning
    a blank list, we'll return a mock crime, as well, in the same format that we'd
    expect from our real `DBHelper`. It's good practice to make any mock classes you
    create behave similarly to their real equivalents as this can help catch development
    errors while we're still testing locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function to `mockdbhelper.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Passing the data to our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the ability to retrieve the data we want from our database
    by calling a single function, let's look at how we will use it in our main Flask
    app and pass it on to our template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time a user visits our home page, we want to get the crime data from
    the database and pass it to the template in JSON format to be displayed using
    JavaScript in our user''s browser. As most of the hard work is done in our `DBHelper`
    class, we can keep our `home()` function quite neat. The entire function looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `json.dumps()` function, which is the opposite of `json.loads()`
    that we used in the first project to create a JSON string for our dictionary (the
    letter "`s`" in `dumps` stands for "string") and then pass the JSON string on
    to our template so that it can use it to populate the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add an import for the JSON library. Near the top of `crimemap.py`,
    add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using the data in our template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our template now has access to a JSON-formatted list of all the crimes in our
    database, and we can use this list to display markers on the map—one for each
    existing crime. We want to use the location data to choose where to place the
    marker, and then we want to embed `category`, `date`, and `description` as a label
    for our marker. This means that when the user moves his or her mouse over one
    of the markers, the information about the crime represented by this marker will
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a new function to our JavaScript code in our `home.html` file.
    Under the `initialize()` function, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function takes `crimes` an argument, loops through it, and creates a new
    marker on our map (which we can refer to now as we previously made it a global
    variable) for each crime in the list. We used the call to `google.maps.Marker()`
    to create the marker and pass in a dictionary of arguments (in this case, a `google.maps.LatLng()`
    "`position`", which we construct from our `latitude` and `longitude` parameters);
    a reference to our map, which is `map`; and a concatenation of our `date`, `category`,
    and `description`, separated by new line characters as the `title`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Customizing Google Map markers**'
  prefs: []
  type: TYPE_NORMAL
- en: The marker we placed can be customized pretty heavily. The full list of options
    we can pass in can be seen at [https://developers.google.com/maps/documentation/javascript/reference?hl=en#MarkerOptions](https://developers.google.com/maps/documentation/javascript/reference?hl=en#MarkerOptions).
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to make a call to our new function inside our `initialize()`
    function and pass in the JSON map list that we built in Python. The entire `initialize()`
    function is shown here with the new section highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We simply called our `placeCrimes()` function and passed in the crimes. Note
    that we used the Jinja built-in `safe` function by using the `|` (pipe) symbol
    and passing in our `crimes` data. This is necessary as, by default, Jinja escapes
    most special characters, but we need our JSON string to be interpreted raw with
    all special characters as is.
  prefs: []
  type: TYPE_NORMAL
- en: However, by using the `safe` function, we tell Jinja that we know that our data
    is safe and at this stage, this is not necessarily the case. Just because we have
    no malicious intent, it does not mean that all our data is inherently safe. Remember,
    most of the pieces of data were submitted by our users, and our data is therefore
    definitely not safe. We'll take a look at the big security hole we've opened in
    our app right after we make sure that it works (with normal, expected usage) as
    intended.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're familiar with *nix shells, `|` or pipe should be pretty straightforward
    syntax. If not, think of it as a usual function with input and output. Instead
    of passing input as parameters in parentheses and using some form of a `return`
    function to get output, we will instead have our input on the left-hand side of
    the `|` symbol and the function name on the right-hand side (in this case, `safe`).
    The input gets piped through the function, and we are left with the output in
    place. This syntax can be very useful to chain lots of functions together, as
    each outer function is simply placed on the right-hand side after another `|`
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, test out the code locally. This will make sure that everything still
    runs and will possibly catch some more subtle bugs as well. As we are using a
    mock for our database function, we won't have a lot of confidence that this works
    until we see it run on the VPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run `python crimemap.py` in your terminal and visit `localhost:5000`
    in your browser, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results](img/B04312_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can note a single marker with the details we specified in our `MockDBHelper`.
    In the screenshot, we moved our mouse over the marker to make the `title` appear
    with all the details of the crime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to `commit` to `git` and push to our VPS. Run the following
    commands locally from your `crimemap` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, SSH to your VPS to pull the new changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we visit the IP address of our VPS now, we should see the two crimes we
    added before we were able to display them. As we used the real `DBHelper` and
    our MySQL database for the production site, we should be able to add crimes using
    the form and see each crime added as a marker to the map in real time. Hopefully,
    you''ll get something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results](img/B04312_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If things don''t work out as expected, as always run the following on your
    VPS and take a look at the output while visiting the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Also, use your browser's debugger by pressing *Ctrl* + *Shift* + *C* to catch
    any JavaScript errors that might have crept in.
  prefs: []
  type: TYPE_NORMAL
- en: Our crime map is now functional and can already be used to start tracking crime
    in a town and keep people informed. However, we'll still add some finishing touches
    in the next chapter before moving on to our final project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to create a mock database in Python so that
    we could develop our application without needing access to a real database. We
    also added a Google Maps widget to our application and allowed our users to easily
    submit a latitude and longitude by clicking on the map while being able to view
    the locations and descriptions of existing crimes as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at another injection vulnerability, XSS, and
    talk about how to protect against it as well as input validation in general.
  prefs: []
  type: TYPE_NORMAL
