- en: Designing a 2D Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camera design is one of those things that is frequently forgotten by novice
    game designers. Up to this point, we have had what is called a *fixed position
    camera*. There is a single screen with no change in perspective. In the 1970s,
    almost all of the early arcade games were designed this way. The oldest game that
    I have found with any sort of camera was Atari's *Lunar Lander*, which was released
    in August 1979\. *Lunar Lander* was an early vector-based game that would zoom
    the camera in as the lander neared the surface of the moon, and would then pan
    the camera out to follow your lander as it approached the surface.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1980s, more games began experimenting with the idea of a game world
    that was larger than a single game screen would allow. *Rally X* was a *Pac-Man-*like
    maze game released in 1980 by Namco, where the maze was larger than a single display.
    *Rally X* used a *position snap camera* (sometimes called a *locked camera*) that
    always kept the player's car in the center of the game screen no matter what.
    That is the most straightforward form of 2D scrolling camera that you can implement,
    and many novice game designers will create a *2D position snap camera* and then
    call it a day, but there are reasons why you may wish to implement a more sophisticated
    camera in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Midway released the game *Defender* in 1981\. It was a side-scrolling shooter
    that allowed the player to move their spaceship in either direction. Realizing
    that the player needed to see more of the level in the direction that the spaceship
    was facing, *Defender* used the first *dual-forward-focus camera*. This camera
    shifts the viewing area so that two-thirds of the screen is in front of the direction
    the player's spaceship is facing, and one third of the screen is behind. That
    puts more of a focus on what is currently in front of the player. The camera did
    not just snap back and forth between the two positions. That would have been very
    jarring. Instead, when the player switched directions, the camera position would
    smoothly transition to its new position (pretty cool for 1981).
  prefs: []
  type: TYPE_NORMAL
- en: During the 1980s, many new camera designs came into use. Konami began using
    an autoscrolling camera in many of their shooter games, including *Scramble*,
    *Gradius*, and *1942*. In 1985, Atari released *Gauntlet*, which was an early
    multi-player game allowing four players to be in the game at the same time. The
    camera in *Gauntlet* positioned itself at the average of all of the player's positions.
    Platformer games, such as *Super Mario Bros.*, would allow the position of the
    user to push the camera forward.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to include several images in your build to make this project work.
    Make sure you include the `/Chapter11/sprites/` folder from the project's GitHub.
    If you haven't yet downloaded the GitHub project, you can get it online at [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: There are many great examples of 2D cameras out there if you take the time to
    look. We are going to focus (no pun intended) on a few 2D camera features that
    will be helpful for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a camera for our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build our camera in several different stages. We will start
    with a bare-bones **locked-on camera** implementation. That will give us a good
    starting point from where we can add new camera features. Later, we will modify
    this camera to be a **projected focus camera**. A projected focus camera looks
    at the velocity of the player's ship and adjusts the camera so that it shows more
    of the gameplay area in front of the player. This technique works off the assumption
    that, in this game, the player is generally more focused on the gameplay in the
    direction the player's ship is moving. For the final version of our camera, we
    will add *camera* *attractors* to our projectiles. The idea behind this modification
    is that, when there are shots fired in the game, the camera should draw attention
    to that area of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Camera for tracking player movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first implementation of our camera will be a locked-on camera, which will
    lock onto our player and follow them as they move through the area in the level.
    Right now, our level is the same size as our *fixed camera* at that level. Not
    only will we need to make our level larger, but we will also need to modify our
    object wrapping so that it works with our camera. The first thing that we will
    need to do to implement our locked-on camera is to modify our `game.hpp` file.
    We will be creating a `Camera` class as well as a `RenderManager` class, where
    we will move all of our rendering-specific code. We will also need to add some
    `#define` macros than define our level's height and width, because that will now
    be different to the canvas height and width that we have already defined. We will
    also be adding a few additional overloaded operators to our `Vector2D` class.
  prefs: []
  type: TYPE_NORMAL
- en: Projected focus and camera attractors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A locked-on camera is not a terrible thing, but a better camera shows more of
    what the player needs to see. In our game, the player is more likely to be interested
    in what lies ahead in the direction they are moving. A camera that looks ahead
    in the direction of movement is sometimes called a projected focus camera. We
    can look at the velocity at which our ship is currently moving, and offset our
    camera accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Another camera technique that we will employ is called **camera attractors**.
    Sometimes in games, there are objects of interest that can be used to pull/attract
    the focus of the camera. These create an attractive force that will pull our camera
    in that direction. One attractive force for our camera is the enemy ship. Another
    attractive force is projectiles. The enemy ship represents potential action, and
    projectiles represent a potential threat to our player. In this section, we will
    combine a projected focus with camera attractors to improve our camera positioning.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing I would like to add is an arrow that points the way toward the
    enemy spaceship. Because the play area is now larger than the canvas, we need
    a hint to help us find the enemy. Without this, we may find ourselves wandering
    around aimlessly, which is not very fun. Another way we could have done this is
    with a mini-map, but, because there is only a single enemy, I felt an arrow would
    be easier to implement. Let's walk through the code we need to add to improve
    our camera and add our locating arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to need to add several new classes for this chapter. Obviously,
    if we want a camera in our game, we will need to add a `Camera` class. In previous
    versions of the code, the rendering was done through direct calls to SDL. Because
    SDL does not have a camera as a part of the API, we will need to add a `RenderManager`
    class that will act as an intermediate step in our rendering process. This class
    will use the position of the camera to determine where on our canvas we will be
    rendering our game object. We will be increasing our gameplay area to four screens
    wide and four screens high. This creates a gameplay problem, because now, we will
    need to be able to find the enemy spaceship when we play. To solve this problem,
    we will need to create a locator **user interface** (**UI**) element that points
    an arrow in the direction of the enemy spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the game.hpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s walk through the changes we will make to our `game.hpp` file. We begin
    by adding a few `#define` macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will define the width and height of our level to be four times as large
    as the width and height of our canvas. At the end of our list of classes, we should
    add a `Camera` class, a `Locator` class, and the `RenderManager` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the last three lines declare that a class called `Camera`,
    a class called `Locator`, and a class called `RenderManager` will be defined later
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The Vector2D class definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be expanding our `Vector2D` class definition to add an `operator+` and
    `operator-` overload for the `+` and `-` operators in our `Vector2D` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with operator overloading, these are a convenient way
    to allow classes to use C++ operators instead of functions. There is a good tutorial
    that can help if you are looking for more information that is available at [https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the new definition of the `Vector2D` class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the last two lines of the definition are new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Locator class definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Locator` class is a new class for a UI element that will be an arrow pointing
    our player in the direction of the enemy spaceship. We require a UI element to
    help the player find the enemy spaceship when it does not appear on the canvas.
    Here is what the class definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two attributes are Boolean flags that have to do with the active
    state of the locator. The `m_Active` attribute tells us whether the locator is
    currently active and should be rendered. The `m_LastActive` attribute is a Boolean
    flag that tells us whether the locator was active the last time a frame was rendered.
    The next two lines are the sprite texture and the destination rectangle that will
    be used by the render manager to render this game object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After that, we have an `x` and `y` positional value in the `m_Position` attribute,
    an integer that represents an RGB color value in `m_ColorFlux`, and a rotation
    value for the sprite in the `m_Rotation` attribute. We will be using the `m_ColorFlux`
    attribute to cause the color of the arrow to be redder when the enemy is close,
    and whiter when the enemy is further away.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last four lines of this class definition are the class functions. There
    is a constructor, a function that sets the status of the locator to active, and
    `Move` and `Render` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Camera class definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to add the new `Camera` class definition. This class will be used
    to define our `viewport` and the position of our camera. The `Move` function will
    be called for every frame. Initially, `Move` will lock on to the position of our
    player and follow it around the level. Later, we will change this functionality
    to create a more dynamic camera. This is what the `Camera` class will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The RenderManager class definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All this time, we have been moving around our level without a background. This
    was fine in previous chapters, where our level fitted exactly onto the canvas
    element. Now, however, we are scrolling around our level with a camera. If nothing
    is moving in the background, it can be hard to tell whether your spaceship is
    moving at all. To create the illusion of movement in our game, we will need to
    add a background renderer. In addition to that, we want all rendering in our game
    to be done using the camera we just created as an offset. Because of this, we
    no longer want our game objects to call `SDL_RenderCopy` or `SDL_RenderCopyEx`
    directly. Instead, we have created a `RenderManager` class that will take responsibility
    for performing the rendering from within our game. We have a `RenderBackground`
    function that will render a starfield as a background, and we have created a `Render`
    function that will render our sprite textures using the camera as an offset. This
    is what the `RenderManager` class definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do in the `game.hpp` file is to create an external
    link to two new object pointers of the `Camera` and `RenderManager` types. These
    will be the camera and render manager objects that we will be using in this version
    of our game engine and are external references to variables that we will define
    inside our `main.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The camera.cpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two functions we have defined in our `Camera` class; a constructor
    for our `camera` object, and the `Move` function, which we will use to follow
    our `player` object. The following is what we have in the `camera.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Camera` constructor and `Move` functions are pretty bare bones in this
    implementation. The constructor sets the half width and half height of the camera
    based on the width and height that is passed in. The `Move` function sets the
    position of the camera to the position of the player and then shifts the position
    of the camera by half of the canvas width and canvas height to center the player.
    We have just built a starter camera and will add more functionality to it later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The render_manager.cpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be moving all of the calls we were making to render sprites inside
    our objects to the `RenderManager` class. We need to do this because we will be
    using the position of our camera to decide where on our canvas we will be rendering
    the sprites. We also need a function that will render our background starfield.
    The first few lines of our `render_manager.cpp` file will be including the `game.hpp`
    file and defining the virtual filesystem location of our background image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will define our constructor. The constructor will be used to
    load our `starfield.png` file as an `SDL_Surface` object, and will then use that
    surface to create an `SDL_Texture` object that we will use to render our background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RenderBackground` function will need to be called at the beginning of
    our `render()` function that we have defined in the `main` loop. Because of this,
    the first two lines of `RenderBackground` will have two functions that we will
    use to clear the renderer that was previously called from the `render()` function
    in `main.cpp` to black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will set up a background rectangle that will be our rendering
    destination. The size of `starfield.png` matches our canvas size (800 x 600),
    so we will need to render it four times based on the camera''s position. Because
    this is a repeating texture, we can use a modulo operator (`%`) on the position
    of our camera to figure out how we want to offset the starfield. As an example,
    if we had positioned our camera at `*x* = 100`, `*y* = 200`, we would want to
    render the first copy of our starfield background at `-100`, `-200`. If we stopped
    there, we would have 100 pixels of black space on the right, and 200 pixels of
    black space on the bottom of our canvas. Because we would like a background in
    those areas, we will need three additional renders of our background. If we render
    our background a second time at `700`, `-200` (adding canvas width to the previous
    render''s *x* value), we would now have a 200-pixel strip of black at the bottom
    of the canvas. We could then render our starfield at `-100`, `400` (adding canvas
    height to the original render''s *y* value). That would leave us with a 100 x
    200 pixel of black in the bottom corner. The fourth render would need to add the
    canvas width and canvas height to the original render''s *x* and *y* value to
    fill in that corner. That is what is going on in the `RenderBackground` function
    that we use to render the repeating background to the canvas based on the position
    of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function we define in `render_manager.cpp` is our `Render` function.
    After defining this function, we will need to find every place where we have previously
    called `SDL_RenderCopy` and `SDL_RenderCopyEx` in our code, and replace those
    calls with calls to our render manager''s `Render` function. This function will
    not only render our sprite based on the position of our camera, but it will also
    be used to set color and alpha channel modifications. Here is the code from the
    `Render` function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing this function does is create a new `SDL_Rect` object, which
    we will use to modify the values in the `dest` variable passed into the `Render`
    function. Because we have a level that wraps the *x* and *y* coordinates, we will
    want to render objects on the far left of our level to the right if we are on
    the right edge of our level. Likewise, if we are on the far-left side of our level,
    we will want to render objects positioned on the far-right side of our level to
    our right. This allows our spaceship to loop around from the left side of our
    level back to the right side of our level, and vice versa. The following is the
    code that adjusts the camera position for wrapping objects to the left and right
    of the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After this has been done, we will do something similar to allow for wrapping
    the position of objects at the top and the bottom of our level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to subtract the camera''s position from the `camera_dest` *x*
    and *y* coordinates, and set the values for our `alpha` and `color` mod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the function, we will call `SDL_RenderCopyEx` if our sprite is
    rotated, and `SDL_RenderCopy` if it is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Modifying main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement our camera, we will need to make several modifications to our `main.cpp`
    file. We will need to add some new global variables for our camera, render manager,
    and locator. We will need to modify our `move` function to include calls to move
    our camera and our locator. We will modify our `render` function to render our
    background and locator. Finally, we will need to add more initialization code
    to our `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: New global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create three new global variables near the beginning of our `main.cpp`
    file. We will need object pointers to `RenderManager`, `Camera`, and `Locator`.
    This is what those declarations look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the move function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to modify our `move` function to move our camera and our locator
    object. We will need to add the following two lines at the end of our `move` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `move` function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the render function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add a new line to the very beginning of the `render` function. This
    line will render the background starfield and move it based on the camera position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will need to add a line to the end of the `render` function.
    This line will need to come immediately before the `SDL_RenderPresent` call, which
    will still need to be the last line in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the `render()` function looks like in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final modifications will be to initialization that happens in the `main`
    function. We will need to create new objects for the `camera`, `render_manager`,
    and `locator` pointers we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous version of our code, we had seven calls to `new Asteroid` and
    used `asteroid_list.push_back` to push those seven new asteroids into our list
    of asteroids. We will now need to create far more asteroids than seven, so, instead
    of doing them as individual calls, we will be using a double `for` loop to create
    and spread out our asteroids all over the gameplay area. To do this, we will first
    need to remove all of those earlier calls to create and push asteroids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have removed all of the preceding code, we will add the following
    code to create our new asteroids and space them semi-randomly throughout the gameplay
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Modifying asteroid.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are using a render manager to render all of our game objects, we
    will need to go through our various game objects and modify them to render through
    the render manager instead of directly. The first file we will modify is `asteroid.cpp`.
    Inside `asteroid.cpp`, we have the `Asteroid::Render()` function. In previous
    chapters, this function would render the asteroid sprite directly through SDL
    using a call to `SDL_RenderCopyEx`. Now that we have the `render_manager` object
    that we defined in our `main.cpp` file, we will be using that render manager to
    render our sprite indirectly. The `RenderManager::Render` function will use the
    camera to adjust the location on the canvas where the sprite will be rendered.
    The first modification we need to make to the `Asteroid::Render()` function is
    to remove the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing the call to `SDL_RenderCopyEX`, we need to add the following
    call to the `Render` function within the `render_manager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of the `Asteroid::Render` function will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Modifying collider.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to modify one function inside the `collider.cpp` file. The previous
    version of the `WrapPosition` function checked to see whether a `Collider` object
    moved off the canvas to one side or another, and, if it did, the function would
    move the collider to the opposite side. This mimicked the behavior of the classic
    Atari arcade game, *Asteroids*. In Atari *Asteroids*, if an asteroid or the player''s
    spaceship moved off the screen on one side, that asteroid (or spaceship) would
    appear on the opposite side of the game screen. Here is the previous version of
    our `wrap` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our game now extends beyond a single canvas, we no longer want to wrap
    if an object moves off the canvas. Instead, we want to wrap the object around
    if it falls outside the bounds of the level. Here is the new version of the `WrapPosition`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Modifying enemy_ship.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A small modification to the `enemy_ship.cpp` file is necessary. The `EnemyShip`
    constructor function will now be setting the `x` and `y` values on the `m_Position`
    attribute. We need to set the position to `810` and `800`, because the level is
    now much larger than the canvas size. We will set the `m_Position` attribute at
    the very top of the `EnemyShip` constructor. This is what the beginning of the
    constructor will look like after the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Modifying finite_state_machine.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to make a small change to the `finite_state_machine.cpp` file.
    Inside the `FiniteStateMachine::AvoidForce()` function, there are several references
    to the canvas dimensions that must be changed to reference the level dimensions
    now that the size of our level and the size of our canvas are different. Previously,
    we had set the `x` and `y` attributes of the `star_avoid` variable to the following
    canvas-based values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines must be changed to reference `LEVEL_WIDTH` and `LEVEL_HEIGHT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We must do the same thing to the `avoid_vec` variable. Here is what we had
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That must also be changed to reference `LEVEL_WIDTH` and `LEVEL_HEIGHT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of the `FiniteState::AvoidForce` function in its entirety is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Modifying particle.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to modify the `Render` function inside the `particle.cpp` file
    to render the particle through `render_manager` instead of directly through calls
    to SDL. The old version of the `Particle::Render` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `Particle::Render` function will make a single call to the `Render`
    function through the `render_manager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Modifying player_ship.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need to make one small modification to the `player_ship.cpp` file. Like
    the change that we made to the `enemy_ship.cpp` file, we will need to add two
    lines to set the `x` and `y` values in the `m_Position` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to remove the first two lines of the `PlayerShip::PlayerShip()`
    constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the changes we will need to make to the `PlayerShip::PlayerShip()`
    constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Modifying projectile.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to make a small change to the `projectile.cpp` file. As in other
    game objects, the `Render` function previously made calls directly to the SDL
    function to render the game object. Instead of making those calls to SDL, we will
    need to make a call through the `render_manager` object. We will need to remove
    the following lines from the `Projectile::Render()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In place of these lines, we will need to add a call to the `Render` function
    on the `render_manager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the new version of the `Projectile::Render()` function will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Modifying shield.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with many other game objects, the `Shield::Render()` function will need
    to be modified so that it no longer calls SDL directly and instead calls the `Render`
    function from the `render_manager` object. Inside the `Shield::Render()` function,
    we will need to remove the following calls to SDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be replacing these lines with a single call to `Render`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the new version of the `Shield::Render` function looks like in
    its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Modifying ship.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modifying the `Render` functions within our game objects is becoming pretty
    routine. As in other objects where we have modified the `Render` function, we
    will need to remove all direct calls to SDL. Here is the code that we will need
    to remove from the `Render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing these lines, we will need to add a line to call the `render_manager->Render`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Modifying star.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to modify two functions inside the `star.cpp` file. First, we
    will need to modify the position of the star in the `Star::Star()` constructor
    function. In the version of the `Star` constructor from the previous chapter,
    we set the position of the star to the middle of the canvas. Now, it must be set
    to the middle of the level. Here are the lines that were in the original version
    of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now change these to positions relative to `LEVEL_WIDTH` and `LEVEL_HEIGHT`
    instead of `CANVAS_WIDTH` and `CANVAS_HEIGHT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the preceding change to the `Star::Star` constructor function,
    we will need to make a change to the `Star::Render` function. We will need to
    remove the call to `SDL_RenderCopy` and replace it with a call to the `Render`
    function on the `render_manager` object. This is what the previous version of
    the `Render` function looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will modify it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Modifying vector.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to add two new overloaded operators to our `Vector2D` class. We
    will need to override `operator-` and `operator+`. This code is pretty straightforward.
    It will use the already overloaded `operator-=` and `operator+=` to allow us to
    add and subtract vectors from each other. Here is the new code for those overloaded
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and playing with a locked-on camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we compile and test what we have right now, we should be able to move around
    our level and see a camera that directly tracks the player''s position. We should
    have a locator arrow that helps us to find the enemy spaceship. Here is the command-line
    call to Emscripten that we can use to build our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Run the preceding line on the Windows or Linux command prompt. After running
    this, serve the `index.html` file from a web server and open it in a browser such
    as Chrome or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current camera is functional, but a little boring. It focuses exclusively
    on the player, which works all right, but could be significantly improved. For
    starters, as the designers of *Defender* realized, it is more important to put
    the focus of the camera in the direction the player is moving, instead of directly
    on the player. To accomplish this, we will add *projected focus* to our camera.
    That will look at the current velocity of the player's ship, and will move the
    camera forward in the direction of that velocity. There are times, however, when
    you may still want the focus of your camera behind the player. To help with this,
    we will add some camera attractors. Camera attractors are objects that draw the
    camera's attention toward them. If the enemy appears behind the player, it may
    be more important to move the camera back somewhat to help keep the enemy on screen.
    If the enemy is shooting at you, it may be more important to draw the cameras
    toward the projectiles that are heading your way.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to games.hpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first change we need to make is to our `games.hpp` file. Having a camera
    follow our player is easy. There is not any snapping or jarring movement of the
    camera because the player''s ship does not move that way. If we are going to use
    more advanced features, such as attractors and forward focus, we will need to
    calculate the desired position of our camera, and then transition smoothly to
    that position. To support this, we will need to add a `m_DesiredPosition` attribute
    to our `Camera` class. The following is the new line we must add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the `Camera` class in our `games.hpp` file will look like after
    we add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Changes to camera.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have added a desired position attribute to the class definition,
    we need to change our `camera.cpp` file. We need to modify the constructor to
    set the position of the camera to the position of the player''s ship. Here are
    the lines we will need to add to our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the constructor after we have added those lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Camera::Move` function will be entirely different. You might as well remove
    all of the lines of code that are in the current version of `Camera::Move`, because
    none of them are useful anymore. Our new desired position attribute will be set
    at the beginning of the `Move` function, the way that the position was set previously.
    To do this, add the following lines to the empty version of `Camera::Move` that
    you created by deleting everything from that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the player is not alive, we will want our camera to settle down on this
    position. After the player is dead, we will not want any attractors to affect
    the position of the camera. Moving the player camera too much after the player
    dies looks a little strange, so add the following lines of code that check whether
    the player''s ship is active and, if not, moves the position of the camera toward
    the desired position and, then returns from the `Move` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to make all of the active projectiles in our game attractors.
    If an enemy is shooting at us, it is a threat to our ship and should therefore
    draw the camera''s attention. If we shoot projectiles, that also indicates the
    direction where we are focused. We are going to use a `for` loop to loop over
    all of the projectiles in our game, and, if that projectile is active, we will
    use its position to shift the desired position of our camera. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After using our attractors to shift the desired position of the camera, we
    will modify the `m_DesiredPosition` variable based on the velocity of the player''s
    ship with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our level wraps around, and if you exit from one side of the level
    you reappear on the opposite side, we will need to adjust the desired position
    of our camera to account for this. Without the following lines of code, the camera
    makes a sudden jarring transition when the player moves outside the level bounds
    on one side and reappears on the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add a few lines of code to smoothly transition the camera''s
    current position to the desired position. We use `delta_time` to make this transition
    take about a second. Setting our camera position directly instead of using the
    desired position and transitioning results in jerky movements when new attractors
    enter the game. Here is the transition code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have seen all of the lines of our `Move` function separately, let''s
    take a look at the completed new version of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and playing with the advanced camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you have built this version, you will notice that the camera moves ahead
    in the direction your ship is moving. If you start shooting, it will move even
    further ahead. When the enemy spaceship approaches, and it shoots at you, the
    camera should also drift in the direction of those projectiles. As before, you
    can compile and test the code by entering the following line on the Windows or
    Linux command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a compiled version of our app, we should run it. The new version
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e7f8642-ae56-40d6-ad9d-4c43bdb3f11c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: New camera version with lines added to divide the screen'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the camera is not centering the player's spaceship. The focus
    of the camera is primarily projected in the direction of the player ship's velocity,
    dragged slightly to the right and up because of the enemy ship and the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter by learning about the history of cameras in video games.
    The first camera we discussed is the simplest type of camera, sometimes called
    a locked-on camera. That is the kind of camera that tracks the location of the
    player exactly. After that, we learned about alternatives to a locked-on camera
    in 2D space, including cameras that lead the player. We talked about projected
    focus cameras, and how they predict the movement of the player and project the
    position of the camera forward based on the direction in which the player is moving.
    We then discussed camera attractors, and how they can draw the focus of the camera
    toward objects of interest. After discussing the types of cameras, we created
    a camera object and designed it to implement projected focus and camera attractors.
    We implemented a render manager and modified all of our game objects to render
    through the `RenderManager` class. We then created a `locator` object to help
    us find the enemy spaceship when it no longer appears on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to add sound effects to our game.
  prefs: []
  type: TYPE_NORMAL
