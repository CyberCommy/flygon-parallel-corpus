- en: Launching Applications Using Fission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up we are going to look at Fission. Fission is a fast-growing, serverless
    framework for Kubernetes and, of the technologies that we have seen in previous
    chapters, is probably the most versatile. In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Who built Fission?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing, configuring, and running Fission locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing, configuring, and running Fission in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a few example Fission applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have worked on installing Fission in two
    different target environments, and also worked through launching several applications.
  prefs: []
  type: TYPE_NORMAL
- en: Fission overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fission is an open source serverless application developed by Platform9\. It
    was designed to run on top of Kubernetes as well as take advantage of some core
    Kubernetes functionality. Platform9 are a managed service provider whose core
    business is the deployment, management, and support of open source clouds specializing
    in OpenStack and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack is a collection of open source components that make up a fully functional
    Infrastructure as a Service offering. It provides compute, networking, block storage,
    object storage, orchestration, and even container service, to name but a few.
  prefs: []
  type: TYPE_NORMAL
- en: The project's goal is to provide support for a number of different hardware
    vendors, from vanilla x86 hardware to specialized storage solutions, allowing
    end users to build out their own AWS and Microsoft Azure style offering.
  prefs: []
  type: TYPE_NORMAL
- en: With services such as AWS Lambda and Azure Functions maturing to the point where
    they are now commonplace in most enterprises, Platform9 saw an opportunity to
    provide their own Functions as a Service offering.
  prefs: []
  type: TYPE_NORMAL
- en: Being a company who specialize in complex open source solutions, it made sense
    for them to contribute their work back to the community, and so they released
    Fission under the Apache License.
  prefs: []
  type: TYPE_NORMAL
- en: The Apache 2.0 License by The Apache Software Foundation allows developers to
    release their software for free, giving the end user permission to use that software
    for any purpose, and modify/redistribute it without the end user having to worry
    about royalties. To ensure that the License is not breached, the end user must
    preserve the original copyright notice and disclaimer.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like a strange decision. However, like OpenWhisk, which we covered
    in the previous chapter, Platform9 have given their customers, and anyone else
    who wants to start deploying **Function as a Service** (**FaaS**), a solid foundation
    to build their applications on top of. Not only are they giving people the freedom
    to deploy their workloads wherever they want, they are also able to offer support
    services for installation and the Fission platform.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we install Fission either locally or in a public cloud we need a few
    supporting tools. The first tool we have already installed and that is the Kubernetes
    command-line interface, `kubectl`. The second tool needed to run Fission, we have
    not installed yet: Helm ([http://helm.sh/](http://helm.sh)).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is a package manager for Kubernetes and is part of the Cloud Native Computing
    Foundation, where Bitnami, Google, Microsoft, and the Helm community all contribute
    to its development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Helm on macOS High Sierra we can use Homebrew; simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running Ubuntu Linux then you can download and install Helm using
    the installation script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, Windows 10 Professional users can download an experimental build of
    Helm from the canary repository. The direct download link for this build is [https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip](https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip).
    As this is an experimental build, I recommend running it directly and not putting
    it in the system folder.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in installing Helm requires you to have a running Kubernetes cluster,
    as that is where it is launched. I will include the instructions for installing
    Tiller, the server component of Helm, later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Fission CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final command-line tool we need to install is the one for Fission itself.
    You can install this by running the following on macOS High Sierra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu 17.04 you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the Windows executable can be downloaded from [https://github.com/fission/fission/releases/download/0.3.0/fission-cli-windows.exe](https://github.com/fission/fission/releases/download/0.3.0/fission-cli-windows.exe).
    I would recommend using it alongside the executable for Helm rather than installing
    it in your `System32` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following commands should show you the currently installed versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/b4a654f6-8c00-4220-b565-f18d42b40e98.png)'
  prefs: []
  type: TYPE_IMG
- en: As already mentioned, we have not installed Tiller yet so we can safely ignore
    the error about not being able to connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Running Fission locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the prerequisites installed we can look at creating our first
    function. To do this we are going to use Minikube. To launch the single node cluster
    we simply need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should launch your Minikube cluster and also confirm that your local version
    has been reconfigured to communicate with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14b2aeba-7121-49c2-a883-32651ffb3353.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have our cluster running and accessible we need to complete the Helm
    installation by installing Tiller. To do this we need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6407f211-02d3-41ab-8863-ba045b51a6e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Launching Fission using Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Helm is now configured and we can use it to deploy the remote components of
    Fission. This can be done by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After a minute or two, you should receive confirmation that Fission has launched.
  prefs: []
  type: TYPE_NORMAL
- en: Working through the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is quite verbose with its output. It will give you an overview of everything
    it has created along with any additional notes the developers have included.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the output contains the basic details of the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we get information on what has been deployed within Kubernetes, starting
    with the service accounts. These provide identity services that run a pod. These
    allow the various components of Fission to interface with Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then come the bindings. These provide role-based authentication (RBAC) for
    the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up are the services themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the deployment details. You will probably notice that, as in the
    following, some of the pods are still launching, which is why they are showing
    zero available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we have the pods for the deployments and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the secrets. These are just for the database being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are nearing the end: the persistent storage claims. You can see, as we have
    launched locally, it is just using a folder on the VM rather than creating external
    storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the role bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the daemon sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen an overview of all the Kubernetes elements of our Fission
    installation, we get notes on how to interact with the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Launching our first function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notes are split into three sections; the first section gives instructions
    on how to install the Fission command-line client. As we have already covered
    this in the previous section of the chapter we can ignore this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, in the second section we are given instructions on environment variables
    we need to set so that our local Fission client can interact with our Fission
    installation. To set these variables run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `export` command only works with macOS High Sierra and Ubuntu 17.04\. Windows
    10 Professional users will have to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the commands, our Fission installation is aware that it
    is running on a Minikube installation and has provided us with commands to dynamically
    generate the IP address of our Minikube installation.
  prefs: []
  type: TYPE_NORMAL
- en: The third section contains step by step instructions on how to run a hello world
    function; let's look at running these steps now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create an environment. To do this we use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates an environment called `nodejs` and then instructs Fission
    to use the Docker image `fission/node-env`from the Docker Hub—you can find this
    image at: [https://hub.docker.com/r/fission/node-env/](https://hub.docker.com/r/fission/node-env/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the environment created, we need a function to deploy. Run
    the following command (macOS and Linux only) to download the hello world example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is not dissimilar to the previous examples we have been
    running in earlier chapters. Now that we have a function downloaded, we can deploy
    it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost there; the final step is to create a route to our function. To
    do this, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to call our function by making an HTTP request. You can
    use either of the following commands to trigger our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows 10 Professional, use the following command to open the example
    in IE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'HTTPie will give you the headers, as well as the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79722f78-5815-45eb-801c-40cd7b7abb1e.png)'
  prefs: []
  type: TYPE_IMG
- en: A guestbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic application up and running, let's look at creating
    something more complex. Fission ships with a demo application that acts as a guestbook.
    You can find the files we are going to be deploying in the `/Chapter08/guestbook/`
    folder in the GitHub repository that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in launching the application is to launch a Redis deployment;
    this will be used to store the comments being written to the guestbook. To create
    the deployment, run the following command from within the `/Chapter08/guestbook/`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the following screenshot this has created a `namespace`, `deployment`,
    and `service`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c999a786-2b0b-42b6-a941-a1bfaf9f659e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to create an environment to launch our functions into. As the application
    is written in Python, let''s run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37069961-48b9-4fef-8ac8-6be14d231f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have created two functions, one for displaying the comments and one
    for writing the comments. To add these, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding commands can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79183e9b-e337-4a2e-ab96-8967a67d41b9.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that the command to add the functions is a little different
    from the one we used to launch the hello world example in the previous section.
    In the previous examples, we are both adding the function and creating the route.
    You might also have noticed that while we have created two functions, they are
    bound to the same route of `/guestbook`. Rather than discuss this now, let's launch
    the application and interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the guestbook, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows 10 Professional, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open your browser at a blank guestbook page, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b699b897-d8f4-4ef6-b4ce-88019c11b36b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now add a comment by entering some text—say `Testing Fission`—and then
    click Add. Upon refreshing, you should see your comment has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d18d10b-b9a8-4b97-858f-1d4dc284f2fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you receive an internal server error, don''t worry—just refresh the page
    and submit again. Taking a look at the HTML source of the page, you may notice
    that the form action is configured to `POST` to `/guestbook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the command we used to create the two functions, both had a
    method attached. The `guestbook-add` one, which runs the `add.py`, used the `POST`
    method, as you can see from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The function reads the data posted by the form, pushes the comment to the Redis
    database, and then takes us back to `/guestbook`. The `303` code is the status
    code used to redirect after a `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever your browser requests a page it is sending a `GET` request. In our
    case, all of the `GET` requests to `/guestbook` are being routed to the `guestbook-get`
    function, which is the `get.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, this connects to the Redis database,
    reads each entry, formats the results as an unordered HTML list, and then inserts
    the list below the horizontal rule (`<hr/>`).
  prefs: []
  type: TYPE_NORMAL
- en: Fission commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at moving our Fission installation to a public cloud, we should
    look at the command client a little more. There are several top-level commands
    available that we can use to manage our functions and routes.
  prefs: []
  type: TYPE_NORMAL
- en: The fission function command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is pretty much where you will spend most of your time when using Fission.
    The function command is how you create, manage, and delete your functions. You
    can use either `fission function <command>` or `fission fn <command>`.
  prefs: []
  type: TYPE_NORMAL
- en: The create command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already used this command so we don''t need to go into too much detail.
    The `fission function create` command takes several options; the most common ones
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--name`: This indicates what we want to call our function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--env`: This indicates the environment we want to deploy our function in.
    More on environments in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--code`: The path or URL to the code we wish to deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--url`: The URL we want our function to be available at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--method`: How we access our function on the preceding URL; the options here
    are `GET`, `POST`, `PUT`, `DELETE`, `HEAD`—if you don''t use `--method` but do
    use `--url` it will always default to `GET`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have already seen in the guestbook example, a `fission function create`
    command would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The get option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This option is a quite a simple one; running `fission function get` will display
    the source code for your chosen function. It accepts one input: `--name`. This
    is the name of the function you wish to display the source code for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following command will display the source code for the hello world
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/136c1f31-a283-4f3b-a893-9e95fedadf5d.png)'
  prefs: []
  type: TYPE_IMG
- en: The list and getmeta commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two commands kind of do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will list the functions that are currently installed. In that
    list is the name of the function, its unique ID, and which environment the function
    is deployed into:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de079f74-35db-4cea-a0c8-ce19c6b2f9dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we already know the name of the function and we want to remind ourselves
    of the environment it is running in, or need its UID, then we can use the `fission
    function getmeta` command and pass it the name of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/30ec7ff7-1556-445e-ad25-d077acc4ffde.png)'
  prefs: []
  type: TYPE_IMG
- en: The logs command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although there are not any views at the moment, you can view the logs for your
    function by using the `fission function logs` command. There are a few different
    options you can pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--name`: This is the name of the function you wish to view the logs for, and
    this is always required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--follow`: Keeps the stream open and logs are displayed in real time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--detail`: Adds more verbose output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the preceding options, the command will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: However, as mentioned, there is not a lot to see at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The update command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fission function update` command deploys an updated version of a function.
    It uses the same options as the `fission function create` command. For example,
    if we wanted to update our hello world function to use a different source, we
    would run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The delete command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final command we are going to look at is `fission function delete`. This
    command is pretty self-explanatory. It deletes the function and only accepts a
    single argument, and that is `--name`.
  prefs: []
  type: TYPE_NORMAL
- en: Please be careful when using `fission function delete`; it does not prompt you
    in any way, and when you hit *Enter* your function will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the hello world function, for example, we should just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/fa8b8ea6-3c38-4779-b118-282ede814f46.png)As you can see, and as
    mentioned, there are no *Are you sure?* prompts so be careful when using the command.'
  prefs: []
  type: TYPE_NORMAL
- en: The fission environment command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next top-level command is environment. As we have already seen, environments
    are where our functions run and they also define what language our functions are
    executed in. At the time of writing, Fission supports Node.js, Go, Python, PHP,
    Ruby, Perl, and .NET C#.
  prefs: []
  type: TYPE_NORMAL
- en: The create command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fission environment create` command is one we have already used. For example,
    when we created the guestbook application we needed a Python environment to run
    our application on, so we ran the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A full list of the images, the URLs to use, and the Dockerfiles used to create
    the images are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Language** | **Image name** | **Source URL** |'
  prefs: []
  type: TYPE_TB
- en: '| Python 2.7 | `fission/python-env` | [https://github.com/fission/fission/tree/master/environments/python](https://github.com/fission/fission/tree/master/environments/python)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Python 3.5 | `fission/python3-env` | [https://github.com/fission/fission/tree/master/environments/python](https://github.com/fission/fission/tree/master/environments/python)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Node.js | `fission/nodejs-env` | [https://github.com/fission/fission/tree/master/environments/nodejs](https://github.com/fission/fission/tree/master/environments/nodejs)
    |'
  prefs: []
  type: TYPE_TB
- en: '| .NET C# | `fission/dotnet-env` | [https://github.com/fission/fission/tree/master/environments/dotnet](https://github.com/fission/fission/tree/master/environments/dotnet)
    |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 2.0 C# | `fission/dotnet20-env` | [https://github.com/fission/fission/tree/master/environments/dotnet20](https://github.com/fission/fission/tree/master/environments/dotnet20)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Go | `fission/go-runtime` | [https://github.com/fission/fission/tree/master/environments/go](https://github.com/fission/fission/tree/master/environments/go)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PHP | `fission/php7-env` | [https://github.com/fission/fission/tree/master/environments/php7](https://github.com/fission/fission/tree/master/environments/php7)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Ruby | `fission/ruby-env` | [https://github.com/fission/fission/tree/master/environments/ruby](https://github.com/fission/fission/tree/master/environments/ruby)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Perl | `fission/perl-env` | [https://github.com/fission/fission/tree/master/environments/perl](https://github.com/fission/fission/tree/master/environments/perl)
    |'
  prefs: []
  type: TYPE_TB
- en: The list and get command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the function command, environment also has a `list` and `get` command,
    and they work in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Running the previous command will list all of the configured environments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Running the previous command will get the details of the named environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0e86e3f1-0777-4fe1-b51e-2417d7382cf4.png)'
  prefs: []
  type: TYPE_IMG
- en: The delete command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` command, again, works as you would expect it to (remember it will
    delete without warning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you have functions within your environment, it will also delete with
    no warning. However, your functions will remain until you manually delete them.
    Any attempt to call a function that does not have an environment will result in
    an internal server error.
  prefs: []
  type: TYPE_NORMAL
- en: Running Fission in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have an idea of what is involved in launching and interacting with Fission
    when it is running locally, let's look at launching Kubernetes in the cloud and
    then configuring Fission to run there.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this section, I will be only providing instructions for
    macOS High Sierra and Ubuntu 17.04 hosts as this these have a greater level of
    compatibility with the commands we will be running.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am going to be launching my Kubernetes in Google Cloud using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9396fbc-ab7c-42f1-91b1-0622bee37be9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once launched, which should take about 5 minutes at the most, you can check
    that your cluster is up and running as expected by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1493cd89-dfb1-41cb-8dce-23131d8674ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our three-node cluster up and running, and our local Kubernetes
    client interacting with it, we can deploy the Kubernetes end of Helm by running
    the following command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e235d7be-a745-4516-8149-9345b8f5317d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have Helm ready, we can go ahead and launch Fission.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Fission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As before, we will be using Helm to install Fission. The only difference between
    installing Fission locally and on a public cloud such as Google Cloud, Microsoft
    Azure, or AWS is that we will not be using the `--set serviceType=NodePort` option
    and instead just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that it's a lot quicker to run this time, and that the information
    returned is quite similar to when we launched Fission on our local single node
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice, this time your installation has a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This name is used to reference the installation throughout, as you can see
    from the following screen, which is taken from the Workloads page of the Google
    Cloud web console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eea42255-91b3-4c26-9e15-bd86210b99e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While still in the console, clicking on Discovery & load balancing will show
    you all of the external IP addresses that have been assigned to your installation.
    As we passed the `NodePort` option, external load balancers have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de0020bb-b6fb-4bed-b6f2-6c714b115af1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final thing to look at while in the console is the Storage page. As you
    can see, external block storage has been created and attached to your installation.
    This is different to when we launched it locally, as the storage was actually
    that of our single machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e81c1074-edd4-49ba-9341-dcee15b2f08d.png)'
  prefs: []
  type: TYPE_IMG
- en: Returning to the command line, you will notice that, again, Helm has given us
    instructions on how to finish off the configuration of our local Fission client.
    However, as we were not using Minikube, the instructions are slightly different
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands to set the `FISSION_URL` and `FISSION_ROUTER` variables this time
    use `kubectl` to query our installation to find out the external IP address of
    our load balancers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the URLs by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27b2dd66-4b9b-4a2a-a8ee-20857a4d0816.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have Fission installed, and our local command-line client configured
    to interact with our cloud-based installation, we can quickly re-run the hello
    world example by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e039c924-6268-4b50-a00d-98c7707193a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once launched, you can use either of the following commands to call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9395a699-b5b0-467e-926f-ced6004eb30c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can already see, like all of the technologies we have looked at, once
    installed, interacting and using Fission in a public cloud is no different to
    how you would interact and use it when running locally. You really don't have
    to care too much about external access and so on, as Fission and Kubernetes are
    both sorting this out for you.
  prefs: []
  type: TYPE_NORMAL
- en: The guestbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to a more advanced example, let''s quickly launch our guestbook
    application again. To do this, change to the `/Chapter08/guestbook/` folder in
    the repository and then run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/87759a92-2586-497c-bf0a-32689b6c97e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will launch the application and also take you to it in your browser, where
    you can add a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0abac7c0-97e9-4abe-beb4-bd6d120aa78b.png)'
  prefs: []
  type: TYPE_IMG
- en: Some more examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish off the chapter, let's look at some more example code running
    in Fission, starting with a weather checker.
  prefs: []
  type: TYPE_NORMAL
- en: Weather
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `/Chapter08/weather/` folder of the repository, you will find `weather.js`.
    This is a simple Node.js function that queries the Yahoo weather API to return
    the current weather for a given location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, the function accepts JSON encoded data,
    which must contain a valid location. Because of this, we will need to deploy the
    function with a `POST` route, and as it gives an error if no location data is
    passed, we should also deploy a `GET` route. To do this, simple run the following
    commands from within the  `/Chapter08/weather/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command may result in an error if you already have the environment
    we originally created for the hello world example up and running, as seen in the
    following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/81dd0f50-1acc-4c96-a450-df575172498e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our function deployed we can quickly test it by running one
    of the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we haven''t supplied the location, you should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0fdce7d-d631-4a8c-a887-dcb6246727bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly what the code has been programmed to do. As you can see, it
    has returned a `400` error with the message we expected. Providing a location
    (I used `Nottingham, England`) by running one of the following commands should
    tell you what the weather is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the following Terminal output, it has confirmed that the weather
    is currently not that great where I am:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a20414b-ca48-4dfc-9068-f4c4c69d2a39.png)'
  prefs: []
  type: TYPE_IMG
- en: Slack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we are going to be posting a message each time a service is
    created or deleted in the default namespace of our current Kubernetes installation.
    The messages will be posted to a group messaging service called Slack using a
    Webhook.
  prefs: []
  type: TYPE_NORMAL
- en: Slack is an online collaboration tool that allows teams to use an environment
    to interact with chatbots and each other. It offers free and paid tiers as well
    as an exhaustive API for your applications to hook into your chat rooms.
  prefs: []
  type: TYPE_NORMAL
- en: I am going to assume that you already have access to a Slack workspace and have
    permissions to add applications to it. If you don't, then you can configure a
    new workspace at [https://slack.com/](https://slack.com).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have access to your workspace, click on the name of the workspace in
    the top-left of the screen and from the drop-down list of options, select Manage
    Apps. This will take you to the Slack **App Directory**. Here, in the search field
    at the top of the page, enter `Incoming WebHooks`, select the result, and then
    click on the Add Configuration button.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the on-screen instructions to create a Webhook for the channel of your
    choice. I choose to post my updates in the random channel and I also customized
    the icon. On this page you will also find a Webhook URL. Mine (which has now been
    removed) was `https://hooks.slack.com/services/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`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a note of this, as we will need to update the code with it. As you can
    see in the following code, which you can also find in the repository at `/Chapter08/slack/`,
    the third line needs to be updated with your Webhook details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To do this, paste everything after `https://hooks.slack.com`, including the
    slash (`/`). For me this was `/services/T8F3CR4GG/B8FNRR3PC/wmLSDgS0fl5SGOcAgNjwr6pC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line should read something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the file is called `kubeEventsSlack.js` and once your Webhook details
    are in the code, we can create and launch the function using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Once the function has been created, we need to create something to trigger it.
    Previously, we have been calling the functions using HTTP calls. This time, though,
    we want to trigger the function each time something happens within our Kubernetes
    cluster. To do this, we need to create a watch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `fission watch` command is something we have not yet discussed, so let's
    take a minute to find out a little more about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of our Fission deployment there is a service called `kubewatcher`.
    By default, this service is used by Fission to help manage itself by watching
    the Kubernetes API, but is also exposed to end users. The command used to create
    the previous watch creates a watcher, which calls our function (`--function kubeslack`)
    each time changes to a service (`--type service`) are made in the default namespace
    (`--ns default`). We could also set up a watch that looks for changes to pods,
    deployments, and so on by changing the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/90b42045-f5c6-46a0-b78f-2d663350d73c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to launch a service in the default namespace. To do this, change
    to the `/Chapter03/` folder and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, delete the service by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8eef86e2-c090-45d1-8966-a81edfa74be6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check Slack, you should see two messages confirming that a service called
    `cli-hello-world` has been added and deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9bcd145-2011-4126-9bbe-079d7e684278.png)'
  prefs: []
  type: TYPE_IMG
- en: You should see this happen in almost real time, and you might also see messages
    about other services being started within the default namespace within your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Whales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next, and also the last, example we are going to look at is a binary environment.
    This environment is different to the ones we have been looking at, as it does
    not contain a programming language as such. Instead, we will be deploying a bash
    script that installs and configures a Unix tool called `cowsay`. The code for
    this looks like the following and is available in the `/Chapter08/whale/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are two sections to the bash script. The first part runs
    the `cowsay` command and if it errors, which it will do to start with, it uses
    `apk` to install `curl` and `perl`. Once installed, it downloads a copy of the
    code, and configures the default behavior. Then it runs the `cowsay` command after
    it is installed.
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking to yourself, what is APK and what is `cowsay`? As the containers
    that are being deployed to run the Fission environments run Alpine Linux, we need
    to use **Alpines package manager** (**APK**) to install the required packages
    needed for our code to run.
  prefs: []
  type: TYPE_NORMAL
- en: Alpine Linux is a Linux distribution, which over the last two years has started
    to gain a lot of traction over the more traditional Ubuntu/CentOS installations—this
    is because of its size. It is possible to have a base installation of Alpine Linux
    that uses only 8 MB of space. However, although it is small, it remains just as
    functional and powerful as other Linux distributions. Its small size coupled with
    its power makes it the perfect operating system for building containers with.
  prefs: []
  type: TYPE_NORMAL
- en: '`cowsay` is a Unix command that repeats whatever input you give it in a speech
    bubble, coming from a cow, hence the name `cowsay`. We will be installing Docker''s
    own version of `cowsay`, which uses a whale instead of a cow. To deploy the binary
    function we first need to create the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can deploy the function and create the `POST` and `GET` routes so that
    we can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d956143c-5c1e-4c68-a677-67e5aba546a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our function deployed, we can access it using one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return an ASCII whale as seen in the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28566bb9-7ffc-483d-8579-f670243cb692.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might notice that there is nothing in the speech bubble; that is because
    we need to `POST` something. Unlike the previous post examples, the function we
    have launched will simply repeat whatever we post. So, if we were to `POST` a
    JSON object, it will return the JSON object. Because of this, we will be posting
    only plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, this returns the message
    we have posted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e37db66-c2f4-43b5-9be1-6296c995ce70.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you maybe thinking to yourself that this seems like a pretty silly example.
    However, what we have done here is taken the content of an HTTP request and posted
    it to a Linux binary, which was executed with the content we have posted. We then
    had the output of the command running returned via an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: At this point you may want to terminate/power down any Kubernetes clusters you
    have launched to test Fission with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at Fission. We have installed it using Helm
    and deployed it both locally and in Google Cloud. We have also launched several
    test applications, some basic and some that call out to third-party services to
    both post and return information. During the installation and configuration of
    the example applications, I hope that you started to see the usefulness of Fission
    and how it, and other serverless technologies, can be integrated into your own
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: When I started writing the chapter, I hoped to include some sections on Fission
    workflows, and also the Fission UI. However, at the time of writing, both those
    add-ons failed to work. Now, don't get me wrong, Fission is a powerful and simple
    to use technology; however, it is very new and is still in development, as is
    Kubernetes—this means that until the code bases get more established, there will
    be feature breaking updates in new releases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the version of Fission we installed, version 0.4.0, was released
    because the latest version of Kubernetes, version 1.8 at the time of writing,
    removed the `ThirdPartyResources` functionality and replaced it with `CustomResourceDefinitions`,
    which means that older versions of Fission will not work on current versions of
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be looking at the Kubernetes release cycle and how this may
    impact you in the remaining chapters.
  prefs: []
  type: TYPE_NORMAL
