- en: Creating Your Own C++ Add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If two (people) on the same job agree all the time, then one is useless. If
    they disagree all the time, then both are useless."'
  prefs: []
  type: TYPE_NORMAL
- en: – Darryl F. Zanuck
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common description of Node is this one: *NodeJS allows Javascript to
    be run on the server*. This is of course true; it is also misleading. The accomplishment
    of Node was in organizing and linking powerful C++ libraries in such a way that
    their efficiency could be harnessed without needing to comprehend their complexities,
    all accomplished by linking native C++ libraries, through V8, to the JavaScript-driven
    runtime that *is* Node. Node aimed to abstract away the complexity of multiuser,
    simultaneous multithreaded I/O management by wrapping that concurrency model into
    a single-threaded environment that was easy to understand, and already well understood
    by millions of web developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The point is simply this: when you are working with Node, you are ultimately
    working with C++ bindings to your OS, a language whose suitability is for enterprise-level
    software development that no one would seriously question.'
  prefs: []
  type: TYPE_NORMAL
- en: This native bridge to C++ programs puts the lie to claims that Node is not enterprise-ready.
    These claims confuse what Javascript’s role in the Node stack actually is. The
    bindings to Redis and other database drivers regularly used in Node programs are
    C bindings—fast, and near the *metal*. As we’ve seen, Node’s simple process bindings
    (spawn, exec, and so on) facilitate a smooth integration of powerful system libraries
    with headless browsers and HTTP data streams. We are able to access the enormously
    powerful suite of native Unix programs as if they were part of the Node API itself.
    Also, of course, we can write our own add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Paraphrasing Professor *Keith Devlin’s* description in "*Calculus: One of the
    Most Successful Technologies*" ([https://www.youtube.com/watch?v=8ZLC0egL6pc](https://www.youtube.com/watch?v=8ZLC0egL6pc)),
    these are some features of successful consumer technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: It should remove difficulty or drudgery from the process of completing a task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be easy to learn and use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be easier to learn and use than the popular method, if one exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once learned, it can be used without constant expert guidance. A user remains
    able to remember and/or derive most or all of the rules governing interactions
    with the technology through time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be possible to use it without knowing how it works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, as you think about the class of problems Node aims to solve, and
    the form of the solution it provides, the mentioned five features are easily seen
    in the technology Node represents. Node is fun to learn and use, with a consistent
    and predictable interface. Importantly, "*under the hood"* Node runs enormously
    powerful tools that the developer need only understand in terms of their API.
  prefs: []
  type: TYPE_NORMAL
- en: Wonderfully, Node, V8, libuv, and the other libraries composing the Node stack
    are open source, a significant fact that further distinguishes Node from many
    competitors. Not only can one contribute directly to the core libraries, one can
    *cut and paste* code blocks and other routines to use in one’s own work. In fact,
    you should see your growth into a better Node developer as a chance to simultaneously
    become a better C++ programmer.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a primer on C++, leaving you to pursue this study on your own. Don’t
    be intimidated! The C-family of languages are designed using forms and idioms,
    not unlike what you are already used to using with JavaScript. The syntax and
    flow control should look very familiar. You should be able to understand the design
    and goals of the following examples with little effort, and can dip into C++ programming
    to resolve the meaning of the parts that aren’t clear. Extending these examples
    iteratively is an excellent way to gently enter the world of C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build our first add-on. In keeping with tradition, this add-on will result
    in a Node module that will print out "Hello World!" Even though this is a very
    simple example, it typifies the structure of all further C++ add-ons you will
    build. This allows you to incrementally experiment with new commands and structures,
    growing your knowledge in easy-to-understand steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the steps that follow to work, you''ll need a C/C++ compiler and Python
    2.7 installed on your system. The tools to build native code on an operating system
    are specific to that operating system (and provided by the community or corporation
    that maintains or owns it). Here are instructions for some of the major operating
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, for instance, Apple offers Xcode, an integrated development environment
    (IDE) that includes a compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Windows, Microsoft's compiler comes with Visual Studio. There is also an
    npm package available for this purpose— `npm i -g windows-build-tools`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux and elsewhere, **GCC, the GNU Compiler Collection**, is common. **GNU
    Make** and **Python** are also needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C++ programmers might benefit from learning how V8 is embedded, from: [https://github.com/v8/v8/wiki/Embedder%27s-Guide](https://github.com/v8/v8/wiki/Embedder%27s-Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: When compiling native code, there's usually another piece of software—the build
    automation tool. This tool directs the steps the compiler takes to turn your source
    code into a native binary. One of the first, for C, was Make. You can type into
    your compiler directly, of course, but Make lets you rerun the same set of commands,
    keeps a record of what those commands are, and transfer those commands to another
    developer. Make was developed in April 1976, and it has been in continuous use
    ever since.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio and Xcode don't use a script-based tool like Make. Instead, they
    keep build steps and settings in binary files, and let developers edit them by
    clicking on checkboxes and entering text in graphical dialog boxes. This approach
    appeared friendlier, but can be more cumbersome and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier, Google developed a tool called **GYP**, for **Generate Your
    Projects**. It's a meta-build system, taking information from you (in text format)
    and generating the build files the native compiler or IDE expects. Instead of
    opening up Visual Studio or Xcode and clicking around on menus and checkboxes,
    GYP will generate the required files for you. For any developer who has spent
    an evening (or several) hunting through settings to fix a broken native build,
    GYP is wonderful magic.
  prefs: []
  type: TYPE_NORMAL
- en: Google first created GYP to build Chrome and V8, but as an open source project,
    a community brought it to an ever-expanding list of new uses. To build native
    Node add-ons, the Node team creates and maintains `node-gyp`, which bundles Google's
    GYP. Use the mentioned commands to install `node-gyp` globally on your system,
    and verify that it's there by getting the version. You can find the installation
    instructions for `node-gyp` on the below mentioned link: [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp)
  prefs: []
  type: TYPE_NORMAL
- en: You may remember our discussion in the first chapter about the Unix design philosophy,
    and specifically, Doug McIlroy's directive to "*Write programs to handle text
    streams, because that is a universal interface.*"
  prefs: []
  type: TYPE_NORMAL
- en: For the task of compiler automation, Make followed this guideline in the 1970s,
    Apple and Microsoft broke the rule in the 1990s with their graphical IDEs and
    binary project files, and now in this decade, Google has restored it with GYP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand where we''re going, it may be helpful to take a look at what
    we''ll have at the end. When we''re done, we''ll have a module definition folder
    with a handful of files in it. Here''s the structure we''ll create first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `/hello_module` module folder contains a C++ file (`hello.cc`), the *instruction* file
    for GYP (`binding.gyp`), and a convenience *wrapper* (`index.js`), whose purpose
    will be made clear shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `hello.cc` with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After including Node's C header, defining a namespace for our code, and declaring
    various parts of V8 that we'll need to use, there are three parts. The `void sayHello`
    function is the native function we will export. Below that, `init` is a required
    initialization function that sets up the exports for the Node module that this
    will all become (here, the function name `"sayHello"`, bound to its C++ counterpart),
    and `NODE_MODULE()` is a C++ macro that actually exports the module that GYP was
    configured to export. As it's a macro, there's no semicolon at the end of that
    line.
  prefs: []
  type: TYPE_NORMAL
- en: You are embedding C++ code into the V8 runtime, so that Javascript can be bound
    into the relevant scope. V8 must scope all the new allocations made in your code,
    and so, you’ll need to wrap the code you write, extending V8\. To this end, you’ll
    see several instances of the `Handle<Value>` syntax, wrapping C++ code in the
    examples that follow. Comparing these wrappers to what will be defined in the
    initialization function pushed out to `NODE_MODULE` should make it clear how Node
    is being bound to C++ methods via the V8 bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about how V8 embeds C++ code, check out: [https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding](https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with `hello.cc`, create `binding.gyp` with this code inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In cases where you've got more than one source file to compile, simply add more
    filenames to the sources array.
  prefs: []
  type: TYPE_NORMAL
- en: This manifest tells GYP that we want to see `hello.cc` turned into compiled
    binary code in a file named `hello.node`  (`target_name`) in the `/Release` folder.
    We now have the C++ file and the compilation instructions we need to compile our
    first native add-on!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the `/hello_module` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, `configure` generates a Makefile, and the `build` command runs
    it. After you run the `configure` command, you can take a look inside the `/build`
    folder that GYP created to familiarize yourself; they''re all text files that
    you can inspect. On a Mac with Xcode installed, it''ll contain a handful of files,
    including a 300 line Makefile. If successful, the output from the `configure` command should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try the `build` command, which runs this Makefile. The output looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll see a new `/build/Release` folder containing (among other things)
    the binary `hello.node` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the `/build` folder, you can run `node-gyp clean`. As a build shortcut,
    you can use `node-gyp configure build` (one line) to configure and build in one
    step, or simply `node-gyp rebuild`, which runs `clean configure build` for you
    in one go. Further command-line options can be found at: [https://github.com/nodejs/node-gyp#command-options](https://github.com/nodejs/node-gyp#command-options).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, always staying in the `/hello_module` folder, create the following `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This file will function as the exporter for this module. Depending on how you
    write your C++ code, you might use this opportunity to craft your module's native
    interface into a Node-specific API. For now, let's just export the `hello` function
    directly, saving the developer the trouble of following our build folder structure
    when using `require`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the "modularization", create a `package.json` file for this module,
    and set the "entry point" value to `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s demonstrate how to use this module in your code. Jump up a directory
    and create a file that will require the module we''ve just created. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using destructuring, we pull the `sayHello` function from the object our module
    returns. Now, execute that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You are now both a C++ programmer and a Node extender!
  prefs: []
  type: TYPE_NORMAL
- en: Note how we're using the same familiar `require` statement, but in a subtly
    powerful way. Instead of bringing in a Node module coded in more JavaScript, it
    detects and loads our newly-minted native add-on.
  prefs: []
  type: TYPE_NORMAL
- en: A calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, one would never bother to write an add-on to simply echo back strings.
    It is more likely that you will want to expose an API or interface to your Node
    programs. Let’s create a simple calculator, with two methods: add and subtract.
    In this example, we will demonstrate how to pass arguments from Javascript to
    methods within an add-on, and to send any results back.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code for this example will be found in your code bundle. The meat
    of the program can be seen in this snippet, where we define an interface for our
    two methods, each one expecting to receive two numbers as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly see that two methods have been scoped: `Add` and `Subtract`
    (Subtract is defined nearly identically with `Add`, with only a change of operator).
    Within the `Add` method, we see an `Arguments` object (reminiscent of Javascript’s
    arguments object) that is checked for length (we expect two arguments) and argument
    type (we want numbers: `!args[0]->IsNumber() || !args[1]->IsNumber()`). Take a
    good look at how this method closes out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While there seems to be a lot going on, it is really rather simple: V8 is instructed
    to allocate space for a Number with name `num`, to be assigned the value of adding
    our two numbers together. When this operation has been completed, we close out
    the execution scope and return `num`. We don’t have to worry about memory management
    for this reference, as that is automatically handled by V8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we see in the following chunk not only how this particular program
    defines its interface, but how, at a deep level, Node modules and the exports
    object are in fact associated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As in our "hello" example, here we see the new symbols (these are just types
    of strings) `add` and `subtract`, which represent the method names for our new
    Node module.  Their function signature is implemented using the easy-to-follow
    `FunctionTemplate::New(Add)->GetFunction())` blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our calculator from a Node program is now easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With just this simple start, we can already implement useful C++ modules. We'll
    go deeper now, and we'll get some help from **nan (Native Abstractions for Node)**.
  prefs: []
  type: TYPE_NORMAL
- en: Using NAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**nan** ([https://github.com/nodejs/nan](https://github.com/nodejs/nan)) is
    a collection of header files providing helpers and macros aimed at simplifying
    the creation of add-ons. According to the documentation, nan was created primarily
    in order to preserve compatibility of your C++ code across different Node versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the crazy changes in V8 (and some in Node core), keeping native add-ons
    compiling happily across versions, particularly 0.10 to 0.12 to 4.0, is a minor
    nightmare. The goal of this project is to store all logic necessary to develop
    native Node.js add-ons without having to inspect `NODE_MODULE_VERSION` and get
    yourself into a macro-tangle.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples that follow, we will use nan to build some native add-ons. Let's
    rebuild our `hello world` example using nan.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, nan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a folder for your project, and add the following package.json file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added a couple of new things here, such as indicating that there exists
    a `gypfile`. More importantly, we create some convenience scripts for compiling
    and running our module: `build` and `start`. Also, of course, we indicate that
    the module''s main execution file is `index.js` (we''ll create that soon). Note
    as well that, when you `npm install` this package, GYP will notice the `binding.gyp`
    file and automatically build—a `/build` folder will be created along with the
    install.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create our GYP binding file. Note the addition of `include_dirs`. This
    ensures that `nan` headers are made available to the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewrite the main C++ file to take advantage of the nan helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the long list of inclusions isn't necessary. The rest
    of the code follows the same pattern as our original example, but with the initialization
    and function definitions now running through NAN-prefixed shortcuts. Note that,
    we can directly type the `sayHello` method on the module object (`NAN_EXPORT(target,
    sayHello)`), rather than requiring us to specify "sayHello" on the interface that
    a `require` statement will receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to prove that this module can be bound to Node. Create the
    following `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we have to do is build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In keeping with the typical pattern of a Node program, add-ons also implement
    the notion of asynchronous callbacks. As one might expect in a Node program, a
    C++ add-on performing an expensive and time-consuming operation should comprehend
    the notion of asynchronously executing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a module that exposes two methods that ultimately call the same
    function, yet one method does it synchronously and the other asynchronously. This
    will allow us to demonstrate how to create native modules with callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to break our module up into 4 files, separating functionality.
    Create a new directory and copy the `package.json` file from the previous example
    (changing `name` to something else), and add the following `binding.gyp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re done, your module folder will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a0c4968-9de2-4bbb-9b36-ccb770df644d.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to create one file containing the asynchronous method (`async.cc`),
    one for synchronous (`sync.cc`), the common function each will call differently
    in `addon.h`, and the main `addon.cc` file that will "bind" everything together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `addons.h` in the module folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this file is where we will create a "mock" function, whose responsibility
    is simply to waste cycles (time). So, we create an inefficient function `Run`.
    Using the `volatile` keyword, we spook V8 into de-optimizing this function (we
    are warning V8 that this value will change unpredictably, scaring off the optimizer).
    The rest will simply run the number of requested cycles and reflect the value
    it was sent...slowly. This is the function that both our async and sync code will
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute `Run` synchronously, create the following sync.cc file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we saw earlier, `info` will contain arguments passed to this `RunSync` method.
    Here, we grab the number of cycles requested, pass those arguments to `Run`, and
    return whatever that function call produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the file for our asynchronous method, `async.cc`. Creating asynchronous
    code is slightly more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Starting from the bottom, you see that we're creating a method that expects
    the first argument (info[0]) to be an integer, which is assigned to `cycles`.
    We then create a new `Callback` object as `callback`, and pass `callback` and
    `cycles` to the `Worker` constructor, passing the resulting instance to `AsyncQueueWorker`
    (setting up our asynchronous  method).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine how to configure an asynchronous `Worker`.
  prefs: []
  type: TYPE_NORMAL
- en: Jump to the bottom of `Worker` and note the establishment of private attributes
    `cycles` and `result` for this class. In JavaScript, the equivalent would be to
    create a local variable context with `this.cycles` and `this.result` -- local
    variables to use in what follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fulfill the worker template we need to implement two key functions: `Execute`
    and `HandleOKCallback`. `Execute` executes our `Run` function (from `addons.h`)
    in a worker thread (the power of C++ at work) and assigns to `result` the returned
    value. Once `Run` has completed we need to send this result back to the original
    JavaScript callback our Node module interface will have sent. `HandleOKCallback`
    prepares the argument list (`argv`) as expected by standard error-first Node callback
    pattern: we set the first error argument to `Null()`, and the second argument
    to the `result`. Via `callback->Call(2, argv)` the original callback is called
    with these 2 arguments, and proceeds accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to create the module export file, `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve created this file, go ahead and build your module via `npm run
    build`. (or `node-gyp rebuild`) and execute this file with `node index.js`. You
    should see something like this in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s the point of that? We''re proving that we can create C++ functions
    that run independently of the single Node process thread. If `addon.runAsync`
    was not running asynchronously, the output would have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, we see that the runtime logged 1, `runAsync` went off into threads
    land, `2` was logged, followed by the synchronous function `runSync`, blocking
    the event loop (which runs in the same single JavaScript thread). When finished,
    this sync function announces its result, and the loop continues with its next
    instruction to log 3, until, finally, pending callbacks are executed, when the
    result of `runAsync` makes an appearance, last.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of room here for exploration, even if you aren't a C++ programmer.
    From these simple building blocks, aided by `nan`, you can build add-ons with
    increasingly complex behavior. And, of course, the largest advantage is this ability
    to pass long running tasks off onto the OS, to run in a very fast, compiled language.
    Your Node project can now fully harness the power of C++.
  prefs: []
  type: TYPE_NORMAL
- en: Closing thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to easily link C++ modules with your Node program is a powerful new
    paradigm. It may be tempting, then, to exuberantly begin writing C++ add-ons for
    every identifiable segment of your programs. While this might be a productive
    way to learn, it is not necessarily the best idea in the long run. While it is
    certainly true that, in general, compiled C++ will run more quickly than JavaScript
    code, remember that V8 is ultimately using another type of compilation on the
    JavaScript code it is running. JavaScript running within V8 runs very efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: As well, we don’t want to lose the simplicity of organization and predictable
    single-threaded runtime of JavaScript when designing complex interactions within
    a high-concurrency environment. Remember that Node came into being partly as an
    attempt to save the developer from working with threads and related complexities
    when performing I/O. As such, try and keep some rules in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Will a C++ module actually run more quickly? The answer isn’t always yes. The
    extra step of jumping into a different execution context and then back into V8
    takes time. *Felix Geisendorfer’s* talk describing his work with building fast
    MySQL bindings provides some insight into how one should think when making these
    decisions, at: [http://www.youtube.com/watch?v=Kdwwvps4J9A](http://www.youtube.com/watch?v=Kdwwvps4J9A).
    In general, stick with JavaScript until you need to really do something deep and
    expensive where getting *closer to the metal* makes sense.'
  prefs: []
  type: TYPE_NORMAL
- en: How does splitting up your code base affect maintainability? While it would
    be hard for any developer to suggest using less-efficient code, sometimes a negligible
    performance gain does not overcome an increase in complexity that can lead to
    harder-to-find bugs or difficulties with sharing or otherwise managing your code
    base (including with future team members you haven't even hired yet!).
  prefs: []
  type: TYPE_NORMAL
- en: Node has merged a beautiful JavaScript API with an enormously powerful and easily
    extensible application stack. Given the ability to integrate C++ into your applications,
    there is no reason to exclude Node from the list of technologies to consider for
    your next project.
  prefs: []
  type: TYPE_NORMAL
- en: Links and resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Additional guides and resources for writing Node add-ons can be found on the
    web:'
  prefs: []
  type: TYPE_NORMAL
- en: The Node documentation for add-ons is excellent: [https://nodejs.org/dist/latest-v9.x/docs/api/addons.html](https://nodejs.org/dist/latest-v9.x/docs/api/addons.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nan repository contains many examples: [https://github.com/nodejs/nan](https://github.com/nodejs/nan)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An excellent resource for those learning C++: [http://www.learncpp.com/](http://www.learncpp.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you’re feeling more confident, the source code for Node’s core modules
    is an excellent place to both explore and learn from: [https://github.com/nodejs/node/tree/master/src](https://github.com/nodejs/node/tree/master/src)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
