- en: Setting up API Endpoints with API Gateway
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build our first Lambda function with
    Go. We also learned how to invoke it manually from the console. To leverage the
    power of Lambda, in this chapter, we are going to learn how to trigger this Lambda
    function in response to incoming HTTP requests (event-driven architecture) using
    the AWS API Gateway service. At the end of this chapter, you will be familiar
    with API Gateway advanced topics such as resources, deployment stages, debugging,
    and much more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with API Gateway
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a RESTful API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a follow-up of the previous one, and hence it's recommended
    to read the previous chapter first to follow this part with ease. In addition,
    basic knowledge of RESTful API design and practices is needed. The code bundle
    for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with API Gateway
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Gateway is an AWS serverless API proxy service that allows you to create
    a single and unified entry point for all of your Lambda functions. It proxies
    and routes the incoming HTTP requests to the appropriate Lambda function (mapping).
    From a server-side perspective, it's a facade or a wrapper that sits on top of
    Lambda functions. However, from a client's perspective, it's just a single monolithic
    application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing a single interface to the clients, and its scalability,
    API Gateway provides powerful features such as the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Caching**: You can cache endpoint responses, hence reducing the number of
    requests made to the Lambda functions (cost optimization) and enhancing the response
    time.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CORS configuration**: By default, the browsers deny access to resources from
    a different domain. This policy can be overridden by enabling **Cross Origin Resource
    Sharing** (**CORS**) in the API Gateway.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS will be discussed in-depth in [Chapter 9](644f4baf-6536-4714-b312-f866c310b48a.xhtml),
    *Building a Frontend with S3*, with a practical example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment stages/life cycle**: You can manage and maintain multiple API
    versions and environments (Sandbox, QA, staging, and production).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: Troubleshooting and debugging incoming requests and outgoing
    responses is simple and is done by enabling CloudWatch integration with API Gateway.
    It will push a stream of log events to AWS CloudWatch Logs and you can expose
    a set of metrics to CloudWatch, including:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side errors, including 4XX and 5XX status codes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total number of API requests in a given period
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint response time (latency)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual editing**: You can describe your API resources and methods directly
    from the console without any coding or RESTful API knowledge.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: You can generate API documentation for each version of your
    API with the ability to export/import and publish the documentation to a Swagger
    specification.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and authentication**: You can secure your RESTful API endpoints
    with IAM roles and policies. API Gateway can also act as a firewall against DDoS
    attacks and SQL/scripts injection. Moreover, rate limiting or throttling can be
    enforced at this level.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's enough theory. In the next section, we will go through how to set up
    API Gateway to trigger our Lambda function each time an HTTP request is received.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its support for AWS Lambda, API Gateway can be used to invoke
    other AWS Services (EC2, S3, Kinesis, CloudFront, and so on) or external HTTP
    endpoints in response to HTTP requests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an API endpoint
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following section describes how to trigger a Lambda function using API
    Gateway:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up an API endpoint, sign in into the **AWS Management Console** ([https://console.aws.amazon.com/console/home](https://console.aws.amazon.com/console/home)),
    navigate to the AWS Lambda Console, and select the Lambda function HelloServerless that
    we built in the previous chapter:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec552854-7f6a-4af7-a783-a47090e60fcf.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Search for API Gateway from the list of triggers available and click on it:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c108355-b25b-4606-999f-9f0eae4e15fc.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: The list of available triggers may change depending on which AWS region you're
    using because AWS Lambda-supported source events are not available in all AWS
    regions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the page, a Configure triggers section will be displayed,
    as shown in the following screenshot:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b890ed7d-ec62-413d-8aba-988cfce91843.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Create a new API, give it a name, set the deployment stage as `staging`, and
    make the API open to the public:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c50f7775-2b70-4e2c-9889-a2a85a45bdfd.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'The form will have to be filled in with the following parameters:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**API name**: A unique identifier of the API.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment stage**: The API stage environment, which helps separate and maintain
    different API environments (dev, staging, production, and so on) and versions/releases
    (major, minor, beta, and so on). Plus, it''s very handy if a Continuous Integration/Continuous
    Deployment pipeline is implemented.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: It defines if the API endpoint will be public or private:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: Publicly accessible and can be invoked by everyone'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS IAM**: Will be invoked by users with granted IAM permissions'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open with Access Key**: Requires an AWS access key to be invoked'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the API is defined, the following section will be displayed:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82193949-da9d-43db-a379-08813ace3a85.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Save button at the top of the page to create the API Gateway trigger. Once
    saved, the API Gateway Invoke URL will be generated with the following format:
    `https://API_ID.execute-api.AWS_REGION.amazonaws.com/DEPLOYMENT_STAGE/FUNCTION_NAME`,
    as shown in the following screenshot:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7e5a33e-5bab-4a0d-ac91-0443b7a6cb54.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'Open your favorite browser with the API Invoke URL; you should see a message
    like the one shown in the following screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c7c1435-c10c-49a2-8412-df2be96ce26c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: The Internal server error message means that something went wrong on Lambda's
    side. To help us troubleshoot and debug the issue, we will enable the logging
    feature in the API Gateway.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debugging and troubleshooting
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to troubleshoot the API Gateway server error, we need to enable logs
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to grant the API Gateway access to CloudWatch in order to be
    able to push API Gateway log events to CloudWatch Logs. Therefore, we need to
    create a new IAM role from identity and access management.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some parts have been skipped to avoid me repeating myself. If you need a step
    by step procedure, make sure that you've followed on from the previous chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot will give you a glimpse of how to create a IAM role:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd8f0a0c-1dc3-47e3-9afa-06b63bef37f1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Select API Gateway from the list of AWS services, then, on the permissions
    page, you can do either of the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select an existing policy called AmazonAPIGatewayPushToCloudWatchLogs, as shown
    in the following screenshot:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a062fcf9-e705-4f16-ab36-220ba6f9a605.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Create a new Policy document with the following JSON:'
  id: totrans-57
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, assign a name to the role and copy the Role ARN (**Amazon Resource Name**)
    to the clipboard:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/682c4898-26b9-431a-b1fb-b5ee95adba11.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Then, select API Gateway from the Networking & Content Delivery section. Click
    on Settings and paste the IAM role ARN that we created earlier:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53c94f8d-7384-4dc9-b0f9-3ced14c6d161.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Save it and select the API created by the Lambda function. Click on Stages in
    the navigation pane:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2d174ac-a164-491b-8809-4669599eb33b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Then, click the Logs tab and under CloudWatch Settings, click on Enable CloudWatch
    Logs and select the Log level you want to catch. In this case, we are interested
    in error logs:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ab2557f-c566-4b95-9081-3c6989bd55b7.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Try to invoke the Lambda again with the API URL and jump to the AWS CloudWatch
    Logs Console; you will see that a new Log Group has been created with the format *API-Gateway-Execution-Logs_AP_ID/DEPLOYMENT_STAGE*:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/041d48b4-8982-4bf3-8151-aedc5c1ceea9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Click on the log group and you will see log streams generated by the API Gateway:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09c34f90-5688-45da-9238-9c480fbcf6fb.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'The preceding log states that the response returned from the Lambda function
    is not in the correct format. The correct format of response should contain the
    following attributes:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Body**: It is a required attribute that contains the function''s actual output.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status Code***:* This is the function response status code, as described
    in the HTTP/1.1 standard ([https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6)).
    It''s mandatory, otherwise the API Gateway will display a 5XX error, as seen in
    the previous section.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional parameters**: It include things like `Headers` and `IsBase64Encoded`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming section, we will fix this incorrect response by formatting the
    response returned by the Lambda function to meet the format expected by the API
    Gateway.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the function with an HTTP request
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen in the previous section, we need to fix the response returned by the
    Lambda function. Instead of returning a simple string variable, we will return
    a `struct` variable with a `Body` attribute which will contain the actual string
    value, and a `StatusCode` with `200` value to tell API Gateway that the request
    was successful. To do so, update the `main.go` file to match the following signature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once updated, build the deployment package with the Shell script provided in
    the previous chapter and upload the package to Lambda using the AWS Lambda Console
    or use the following AWS CLI command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ensure that you grant `lambda:CreateFunction` and `lambda:UpdateFunctionCode`
    permissions to the IAM user to be able to use the AWS command line throughout
    this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to your web browser and invoke the API Gateway URL again:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d26a326f-64ed-4c68-ab2d-4922e7001f60.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have just built your first event-driven function with Lambda
    and API Gateway.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'For quick reference, the Lambda Go package offers an easier way to integrate
    Lambda with the API Gateway by using the `APIGatewayProxyResponse` structure as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know how to invoke our Lambda function in response to HTTP requests,
    let's go further and build a RESTful API with API Gateway.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Building a RESTful API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will design, build, and deploy a RESTful API from scratch
    to explore some advanced topics involving Lambda and API Gateway.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: API architecture
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going into further detail about the architecture, we will look at an
    AIP that will help a local movie rental shop in managing their available movies.
    The following diagram shows how the API Gateway and Lambda fit into the API architecture:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db48f44-d52f-4e97-bfd3-7ff4dfe20831.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: AWS Lambda empowers microservice development. That being said, each endpoint
    triggers a different Lambda function. These functions are independent of one another
    and can be written in different languages. Hence, this leads to scaling at function
    level, easier unit testing, and loose coupling.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: All requests from clients first go through the API Gateway. It then routes the
    incoming request to the right Lambda function accordingly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Note that a single Lambda function can `Handle` multiple HTTP methods (`GET`,
    `POST`, `PUT`, `DELETE`, and so on). In order to leverage the power of microservices,
    we will create multiple Lambda functions for each functionality. However, building
    a single Lambda function to handle multiple endpoints could be a good exercise.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints design
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the architecture has been defined, we will go through the implementation
    of the functionalities described in the previous diagram.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The GET method
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first feature to implement is listing movies. That''s where the `GET` method
    comes into play. The following steps are to be referred to in order to do this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Lambda function that registers a `findAll` handler. This handler transforms
    a list of `movies` structure to a `string`, and then returns this string wrapped
    by the `APIGatewayProxyResponse` variable along with a 200 HTTP status code. It
    also handles errors in case of conversion failure. The handler implementation
    is as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of hardcoding the HTTP status code, you can use the `net/http` Go package
    and use a built-in status code variables such as `http.StatusOK`, `http.StatusCreated`,
    `http.StatusBadRequest`, `http.StatusInternalServerError`, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new Lambda function using the AWS CLI after building the ZIP
    file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`FindAllMoviesRole` should be created in advance, as described in the previous
    chapter, with permissions to allow streaming Lambda logs to AWS CloudWatch.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Heading back to the AWS Lambda Console; you should see that the function has
    been created successfully:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68a10a54-c57b-4215-bc13-5e5963bef6cf.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'Create a sample event with an empty JSON, as the function doesn''t expect any
    argument, and click on the Test button:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ded86f5-21f6-43db-bf03-7788caf6e811.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: You will notice in the previous screenshot that the function returns the expected
    output in a JSON format.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the function has been defined, we need to create a new API Gateway
    in order to trigger it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a6419f0-5de2-4331-a49d-fdc40860d891.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Next, from the Actions drop-down list, select Create resource and name it movies:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4035b98f-73ab-455a-8b9b-452485e533a8.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Expose a GET method on this `/movies` resource by clicking on Create Method.
    Choose Lambda Function under the Integration type section and select the *FindAllMovies*
    function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd7952a6-1fe9-4a99-b4dd-fc1fb6204c57.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'To deploy the API, select Deploy API from the Actions drop-down list.  You
    will be prompted to create a new deployment stage:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/048ca6a2-b121-4e8e-a884-263a07f18a3a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Once the deployment stage is created, an invocation URL will be displayed:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b3c50d4-bbb7-44fd-b5c8-b24f44667c92.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Point your browser to the URL given or use a modern REST client like Postman
    or Insomnia. I opted to go with the cURL tool as it is installed by default on
    almost all operating systems:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command will return a list of movies in a JSON format:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21ebbf74-2264-4953-8197-bae5bcd7ebbb.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: When calling the `GET` endpoint, the request will go through the API Gateway,
    which will trigger the `findAll` handler. This returns a response which is proxied
    by the API Gateway to the client in a JSON format.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `findAll` function has been deployed, we can implement a `findOne`
    function to search for a movie by its ID.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The GET method with parameters
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `findOne` handler expects the `APIGatewayProxyRequest` argument that contains
    the event input. Then, it uses the `PathParameters` method to get the movie ID
    and validate it. If the ID provided is not a valid number, the `Atoi` method will
    return an error and a 500 error code will be returned to the client. Otherwise,
    a movie will be fetched based on the index and returned to the client with a 200
    OK status wrapped in `APIGatewayProxyResponse`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in the preceding code, we have used both methods of handling errors.
    The first is the `err.Error()` method, which returns a built-in Go error message
    that's raised when the encoding fails. The second one is a user-defined error,
    which is error-specific and easy to understand and debug from the client's perspective.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the `FindAllMovies` function, create a new Lambda function for
    searching for a movie:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Go back to API Gateway console, create a new resource, and expose the `GET`
    method, and then link the resource to the `FindOneMovie` function. Note the use
    of the `{id}` placeholder in the path. The value of `id` will be made available
    via the `APIGatewayProxyResponse` object. The following screenshot depicts this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72a7969a-7868-45fb-9f68-59b39d73e2c5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Redeploy the API and use the following cURL command to test the endpoint:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following JSON will be returned:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71fb6d67-279e-4739-a3be-0dabdc8aa39c.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: When the API URL is invoked with an ID, the movie corresponding to the ID is
    returned if it exists.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The POST method
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we know how the GET method works with and without path parameters. The
    next step will be to pass a JSON payload to a Lambda function through the API
    Gateway. The code is self-explanatory. It converts the request input to a movie
    structure, adds it to the list of movies, and returns the new list of movies in
    a JSON format:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, create a new Lambda function for `InsertMovie` with the following command*:*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, create a `POST` method on the `/movies` resource and link it to the `InsertMovie`
    function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60b78a39-0b53-4814-b6e9-2f69bce47766.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'To test it out, use the following cURL command with the `POST` verb and the `-d`
    flag, followed by a JSON string (with the `id` and `name` attributes):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding command will return the following JSON response:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe9cd668-035f-41ee-ba7d-6f2bead59d27.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the new movie has been inserted successfully. If you test it
    again, it should work as expected:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command will return the following JSON response:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6d4771b-cdbe-43a8-968f-01e87e45bfd0.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it was successful and the movie was again inserted as expected,
    but what if we wait few minutes and try to insert a third movie? The following
    command will be used to execute it again:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, a new JSON response will be returned:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/460bf1f2-44ca-4dc9-b2a3-1b2cbe92fe02.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: You will find that the movies with IDs 6 and 7 have been removed; why did this
    happen?  It's simple. If you remember from [Chapter 1](746d14b6-7349-4f9e-b76f-f56706e1d0d5.xhtml), *Go
    Serverless*, the Lambda functions are stateless. When the `InsertMovie` function
    is invoked for the first time (first insert), AWS Lambda creates a container and
    deploys the function payload to the container. Then, it remains active for a few
    minutes before it is terminated (**warm start**), which explains why the second insert
    passed. In the third insert, the container is already terminated, and hence Lambda
    creates a new container (**cold start**) to handle the insert.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the previous state is lost. The following diagram illustrates the
    cold/warm start issue:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be7e04f8-2874-4469-8b8d-0e397ac9a9ad.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: This explains why Lambda functions should be stateless and why we should not
    make any assumptions that the state will be preserved from one invocation to the
    next. So, how can we manage data persistency when working with serverless applications?
    The answer is by using an external database like DynamoDB, which will be the subject
    of the upcoming chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build a RESTful API from scratch with Lambda
    and API Gateway. We also covered how to debug and troubleshoot incoming API Gateway
    requests by enabling the CloudWatch logs feature, plus how to create an API deployment
    stage and how to create multiple endpoints with different HTTP methods. Finally,
    we learned about the cold/warm container issue and why Lambda functions should
    be stateless.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用Lambda和API Gateway从头开始构建RESTful API。我们还介绍了如何通过启用CloudWatch日志功能来调试和解决传入的API
    Gateway请求，以及如何创建API部署阶段以及如何创建具有不同HTTP方法的多个端点。最后，我们了解了冷/热容器问题以及为什么Lambda函数应该是无状态的。
- en: In the upcoming chapter, we will use DynamoDB as a database to manage data persistency
    for our API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用DynamoDB作为数据库，为我们的API管理数据持久性。
