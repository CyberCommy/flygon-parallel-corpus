- en: Chapter 11. Demonstrating Functional Reactive Programming in JavaScript with
    a Live Example Part IV – Adding a Scratchpad and Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the three last endeavors intended to put it all
    together and finish our sample ReactJS application. Earlier chapters dealt with
    a basic custom-made component made with 100 percent ReactJS. This chapter is different
    in making a valid components, that works with ReactJS while drawing on a significant
    non-ReactJS-based tool.
  prefs: []
  type: TYPE_NORMAL
- en: Having made the last component, we will integrate them into one page, where
    each of the four components is placed in its quarter of the page. This is different
    from development, where we gave the tool under development the whole page. This
    will be the second major section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the page has no way of keeping track of the state. Suppose you make
    an entry in the calendar, a to-do item, or make some notes in the scratchpad.
    Then, if you navigate away and come back or reload the page, all your changes
    will be lost. It would be nice to have the changes remembered, and this is exactly
    what we will do next. In the third, and last, major section in this chapter, we
    will introduce a cheap, homegrown HTML5 localStorage-based persistence solution
    that works surprisingly well. It does not let you access your data from multiple
    computers, but let's leave that alone for now and just work on persistence on
    the same computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall application is intended to handle personal information management/logistics:
    a scratchpad for any information, a to-do list, a calendar, and a stub of whining
    artificial intelligence that is meant to be replaced by something interesting
    of your own devising.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a WYSIWYG scratchpad, courtesy CKeditor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple **What You See Is What You Get** (**WYSIWYG**) editors out
    here, and the choice of CKeditor is not much a judgment that CKeditor is the uncontested
    king of free and paid editors as a common choice. We will see how to ask ReactJS
    to leave part of the DOM alone (and in this case, not clobber our CKeditor instance).
    We will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use something such as CKeditor when it doesn't work similar to ReactJS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a "small is beautiful" take on CKeditor, with a look at which edition
    is the best
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including CKeditor in our page, with an emphasis on JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing all things together into one web page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve done almost everything together. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the JSX so that all our features are now uncommented. This is a very
    simple step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS styling that lets everything fit. We arrange the components in a 2 x 2 grid,
    but this could be replaced by pretty much any styling approach that would fit
    the components on a page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing in elementary data persistence which displays the components together.
    This will include some basic, non-exhaustive CSS work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the interests of offering a complete sample application, the user-interface-centric
    application we have been developing will include basic persistence on your computer,
    in this case humbly implemented with HTML5 localStorage. This means that one computer,
    without sign-in or other annoyances, will be able to persistently use data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few simple `JSON.stringify()` calls work and lay a foundation for a more common
    style of remote, server-based persistence. The data is stringified through `JSON.stringify()`,
    which is not specifically needed with localStorage, but makes the code slightly
    more ready to swap out the localStorage references alone and replace them with
    a potentially remote server of choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causing the CKeditor state to persist. Some experienced programmers, on being
    asked to create a localStorage persistence solution for the component state, might
    reasonably guess our solution for everything but the scratchpad. The scratchpad
    has some gotchas for Web 2.0 work, because CKeditor has some gotchas for Web 2.0
    work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire system working together may be seen at [http://demo.pragmatometer.com/](http://demo.pragmatometer.com/).
  prefs: []
  type: TYPE_NORMAL
- en: This book is about ReactJS, so why use CKeditor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might, in general, be suggested that it is better to have something that
    works with the declarative spirit of ReactJS and one-way data bindings. If you
    have a choice between a good implementation of something such as CKeditor that
    doesn't particularly work in a similar way to ReactJS, and some other component
    made that fits in nicely with ReactJS and handles WYSIWYG well, you should go
    with the component that fits ReactJS well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book is intended to help you with either side of a fork on the road. It
    includes development with and without JSX, both legacy and green field development,
    one-way and two-way data binding, and (here) purely ReactJS components versus
    integrating with non-ReactJS JavaScript tools. The good news is that ReactJS is
    good at playing nicely with other children. Tools from all across the world of
    JavaScript are at least potentially available for you, not just the sliver explicitly
    developed for work with ReactJS. Perhaps you may have the luxury of working with
    pure ReactJS components. Perhaps you want, need, or have to use some JavaScript
    tool that was not built with any ReactJS integration in mind. Here''s the good
    news: in either case, ReactJS probably has covered. In this chapter, we will use
    a standard non-ReactJS tool—the famous and well-established CKeditor, which ReactJS
    lets us integrate into our web page quite well.'
  prefs: []
  type: TYPE_NORMAL
- en: CKeditor – small free offerings, and small is beautiful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several free and commercial editors available; one such editor is
    CKeditor, (its home page is at [http://ckeditor.com/](http://ckeditor.com/)).
    CKeditor comes with four basic options: *Basic*, *Standard*, *Full*, as well as
    a *Custom* option that allows complete freedom in selecting and deselecting optional
    functionality. For this project, we will use the *Basic* option. This is not a
    service for a user to present an overwhelming array of rows of buttons, and the
    correct question regarding which features to include is, "What is the minimum
    that will work well for us?"'
  prefs: []
  type: TYPE_NORMAL
- en: Including CKeditor in our page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Basic** option (and also the Standard, Full, and Custom arrays of options)
    is available for download or from CDN. At the time of writing this book, the Basic
    option can be obtained from CDN using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be our HTML. We also need to work on JSX. The code used to put
    up the scratchpad is the simplest and shortest of our four subcomponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `render()` method is as simple as it looks. Note that it defines a `TEXTAREA`
    rather than a CKeditor widget. The different versions of CKeditor work by Hijaxing
    specific `TEXTAREAs` rather than writing their widget in the code. The `shouldComponentUpdate()`
    method is also as simple as it looks, but it is worthy of a comment. This method
    is intended to facilitate optimization for the rare case where ReactJS's virtual
    DOM diffing isn't as fast as what you can do. For instance, under ClojureScript,
    Om has immutable data structures and can therefore test equality via reference
    comparison alone, without the need for deep equality checking, which is why Om
    plus ClojureScript is about twice as fast as ReactJS plus JavaScript. And, as
    stated in earlier chapters, 99 percent of the time, micromanaging ReactJS's virtual
    DOM is simply not needed, even if you want to be very performant.
  prefs: []
  type: TYPE_NORMAL
- en: However, here we have a separate use case for the mechanism of `shouldComponentUpdate()`.
    Its use here is unrelated to optimization and obtaining the same result with less
    comparison. Instead, it is used to disclaim the jurisdiction of part of the DOM.
    For some other tools that you might like to include, such as CKeditor, it is desirable
    to ask ReactJS to create part of the DOM and then leave it alone, without later
    clobbering another tool's changes; this is exactly what we have done here. Hence,
    `shouldComponentUpdate()`—besides constituting a mechanism to prune unnecessary
    comparisons in lightning-fast virtual DOM diffing—can also be used to affix a
    label that says, "Something other than ReactJS is responsible for maintaining
    this part of the DOM. Please do not clobber it."
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first rendering of the web application, we ask CKeditor to replace
    the `TEXTAREA` that has an ID of scratchpad, which should give us a live widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we have an interactive scratchpad. Here is a screenshot of our web
    application, showing only the scratchpad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Including CKeditor in our page](img/B04108_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Integrating all four subcomponents into one page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having created four subcomponents—a calendar, a scratchpad, a to-do list, and
    a **You Pick** slot with a placeholder—we will now integrate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by uncommenting all the commented subcomponents in the Pragmatometer''s
    `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our next step is to add styling, with just a bit of responsive design. At least
    one of the main contenders in responsive design is to simply not try to know and
    address each screen resolution, but to have several steps of responsiveness depending
    on screen width. You can see this if, for example, you have a wide desktop monitor,
    load [http://therussianshop.com/](http://therussianshop.com/), and progressively
    narrow your browser window. Different adaptations kick in, and the page as a whole
    makes a whole when seen at desktop width, tablet on either orientation, or smartphone.
    We will not be attempting a serious solution here, but there is some responsiveness
    in the fact that we make our styling conditional to a minimum width of 513 px.
    Without any styling, the four elements will displayed one on top of the other;
    with styling, they will be corralled into a 2 x 2 grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS that styles the subcomponents essentially divides a sufficiently large
    window into quarters, adds some padding, and ensures that any overflow on each
    application will scroll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to display and the following is a screenshot of all the parts
    of our web application put together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating all four subcomponents into one page](img/B04108_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some frameworks are all-purpose frameworks that are intended to do everything;
    ReactJS is not. It does not even offer any method by which to make an AJAX call,
    even though (practically) any important project that uses ReactJS will have AJAX
    requirements. This is entirely by design. The reason is that ReactJS is specialized
    as a framework for working on user interfaces or making Views, and it is intended
    to be combined with other technologies to make whatever complete package is appropriate
    for your site.
  prefs: []
  type: TYPE_NORMAL
- en: One feature that is desirable in this Pragmatometer application is that it remembers
    the data you enter. If you enter an appointment for tomorrow at 2:00 p.m., then
    leave the page and come back, it would be nice if the page remembered the appointment
    instead of presenting a completely blank slate every single time you load it.
    Persistence is one part of a complete web application, but it's not the responsibility
    of the view or user interface, and ReactJS obviously does not offer a solution
    for persistence. Nor should it—perhaps. Some recent chapters covered how to use
    ReactJS to do "X"; this chapter is about how to do something else that complements
    ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: For mainstream use, persistence is usually handled by communication with a backend;
    there are several good technologies available. But perhaps it will not be terribly
    useful to try to cram the treatment of properly implementing a backend into one
    section of one chapter of a book on frontend development with ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise that remains squarely in frontend territory, we will handle persistence
    by a well-known frontend route—HTML5's localStorage (the persistence code does
    nothing if Modernizr fails to detect localStorage). The functions used, `save()`
    and `restore()`, save in localStorage if such is found. They call `JSON.stringify()`
    and `JSON.parse()` directly, even though such a step is not strictly needed to
    cause JSON-serializable objects to persist in localStorage. This is intended to
    provide a direct hook to change the code to talk to a remote backend. The simplest
    adaptation would, like the implementation here, monolithically save and restore
    the entire state for an application, but remember that premature optimization
    remains the root of all evil. Extremely heavy use of an application in this way
    might lead to an amount of state comparable to a single large PNG file. The code
    is, of course, further adaptable to more surgical approaches to saving or restoring
    a diff that is lighter, but the point here is to lay a solid groundwork, not push
    optimization as far as it can go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Crockford''s JSON from [https://github.com/douglascrockford/JSON-js/blob/master/json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)
    and Modernizr from [http://modernizr.com/](http://modernizr.com/). We will only
    use Modernizr in this application to test the localStorage availability, so if
    you''re looking for a "minimum weight that''s sufficient for this project" Modernizr
    build, opt to test for localStorage and opt out of everything else. Let''s include
    these files in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `site.jsx` file, we define the `save()` and `restore()` functions. These
    will be used to cause the entire state to persist for different applications.
    A different approach might be to make more and smaller saves instead of a few
    monolithic saves, but a few monolithic saves are easy to keep track of mentally.
    Therefore, they are easier to maintain and debug than a mesh of different saves
    for minor aspects of data (if we need to optimize later, we can, but premature
    optimization is still the root of all evil). The save() function reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The most obvious way to connect this to a remote backend, besides taking care
    of details such as account management (which are not addressed in this example),
    would be to replace the `localStorage[key]` assignment with a call to notify the
    server of the new stringified data associated with that key. That would make the
    Modernizr check unnecessary. However, be warned: even IE8 supports localStorage,
    and clients that don''t support it will be a little archaic and probably not supported
    by ReactJS, which does not advertise support for IE versions earlier than 8 (also,
    IE8 support is now based on a shim instead of being native; see [http://tinyurl.com/reactjs-ie8-shim](http://tinyurl.com/reactjs-ie8-shim)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `restore()` function takes an optional parameter besides key—`default_value`.
    This is used to support an initialization that pulls the saved state if it exists
    and falls back to the normal value that would otherwise be used in initialization.
    Initialization code can be reused to work with this `restore()` function, which
    pulls non-null and defined saved data for that key if it exists, or the default
    if nothing interesting is found. The line with `JSON.parse()` and the `if` statement
    that probes localStorage are the lines you would most directly replace with calls
    to talk to a remote backend. Alternatively, and to take a step further, the `restore()`
    function would probably be gutted and replaced with a function with the same signature
    and semantics, but would talk to a remote server that owned more of the work of
    checking whether any pre-existing data has been saved. This perhaps leaves the
    client to return the default value if the server has nothing to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all the `getInitialState()` functions are modified to go through the restore()
    function. See what happens hence. Consider the `Todo` initializer of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is simply wrapped in a call to `restore()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few functions that alter the state on one component or another,
    and we make any function that changes part one of our component''s states save
    the whole state. Hence, in the appropriately named `Calendar#handle_submit`, numerous
    details of `this.state.entry_being_added` are filled in to match what is on the
    (Hijaxed) form. Then the filled-in entry is added to the list of live filled-in
    entries, and a new one is put in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These two lines alter `this.state`, and so we save the state after them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One detail – persisting the CKeditor state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of this section is relatively predictable. Some programmers, who were told
    that we were adding persistence through HTML5 localStorage, might have guessed
    something close to what was written earlier, and most likely, they would be pretty
    close to the mark. There is one detail about CKeditor, however, that is less than
    obvious and less than ideal.
  prefs: []
  type: TYPE_NORMAL
- en: CKeditor does what you might naïvely expect under "un-fancy" Web 1.0 form usage.
    If you have a form, include a `TEXTAREA` with a name and ID of `foo`, call CKeditor
    to convert it, and submit the form. The form will be submitted as if the HTML,
    which was then on the CKeditor instance, had been the content of the `TEXTAREA`.
    All of this is as it should be.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you use CKeditor in almost any "AJAXian" way, querying the value
    of the text area without having a full-page form submission, you will run into
    a problem. The reported value of the CKeditor instance is neither more nor less
    than the text that it was initialized to. The reason is that the value of `TEXTAREA`
    is synced for you on a whole-page form submission, but this is not automatically
    done at the intermediate steps. This means that unless you take an extra step,
    you cannot usefully query the CKeditor instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the extra step is not particularly difficult or slippery; CKeditor
    provides an API to sync the `TEXTAREA`, so you can query `TEXTAREA` to get the
    CKeditor instance''s value. Before connecting the CKeditor scratchpad, we initialized
    the entire display and set an interval so that the display is updated every 100
    milliseconds (there is nothing necessary or magical about this length for an interval;
    it could be updated more or less often, with longer intervals being choppier but
    basically the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To accommodate CKeditor, we shuffle and unbundle things slightly. Our code will
    be a little messier in order to accommodate calling things in a particular order.
    For our `TEXTAREA` to exist in the first place, we need to render the Pragmatometer
    master component once (or more than once, if we want). Then, after that call,
    we ask CKeditor to convert the `TEXTAREA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we start an update function. This both updates the display and synchronizes
    CKeditor''s `TEXTAREAs` to where they can be queried. The loop that synchronizes
    the `TEXTAREA` is not strictly necessary. If we have only one editor instance,
    we need only one line of code, but the code we have is generic for any number
    of CKeditor instances with any ID. Finally, within the loop, we call `save()`
    on the editor contents. One optimization, if `save()` and `restore()` are gutted
    and replaced to talk to a backend server, would be to save the current editor
    state in a variable and only `save()` if the editor''s contents differ from the
    previous saved value. This should diminish the frequent network chatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are a few more changes so that all of the initialization wraps our earlier
    code in a call to `restore()`. Also, each time we change a component's state,
    we call `save()`. And we're done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a fourth component. It differs from the others by
    not being built from the ground up in ReactJS, but integrating a third-party tool.
    This can work well enough; just be careful to have a `shouldComponentUpdate()`
    method that returns `false` as a way of saying, "Don't clobber this; let the other
    software do its work here."
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that we covered three basic topics—a component, integration,
    and persistence—this chapter was easier than some others. We have a live, working
    system, and you can see it at [http://demo.pragmatometer.com/](http://demo.pragmatometer.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a step back to look at the conclusion, discussing what you learned
    over the course of this book.
  prefs: []
  type: TYPE_NORMAL
