- en: '*Chapter 4*: Building a Photo Management Desktop App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only built web applications with Vue 3\. In this chapter, we
    will build a photo management desktop app with the Vue Electron plugin. We will
    learn how to easily build cross-platform desktop apps with Electron and Vue. This
    is useful because we can build cross-platform desktop apps without much additional
    effort. This will save us time and get us good results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project with Vue CLI Plugin Electron Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a photo submission UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a photo display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routing to the Photo Manager app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using our app with photo management APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand this chapter, you should already know how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create basic Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create projects with the Vue CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the code for this chapter at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter04](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Components** can only have so much inside them. They take props from the
    parent component, so we can customize their behavior. Additionally, they can have
    computed properties and watchers to watch for reactive properties and return the
    data or do the things we want them to do. They can also have methods that allow
    us to do specific things with them. Components should be simple; that is, they
    should not have too much going on inside them. Templates should only have a few
    elements and components inside them in order to keep them simple. Components also
    have some built-in directives for us to manipulate the **Document Object Model**
    (**DOM**) and carry out data binding.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, components cannot do much. It would be impossible to build
    anything with non-trivial complexity if we only have a few components and no way
    to navigate with URLs.
  prefs: []
  type: TYPE_NORMAL
- en: If our app only has components, then we can only nest a few of them before it
    gets too complex. Additionally, if we have lots of nested components, then the
    navigation becomes difficult. Most apps have different pages, and it's impossible
    to navigate without some kind of routing mechanism in place.
  prefs: []
  type: TYPE_NORMAL
- en: With Vue Router, we can render the components we want when we go to a given
    URL. We can also navigate to the routes with the `router-link` component provided
    by Vue Router. Vue Router has many features. It can match URLs to routes. The
    URL can have query strings and URL parameters. Additionally, we can add nested
    routes with it so that we can nest the routes inside different components. Components
    that are mapped to URLs are displayed in Vue Router's `router-view` component.
    If we have nested routes, then we need the `router-view` component in the parent
    route. This way, the child routes will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: To navigate to different routes, Vue Router provides a wrapper for the JavaScript
    History API, which is built into nearly all modern browsers. With this API, we
    can easily go back to a different page, go to a historical record, or go to the
    URL we want. Vue Router also supports HTML5 mode so that we can have URLs that
    don't have the hash sign to distinguish them from server-side rendered routes.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, transition effects are supported, and we can see them when we
    navigate between different routes. Styles can also be applied to the links when
    the link is the one that has been navigated to and is active.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vue CLI Plugin Electron Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can convert JavaScript client-side web applications into desktop apps with
    Electron. Vue CLI Plugin Electron Builder enables us to add the files and settings
    to build a Vue 3 app inside a desktop app without many manual changes. Essentially,
    an Electron app is a web app that runs inside a Chromium browser wrapper that
    displays our web app. Therefore, it can do anything that we need it to do, with
    a browser. This includes some limited hardware interaction such as using microphones
    and cameras. Also, it provides some native capabilities such as displaying items
    in the notification area of popular operations systems and displaying native notifications.
    It is intended to be an easy way to build desktop apps from web apps that do not
    require low-level hardware access.
  prefs: []
  type: TYPE_NORMAL
- en: Vue CLI Plugin Electron Builder is the fastest way to create an Electron app
    from a Vue app, as it has support for some native code. We can also include native
    modules in our code with it; we just have to include the locations of the Node.js
    modules with the native code that we want to include. Additionally, we can include
    environment variables to build our code accordingly for different environments.
    Web workers are also supported since this is supported by Chromium. We can use
    it to run background tasks so that we don't have to hold up the main browser thread
    when we want to do long-running or CPU-intensive tasks. All this can be done with
    either regular Vue app code or via configuration changes. There are also other
    things that Electron supports that are not supported with Vue CLI Plugin Electron
    Builder. This means it's more limited in its capabilities. Features such as native
    menus are not available when using this plugin. However, we can build the desktop
    app on multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a photo manager desktop app that will run on
    Windows. The app will consist of a page to display all the photos you have added.
    Also, it will allow users to add photos and store them; it will have a form to
    enable users to add photos. The photos will be stored using our own photo storage
    mechanism. We will use Vue Router to let us navigate through the pages manually
    or automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project with Vue CLI Plugin Electron Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a project with Vue 3 and Vue CLI Plugin Builder is an easy task. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, create a project folder called `vue-example-ch4-photo-manager`.
    Then, go into the folder and run the following commands with `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run the following commands with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you have run the command, you should see a menu with choices for the types
    of projects you can create.
  prefs: []
  type: TYPE_NORMAL
- en: Pick the default **Vue 3 project** option to create a Vue 3 project. Then, add
    Vue CLI Plugin Electron Builder to our Vue app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add the Vue CLI Electron Builder plugin, run `vue add electron-builder` in
    your project folder. Run `cd <folder path>` to navigate to the folder. All the
    files and settings will be added to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the command is run, we should see a couple of new things in our project.
    We now have the `background.js` file that has the code to display the Electron
    window. We also have a few new script commands added to our `package.json` file.
    The `electron:build` script command lets us build our app for production. The
    `electron:server` command lets us serve our Electron app with a development server
    so that we can develop our app with it. We are automatically provided with hot
    reload capability so that we can see all the changes live in the browser and also
    in the Electron desktop app window. Since it's just a wrapper for a browser, we
    can see the latest changes in the desktop window with our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the desktop window, we should also see the Chromium development console,
    which is the same as the one in the browser. To make debugging easier, we suggest
    looking at the browser window for debugging since we can inspect elements and
    do whatever we want to do in our development console.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the `background.js` file can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter04/src/background.js](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter04/src/background.js).
  prefs: []
  type: TYPE_NORMAL
- en: The `BrowserWindow` constructor creates a browser window with a width of 800
    px and a height of 600 px, by default. We can change the window size by dragging
    the window as we would do with other desktop apps. The `win.loadURL()` method
    loads the home page for our app, which is the `index.html` file. The `index.html`
    file is in the `dist-electron` folder. Otherwise, we call the `win.loadURL()`
    method to load the `webpack-dev-server` URL in order to see the app in a window
    in the development environment. This is because `webpack-dev-server` only loads
    the app in memory when it is run in the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `win.webContents.openDevTools()` method opens the Chromium development console
    in the development environment. The `app.quit()` method exits the desktop app.
    We listen to the message event when it is running under Windows, as indicated
    by the `process.platform === 'win32'` expression. Otherwise, Electron listens
    to the SIGTERM event and closes the window when that is emitted. The SIGTERM event
    is emitted when we end a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the title of the window, we just change the `title` tag in the `public/index.html`
    file. For example, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We just change the `title` tag's content to what we want, and the text will
    be displayed as the title of the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, once we run the `vue add electron-builder` command, we get the files
    and settings added. To start the development server and display the Electron app
    on our screen, we run the `yarn electron:serve` or `npm run electron:serve` commands,
    which are provided by Vue CLI Plugin Electron Builder. You should see a window
    display on the screen (please refer to *Figure 4.1*). This will automatically
    refresh when we make any changes to the existing files or if we add or remove
    files. Now we are almost ready to start building our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Electron app window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.1_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – The Electron app window
  prefs: []
  type: TYPE_NORMAL
- en: We will install a few packages that we need to use in our Vue app and the Vue
    Router library to add routing to our app. We will use it for the router links
    and to also navigate programmatically. We will also use the Axios HTTP client
    to make HTTP requests easily to our API. To install the packages, we can run the
    `npm install axios vue-router@4.0.0-beta.9` or `yarn add axios vue-router@4.0.0-beta.9`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: We install Axios so that we can make HTTP requests conveniently. Now we are
    ready to build our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a photo submission UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build the app, we will first add our components and the file to store the
    constants that we will need throughout the app. To start with, we get rid of the
    `components/HelloWorld.vue` file. Then, we remove any references of it in the
    `App.vue` file, including the `import` and `components` properties to unregister
    the component. Now we will add some new components to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the `PhotoFormPage.vue` component file to the `src/components`
    folder. Inside the file, we add the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This template has the inputs for adding and editing photos. `name` and `description`
    are text inputs. The `Date Taken` field is a date input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add the photo field as a file input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will read the selected file into a base64 string so that we can save the
    data easily using an HTTP request. We also use the base64 string to preview the
    image in the `img` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add the `script` tag to `PhotoFormPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This determines whether we are editing an existing photo or creating a new one
    by checking whether the `id` parameter is set. If it is, then we are editing.
    Otherwise, we are creating a new photo. This logic is used in the `submit` method
    and the `beforeMount` hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `submit()` method''s `id` is used to make an HTTP request to the API to
    save the entry. We get the `id` parameter from the route by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, we add an `if` statement immediately below that to check whether it is
    set. If it is set, we make a *PUT* request to update an existing entry. Otherwise,
    we make a *POST* request to create a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: In this component, we have a form that allows us to add and edit the photos
    in our app. We display the **Add** or **Edit** text depending on the value of
    the `edit` prop. Then, we have a form with a bunch of fields in it. The `form`
    element has the submit event listener that runs the `submit()` method when we
    click on the **Submit** **input** button. The `prevent` modifier runs the `event.preventDefault()`
    method without us having to add it ourselves inside the `submit` handler. We need
    this since we don't want the browser to execute the default `submit` behavior,
    which will submit our form data to the server directly. We want to process the
    data on the client side with our own client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we won't create our own API and we won't do any data validation
    on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the modifier saves us from typing it in and also makes our code shorter.
    The directive syntax is common enough that there is a symbol for it. The `@` symbol
    can also be replaced with the `v-on` directive since `@` is the shorthand for
    the `v-on` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `form` tag, we have the `input` elements with the `v-model` directive
    that binds to various properties of the `form` reactive property. The `label`
    HTML element is the label of each input. The `label` has the `for` attribute,
    which allows it to map the label to the `id` parameter of the `input` element.
    This is good for accessibility since screen readers will pick it up and read it
    to the user. This is very helpful for visually impaired users of our app. We will
    use very similar code in the `textarea` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The date and time picker is a native date and time picker that is created by
    setting the `type` attribute to `datetime-local`. This enables us to add a date
    and time picker that is set to the time zone of your device. Then, we set the
    `v-model` directive to bind the date and time picker value to the one that the
    user picked in the browser or desktop app window. Most modern browsers support
    this type of input, so we can use this to enable users to pick the date and time.
    The `type` attribute can also be set to `date` to add a date picker only. Additionally,
    we can set the type to `datetime` to add a date and time picker that is set to
    UTC.
  prefs: []
  type: TYPE_NORMAL
- en: The `file` input is more complex. The input's `type` attribute is set to `file`
    so that we can see a file input. Additionally, it has a change event listener
    that runs the `onChange()` method to convert the binary image file into a base64
    string. This saves the image to our API as a text string. For a small app, such
    as this photo management app, we can save images directly as a string.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we were building a production-quality app with lots of users using
    the app and making lots of file uploads, then it would be a good idea to save
    the files in a third-party storage service, such as Dropbox or Amazon S3\. Then,
    we could just get the files from the URL instead of as a base64 string. The HTTP
    URL and the base64 URL are equivalent. We can set both as the value of the `src`
    attribute of the `img` tag to display the image. In this case, we set the `src`
    attribute to the base64 URL in the `img` tag inside our form element.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of our form, we have the input with the `type` attribute set to
    `submit`. This allows us to submit the input by pressing *Enter* on a form input
    element or clicking on the **Submit input** button.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the `data()` method. This returns the initial values of the `form`
    reactive property. The `form` reactive property includes the `name`, `description`,
    `dateTaken`, and `photoFile` properties. The `name` property is the name of our
    photo. The `description` property is the description of our photo. The `dateTaken`
    property has a string with the date and time that the photo was taken at. And
    the `photoFile` property is the base64 string representation of the photo file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a few methods in this component. First, we have the `submit()`
    method that either makes a *PUT* request, to update an existing photo entry, or
    a *POST* request, to create a new photo entry. Before we make any HTTP requests,
    we check whether all the properties of the `this.form` reactive property are populated
    with non-falsy values. We want all the fields to be filled in. If there is a false
    value that has been set as the value of any of the properties, then we show an
    alert that tells the user to fill in all the fields.
  prefs: []
  type: TYPE_NORMAL
- en: To make the process of getting the properties shorter, we destructure the properties
    of the `this.form` reactive property and then carry out a check. After that, we
    check whether the `edit` prop is `true`. If it is, then we use the *PUT* request
    to update an existing entry. The `id` prop is set to the `$route.params.id` value
    so that we get the value of the ID URL parameter from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `edit` reactive property is `true`, then we make a *PUT* request to
    our API to update an existing photo entry. To make the *PUT* request, we call
    the `axios.put()` method. This takes the URL as the first argument and an object
    with the request body content as the second argument. Otherwise, we call `axios.post()`
    with the same arguments to make a *POST* request to create a new photo entry.
    The URL of the *PUT* request has the ID of the photo entry attached to the end
    of it so that the API can identify which entry to update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have also defined the `onChange()` method to be used as the change event
    listener for the file input. When we select a file, this method is run. In the
    method body, we create a new `FileReader` instance to read the selected image
    file into a base64 string. The parameter has an event object, which has the file
    that we selected. The `ev.target.files` property is an array-like object with
    the selected files. Since we only allow the user to select one file, we can use
    the `0` property to get the first file. `0` is a property name and not an index
    since the `files` property is an array-like object; that is, it just looks like
    an array but doesn't act like it. However, it is an iterative object, so we can
    use the `for-of` loop or the `spread` operator to loop through the items or convert
    them into an array.
  prefs: []
  type: TYPE_NORMAL
- en: To read the selected file into a base64 string, we call the `reader.readAsDataURL`
    method with the file object as the argument to read the file into a base64 string.
    Then, we get the result by listening to the load event emitted by the `reader`
    object. We do this by setting an event handler as the value of the `onload` property.
    The result that is read is inside the `result` property. It is set to the `this.form.photoFile`
    property so that we can display the image in the `img` tag below our file input
    and also store it in our database after we submit it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add some code to the `beforeMount` hook. We check for the value of
    the `this.edit` prop and then get the photo entry from our API if the value of
    the `this.edit` prop is `true`. We only need to check when we are mounting this
    component since we are using this component in a `route` component. Additionally,
    a `route` component is mounted when we go to a URL that maps to the component.
    When we go to another URL, the component will be unmounted. Therefore, we won't
    need a watcher to watch for the values of the `edit` or `id` props. We set the
    retrieved data to the `form` reactive property so that the user can see the data
    in the form fields and edit them as they wish.
  prefs: []
  type: TYPE_NORMAL
- en: The `axios.post()`, `axios.put()`, and `axios.get()` methods all return a promise
    that resolves to the response data as its resolved value. The `data` property
    has the response data. Therefore, we can use the `async` or `await` syntax to
    make our promise code shorter, just as we did in the entire component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `style` tag, we have several styles that we can use to style our form.
    We display the form closer to the center of the screen by adding a `margin` property
    and setting it to `0 auto` in our `form` class. The width is set to `70vw` so
    that it is set to take up only 70 percent of the viewport width instead of the
    entire width. The `form-field` class has the `width` property set to 100 percent
    so that the form fields fill up the entire width of the form. Otherwise, they
    will be displayed at the default width, which is very short. The `photo-preview`
    ID is assigned to the `img` tag that we use for the preview. And we set the `width`
    property of it to `200px` so that we only show a thumbnail preview of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we make requests that allow us to edit or delete the photo entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a component for our home page. We will create a `HomePage.vue`
    file in the `src/components` folder and write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This file is more complex than the components we previously created. In the
    `component options` object, we have the `data()` method that returns the initial
    values for our reactive properties. We only have one in this component to hold
    the photos. The `photos` reactive property will have the files. In the `methods`
    property, we have a few methods that can be used to populate the reactive properties.
    The `load` method uses the `axios.get()` method to get the data from the `photos`
    endpoint. `APIURL` is from the `constants.js` file, which we will create later.
    It simply has a string with the base URL for the endpoints, to which we can make
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: The `axios.get()` method returns a promise that resolves to an object. The object
    has the HTTP request. The `data` property has the response body. We assign the
    body data to the `this.photos` reactive property to show the photo entries in
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for retrieving the photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `edit()` method calls the `this.$router.push()` method with an object that
    has the URL path that we want to go to. Additionally, the `path` property has
    the base path for the route we want to go to plus the URL parameters that we want
    to add to the end of the path. The `id` parameter is a URL parameter that we attach
    to the path. It has the ID of the photo entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deletePhoto()` method also takes the `id` parameter. It is the same one
    as the parameter of the `edit()` method. In this method, we call the `axios.delete()`
    method to make a *DELETE* request to the `photos` endpoint with the `id` parameter,
    which was used as the URL parameter, to identify which entry to delete. Once the
    item has been deleted, we call the `this.load()` method to reload the latest entries
    from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `template` section, we use the `v-for` directive to render the entries
    of the `photos` reactive property array into a table. The `key` prop is required
    to identify unique items with a unique ID. The `key` prop is very important since
    we are going to remove items from the list when the user clicks on the **Delete**
    button. This means that each entry must have a unique ID so that Vue 3 can identify
    all of the items after we delete one item properly. This is so that the latest
    items can render correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We render the photos using a `v-for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the image, we use the `img` tag with the `src` prop. The `photoFile`
    property is a base64 URL that has the text form of the image. The other properties
    are strings that we render directly in our table. In the rightmost column, we
    have two buttons – **Edit** and **Delete**. The **Edit** button calls `edit()`
    with the `id` property of the photo entry when we click on it. This will navigate
    us to the photo edit form, which we will create later. The **Delete** button will
    call the `deletePhoto()` method with the `id` property of the photo entry to delete.
    The items will be reloaded once the items are deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The Edit and Delete buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.2_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The Edit and Delete buttons
  prefs: []
  type: TYPE_NORMAL
- en: In the `style` tag, we have some CSS to display `div` tags as a table. The `row`
    class has the `display` property set to `flex` so that we can use it as a `flexbox`
    container. The `flex-wrap` property is set to `wrap` so that we can wrap anything
    that overflows. Usually, we won't have anything that overflows in this template.
    `justify-content` is set to `space-between` in order to evenly distribute the
    child elements in the `flexbox` container.
  prefs: []
  type: TYPE_NORMAL
- en: The `div` tags inside the `div` tag with the `row` class have the `width` property
    set to `25%` so that we can evenly distribute the child elements in the row. This
    allows us to display the four `div` tags inside the `div` tag for the row side
    by side. The `img` element inside the `div` tag with the `row` class has the `width`
    property set to `100px` so that we can view a small thumbnail preview in the list
    of photos.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `style` tag has the `scoped` attribute, which means that the styles won''t
    affect any other components in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a navigation bar in our app. To do that, we go into the `src/components`
    folder and add the `NavBar.vue` component file. Once we have created the file,
    we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added a `ul` element to add an unordered list. This way, we won't see
    any numbers displayed on the left of each `li` element. Inside the `li` elements,
    we have the `router-link` component from Vue Router to display the links that
    allow us to navigate our app. We use `router-link` instead of a regular `a` tag.
    This is because Vue Router will resolve the `to` prop of the `router-link` component
    to the correct path and display the component we expect if it finds a match in
    the URL patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Since we haven't registered the Vue Router plugin or any of the routes yet,
    or added `NavBar` to any component, we won't see anything in the navigation bar.
    The `style` tag has some styles that can make the links display horizontally instead
    of vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we have a **Log Out** link to log us out of the app. The `logout()`
    method clears the local storage with the `localStorage.clear()` method. Then,
    we redirect back to the login page by calling the `this.$router.push()` method
    with the `/login` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `ul` `li` selector has the `list-style` property set to `none`, so we don't
    see the bullet displayed to the left of the `NavBar` item. We display them horizontally
    with the `display` property set to `inline`. Then, we add the `margin-right` property
    and set it to `10px` so that we have some spaces between the links.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ul` selector has the `margin` property set to `0 auto`, so we can center
    the links horizontally. The `width` is `70vw` so that they are closer to the center
    of the screen instead of putting the items on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have finished the form that allows us to save our photos, let's
    take a look at how to display the added photos on a page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a photo display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we add a search page so that we can search for photo entries using their
    names. To do that, we add the `SearchPage.vue` component file to our project's
    `src/components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SearchPage.vue` component is simpler than the `PhotoForm` component. It
    has one form element with one form field. The form field is used to accept a keyword
    from the user to search our photo collection. The input has the `type` attribute
    set to `text`, so we have a regular text input in our code. As with the other
    inputs, we bind the input value to a reactive property with the `v-model` directive.
    The `id` parameter is set so that we can use the `for` attribute with the label.
    The form also has a **Search** button, which has an `input` type set to `submit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, the search results are displayed in a `row` class so that the items are
    in rows. This is similar to how we display the photos in the `HomePage` component.
    `img` has the base64 URL set as the value of the `src` prop. Additionally, we
    have the `name` and `description` properties to the right of it. The `v-for` directive
    loops through the `photos` reactive property array to enable us to display the
    data. Once again, we have the `key` prop set to a unique ID to display the items
    by their IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `component options` object, we use the `data()` method to initialize
    our reactive properties. They include `keyword` and `photos`. The `keyword` reactive
    property is used for the search keyword. The `photos` reactive property is used
    to store the photo collection search results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `methods` property, we have a few methods that we can use. The `search()`
    method allows us to get the data with the `axios.get()` method. This method makes
    a *GET* request with a query string, so we can get the entries we are looking
    for. The `this.$route.query.q` property is used to get the `q` query parameter
    from the URL. This property is made available because we will register the Vue
    Router plugin so that we can get the `query` parameter from this property. Once
    we get the response data, we assign it to the `this.photos` reactive property.
  prefs: []
  type: TYPE_NORMAL
- en: The `submit()` method is run when the form is being submitted, either by clicking
    on the **Search** button or pressing *Enter*. Since we listen to the `submit`
    event in the form, this method will be run. Like with all the other forms, we
    add the `prevent` modifier to the `@submit` directive. This is so that we can
    call to the `event.preventDefault()` method to prevent data from being submitted
    to the server side. In this method, we call the `this.$router.push()` method to
    redirect the page to the `/search` path with a query string. The `/search` path
    will be mapped to the current component, so we just remount this component with
    the new query string in the URL. This way, we can set the `this.$router.query.
    q` property to get the query string parameter with the key to get the query string
    value and use it.
  prefs: []
  type: TYPE_NORMAL
- en: The `name_like` URL query parameter will be picked up by the API so that we
    can search for the text that we set as the value in the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a watcher for the `$route` reactive property. We need to set
    the `immediate` property to `true` so that we get the latest value of the `query`
    parameter, and then run the `search()` method to get the data from the *GET* request
    when this component mounts. The `handler()` method has a method that runs when
    the `$route` object changes. The changes to the `query` property will be picked
    up. Therefore, inside the method, we set the `keyword` reactive property to the
    value of `this.$route.query.q` to display the latest value of the `q` query string
    in the input box. Additionally, we call the `this.search()` method to get the
    latest search results based on the query string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `styles` tag has some styles that we can use to style our form and rows.
    They are similar to the ones we had before. We make the form fields wide and display
    the form closer to the center. The rows are displayed with a flexbox container
    with all of the cells having an even width within the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create a file to export an `APIURL` variable so that the
    components can reference them. We have used these in most of the components we
    have created so far. In the `src` folder, we create the `constants.js` file and
    write the following code to export the `APIURL` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can import `SearchPage.vue` to all of our components properly and add
    a search page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routing to the Photo Manager app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without the Vue Router plugin, we cannot display the page components inside
    our app. The links won''t work and we cannot redirect anywhere. To add the Vue
    Router plugin, we need to register it and then add the routes. We add the following
    code to the `src/main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we import all of the page components and then put them into the
    `routes` array. The `routes` array has the routes. Each object in the array has
    the `path` and `component` properties. The path has the URL patterns we want to
    match to the component and the `component` property has the `component` object
    that we want to load when the URL pattern matches what we have in the path. The
    path is a string with a URL pattern. We have one URL parameter placeholder in
    our string. The `:id` string has the URL placeholder for the `id URL` parameter.
    In our `EditPhotoFormPage` component, we retrieve the `id URL` parameter by using
    the `this.$route.params.id` property. It will be returned as a string.
  prefs: []
  type: TYPE_NORMAL
- en: The `createRouter()` function enables us to create a router object that we can
    register in our app using the `app.use()` method. This is new to Vue Router 4
    and is different from Vue Router 3\. The way we register the Vue Router plugin
    and the routes is different from Vue Router 3\. Therefore, Vue Router 4 is the
    only version that can be used with Vue 3\. The `createWebHistory()` function lets
    us use HTML5 mode. Using this, we can remove the hash sign between the base URL
    segment and the rest of the URL. This makes the URLs look better and more familiar
    to the user. The `routes` property has the array of routes that we created earlier.
    Then, to register the routes and the Vue Router plugin, we call `app.use(router)`
    to register both. Now the `router-link` components and the redirects should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `beforeEnter()` method is a per-route navigation guard. We need this method
    so that we can only access the pages that are available after login. In this method,
    we check whether the local storage item with the key logged in is `true`. Then,
    if that is `false`, we redirect to the login page by calling the `next()` function
    with the `path` property set to `login`. The `return` keyword is required before
    calling `next` since we don''t want to run the rest of the function''s code. Otherwise,
    we just call `next` to continue with the navigation to the destination route,
    which is the value of the `path` property. We also add the `beforeEnter()` method
    to the route objects that we want to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `src/App.vue`, we add the `router-view` component and the `NavBar`
    component by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We import the `NavBar.vue` component and then register it by putting it in the
    `components` property. Then, we add the `nav-bar` component to display the navigation
    bar with the `router-link` components using router links. The `router-view` component
    displays the component that is matched by Vue Router by comparing the URL pattern
    to the patterns in the `routes` array.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we click on the links or submit the forms successfully, we will see
    the routes loaded.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to display the `nav-bar` component when we are on the login page.
    Therefore, we add a check for the `$route.fullPath.includes()` method to check
    whether we are on the login page. The `$route.fullPath` property has the full
    path without the base URL of the current page.
  prefs: []
  type: TYPE_NORMAL
- en: Using our app with photo management APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we looked at the client-side part of the photo display.
    To return the photos from the API, we have to add a backend API that will enable
    us to store and retrieve the data for our app. Since this book is mostly focused
    on client-side app development with Vue 3 and not server-side app development,
    we will use a simple API solution to store our data with JSON so that we don't
    have to create our own API. All of the data is stored in a flat-file database,
    which is entirely JSON. To do this, we use the JSON Server package. This is a
    package that requires no configuration, and we can get it running in only a minute.
    All our fields are stored as JSON object properties, so they need to be text,
    including images. This package is made for frontend developers who require a backend
    to quickly prototype our apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we run `npm i –g json-server` to install the JSON Server package. This
    way, we can access the JSON Server package from any folder. Once we do that, we
    create a `photo-api` folder to store our photo database. Then, inside the folder,
    we add the `db.json` file. Next, we create the `photo-api` folder, go to the folder
    we just created, and run `json-server --watch db.json` to run the server. Inside
    the folder, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `db.json` files, we will have all the endpoints that we point to in
    our Vue 3 app. The server should be listening to port `3000`, and so, the base
    URL for the API is `localhost:3000`. Now, we should have access to the following
    API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /photos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /photos/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /photos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /photos/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /photos/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /photos/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GET /photos` endpoint allows us to get all the items in the `photos` JSON
    array. The `GET /photos/1` endpoint returns a single photo entry with an ID of
    `1`. We can replace it with any ID. The `POST /photos` endpoint enables us to
    add a new entry in the `photos` JSON array. `PUT /photos/1` and `PATCH /photos/1`
    allow us to update a photo entry with ID `1`. The `DELETE /photos` route lets
    us delete a photo with an ID of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The *GET* request also takes a query string. In order to search the field with
    a given piece of text, we can make a *GET* request to a URL such as `GET /photos?tname_like=foo`.
    This enables us to search the Name field of each entry and find the `photos` entries
    with the Name field containing the text as its value.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should be able to make the requests that we have in the client-side
    API to get the things we want. The whole JSON array is returned as JSON so that
    we can render the items easily. The JSON Server package will watch for any updates
    to the JSON, so we will always get the latest data. Additionally, we can change
    the port by using the `port` flag. So, we can write something such as `run json-server
    --watch db.json –port 3005` to run the JSON server in port `3005`. The `APIURL`
    variable also has to change accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the server is running, we should see something similar to the following
    in Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – JSON Server output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.3_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – JSON Server output
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our Electron desktop app window has the Vue 3 photo management app displayed,
    and we can manipulate our photo collection as we wish. We should now be able to
    view our app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Photo App form'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.4_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – The Photo App form
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the Search page in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The Search page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.5_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – The Search page
  prefs: []
  type: TYPE_NORMAL
- en: The photo app project is now finished. We added forms to enable users to add
    photo entries. We used Vue Router to allow us to add apps with multiple pages
    and easily navigate between them. We also added the Vue CLI Electron plugin so
    that we can easily build cross-platform desktop apps with Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we can build apps that are beyond simple apps using a few components with
    Vue Router. This allows us to map different URLs to different components. This
    way, we can go to different URLs and have different components rendered. The URLs
    can have query strings, hashes, and URL parameters in them, and they will be parsed
    automatically by Vue Router. They will be matched with the route patterns listed
    in the route definition arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Routes can be nested, and they can have names so that we can identify them by
    their name rather than their route pattern. Additionally, we can have a catchall
    or a 404 route to enable us to display something when none of the route patterns
    listed in our route definitions are matched.
  prefs: []
  type: TYPE_NORMAL
- en: Vue Router also has methods for programmatic navigation, which are named in
    the same way as the ones in the browser history API and can be called with the
    same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we learned how to restrict some routes from being displayed unless
    certain conditions are met. To restrict when the route components can be seen
    by the user, we can use navigation guards to do our checks before we go to a route.
    Navigation guards can also be added to run after the route is loaded. They can
    also be applied globally or with individual routes. If we apply navigation guards
    individually, then the checks for the navigation can be tailored to each route.
    Additionally, we can apply more than one per-route navigation guard to a route.
    This enables us to have much more flexibility than we would otherwise have with
    global navigation guards.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at how to convert our Vue 3 web app into a desktop app. With
    Electron, we can build desktop apps from browser apps. This is very handy since
    we can build business apps that are web-based and convert them into desktop apps
    with ease. The apps are cross-platform, and we can do a lot of stuff that we can
    do with regular desktop apps easily. For example, we can have limited access to
    hardware such as cameras and microphones just as we do with browser apps. Additionally,
    we can show native notifications to users, as we would in a desktop app since
    this is supported by the Chromium browser engine. Electron just runs our app in
    the Chromium browser. The Vue CLI Electron Builder plugin lets us convert a Vue
    app into an Electron app with one command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a calculator mobile app with Ionic.
  prefs: []
  type: TYPE_NORMAL
