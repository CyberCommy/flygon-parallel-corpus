- en: Working with Memory, Arrays, and Pointers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows you to have direct access to memory through pointers. This gives
    you a lot of flexibility, and potentially it allows you to improve the performance
    of your code by eliminating some unnecessary copying of data. However, it also
    provides an extra source of errors; some can be fatal for your application or
    worse (yes, worse than fatal!) because poor use of memory buffers can open security
    holes in your code that can allow malware to take over the machine. Clearly pointers
    are an important aspect of C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll see how to declare pointers and initialize them to memory
    locations, how to allocate memory on the stack and, C++ free store, and how to
    use C++ arrays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using memory in C++
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ uses the same syntax as C to declare pointer variables and assign them to
    memory addresses, and it has C-like pointer arithmetic. Like C, C++ also allows
    you to allocate memory on the stack, so there is automatic memory cleanup when
    the stack frame is destroyed, and dynamic allocation (on the C++ free store) where
    the programmer has the responsibility to release memory. This section will cover
    these concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ pointer syntax
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax to access memory in C++ is straightforward. The `&` operator returns
    the address of an object. That *object* can be a variable, a built-in type or
    the instance of a custom type, or even a function (function pointers will be covered
    in the next chapter). The address is assigned a typed pointer variable or a `void*`
    pointer. A `void*` pointer should be treated as merely storage for the memory
    address because you cannot access data and you cannot perform pointer arithmetic
    (that is, manipulate the pointer value using arithmetic operators) on a `void*`
    pointer. Pointer variables are usually declared using a type and the `*` symbol.
    For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, the variable `i` is an integer, and the compiler and linker will
    determine where this variable will be allocated. Usually, a variable in a function
    will be on a stack frame, as described in a later section. At runtime, the stack
    will be created (essentially a chunk of memory will be allocated) and space will
    be reserved in the stack memory for the variable `i`. The program then puts a
    value (42) in that memory. Next, the address of the memory allocated for the variable
    `i` is placed in the variable `pi`. The memory usage of the previous code is illustrated
    in the following diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89bf3c10-6e3f-4ac5-8ef7-9e801286fa70.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: The pointer holds a value of `0x007ef8c` (notice that the lowest byte is stored
    in the lowest byte in memory; this is for an x86 machine). The memory location
    `0x007ef8c` has a value of `0x0000002a`, that is, a value of 42, the value of
    the variable `i`. Since `pi` is also a variable, it also occupies space in memory,
    and in this case the compiler has put the pointer *lower* in memory than the data
    it points to and, in this case, the two variables are not contiguous.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: With variables allocated on the stack like this, you should make no assumptions
    about where in memory the variables are allocated, nor their location in relation
    to other variables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: This code assumes a 32-bit operating system, and so the pointer `pi` occupies
    32 bits and contains a 32-bit address. If the operating system is 64 bits then
    the pointer will be 64 bits wide (but the integer may still be 32 bits). In this
    book, we will use 32-bit pointers for the simple convenience that 32-bit addresses
    take less typing than 64-bit addresses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The typed pointer is declared with a `*` symbol and we will refer to this as
    an `int*` pointer because the pointer points to memory that holds an `int`. When
    declaring a pointer, the convention is to put the `*` next to the variable name
    rather than next to the type. This syntax emphasizes that the *type pointed* to
    is an `int`. However, it is important to use this syntax if you declare more than
    one variable in a single statement:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is clear that the first variable is an `int*` pointer and the second is
    an `int`. The following is not so clear:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，第一个变量是`int*`指针，第二个是`int`。以下则不太清楚：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You might interpret this to mean that the type of both variables is `int*`, *but
    this is not the case*, as this declares a pointer and an `int`. If you want to
    declare two pointers, then apply `*` to each variable:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会理解这意味着两个变量的类型都是`int*`，*但事实并非如此*，因为这声明了一个指针和一个`int`。如果你想声明两个指针，那么对每个变量应用`*`：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is probably better just to declare the two pointers on separate lines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是将这两个指针分开声明。
- en: When you apply the `sizeof` operator to a pointer, you will get the size of
    the pointer, not what it points to. Thus, on an x86 machine, `sizeof(int*)` will
    return 4; and on an x64 machine, it will return 8\. This is an important observation,
    especially when we discuss C++ built-in arrays in a later section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对指针应用`sizeof`运算符时，你将得到指针的大小，而不是它指向的内容。因此，在x86机器上，`sizeof(int*)`将返回4；在x64机器上，它将返回8。这是一个重要的观察，特别是当我们在后面的部分讨论C++内置数组时。
- en: 'To access the data pointed to by a pointer, you must **dereference** it using
    the `*` operator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问指针指向的数据，你必须使用`*`运算符对其进行**解引用**：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Used like this on the right-hand side of an assignment, the dereferenced pointer
    gives access to the value pointed to by the pointer, so `j` is initialized to
    42\. Compare this to the declaration of a pointer, where the `*` symbol is also
    used, but has a different meaning.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值的右侧使用解引用指针可以访问指针指向的值，所以`j`被初始化为42。与指针的声明相比，`*`符号也被使用，但意义不同。
- en: 'The dereference operator does more than give read access to the data at the
    memory location. As long as the pointer does not restrict it (using the `const`
    keyword; see later), you can dereference the pointer to write to a memory location
    too:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符不仅可以读取内存位置的数据。只要指针没有限制（使用`const`关键字；见后文），你也可以解引用指针来写入内存位置：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, the pointer `pi` points to the location in memory of the variable
    `i` (in this case, using the brace syntax). Assigning the dereferenced pointer
    assigns the value to the location that the pointer points to. The result is that
    on the last line, the variable `i` will have a value of 99 and not 42.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，指针`pi`指向变量`i`在内存中的位置（在这种情况下，使用大括号语法）。对解引用指针进行赋值将值分配给指针指向的位置。结果是在最后一行，变量`i`的值将是99而不是42。
- en: Using null pointers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空指针
- en: A pointer could point to anywhere in the memory installed in your computer,
    and assignment through a dereferenced pointer means that you could potentially
    write over sensitive memory used by your operating system, or (through direct
    memory access) write to memory used by hardware on your machine. However, operating
    systems will usually give an executable a specific memory range that it can access,
    and attempts to access memory out of this range will cause an operating system
    memory access violation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以指向计算机中安装的内存的任何位置，通过解引用指针进行赋值意味着你可能会覆盖操作系统使用的敏感内存，或者（通过直接内存访问）写入计算机硬件使用的内存。然而，操作系统通常会给可执行文件分配一个特定的内存范围，它可以访问，尝试访问超出此范围的内存将导致操作系统内存访问违规。
- en: 'For this reason, you should almost always obtain pointer values using the `&`
    operator or from a call to an operating system function. You should not give a
    pointer an absolute address. The only exception to this is the C++ constant for
    an invalid memory address, `nullptr`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你几乎总是应该使用`&`运算符或从操作系统函数调用中获取指针值。你不应该给指针一个绝对地址。唯一的例外是C++对于无效内存地址的常量`nullptr`：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code initializes the pointer `pi` to `nullptr`. Later in the code, the
    pointer is initialized to the address of an integer variable. Still later in the
    code, the pointer is used, but rather than calling it immediately, the pointer
    is first checked to ensure that it has been initialized to a non-null value. The
    compiler will check to see if you are about to use a variable that has not been
    initialized, but if you are writing library code, the compiler will not know whether
    the callers of your code will use pointers correctly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将指针`pi`初始化为`nullptr`。稍后在代码中，指针被初始化为整数变量的地址。代码中稍后使用了指针，但是不是立即调用它，而是首先检查指针以确保它已经被初始化为非空值。编译器将检查你是否即将使用一个未初始化的变量，但如果你正在编写库代码，编译器将不知道你的代码的调用者是否正确使用指针。
- en: The type of constant `nullptr` is not an integer, it is `std::nullptr_t`. All
    pointer types can be implicitly converted to this type, so `nullptr` can be used
    to initialize variables of all pointer types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`nullptr`的类型不是整数，而是`std::nullptr_t`。所有指针类型都可以隐式转换为此类型，因此`nullptr`可以用于初始化所有指针类型的变量。
- en: Types of memory
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存类型
- en: 'In general, you can regard memory as being one of four types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以将内存视为四种类型之一：
- en: Static or global
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态或全局
- en: String pool
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串池
- en: Automatic or stack
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动或堆栈
- en: Free store
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由存储
- en: When you declare a variable at the global level, or if you have a variable declared
    in a function as `static`, then the compiler will ensure that the variable is
    allocated from memory that has the same lifetime as the application--the variable
    is created when the application starts and deleted when the application ends.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在全局级别声明一个变量，或者在函数中将变量声明为`static`时，编译器将确保变量分配的内存具有与应用程序相同的生命周期--变量在应用程序启动时创建，在应用程序结束时删除。
- en: 'When you use a string literal, the data will also, effectively, be a global
    variable, but stored in a different part of the executable. For a Windows executable,
    string literals are stored in the `.rdata` PE/COFF section of the executable.
    The `.rdata` section of the file is for read-only initialized data, and hence
    you cannot change the data. Visual C++ allows you to go a step further and gives
    you an option of **string pooling**. Consider this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用字符串常量时，数据实际上也是全局变量，但存储在可执行文件的不同部分。对于Windows可执行文件，字符串常量存储在可执行文件的`.rdata`
    PE/COFF部分中。文件的`.rdata`部分用于只读初始化数据，因此您无法更改数据。Visual C++允许您更进一步，并为您提供了**字符串池**的选项。考虑这个：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, two pointers are initialized with the address of the string literal
    `hello`. In the following two lines, the address of each pointer is printed on
    the console. Since the `<<` operator for `char*` treats the variable as a pointer
    to a string, it will print the string rather than the address of the pointer.
    To get around this, we call the `reinterpret_cast` operator to convert the pointer
    to an integer and print the value of the integer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，两个指针被初始化为字符串常量`hello`的地址。在接下来的两行中，每个指针的地址都打印在控制台上。由于`<<`运算符对于`char*`将变量视为指向字符串的指针，它将打印字符串而不是指针的地址。为了解决这个问题，我们调用`reinterpret_cast`运算符将指针转换为整数并打印整数的值。
- en: If you compile the code at the command line using the Visual C++ compiler, you
    will see two different addresses printed. These two addresses are in the `.rdata`
    section and are both read-only. If you compile this code with the `/GF` switch
    to enable string pooling (which is default for Visual C++ projects), the compiler
    will see that the two string literals are the same and will only store one copy
    in the `.rdata` section, so the result of this code will be that a single address
    will be printed on the console twice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在命令行使用Visual C++编译器编译代码，您将看到打印出两个不同的地址。这两个地址都在`.rdata`部分，并且都是只读的。如果您使用`/GF`开关编译此代码以启用字符串池（这是Visual
    C++项目的默认设置），编译器将看到两个字符串常量是相同的，并且只会在`.rdata`部分存储一个副本，因此此代码的结果将是在控制台上打印两次相同的地址。
- en: In this code, the two variables `p1` and `p2` are automatic variables, that
    is, they are created on the stack created for the current function. When a function
    is called, a chunk of memory is allocated for the function and this contains space
    for the parameters passed to the function and the return address of the code that
    called the function, as well as space for the automatic variables declared in
    the function. When the function finishes, the stack frame is destroyed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，两个变量`p1`和`p2`是自动变量，也就是说，它们是在当前函数的堆栈上创建的。当调用函数时，为函数分配一块内存，其中包含为函数传递的参数和调用函数的代码的返回地址，以及在函数中声明的自动变量的空间。当函数结束时，堆栈帧被销毁。
- en: The **calling convention** of the function determines whether the calling function
    or the called function has the responsibility to do this. In Visual C++, the default
    is the `__cdecl` calling convention, which means the calling function cleans up
    the stack. The `__stdcall` calling convention is used by Windows operating system
    functions and the stack clean up is carried out by the called function. More details
    will be given in the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的**调用约定**决定了是调用函数还是被调用函数负责这样做。在Visual C++中，默认的是`__cdecl`调用约定，这意味着调用函数清理堆栈。`__stdcall`调用约定被Windows操作系统函数使用，并且堆栈清理由被调用函数执行。更多细节将在下一章中给出。
- en: Automatic variables only last as long as the function and the address of such
    variables only make any sense within the function. Later in this chapter, you
    will see how to create arrays of data. Arrays allocated as automatic variables
    are allocated on the stack to a fixed size determined at compile time. It is possible
    with large arrays that you could exceed the size of the stack, particularly with
    functions that are called recursively. On Windows, the default stack size is 1
    MB, and on x86 Linux, it is 2 MB. Visual C++ allows you to specify a bigger stack
    with the `/F` compiler switch (or the `/STACK` linker switch). The gcc compiler
    allows you to change the default stack size with the `--stack` switch.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自动变量只在函数执行期间存在，这样变量的地址只在函数内部有意义。在本章的后面，您将看到如何创建数据数组。作为自动变量分配的数组是在编译时确定的固定大小的堆栈上分配的。对于大数组，可能会超出堆栈的大小，特别是在递归调用的函数中。在Windows上，默认堆栈大小为1
    MB，在x86 Linux上为2 MB。Visual C++允许您使用`/F`编译器开关（或`/STACK`链接器开关）指定更大的堆栈。gcc编译器允许您使用`--stack`开关更改默认堆栈大小。
- en: The final type of memory is **dynamic memory** created on the **free store**
    or sometimes known as the **heap**. This is the most flexible way of using memory.
    As the name suggests, you allocate memory at runtime of a size determined at runtime.
    The implementation of the free store depends on the C++ implementation but you
    should regard the free store as having the same lifetime as your application,
    so memory allocated from the free store should last at least as long as your application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型的内存是在**自由存储器**或有时称为**堆**上创建的**动态内存**。这是使用内存的最灵活的方式。顾名思义，您在运行时分配大小确定的内存。自由存储器的实现取决于C++的实现，但您应该将自由存储器视为具有与应用程序相同的生命周期，因此从自由存储器分配的内存应该至少持续与应用程序一样长的时间。
- en: However, there are potential dangers here, particularly for long-lived applications.
    All memory allocated from the free store should be returned back to the free store
    when you have finished with it so that the free store manager can reuse the memory.
    If you do not return memory appropriately, then potentially the free store manager
    could run out of memory, which will prompt it to ask the operating system for
    more memory, and consequently, the memory usage of your application will grow
    over time, causing performance issues due to memory paging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Pointer arithmetic
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pointer points to memory, and the type of the pointer determines the type
    of the data that can be accessed through the pointer. So, an `int*` pointer will
    point to an integer in memory, and you dereference the pointer (`*`) to get the
    integer. If the pointer allows it (it is not marked as `const`), you can change
    its value through pointer arithmetic. For example, you can increment or decrement
    a pointer. What happens to the value of the memory address depends on the type
    of the pointer. Since a typed pointer points to a type, any pointer arithmetic
    will change the pointer in units of the *size* of that type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'If you increment an `int*` pointer, it will point to the *next* integer in
    memory and the change in the memory address depends on the size of the integer.
    This is equivalent to array indexing, where an expression such as `v[1]` means
    you should start at the memory location of the first item in `v` and then move
    one item further in memory and return the item there:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line allocates an array of five integers on the stack and initializes
    the values to the numbers 1 to 5\. In this example, because an initialization
    list is used, the compiler will create space for the required number of items,
    hence the size of the array is not given. If you give the size of the array between
    the brackets, then the initialization list must not have more items than the array
    size. If the list has fewer items, then the rest of the items in the array are
    initialized to the default value (usually zero).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line in this code obtains a pointer to the first item in the array.
    This line is significant: an array name is treated as a pointer to the first item
    in the array. The following lines alter array items in various ways. The first
    of these (`*pv`) changes the first item in the array by dereferencing the pointer
    and assigning it a value. The second (`v[1]`) uses array indexing to assign a
    value to the second item in the array. The third (`pv[2]`) uses indexing, but
    this time with a pointer, and assigns a value to the third value in the array.
    And the final example (`*(pv + 3)`) uses pointer arithmetic to determine the address
    of the fourth item in the array (remember the first item has an index of 0) and
    then dereferences the pointer to assign the item a value. After these, the array
    contains the values `{ 11, 12, 13, 14, 5 }` and the memory layout is illustrated
    here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5daa49f6-aa94-46a5-b9e8-1e3f60e607a0.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'If you have a memory buffer containing values (in this example, allocated via
    an array) and you want to multiply each value by 3, you can do this using pointer
    arithmetic:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The loop statement is complicated, and you will need to refer back to the operator
    precedence given in [Chapter 2](92dda5f2-3cee-40d5-8797-cdbbd6b8f59a.xhtml), *Understanding
    Language Features*. The postfix increment operator has the highest precedence,
    the next highest precedence is the dereference operator (`*`), and finally, the
    `*=` operator has the lowest of the three operators, so the operators are run
    in this order: `++`, `*`, `*=`. The postfix operator returns the value *before*
    the increment, so although the pointer is incremented to the next item in memory,
    the expression uses the address before the increment. This address is then dereferenced
    which is assigned by the assignment operator that replaces the item with the value
    multiplied by 3\. This illustrates an important difference between pointers and
    array names; you can increment a pointer but you cannot increment an array:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句很复杂，您需要参考[第2章](92dda5f2-3cee-40d5-8797-cdbbd6b8f59a.xhtml)中给出的运算符优先级，*理解语言特性*。后缀递增运算符具有最高的优先级，其次是解引用运算符（`*`），最后是`*=`运算符的优先级最低，因此这些运算符按照这个顺序运行：`++`，`*`，`*=`。后缀运算符返回递增*之前*的值，因此尽管指针被递增到内存中的下一个项目，表达式使用的是递增之前的地址。然后对这个地址进行解引用，由赋值运算符赋予值乘以3的值。这说明了指针和数组名称之间的一个重要区别；您可以递增指针，但不能递增数组：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can, of course use indexing (with `[]`) on both array names and pointers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在数组名称和指针上都使用索引（使用`[]`）。
- en: Using arrays
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组
- en: 'As the name suggests, a C++ built-in array is zero or more items of data of
    the same type. In C++, square brackets are used to declare arrays and to access
    array elements:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，C++内置数组是零个或多个相同类型的数据项。在C++中，使用方括号声明数组和访问数组元素：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `squares` variable is an array of integers. The first line allocates enough
    memory for *four* integers and then the `for` loop initializes the memory with
    the first four squares. The memory allocated by the compiler from the stack is
    contiguous and the items in the array are sequential, so the memory location of
    `squares[3]` is `sizeof(int)` following on from `squares[2]`. Since the array
    is created on the stack, the size of the array is an instruction to the compiler;
    this is not dynamic allocation, so the size has to be a constant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares`变量是一个整数数组。第一行为*四个*整数分配了足够的内存，然后`for`循环初始化了前四个平方的内存。编译器从堆栈中分配的内存是连续的，数组中的项目是顺序的，因此`squares[3]`的内存位置是从`squares[2]`的`sizeof(int)`开始的。由于数组是在堆栈上创建的，数组的大小是对编译器的一条指令；这不是动态分配，因此大小必须是一个常量。'
- en: 'There is a potential problem here: the size of the array is mentioned twice,
    once in the declaration and then again in the `for` loop. If you use two different
    values, then you may initialize too few items, or you could potentially access
    memory outside the array. The ranged `for` syntax allows you to get access to
    each item in the array; the compiler can determine the size of the array and will
    use this in the ranged `for` loop. In the following code, there is a deliberate
    mistake that shows an issue with array sizes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在潜在的问题：数组的大小被提到两次，一次在声明中，然后在`for`循环中再次提到。如果使用两个不同的值，那么您可能会初始化太少的项目，或者可能会访问数组之外的内存。范围`for`语法允许您访问数组中的每个项目；编译器可以确定数组的大小，并将在范围`for`循环中使用它。在下面的代码中，有一个故意的错误，显示了数组大小的问题：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The size of the array and the range of the first `for` loop do not agree and
    consequently the last item will not be initialized. The ranged `for` loop, however,
    will loop through all five items and so will print out some random value for the
    value of the last value. What if the same code is used but the `squares` array
    is declared to have three items? It depends on the compiler you are using and
    whether you are compiling a debug build, but clearly you will be writing to memory
    *outside* of that allocated to the array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小和第一个`for`循环的范围不一致，因此最后一个项目将不会被初始化。然而，范围`for`循环将循环遍历所有五个项目，因此将打印出最后一个值的一些随机值。如果使用相同的代码，但将`squares`数组声明为三个项目呢？这取决于您使用的编译器以及您是否正在编译调试版本，但显然您将写入*数组分配之外*的内存。
- en: 'There are some ways to mitigate these issues. The first one has been mentioned
    in an earlier chapter: declare a constant for the size of the array and use that
    whenever your code needs to know the array size:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以缓解这些问题。第一个方法在早期的章节中已经提到过：声明一个数组大小的常量，并在代码需要知道数组大小时使用它：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The array declaration must have a constant for the size, and that is managed
    by using the `sq_size` constant variable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明必须有一个常量作为大小，并且通过使用`sq_size`常量变量来管理。
- en: 'You may also want to calculate the size of an already allocated array. The
    `sizeof` operator, when applied to an array, returns the size in bytes of the
    *entire* array, so you can determine the size of the array by dividing this value
    by the size of a single item:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想计算已分配数组的大小。`sizeof`运算符，当应用于数组时，返回*整个*数组的字节大小，因此您可以通过将这个值除以单个项目的大小来确定数组的大小：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is safer code, but clearly it is verbose. The C runtime library contains
    a macro called `_countof` that performs this calculation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更安全的代码，但显然很冗长。C运行时库包含一个名为`_countof`的宏，用于执行这个计算。
- en: Function parameters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数
- en: As illustrated, there is an automatic conversion of an array to the appropriate
    pointer type and this occurs if you pass an array to a function, or return it
    from a function. This decay to a dumb pointer means that other code can make no
    assumption about an array size. A pointer could point to memory allocated on the
    stack where the memory lifetime is determined by the function, or a global variable
    where the memory lifetime is that of the program, or it could be to memory that
    is dynamically allocated and the memory is determined by the programmer. There
    is nothing in a pointer declaration that indicates the type of memory or who is
    responsible for the deallocation of the memory. Nor is there any information in
    a dumb pointer of how much memory the pointer points to. When you write code using
    pointers, you have to be disciplined about how you use them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所示，数组会自动转换为适当的指针类型，如果你将数组传递给一个函数，或者从一个函数返回它。这种衰变为愚蠢的指针意味着其他代码不能假设数组的大小。指针可能指向在函数确定内存生命周期的堆栈上分配的内存，或者指向程序的内存生命周期的全局变量，或者可能指向由程序员确定内存的动态分配的内存。在指针声明中没有任何信息表明内存的类型或谁负责释放内存。在愚蠢的指针中也没有任何关于指针指向多少内存的信息。当你使用指针编写代码时，你必须严格遵守它们的使用方式。
- en: 'A function can have an array parameter, but this means a lot less than it appear
    to indicate:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有一个数组参数，但这意味着的远不及它表面所示的那么多：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function will check that each member of the array has a value between
    the minimum and maximum values allowed. There are four tires in use at any one
    time on a car, so the function *should* be called with an array of four values.
    The problem is that although it appears that the compiler *should* check that
    the array passed to the function is the appropriate size, it doesn''t. You can
    call this function like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将检查数组的每个成员是否具有在允许的最小和最大值之间的值。汽车上一次使用四个轮胎，所以这个函数*应该*被调用以传递一个包含四个值的数组。问题在于，尽管看起来编译器*应该*检查传递给函数的数组是否是适当的大小，但它并没有。你可以这样调用这个函数：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, it should have been obvious to the developer that a truck is not
    a car, and so this developer should not have written this code, but the usual
    advantage of a compiled language is that the compiler will perform some *sanity
    checks* for you. In the case of array parameters, it won't.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发人员应该明显地意识到卡车不是汽车，因此这个开发人员不应该编写这段代码，但编译语言的通常优势是编译器会为你执行一些*合理性检查*。在数组参数的情况下，它不会。
- en: The reason is that the array is passed as a pointer, so although the parameter
    appears to be a built-in array, you cannot use facilities you are used to using
    with arrays like ranged `for`. In fact, if the `safe_car` function calls `sizeof(tire_pressures)`,
    it will get the size of a double pointer and not 16, the size in bytes of a four
    `int` array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是数组被传递为指针，因此尽管参数看起来是一个内置数组，但你不能使用你习惯使用的数组功能，比如范围`for`。事实上，如果`safe_car`函数调用`sizeof(tire_pressures)`，它将得到一个双指针的大小，而不是16，即四个`int`数组的字节大小。
- en: 'This *decay to a pointer* feature of array parameters means that functions
    will only ever know the size of an array parameter if you explicitly tell it the
    size. You can use an empty pair of square brackets to indicate that the item should
    be passed an array, but it really is just the same as a pointer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数组参数的*衰变为指针*特性意味着函数只有在你明确告诉它大小时才会知道数组参数的大小。你可以使用一对空的方括号来表示应该传递一个数组，但实际上它只是一个指针：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here the function has a parameter that indicates the size of the array. The
    preceding function is exactly the same as declaring the first parameter to be
    a pointer. The following is not an overload of the function; it is the *same*
    function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数有一个指示数组大小的参数。前面的函数与声明第一个参数为指针完全相同。以下不是函数的重载；它是*相同*的函数：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The important point is that when you pass an array to a function, the *first
    dimension* of the array is treated as a pointer. So far arrays have been single
    dimensional, but they may have more than one dimension.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，当你把一个数组传递给一个函数时，数组的*第一个维度*会被视为一个指针。到目前为止，数组一直是单维的，但它们可能有多个维度。
- en: Multidimensional arrays
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'Arrays can be multidimensional and to add another dimension you add another
    set of square brackets:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以是多维的，要添加另一个维度，需要添加另一组方括号：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first example creates an array of two integers, the second creates a two-dimensional
    array with 12 integers arranged so that there are four rows of three columns.
    Of course, *row* and *column* are arbitrary and treat the two-dimensional array
    like a conventional spreadsheet table, but it helps to visualize how the data
    is arranged in memory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子创建了一个包含两个整数的数组，第二个例子创建了一个包含12个整数的二维数组，排列成四行三列。当然，*行*和*列*是任意的，并且将二维数组视为传统的电子表格表格，但这有助于可视化数据在内存中的排列方式。
- en: Note that there are square brackets around every dimension. C++ is different
    to other languages in this respect, so a declaration of `int x[10,10]` will be
    reported as an error by the C++ compiler.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个维度周围都有方括号。在这方面，C++与其他语言不同，所以`int x[10,10]`的声明将被C++编译器报告为错误。
- en: 'Initializing multidimensional arrays involves a pair of braces and the data
    in the order that it will be used to initialize the dimensions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化多维数组涉及一对大括号和按照将用于初始化维度的顺序排列的数据：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, the values having the highest digit reflect the left-most
    index and the lower digit reflect, the right-most index (in both cases, one more
    than the actual index). Clearly, you can split this over several lines and use
    whitespace to group values together to make this more readable. You can also use
    nested braces. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，具有最高数字的值反映了最左边的索引，较低的数字反映了右边的索引（在这两种情况下，比实际索引多一个）。显然，你可以将这个分成几行，并使用空格来将值分组在一起，以使其更易读。你也可以使用嵌套的大括号。例如：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you read the dimensions going left to right, you can read the initialization
    going into deeper levels of nesting. There are four rows, so within the outer
    braces there are four sets of nested braces. There are three columns, and so within
    the nested braces there are three initialization values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从左到右读取维度，你可以读取初始化值进入更深层次的嵌套。有四行，所以在外部大括号内有四组嵌套的大括号。有三列，所以在嵌套的大括号内有三个初始化值。
- en: 'Nested braces are not just a convenience for formatting your C++ code, because
    if you provide an empty pair of braces the compiler will use the default value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的大括号不仅仅是为了格式化你的C++代码的方便，因为如果你提供了一对空的大括号，编译器将使用默认值：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the second-row items are initialized to 0.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第二行的项目被初始化为0。
- en: 'When you increase the dimensions, the principle applies: increase the nesting
    for the right most dimension:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你增加维度时，原则仍然适用：增加最右边维度的嵌套：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is four rows of three columns of pairs (as you can see, when the dimensions
    increase it becomes apparent that the terms **rows** and **columns** are largely
    arbitrary).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四行三列的成对数组（当维度增加时，可以看出术语**行**和**列**在很大程度上是任意的）。
- en: 'You access items using the same syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的语法访问项目：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In terms of the memory layout, the compiler interprets the syntax in the following
    way. The first index determines the offset from the beginning of the array in
    chunks of six integers (3 * 2), the second index indicates the offset within one
    of these six integer *chunks* itself in chunks of two integers, and the third
    index is the offset in terms of individual integers. Thus `[3][2][0]` is *(3 *
    6) + (2 * 2) + 0 = 22* integers from the beginning, treating the first integer
    as index zero.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就内存布局而言，编译器以以下方式解释语法。第一个索引确定了从数组开始处的偏移量，每次偏移六个整数（3 * 2），第二个索引指示了在这六个整数“块”内的偏移量，每次偏移两个整数，第三个索引是以单个整数为单位的偏移量。因此`[3][2][0]`是从开始处*(3
    * 6) + (2 * 2) + 0 = 22*个整数的偏移量，将第一个整数视为索引零。
- en: A multidimensional array is treated as arrays of arrays, so the type of each
    "row" is `int[3][2]` and we know from the declaration that there are four of them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组被视为数组的数组，因此每个“行”的类型是`int[3][2]`，我们从声明中知道有四个这样的行。
- en: Passing multidimensional arrays to functions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多维数组传递给函数
- en: 'You can pass a multidimensional array to a function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多维数组传递给一个函数：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This compiles and you can access the parameter as a 4x5 array, assuming that
    this vehicle has four wheels with five nuts on each one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样编译后，你可以将参数作为一个4x5的数组访问，假设这辆车有四个轮子，每个轮子上有五个螺母。
- en: 'As stated earlier, when you pass an array, the first dimension will be treated
    as a pointer, so while you can pass a 4x5 array to this function, you can also
    pass a 2x5 array and the compiler will not complain. However, if you pass a 4x3
    array (that is, the second dimension is not the same as declared in the function),
    the compiler will issue an error that the array is incompatible. The parameter
    may be more accurately described as being `double row[][5]`. Since the size of
    the first dimension is not available, the function should be declared with the
    size of that dimension:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你传递一个数组时，第一个维度将被视为指针，所以虽然你可以将一个4x5的数组传递给这个函数，你也可以传递一个2x5的数组，编译器不会抱怨。然而，如果你传递一个4x3的数组（也就是说，第二个维度与函数中声明的不同），编译器将发出一个数组不兼容的错误。参数可能更准确地描述为`double
    row[][5]`。由于第一个维度的大小不可用，函数应该声明该维度的大小：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This says that `nut_torques` is one or more "rows", each of which has five
    items. Since the array does not provide information about the number of rows it
    has, you should provide it. Another way to declare this is:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明`nut_torques`是一个或多个“行”，每个行有五个项目。由于数组没有提供有关它有多少行的信息，你应该提供它。另一种声明方式是：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The brackets are important here, if you omit them and use `double *nut_torques[5]`,
    then it means the `*` will refer to the type in the array, that is, the compiler
    will treat `nut_torques` as a five-element array of `double*` pointers. We have
    seen an example of such an array before:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里括号很重要，如果你省略它们并使用`double *nut_torques[5]`，那么`*`将指的是数组中的类型，也就是说，编译器将把`nut_torques`视为一个`double*`指针的五个元素数组。我们之前已经看到了这样一个数组的例子：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `argv` parameter is an array of `char*` pointers. You can also declare the
    `argv` parameter as `char**` which has the same meaning.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv`参数是一个`char*`指针数组。你也可以将`argv`参数声明为`char**`，它具有相同的含义。'
- en: In general, if you intend to pass arrays to a function it is best to use custom
    types, or use the C++ array types.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你打算将数组传递给一个函数，最好使用自定义类型，或者使用C++数组类型。
- en: Using ranged `for` with multidimensional arrays is a bit more complicated than
    appears on first sight, and requires the use of a reference as explained in the
    section later in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多维数组的范围`for`循环比第一眼看上去更复杂，并且需要在本章后面的部分中解释的引用的使用。
- en: Using arrays of characters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符数组
- en: Strings will be covered in more detail in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*, but it is worth pointing out here that C strings are arrays of
    characters and are accessed through pointer variables. This means that if you
    want to manipulate strings, you must manipulate the memory that the pointer points
    to, and not manipulate the pointer itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串将在[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml) *使用字符串*中更详细地介绍，但值得指出的是，C字符串是字符数组，并且通过指针变量访问。这意味着如果你想操作字符串，你必须操作指针指向的内存，而不是操作指针本身。
- en: Comparing strings
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较字符串
- en: 'The following allocates two string buffers and it calls the `strcpy_s` function
    to initialize each with the same string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下分配了两个字符串缓冲区，并调用`strcpy_s`函数来用相同的字符串初始化每个缓冲区：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `strcpy_c` function will copy characters from the pointer given in the last
    parameter (until the terminating `NUL`), into the buffer given in the first parameter,
    whose maximum size is given in the second parameter. These two pointers are compared
    in the final line, and this will return a value of `false`. The problem is that
    the compare function is comparing the values of the pointers, not what the pointers
    point to. The two buffers have the same string, but the pointers are different,
    so `b` will be `false`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcpy_c`函数将从最后一个参数中给定的指针（直到终止的`NUL`）复制字符，到第一个参数中给定的缓冲区中，该缓冲区的最大大小在第二个参数中给出。这两个指针在最后一行进行比较，这将返回一个`false`值。问题在于比较函数比较的是指针的值，而不是指针指向的内容。这两个缓冲区具有相同的字符串，但指针不同，因此`b`将是`false`。'
- en: 'The correct way to compare strings is to compare the data character by character
    to see if they are equal. The C runtime provides `strcmp` that compares two string
    buffers character by character, and the `std::string` class defines a function
    called `compare` that will also perform such a comparison; however, be wary of
    the value returned from these functions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 比较字符串的正确方法是逐个字符比较数据以查看它们是否相等。C运行时提供了`strcmp`，它逐个字符比较两个字符串缓冲区，并且`std::string`类定义了一个名为`compare`的函数，也将执行这样的比较；但是，要注意这些函数返回的值：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The return value is not a `bool` type indicating if the two strings are the
    same; it is an `int`. These compare functions carry out a lexicographical compare
    and return a negative value if the parameter (`s2` in this code) is greater than
    the operand (`s1`) lexicographically, and a positive number if the operand is
    greater than the parameter. If the two strings are the same, the function returns
    0\. Remember that a `bool` is `false` for a value of 0 and `true` for non-zero
    values. The standard library provides an overload for the `==` operator for `std::string`,
    so it is safe to write code like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值不是`bool`类型，表示两个字符串是否相同；它是一个`int`。这些比较函数进行词典比较，如果参数（在这个代码中是`s2`）在词典上大于操作数（`s1`），则返回一个负值，如果操作数大于参数，则返回一个正数。如果两个字符串相同，函数返回0。记住，`bool`对于值为0是`false`，对于非零值是`true`。标准库为`std::string`提供了`==`运算符的重载，因此可以安全地编写这样的代码：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The operator will compare the strings contained in the two variables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员将比较两个变量中包含的字符串。
- en: Preventing buffer overruns
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止缓冲区溢出
- en: 'The C runtime library for manipulating strings is notorious for allowing buffer
    overruns. For example, the `strcpy` function copies one string to another, and
    you get access to this through the `<cstring>` header, which is included by the
    `<iostream>` header. You may be tempted to write something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于操作字符串的C运行时库以允许缓冲区溢出而臭名昭著。例如，`strcpy`函数将一个字符串复制到另一个字符串，并且您可以通过`<cstring>`头文件访问它，该头文件由`<iostream>`头文件包含。您可能会尝试编写类似这样的代码：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The problem is that `strcpy` will copy all the character up to, and including
    the terminating `NULL` character and so you will be copying six characters into
    an array with space for only *five*. You could be taking a string from the user
    input (say, from a text box on a web page) and think that the array you have allocated
    is big enough, but a malicious user could provide an excessively long string deliberately
    bigger than the buffer so that it overwrites other parts of your program. Such
    *buffer overruns* have caused a lot of programs to be subjected to hackers taking
    control of servers, so much so that the C string functions have all been replaced
    by safer versions. Indeed, if you are tempted to type the preceding code, you''ll
    find that `strcpy` is available, but the Visual C++ compiler will issue an error:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`strcpy`将复制所有字符直到包括终止的`NULL`字符，因此您将把六个字符复制到只有*五*个空间的数组中。您可能会从用户输入中获取一个字符串（比如，从网页上的文本框），并认为您分配的数组足够大，但是恶意用户可能会提供一个故意大于缓冲区的过长字符串，以便覆盖程序的其他部分。这种*缓冲区溢出*导致许多程序遭受黑客控制服务器的攻击，以至于C字符串函数都已被更安全的版本所取代。实际上，如果您尝试键入上述代码，您会发现`strcpy`是可用的，但是Visual
    C++编译器会发出错误：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you have existing code that uses `strcpy`, and you need to make that code
    compile, you can define the symbol before `<cstring>`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用`strcpy`的现有代码，并且需要使该代码编译，可以在`<cstring>`之前定义该符号：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An initial attempt to prevent this issue is to call `strncpy`, which will copy
    a specific number of characters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这个问题的一个初始尝试是调用`strncpy`，它将复制特定数量的字符：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The function will copy up to five characters and then stop. The problem is
    that the string to copy has five characters and so the result will be no `NULL`
    termination. The safer version of this function has a parameter that you can use
    to say how big the destination buffer is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将复制最多五个字符，然后停止。问题在于要复制的字符串有五个字符，因此结果将没有`NULL`终止。此函数的更安全版本具有一个参数，您可以使用该参数指定目标缓冲区的大小：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At runtime this will still cause a problem. You have told the function that
    the buffer is five characters in size and it will determine that this is not big
    enough to hold the six characters that you have asked it to copy. Rather than
    allowing the program to silently continue and the buffer overrun to cause problems,
    the safer string functions will call a function called the **constraint handler**
    and the default version will shut down the program on the rationale that a buffer
    overrun means that the program is compromised.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，这仍然会导致问题。您告诉函数缓冲区大小为五个字符，它将确定这不足以容纳您要求它复制的六个字符。与其允许程序悄悄继续并且缓冲区溢出导致问题，更安全的字符串函数将调用一个名为**约束处理程序**的函数，其默认版本将关闭程序，理由是缓冲区溢出意味着程序已受到威胁。
- en: 'The C runtime library strings functions were originally written to return the
    result of the function, the safer versions now return an error value. The `strncpy_s`
    function can also be told to truncate the copy rather than call the constraint
    handler:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The C++ `string` class protects you from such issues.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers in C++
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers are clearly very important in C++, but as with any powerful feature,
    there are issues and dangers, so it is worth pointing out some of the major issues.
    A pointer points to a single location in memory, and the type of the pointer indicates
    how the memory location should be interpreted. The very most you can assume is
    the number of bytes at that position in memory is the size of the type of the
    pointer. That's it. This means that pointers are inherently unsafe. However, in
    C++ they are the quickest way to enable code within your process to access large
    amounts of data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Accessing out of bounds
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you allocate a buffer, whether on the stack or on the free store, and
    you get a pointer, there is little to stop you from accessing memory you have
    not allocated--either before or after the position of the buffer. This means that
    when you use pointer arithmetic, or indexed access on arrays, that you check carefully
    that you are not going to access data out of bounds. Sometimes the error may not
    be immediately obvious:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you use indexing, you have to keep reminding yourself that arrays are indexed
    from zero so the highest index is the size of the array minus 1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Pointers to deallocated memory
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This applies to memory allocated on the stack and to memory dynamically allocated.
    The following is a poorly written function that returns a string allocated on
    the stack in a function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code allocates a buffer of six characters and then initializes
    it with the five characters of the string literal `hello`, and the `NULL` termination
    character. The problem is that once the function finishes the stack frame is torn
    down so that the memory can be re-used, and the pointer will point to memory that
    could be used by something else. This error is caused by poor programming, but
    it may not be as obvious as in this example. If the function uses several pointers
    and performs a pointer assignment, you may not immediately notice that you have
    returned a pointer to a stack-allocated object. The best course of action is simply
    not to return raw pointers from functions, but if you do want to use this style
    of programming, make sure that the memory buffer is passed in through a parameter
    (so the function does not own the buffer) or is dynamically allocated and you
    are passing ownership to the caller.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: This leads on to another issue. If you call `delete` on a pointer and then later
    in your code, try to access the pointer, you will be accessing memory that is
    potentially being used by other variables. To alleviate this problem, you can
    get into the habit of assigning a pointer to `null_ptr` when you delete it and
    check for `null_ptr` before using a pointer. Alternatively, you can use a smart
    pointer object which will do this for you. Smart pointers will be covered in [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Converting pointers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can either have typed pointers, or the `void*` pointer. Typed pointers will
    access the memory as if it is the specified type (this has interesting consequences
    when you have inheritance with classes, but that will be left for [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes* and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction
    to Object-Oriented Programming*). Thus, if you cast a pointer to a different type
    and dereference it, the memory will be treated as containing the cast type. It
    rarely makes sense to do this. The `void*` pointer cannot be dereferenced, so
    you can never access data through a `void*` pointer, to access the data you have
    to cast the pointer. The whole reason for the `void*` pointer type is that it
    can point to anything. In general, `void*` pointers should only be used when the
    type does not matter to that function. For example, the C `malloc` function returns
    a `void*` pointer because the function merely allocates memory; it does not care
    what that memory will be used for.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Constant pointers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pointers can be declared as `const` which, depending on where you apply it,
    means that the memory the pointer points to is read-only through the pointer,
    or the value of the pointer is read-only:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, `ptc` is a pointer to constant `char`, that is, although you can change
    what `ptc` points to, and you can read what it points to, you cannot use it to
    change the memory. On the other hand, `cp` is a constant pointer, which means
    you can both read and write the memory which the pointer points to, but you cannot
    change where it points to. It is typical to pass the `const char*` pointers to
    functions because the functions do not know where the string has been allocated
    or the size of the buffer (the caller may pass a literal which cannot be changed).
    Note that there is no `const*` operator so `char const*` is treated as `const
    char*`, a pointer to a constant buffer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a pointer constant, change it, or remove it using casts. The following
    does some fairly pointless changing around of the `const` keyword to prove the
    point:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The pointers `cp1` and `cp2` can be used to change the memory they point to,
    but once assigned neither can point to other memory. The first `const_cast` casts
    away the `const`-ness to a pointer that can be changed to point to other memory,
    but cannot be used to alter that memory, `ptc`. The second `const_cast` casts
    away the `const`-ness of `ptc` so that the memory can be changed through the pointer,
    `cp2`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type pointed to
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `static_cast` operator is used to convert with a compile time check, but
    not a runtime check, so this means that the pointers must be related. The `void*`
    pointer can be converted to any pointer, so the following compiles and makes sense:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The C `malloc` function returns a `void*` pointer so you have to convert it
    to be able to use the memory. (Of course, the C++ `new` operator removes the need
    for such casting.) The built-in types are not "related" enough for `static_cast`
    to convert between pointer types, so you cannot use `static_cast` to convert an
    `int*` pointer to a `char*` pointer, even though `int` and `char` are both integer
    types. For custom types that are related through inheritance, you can cast pointers
    using `static_cast`, but there is no runtime check that the cast is correct. To
    cast with runtime checks you should use `dynamic_cast`, and more details will
    be given in [Chapters 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*
    and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction to
    Object-Oriented Programming*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reinterpret_cast` operator is the most flexible, and dangerous, of the
    cast operators because it will convert between any pointer types without any type
    checks. It is inherently unsafe. For example, the following code initializes a
    wide character array with a literal. The array `wc` will have six characters,
    `hello` followed by `NULL`. The `wcout` object interprets a `wchar_t*` pointer
    as a pointer to the first character in a `wchar_t` string, so inserting `wc` will
    print the string (every character until the `NUL`). To get the actual memory location,
    you have to convert the pointer to an integer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, if you insert a `wchar_t` into the `wcout` object, it will print
    the character, not the numeric value. So, to print out the codes for the individual
    characters, we need to cast the pointer to a suitable integer pointer. This code
    assumes that a `short` is the same size as a `wchar_t`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Allocating memory in code
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ defines two operators, `new` and `delete`, that allocate memory from the
    free store and release memory back into the free store.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Allocating individual objects
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new` operator is used with the type to allocate memory, and it will return
    a typed pointer to that memory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `new` operator will call the *default constructor* for custom types for
    every object it creates (as explained in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*). Built-in types do not have constructors, so instead a type initialization
    will occur and this will usually initialize the object to zero (in this example,
    a zero integer).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should not use memory allocated for built-in types without explicitly
    initializing it. In fact, in Visual C++ the debug version of the `new` operator
    will initialize memory to a value of `0xcd` for every byte, as a visual reminder
    in the debugger that you have not initialized the memory. For custom types, it
    is left to the author of the type to initialize allocated memory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important that when you have finished with memory that you return it
    back to the free store so that the allocator can reuse it. You do this by calling
    the `delete` operator:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you delete a pointer, the **destructor** for the object is called. For
    built-in types, this does nothing. It is good practice to initialize a pointer
    to `nullptr`, after you have deleted it, and if you use the convention of checking
    the value of a pointer before using it, this will protect you from using a deleted
    pointer. The C++ standard says that the `delete` operator will have no effect
    if you delete a pointer that has a value of `nullptr`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ allows you to initialize a value at the time you call the `new` operator,
    in two ways:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For a custom type, the `new` operator will call a constructor on the type; for
    a built in type, the end result is the same, and is carried out by initializing
    the item to the value provided. You can also use initialized list syntax, as shown
    in the second line in the preceding code. It is important to note that the initialization
    is the memory pointed to, not the pointer variable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Allocating arrays of objects
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create arrays of objects in dynamic memory using the `new` operator.
    You do this by providing the number of items you want created in a pair of square
    brackets. The following code allocates memory for two integers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The operator returns a pointer to the type allocated, and you can use pointer
    arithmetic or array indexing to access the memory. You cannot initialize the memory
    in the `new` statement; you have to do that after creating the buffer. When you
    use `new` to create a buffer for more than one object, you must use the appropriate
    version of the `delete` operator: the `[]` is used to indicate that more than
    one item is deleted and the destructor for each object will be called. It is important
    that you always use the right version of `delete` appropriate to the version of
    `new` used to create the pointer.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Custom types can define their own operator `new` and operator `delete` for individual
    objects, as well as operator `new[]` and operator `delete[]` for arrays of objects.
    The custom type author can use these to use custom memory allocation schemes for
    their objects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Handling failed allocations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the `new` operator cannot allocate the memory for an object, it will throw
    the `std::bad_alloc` exception and the pointer returned will be `nullptr`. Exceptions
    are covered in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics
    and Debugging*, so only a brief outline of the syntax will be given here. It is
    important that you check for failure to allocate memory in production code. The
    following code shows how to guard the allocation so that you can catch the `std::bad_alloc`
    exception and handle it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If any code in the `try` block throws an exception control it is passed to the
    `catch` clause, ignoring any other code that has not been executed yet. The `catch`
    clause checks the type of the exception object and if it is the correct type (in
    this case an allocation fault), it creates a reference to that object and passes
    control to the `catch` block, and the scope of the exception reference is this
    block. In this example, the code merely prints an error, but you would use it
    to take action to ensure that the memory allocation failure does not affect subsequent
    code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Using other versions of the new operator
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Further, a custom type can define a placement operator `new`, which allows you
    to provide one or more parameters to the custom `new` function. The syntax of
    the placement `new` is to provide the placement fields through parentheses.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ Standard Library version of the `new` operator provides a version that
    can take the constant `std::nothrow` as a placement field. This version will not
    throw an exception if the allocation fails, instead, the failure can only be assessed
    from the value of the returned pointer:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The parentheses before the type are used to pass placement fields. If you use
    parentheses after the type, these will give a value to initialize the object if
    the allocation is successful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Memory lifetime
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The memory allocated by `new` will remain valid until you call `delete`. This
    means that you may have memory with long lifetimes, and the code may be passed
    around various functions in your code. Consider this code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code creates a pointer and initializes the memory it points to and then
    passes the pointer to a function, which itself returns a pointer. Since the `p1`
    pointer is no longer needed, it is deleted and assigned to `nullptr` so that it
    cannot be used again. This code looks fine, but the problem is what do you do
    with the pointer returned by the function? Imagine that the function simply manipulates
    the data pointed to by the pointer:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In effect, calling `do_something` creates a copy of a pointer, but not a copy
    of what it points to. This means that when the `p1` pointer is deleted, the memory
    it points to is no longer available, and so the pointer `p2` points to the invalid
    memory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be addressed using a mechanism called **Resource Acquisition
    Is Initialization** (**RAII**), which means using the features of C++ objects
    to manage resources. RAII in C++ needs classes and in particular, copy constructors
    and destructors. A smart pointer class can be used to manage a pointer so that
    when it is copied, the memory it points to is also copied. A destructor is a function
    that is called automatically when the object goes out of scope and so a smart
    pointer can use this to free memory. Smart pointers and destructors will be covered
    in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The Windows SDK and pointers
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Returning a pointer from a function has its inherent dangers: the responsibility
    for the memory is passed to the caller, and the caller must ensure that the memory
    is appropriately de-allocated, otherwise this could cause a memory leak with a
    corresponding loss of performance. In this section, we will look at some ways
    that the Window''s **Software Development Kit** (**SDK**) provides access to memory
    buffers and learn some techniques used in C++.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: First, it is worth pointing out that any function in the Windows SDK that returns
    a string, or has a string parameter, will come in two versions. The version suffixed
    with `A` indicates that the function uses ANSI strings, and the `W` version will
    use wide character strings. For the purpose of this discussion, it is easier to
    use the ANSI functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetCommandLineA` function has the following prototype (taking into account
    the Windows SDK `typedef`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: All Windows functions are defined as using the `__stdcall` calling convention.
    Usually, you will see the `typedef` of `WINAPI` used for the `__stdcall` calling
    convention.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The function can be called like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice that we are making no effort to do anything about freeing the returned
    buffer. The reason is that the pointer points to memory that lives the lifetime
    of your process, so you *should not* release it. Indeed, if you were to release
    it, how would you do it? You cannot guarantee that the function was written with
    the same compiler, or the same libraries that you are using, so you cannot use
    the C++ `delete` operator or the C `free` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: When a function returns a buffer, it is important to consult the documentation
    to see who allocated the buffer, and who should release it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is `GetEnvironmentStringsA`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This also returns a pointer to a buffer, but this time the documentation is
    clear that after using the buffer you should release it. The SDK provides a function
    to do this called `FreeEnvironmentStrings`. The buffer contains one string for
    each environment variable in the form `name=value` and each string is terminated
    by a `NUL` character. The last string in the buffer is simply a `NUL` character,
    that is, there are two `NUL` characters at the end of the buffer. These functions
    can be used like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `strlen` function is part of the C runtime library and it returns the length
    of a string. You do not need to know how the `GetEnvironmentStrings` function
    allocates the buffer because the `FreeEnvironmentStrings` will call the correct
    deallocation code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'There are cases when the developer has the responsibility of allocating a buffer.
    The Windows SDK provides a function called `GetEnvironmentVariable` to return
    the value of a named environment variable. When you call this function, you do
    not know if the environment variable is set, or if it is set, or how big its value
    is, so this means that you will most likely have to allocate some memory. The
    prototype of the function is:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There are two parameters that are pointers to C strings. There is a problem
    here, a `char*` pointer could be passing *in* a string to the function, or it
    could be used to pass in a buffer for a string to be returned *out*. How do you
    know what a `char*` pointer is intended to be used for?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You are given a clue with the full parameter declaration. The `lpName` pointer
    is marked `const` so the function will not alter the string it points to; this
    means that it is an *in* parameter. This parameter is used to pass in the name
    of the environment variable you want to obtain. The other parameter is simply
    a `char*` pointer, so it could be used to pass a string *in* to the function or
    *out*, or indeed, both *in* and *out*. The only way to know how to use this parameter
    is to read the documentation. In this case, it is an *out* parameter; the function
    will return the value of the environment variable in `lpBuffer` if the variable
    exists, or if the variable does not exist, the function will leave the buffer
    untouched and return the value 0\. It is your responsibility to allocate this
    buffer in whatever way you see fit, and you pass the size of this buffer in the
    last parameter, `nSize`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The function's return value has two purposes. It is used to indicate that an
    error has occurred (just one value, 0, which means you have to call the `GetLastError`
    function to get the error), and it is also used to give you information about
    the buffer, `lpBuffer`. If the function succeeds, then the return value is the
    number of characters copied into the buffer excluding the `NULL` terminating character.
    However, if the function determines that the buffer is too small (it knows the
    size of the buffer from the `nSize` parameter) to hold the environment variable
    value, no copy will happen, and the function will return the required size of
    the buffer, which is the number of characters in the environment variable including
    the `NULL` terminator.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'A common way to call this function is to call it twice, first with a zero-sized
    buffer and then use the return value to allocate a buffer before calling it again:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In general, as with all libraries, you have to read the documentation to determine
    how the parameters are used. The Windows documentation will tell you if a pointer
    parameter is in, out, or in/out. It will also tell you who owns the memory and
    whether you have the responsibility for allocating and/or freeing the memory.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you see a pointer parameter for a function, take special care to check
    the documentation as to what the pointer is used for and how the memory is managed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Memory and the C++ Standard Library
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Standard Library provides various classes to allow you to manipulate
    collections of objects. These classes, called the **Standard Template Library**
    (**STL**), provide a standard way to insert items into collection objects and
    ways to access the items and iterate through entire collections (called iterators).
    The STL defines collection classes that are implemented as queues, stacks, or
    as vectors with random access. These classes will be covered in depth [Chapter
    8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml), *Using the Standard Library Containers*,
    so in this section we will limit the discussion to just two classes that behave
    like C++ built in arrays.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Standard Library arrays
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C+ Standard Library provides two containers that give random access via
    an indexer to the data. These two containers also allow you to access the underlying
    memory and since they guarantee to store the items sequentially and contiguous
    in memory, they can be used when you are required to provide a pointer to a buffer.
    These two types are both templates, which means that you can use them to hold
    built-in and custom types. These two collection classes are `array` and `vector`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Using the stack-based array class
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `array` class is defined in the `<array>` header file. The class allows
    you to create fixed sized arrays on the stack and, as with built-in arrays, they
    cannot shrink or expand at runtime. Since they are allocated on the stack, they
    do not require a call to a memory allocator at runtime, but clearly, they should
    be smaller than the stack frame size. This means that an `array` is a good choice
    for small arrays of items. The size of an `array` must be known at compile time
    and it is passed as a template parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this code, the first template parameter in the angle brackets (`<>`) is
    the type of each item in the array, and the second parameter is the number of
    items. This code initializes the array with an initialize list, but note that
    you still have to provide the size of the array in the template. This object will
    work like a built-in array (or indeed, any of the Standard Library containers)
    with ranged `for`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The reason is that `array` implements the `begin` and `end` functions that
    are required for this syntax. You can also use indexing to access items:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `size` function will return the size of the array and the square bracket
    indexer gives random access to members of the array. You can access memory outside
    of the bounds of the array, so for the previously defined array that has four
    members, you can access `arr[10]`. This may cause unexpected behavior at runtime,
    or even some kind of memory fault. To guard against this, the class provides a
    function, `at`, which will perform a range check and if the index is out of range
    the class will throw the C++ exception `out_of_range`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of using an `array` object is that you get compile time
    checks to see if you are inadvertently passing the object to a function as a dumb
    pointer. Consider this function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At runtime, the function does not know the size of the buffer passed to it,
    and in this case the documentation says that you must pass a buffer with 10 `int`
    type variables, but, as we have seen, C++ allows a built-in array to be used as
    a pointer:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is no compiler check, nor any runtime check to catch this error. The
    `array` class will not allow such an error to happen because there is no automatic
    conversion into a dumb pointer:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you really insist in obtaining a dumb pointer, you can do this and be guaranteed
    to have access to the data as a contiguous block of memory where the items are
    stored sequentially:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The class is not just a wrapper around a built-in array, it also provides some
    additional functionality. For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Using the dynamically allocated vector class
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library also provides the `vector` class in the `<vector>` header.
    Again, this class is a template, so you can use it with built-in and custom types.
    However, unlike `array`, the memory is dynamically allocated, which means that
    a `vector` can be expanded or shrunk at runtime. The items are stored contiguously
    so you can access the underlying buffer by calling the `data` function or accessing
    the address of the first item (to support resizing the collection, the buffer
    may change, so such pointers should only be used temporarily). And, of course,
    as with `array`, there is no automatic conversion to a dumb pointer. The `vector`
    class provides indexed random access with square bracket syntax and a range check
    with the `at` function. The class also implements the methods to allow the container
    to be used with Standard Library functions and with ranged `for`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` class has more flexibility than the `array` class because you can
    insert items, and move items around, but this does come with some overhead. Because
    instances of the class allocate memory dynamically at runtime there is a cost
    of using an allocator and there is some extra overhead in initialization and destruction
    (when the `vector` object goes out of scope). Objects of the `vector` class also
    take more memory than the data it holds. For this reason, it is not suitable for
    small numbers of items (when `array` is a better choice).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A reference is an alias to an object. That is, it is another name for the object,
    and so access to the object is the same through a reference as it is through the
    object''s variable name. A reference is declared using a `&` symbol on the reference
    name and it is initialized and accessed in exactly the same way as a variable:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this code, a variable is declared and initialized, then a pointer is initialized
    to point to this data, and a reference is initialized as an alias for the variable.
    Reference `ri1` is initialized with an assignment operator, whereas reference
    `ri2` is initialized using initializer list syntax.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The pointer and reference have two different meanings. The reference is not
    initialized to the value of the variable, the variable's data; it is an alias
    for the variable name.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Wherever the variable is used, the reference can be used; whatever you do to
    the reference is actually the same as performing the same operation on the variable.
    A pointer points to data, so you can change the data by dereferencing the pointer,
    but equally so, you can make the pointer point to any data and change that data
    by dereferencing the pointer (this is illustrated in the last two lines of the
    preceding code). You can have several aliases for a variable, and each must be
    initialized to the variable at the declaration. Once declared, you cannot make
    a reference refer to a different object.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will not compile:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since a reference is an alias for another variable, it cannot exist without
    being initialized to a variable. Likewise, you cannot initialize it to anything
    other than a variable name, so there is no concept of a *null reference*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Once initialized, a reference is only ever an alias to the one variable. Indeed,
    when you use a reference as an operand to any operator, the operation is performed
    on the variable:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this code, `rx` is an alias to the variable `x`, so the assignment in the
    last line simply assigns `x` with the value of `y`: the assignment is performed
    on the aliased variable. Further, if you take the address of a reference, you
    are returned the address of the variable it references. While you can have a reference
    to an array, you cannot have an array of references.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Constant references
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reference used so far allows you to change the variable it is an alias for,
    therefore it has lvalue semantics. There are also `const` lvalue references, that
    is, a reference to an object that you can read, but not write to.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `const` pointers, you declare a `const` reference using the `const`
    keyword on a lvalue reference. This essentially makes the reference read-only:
    you can access the variable''s data to read it, but not to change it.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Returning references
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes an object will be passed to a function and the semantics of the function
    is that the object should be returned. An example of this is the `<<` operator
    used with the stream objects. Calls to this operator are *chained*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is actually a series of calls to functions called `operator<<`, one that
    takes a `const char*` pointer, and another that takes an `int` parameter. These
    functions also have an `ostream` parameter for the stream object that will be
    used. However, if this is simply an `ostream` parameter then it would mean that
    a copy of the parameter would be made, and the insertion would be performed on
    the copy. Stream objects often use buffering, so changes to a copy of a stream
    object may not have the desired effect. Further, to enable the *chaining* of the
    insertion operators, the insertion functions will return the stream object passed
    as a parameter. The intention is to pass the same stream object through multiple
    function calls. If such a function returned an object then it would be a copy
    and not only would this means that a series of insertions would involve lots of
    copies being made, these copies would also be temporary and so any changes to
    the stream (for example, manipulators such as `std::hex`) would not persist. To
    address these issues, references are used. A typical prototype of such a function
    is:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Clearly you have to be careful about returning a reference since you have to
    ensure that the object lifetime lasts as long as the reference. This `operator<<`
    function will return the reference passed in the first parameter, but in the following
    code a reference is returned to an automatic variable:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, the `string` object only lives as long as the function,
    so the reference returned by this function will refer to an object that does not
    exist. Of course, you can return a reference to a `static` variable declared in
    a function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Returning a reference from a function is a common idiom, but whenever you consider
    doing this make sure that the lifetime of the aliased variable is not the scope
    of the function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Temporaries and references
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lvalue references must refer to a variable, but C++ has some odd rules
    when it comes to `const` references declared on the stack. If the reference is
    a `const`, the compiler will extend the lifetime of a temporary for the lifetime
    of the reference. For example, if you use the initialization list syntax, the
    compiler will create a temporary:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this code, the compiler will create a temporary `int` and initialize it
    to a value and then alias it to the `cri` reference (it is important that this
    reference is `const`). The temporary is available through the reference while
    it is in scope. This may look a little odd, but consider using a `const` reference
    in this function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can call this function with a `string` variable, a variable that will explicitly
    convert to a `string` or with a `string` literal:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In most cases, you'll not want to have a `const` reference to a built-in type,
    but with custom types where there will be an overhead in making copies there is
    an advantage and, as you can see here, the compiler will fall back to creating
    a temporary if required.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The rvalue references
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 defines a new type of reference, rvalue references. Prior to C++11, there
    was no way that code (like an assignment operator) could tell if the rvalue passed
    to it was a temporary object or not. If such a function is passed a reference
    to an object, then the function has to be careful not to change the reference
    because this would affect the object it refers to. If the reference is to a temporary
    object, then the function can do what it likes to the temporary object because
    the object will not live after the function completes. C++11 allows you to write
    code specifically for temporary objects, so in the case of the assignment, the
    operator for temporary objects can just *move* the data from the temporary into
    the object being assigned. In contrast, if the reference is not to a temporary
    object then the data will have to be *copied*. If the data is large, then this
    prevents a potentially expensive allocation and copy. This enables so-called *move
    semantics*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this rather contrived code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The three functions return a `string` object. In the first two cases, the `string`
    has the lifetime of the program and so a reference can be returned. In the last
    function, the function returns a string literal, so a temporary `string` object
    is constructed. All three can be used to provide a `string` value. For example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: All three can provide a string that can be used to assign a `string` object.
    The important point is that the first two functions return along a lived object,
    but the third function returns a temporary object, but these objects can be used
    the same.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'If these functions returned access to a large object, you would not want to
    pass the object to another function, so instead, in most cases, you''ll want to
    pass the objects returned by these functions as references. For example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The reference parameter prevents another copy of the string. However, this
    is just half of the story. The `use_string` function could manipulate the string.
    For example, the following function creates a new `string` from the parameter,
    but replaces the letters a, b, and o with an underscore (indicating the gaps in
    words without those letters, replicating what life would be like without donations
    of the blood types A, B, and O). A simple implementation would look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The string object has an index operator (`[]`), so you can treat it like an
    array of characters, both reading the values of characters and assigning values
    to character positions. The size of the `string` is obtained through the `length`
    function, which returns an `unsigned int` (`typedef` to `size_t`). Since the parameter
    is a reference, it means that any change to the `string` will be reflected in
    the `string` passed to the function. The intention of this code is to leave other
    variables intact, so it first makes a copy of the parameter. Then on the copy,
    the code iterates through all of the characters changing the `a`, `b`, and `o`
    characters to an underscore before printing out the result.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This code clearly has a copy overhead--creating the `string`, `s`, from the
    reference, `rs`; but this is necessary if we want to pass strings like those from
    `get_global` or `get_static` to this function because otherwise the changes would
    be made to the actual global and `static` variables.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the temporary `string` returned from `get_temp` is another situation.
    This temporary object only exists until the end of the statement that calls `get_temp`.
    Thus, it is possible to make changes to the variable knowing that it will affect
    nothing else. This means that you can use move semantics:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'There are just two changes here. The first is that the parameter is identified
    as an rvalue reference using the `&&` suffix to the type. The other change is
    that the changes are made on the object that the reference refers to because we
    know that it is a temporary and the changes will be discarded, so it will affect
    no other variables. Note that there are now *two* functions, overloads with the
    same name: one with an lvalue reference, and one with an rvalue reference. When
    you call this function, the compiler will call the right one according to the
    parameter passed to it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Recall that `get_global` and `get_static` return references to objects that
    will live the lifetime of the program, and for this reason the compiler chooses
    the `use_string` version that takes an lvalue reference. The changes are made
    on a temporary variable within the function, and this has a copy overhead. The
    `get_temp` returns a temporary object and so the compiler calls the overload of
    `use_string` that takes an rvalue reference. This function alters the object that
    the reference refers to, but this does not matter because the object will not
    last beyond the semicolon at the end of the line. The same can be said for calling
    `use_string` with a C-like string literal: the compiler will create a temporary
    `string` object and call the overload that has an rvalue reference parameter.
    In the final example in this code, a C++ `string` object is created on the stack
    and passed to `use_string`. The compiler sees that this object is an lvalue and
    potentially can be altered, so it calls the overload that takes an lvalue reference
    that is implemented in a way that only alters a temporary local variable in the
    function.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that the C++ compiler will detect when a parameter is a temporary
    object and will call the overload with an rvalue reference. Typically, this facility
    is used when writing *copy constructors* (special functions used to create a new
    custom type from an existing instance) and assignment operators so that these
    functions can implement the lvalue reference overload to copy the data from the
    parameter, and the rvalue reference overload to move the data from the temporary
    to the new object. Other uses are for writing custom types that are *move only*,
    where they use resources that cannot be copied, for example file handles.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Ranged for and references
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example of what you can do with references, it is worth looking at the
    ranged `for` facility in C++11\. The following code is quite straightforward;
    the array `squares` is initialized with the squares of 0 to 4:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The compiler knows the size of the array so you can use ranged `for` to print
    out the values in the array. In the following, on each iteration, the local variable
    `j` is a copy of the item in the array. As a copy, it means that you can read
    the value, but any changes made to the variable will not be reflected to the array.
    So, the following code works as expected; it prints out the contents of the array:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If you want to change the values in the array, then you have to have access
    to the actual values, and not a copy. The way to do this in a ranged `for` is
    to use a reference as the loop variable:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, on every iteration, the `k` variable is an alias to an actual member in
    the array, so whatever you do to the `k` variable is actually performed on the
    array member. In this example, every member of the `squares` array is multiplied
    by 2\. You cannot use `int*` for the type of `k` because the compiler sees that
    the type of the items in the array is `int` and will use this as the loop variable
    in the ranged `for`. Since a reference is an alias for a variable, the compiler
    will allow a reference as the loop variable, and moreover, since the reference
    is an alias, you can use it to change the actual array member.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranged `for` becomes interesting for multidimensional arrays. For example,
    in the following, a two-dimensional array is declared and an attempt is made to
    use nested loops using `auto` variables:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Since a two-dimensional array is an array of arrays (each row is a one-dimensional
    array), the intention is to obtain each row in the outer loop and then in the
    inner loop access each item in the row. There are several issues with this approach,
    but the immediate issue is that this code will not compile.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will complain about the inner loop, saying that it cannot find
    a `begin` or `end` function for the type `int*`. The reason is that ranged `for`
    uses iterator objects and for arrays it uses the C++ Standard Library functions,
    `begin` and `end,` to create these objects. The compiler will see from the `arr`
    array in the outer ranged for that each item is an `int[3]` array, and so in the
    outer `for` loop the loop variable will be a *copy* of each element, in this case
    an `int[3]` array. You cannot copy arrays like this, so the compiler will provide
    a pointer to the first element, an `int*`, and this is used in the inner `for`
    loop.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will attempt to obtain iterators for `int*`, but this is not possible
    because an `int*` contains no information about how many items it points to. There
    is a version of `begin` and `end` defined for `int[3]` (and all sizes of arrays)
    but not for `int*`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple change makes this code compile. Simply turn the `row` variable into
    a reference:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The reference parameter indicates that an alias is used for the `int[3]` array
    and, of course, an alias is the same as the element. Using `auto` hides the ugliness
    of what is actually going on. The inner loop variable is, of course, an `int`
    since this is the type of the item in the array. The outer loop variable is in
    fact `int (&)[3]`. That is, it is a reference to an `int[3]` (the parentheses
    used to indicate that it references an `int[3]` and is not an array of `int&`).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers in practice
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common requirement is to have a collection that can be an arbitrary size and
    can grow and shrink at runtime. The C++ Standard Library provides various classes
    to allow you to do this, as will be described in [Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*. The following example illustrates some
    of the principles of how these standard collections are implemented. In general,
    you should use the C++ Standard Library classes rather than implementing your
    own. Further, the Standard Library classes *encapsulate* code together in a class
    and since we have not covered classes yet, the following code will use functions
    that potentially can be called incorrectly. So, you should regard this example
    as just that, example code. A linked list is a common data structure. These are
    typically used for queues where the order of items is important. For example,
    a first-in-first-out queue where tasks are performed in the order that they are
    inserted in the queue. In this example, each task is represented as a structure
    that contains the task description and a pointer to the next task to be performed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'If the pointer to the next task is `nullptr` then this means the current task
    is the last task in the list:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Recall from the last chapter that you access members of a structure using the
    dot operator through an instance:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In this case, the compiler will create a `string` object initialized with the
    string literal `do something` and assign it to the `description` member of the
    instance called `item`. You can also create a `task` on the free store using the
    `new` operator:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In this case, the members of the object have to be accessed through a pointer,
    and C++ provides the `->` operator to give you this access:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here the `description` member is assigned to the string. Note that since `task`
    is a structure there are no access restrictions, something that is important with
    classes and described in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder under `C:\Beginning_C++` called `Chapter_04`. Start Visual
    C++ and create a C++ source file and save it to the folder you just created, as
    `tasks.cpp`. Add a simple `main` function without parameters, and provide support
    for input and output using C++ streams:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Above the `main` function, add a definition for the structure that represents
    a task in the list:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This has two members. The guts of the object is the `description` item. In our
    example, executing a task will involve printing the `description` item to the
    console. In an actual project, you'll most likely have many data items associated
    with the task, and you may even have member functions to execute the task, but
    we have not yet covered member functions; that's a topic for [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The plumbing of the linked list is the other member, `pNext`. Note that the
    `task` structure has not been completely defined at the point that the `pNext`
    member is declared. This is not a problem because `pNext` is a *pointer*. You
    cannot have a data member of an undefined, or a partially defined type, because
    the compiler will not know how much memory to allocate for it. You can have a
    pointer member to a partially defined type because a pointer member is the same
    size irrespective of what it points to.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'If we know the first link in a list, then we can access the whole list and,
    in our example, this will be a global variable. When constructing the list, the
    construction functions need to know the end of the list so that they can attach
    a new link to the list. Again, for convenience, we will make this a global variable.
    Add the following pointers after the definition of the `task` structure:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As it stands, the code does nothing, but it is a good opportunity to compile
    the file to test that there are no typos:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Adding a task object to the list
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing to do to provide the code is to add a new task to the task list.
    This needs to create a new `task` object and initialize it appropriately and then
    add it to the list by altering the last link in the list to point to the new link.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `main` function, add the following function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The parameter is a `const` reference because we will not change the parameter
    and we do not want the overhead of a copy being made. The first thing this function
    must do is create a new link, so add the following lines:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first line creates a new link on the free store, and the following lines
    initialize it. This is not necessarily the best way of initializing such an object,
    and a better mechanism, a constructor, will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. Notice that the `pNext` item is initialized to `nullptr`; this indicates
    that the link will be at the end of the list.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of this function adds the link to the list, that is, it makes
    the link the last in the list. However, if the list is empty, it means that this
    link is also the *first* link in the list. The code must perform both actions.
    Add the following code to the end of the function:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The first line checks to see if the list is empty. If `pHead` is `nullptr`,
    it means that there are no other links and so the current link is the first link,
    and so both `pHead` and `pCurrent` are initialized to the new link pointer. If
    there are existing links in the list, the link has to be added to the last link,
    so in the `else` clause the first line makes the last link point to the new link
    and the second line initializes `pCurrent` with the new link pointer, making the
    new link the last link for any new insertions to the list.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'The items are added to the list by calling this function in the `main` function.
    In this example, we will queue the tasks to wallpaper a room. This involves removing
    the old wallpaper, filling any holes in the wall, sizing the wall (painting it
    with diluted paste to make the wall sticky), and then hanging the pasted wallpaper
    to the wall. You have to do these tasks in this order, you cannot change the order,
    so these tasks are ideal for a linked list. In the `main` function add the following
    lines:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: After the last line, the list has been created. The `pHead` variable points
    to the first item in the list and you can access any other item in the list simply
    by following the `pNext` member from one link to the next.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: You can compile the code, but there is no output. Worse, as the code stands,
    there is a memory leak. The program has no code to `delete` the memory occupied
    by the `task` objects created on the free store by the `new` operator.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the task list
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterating through the list is simple, you follow the `pNext` pointer from one
    link to the next. Before doing this, let''s first fix the memory leak introduced
    in the last section. Above the `main` function, add the following function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This function will remove the link at the beginning of the list and make sure
    that the `pHead` pointer points to the next link, which will become the new beginning
    of the list. The function returns a `bool` value indicating if there are any more
    links in the list. If this function returns `false` then it means the entire list
    has been deleted.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line checks to see if this function has been called with an empty
    list. Once we are reassured that the list has at least one link, we create a temporary
    copy of this pointer. The reason is that the intention is to delete the first
    item and make `pHead` point to the next item, and to do that we have to do those
    steps in reverse: make `pHead` point to the next item and then delete the item
    that `pHead` previously pointed to.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the entire list, you need to iterate through the links, and this
    can be carried out using a `while` loop. Below the `remove_head` function, add
    the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: To delete the entire list, and address the memory leak, add the following line
    to the bottom of the main function
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You can now compile the code, and run it. However, you'll see no output because
    all the code does is create a list and then delete it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Iterating the task list
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to iterate the list from the first link following each `pNext`
    pointer until we get to the end of the list. For each link accessed, the task
    should be executed. Start by writing a function that performs the execution by
    printing out the description of the task and then returning a pointer to the next
    task. Just above the `main` function, add the following code:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The parameter here is marked as `const` because we will not change the `task`
    object pointed to by the pointer. This indicates to the compiler that if the code
    does try to change the object there is an issue. The first line checks to make
    sure that the function is not called with a null pointer. If it was then the following
    line would dereference an invalid pointer and cause a memory access fault. The
    last line returns the pointer to the next link (which could be `nullptr` for the
    last link in the list), so that the function can be called in a loop. After this
    function, add the following to iterate the entire list:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This code starts at the beginning, `pHead`, and calls `execute_task` on each
    link in the list until the function returns a `nullptr`. Add a call to this function
    towards the end of the `main` function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can now compile and run the code. The result will be:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Inserting items
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of linked lists is that you can insert items into the
    list by only allocating one new item and changing the appropriate pointers to
    point to it, and make it point to the next item in the list. Contrast this to
    allocating an array of `task` objects; if you want to insert a new item somewhere
    in the middle, you would have to allocate a new array big enough for the old items
    and the new one and then copy the old items to the new array, copying in the new
    item in the right position.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the wallpaper task list is that the room has some painted wood
    and, as any decorator knows, it is best to paint the woodwork before hanging the
    wallpaper, and usually before sizing the walls. We need to insert a new task between
    filling any holes and sizing the walls. Further, before you do any decorating,
    you should cover any furniture in the room before doing anything else, so you
    need to add a new task to the beginning.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to find the position where we want to put our new task to
    paint the woodwork. We will look for the task that we want to be before the task
    we are inserting. Before `main` add the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This code searches the entire list for a link with the `description` that matches
    the parameter. This is carried out through a loop which uses the `string` comparison
    operator, and if the required link is found, a pointer to that link is returned.
    If the comparison fails, the loop initializes the loop variable to the address
    of the next link and if this address is `nullptr` it means that the required task
    is not in the list.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'After the list is created in the main function, add the following code to search
    for the `fill holes` task:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If the `find_task` function returns a valid pointer, then we can add an item
    at this point.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to do this will allow you to add a new item after any item in
    the list that you pass to it and, if you pass `nullptr`, it will add the new item
    to the beginning. It''s called `insert_after`, but clearly, if you pass `nullptr`
    it also means *insert before the beginning*. Add the following just above the
    `main` function:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The second parameter is a `const` reference because we will not change the `string`,
    but the first parameter is not a `const` pointer because we will be changing the
    object that it points to. This function creates a new `task` object and initializes
    the `description` member to the new task name. It then checks to see if the `task`
    pointer passed to the function is null. If it is not, then the new item can be
    inserted *after* the specified link in the list. To do this, the new link `pNext`
    member is initialized to be the next item in the list, and the `pNext` member
    of the previous link is initialized to the address of the new link.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: What about inserting an item at the beginning, when the function is passed `nullptr`
    as the item to insert after? Add the following `else` clause.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, we make the `pNext` member of the new item to point to the old beginning
    of the list and then change `pHead` to point to the new item.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `main` function, you can add a call to insert a new task to paint
    the woodwork, and since we also forgot to indicate that it is best to decorate
    a room after covering all furniture with dustsheets, add a task to do that first
    in the list:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You can now compile the code. When you run the code, you should see the tasks
    performed in the required order:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be argued that one of the main reasons to use C++ is that you have direct
    access to memory using pointers. This is a feature that programmers of most other
    languages are prevented from doing. This means that as a C++ programmer, you are
    a special type of programmer: someone who is trusted with memory. In this chapter,
    you have seen how to obtain and use pointers and some examples of how inappropriate
    use of pointers can make your code go horribly wrong.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will cover functions which will include the description
    of another type of pointer: function pointers. If you are trusted with pointers
    to data and function pointers, you really are a special type of programmer.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
