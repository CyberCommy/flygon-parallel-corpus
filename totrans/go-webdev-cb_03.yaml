- en: Working with Sessions, Error Handling, and Caching in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first HTTP session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your HTTP session using Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first HTTP cookie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing caching in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing HTTP error handling in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing login and logout in a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we would like to persist information such as user data at an application
    level rather than persisting it in a database, which can be easily achieved using
    sessions and cookies. The difference between the two is that sessions are stored
    on the server side, whereas cookies are stored on the client side. We may also
    need to cache static data to avoid unnecessary calls to a database or a web service,
    and implement error handling while developing a web application. With knowledge
    of the concepts covered in this chapter, we will be able to implement all these
    functionalities in a fairly easy way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with creating an HTTP session, then we will learn
    how we can manage it using Redis, creating cookies, caching HTTP responses, implementing
    error handling, and eventually end with implementing login and logout mechanisms
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first HTTP session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a stateless protocol, which means each time a client retrieves a web
    page, the client opens a separate connection to the server and the server responds
    to it without keeping any record of the previous client request. So, if we want
    to implement a mechanism where the server knows about a request that the client
    has sent to it, then we can implement it using a session.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are working with sessions, clients just need to send an ID and the
    data is loaded from the server for the corresponding ID. There are three ways
    that we can implement this in a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden form fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL rewriting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will implement a session using HTTP cookies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/sessions` package using the `go get` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-session.go` where we will create a Gorilla cookie store to save
    and retrieve session information defining three handlers—`/login`, `/home`, and
    `/logout`—where we will be creating a valid session cookie, writing a response
    to an HTTP response stream, and invalidating a session cookie respectively, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start listening locally on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will execute a couple of commands to see how the session works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will access `/home` by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in an unauthorized access message from the server as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90912e34-54a2-44dc-9576-f61fb35e2e58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is because we first have to log in to an application, which will create
    a session ID that the server will validate before providing access to any web
    page. So, let''s log in to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the previous command will give us the `Cookie`, which has to be set
    as a request header to access any web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70bc5c54-9374-4701-880e-88cc2d0eb939.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will use this provided `Cookie` to access `/home`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the home page as a response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c042535-965d-417c-910b-2f9b3014aa3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the Go program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `var store *sessions.CookieStore`, we declared a private cookie store
    to store sessions using secure cookies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `func init() { store = sessions.NewCookieStore([]byte("secret-key")) }`,
    we defined an `init()` function that runs before `main()` to create a new cookie
    store and assign it to the `store`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init()` is always called, regardless of whether there''s a main function or
    not, so if you import a package that has an `init` function, it will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a `home` handler where we get a session from the cookie store
    for the given name after adding it to the registry using `store.Get` and fetch
    the value of the `authenticated` key from the cache. If it is true, then we write
    `Home Page` to an HTTP response stream; otherwise, we write a You are unauthorized
    to view the page. message along with a `403` HTTP code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a `login` handler where we again get a session, set the `authenticated`
    key with a value of `true`, save it, and finally write You have successfully logged
    in. to an HTTP response stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a `logout` handler where we get a session, set an `authenticated`
    key with the value of `false`, save it, and finally write You have successfully
    logged out. to an HTTP response stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we defined `main()` where we mapped all handlers, `home`, `login`,
    and `logout`, to `/home`, `/login`, and `/logout` respectively, and start the
    HTTP server on `localhost:8080`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your HTTP session using Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with the distributed applications, we probably have to implement stateless
    load balancing for frontend users. This is so we can persist session information
    in a database or a filesystem so that we can identify the user and retrieve their
    information if a server gets shut down or restarted.
  prefs: []
  type: TYPE_NORMAL
- en: We will be solving this problem as part of the recipe using Redis as the persistent
    store to save a session.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a session variable in our previous recipe using the
    Gorilla cookie store, we will just extend this recipe to save session information
    in Redis rather than maintaining it on the server.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple implementations of the Gorilla session store, which you can
    find at `https://github.com/gorilla/sessions#store-implementations`. As we are
    using Redis as our backend store, we will be using `https://github.com/boj/redistore`,
    which depends on the Redigo Redis library to store a session.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe assumes you have Redis and Redis Browser installed and running locally on
    ports `6379` and `4567` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install  `gopkg.in/boj/redistore.v1` and `github.com/gorilla/sessions` using
    the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-session-redis.go`, where we will create a `RedisStore` to store
    and retrieve session variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will execute a couple of commands to see how the session works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will access `/home` by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in an unauthorized access message from the server as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/060b9289-61e3-4786-bab8-6be435d42f95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is because we first have to log in to an application, which will create
    a **session ID** that the server will validate before providing access to any
    web page. So, let''s log in to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the previous command will give us the `Cookie`, which has to be set
    as a request header to access any web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75be8a84-1ba2-404b-abb1-3c64d109b0ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the previous command is executed, a `Cookie` will be created and saved
    in Redis, which you can see by executing the command from `redis-cli` or in the
    Redis Browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13be0e7f-26c1-42c3-94db-70ae68aa1b54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will use the `Cookie` provided to access `/home`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the Home Page as a response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d723b277-e3d6-463e-95f9-6c8ca2e20624.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the changes we introduced in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `var store *redisStore.RediStore`, we declared a private `RediStore` to
    store sessions in Redis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we updated the `init()` function to create `NewRediStore` with a size
    and maximum number of idle connections as `10`, and assigned it to the store.
    If there is an error while creating a store, then we log the error and exit with
    a status code of `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we updated `main()` to introduce the `defer store.Close()` statement,
    which closes the Redis store once we return from the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating your first HTTP cookie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies play an important role when storing information on the client side and
    we can use their values to identify a user. Basically, cookies were invented to
    solve the problem of remembering information about the user or persistent-login
    authentication, which refers to websites being able to remember the identity of
    a principal between sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are simple text files that web browsers create when you visit websites
    on the internet. Your device stores the text files locally, allowing your browser
    to access the cookie and pass data back to the original website, and are saved
    in name-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/securecookie` package using the `go get` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-cookie.go`, where we will create a Gorilla secure cookie to store
    and retrieve cookies, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `http://localhost:8080/read` will display Hello in the browser, as
    you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa64f000-0212-46be-9698-9aae55c3c804.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will access `http://localhost:8080/create`, which will create a cookie
    with the name first-cookie and display the Cookie created message in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f5ab86f-a1ce-4842-b86c-2c57d1906282.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, subsequent access to `http://localhost:8080/read` will use first-cookie to
    display Hello, followed by the value of first-cookie, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56a72dba-36a7-48b2-9d0f-bb4f6531db2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ("fmt" "log" "net/http" "github.com/gorilla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: /securecookie")`, we introduced an additional package—`github.com/gorilla/securecookie`,
    which we will use to encode and decode authenticated and encrypted cookie values.
  prefs: []
  type: TYPE_NORMAL
- en: Using `var cookieHandler *securecookie.SecureCookie`, we declared a private
    secure cookie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we updated the `init()` function to create `SecureCookie` passing a 64-byte
    hash key, which is used to authenticate values using HMAC and a 32-byte block
    key, which is used to encrypt values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a `createCookie` handler where we create a `Base64` encoded
    cookie with the key as `username` and the value as `Foo` using an `Encode` handler
    of `gorilla/securecookie`. Then, we add a `Set-Cookie` header to the provided
    `ResponseWriter` headers and write a `Cookie created.` message to an HTTP response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a `readCookie` handler, where we retrieve a cookie from the
    request, which is `first-cookie` in our code, get a value for it, and write it
    to an HTTP response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we defined `main()` where we mapped all handlers—`createCookie` and
    `readCookie`—to `/create` and `/read` respectively, and started the HTTP server
    on `localhost:8080`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing caching in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching data in a web application is sometimes necessary to avoid requesting
    static data from a database or external service again and again. Go does not provide
    any built-in package to cache responses, but it does support it through external
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of packages, such as `https://github.com/coocood/freecache`
    and `https://github.com/patrickmn/go-cache`, which can help in implementing caching
    and, in this recipe, we will be using the `https://github.com/patrickmn/go-cache` to
    implement it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/patrickmn/go-cache` package using the `go get` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-caching.go`, where we will create a cache and populate it with
    data on server boot up, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: On startup, the key with the name `foo` with a value as `bar` will be added
    to the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `http://localhost:8080/` will read a key value from the cache and
    append it to Hello as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42c7eeff-5a4e-4c2a-bc9a-d125b604ae54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have specified the cache data expiration time in our program as five minutes,
    which meansthe key that we have created in the cache at server startup will not
    be there after five minutes. So, accessing the same URL again after five minutes
    will return Key Not Found in the Cache from the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ced8f589-c0f6-4016-b5a6-0d7e80003110.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `var newCache *cache.Cache`, we declared a private cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we updated the `init()` function where we create a cache with five minutes
    of expiration time and 10 minutes of cleanup interval, and add an item to the
    cache with a key as `foo` with its value as `bar` and its expiration value as `0`,
    which means we want to use the cache's default expiration time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expiration duration is less than one (or `NoExpiration`), the items in
    the cache never expire (by default) and must be deleted manually. If the cleanup
    interval is less than one, expired items are not deleted from the cache before
    calling `c.DeleteExpired()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined the `getFromCache` handler where we retrieve the value for
    a key from the cache. If found, we write it to an HTTP response; otherwise, we
    write the `Key Not Found in Cache` message to an HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing HTTP error handling in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing error handling in any web application is one of the main aspects
    because it helps in troubleshooting and fixing bugs faster. Error handling means
    whenever an error occurs in an application, it should be logged somewhere, either
    in a file or in a database with the proper error message, along with the stack
    trace.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, it can be implemented in multiple ways. One way is to write custom handlers,
    which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-error-handling.go`, where we will create a custom handler that
    acts as a wrapper to handle all the HTTP requests, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, browsing `http://localhost:8080/employee/get/foo` will give us the Hello,
    followed by the employee name with the status code as `200`, as a response in
    the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35f4f25b-54f5-4ab0-9c0f-a4103482a04d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, accessing `http://localhost:8080/employee/get/bar` will
    return us an HTTP error with the message Name Not Found and an error code of `500`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84a2f72f-5760-4af1-bd09-675a3cc4206b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a `NameNotFoundError` struct with two fields—`Code` of type `int`
    and `Err` of type `error`, which represents an error with an associated HTTP status
    code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we allowed `NameNotFoundError` to satisfy the error interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we defined a user-defined type `WrapperHandler`, which is a Go function
    that accepts any handler that accepts `func(http.ResponseWriter, *http.Request)`
    as input parameters and returns an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we defined a `ServeHTTP` handler, which calls a handler we pass to `WrapperHandler` passing
    `(http.ResponseWriter, *http.Request)` as parameters to it and checks if there
    are any errors returned by the handler. If there are, then it handles them appropriately
    using the switch case, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, we defined a `getName` handler, which extracts request path variables,
    gets the value of the `name` variable, and checks if the name matches `foo`. If
    so, then it writes Hello, followed by the name, to an HTTP response; otherwise,
    it returns a `NameNotFoundError` struct with a `Code` field value of `500` and
    an `err` field value of an `error` with the text `Name Not Found`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we defined `main()`, where we registered `WrapperHandler` as a handler
    to be called for the URL pattern as `/get/{name}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing login and logout in web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want an application to be accessed by registered users, we have
    to implement a mechanism that asks for the user's credentials before allowing
    them to view any web pages, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created an HTML form in one of our previous recipes, we will
    just update it to implement login and logout mechanisms using the `gorilla/securecookie`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Implementing login and logout in web application* recipe in [Chapter
    2](14068271-ad23-4956-960d-ec6d01e52494.xhtml), *Working with Templates, Static
    Files, and HTML Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install `github.com/gorilla/mux` and `github.com/gorilla/securecookie` using
    the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `home.html` inside the `templates` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following content to `home.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding template, we defined a placeholder, `{{.userName}}`, whose
    values will be substituted by the template engine at runtime and a Logout button.
    By clicking the Logout button, the client will make a `POST` call to a form action,
    which is `/logout` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `html-form-login-logout.go`, where we will parse the login form, read
    the username field, and set a session cookie when a user clicks the Login button.
    We also clear the session once a user clicks the Logout button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae457fe4-65c1-46ed-ab4e-3998905c80b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start listening locally on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, browsing `http://localhost:8080` will show us the login form, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3e86f3e-8cee-4306-a391-29d2e021ccfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Submitting the form after entering the username `Foo` and a random password
    will render the Welcome Foo! message in the browser and create a cookie with the
    name session, which manages the user login/logout state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdf572bb-d0f3-49b5-95c7-b5cc9f0f43af.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, every subsequent request to `http://localhost:8080/home` will display the
    Welcome Foo! message in the browser until the cookie with the name session exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, accessing `http://localhost:8080/home` after clearing the cookie will
    redirect us to `http://localhost:8080/` and show us the login form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bb677a6-44ea-4603-a5a6-28590d64ed97.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's understand the program we have written.
  prefs: []
  type: TYPE_NORMAL
- en: Using `var cookieHandler = securecookie.New(securecookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GenerateRandomKey(64), securecookie.GenerateRandomKey(32))`, we are creating
    a secure cookie, passing a hash key as the first argument, and a block key as the
    second argument. The hash key is used to authenticate values using HMAC and the
    block key is used to encrypt values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a `getUserName` handler, where we get a cookie from the HTTP
    request, initialize a `cookieValue` map of string `keys` to string `values`, decode
    a cookie, and get a value for the username and return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `setSession` handler, where we create and initialize a map
    with the `key` and `value` as `username`,serialize it, sign it with a message
    authentication code, encode it using a `cookieHandler.Encode` handler, create
    a new HTTP cookie, and write it to an HTTP response stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined `clearSession`, which basically sets the value of the cookie
    as empty and writes it to an HTTP response stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `login` handler, where we get a username and password from
    an HTTP form, check if both are not empty, then call a `setSession` handler and
    redirect to `/home`, otherwise, redirect to the root URL `/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `logout` handler, where we clear the session values calling
    the `clearSession` handler and redirect to the root URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `loginPage` handler, where we parse `login-form.html`, return
    a new template with the name and its content, call the `Execute` handler on a
    parsed template, which generates HTML output, and write it to an HTTP response
    stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `homePage` handler, which gets the username from the HTTP
    request calling the `getUserName` handler. Then, we check whether it is not empty
    or whether there is a cookie value present. If the username is not blank, we parse
    `home.html`, inject the username as a data map, generate HTML output, and write
    it to an HTTP response stream; otherwise, we redirect it to the root URL `/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we defined the `main()` method, where we start the program execution.
    As this method does a lot of things, let''s look at it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var router = mux.NewRouter()`: Here, we create a new router instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.HandleFunc("/", loginPage)`: Here, we are registering the `loginPageHandler`
    handler with the `/` URL pattern using `HandleFunc` of the `gorilla/mux` package,
    which means the `loginPage` handler gets executed by passing `(http.ResponseWriter,
    *http.Request)` as parameters to it whenever we access the HTTP URL with the `/`
    pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.HandleFunc("/home", homePage)`: Here, we are registering the `homePageHandler`
    handler with the `/home` URL pattern using the `HandleFunc` of the `gorilla/mux`
    package, which means the `homePage` handler gets executed by passing `(http.ResponseWriter,
    *http.Request)` as parameters to it whenever we access the HTTP URL with the `/home`
    pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.HandleFunc("/login", login).Methods("POST")`: Here, we are registering
    the `loginHandler` handler with the `/login` URL pattern using the `HandleFunc`
    of the `gorilla/mux` package, which means the `login` handler gets executed by
    passing `(http.ResponseWriter, *http.Request)` as parameters to it whenever we
    access the HTTP URL with the `/login` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.HandleFunc("/logout", logout).Methods("POST")`: Here, we are registering
    the `logoutHandler` handler with the `/logout` URL pattern using the `HandleFunc`
    of the `gorilla/mux` package, which means the `logout` handler gets executed by
    passing `(http.ResponseWriter, *http.Request)` as parameters to it whenever we
    access the HTTP URL with the `/logout` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.Handle("/", router)`: Here, we are registering the router for the `/` URL pattern
    using `HandleFunc` of the `net/http` package, which means all requests with the
    `/` URL pattern are handled by the router handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here, we are calling
    `http.ListenAndServe` to serve HTTP requests that handle each incoming connection
    in a separate Goroutine. `ListenAndServe` accepts two parameters—server address
    and handler, where the server address is `localhost:8080` and the handler is `nil`,
    which means we are asking the server to use `DefaultServeMux` as a handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here, we check if there are any problems with starting the server. If there are, then
    log the error and exit with a status code of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
