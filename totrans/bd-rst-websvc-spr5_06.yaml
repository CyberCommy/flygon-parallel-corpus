- en: Spring Security and JWT (JSON Web Token)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will acquire a simple understanding of Spring Security and
    we will also talk about **JSON Web Token** (**JWT**) and how to use JWTs in our
    web service calls. This will also include JWT creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Token (JWT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate JWTs in web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to access and retrieve information from JWTs in a web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to restrict web service calls by adding JWT security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security is a powerful authentication and authorization framework, which
    will help us to provide a secure application. By using Spring Security, we can
    keep all of our REST APIs secured and accessible only by authenticated and authorized
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at an example to explain this. Assume you have a library with many
    books. Authentication will provide a key to enter the library; however, authorization
    will give you permission to take a book. Without a key, you can't even enter the
    library. Even though you have a key to the library, you will be allowed to take
    only a few books.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Token (JWT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security can be applied in many forms, including XML configurations using
    powerful libraries such as JWT. As most companies use JWT in their security, we
    will focus more on JWT-based security than simple Spring Security, which can be
    configured in XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'JWT tokens are URL-safe and web browser-compatible especially for **Single
    Sign-On** (**SSO**) contexts. JWT has three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header part decides which algorithm should be used to generate the token.
    While authenticating, the client has to save the JWT, which is returned by the
    server. Unlike traditional session creation approaches, this process doesn't need
    to store any cookies on the client side. JWT authentication is stateless as the
    client state is never saved on a server.
  prefs: []
  type: TYPE_NORMAL
- en: JWT dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use JWT in our application, we may need to use the Maven dependency. The
    following dependency should be added in the `pom.xml` file. You can get the Maven
    dependency from: [https://mvnrepository.com/artifact/javax.xml.bind](https://mvnrepository.com/artifact/javax.xml.bind).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used version `2.3.0` of the Maven dependency in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As Java 9 doesn't include `DataTypeConverter` in their bundle, we need to add
    the preceding configuration to work with `DataTypeConverter`. We will cover `DataTypeConverter`
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JWT token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a token, we have added an abstract method called `createToken` in
    our `SecurityService` interface. This interface will tell the implementing class
    that it has to create a complete method for `createToken`. In the `createToken`
    method, we will use only the subject and expiry time as these two options are
    important when creating a token.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we will create an abstract method in the `SecurityService` interface.
    The concrete class (whoever implements the `SecurityService` interface) has to
    implement the method in their class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the method for token creation in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`SecurityServiceImpl` is the concrete class that implements the abstract method
    of the `SecurityService` interface by applying the business logic. The following
    code will explain how JWT will be created by using the subject and expiry time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates the token for the subject. Here, we have hardcoded
    the secret key `"4C8kum4LxyKWYLM78sKdXrzbBjDCFyfX"` to simplify the token creation
    process. If needed, we can keep the secret key inside the properties file to avoid
    hard code in the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we verify whether the time is greater than zero. If not, we throw
    the exception right away. We are using the SHA-256 algorithm as it is used in
    most applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Hash Algorithm** (**SHA**) is a cryptographic hash function. The cryptographic
    hash is in the text form of a data file. The SHA-256 algorithm generates an almost-unique,
    fixed-size 256-bit hash. SHA-256 is one of the more reliable hash functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have hardcoded the secret key in this class. We can also store the key in
    the `application.properties` file. However to simplify the process, we have hardcoded
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are converting the string key to a byte array and then passing it to a Java
    class, `SecretKeySpec`, to get a `signingKey`. This key will be used in the token
    builder. Also, while creating a signing key, we use JCA, the name of our signature
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Cryptography Architecture** (**JCA**) was introduced by Java to support
    modern cryptography techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `JwtBuilder` class to create the token and set the expiration time
    for it. The following code defines the token creation and expiry time setting
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will have to pass time in milliseconds while calling this method as the `setExpiration`
    takes only milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to call the `createToken` method in our `HomeController`.
    Before calling the method, we will have to autowire the `SecurityService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `createToken` call is coded as follows. We take the subject as the parameter.
    To simplify the process, we have hardcoded the expiry time as `2 * 1000 * 60`
    (two minutes).
  prefs: []
  type: TYPE_NORMAL
- en: '`HomeController.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Generating a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can test the token by calling the API in a browser or any REST client. By
    calling this API, we can create a token. This token will be used for user authentication-like
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample API for creating a token is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have used `one` as a subject. We can see the token in the following
    result. This is how the token will be generated for all the subjects we pass to
    the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JWT is a string that has three parts, each separated by a dot (.). Each section
    is base-64 encoded. The first section is the header, which gives a clue about
    the algorithm used to sign the JWT. The second section is the body, and the final
    section is the signature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a subject from a JWT token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created a JWT token. Here, we are going to decode the token
    and get the subject from it. In a future section, we will talk about how to decode
    and get the subject from the token.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we have to define the method to get the subject. We will define the
    `getSubject` method in `SecurityService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will create an abstract method called `getSubject` in the `SecurityService`
    interface. Later, we will implement this method in our concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our concrete class, we will implement the `getSubject` method and add our
    code in the `SecurityServiceImpl` class. We can use the following code to get
    the subject from the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we use the `Jwts.parser` to get the `claims`. We set
    a signing key by converting the secret key to binary and then passing it to a
    parser. Once we get the `Claims`, we can simply get the subject by calling `getSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can call the method in our controller and pass the generated token
    to get the subject. You can check the following code, where the controller is
    calling the `getSubject` method and returning the subject in the `HomeController.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Getting a subject from a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we created the code to get the token. Here we will test the method
    we created previously by calling the get subject API. By calling the REST API,
    we will get the subject that we passed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we used `one` as the subject when creating the token by calling the `generateToken`
    method, we will get `"one"` in the `getSubject` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Usually, we attach the token in the headers; however, to avoid complexity, we
    have provided the result. Also, we have passed the token as a parameter to get
    the subject. You may not need to do it the same way in a real application. This
    is only for demo purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed Spring Security and JWT token-based security
    to get and decode the token. In future chapters, we will discuss how to use the
    token in AOP and restrict the API call by using a JWT token.
  prefs: []
  type: TYPE_NORMAL
