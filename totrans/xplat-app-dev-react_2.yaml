- en: Chapter 2. Project 2 – Image Sharing App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we know how to create a fully-featured app with a custom interface.
    You even learned how to add a state management library to control shared data
    in our app so that the code base remains maintainable and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, we will focus on building the app with a different state management
    library (Redux), using the camera capabilities, writing platform-specific code,
    and diving deeper into building a custom user interface, which is both appealing
    and usable. An image sharing app will serve as a good example for these features
    and also will set up the basis for understanding how big apps should be built
    on React Native.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reuse most of our code for the two platforms where this app will be
    available: iOS and Android. Although most of our user interface will be custom,
    we will use `native-base` to simplify UI elements as icons. For navigation, we
    will use `react-navigation` again as it provides the most commonly used navigation
    for each platform: tabbed navigation for iOS and drawer menu navigation for Android.
    Finally, we will use `react-native-camera` to handle the interaction with the
    device''s camera. This will not only reduce implementation complexity but also
    will provide us with a large set of features for free that we could use to extend
    our app in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: For this app, we will mock up a number of API calls so that we don't need to
    build a backend. These calls should be easily replaced by real API when the time
    to build a connected app comes.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main requirements when building an image sharing app is an appealing
    design. We will follow the design patterns for some of the most popular image
    sharing apps, adapting those patterns for each platform while trying to reuse
    as much code as possible taking advantage of React Native's cross-platform capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the user interface in iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The main screen shows a simple header and a list of images, including the user
    picture, name, and a **More** icon to share the image. At the bottom, the tabbed
    navigation displays three icons representing the three main screens: **All Images**,
    **My Images**, and **Camera**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All images used for this sample app are free to be used in any form.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user presses the **More** icon for a specific image, the **Share** menu
    will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a standard iOS component. It doesn't make much sense to use it on a
    simulator, it can be better tested on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the second screen, **My Images**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a grid representation of all the images uploaded by the current user,
    which can be updated by the next screen, **Camera**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The iOS simulator doesn't include support for any camera, so this feature is
    again better tested on an actual device, although `react-native-camera` is fully
    usable and will return fake data when accessed. We will use a static image for
    testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all for iOS; let''s move now to the Android version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As Android encourages drawer-based navigation instead of tabs, we will include
    a drawer menu icon in the header and will also make the camera available through
    a different icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As with the iOS **Share** menu, Android has its own controller, so we will
    take advantage of this feature and include it whenever a user taps on the **More**
    icon on a specific image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When a user taps on the drawer menu icon, the menu will be displayed, revealing
    the three available screens. From here, the user can navigate to the **My Images**
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the camera screen will also be accessible through the drawer menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Android Simulator includes a camera simulation consisting of a colored moving
    square, which can be used for testing. Instead, we will stick with the fixed image
    we used in the iOS version for consistency reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux in React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer and tabbed navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data with other apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Folder Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `imageShare` and will be available for iOS and Android devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In order to use some packages in this app, we will be using a specific version
    of React Native (`0.44.0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using Redux for our app, so we will create a folder structure in
    which we can accommodate our `reducers`, `actions`, `components`, `screens`, and
    `api` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we have added `logo.png` in the `img` folder. For the rest, we have
    a very standard React Native project. The entry point will be `index.ios.js` for
    iOS and `index.android.js` for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have the same implementation for both files as we want to use `src/main.js`
    as the common entry point for both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump into our `package.json` file to understand which dependencies we
    will have in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the dependencies, such as `react-navigation` or `native-base`, are
    old acquaintances from previous lessons. Others, such as `react-native-camera`,
    will be introduced in this lesson for the first time. Some of them are closely
    related to the state management library we will be using for this app, Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redux`: This is the state management library itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-redux`: These are the React handlers for Redux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redux-thunk`: This is Redux middleware that handles asynchronous action execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To complete the installation, we will need to link `react-native-camera` as
    it requires some changes in the native part of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On iOS 10 and higher, we also need to modify our `ios/imageShare/Info.plist`
    to add a **Camera Usage Description**, which should be displayed to request permission
    to enable the camera within the app. We need to add these lines right before the
    last `</dict></plist>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redux is a predictable state container for JavaScript apps based on simple
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The whole state of your app is stored in an object tree inside a single **store**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only way to change the state tree is to emit an **action**, an object describing
    what happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To specify how the actions transform the state tree, you write pure **reducers**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its popularity comes from the degree of consistency, testability, and developer
    experience that can be derived from its use in any kind of code base (frontend
    or backend). It''s also simple to reason and master due to its strict unidirectional
    data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Redux](Images/02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User triggers and **Actions** that are processed by **Reducers**, which are
    just pure functions applying changes to the state based on that **Action**. The
    resulting state is saved in a single **Store**, which is used by the **View**
    in our app to display the current state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a complex topic that falls out of the scope of this book, but it will
    be extensively used throughout some of the lessons in this book, so it could be
    beneficial to take a look at their official documentation ([http://redux.js.org/](http://redux.js.org/))
    to get acquainted with the basic concepts of this state management library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the basic concepts of Redux will be used in our `src/main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's focus first on the Redux ceremony. `let store = createStore(combineReducers({
    imagesReducer }), applyMiddleware(thunk));` sets up the store by combining the
    imported reducers (we only have one reducer for this app, so this is merely informative)
    and applying the **Thunk** middleware, which will enable our app to use asynchronous
    actions. We will simulate several API calls that will return asynchronous promises,
    so this middleware is needed to properly handle the resolutions of those promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have our `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is standard in most Redux apps using React. We wrap the root component
    `(<Navigator />` in our case) with a `<Provider />` component to ensure that we
    will have the `store` available from the root of our app. The Redux `connect`
    method will be available for us to use in our containers or screens as we proceed
    in this lesson.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a `<Navigator />` component as the root of our app, but it will
    have a different nature based on which platform is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Platform` is a React Native API used mainly to identify which platform our
    app is running on. We can write iOS-specific code by enclosing that code with
    `if(Platform.OS === ''ios''){ ... }` and the same goes for Android: `if(Platform.OS
    === ''android''){ ... }`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using it to build a tabbed navigator on iOS and a drawer
    navigator on Android, which are the **de facto** navigation patterns for those
    platforms. On both navigators, we will set `ImagesList`, `MyImages`, and `Camera`
    as the three main screens in our app.
  prefs: []
  type: TYPE_NORMAL
- en: ImagesList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main screen in our app is a list of images retrieved from the backend.
    We will display this images together with their corresponding uploader profile
    pictures and names. For each image, we will show `More`, which can be used to
    share the image with other apps on the user''s device, such as messaging apps
    or social networks. Most of the UI for this screen will be derived from the `<Gallery
    />` component, so we will focus on connecting the screen with Redux store, adding
    a custom header, and a scroll view to make the gallery scrollable, and adding
    an activity indicator to warn the user about network activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As most of the React apps use Redux, we need to connect our component with
    the state and the actions. We will create two functions (`mapStateToProps` and
    `mapStateActionsToProps`) to decorate our `<ImageList />` component with the mapped
    actions and parts of the state the component is interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`images`: This is the list of images we will use to render in our `<Gallery
    />`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addingImage`: This is a flag we will set to `true` when uploading an image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchingImages`: This is a flag that will be set to `true` when the app requests
    the list of images to the backend in order to update the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only action we will need on this screen is `fetchImages`, which is accessible
    through the `propscomponent` because we connected the list of actions in `Actions`
    to our `<ImagesList />` component. On a similar note, we have the three state
    variables (`images`, `addingImage`, and `fetchingImages`) available through `props`,
    thanks to the same `connect` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need from Redux. We will see this pattern in other screens as
    well, as it's a common solution for connecting React components with parts of
    the store and the list of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fetchImages` action is called on `componentWillMount` as the initial retrieval
    of the list of images to be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also added a way to detect the moment the `addingImage` flag is set to `true`
    to display the activity indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method will call `scrollTo` in the `<Scrollview />` to make sure it displays
    the top part, so the `<ActivityIndicator />` is visible to the user. We are using
    a custom `<ActivityIndicator />` this time (imported from `src/components/ActivityIndicator`),
    as we want to display not only a spinner but also a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we will add two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Header />`: This displays the logo and (in the Android version) two icons
    to navigate to the drawer menu and the camera screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Gallery />`: This shows the formatted list of images and uploaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before moving to another screen, let''s take a look at the three custom components
    we included in this one: `<ActivityIndicator />`, `<Header />`, and `<Gallery
    />`.'
  prefs: []
  type: TYPE_NORMAL
- en: Gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gallery holds all the rendering logic for the list of images. It relies on
    `native-base` and, more specifically, on two of its components, `<List />` and
    `<ListItem />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This component takes two props from its parent: `loading` and `imageList`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading` is used to display a standard `<ActivityIndicator />` showing the
    user network activity. This time we are using the standard one instead of a custom
    indicator as it should be clear enough what the network activity is indicating.'
  prefs: []
  type: TYPE_NORMAL
- en: '`imageList` is the array storing the list of images, which will be rendered
    in our `<Gallery />` one `<ListenItem />` at a time. Each `<ListItem />` holds
    a `<Button />` with `onPress={this._share.bind(this, image)` to share the image
    with other apps. Let''s take a look at the `_share` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Share` is a React Native API for sharing text content. In our case, we will
    share the URL (`img.src`) of the image together with a simple title. Sharing text
    is the easiest way of sharing content between apps, as many apps would accept
    text as a shared format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth noting the style we apply to the image to take over the whole
    width and a fixed height (`300`), so we have a stable layout for all images even
    when the display images have different sizes. For this setup, we use `resizeMode:
    ''cover''` so the images are not stretched in any dimension. This means we may
    end up cutting the image, but it compensates on uniformity. Another option would
    be to use `resizeMode: contain` if we don''t want to cut anything, but rather
    want to fit the image inside these bounds while possibly shrinking them.'
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to reuse a custom header between several screens. That''s why it''s
    best to create a separate component for it and import it in those screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `Platform` API again to detect Android devices and show a
    drawer menu button and a camera button only on that platform. We decided to do
    this to make those features, which are the core of the app, more prominent to
    Android users by reducing the number of buttons needed to be pressed to reach
    them. The actions to be performed when pressing the buttons are passed by the
    parent component through two props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onMenuButtonPress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCameraButtonPress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those two props call two separate functions invoking the `navigate` method
    of the navigator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.props.navigation.navigate(''DrawerOpen'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.props.navigation.navigate(''Camera'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last thing to note is how we set up the layout for the container in this
    component. We use `justifyContent: ''space-around''`, which is the way we tell
    Flexbox to evenly distribute items in the line with equal space around them. Note
    that, visually, the spaces aren''t equal since all the items have equal space
    on both sides. The first item will have one unit of space against the container
    edge, but two units of space between the next item because that next item has
    its own spacing that applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Header](Images/02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ActivityIndicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our custom `ActivityIndicator` is a very simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It receives a message as a prop and displays it next to a standard spinner.
    We also added a custom background color (`#f0f0f0`) to make it more visible over
    the white backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move now to the camera screen to add our images to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the logic when taking photos can be abstracted when using `react-native-camera`,
    so we will focus on using this module in our component and making sure we connect
    it to our app''s state through Redux actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The way `react-native-camera` works is by providing a component we can include
    in our screen and, through a reference, we can call its `capture` method, which
    returns a promise we can use to call `addImage` to upload our image to the app's
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `<Camera />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<Camera />` component takes three props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ref`: This sets a reference to the `<Camera />` component in the parent component
    for it to call the capture method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: This allows the developer to specify the look of the component in
    the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspect`: This allows you to define how the view renderer will behave when
    displaying camera''s view. There are three options: `fill`, `fit`, and `stretch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `takePicture` function will be invoked when the user presses the camera
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will use the saved reference to the camera to call its `capture` method to
    which we can pass some metadata (for example, the location in which the photo
    was taken). This method returns a promise, which will be resolved with the image
    data so we will use this data to call the `addImage` action to send this data
    to the backend, so the picture can be added to the `imagesList`. Right after sending
    the image to the backend, we will make the app navigate back to the `ImagesList`
    screen. The `addImage` method will set the `addingImages` flag, so the `ImageList`
    screen can display the activity indicator with the corresponding message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the last screen in our app: `MyImages`.'
  prefs: []
  type: TYPE_NORMAL
- en: MyImages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This screen shows all the images the logged user has uploaded. We are using
    fake images for this screen to pre-fill this screen, but more images can be added
    through the camera screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the rendering logic will be moved to a separate component named `<ImagesGrid
    />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first thing this component does is make a call to the `fetchImages` action
    but, unlike the `<ImagesList />` component, it passes the username to only retrieve
    the pictures for the logged in user. When we create this action, we need to take
    this into account and receive an optional `userName` parameter to filter out the
    list of images we will retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, this component delegates most of its behavior to `<ImageGrid
    />` so that we can reuse the render capabilities for other users. Let's move on
    to `<ImageGrid />`.
  prefs: []
  type: TYPE_NORMAL
- en: ImageGrid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple scroll view and a list of images. This component is as simple as that,
    but it''s configured in a way that allows the images to flow like a grid in an
    easy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When styling the container, we use `flexWrap`: ''wrap'' to ensure the images
    flow not only in the `row` direction but also spread to new lines when the device
    width is covered for a line of images. By setting `width` and `height` for each
    image to `width/3 - 2`, we ensure the container can fit three images per row,
    including two pixels for a small margin between them.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also several grid modules available through `npm`, but we have decided
    to build our own component for this matter, as we don't need extra functionality
    in the grid and we gain the flexibility to do it this way.
  prefs: []
  type: TYPE_NORMAL
- en: Those were all the screens and visual components we need in our image share
    app. Let's take a look now at the glue that makes them work together, the actions
    and the reducers.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we see on our screens, there are only two actions needed for this app, `fetchImages`
    (for all users or for a specific user) and `addImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Redux actions are just simple objects describing an event, including its payload.
    Since we are using `redux-thunk`, our **action creators** will return a function
    in which the Redux `dispatch` function will be called, passing the action. Let''s
    take a closer look at our `addImage` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The function we return starts by dispatching an action named `ADD_IMAGE` with
    no payload, as we just want to let Redux know that we are ready to make a network
    request to upload the image to our backend. Then, we make that request using our
    `api` (we will mock this call later). This request will return a promise, so we
    can attach `.then` and `.catch` callbacks to handle the response. If the response
    is positive (the image was properly uploaded), we will dispatch an `ADD_IMAGE_SUCCESS`
    action passing the URL for the uploaded image. If there is an error, we will dispatch
    an `ADD_IMAGE_ERROR` action covering all the possible states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the action creators work in a similar way when making network requests
    in **Redux** and **Thunk**. In fact, our action `fetchImages` is very similar
    to `addImage`, with one exception: it needs to check if `userId` was passed and
    issued a different set of actions instead, so the reducers can modify the state
    accordingly. Let''s then take a look at the reducers, which will be handling all
    these actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Redux, reducers are functions in charge of updating the state as new actions
    happen. They receive the current `state` and the action (including any payload)
    and return a new state object. We won''t go deep into how reducers work, we just
    need to understand their basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an initial state where all properties will be set to `null` except
    for `user`, which will contain mocked user data. This initial state is injected
    by default in the reducer on startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the subsequent calls, Redux will inject the actual state after applying
    any actions. Inside this function, we have `switch` evaluating the type of each
    triggered action to modify the state according to that action and its payload.
    Let''s take, for example, the `FETCH_IMAGES_SUCCESS` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One of the rules in Redux is that reducers shouldn't mutate state, but return
    a new object after an action is triggered. Using `Object.assign`, we return a
    new object containing the current state plus the desired changes based on the
    action which just happened. In this case, we are setting the `fetchingImages`
    flag to `false` to let our components know that they can hide any activity indicator
    related to the action of fetching images. We also set the received list of images
    (from `actions.images`) in the key `images` of our state, so they can be injected
    into the components requiring them. Finally, we set the `error` flag to `null`
    to hide any errors we may have displayed because of a previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned before, every asynchronous action should be split into three
    separate actions to represent the three different states: asynchronous request
    pending, succeeded, and errored. This way, we will have three groups of actions
    for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FETCH_IMAGES`, `FETCH_IMAGES_SUCCESS`, and `FETCH_IMAGES_ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FETCH_USER_IMAGES`, `FETCH_USER_IMAGES_SUCCESS`, and `FETCH_USER_IMAGES_ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_IMAGE`, `ADD_IMAGE_SUCCESS`, and `ADD_IMAGE_ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s important to note that we have separate cases for `FETCH_IMAGES` and
    `FETCH_USER_IMAGES`, as we want to keep two separate lists of images at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: A general one containing the images of all the people the user is following
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of the pictures the user has uploaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last missing piece is the API calls invoked from the action creators.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a real-world app, we would place all the calls to our backend in a separate
    `api` folder. For educational purposes, we just mocked the two API calls that
    are core to our app, `addImage` and `fetchImages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To simulate the network delay, we added some `setTimeouts` that will help in
    testing the activity indicators we set up to show the user network activity. We
    also used promises instead of plain callbacks to make our code easier to read.
    We also skipped the image URLs in these examples to make it more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used Redux in this app, and that shaped the folder structure we use. Although
    using Redux requires some boilerplate code, it helps break up our codebase in
    a reasonable way and removes direct dependencies between containers or screens.
    Redux is definitely a great addition when we need to maintain a shared state between
    screens, so we will be using it further throughout the rest of this book. In more
    complex apps, we would need to build more reducers and possibly separate them
    by domain and use Redux `combineReducers`. Moreover, we would need to add more
    actions and create separate files for each group of actions. For example, we would
    need actions for login, logout, and register, which we could put together in a
    folder named `src/actions/user.js`. Then, we should move our image-related actions
    (currently in `index.js`) to `src/actions/images.js`, so we can modify `src/actions/index.js`
    to use it as a combinator for the user and images actions in case we want to have
    the ability to import all the actions in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Redux also helps with testing as it isolates the app's business logic into the
    reducers, so we can focus on testing them thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the API calls enables us to build a quick prototype for our app. When
    a backend is available, we can reuse those mockups for test purposes and replace
    `src/api/index.js` with real HTTP calls. In any case, it's a good idea to have
    a separate folder for all our API calls, so we can replace them easily if there
    are any backend changes.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to build platform-specific code (Android-specific in our
    case), which is a very useful feature for most apps. Some companies prefer to
    write separate apps for each platform and only reuse their business logic code,
    which should be very easy in any Redux-based app as it resides in the reducers.
  prefs: []
  type: TYPE_NORMAL
- en: There is no specific API in React Native to control the device's camera, but
    we can use the `react-native-camera` module for it. This is an example of a library
    accessing iOS- and Android-native APIs to expose them in the React Native JavaScript
    world.
  prefs: []
  type: TYPE_NORMAL
- en: In our next lesson, we will explore and cross that bridge between the native
    and the JavaScript world in React Native apps by building a messaging application.
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions that are processed by ______ are just pure functions that apply changes
    to the state based on that action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Viewer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gallery holds all the rendering logic for the list of images. It relies on _____and,
    more specifically, on two of its components, `<List />` and `<ListItem />`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`native-base`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`base-native`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`resizeMode`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`header`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether the following statement is True or False: Every time a new message
    is stored in Firebase, `this.selectedChatMessages` will be synced to reflect it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among the following is a `<TextInput/>` property that will be invoked
    when a user presses the **Return** or **Next** button on the keyboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`this.refs.loginPassword.focus()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`React.Component`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onSubmitEditing`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onChangeText`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While splitting the login screen in two forms: `<LoginForm />` and `<RegistrationForm
    />` which three property components need to be passed?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
