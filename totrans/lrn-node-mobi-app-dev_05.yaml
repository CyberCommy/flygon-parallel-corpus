- en: Chapter 5. Real-Time Data and WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will show you how to enable real-time data communication
    using WebSockets. This will allow your server to directly communicate with the
    connected clients without having any polling on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: '*I would really love a two-way conversation, John*'
  prefs: []
  type: TYPE_NORMAL
- en: In its infancy, the Internet was not much of a two-way street. The traditional
    client-server architecture was the king, and servers initiating communication
    with clients was almost unheard of (and quite possibly seen as quite heretical
    by some, too).
  prefs: []
  type: TYPE_NORMAL
- en: However, starting with protocols such as **Internet Relay Chat** (**IRC**),
    real-time chat applications quickly became killer apps over time, with an enormous
    surge in popularity among ordinary users (if you are old enough to remember the
    **instant messaging computer program** (**ICQ**), yes, that is nostalgia that
    you are feeling). It was not very long until real-time features took the leap
    to the HTTP world, causing browser-based chat services to pop up everywhere. Meanwhile,
    related concepts such as push notifications gained popularity, especially with
    the advent of the smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: Polling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, real-time features are an integral part of the Internet as we know it.
    However, their implementation has not always been optimal. Especially during its
    early stages, real-time data communication was almost always implemented by using
    polling, a technique where the client regularly contacts the server in order to
    check whether its state has changed. If it had (say, if a new message had been
    made available), the server responded by sending the updated state back. Needless
    to say, polling is a recipe for wasted resource usage. Moreover, it leads to rather
    choppy programming, since we find ourselves just repeatedly asking for updates
    rather than waiting and taking action on them when they are actually sent.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid polling, we need a full-duplex solution, where the server can communicate
    directly with the client without the latter's initiative. Today, perhaps the most
    advanced and prevalent solution for this is the **WebSocket** protocol. A **WebSocket**
    protocol is a direct, two-way connection between the client and the server over
    the TCP protocol. It is structured in a way that allows both sides of the connection
    to initiate data transfer on their own. WebSockets were standardized in 2011 and
    are supported in all major browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebSockets in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js does not come with a default module for using WebSockets. While we have
    tried so far to avoid third-party solutions and just show you how to work with
    **Vanilla node**, this topic is complex enough to put writing a WebSocket handler
    from scratch well beyond the scope of the book. Therefore, for the remainder of
    this chapter, we will use the excellent `socket.io` library. We of course do not
    imply that this is what you should be using in your own work, and in the [Chapter
    6](ch06.html "Chapter 6. Introducing Ionic"), *Introducing Ionic*, the *Going
    further* section at the end of the chapter, we will direct you to alternative
    solutions and reading materials for WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will set up a separate project for this chapter, demonstrating how we can
    create a simple chat application that demonstrates the essentials of using WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a separate project folder and name it `chat-app`. In this folder, create
    a blank file named `app.js`. Finally, open your terminal or the command prompt,
    go into the folder, and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Answer the questions prompted by Node.js and make sure that you specify `app.js`
    as the entry point for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing socket.io
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will install `socket.io`, as always, by using our good friend `npm`. From
    your terminal, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We are now good to go. Let's start setting up our server! However,
    before we do that, let's start from the top and define a basic chat interface
    for us to play with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chat interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are not creating the next WhatsApp (yet!). So, building a full-fledged chat
    interface is a bit beyond what we want to achieve in this chapter. Let''s go for
    something basic, as illustrated in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a chat interface](img/B04653_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create this layout, create the `index.html` file in your project folder
    and insert a basic HTML setup inside it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add some custom elements to this markup in order to get the layout
    we need for our chat to be nice and user friendly. First, import the **Bootstrap**
    CSS framework by inserting a link into `href` in the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Bootstrap**, originally developed by Twitter, is a widely used framework
    that can be utilized to quickly build responsive web interfaces. As web design
    is beyond the scope of this book, we will use it in order to keep manual styling
    to a minimum. Don''t worry if you are unfamiliar with the framework. It is very
    intuitive, and we will explain what you need to know along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a Bootstrap container `div` to our interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is simply an organizational unit that Bootstrap uses to contain a set of
    UI elements inside a `container` so that the layout fits well on the screen being
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside the `container`, let''s add a `chat-box`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the three classes that are being used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `row` class, which is similar to the `container` class, is an organizational
    unit that confines the elements that it holds to a single row in the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `well` class, which creates a shaded container, make the elements it contains
    more visually distinct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `list-unstyled` class, which simplifies the ordinary HTML unordered list
    tag, removes, among other things, the bullet styling that appears next to elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The end result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a chat interface](img/B04653_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add the elements needed for users to enter their names and submit
    actual messages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should be familiar with most of the UI elements and what they do,
    and the rest is nothing but a standard HTML form (note that we do not provide
    an action for the form itself; submissions will be handled dynamically through
    JavaScript instead). Note that we added some classes to the `form` elements. These
    are standard Bootstrap layout classes that are used to style the appearance of
    the elements themselves. They do not introduce any functionality in themselves,
    and as such, we do not need to deal with them in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! If you open the file in your browser, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a chat interface](img/B04653_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The chat obviously does not really do anything at the present time. We will
    do something about this in a moment, but first, let's see how we can serve the
    HTML file that we just created directly from Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: A basic file server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have an HTML file for our interface, which we would like the user to
    see whenever they connect to the app via their browser. To make this happen, we
    need to make our Node.js app listen to HTTP requests and then respond with the
    appropriate HTML file. Sounds familiar? Yep, it''s time to reintroduce the Node.js
    HTTP module. Go ahead and add the following at the top of the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen the first two modules. The third one, `fs`, is the standard
    module that is used to handle interactions with the file system. We will need
    this module in order to retrieve and serve the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an HTTP server for this end. Add the following to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through what happens here. Upon receiving an HTTP request, our server
    will try to find a match for the path name of the request. If the path is for
    the root of the document hierarchy (signified by a normal slash), we want to serve
    the `index.html` document. If this is the requested path, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The `readFile()` method, which is part of the `fs` module, is invoked in order
    to load the `index.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the load fails (that is, if there was an I/O error), the server responds
    with status *500*, indicating a server error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file is successfully loaded, we add its content (in this case, a string
    of HTML content) to the response payload, set the appropriate media type and code
    for the response, and serve it back to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, a status *404* is served if the client tries to access any other
    part of the document hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action. Add the following to the end of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server from your terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your browser and visit `http://localhost:8080`. You will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A basic file server](img/B04653_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An alternate chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find an excellent tutorial on how to build a chat application that is
    similar to ours using Express.js and `Socket.io` at [http://socket.io/get-started/chat/](http://socket.io/get-started/chat/).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the example that we used here is inspired by this one, though we have
    modified it in order to make it suitable for the book.
  prefs: []
  type: TYPE_NORMAL
- en: The efficient serving of static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep things brief, and also to get our feet wet when it comes to using the
    HTTP module, we served a static HTML file directly from Node.js in our example.
    In a production system, static files are usually much more efficient as regards
    serving from a standard file server such as Apache or Nginx.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basic theory behind WebSockets and why they
    matter to modern, real-time web applications. Building on this, we created a simple
    chat application by making use of the `socket.io` library in order to demonstrate
    real-time communication between several clients connected to the same server.
  prefs: []
  type: TYPE_NORMAL
