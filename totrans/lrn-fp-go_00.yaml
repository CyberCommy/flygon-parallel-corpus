- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until recently, the message has been *Go and functional programming—don't do
    it*.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming (FP) is a perfect fit for multicore, parallel processing.
    Go is a concurrency baller (with Goroutines, channels, and so on) and already
    runs on every available CPU core. FP reduces complexity; simplicity is one of
    Go's biggest strengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what can FP bring to Go that will actually improve our software applications?
    Here''s what it offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition**: FP shows us how to decompose our apps and rebuild them by
    reusing small building blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monads**: Using monads, we are able to safely order our workflows into pipelines
    of data transformations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: We can leverage monadic error handling and still maintain
    compatibility with idiomatic Go code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Referential transparency is where we can evaluate our function
    once and then subsequently refer to its pre-computed value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expressive code**: FP allows us to concisely express business intent in our
    code. We declare what our functions do, without the clutter of error checking
    after every function call, and without having to follow state changes (pure FP
    means immutable variables).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simpler code**: No shared data means not having to deal with semaphores,
    locks, race conditions, or deadlocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most people have difficulty grasping FP.
  prefs: []
  type: TYPE_NORMAL
- en: I did too. And when I got it, I wrote this book. Take this journey with me.
    We'll see hundreds of illustrations, read easy-to-understand explanations, and
    implement FP in Go code along the way.
  prefs: []
  type: TYPE_NORMAL
- en: I enjoyed coaching soccer. The litmus test I used to determine whether I succeeded
    as a coach was the answer to this simple question: *Did they all register for
    next season and request me to be their coach?* Just like planning practice, I
    planned each chapter, starting with simple concepts and adding to them. Read this
    book, then you too will be able to say, *I got it**.*
  prefs: []
  type: TYPE_NORMAL
- en: If you want to improve your FP skills, this book is for you.
  prefs: []
  type: TYPE_NORMAL
- en: What this book covers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*, introduces
    the declarative style of programming and demonstrates recursion, memorization,
    and Go''s concurrency constructs using the Fibonacci Sequence. We will learn how
    to benchmark/performance test your recursive code and we will get some bad news.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](../Text/Ch02.xhtml), *Manipulating Collections*, shows us how to
    use intermediate (Map, Filter, and Sort) and terminal (Reduce, GroupBy, and Join)
    functions to perform data transformations. We use a Mocha-like BDD Go framework
    to test predicate functions. Itertools helps us grasp the breadth of FP collection
    manipulating function and we look at a distributed MapReduce solution: Gleam =
    Go + LuaJIT + Unix Pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](../Text/Ch03.xhtml), *Using High-Order Functions*, covers a list
    of 27 FP characteristics: Anonymous function, closures, currying, Either data
    type, first-class functions, functions, functional composition, Hindley-Milner
    type system, Idempotence, immutable state, immutable variables, Lambda expressions,
    List Monad, Maybe data type, Maybe Monad, Monadic error, handling, No side-effects,
    operator overloading, option type, parametric polymorphism, partial function application,
    recursion, referential transparency, sum or union types, Tail Call Optimization,
    typeclasses, and Unit type. It also covers an example of Generics, and illustrates
    its value to FP programmers. We implement the Map, Filter, and Reduce functions,
    as well as lazy evaluation using Goroutines and a Go channel.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](../Text/Ch04.xhtml), *SOLID Design in Go*, talks about why Gophers
    loath Java, principles of good software design, how to apply the Single Responsibility
    principle, function composition, the open/closed Principle, FP contracts, and
    duck typing. It also covers how to model behavior using interfaces, compose software
    using the Interface Segregation principle and embedded interfaces. We will learn
    about the law of Associativity with a purple Monoid chain and get the big reveal—Monads
    chain continuations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](../Text/Ch05.xhtml), *Adding Functionality with Decoration*, illustrates
    interface composition using Go''s complimentary Reader and Writer interfaces.
    Next, we will learn how procedural design compares to functional Inversion of
    Control. We will implement the following decorators: authorization, logging, and
    load balancing. Also, we will add easy-metrics to our app to see our decorator
    pattern in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](../Text/Ch06.xhtml), *Applying FP at the Architectural Level*,
    builds an application framework using a layered architecture, which solves cyclical
    dependency errors. We will learn how to apply the Hollywood principle and the
    difference between the observer pattern and dependency injection. We will use
    Inversion of Control (IoC) to control the flow of logic and build a layered application.
    Also, we will build an effective table-driven framework to test our application''s
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](../Text/Ch07.xhtml), *Functional Parameters*, enlightens us as
    to why a lot of  we''ve learned from Java and object-oriented programming does
    not apply to Go, teaches us a better way to refactor long parameter lists using
    functional options, and helps us understand the difference between currying and
    partial application. We will learn how to apply partial application to create
    another function with a smaller arity. We will use a context to gracefully shut
    down our server and see  how to cancel and roll back a long-running database transaction
    using a context.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](../Text/Ch08.xhtml), *Increase Performance Using Pipelining*, covers
    data flow types (Read, Split, Transform, Merge, and Write) and teaches us when
    and how to build a data transformation pipeline. We use buffering to increase
    throughput, goroutines and channels to process data faster, improve API readability
    using interfaces, and implement some useful filters. We also implement and compare
    imperative and functional pipeline designs for processing credit card charges.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*, gives us
    an appreciation for the lack of support for Generics in Go. We will see how to
    use a code generation tool to solve the repetitive boilerplate code problem. We
    will dive deep into function composition, implement a few functors, and learn
    how to map between worlds. We will also learn how to write a Reduce function to
    implement an invoice processing monoid.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](../Text/Ch10.xhtml), *Monads, Type Classes, and Generics*, shows
    us how a Monad works and teaches us how to compose functions using the Bind operation.
    It shows us how Monads process errors and deal with Input/Output (I/O). This chapter
    works through a monadic workflow implementation in Go. We cover what The Lambda
    Calculus is and what it has to do with Monads, see how The Lambda Calculus implements
    Recursion, and learn how the Y-Combinator works in Go. Next, we use the Y-Combinator
    to control a workflow and learn how to handle all errors at the end of the pipe.
    We will learn how type classes work and implement a few in Go. Finally, we review
    the pros and cons of generics in Go.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](../Text/Ch11.xhtml), *Category Theory That Applies*, gives us
    a working understanding of category theory. We will learn to appreciate the deep
    connection between category theory, logic, and type theory. We will increase our
    understanding with a journey through the history of FP. This chapter uses a Venn
    diagram to help explain various categories of programming languages. We come to
    understanding of what binding, currying, and application mean in the context of
    a lambda expression. This chapter shows us that the Lambda Calculus is like chocolate
    milk. This chapter covers the type system implications of FP, shows us different
    categories of homomorphisms and when to use them, and uses mathematics and the
    flight of a soccer ball to increase our understanding of morphisms. We will cover
    function composition with linear and quadratic functions, and we will learn about
    interface-driven development. We''ll explore the value in knowledge-driven systems,
    and we will learn how to apply our understanding of category theory to build better
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix, *Miscellaneous Information and How-Tos*, shows us how the author
    suggests that we build and run the Go projects in this book. It shows us how to
    propose changes to Go, introduces the Lexical Workflow Solution: a Go-compatible
    way to handle errors in one place, provides a place to go to provide feedback
    and an FP resources page, discusses the Minggatu-Catalan Number, and offers a
    solution for world peace.'
  prefs: []
  type: TYPE_NORMAL
- en: What you need for this book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to run the Go projects discussed in each chapter, you need to install
    Go. Next, you need to get your Go development environment running and start writing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Read  the *TL;DR* subsection of the *How to build and run Go projects *section
    of the *Appendix*. Go  to [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming
    in Go* in the book and start reading the *Getting the source code* section. Continue
     reading on how to set up and run your first project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other Go resources include:'
  prefs: []
  type: TYPE_NORMAL
- en: Tour of Go ([https://tour.golang.org/welcome/1](https://tour.golang.org/welcome/1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go by Example ([https://gobyexample.com/](https://gobyexample.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Go book ([https://www.miek.nl/go/](https://www.miek.nl/go/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go language specification ([https://golang.org/ref/spec](https://golang.org/ref/spec))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When I think of other things to add, I''ll put that information here: [https://lexsheehan.blogspot.com/2017/11/what-you-need-for-this-book.html](https://lexsheehan.blogspot.com/2017/11/what-you-need-for-this-book.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of the information in this book requires only a high school education.
  prefs: []
  type: TYPE_NORMAL
- en: For the programming sections in this book, you should have at least one year
    programming experience. Proficiency with Go or Haskell is ideal, but experience
    with other languages such as C/C++, Python, Javascript, Java, Scala or Ruby is
    also sufficient. You should have some familiarity using the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book should appeal to two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-programmers (read [Chapter 11](../Text/Ch11.xhtml), *Category Theory That
    Applies*) If you are one of these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: K-12 math teacher and want to see why what you are teaching matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math teacher and want to see how what you are teaching relates to other branches
    of mathematics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Student in law school and want to understand what you will be doing when you
    plead your client’s case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soccer enthusiast and like math
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Person interested in learning category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lover of the Lambda Calculus and want to see it illustrated with diagrams, pictures,
    and Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager of software projects and want to see a better correspondence between
    requirement gathering, implementation, and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C-level executive and want to understand what motivates and excites your IT
    staff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Programmers: If you are one of these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software enthusiast and want to learn Functional Programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software tester and want to see a better correspondence between requirement
    gathering, implementation, and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software architect and want to understand how to use FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go developer and like soccer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go developer and want to implement your business use case programming tasks
    with more expressive code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go developer and want to understand Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java developer and would like to understand why we say, *l*ess is more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Your_language_here* developer who knows FP and wants to transfer your skills
    to Go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go developer looking for a better way to build data transformation pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go developer and would like to see a viable way to write less code, that is,
    fewer if *err != nil* blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experienced Go developer and want to learn FP or add some tools to your toolbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Person involved in software development and want to understand any of the terms
    below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are a Go developer looking for working code, with line-by-line explanations
    for any of the following, this book is for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency (Goroutines/Channels)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transformation pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Funcitonal parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics via code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hollywood Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I18N (language translation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered application framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline to process credit card payments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce function to sum invoice totals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve circular dependency errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-driven http API test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload/download files to/from Google Cloud Buckets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y-Combinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If I decide to change the format or update this info, I''ll put it here: [http://lexsheehan .blogspot.com/2017/11/who-this-book-is-for.html](http://lexsheehan%C2%A0.blogspot.com/2017/11/who-this-book-is-for.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning. Code words in text, database table names, folder
    names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter
    handles are shown as follows: "We update code, run the `glide-update` and `go-run` commands,
    and repeat until done." A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, for example, in menus or dialog boxes, appear in the text like
    this: "In order to download new modules, we will go to Files | Settings | Project
    Name | Project Interpreter."'
  prefs: []
  type: TYPE_NORMAL
- en: Warnings or important notes appear like this.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks appear like this.
  prefs: []
  type: TYPE_NORMAL
