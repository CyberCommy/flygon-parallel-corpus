- en: '*Chapter 5*: Linux to Windows Interoperability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B16412_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Introduction
    to the Windows Subsystem for Linux*, we compared the WSL experience to running
    Linux in a virtual machine and mentioned the WSL capabilities for interoperability.
    In [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047), *Windows to
    Linux Interoperability*, we saw how to begin leveraging these interoperability
    features from the Windows side. In this chapter, we will continue exploring the
    interoperability features, but this time from the Linux side. This will allow
    you to bring the capabilities of Windows commands and tools into WSL environments.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at how to interact with Windows applications and files
    from within the WSL environment. Next up, we will look at how to work with scripts
    across Linux and Windows, including how to pass input between them. We will finish
    up with a number of interoperability tips and tricks to boost your productivity,
    from making Windows commands feel more natural by aliasing them, to sharing your
    **Secure Shell** (**SSH**) keys between Windows and Linux for ease of use and
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Windows files from Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Windows apps from Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Windows scripts from Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability tips and tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started with the first topic!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Windows files from Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, WSL automatically mounts your Windows drives inside WSL `/mnt`;
    for example, your `C:` drive is mounted as `/mnt/c`. To try this out, create a
    folder called `wsl-book` on your `C:` drive and place an `example.txt` file in
    it (the contents of the text file don''t particularly matter). Now, fire up a
    terminal in WSL and run `ls /mnt/c/wsl-book`, and you will see the file you created
    listed in the Bash output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A screenshot showing listing folder contents from Windows and
    WSL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – A screenshot showing listing folder contents from Windows and WSL
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot includes the directory listing from Windows showing `example.txt`
    in `/mnt/c` path in a WSL distro on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can interact with the mounted files as you would any other file; for example,
    you can `cat` the file to see its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can redirect content to a file in the Windows file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can edit files in `vi` (or whatever your favorite terminal text editor
    is):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A screenshot showing editing a Windows file in vi under WSL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B16413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – A screenshot showing editing a Windows file in vi under WSL
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see the file from the Windows file system being
    edited in `vi` from a WSL distro after running `vi /mnt/c/wsl-book/wsl.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Under Windows, file systems are generally case-insensitive; that is, Windows
    treats `SomeFile` as the same as `somefile`. Under Linux, file systems are case-*sensitive*
    so those would be viewed as two separate files.
  prefs: []
  type: TYPE_NORMAL
- en: When accessing the Windows file system from the WSL mounts, the files are treated
    in a case-sensitive manner on the Linux side, so attempting to read from `/mnt/c/wsl-book/EXAMPLE.txt`
    would fail.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Linux side treats the file system as case-sensitive, the underlying
    Windows file system is still case-insensitive and it is important to keep this
    in mind. For example, while Linux would consider `/mnt/c/wsl-book/wsl.txt` and
    `/mnt/c/wsl-book/WSL.txt` to be separate files, writing to `/mnt/c/wsl-book/WSL.txt`
    from Linux would actually overwrite the contents of the previously created `wsl.txt`
    file because Windows treats the names as case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen in this section, the automatically created mounts (`/mnt/…`)
    make it really easy to access Windows files from within your Linux distros with
    WSL (if you want to disable this mounting or change where the mounts are created,
    you can use `wsl.conf`, as shown in [*Chapter 2*](B16412_02_Final_JC_ePub.xhtml#_idTextAnchor023),
    *Installing and Configuring the Windows Subsystem for Linux*). The next section
    will cover calling Windows applications from Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Windows apps from Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047), *Windows to
    Linux Interoperability*, we saw how we can use the `wsl` command to call Linux
    applications from Windows. Going the other way (calling Windows applications from
    Linux) is even easier! To see this in action, fire up a terminal in your WSL distro
    and run `/mnt/c/Windows/System32/calc.exe` to launch the Windows Calculator app
    directly from Linux. If Windows is not installed in `C:\Windows`, then update
    the path to match. In this way, you can launch any Windows application from a
    terminal in your WSL distros.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Windows Calculator (and many other applications), WSL actually
    makes it even easier. This time, type `calc.exe` in your terminal and Windows
    Calculator will still run. The reason this works is that `calc.exe` is in your
    Windows path and (by default) WSL will map your Windows path to the Linux path
    in your WSL distros. To demonstrate this, run `echo $PATH` in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this, the `PATH` variable in Linux contains not only the
    usual paths, such as `/home/stuart/bin`, but also values from the Windows `PATH`
    variable that have been translated to use the WSL mounts, such as `/mnt/c/WINDOWS/System32`.
    The result of this is that any application that you are used to being able to
    run in Windows without specifying the path can also be run in WSL without specifying
    the path. One difference is that in Windows, we don't need to specify the file
    extension (for example, we can run `calc` in PowerShell) but in WSL we do.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we created a text file in Windows (`c:\wsl-book\wsl.txt`)
    and opened it in Linux using `vi`, but what if we want to open the file in a Windows
    app? If you try running `notepad.exe c:\wsl-book\wsl.txt` from Linux, Notepad
    will give an error that it cannot find the file. To fix this, you can either put
    the path in quotes (`notepad.exe "c:\wsl-book\wsl.txt"`) or escape the backslashes
    (`notepad.exe c:\\wsl-book\\wsl.txt`). With either of these fixes in place, the
    command will launch Notepad with the specified file open.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, when you're working in the terminal in a WSL distro, you will be
    spending a lot of time working with files in the Linux file system and you will
    want to open *those* files in an editor. If you have the sample code for the book
    (you can find it at [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)),
    navigate to the `chapter-05` folder in your terminal, where there is an `example.txt`
    file (if you haven't got the sample, you can run `echo "Hello from WSL!" > example.txt`
    to create a test file). In the terminal, try running `notepad.exe example.txt`
    – this will launch Notepad with the `example.txt` file from the WSL file system
    loaded. This is very handy as it allows you to easily launch Windows GUI editors
    to work with files in your WSL distros.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've seen how easily we can call Windows GUI applications
    from WSL and pass paths as parameters. In the next section, we'll take a look
    at calling Windows scripts from WSL, and how to explicitly translate paths when
    we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Windows scripts from Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re used to running PowerShell in Windows, then you will also be used
    to being able to directly call PowerShell cmdlets and scripts. When you are running
    PowerShell scripts in WSL, you have two options: install PowerShell for Linux
    or call PowerShell in Windows to run the script. If you are interested in PowerShell
    for Linux, the install documentation can be found at [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7).
    However, since this chapter is focused on calling Windows from WSL, we will look
    at the latter option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell is a Windows application and is in the Windows path, so we can call
    it using `powershell.exe` from Linux, as we saw in the last section. To run a
    command with PowerShell, we can use the `-C` switch (short for `-Command`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here we are using the `-C` switch to run the PowerShell `Get-ItemProperty`
    cmdlet to retrieve values from the Windows registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being able to call PowerShell cmdlets, you can call PowerShell
    scripts from Linux. The accompanying code for this book contains an example `wsl.ps1`
    script. This script prints a greeting to the user (using the `Name` parameter
    passed in), prints out the current working directory, and then outputs some entries
    from the Windows event log. From a Bash prompt, with the working folder set to
    the `chapter-05` folder, we can run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output shows the result of running the script we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `Hello from WSL: Stuart` output, which includes `Stuart` (the
    value we passed as the `Name` parameter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current directory is output (`Microsoft.PowerShell.Core\FileSystem::\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entries from the Windows event log from calling the `Get-EventLog` PowerShell
    cmdlet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example shows getting Windows event log entries, but since it's running
    PowerShell in Windows, you have access to any of the Windows PowerShell cmdlets
    to retrieve Windows data or manipulate Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to call PowerShell commands and scripts as you've seen here provides
    an easy way to get information from Windows when you need to. The example also
    shows passing a parameter (`Name`) from WSL to the PowerShell script, and next,
    we will explore this further to see how we can combine PowerShell and Bash commands.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data between PowerShell and Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, calling a PowerShell command or script is sufficient, but other
    times, you will want to work with the output from that command in Bash. Processing
    the output from a PowerShell script in WSL works in a natural manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this command demonstrates taking the output from executing some
    PowerShell and piping it into `wc -l`, which counts the number of lines in the
    input (`10`, in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you write scripts, it is also possible that you will want to pass values
    *into* a PowerShell script. In simple cases, we can use Bash variables, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a `MESSAGE` variable in Bash, and then used it in the command
    we passed to PowerShell. This approach uses variable substitution in Bash – the
    command that is passed to PowerShell is actually `Write-Host Hello`. This technique
    works for some scenarios, but sometimes you actually need to pipe input into PowerShell.
    This is a little less intuitive and uses the special `$input` variable in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see the output from `echo "Stuart"` being passed into
    PowerShell, which uses the `$input` variable to retrieve the input. This example
    has been kept deliberately simple to help show the technique for passing input.
    More often, the input could be the contents of a file or the output from another
    Bash command, and the PowerShell command could be a script that performs richer
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've seen how to call Windows applications from WSL, including
    how to open WSL files in GUI applications. You've also seen how to call PowerShell
    scripts, as well as how to pass data between PowerShell and Bash to create scripts
    that span both environments to give you more options for how to write your scripts.
    In the next section, we'll explore some tips and tricks for making the integration
    even tighter to further boost your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some tips that you can use to boost your productivity
    when working between Windows and WSL. We will see how to use aliases to avoid
    specifying the extension when executing Windows commands to make them feel more
    natural. We'll also see how to copy text from Linux to the Windows clipboard and
    how to make Windows folders fit in more naturally in a WSL distro. After that,
    we'll see how to open files in the default Windows application from Linux. From
    there, we will look at how Windows applications are able to work with WSL paths
    when we pass them as parameters, as well as how to take control of mapping paths
    when the default behavior doesn't work. Finally, we'll look at how to share SSH
    keys from Windows into WSL distros for easy key maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Creating aliases for Windows applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As was noted earlier in the chapter, when calling Windows applications from
    WSL, we need to include the file extension. For example, we need to use `notepad.exe`
    to launch Notepad, whereas in Windows, we can just use `notepad`. If you are used
    to not including the file extension, then including it can take a bit of getting
    used to.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to trying to retrain yourself, you can retrain Bash! Aliases
    in Bash allow you to create an alias, or an alternative name, for a command. As
    an example, running `alias notepad=notepad.exe` will create an alias of `notepad`
    for `notepad.exe`. This means that when you run `notepad hello.txt`, Bash will
    interpret it as `notepad.exe hello.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `alias` command interactively in the terminal only sets the alias
    for the current instance of the shell. To add the alias permanently, copy the
    `alias` command into your `.bashrc` (or `.bash_aliases`) file so that the shell
    automatically sets it each time it starts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at a handy Windows utility that is a good candidate for an
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: Copying output to the Windows clipboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows has had the `clip.exe` utility for a long time. The help text for `clip.exe`
    states that it *redirects output of command line tools to the Windows clipboard*,
    which is a good description. As we saw earlier in the chapter, we can pipe output
    from WSL to Windows applications, and we can use this with `clip.exe` to put items
    on the Windows clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: For example, running `echo $PWD > clip.exe` will pipe the current working directory
    in the terminal (the value of `$PWD`) to `clip.exe`. In other words, you can copy
    the current working directory in WSL to the Windows clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: You can also combine this with an alias (`alias clip=clip.exe`) to simplify
    it to `echo $PWD > clip`.
  prefs: []
  type: TYPE_NORMAL
- en: I find myself using `clip.exe` a lot – for example, to copy the output of a
    command into my code editor or an email – and it saves having to select and copy
    text in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the tips by taking a look at a way to make Windows paths
    more at home in WSL.
  prefs: []
  type: TYPE_NORMAL
- en: Using symlinks to make Windows paths easier to access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier, we can access Windows paths via the `/mnt/c/…` mapping. But
    there are some paths that you may find you access frequently, and would prefer
    to have even easier access to. For me, one of these paths is my Windows `Downloads`
    folder – each time I discover a Linux tool that I want to install in WSL and need
    to download a package to install, my browser defaults to downloading it to the
    `Downloads` folder in Windows. While I can access this via `/mnt/c/Users/stuart/Downloads`,
    I like having access to this as `~/Downloads` in WSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we can use the `ln` utility to create a `~/Downloads` that
    targets the Windows `Downloads` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this output, you can see the `ln -s /mnt/c/Users/stuart/Downloads/ ~/Downloads`
    command being used to create the symlink (you will need to change the first path
    to match your Windows `Downloads` folder). After that, you can see the output
    of listing the contents of the new symlinked location in WSL.
  prefs: []
  type: TYPE_NORMAL
- en: While there is nothing special in WSL in terms of symlinks, being able to create
    symlinks to Windows folders allows you to customize your WSL environment even
    further. As you use WSL, you will likely find your own folders that you want to
    symlink to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at opening WSL files in the default Windows editor for
    their file types.
  prefs: []
  type: TYPE_NORMAL
- en: Using wslview to launch default Windows applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we've seen how we can call specific Windows applications from
    WSL. Another feature that Windows has is being able to launch *a file* and have
    Windows determine which application should actually be launched to open it. For
    example, at a PowerShell prompt, executing `example.txt` will open the default
    text editor (likely Notepad), whereas executing `example.jpg` will open your default
    image viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, help is at hand, and `wslview` from `wslutilities` allows us to
    do the same thing from Linux. Recent versions of Ubuntu in the Microsoft Store
    come with `wslutilities` preinstalled, but installation instructions for other
    distros can be found at [https://github.com/wslutilities/wslu](https://github.com/wslutilities/wslu).
  prefs: []
  type: TYPE_NORMAL
- en: 'With `wslutilities` installed, you can run `wslview` in your WSL terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These commands show several examples of using `wslview`. The first two examples
    show the launching of the default Windows application for a file, based on its
    extension. The first example launches the default Windows text editor (typically
    Notepad) and the second example launches the Windows application associated with
    JPEG files. In the third example, we passed a URL, and this will open that URL
    in the default Windows browser.
  prefs: []
  type: TYPE_NORMAL
- en: This utility is a really handy way to bridge from the console in WSL to graphical
    applications in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there are some limitations to the paths that can be
    used with `wslview`; for example, `wslview ~/my-text-file.txt` will fail with
    an error as `The system cannot find the file specified`. In the next section,
    we will look at how to convert paths between Windows and Linux to overcome this.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping paths between Windows and WSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, we were running commands from WSL such as `notepad.exe
    example.txt`, which resulted in Notepad opening with the text file we specified.
    At first glance, it might seem like WSL translated the path for us when we ran
    the command, but the following screenshot shows Notepad in Task Manager (with
    the **Command line** column added):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A screenshot showing notepad.exe running in Task Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A screenshot showing notepad.exe running in Task Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screenshot, you can see Notepad with three different arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`notepad.exe example.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notepad.exe ../chapter-05/example.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notepad.exe /home/stuart/wsl-book/chapter-05/example.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of the examples listed, I made sure I was in a directory where the
    path resolved to a file in WSL, and Notepad launched with the example file open
    each time, even though the argument was passed directly to Notepad without translation
    (as shown in the *Figure 5.3* screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that this works is very helpful to us as WSL users, but while this
    *just works* in this scenario, and most others, understanding why it works is
    useful for the occasions when it doesn''t. That way, you know when you might want
    to change the behavior – for example, when calling Windows scripts from WSL. So,
    if the paths aren''t being converted when the command is invoked, how did Notepad
    find `example.txt` in WSL? The first part of the answer is that when Notepad is
    launched by WSL, it has its working directory set to the `\\wsl$\...` path that
    corresponds to the current working directory for the terminal in WSL. We can confirm
    this behavior by running `powershell.exe ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this output, you can see PowerShell launched from WSL listing the contents
    of its current working directory. The WSL shell has a working directory of `/home/stuart/wsl-book/chapter-05`
    and when PowerShell is launched, it gets the Windows equivalent, which is `\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that Notepad starts with its working directory based on the
    WSL working directory, we can see that in the first two of our examples (`notepad.exe
    example.txt` and `notepad.exe ../chapter-05/example.txt`), Notepad has treated
    the paths as relative paths and resolved them against its working directory to
    find the file.
  prefs: []
  type: TYPE_NORMAL
- en: The last example (`notepad.exe /home/stuart/wsl-book/chapter-05/example.txt`)
    is slightly different. In this case, Notepad resolves the path as a root-relative
    path. If Notepad had a working directory of `C:\some\folder`, then it would resolve
    the path as relative to the root of its working directory (`C:\`) and result in
    the path `C:\home\stuart\wsl-book\chapter-05\example.txt`. However, since we launched
    Notepad from WSL, it has a working directory of `\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`,
    which is a UNC path, and so the root is considered to be `\\wsl$\Ubuntu-20.04`.
    This works out very well as that maps to the root of the `Ubuntu-20.04` distro's
    file system so adding the Linux absolute path to it generates the intended path!
  prefs: []
  type: TYPE_NORMAL
- en: This mapping is very productive and works most of the time, but in the previous
    section, we saw that `wslview ~/my-text-file.txt` doesn't work. We have another
    utility that we can use when we need to control the path mapping ourselves, and
    we will look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing wslpath
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `wslpath` utility can be used to translate between Windows paths and Linux
    paths. For example, to convert from a WSL path to a Windows path, we can run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that `wslpath` returned the `\\wsl$\...` path for the WSL
    path we passed as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `wslpath` to convert paths in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `\\wsl$\...` path has been translated back to the
    WSL path.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When specifying Windows paths in Bash, you must either escape them or surround
    the path with single quotes to avoid the need to escape them. The same applies
    to the dollar sign in `\\wsl$\...` paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, we were working with paths to files in the WSL file
    system, but `wslpath` works just as well with paths from the Windows file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this output, you can see `wslpath` translating a path in the Windows file
    system to the `/mnt/…` path and back again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how `wslpath` works, let's look at a couple of examples
    of using it.
  prefs: []
  type: TYPE_NORMAL
- en: wslpath in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, we saw the handy `wslview` utility, but observed that
    it only handles relative WSL paths, so we can''t use `wslview /home/stuart/my-text-file.txt`.
    But `wslview` does work with Windows paths, and we can use `wslpath` to take advantage
    of this. For example, `wslview $(wslpath -w /home/stuart/my-text-file.txt)` will
    use `wslpath` to convert the path into the corresponding Windows path, and then
    call `wslview` with that value. We can wrap all that into a function for ease
    of use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a `wslvieww` function is created in Bash (the extra `w` is
    for Windows), but you can pick another name if you prefer. The new function is
    then called in the same way as `wslview`, but this time performs the path mapping,
    and Windows is able to resolve the mapped path and load it in the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example we''ve seen where we could use `wslpath` is for creating the
    symlink to the Windows `Downloads` folder in our Linux `home` folder. The command
    given earlier in the chapter required you to edit the command to put the appropriate
    path into your Windows user profile. The following set of commands will do this
    without modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These commands show calling into Windows to get the `USERPROFILE` environment
    variable and then converting that with `wslpath` to get the `/mnt/…` path. Finally,
    that is combined with the `Downloads` folder and passed to `ln` to create the
    symlink.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a couple of examples of how `wslpath` can be used to get complete
    control over converting paths between Windows and WSL file systems. Most of the
    time, this isn't needed, but knowing it exists (and how to use it) can help keep
    you productively working with files in WSL.
  prefs: []
  type: TYPE_NORMAL
- en: The final tip we'll look at is sharing SSH keys between Windows and WSL distros.
  prefs: []
  type: TYPE_NORMAL
- en: SSH agent forwarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When connecting to remote machines using SSH, it is common to use SSH authentication
    keys. SSH keys can also be used to authenticate to other services – for example,
    when pushing source code changes to GitHub via `git`.
  prefs: []
  type: TYPE_NORMAL
- en: This section will walk you through configuring OpenSSH Authentication Agent
    for use in WSL distros. It is assumed that you already have SSH keys and a machine
    to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have SSH keys, the OpenSSH docs walks through how to create them:
    [https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have a machine to connect to, the Azure docs will help you create
    a virtual machine with SSH access (which you can do with a free trial): [https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ssh-from-windows#provide-an-ssh-public-key-when-deploying-a-vm](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ssh-from-windows#provide-an-ssh-public-key-when-deploying-a-vm).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using your SSH keys in Windows and one or more WSL distros, you *could*
    copy the SSH keys each time. An alternative is to set up **OpenSSH Authentication
    Agent** in Windows and then configure the WSL distros to use that to get the keys.
    This means that you only have one place to manage your SSH keys and one place
    to enter SSH key passphrases (assuming you are using them).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the Windows OpenSSH Authentication Agent.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Windows' OpenSSH Authentication Agent is running
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step of setting this up is to ensure that Windows'' OpenSSH Authentication
    Agent is running. To do this, open the **Services** app in Windows and scroll
    down to **OpenSSH Authentication Agent**. If it is not showing as **Running**,
    then right-click and choose **Properties**. In the dialog that opens, ensure it
    has the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup Type** is **Automatic**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Status** is **Running** (click the **Start** button if not).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you can use `ssh-add` to add your keys to the agent – for example, `ssh-add
    ~/.ssh/id_rsa`. If you have a passphrase for your SSH key, you will be prompted
    to enter it. If you get an error that `ssh-add` is not found, then install the
    OpenSSH client using the instructions at [https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that the key has been added correctly, try running `ssh` from Windows
    to connect to your remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this output, you can see `ssh` running and successfully connecting to a remote
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you have configured your SSH keys to be used to authenticate with GitHub,
    you can use `ssh -T git@github.com` to test your connection. Full details for
    using SSH keys with GitHub can be found at [https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh).
  prefs: []
  type: TYPE_NORMAL
- en: To tell Git to use `GIT_SSH` environment variable to `C:\Windows\System32\OpenSSH\ssh.exe`
    (or whatever path it is installed to if your Windows folder is different).
  prefs: []
  type: TYPE_NORMAL
- en: The steps so far have configured OpenSSH Authentication Agent with our SSH keys
    in Windows. If we have passphrases for our keys, this will avoid us being prompted
    for them each time they are used. Next, we will set up access to these keys from
    WSL.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring access to the Windows SSH keys from WSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the key working in Windows, we want to set up our Linux distribution
    in WSL to connect to Windows' OpenSSH Authentication Agent. The Linux `ssh` client
    has the `SSH_AUTH_SOCK` environment variable, which allows you to provide a socket
    for `ssh` to connect to when it retrieves SSH keys. The challenge is that OpenSSH
    Authentication Agent allows connections via Windows-named pipes, rather than sockets
    (not to mention being a separate machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect the Linux socket to the Windows-named pipe, we will use a couple
    of utilities: `socat` and `npiperelay`. The `socat` utility is a powerful Linux
    tool that can relay streams between different locations. We will use it to listen
    on the `SSH_AUTH_SOCK` socket and forward to a command that it executes. That
    command will be the `npiperelay` utility (written by John Starks, a developer
    on the Windows team doing cool stuff with Linux and containers), which will forward
    its input to a named pipe.'
  prefs: []
  type: TYPE_NORMAL
- en: To install `npiperelay`, get the latest release from GitHub ([https://github.com/jstarks/npiperelay/releases/latest](https://github.com/jstarks/npiperelay/releases/latest))
    and extract `npiperelay.exe` to a location in your path. To install `socat`, run
    `sudo apt install socat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start forwarding SSH key requests, run the following commands in WSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line sets the `SSH_AUTH_SOCK` environment variable. The second line
    runs `socat` and tells it to listen on the `SSH_AUTH_SOCK` socket and relay that
    to `npiperelay`. The `npiperelay` command line tells it to listen and forward
    its input to the `//./pipe/openssh-ssh-agent` named pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, you can now run `ssh` in your WSL distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows successfully running `ssh` in a WSL distribution. We can
    verify that the keys have been loaded from Windows by running `ssh` with the `-v`
    (verbose) switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The full verbose output is rather long, but in this snippet of it, we can see
    the keys that `ssh` used to make the connection. Notice that the paths are the
    Windows paths, showing that the keys were loaded via the Windows OpenSSH agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands we ran earlier to start `socat` have enabled us to test this scenario,
    but you will likely want to have the SSH key requests forwarded automatically,
    rather than needing to run the commands with each new terminal session. To achieve
    this, add the following lines to your `.bash_profile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The essence of these commands is the same as the original `socat` command, but
    adds error checking, tests whether the `socat` command is already running before
    starting it, and allows it to persist across terminal sessions.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, you can have one place to manage your SSH keys and passphrases
    (Window's OpenSSH Authentication Agent) and seamlessly share your SSH keys with
    your WSL distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the technique of forwarding a Linux socket to a Windows-named
    pipe can be used in other situations. Check out the `npiperelay` docs for more
    examples, including connecting to a MySQL service in Windows from Linux: [https://github.com/jstarks/npiperelay](https://github.com/jstarks/npiperelay).'
  prefs: []
  type: TYPE_NORMAL
- en: In this tips-and-tricks section, you've seen a range of examples that illustrate
    techniques for bridging WSL and Windows, from creating command aliases to sharing
    SSH keys. While the examples are intended to be useful as is, the techniques behind
    them are generalizable. For example, the SSH key sharing example shows how to
    use a couple of tools to enable bridging between Linux sockets and Windows-named
    pipes, and could be used in other scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen how to access files in the Windows file system
    from WSL distributions, and how to launch Windows applications from Linux, including
    using the `wlsview` utility to easily launch the default Windows application for
    a file. You've learned how to pipe input between Windows and Linux scripts, including
    how to map paths between the two file system schemes using `wslpath` when required.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, you saw how to map from Linux sockets to Windows-named
    pipes, and used this technique to make your Windows SSH keys available in WSL.
    This allows you to avoid copying your SSH keys into each WSL distribution and
    instead manage your SSH keys and passphrases in a single, shared place, making
    it easier to control and back up your SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: All of this helps to bring Windows and Linux closer together with WSL and to
    drive greater productivity in your daily workflows.
  prefs: []
  type: TYPE_NORMAL
- en: We've spent quite a lot of time in the terminal in this chapter. In the next
    chapter, we will revisit the Windows terminal and explore some more advanced ways
    to customize it to suit your needs.
  prefs: []
  type: TYPE_NORMAL
