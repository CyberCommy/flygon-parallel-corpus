- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions on the run using lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding polymorphy by wrapping lambdas into `std::function`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions by concatenation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating complex predicates with logical conjunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling multiple functions with the same input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `transform_if` using `std::accumulate` and lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating cartesian product pairs of any input at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important new feature of C++11 was **lambda expressions**. In C++14 and
    C++17, the lambda expressions got some new additions, which have made them even
    more powerful. But first, what *is* a lambda expression?
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda expressions or lambda functions construct closures. A closure is a very
    generic term for *unnamed objects* that can be *called* like functions. In order
    to provide such a capability in C++, such an object must implement the `()` function
    calling operator, with or without parameters. Constructing such an object without
    lambda expressions before C++11 could still look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Instances of the `name_greeter` struct obviously carry a string with them. Note
    that both this structure type and instance are not unnamed but lambda expressions
    can be, as we will see. In terms of closures, we would say they *capture* a string.
    When the example instance is called like a function without parameters, it prints
    `"Hello, John Doe"` because we constructed it with this name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++11, it has become easier to create such closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The whole struct, `name_greeter`, is replaced by a little `[] { /*
    do something */ }` construct, which might look a bit like magic at first, but
    the first section of this chapter will explain it thoroughly in all the possible
    variants.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions are of a great help to make code *generic* and *tidy*. They
    can be used as parameters for very generic algorithms in order to specialize what
    those do when processing specific user-defined types. They can also be used to
    wrap work packages together with data in order to be run in threads or just to
    save work and postpone the actual execution. Since C++11 came out, more and more
    libraries work with lambda expressions because they became a very natural thing
    in C++. Another use case is metaprogramming, because lambda expressions can also
    be evaluated at compile time. However, we are not going much into *that* direction,
    as this would quickly blast the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter does heavily rely on some *functional programming* patterns, which
    might look weird to novices or programmers who are already experienced but not
    with such patterns. If you see lambda expressions in the coming recipes that return
    lambda expressions, which again return lambda expressions, please don't feel frustrated
    or confused too quickly. We are pushing the boundaries a bit in order to prepare
    ourselves for modern C++, where functional programming patterns occur with increasing
    regularity. If some code in the following recipes looks a bit too complex, take
    your time to understand it. Once you got through this, complex lambda expressions
    in real projects in the wild will not confuse you any longer.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions on the run using lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With lambda expressions, we can encapsulate code in order to call it later,
    and that also might be somewhere else because we can copy them around. We can
    also just encapsulate code to call it multiple times with slightly different parameters
    without having to implement a whole new function class for that task.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of lambda expressions was really new in C++11, and it has slightly
    evolved with the next two standard versions until C++17\. In this section, we
    will see what lambda expressions can look like and what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to write a little program in which we play with lambda expressions
    in order to get a feeling for them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda expressions do not need any library support, but we are going to write
    messages to the terminal and use strings, so we need the headers for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything happens in the main function this time. We define two function objects
    that take no parameters and return integer constants with the values, `1` and
    `2`. Note that the return statement is surrounded by curly brackets `{}`, like
    it is in normal functions, and the `()` parentheses, which denote a parameterless
    function, are *optional,* we don''t provide them in the second lambda expression.
    But the `[]` brackets have to be there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call both the function objects just by writing the names of the
    variables they are saved to and appending the parentheses. In this single line,
    they are indistinguishable from *normal functions* for the reader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s forget about those and define another function object, which is
    called `plus` because it takes two parameters and returns their sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also easy to use, just like any other binary function. As we defined
    its parameters to be of the `auto` type, it will work with anything that defines
    the plus operator `+`, just as strings do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need to store a lambda expression in a variable in order to use it.
    We can also define it *in place* and then write the parameters in parentheses
    just behind it `(1, 2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define a closure that carries an integer counter value around
    with it. Whenever we call it, it increments its counter value and returns the
    new value. In order to tell it that it has an internal counter variable, we write
    `count = 0` within the brackets to tell it that there is a variable `count` initialized
    to the integer value `0`. In order to allow it to modify its own captured variables,
    we use the `mutable` keyword, as the compiler would not allow it otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call the function object five times and print the values it returns,
    so we can see the increasing number values later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also take existing variables and capture them by *reference* instead
    of giving a closure its own value copy. This way, the captured variable can be
    incremented by the closure, but it is still accessible outside. In order to do
    so, we write `&a` between the brackets, where the `&` means that we store only
    a *reference* to the variable, not a *copy*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If this works, then we should be able to call this function object multiple
    times, and then observe that it has really changed the value of variable `a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example is *currying*. Currying means that we take a function that
    can accept some parameters and store it in another function object, which accepts
    *fewer* parameters. In this case, we store the `plus` function and only accept
    *one* parameter, which we forward to the `plus` function. The other parameter
    is the value `10`, which we save in the function object. This way, we get a function,
    which we call `plus_ten` because it can add that value to the single parameter
    it accepts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before compiling and running the program, go through the code again and try
    to foresee what it will print to the terminal. Then run it and check against the
    real output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we just did was not overly complicated--we added numbers, and incremented
    and printed them. We even concatenated strings with a function object, which was
    implemented to add up numbers. But for anyone who didn't know lambda expression
    syntax yet, it might have looked confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s first have a look at all the lambda expression peculiarities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d0ec8da-5bcf-4a59-945e-35aeb40addfe.png)'
  prefs: []
  type: TYPE_IMG
- en: We can usually omit most of this, which spares us some typing, in the average
    case. The shortest lambda expression possible is `[]{}`. It accepts no parameters,
    captures nothing, and essentially *does* nothing.
  prefs: []
  type: TYPE_NORMAL
- en: So what does the rest mean?
  prefs: []
  type: TYPE_NORMAL
- en: Capture list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Specifies if and what we capture. There are several forms to do so. There are
    two lazy variants:'
  prefs: []
  type: TYPE_NORMAL
- en: If we write `[=] () {...}`, we capture every variable the closure references
    from outside by value, which means that the values are *copied*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing `[&] () {...}` means that everything the closure references outside
    is only captured by *reference*, which does *not* lead to a copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we can set the capturing settings for every variable individually.
    Writing `[a, &b] () {...}` means, that we capture the variable `a` by *value*,
    and `b` by *reference*. This is more typing work, but it's generally safer to
    be that verbose because we cannot accidentally capture something we don't want
    to capture from outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, we defined a lambda expression as such: `[count=0] () {...}`.
    In this special case, we did not capture any variable from outside, but we defined
    a new one called `count`. Its type is deduced from the value we initialized it
    with, namely `0`, so it''s an `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to capture some variables by value and some, by reference,
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[a, &b] () {...}`: This captures `a` by copy and `b` by reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[&, a] () {...}`: This captures `a` by copy and any other used variable by
    reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=, &b, i{22}, this] () {...}`: This captures `b` by reference, `this` by
    copy, initializes a new variable `i` with value `22`, and captures any other used
    variable by copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try to capture a member variable of an object, you cannot do this directly
    using `[member_a] () {...}`. Instead, you have to capture either `this` or `*this`.
  prefs: []
  type: TYPE_NORMAL
- en: mutable (optional)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the function object should be able to *modify* the variables it captures
    by *copy* (`[=]`), it must be defined `mutable`. This includes calling non-const
    methods of captured objects.
  prefs: []
  type: TYPE_NORMAL
- en: constexpr (optional)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we mark the lambda expression explicitly as `constexpr`, the compiler will
    *error* out if it does not satisfy the criteria of `constexpr` functions. The
    advantage of `constexpr` functions and lambda expressions is that the compiler
    can evaluate their result at compile time if they are called with compile-time
    constant parameters. This leads to less code in the binary later.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not explicitly declare the lambda expression to be `constexpr` but
    it fits the requirements for that, it will be implicitly `constexpr` *anyway*.
    If we *want* a lambda expression to be `constexpr`, it helps to be explicit because
    the compiler will then help us by erroring out if we did it *wrong*.
  prefs: []
  type: TYPE_NORMAL
- en: exception attr (optional)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the place to specify if the function object can throw exceptions when
    it's called and runs into an error case.
  prefs: []
  type: TYPE_NORMAL
- en: return type (optional)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to have ultimate control over the return type, we may not want the
    compiler to deduce it for us automatically. In such a case, we can just write
    `[] () -> Foo {}`, which tells the compiler that we will really always return
    the `Foo` type.
  prefs: []
  type: TYPE_NORMAL
- en: Adding polymorphy by wrapping lambdas into std::function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we want to write an observer function for some kind of value, which
    might change sometimes, which then notifies other objects; like a gas pressure
    indicator, or a stock price, or something similar. Whenever the value changes,
    a list of observer objects should be called, which then react their way.
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement this, we could store a range of observer function objects
    in a vector, which all accept an `int` variable as the parameter, which represents
    the observed value. We do not know what these function objects do in particular
    when they are called with the new value, but we also don't care.
  prefs: []
  type: TYPE_NORMAL
- en: Of what type will that vector of function objects be? The `std::vector<void
    (*)(int)>` type would be correct if we were capturing pointers to *functions*
    with signatures such as `void f(int);`. This would indeed also work with any lambda
    expression that does *not* capture any variables, such as `[](int x) {...}`. But
    a lambda expression that captures something is actually a *completely different
    type* compared with a normal function because it's not just a function pointer.
    It is an *object* that couples a certain amount of data with a function! Think
    of pre-C++11 times, when there were no lambdas. Classes and structs are the natural
    way of coupling data with functions, and if you change the data member types of
    a class, you get a completely different class type. It's just *natural* that a
    vector can't store completely different types using the same type name.
  prefs: []
  type: TYPE_NORMAL
- en: Telling the user that it's only possible to save observer function objects that
    do not capture anything is bad because it limits the number of use cases very
    much. How can we allow the user to store any kind of function object, only constraining
    to the call interface, which takes a specific set of parameters that represent
    the value that shall be observed?
  prefs: []
  type: TYPE_NORMAL
- en: This section shows how to solve this problem using `std::function`, which can
    act as a polymorphic wrapper around any lambda expression, no matter if and what
    it captures.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create several lambda expressions that are
    completely different in regard to the variable types they capture but have the
    same function call signature in common. These will be saved in one vector using
    `std::function`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first do some necessary includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement a little function that returns a lambda expression. It accepts
    a container and returns a function object that captures that container by reference.
    The function object itself accepts an integer parameter. Whenever that function
    object is fed with an integer, it will *append* that integer to the container
    it captures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another little helper function will print whatever container instance we provide
    as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we first instantiate a `deque`, a `list`, and a `vector`,
    which all store integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we use the `consumer` function with our container instances, `d`, `l`,
    and `v`: we produce consumer function objects for those and store them all in
    a `vector` instance. Then we have a vector that stores three function objects.
    These function objects each capture a reference to one of the container objects.
    These container objects are of completely different types and so are the function
    objects. Nevertheless, the vector holds instances of `std::function<void(int)>`.
    All the function objects are implicitly wrapped into such `std::function` objects,
    which are then stored in the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we feed 10 integer values to all the data structures by looping over the
    values and then looping over the consumer function objects, which we call with
    those values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All the three containers should now contain the same 10 number values. Let''s
    print their content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output, which is just
    what we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complicated part of this recipe is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The objects `d`, `l`, and `v` are each wrapped into a `consumer(...)` call.
    This call returns function objects, which then each capture references to one
    of `d`, `l`, and `v`. Although these function objects all accept `int` values
    as parameters, the fact that they capture completely *different* variables also
    makes them completely different *types*. This is like trying to stuff variables
    of type `A`, `B`, and `C` into a vector, although these types have *nothing* in
    common.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this, we need to find a *common* type, which can store very
    *different* function objects, that is, `std::function`. An `std::function<void(int)>`
    object can store any function object or traditional function, which accepts an
    integer parameter and returns nothing. It decouples its type from the underlying
    function object type, using polymorphy. Consider we write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function object which is constructed from the lambda expression is
    wrapped into an `std::function` object, and whenever we call `f(123)`, this leads
    to a *virtual function call*, which is *redirected* to the actual function object
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: While storing function objects, `std::function` instances apply some intelligence.
    If we capture more and more variables in a lambda expression, it must grow larger.
    If its size is not too large, `std::function` can store it within itself. If the
    size of the stored function object is too large, `std::function` will allocate
    a chunk of memory on the heap and then store the large function object there.
    This does not affect the functionality of our code, but we should know about this
    because this can impact the *performance* of our code.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of novice programmers think or hope that `std::function<...>` actually
    expresses the *type* of a lambda expression. No, it doesn't. It is a polymorphic
    library helper, which is useful for wrapping lambda expressions and erasing their
    type differences.
  prefs: []
  type: TYPE_NORMAL
- en: Composing functions by concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of tasks are not really worthy of being implemented in completely custom
    code. Let''s, for example, have a look on how a programmer might solve the task
    of finding out how many unique words a text contains with the programming language
    Haskell. The first line defines a function `unique_words` and the second one demonstrates
    its use with an example string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d12ee785-b9b9-4b8e-9ba5-8c42f81de022.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow, that is short! Without explaining Haskell syntax too much, let's see what
    the code does. It defines the function called `unique_words`, which applies a
    series of functions to its input. It first maps all the characters from the input
    to lowercase with `map toLower`. This way, words like `FOO` and `foo` can be regarded
    as the *same* word. Then, the `words` function splits a sentence into individual
    words, as from `"foo bar baz"` to `["foo", "bar", "baz"]`. Next step is sorting
    the new list of words. This way, a word sequence such as `["a", "b", "a"]` becomes
    `["a", "a", "b"]`. Now, the `group` function takes over. It groups consecutive
    equal words into grouped lists, so `["a", "a", "b"]` becomes `[ ["a", "a"], ["b"]
    ]`. The job is now nearly done, as we now only need to count *how many* groups
    of equal words we got, which is exactly what the `length` function does.
  prefs: []
  type: TYPE_NORMAL
- en: This is a *wonderful* style of programming, as we can read *what* happens from
    right to left because we are just, kind of, describing a transformation pipeline.
    We don't need to care *how* the individual pieces are implemented (unless it turns
    out that they are slow or buggy).
  prefs: []
  type: TYPE_NORMAL
- en: However, we are not here to praise Haskell but to improve our C++ skills. It
    is possible to work like this in C++ too. We will not completely reach the elegance
    of the Haskell example but we still have the fastest programming language there
    is. This example explains how to imitate *function concatenation* in C++ with
    lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we define some simple toy function objects and *concatenate*
    them, so we get a single function that applies the simple toy functions after
    each other to the input we give it. In order to do so, we write our own concatenation
    helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need some includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement the helper function, `concat`, which arbitrarily takes many
    parameters. These parameters will be functions, such as `f`, `g`, and `h`, and
    the result will be another function object that applies `f(g(h(...)))` on any
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it gets a little complicated. When the user provides functions `f`, `g`,
    and `h`, we will evaluate this to `f( concat(g, h) )`, which again expands to
    `f( g( concat(h) ) )`, where the recursion aborts, so we get `f( g( h(...) ) )`.
    This chain of function calls representing the concatenation of these user functions
    is captured by a lambda expression, which can later take some parameters, `p`,
    and then forward them to `f(g(h(p)))`. This lambda expression is what we return.
    The `if constexpr` construct checks whether we are in a recursion step with more
    than one function to concatenate left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The other branch of the `if constexpr` construct is selected by the compiler
    if we are at the *end* of the recursion. In such a case, we just return the function,
    `t`, because it is the only parameter left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use our cool new function concatenation helper with some functions
    we want to see concatenated. Let''s begin with the `main` function, where we define
    two cheap simple function objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now let's concatenate. We concatenate our two multiplier function objects with
    the STL function, `std::plus<int>`, which takes two parameters and simply returns
    their sum. This way, we get a function that does `twice(thrice(plus( a, b )))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use it. The `combined` function looks like a single normal function
    now, and the compiler is also able to concatenate those functions without any
    unnecessary overhead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running our program yields the following output, which we also
    expected, because `2 * 3 * (2 + 3)` is `30`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complicated thing in this section is the `concat` function. It looks horribly
    complicated because it unpacks the parameter pack `ts` into another lambda expression,
    which recursively calls `concat` again, with less parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a simpler version, which concatenates exactly *three* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This already looks similar, but less complicated. We return a lambda expression,
    which captures `f`, `g`, and `h`. This lambda expression arbitrarily accepts many
    parameters and just forwards them to a call chain of `f`, `g`, and `h`. When we
    write `auto combined (concat(f, g, h))`, and later call that function object with
    two parameters, such as `combined(2, 3)`, then the `2, 3` are represented by the
    `params` pack from the preceding `concat` function.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the much more complex, generic `concat` function again; the only
    thing we do really differently is the `f ( g( h( params... ) ) )` concatenation.
    Instead, we write `f( concat(g, h) )(params...)`, which evaluates to `f( g( concat(h)
    ) )(params...)` in the next recursive call, which then finally results in `f(
    g( h( params... ) ) )`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex predicates with logical conjunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When filtering data with generic code, we end up defining **predicates**, which
    tell what data we want, and what data we do not want. Sometimes predicates are
    the *combinations* of different predicates.
  prefs: []
  type: TYPE_NORMAL
- en: When filtering strings, for example, we could implement a predicate that returns
    `true` if its input string *begins* with `"foo"`. Another predicate could return
    true if its input string *ends* with `"bar"`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing custom predicates all the time, we can *reuse* predicates
    by combining them. If we want to filter strings that begin with `"foo"` and end
    with `"bar"`, we can just pick our *existing* predicates and *combine* them with
    a logical *and*. In this section, we play with lambda expressions in order to
    find a comfortable way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement very simple string filter predicates, and then we will combine
    them with a little helper function that does the combination for us in a generic
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we''ll include some headers first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are going to need them later, we implement two simple predicate
    functions. The first one tells if a string begins with the character `''a''` and
    the second one tells if a string ends with the character `''b''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement a helper function, which we call `combine`. It takes
    a binary function as its first parameter, which could be the logical `AND` function
    or the logical `OR` function, for example. Then, it takes two other parameters,
    which shall be two predicate functions that are then combined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply return a lambda expression that captures the new predicate *combination*.
    It forwards a parameter to both predicates and, then, puts the results of both
    into the binary function and returns its result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s state that we use the `std` namespace to spare us some typing in the
    `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s combine our two predicate functions in another predicate function,
    which tells if a given string begins with `a` *and* ends with `b`, as `"ab"` does
    or `"axxxb"`. As the binary function, we choose `std::logical_and`. It is a template
    class that needs to be instantiated, so we use it with curly braces in order to
    instantiate it. Note that we don''t provide a template parameter because for this
    class, it defaults to `void`. This specialization of the class deduces all parameter
    types automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate over the standard input and print all words back to the terminal,
    which satisfies our predicate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output. We feed the
    program with four words, but only two satisfy the predicate criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The STL already provides a useful bunch of functional objects such as `std::logical_and`,
    `std::logical_or`, as well as many others, so we do not need to reimplement them
    in every project. It''s a good idea to have a look at the C++ reference and explore
    what''s there already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.cppreference.com/w/cpp/utility/functional](http://en.cppreference.com/w/cpp/utility/functional)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling multiple functions with the same input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of tasks, which lead to repetitive code. A lot of repetitive
    code can be eliminated easily using lambda expressions and a lambda expression
    helper that wraps such repetitive tasks is created very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will play with lambda expressions in order to forward a
    single call with all its parameters to multiple receivers. This is going to happen
    without any data structures in between, so the compiler has a simple job to generate
    a binary without overhead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to write a lambda expression helper, which forwards a single call
    to multiple objects, and another lambda expression helper, which forwards a single
    call to multiple calls of other functions. In our example, we are going to use
    this to print a single message with different printer functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the STL header we need for printing first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, we implement the `multicall` function, which is central to this recipe.
    It accepts an arbitrary number of functions as parameters and returns a lambda
    expression that accepts one parameter. It forwards this parameter to all the functions
    that were provided before. This way, we can define `auto call_all (multicall(f,
    g, h))`, and then, `call_all(123)` leads to a sequence of calls,`f(123); g(123);
    h(123);`. This function looks really complicated because we need a syntax trick
    in order to expand the parameter pack, `functions`, into a series of calls by
    using an `std::initializer_list` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next helper accepts a function, `f`, and a pack of parameters, `xs`. What
    it does is it calls `f` with each of those parameters. This way, a `for_each(f,
    1, 2, 3)` call leads to a series of calls: `f(1); f(2); f(3);`. This function
    essentially uses the same syntax trick to expand the parameter pack, `xs`, to
    a series of function calls, as the other function before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `brace_print` function accepts two characters and returns a new function
    object, which accepts one parameter, `x`. It will *print* it, surrounded by the
    two characters we just captured before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finally put everything to use in the `main` function. At first,
    we define functions `f`, `g`, and `h`. They represent print functions that accept
    values and print them surrounded by different braces/parentheses each. The `nl`
    function takes any parameter and just prints a line break character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s combine all of them using our `multicall` helper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For each of the numbers we provide, we want to see them individually printed
    three times surrounded by different pairs of braces/parentheses. This way, we
    can do a single function call and end up with five calls to our multifunction,
    which does another four calls to `f`, `g`, `h`, and `nl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Before compiling and running, think about what output to expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The helpers we just implemented look horribly complicated. This is because
    we expand parameter packs with `std::initializer_list`. Why did we even use that
    data structure? Let''s have a look at `for_each` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The heart of this function is the `f(xs)` expression. `xs` is a parameter pack,
    and we need to *unpack* it in order to get the individual values out of it and
    feed them to individual `f` calls. Unfortunately, we cannot just write `f(xs)...`
    using the `...` notation, which we already know.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do is constructing a list of values using `std::initializer_list`,
    which has a variadic constructor. An expression such as `return std::initializer_list<int>{f(xs)...};`
    does the job, but it has *downsides*. Let''s have a look at an implementation
    of `for_each` which does just this, so it looks simpler than what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easier to grasp, but its downsides are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It constructs an actual initializer list of return values from all the `f` calls.
    At this point, we do not care about the return values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It *returns* that initializer list, although we want a *"fire and forget"* function,
    which returns *nothing*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's possible that `f` is a function, which does not even return anything, in
    which case, this would not even compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The much more complicated `for_each` function fixes all these problems. It
    does the following things to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not *return* the initializer list, but it *casts* the whole expression
    to `void` using `(void)std::initializer_list<int>{...}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the initializer expression, it wraps `f(xs)...` into an `(f(xs), 0)...`
    expression. This leads to the return value being *thrown away*, while `0` is put
    into the initializer list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `f(xs)` in the `(f(xs), 0)...` expression is again cast to `void`, so the
    return value is really not processed anywhere *if* it has any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Putting all this together unluckily leads to an *ugly* construct, but it does
    it's work right and compiles with a whole variety of function objects, regardless
    of whether they return anything or what they return.
  prefs: []
  type: TYPE_NORMAL
- en: A nice detail of this technique is that the order in which the function calls
    are applied is guaranteed to be in a *strict sequence*.
  prefs: []
  type: TYPE_NORMAL
- en: Casting anything using the old C-style notation `(void)expression` is advised
    against because C++ has its own cast operators. We should have used `reinterpret_cast<void>(expression)`
    instead, but this would have decreased the *readability* of the code further.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing transform_if using std::accumulate and lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers who have used `std::copy_if` and `std::transform` may have asked
    themselves already, why there is no `std::transform_if`. The `std::copy_if` function
    copies items from a source range to a destination range, but *skips* the items
    that are not selected by a user-defined *predicate* function. The `std::transform`
    unconditionally copies all items from a source range to a destination range but
    transforms them in between. The transformation is provided by a user-defined function,
    which might do simple things, such as multiplying numbers or transforming items
    to completely different types.
  prefs: []
  type: TYPE_NORMAL
- en: Such functions have been there for a long time now, but there is *still* no
    `std::transform_if` function. In this section, we are going to implement this
    function. It would be easy to do this by just implementing a function that iterates
    over the ranges while copying all the items that are selected by a predicate function
    and transforming them in between. However, we'll use this occasion to delve deeper
    into lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build our own `transform_if` function which works by supplying
    `std::accumulate` with the right function objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include some headers, as always:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will implement a function called `map`. It accepts an input-transforming
    function as parameter and returns a function object, which works well together
    with `std::accumulate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'What we return is a function object that accepts a *reduce* function. When
    this object is called with such a reduce function, it returns another function
    object, which accepts an *accumulator* and an input parameter. It calls the reduce
    function on this accumulator and the `fn` transformed input variable. Don''t worry
    if this looks complicated, we''ll put it together later and see how it really
    works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we implement a function called `filter`. It works exactly the same way
    as the `map` function, but it leaves the input *untouched*, while the `map` function
    *transforms* it using a transform function. Instead, we accept a predicate function
    and *skip* input variables without reducing them in case they are not accepted
    by the predicate function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The two lambda expressions have exactly the same function signature as the
    expressions in the `map` function. The only difference is that the `input` parameter
    is left untouched. The predicate function is used to distinguish if we call the
    `reduce_fn` function on the input or if we just reach the accumulator forward
    without any change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s finally use those helpers. We instantiate iterators that let us
    read integer values from the standard input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define a predicate function, `even`, which just returns `true` if we
    have an *even number*. The transformation function `twice` multiplies its integer
    parameter with the factor `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::accumulate` function takes a range of values and *accumulates* them.
    Accumulating means *summing* the values up with the `+` operator in the default
    case. We want to provide our own accumulation function. This way, we do not maintain
    a *sum* of the values. What we do is we assign each value of the range to the
    dereferenced iterator, `it`, and then return this iterator after *advancing* it
    further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we finally put together the pieces. We iterate over the standard input
    and provide an output, `ostream_iterator`, which prints to the terminal. The `copy_and_advance`
    function object works on that output iterator by assigning the user input integers
    to it. Assigning to the output iterator effectively *prints* the assigned items.
    But we only want the *even* numbers from the user input, and we want to *multiply*
    them. To achieve this, we wrap the `copy_and_advance` function into an `even`
    *filter* and then into a `twice` *mapper*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program leads to the following output. The values
    `1`, `3`, and `5` are dropped because they are not even, and the values `2`, `4`,
    and `6` are printed after they have been doubled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe looks really complicated because we are nesting lambda expressions
    a lot. In order to understand how this works, let''s first have a look at the
    inner workings of `std::accumulate`. This is how it will look like in a typical
    STL implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The function parameter, `f`, does the main work here, while the loop collects
    its results in the user provided `init` variable. In a usual example case, the
    iterator range may represent a vector of numbers, such as `0, 1, 2, 3, 4`, and
    the `init` value is `0`. The `f` function is then just a binary function that
    might calculate the *sum* of two items using the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In this example case, the loop just sums up all the items into the `init` variable,
    such as in `init = (((0 + 1) + 2) + 3) + 4`. Writing it down like this makes obvious
    that `std::accumulate` is just a general *folding* function. Folding a range means
    applying a binary operation to an accumulator variable and stepwise every item
    contained in the range (the result of each operation is then the accumulator value
    for the next one). As this function is so general, we can do all kinds of things
    with it, just like implementing `std::transform_if`! The `f` function is then
    also called the *reduce* function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very direct implementation of `transform_if` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This looks quite *similar* to `std::accumulate`, if we regard the parameter
    `out` as the `init` variable, and *somehow* get function `f` to substitute the
    if-construct and its body!
  prefs: []
  type: TYPE_NORMAL
- en: 'We actually did that. We constructed that if-construct and its body with the
    binary function object we provided as a parameter to `std::accumulate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `std::accumulate` function puts the `init` variable into the binary function's
    `it` parameter. The second parameter is the current value from the source range
    per loop iteration step. *We* provided an *output iterator* as the `init` parameter
    of `std::accumulate.`. This way, `std::accumulate` does not calculate a sum, but
    forwards the items it iterates over to another range. This means that we just
    reimplemented `std::copy` without any predicate and transformation, yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filtering using a predicate was added by us by wrapping the `copy_and_advance`
    function object into *another* function object, which employs a predicate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This construction does not look too simple at first but have a look at the `if`
    construct. If the `predicate` function returns `true`, it forwards the parameters
    to the `reduce_fn` function, which is `copy_and_advance` in our case. If the predicate
    returns `false`, the `accum` variable, which is the `init` variable of `std::accumulate`,
    is just returned without change. This implements the *skipping* part of a filter
    operation. The `if` construct is located within the inner lambda expression, which
    has the same binary function signature as the `copy_and_advance` function, which
    makes it a fitting substitute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are able to *filter* but are still not *transforming*. This is done
    with the `map` function helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This code looks much easier. It again contains an inner lambda expression, which
    has the same signature as `copy_and_advance` has, so it can substitute it. The
    implementation just forwards the input values but *transforms* the *right* parameter
    of the binary function call with the `fn` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, when we used those helpers, we wrote the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `filter(even)` call captures the `even` predicate and gives us a function,
    which takes a binary function in order to wrap it into *another* binary function,
    which does additional *filtering*. The `map(twice)` function does the same with
    the `twice` transformation function but wraps the binary function, `copy_and_advance`,
    into another binary function, which always *transforms* the right parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Without any optimization, we would get a horribly complicated nested construction
    of functions that call functions and do only a very little amount of work in between.
    However, it is a very simple task for the compiler to optimize all the code. The
    resulting binary is as simple as if it resulted from a more direct implementation
    of `transform_if`. We pay nothing in terms of performance this way. But what we
    get is a very nice composability of functions because we were able to stick the
    `even` predicate together with the `twice` transformation function, nearly as
    simply as if they were *lego* bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Generating cartesian product pairs of any input at compile time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions in combination with parameter packs can be used for complex
    tasks. In this section, we will implement a function object that accepts an arbitrary
    number of input parameters and generates the **cartesian product** of this set
    with *itself*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cartesian product is a mathematical operation. It is noted as `A x B`,
    meaning the cartesian product of set `A` and set `B`. The result is another *single
    set*, which contains pairs of *all* item combinations of the sets `A` and `B`.
    The operation basically means, c*ombine every item from A with every item from
    B*. The following diagram illustrates the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f83f3245-6b4c-4919-b137-17c2d6a11e7e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, if `A = (x, y, z)`, and `B = (1, 2, 3)`, then the
    cartesian product is `(x, 1)`, `(x, 2)`, `(x, 3)`, `(y, 1)`, `(y, 2)`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide that `A` and `B` are the *same* set, say `(1, 2)`, then the cartesian
    product of that is `(1, 1)`, `(1, 2)`, `(2, 1)`, and `(2, 2)`. In some cases,
    this might be declared *redundant*, because the combination of items with *themselves*
    (like in `(1, 1)`) or redundant combinations of `(1, 2)` and `(2, 1)` may not
    be needed. In such a case, the cartesian product can be filtered with a simple
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement the cartesian product without any loops but
    with lambda expressions and parameter pack unpacking.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We implement a function object that accepts a function, `f`, and a set of parameters.
    The function object will *create* the cartesian product of the parameter set,
    *filter* out the redundant parts, and *call* the `f` function with each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need to include the STL header that is needed for printing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a simple helper function that prints a pair of values, and
    we begin implementing the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The hard part starts now. We first implement a helper for the `cartesian` function
    that we are going to implement in the next step. This function accepts a parameter,
    `f`, which will be the `print` function when we use it later. The other parameters
    are `x` and the parameter pack `rest`. These contain the actual items of which
    we want to have the cartesian product. Look at the `f(x, rest)` expression: for
    `x=1` and `rest=2, 3, 4`, this will result in calls such as `f(1, 2); f(1, 3);
    f(1, 4);`. The `(x < rest)` test is for removing redundancy in the generated pairs.
    We will look at this in more detail later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `cartesian` function is the most complex piece of code in this whole recipe.
    It accepts the parameter pack `xs` and returns a function object that captures
    it. The returned function object accepts a function object, `f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a parameter pack, `xs=1, 2, 3`, the inner lambda expression will generate
    the following calls: `call_cart(f, **1**, 1, 2, 3); call_cart(f, **2**, 1, 2,
    3); call_cart(f, **3**, 1, 2, 3);`. From that range of calls, we can generate
    all the cartesian product pairs we need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use the `...` notation for expanding the `xs` parameter pack *twice*,
    which looks weird at first. The first occurrence of `...` expands the entire `xs`
    parameter pack into the `call_cart` call. The second occurrence leads to multiple
    `call_cart` calls with a differing *second* parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's generate the cartesian product of the numeric set `1, 2, 3` and print
    the pairs. Without the redundant pairs, this should result in the number pairs,
    `(1, 2)`, `(2, 3)`, and `(1, 3)`. More combinations are not possible if we ignore
    the order and do not want the same number in one pair. This means that we do *not*
    want `(1, 1)`, and consider `(1, 2)` and `(2, 1)` the *same* pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we let `cartesian` generate a function object that already contains all
    possible pairs and accepts our print function. Then, we use it to let our `print`
    function being called with all these pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the `print_cart` variable, `constexpr`, so we can guarantee that
    the function object it holds (and all the pairs it generates) is created at compile
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running yields the following output, just as expected. Play around
    with the code by removing the `(x < xs)` conditional in the `call_cart` function
    and see that we get the full cartesian product with redundant pairs and the same
    number pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was another really complicated-looking lambda expression construct. But
    as soon as we understand this thoroughly, we will not be confused by any lambda
    expression anytime soon!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s have a detailed look at it. We should get a mental picture of what
    needs to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/957b7794-331d-4b2d-958e-ac82ee95071d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We take our set `1, 2, 3` and compose *three new* sets from it. The first part
    of each of these sets is consecutively a single item from the set, and the second
    part is the whole set itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We combine the first item with every item from the set and get as many *pairs*
    out of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From these resulting pairs, we only pick the ones that are *not redundant* (as
    for example `(1, 2)` and `(2, 1)` are redundant) and not same-numbered (as for
    example `(1, 1)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, back to the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The inner expression, `call_cart(xs, xs...)`, exactly represents the separation
    of `(1, 2, 3)` into those new sets, such as `1, [1, 2, 3]`. The full expression,
    `((void)call_cart(f, xs, xs...), 0)...` with the other `...` outside, does this
    separation for every value of the set, so we also get `2, [1, 2, 3]` and `3, [1,
    2, 3]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2 and step 3 are done by `call_cart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Parameter `x` always contains the single value picked from the set, and `rest`
    contains the whole set again. Let's ignore the `(x < rest)` conditional at first.
    Here, the expression `f(x, rest)`, together with the `...` parameter pack expansion
    generates the function calls `f(1, 1)`, `f(1, 2)`, and so on, which results in
    the pairs being printed. This was step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is achieved by filtering out only the pairs where `(x < rest)` applies.
  prefs: []
  type: TYPE_NORMAL
- en: We made all lambda expressions and the variables holding them `constexpr`. By
    doing so, we can now guarantee that the compiler will evaluate their code at compile
    time and compile a binary that already contains all the number pairs instead of
    calculating them at runtime. Note that this *only* happens if all the function
    arguments we provide to a constexpr function are *known at compile time* already.
  prefs: []
  type: TYPE_NORMAL
