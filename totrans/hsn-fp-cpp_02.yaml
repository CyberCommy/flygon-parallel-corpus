- en: An Introduction to Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is functional programming useful? Functional programming constructs have
    popped up in all major programming languages in the past decade. Programmers have
    enjoyed their benefits—simplified loops, more expressive code, and simple parallelization.
    But there's more to it—decoupling from time, enabling opportunities to remove
    duplication, composability, and a simpler design. Higher adoption of functional
    programming (including the large-scale adoption of Scala in the financial sector)
    means more opportunities for you once you know and understand it. While we will
    take a deep dive into functional programming in this book to help you learn, remember
    that functional programming is another tool to add to your toolbox—one that you
    can choose to use when the problem and the context fits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to functional programming and an examination of how you've already
    been using functional constructs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured loops versus functional loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) versus functional design'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composability and removing duplication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code works with g++ 7.3.0 and C++ 17; it includes a `makefile` for your
    convenience. You can find it in the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp))
    in the `Chapter01` directory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to functional programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My first experience with functional programming was at university. I was a 20-year-old
    geek who was interested in Sci-Fi, reading, and programming; programming was the
    highlight of my academic life. Everything to do with C++, Java, MATLAB, and a
    few other programming languages that we used was fun for me. Unfortunately, I
    can't say the same thing about the disciplines around electrical engineering,
    circuits, or compiler theory. I just wanted to write code!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Based on my interests, functional programming should have been a very fun course
    for me. Our teacher was very passionate. We had to write code. But something went
    wrong—I didn't click with what the teacher was telling us. Why were lists so interesting?
    Why was the syntax so backward and full of parentheses? Why would I use these
    things when it was much simpler to write the same code in C++? I ended up trying
    to translate all the programming constructs I knew from BASIC and C++ into Lisp
    and OCaml. It completely missed the point of functional programming, but I passed
    the course and forgot about it for many years.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: I imagine that many of you can relate to this story, and I have a possible reason
    for this. I now believe that my teacher, despite being extremely passionate, used
    the wrong approach. Today, I understand that functional programming has a certain
    elegance at its core, due to its strong relationship with mathematics. But that
    elegance requires a sense of insightful observation that I didn't have when I
    was 20, that is, a sense that I was lucky to build on after years of various experiences.
    It's obvious to me now that learning functional programming shouldn't be related
    to the ability of the reader to see this elegance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: So, what approach could we use instead? Thinking about the past me, that is,
    the geek who just wanted to write code, there's only one way to go—look at the
    common problems in code and explore how functional programming reduces or removes
    them entirely. Additionally, start from the beginning; you've already seen functional
    programming, you've already used some of the concepts and constructs, and you
    might have even found them very useful. Let's examine why.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming constructs are everywhere
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Around 10 years after I finished the university functional programming course,
    I had a casual chat with my friend, Felix. As any two geeks, we would rarely see
    each other, but we had, for years, an ongoing conversation on instant messaging
    discussing all kinds of nerdy topics and, of course, programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Somehow, the topic of functional programming came up. Felix pointed out that
    one of my favorite and most enjoyable programming languages, LOGO, was, in fact,
    a functional programming language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**LOGO** is an educational programming language whose main characteristic is
    utilization of so-called **turtle graphics**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'It was obvious in retrospect; here is how to write a function that draws a
    square in the KTurtle version of LOGO:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45f3ee41-d99c-4630-8595-8f4b1e2aadbb.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Can you see how we're passing two lines of code to the repeat function? That's
    functional programming! A fundamental tenet of functional programming is that
    code is just another type of data, which can be packed in a function and passed
    around to other functions. I used this construct in LOGO hundreds of times without
    making the connection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'This realization made me think: could there be other functional programming
    constructs that I''ve used without knowing? As it turns out, yes, there were.
    In fact, as a C++ programmer, you''ve most likely used them as well; let''s take
    a look at a few examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is a typical example of recommended C++ code. I first learned
    about the benefits of adding `const` everywhere from the amazing books of Bertrand
    Meyer: *Effective C++*, *More Effective C++*, and *Effective STL*. There are multiple
    reasons this construct works well. First, it protects the data members and parameters
    that shouldn't change. Second, it allows a programmer to reason more easily about
    what happens in the function by removing possible side effects. Third, it allows
    the compiler to optimize the function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, this is also an example of immutability in action. As we'll
    discover in the following chapters, functional programming places immutability
    at the core of the programs, moving all side effects to the edges of the program.
    We already know the basic construct of functional programming; to say that we
    use functional programming just means to use it much more extensively!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example from STL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The STL algorithms have great power; this power comes from polymorphism. I'm
    using this term in a more fundamental sense than in OOP—it merely means that it
    doesn't matter what the collection contains, because the algorithm will still
    work fine as long as a comparison is implemented. I have to admit that when I
    first understood it, I was impressed by the smart, effective solution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a variant of the `sort` function that allows the sorting of elements
    even when the comparison is not implemented, or when it doesn''t work as we''d
    like; for example, when we are given a `Name` structure, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we''d like to sort a `vector<Name>` container by first name, we just need
    a `compare` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Additionally, we need to pass it to the `sort` function, as shown in the following
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This makes a kind of *higher-order function*. A high-level function is a function
    that uses other functions as parameters in order to allow higher levels of polymorphism.
    Congratulations—you've just used a second functional programming construct!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: I will go as far as to state that STL is a good example of functional programming
    in action. Once you learn more about functional programming constructs, you'll
    realize that they are used everywhere in STL. Some of them, such as function pointers
    or functors, have been in the C++ language for a very long time. In fact, STL
    has stood the test of time, so why not use similar paradigms in our code as well?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: There's no better example to support this statement other than the functional
    loops present in STL.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Structured loops versus functional loops
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s hardly a surprise that one of the first things that we learn as programmers
    is how to write a loop. One of my first loops in C++ was printing the numbers
    from `1` to `10`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a curious programmer, I took this syntax for granted, went over its peculiarities
    and complications, and just used it. Looking back, I realize that there are a
    few unusual things about this construct. First, why start with `0`? I've been
    told it's a convention, due to historical reasons. Then, the `for` loop has three
    statements—an initialization, a condition, and an increment. This sounds slightly
    too complicated for what we're trying to achieve. Finally, the end condition forced
    me into more off-by-one errors than I'd like to admit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you will realize that STL allows you to use iterators when looping
    over collections:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is definitely better than the `for` loop using a cursor. It avoids off-by-one
    errors and there are no `0` convention shenanigans. There's still a lot of ceremony
    around the operation, however. Even worse is that the loop tends to grow as the
    complexity of the program grows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: There's an easy way to show this symptom. Let's take a look back at the first
    problems that I've solved using loops.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a vector of integers and compute their sum; the naive implementation
    will be as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If only production code was so simple! Instead, the moment we implement this
    code, we''ll get a new requirement. We now need to sum only the even numbers from
    the vector. Hmm, that''s easy enough, right? Let''s take a look at the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you thought this is the end, it''s not. We now require three sums for the
    same vector—one of the even numbers, one of the odd numbers, and one of the total.
    Let''s now add some more code, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our loop, which initially started relatively simple, has become more and more
    complex. When I first started professional programming, we used to blame users
    and clients who couldn't make up their minds about the perfect feature and give
    us the final, frozen requirements. That's rarely possible in reality, however;
    our customers learn new things every day from the interaction of users with the
    programs we write. It's up to us to make this code clear, and it's possible with
    functional loops.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Years later, I learned Groovy. A Java virtual machine-based programming language,
    Groovy focuses on making the job of programmers easier by helping them to write
    less code and avoid common errors. Here''s how you could write the previous code
    in Groovy:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's compare the two for a moment. There's no loop. The code is extremely clear.
    There's no way to make off-by-one errors. There's no counter, so, therefore, there
    is no *starting from* `0` weirdness. Additionally, there's no scaffolding around
    it—I just write what I want to achieve, and a trained reader can easily understand
    it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'While the C++ version is more verbose, it allows us to achieve the same goals:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There''s still a lot of ceremony though, and too much code similarity. So,
    let''s get rid of it, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've just replaced a complex `for` loop with a number of simpler, more readable,
    and composable functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: So, is this code better? Well, that depends on your definition of *better*.
    I like to think of any implementation in terms of advantages and disadvantages.
    The advantages of functional loops are simplicity, readability, reduced code duplication,
    and composability. Are there any disadvantages? Well, our initial `for` loop only
    requires one pass through the vector, while our current implementation requires
    three passes. This can be a burden for very large collections, or when response
    time and memory usage are very important. This is definitely worth discussing,
    and we will examine it in more detail in [Chapter 10](4612efcd-7520-4ae3-9813-0c42acee664a.xhtml), *Performance
    Optimization,* which is focused solely on performance optimization for functional
    programming. For now, I recommend that you focus on understanding the new tool
    of functional programming.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In order to do that, we need to revisit immutability.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already understood that a certain level of immutability is preferred
    in C++; the common example is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `const` keyword clearly communicates a few important constraints on the
    code, such as the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The function does not change any of its arguments before returning.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function does not change any data member of the class it belongs to.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now imagine an alternate version of `add`, as follows
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I called this `uglyAdd` for a reason—I don't tolerate code like this when I'm
    programming! This function violates the principle of minimal surprise and does
    too many things. Reading the function code reveals nothing about its intent. Imagine
    the surprise of the caller, if not careful, then, just by calling an `add` function,
    two things changed—one in the parameters passed, and the second in the class where
    the function is located.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: While this is an extreme example, it contributes to an argument for immutability.
    Immutable functions are boring; they receive data, change nothing in the received
    data, change nothing in the class containing them, and return a value. When it
    comes to maintaining code over long periods of time, however, boring is good.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is the core property of functions in functional programming. Of
    course, there's at least one part of your program that cannot be immutable—**input/output**
    (**I/O**). We will accept I/O for what it is, and we will focus on increasing
    the immutability of our code as much as possible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are probably wondering whether you have to completely rethink the way
    you write programs. Should you forget all that you learned about OOP? Well, not
    really, and let's see why.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: OOP versus functional design styles
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important part of my job is to work with programmers and help them to improve
    the way they write code. To do so, I try my best to come up with simple explanations
    for complex ideas. I have one such explanation for software design. Software design
    is, for me, the way we structure the code such that we optimize it for business
    purposes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'I like this definition because it''s plain and short. But one thing bugged
    me after I started experimenting with functional constructs; that is, functional
    programming leads to code such as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Writing similar code in OOP style would most likely mean creating classes and
    using inheritance. So, which style is better? Additionally, if software design
    is about code structure, is there an equivalence between the two styles?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at what the two design styles really promote. What
    is OOP? For many years, I believed all the books that listed the following three
    properties of object-oriented languages:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alan Kay, the thinker behind OOP, does not really agree with this list. For
    him, OOP is about communication between many small objects. As a biology major,
    he saw an opportunity to organize programs like the body organizes cells, and
    to allow objects to communicate much like cells do. He places more importance
    on objects over classes, and on communication over the commonly listed OOP properties.
    I would best summarize his position as follows: the dynamic relations in the system
    are more important than its static properties.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: This changes a lot about the OOP paradigm. So, should classes match the real
    world? Not really. They should be optimized for the representation of the real
    world. Should we focus on having clear, well-thought out class hierarchies? No,
    since those are less important than the communication between objects. What is
    the smallest object that we can think of? Well, either a combination of data,
    or a function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In a recent answer on Quora ([https://www.quora.com/Isnt-getting-rid-of-the-evil-state-like-Haskells-approach-something-every-programmer-should-follow/answer/Alan-Kay-11](https://www.quora.com/Isnt-getting-rid-of-the-evil-state-like-Haskells-approach-something-every-programmer-should-follow/answer/Alan-Kay-11)),
    Alan Kay stated an interesting idea when answering a question on functional programming.
    Functional programming came from mathematics and from an effort to model the real
    world in order to enable artificial intelligence. This effort hit the following
    problem—*Alex is in Bucharest* and *Alex is in London* can both be true, but at
    different points in time. The solution to this modeling issue is immutability;
    that is, time becomes a parameter to functions, or a data member in the data structures.
    In any program, we can model data changes as time-bound versions of the data.
    Nothing stops us from modeling the data as small objects, and the changes as functions.
    Additionally, as we will see later, we can easily turn functions into objects
    and vice versa.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize, there's no real tension between OOP as Alan Kay meant it and
    functional programming. We can use them together and interchangeably, as long
    as we focus on increasing the immutability of our code, and on small objects that
    communicate with one another. We'll discover, in the following chapters, how easy
    it is to replace a class with functions and vice versa.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: But there are many ways to use OOP that are different from Alan Kay's vision.
    I've seen a lot of C++ code with my clients, and I've seen it all—big functions,
    huge classes, and deep inheritance hierarchies. Most of the time, the reason I'm
    called is because the design is too hard to change and because adding new features
    slows down to a crawl. Inheritance is a very strong relationship and overusing
    it leads to strong coupling, and, therefore, to code that's difficult to change.
    Long methods and long classes are harder to understand and harder to change. Of
    course, there are situations when inheritance and long classes make sense, but,
    in general, going for small objects with loose coupling enables changeability.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: But classes can be reused, can't they? Can we do that with functions? Let's
    visit this topic next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Composability and removing duplication
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen an example of where we had a fair amount of duplication:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We managed to reduce it using functions, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It''s interesting to see how the functions are composed in various ways; we
    have `sum(filter())` called twice, and `sum()` called once. Moreover, `filter`
    can be used with multiple predicates. Additionally, with a bit of work, we can
    make both `filter` and `sum` polymorphic functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It's now easy to call `filter` and `sum` with arguments of type other than `vector<int>`.
    The implementation is not perfect, but it illustrates the point that I'm trying
    to make, that is, small, immutable functions can easy become polymorphic and composable.
    This works especially well when we can pass functions to other functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易使用除了`vector<int>`之外的类型的参数调用`filter`和`sum`。实现并不完美，但它说明了我试图表达的观点，即小的不可变函数可以轻松变成多态和可组合的。当我们可以将函数传递给其他函数时，这种方法特别有效。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've already covered a lot of interesting topics! You've just realized that
    you know the basics of functional programming. You can write immutable functions
    in C++ with the help of the `const` keyword. You've already used high-level functions
    from STL. Additionally, you don't have to forget anything about OOP, but, instead,
    just see it from a different perspective. Finally, we discovered how small immutable
    functions can be composed to offer complex functionality, and how they can become
    polymorphic with the help of C++ templates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了很多有趣的话题！你刚刚意识到你已经掌握了函数式编程的基础知识。你可以使用`const`关键字在C++中编写不可变函数。你已经在STL中使用了高级函数。此外，你不必忘记面向对象编程的任何内容，而是从不同的角度来看待它。最后，我们发现了小的不可变函数如何组合以提供复杂的功能，并且如何借助C++模板实现多态。
- en: It's now time to take an in-depth look at the building blocks of functional
    programming and learn how to use them in C++. This includes pure functions, lambdas,
    and operations with functions such as functional composition, currying, or partial
    functional application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解函数式编程的构建模块，并学习如何在C++中使用它们了。这包括纯函数、lambda表达式，以及与函数相关的操作，如函数组合、柯里化或部分函数应用。
- en: Questions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an immutable function?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是不可变函数？
- en: How do you write an immutable function?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写不可变函数？
- en: How do immutable functions support code simplicity?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可变函数如何支持代码简洁性？
- en: How do immutable functions support simple design?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可变函数如何支持简单设计？
- en: What is a high-level function?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是高级函数？
- en: What example of high-level function can you give from STL?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能从STL中举一个高级函数的例子吗？
- en: What are the advantages of functional loops over structured loops? What are
    the potential disadvantages?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式循环相对于结构化循环有哪些优势？可能的缺点是什么？
- en: What is OOP from the perspective of Alan Kay? How does it relate to functional
    programming?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Alan Kay的角度来看，面向对象编程是什么？它如何与函数式编程相关？
