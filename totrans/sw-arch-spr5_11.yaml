- en: DevOps and Release Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is an important technique that helps teams to prevent their work from
    becoming isolated. It also helps remove boring processes and unnecessary bureaucracy
    throughout the whole software development cycle. This technique is used throughout
    the whole software development process, from writing code to deploying applications
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will demonstrate how to achieve these goals by embracing automation
    in order to reduce the number of manual tasks and deploy applications using automated
    pipelines in charge of validating written code, provisioning infrastructure, and
    deploying the required artifacts into a production environment. In this chapter,
    we will review the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Silos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps culture motivations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure as code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying DevOps practices using Spring Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release management pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some years ago, the software industry used the waterfall model to manage the
    **systems development lifecycle** (**SDLC**). The waterfall model includes many
    phases, such as gathering requirements, designing a solution, writing the code,
    verifying that the code meets the user requirements, and finally, delivering the
    product. In order to work on each of these phases, different teams and roles were
    created, including analysts, developers, software architects, QA teams, operations
    people, project managers, and so on. Each one of these roles were responsible
    for producing output and delivering it to the next team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps needed to create a software system using the waterfall model are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Analysts gather the software requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software architects review the requirements carefully and expand the documents
    with information about the tools and technologies that will be used, modules that
    have to be written to create the system, diagrams showing how the components are
    going to be connected in order to work as a whole, and so on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developers follow the directions issued by the architects and code the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QAs have to validate if the created software works as expected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operations team deploys the software
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you might notice from these steps, at each stage, a different team is producing
    a well-defined output that is delivered to the next team creating a chain. This
    process perfectly describes how teams work using a silo mentality.
  prefs: []
  type: TYPE_NORMAL
- en: This software production process seems good at first glance. However, this approach
    has several disadvantages. Firstly, it is impossible to produce perfect output
    in each phase, and incomplete artifacts are often produced. As a result, teams
    and departments that are concentrated on their own processes begin to pay less
    attention to what everyone else in the organization does. If a member of a team
    feels less responsible for the problems that occur within another team, a wall
    of conflict arises in this area because each team works separately with several
    barriers between them, causing issues such as communication breakdowns, thereby
    disrupting the free and fluent flow of information.
  prefs: []
  type: TYPE_NORMAL
- en: How to break silos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at how teams are organized to produce output.
    It's pretty self-evident that each team member by and large has the same skills
    as their fellow team members. As a consequence, it's impossible to ask a team
    of analysts to write code for a certain functionality or provision the infrastructure
    to deploy the application into production.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to breaking silos is creating multidisciplinary teams. This means
    that a team should have members with different skills that will help the team
    approach different problems and needs.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, each team member should have all the necessary skills to approach any
    kind of need. However, this goal is almost impossible to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a multidisciplinary team, you can easily end up having people
    working using a silo style within the same team. In order to solve this problem,
    you need to define a plan to make each member incorporate more skills as part
    of their portfolio. For example, you can make a developer work with a QA expert
    using the pair programming technique. In this way, the developer will learn how
    the QA expert thinks, and the QA will acquire development skills.
  prefs: []
  type: TYPE_NORMAL
- en: Multidisciplinary teams create an environment of collaboration across all stages
    of the SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps culture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There a lot of definitions for DevOps. We are going to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"DevOps is a culture that encourages operation and development teams to work
    together without taking away from the specific skills and responsibilities that
    each team has."'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the software development team takes the responsibility and ownership
    of the code they produce. DevOps changes the way that people are organized and
    the processes they follow across the SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: 'This culture removes silos because it requires all roles to become involved
    in the SDLC and to work together, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b318270d-09d7-4d05-a27b-9ed23091466c.png)'
  prefs: []
  type: TYPE_IMG
- en: Breaking the silos in an organization
  prefs: []
  type: TYPE_NORMAL
- en: Motivations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the motivation for adopting DevOps, let's look at a common real-life
    scenario that is often encountered in companies and organizations that develop
    software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are working at a company that hasn''t yet adopted DevOps or practices
    for **continuous integration** (**CI**) and **continuous deployment** (**CD**) in
    the software development process. Let''s imagine that this company has the following
    teams that are responsible for releasing a feature or a new piece of software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development team:** This team writes and commits code to a source version
    control system using branches that represent new features or bug fixes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations team:** This team installs the artifacts in the different environments—for
    example, through testing and production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QA team:** This team validates that the produced artifact works as expected
    from an end-user and technical perspective, and it approves or rejects the produced
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This process is repeated each time that features and bug fixes are released
    by developers. When first going through this common process, we realize that there
    are several problems, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Different environments:** The environment in which the code is developed
    often has a different environment and configuration to the staging and production
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication:** Forming a multidisciplinary team based on DevOps practices
    is going to help us break silos in organizations. Otherwise, lack of communication
    between teams is solved via meetings, conference calls, and/or emails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different behavior:** The number of bugs produced in a production environment
    varies in comparison to those produced in a development environment. There are
    also cases where bugs can''t be reproduced at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see, there are several problems that we need to solve here. Let''s
    look at how to approach each one of the aforementioned problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Different environments**: With infrastructure-as-code practices, we can create
    files that are going to enable each environment to work with immutable servers,
    which is a concept that we are going to look at in a future section about infrastructure
    as code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: Forming a multidisciplinary team based on DevOps practices
    is going to help us to break up silos in the organization in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different behavior**: Using an infrastructure as code approach, we will be
    able to create immutable servers, guaranteeing the same behavior in different
    environments (such as development, test, and production).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to market**: Applying **continuous delivery** (**CD**), allows us to
    deploy new features to production as quickly as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these are common problems in real-life scenarios, which is why several
    organizations are adopting DevOps. This starts by breaking the silos, which has
    several advantages to development teams. For example, it allows them to deploy
    as soon as possible with fewer errors. It also allows them to react quickly to
    change, making the process more productive. As a result of this, I encourage your
    organization to break silos and become agile in order to produce higher quality
    applications fast.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps adoption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adoption of DevOps suits organizations' need to release applications faster,
    minimizing the bugs and risks associated with delivering software to production.
    As part of this process, we need to increase the number of automated processes
    for testing an application, and it's highly recommended that we remove manual
    processes to avoid human interaction, which can lead us to create errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of such processes that could be automated are the environment configuration
    and deployment processes. Let''s look at the improvements to the SDLC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a4f4bff-9659-4f32-9ef2-29dda3582059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Waterfall method versus agile method and DevOps
  prefs: []
  type: TYPE_NORMAL
- en: However, there are several problems that we must handle in order to deliver
    software faster. First of all, we need to embrace a culture of automation. A culture
    of automation forces us to use many tools that we are going to introduce in the
    next section, and we need to understand that DevOps has become an essential part
    of our process because of the rise of microservices with more complex and distributed
    systems. However, don't forget that the *main goal of DevOps is collaboration,
    not just automation*.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embracing automation is one of the key factors in the adoption of DevOps. There
    are several tools that will help us with this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find tools that help us to automate the process in all stages throughout
    the SDLC. These phases are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fe552c5-3b23-44a3-a440-01ddb919becd.png)'
  prefs: []
  type: TYPE_IMG
- en: Pipeline in the organization
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an organization, a pipeline is designed to keep the software delivery
    process simple. The first step is to identify the different stages, as we did
    in the preceding diagram, and then we should choose the right tools that will
    allow us to automate each stage. Let''s review the stages and tools/software associated
    with each stage:'
  prefs: []
  type: TYPE_NORMAL
- en: Code (Git, SVN, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build (Maven, Gradle, npm, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation. This could also include integration testing (JUnit, Postman,
    Newman, JFrog, Selenium, Cucumber, Gherkin, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment (Ansible, Vagrant, Docker, Chef, Puppet, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring (we are going to talk in depth about monitoring in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml),
    *Monitoring*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration and continuous deployment (Jenkins, Hudson, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code analysis (Sonatype, Jacoco, PMD, FindBugs, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learned in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml), *Containerizing
    Your Applications*, we know how to provide environments based on containers, and
    we need to understand that the examples that we created can also be applied to
    the concept of infrastructure as code, which we are going to look at in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure as code refers to the process of creating files along with environment
    definitions and procedures that are going to be used to provision an environment.
    The DevOps concept started to use these scripts or files in a repository together
    with the code so that we can determine what code is going to be deployed in which
    environment. Using these practices, we can be sure that all servers and environments
    are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: A typical organization or team will deploy their application in more than one
    environment, mainly for testing purposes. When we have environments for development,
    staging, and production, the biggest problem developers face is that each environment
    is different and requires different properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties may include the following configurations, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Server names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP addresses and port numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server queue connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modern era of software development suddenly brought us testability, repeatability,
    and transparency in building infrastructures. One of the key goals nowadays is
    to recreate or build complete software environments with nothing other than physical
    server resources within an on-premise or cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of this, we should be able to create database instances, populate
    them with initial data from scripts or backup files, and rebuild our source code
    to create artifacts that can be deployed whenever we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many tools that we can use to apply the concept of infrastructure
    as code:'
  prefs: []
  type: TYPE_NORMAL
- en: For configuration synchronization, we can use Chef, Puppet, or Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For containerized servers, we can use Docker to deploy new application versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the key benefits that we are going to embrace are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Immutable servers*, which apply changes by rebuilding servers in our infrastructure
    instead of modifying the existing servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The testing of *changes to the infrastructure, which involves reproducing
    the environment with files that we can test in different stages of our application
    and infrastructure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the main idea behind these two key benefits to
    recreate environments at each stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75d805ec-7501-480a-bf5f-5f623c339570.png)'
  prefs: []
  type: TYPE_IMG
- en: Immutable infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: 'An automated process to provision servers gives, us the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to recreate any environment or server automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files can store credentials or custom configurations that can
    be different for each environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment will always be the same at different stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we are going to create some examples of infrastructure
    as code.
  prefs: []
  type: TYPE_NORMAL
- en: Spring application and DevOps practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides out-of-the-box features aligned to DevOps principles. Let's
    look at some of these.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we are going to create a new Spring Boot application using the
    Spring Initializr available at [https://start.spring.io](https://start.spring.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scenario in the delivery of an application is that we code the application
    on a development environment (almost always our own computer) and then the application
    is deployed in different test and production environments. Spring configuration
    files allow us to use different configurations on each environment. We can use
    a local configuration file as part of an application and then later, we can override
    those configuration values using environment variables. This is commonly needed
    because we use different credentials and configurations for each environment of
    our deployment configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating different Spring configuration files for each of the different
    environments that we need to deploy our application on, we are going to add an
    `index.html` static page behind the `/main/resources/static` folder with the following
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the next steps, we are going to show some features that Spring offers in
    favor of DevOps. We are also going to complete an exercise in which we provide
    Docker containers with layers that will be configured to support different environments,
    such as development, testing, and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a different profile for our application. For
    example, we can create different configuration files for development, testing,
    and production, using three files named `application-dev.properties`, `application-test.properties` and `application-production.properties` in
    the `/infra-as-code/src/main/resources` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a1858d4-9302-4b3c-a3bc-f8cd6bc3782e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to see how Spring Profiles work, we are going to change the port that
    our application is using. The property that is used to configure the port is `server.port`.
    Let''s change this value for each one of the different files we have, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application-dev.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`application-test.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`application-production.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Selecting profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before running an application supporting different profiles, you will need
    to select the desired profile to use the configuration needed. A profile can be
    selected using the `spring.profiles.active` flag using the JVM parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can check the application in the browser using the port associated
    with the profile provided. Valid values for the `spring.profiles.active` flag
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`production`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't provide any value for the flag, then the configurations from `application.properties`
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of exploring profiles in Spring. Remember that with
    profiles, we can also configure datasources, queues, beans, and anything you need.
    You can always override any of the provided configuration variables using environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, as we saw in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml),
    *Containerizing Your Applications*, we are able to dockerize a Spring Boot application,
    and with this knowledge, we can learn about immutable servers and how to test
    infrastructure changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to learn a similar way to recreate the infrastructure
    using Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/)) version
    1.7.0 or later. This may require virtualization software (for example, VirtualBox:
    [https://www.virtualbox.org/](https://www.virtualbox.org/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that can perform the same task is Ansible ([http://ansible.com/](http://ansible.com/)),
    which is not covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is a tool that is designed to recreate virtual environments that are
    primarily intended for development. The functionality is based on VirtualBox,
    and it can use provisioning tools such as Chef, Salt, or Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: It also makes it possible to work with different providers, such as Amazon EC2,
    DigitalOcean, VMware, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant uses a configuration file named `Vagrantfile`, which contains all the
    configurations needed to provision the desired environment. Once the aforementioned
    configuration file is created, the `vagrant up` command is used to install and
    configure the environment using the provided instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant has to be installed on the machine before we continue. To do this, follow
    the tool's documentation available at [https://www.vagrantup.com/intro/getting-started/install.html](https://www.vagrantup.com/intro/getting-started/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: Working with Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to create a `Vagrantfile` configuration file in the root
    of our application to create a simple environment. We will provide a Linux distribution
    environment, which will be Ubuntu. The content of the `Vagrantfile` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to line 6 of `Vagrantfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are creating our Linux environment from an already built VM box from `hashicorp/precise32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing with the provision of the environment using Vagrant, we are
    going to create an `ssh` file that will install JDK 8 for us. At the root of the
    project, create an `entrypoint.sh` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to create the box and provision the VM, we are going to run the following
    on the Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On the first attempt, it will take some minutes to download the box and provision
    the server. Between these processes, you will be asked which network interface
    you will use to provision your server with the question *Which interface should
    the network bridge to?*. You can then choose what is more convenient for your
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the whole output of our execution, we will see our Spring application
    running on the provisioned server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8364ec2-ae89-485e-84c2-8cbb275367e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can check our application is running on port `8090` (`http://localhost:8090/`)
    in the browser. You can check the Java process running inside Vagrant by accessing
    `ssh` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open an `ssh` session on our provision server, allowing us to see
    the process already created in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the result will be our running Java process, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1622befd-b408-4574-bc6f-0e3a0b47e948.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To stop the VM, we can use the `vagrant halt` command in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To destroy the created VM you can enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We just learned to express our infrastructure as code using Vagrant. We can
    create an environment or server needed for the different stages using different
    tools; we can review this in the previous chapter. In the next section, we are
    going to create an example of the process of release management.
  prefs: []
  type: TYPE_NORMAL
- en: Release management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To bring your code to production, the process must be planned out.
  prefs: []
  type: TYPE_NORMAL
- en: This process of planning is called **release management**. Throughout this process,
    we need to take care of the integrity and consistency of the existing services,
    guaranteeing the operation of our systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the steps involved in the release management process, we are
    going to look at the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery and continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipeline is a sequence of steps that we must go through to accomplish a goal.
    We looked at this concept in [Chapter 7](c5c3f9e5-157a-4f24-bebf-fb42488ee995.xhtml), *Pipe-and-Filter
    Architectures*. The same concept in this context is used to execute a sequence
    of steps in our release management process. A pipeline will assist us during the software delivery
    process in different environments. We are going to create a simple pipeline that
    consists of five stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically building our projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests (such as unit and integration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to staging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running an acceptance test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to production (this includes deploying our application in a cloud
    or on-premise server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how the pipeline will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd11eede-1f3b-41a6-8d9b-cd6c0aa27780.png)'
  prefs: []
  type: TYPE_IMG
- en: Pipeline CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: Each stage could have one or more tasks or jobs, such as creating a database
    schema, provisioning a box with Vagrant, cloning a Docker container, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous diagram is divided into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few sections, we are going to briefly look at these two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration (CI) refers to the practice in which developers merge
    their produced code into the main branch as often as possible. The merged code
    should work without bugs and it should also provide value for the business.
  prefs: []
  type: TYPE_NORMAL
- en: Using CI, we can automatically validate the committed code by running a set
    of automated tests. When we are using this practice, we are working on a CI codebase,
    avoiding the problems that arose in the past when scheduling a specific date and
    time to release a build.
  prefs: []
  type: TYPE_NORMAL
- en: With the CI approach, the most important goal is to automate the test to guarantee
    that the application is not broken any time the new commits are pushed into the
    main source code branch.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery and continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD is a process based on CI. As part of the CD process, we need other steps
    that are required to deploy the application to a production environment including
    tasks such as configuring and provisioning servers (infrastructure as code), acceptance
    testing, and preparing the build for a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: A continuous deployment process differs from a continuous delivery process when
    deploying in a production environment without *human* intervention.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to create an example based on our simple pipeline. To focus
    on the processes of CI and CD, we are going to use the project that we created
    in the last chapter's *Docker Compose* section that showed you how to containerize
    your application. This project includes a complete environment that is ready to
    use, and which already includes an automated test.
  prefs: []
  type: TYPE_NORMAL
- en: Automating pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously explained, we are going to need several tools to automate our
    pipeline for our example. For this, we are going to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A GitHub repository for our code: We can push our code to a repository and
    create a merge that automatically launches the build and test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle or Maven to build our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Junit, Postman, and Newman to test the automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker to deploy into containersJenkins to act as our automation server for
    CI and CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we are going to push our code to a repository. To do this, we are going
    to use GitHub. Create an account if you haven't already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and go to the root folder of our application. For our convenience,
    we are going to push the repository from our machine, so we are going to initialize
    our project as a repository. In the command line, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are going to add all our files to a new local repository, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to commit our code locally, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of our local commit will print the following initial lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To push our code, we then need to create a repository in our GitHub account.
    We can create a new repository by going to the Repositories section, clicking
    on the green Create Repository button, and filling in the name and description of
    the repository, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f922b3-48dd-446f-b3b3-94c9c9c828fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the URL of our repository—for example, `https://github.com/$YOUR_GITHUB_USER/bank-app`. The
    result of the repository that we created will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3ab7ef0-b637-4810-9d47-122653be156d.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the instructions given in GitHub, we now need to push our code to the
    repository using the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will push our changes from the local repository to our GitHub repository,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now we can review our code on our GitHub account repository and, as recommended,
    add a `README` file to explain the purpose of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to look at the concept of a CI server before
    continuing with our exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jenkins is a continuous integration server that is in charge of automating
    our pipeline. Before integrating with our Git repository to build our application
    automatically, let''s review the key concepts behind the CI server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipeline**: A pipeline consist of a set of sequential steps that will occur
    in the order in which they are arranged. The pipeline is also where we can parallelize
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job**: This is a small unit of work, such as *run test* or *pull our code*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue**: This represents all queuing jobs that the CI server will run when
    there is the capacity to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin**: These are the features that we can add to our CI server. For example,
    we can use one plugin to connect to our Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master/slave**: The master is the host that can delegate work to a slave
    client machine to scale our CI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins has different methods of distribution. We can see more details about
    this project at [https://jenkins.io/download/](https://jenkins.io/download/).
    For our example, we are going to use a Docker image that is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already have Docker installed, we can pull the Jenkins image in the command
    line by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see our image by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to run our Jenkins master from our container by running the
    following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the output of the console with the generated administrator
    password, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bc7e400-605d-4b1f-b498-ac8854682b17.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating the Jenkins password
  prefs: []
  type: TYPE_NORMAL
- en: We can now see our Jenkins server is running using `http://localhost:8080/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to paste the administrator password that we have just seen
    on the console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0dec531-f445-4ed3-bd75-ab2a4db0e90a.png)'
  prefs: []
  type: TYPE_IMG
- en: Unlocking Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to install the suggested plugins, which is going to take a
    while. Then we will continue the process by creating an admin user and URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to enable build triggering, so we are going to configure our Jenkins
    instance for receiving push notifications from GitHub. To do this, go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Jenkins home page (`http://localhost:8080`) and then click on the
    **New item** icon in the left menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the name of the project and select Freestyle project. After doing this,
    click on the OK button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e7d5c71-1915-4f60-80cd-a6b7fc4b9a15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Jenkins will show a page where the job steps should be configured. First, enter
    a description for the project and GitHub URL repository created as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e925304f-0205-4859-b0a5-4255442a3256.png)'
  prefs: []
  type: TYPE_IMG
- en: '4. Enter the credentials of your user account for GitHub, as is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d984098f-7203-45ca-8097-944a3e164645.png)'
  prefs: []
  type: TYPE_IMG
- en: '5\. Finally, at the end of the page select Gradle as the build tool for the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71fd61b3-d798-47d6-9762-730393860b23.png)'
  prefs: []
  type: TYPE_IMG
- en: The job created can be configured to be triggered every time we commit code
    to GitHub. The job will download the code, run tests, and generate the deployable
    artifact (JAR file) using Gradle. You can add additional steps in this job to build,
    tag, and push Docker images in Docker Hub and later deploy it automatically on
    an on-premise or cloud-based server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have familiarized ourselves with the meaning of a DevOps
    culture and how it affects the processes of an organization. We also looked at
    how to automate the instrumentation process of servers, using techniques such
    as infrastructure as code to embrace automation. Furthermore, we learned how to
    build pipelines that are capable of getting the latest implemented features from
    a repository, validating the code, running tests on different levels, and bringing
    the application to production. In the next chapter, we will look at the concerns
    surrounding the monitoring of applications, looking at why it is so important
    to care for them.
  prefs: []
  type: TYPE_NORMAL
