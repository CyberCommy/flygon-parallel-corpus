- en: Exploring Type Erasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn what type erasure (also known as type erasing)
    is as well as how to use it in your own applications. This chapter is important
    because type erasing provides the ability to work with objects of different types
    without the need for the object to share a common base class.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with a simple explanation of type erasure by explaining
    how type erasure works in the C language as well as how to perform type erasure
    in C++ using inheritance. The next recipe will provide a different approach to
    type erasure using C++ templates, which will teach you how C++ concepts are used
    to define a type's specifications instead of the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will walk through the classic C++ type erasure pattern. This recipe
    will teach you the skills to erase type information, providing the ability to
    create type-safe, generic code. Finally, we will conclude with a comprehensive
    example of using type erasure to implement the delegate pattern, which is a pattern
    that provides the ability to wrap callable objects of any type and is used heavily
    by languages such as ObjC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to erase a type with inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++ templates to write generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the C++ type eraser pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the delegate pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter09](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: How to erase a type with inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to erase types using inheritance. When type
    erasing is discussed, inheritance is not usually considered, but in reality, it
    is the most common form of type erasing used in C++. This recipe is important
    because it will discuss what type erasing is and why it is so useful in everyday
    applications without simply removing type information—a practice that is common
    in C.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try this recipe with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to lessons being taught in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type erasure (or type erasing) is simply the act of removing, hiding, or reducing
    type information about an object, function, and so on. In the C language, type
    erasure is used all the time. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create an array of `10` elements, and then we
    use the `memset()` function to clear the array to all zeros. The `memset()` function
    in C looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the first parameter the `memset()` function
    takes is `void*`. The array in our preceding example, however, is an array of
    integers. The `memset()` function doesn't actually care what type you provide,
    so long as you provide a pointer to the type and a size that represents the total
    size of the type in bytes. The `memset()` function then proceeds to type cast
    the provided pointer to a type that represents a byte (in C, this is usually `char` or
    unsigned `char`), and then sets the value of the type, byte by byte.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `void*` in C is a form of type erasure. This type (pun intended)
    of erasure in C++ is typically discouraged as the only way to get the type information
    back is to use `dynamic_cast()`, which is slow (it requires a runtime type information
    lookup). Although there are many ways to perform type erasure in C++ without the
    need for a `void *`, let's focus on inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is not generally described as type erasure in most literature, but
    it is likely the most widely used form of it. To better explore how this works,
    let's look at a common example. Suppose we are creating a game with multiple superheroes
    the user can choose from. Each superhero at some point has to attack the bad guy,
    but how the superhero attacks the bad guy varies from hero to hero.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, our first hero doesn''t care whether
    the bad guy is on the ground or in the air (that is, the hero will successfully
    hit the bad guy regardless of the bad guy''s vertical distance), but will miss
    the bad guy if they are not in a specific horizontal position. Likewise, we might
    also have another hero as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second hero is the complete opposite of our first. This hero can successfully
    hit the bad guy anywhere on the ground but will miss if the bad guys is anywhere
    above the ground (the hero probably cannot reach them).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, both superheroes are fighting the bad guy at the
    same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although we could call each superhero one at a time during the fight, it would
    be a lot more convenient if we could just loop through each hero in the fight
    and check to see which hero hits the bad guy versus which hero misses the bad
    guy.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have a hypothetical array of heroes that we loop
    through, checking to see which hero hits versus which hero misses. In this example,
    we don't care about the hero's type (that is, we don't care whether the hero is
    specifically our first or second hero), we simply care that each hero is actually
    a hero (and not an inanimate object) and that the hero is capable of attacking
    the bad guy. In other words, we need a way to erase each superhero's type so that
    we can put both heroes into a single array (which is not possible unless each
    hero is the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably have already guessed, the most common way to accomplish this
    in C++ is to use inheritance (but as we will show later on in this chapter, it
    is not the only way). To start, we must first define a base class called `hero`,
    which each hero will inherit from, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the only common function between each hero is that they both
    can attack the bad guy, the `attack()` function is the same for all heroes. As
    a result, we have created a pure virtual base class with a single pure virtual
    function called `attack()` that each hero must implement. It should also be noted
    that for a class to be pure virtual all member functions must be set to `0`, and
    the class's destructor must be explicitly labeled as `virtual`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined what a hero is, we can modify our heroes to inherit
    this pure virtual base class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, both heroes inherit from the pure virtual definition of a hero and
    override the `attack()` function as required. With this modification, we can now
    create our list of heroes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an array of `hero` pointers (using `std::unique_ptr` to store the
    lifetime of the hero, a topic that will be discussed in the next chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This array is then initialized to contain two heroes (one of each).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we loop through each hero to see whether the hero successfully attacks
    the bad guy or misses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `hero::attack()` function is called, the call is routed automatically
    to the correct `spiderman::attack()` and `captain_america::attack()` functions
    as needed through the use of inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The array is erasing the type information of each hero in a type-safe manner
    to place each hero into a single container.
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ templates to write generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to erase (or ignore) type information leveraging
    C++ templates. You will learn how C++ templates can be used to implement a C++
    concept and how this type of erasure is used in the C++ Standard Library. This
    recipe is important as it will teach you how to better design your APIs as specifications
    that do not rely on specific types (or, in other words, how to write generic code).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try this recipe with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the oldest and most widely used features of C++ is C++ templates. Like
    inheritance, C++ templates are not generally described as a form of type erasure,
    but they are. Type erasure is nothing more than the act of removing or, in this
    case, ignoring type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the C language, however, type erasure in C++ generally attempts to avoid
    removing type information in favor of working around a type''s strict definition
    while retaining type safety. One way to accomplish this is through the use of
    C++ templates. To better explain this, let''s start with a simple example of a
    C++ template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have created a simple function that calculates
    the power of two for any given input. For example, we can call this function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler sees the use of the `pow2()` function, it automatically generates
    the following code for you (behind the scenes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, the compiler creates two versions of
    the `pow2()` function: a version that takes an unsigned value and returns an unsigned
    one, and a version that takes an integer and returns an integer. The compiler
    created these two versions because the first time we used the `pow2()` function,
    we provided it with an unsigned value, while the second time we used the `pow2()`
    function, we provided it with `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: As far as our code is concerned, however, we don't actually care what type the
    function is provided, so long as the type that is provided can successfully execute
    `operator*()`. In other words, both the user of the `pow2()` function and the
    author of the `pow2()` function are safely ignoring (or erasing) the type information
    that is passed to and returned from the function from a conceptual point of view.
    The compiler, however, is very much aware of the types that are being provided
    and must safely handle each type as needed.
  prefs: []
  type: TYPE_NORMAL
- en: This form of type erasure performs the erasure at the specification of the API,
    and in C++, this specification is called a concept. Unlike most APIs that dictate
    both input and output types (for example, the `sleep()` function takes an unsigned
    integer and only an unsigned integer), a concept specifically ignores the type
    in favor of defining, instead, what properties a given type must provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the preceding `pow2()` function has the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The provided type must either be an integer type or provide an `operator *()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provided type must be either copy-constructible or move-constructible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the previous code snippet, the `pow2()` function doesn''t care
    what type it is given so long as the type provided meets certain minimum requirements.
    Let''s examine a more complicated example to demonstrate how C++ templates can
    be used as a form of type erasure. Suppose we have two different heroes that are
    fighting a bad guy, and each hero provides the ability to attack the bad guy,
    which is shown with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, each hero provides the ability to attack
    a bad guy, but neither hero shares anything in common other than the fact that
    both happen to provide an `attack()` function with the same function signature.
    We also do not have the ability to add inheritance to each hero (maybe our design
    cannot handle the extra `vTable` overhead that inheritance adds, or maybe the
    hero definition is provided to us).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose we have a complicated function that must call the `attack()` function
    for each hero. We could write the same logic for each hero (that is, manually
    duplicate the logic), or we could write a C++ template function to handle this
    for us, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we can leverage the type erasing properties
    of C++ templates to encapsulate our attack logic into a single template function.
    The preceding code doesn't care about what type it is provided so long as the
    type provides an `attack()` function that takes two integer types and returns
    an integer type (preferably `bool`, but any integer would work). In other words,
    so long as the type provided adheres to an agreed-upon concept, this template
    function will work, providing the compiler with a means to handle the type-specific
    logic for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70426f57-68a7-48bf-ac42-6ee95388297b.png)'
  prefs: []
  type: TYPE_IMG
- en: Although this example shows how C++ templates can be used as a form of type
    erasure (at least for a specification to create a concept), when type erasure
    is discussed, there is a specific pattern called the type erasure pattern or just
    type erasure. In the next recipe, we will explore how we can leverage what we
    have learned in the first two recipes to erase type information generically while
    still supporting simple things such as containers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we learned how concepts can be used to ignore (or erasing) type-specific
    knowledge in favor of requiring a type to implemented a minimum set of features.
    These features can be enforce using SFINAE, a topic we discussed in greater detail
    in [Chapter 4](aff3ffea-2bdd-4d69-9e32-0edae7142703.xhtml), *Using Templates for
    Generic Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 13](69ea92ce-8503-4c3f-95c7-9733bd86d039.xhtml), *Bonus – Using
    C++20 Features*, we will also discuss how the enforcement of a concept can be
    done using new features being added to C++20.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the C++ type eraser pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn what the type erasure pattern is in C++, and how
    we can leverage it to generically erase type information without sacrificing type-safety
    or requiring our types to inherit pure virtual base classes. This recipe is important
    as the type erasure pattern is used heavily in the C++ Standard Library and provides
    a simple way to encapsulate data types that do not share anything in common, other
    than providing a similar set of APIs, while still supporting things such as containers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try this recipe with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we typically think of C++ type erasure, this is the example we think of.
    The type erasure pattern is needed when we must leverage a set of objects as if
    they are related, that may or may not share a common base class (that is, they
    either do not use inheritance or if they do use inheritance, it is possible they
    do not inherit from the same set of classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, each class defines a different type
    of hero. We would like to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is, each class doesn''t inherit from a similar base class, so we
    cannot just create an instance of each class and add them to `std::array` as the
    compiler would complain about the classes not being the same. We could store a
    raw `void *` pointer of each class in `std::array`, but then when it comes time
    to use `void *`, we would have to `dynamic_cast()` back to each type to do anything
    useful, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The use of `void *` is a form of type erasure, but this is far from ideal as
    the use of `dynamic_cast()` is slow, each new type that we add would only increase
    the number of `if` statements, and this implementation is far from C++ Core Guideline
    compliant.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way, however, that we can address this problem. Suppose we
    wish to run the `attack()` function, which happens to be the same between each
    hero class (that is, each hero class at least adheres to a shared concept). If
    each class had used the following base class, we could just use inheritance, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is, our hero classes do not inherit from this base class. So, instead,
    let''s create a wrapper class that does, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we have created a template wrapper class
    that inherits from our base class. This wrapper stores an instance to whatever
    type it is given, and then overrides the `attack()` function that is defined in
    the pure virtual base class, which forwards a call to it, to the instance that
    the wrapper is storing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create our array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`std::array` stores `std::unique_ptr` to our base class, and then we create
    our wrapper class (which inherits the base class) with each type we need, to store
    in the array. The compiler creates a version of the wrapper for each type that
    we need to store in the array, and since the wrapper inherits the base class,
    no matter what type we give the wrapper, the array can always store the resulting
    wrapper as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from this array, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And there you have it: type erasure in C++. This pattern leverages C++ templates
    to give an object the same properties of inheritance even if the object doesn''t
    directly use inheritance itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing delegates with type erasing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement the delegate pattern, which is
    a pattern that has been around for years (and is heavily used by some other languages,
    such as ObjC). This recipe is important as it will teach you what a delegate is,
    and how to leverage this pattern in your own applications to provide better extensibility
    without requiring your APIs to use inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try this recipe with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have ever read a book on C++, you have likely seen the apples and oranges
    example, which demonstrates how object-oriented programming works. The idea goes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An apple is a fruit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An orange is a fruit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An apple is not an orange but both are fruit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example is meant to teach how to organize your code into logical objects
    using inheritance. A logic that is shared by both an apple and an orange is written
    into an object called `fruit` while logic that is specific to an apple or an orange
    is written into the `apple` or `orange` objects that inherit from the base `fruit`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: This example is also, however, showing how to extend the functionality of a
    fruit. By subclassing a fruit, I can create an apple that is capable of doing
    more than the `fruit` base class. This idea of *extending* the functionality of
    a class is common in C++, and oftentimes, we think of using inheritance to implement
    it. In this recipe, we will explore how to do this without the need for the apple
    or the orange to leverage inheritance with something called a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are creating a game, and you wish to implement a battlefield where
    heroes and bad guys are fighting. At some point in your code, each hero in the
    battle will need to attack the bad guys. The problem is heroes come and go within
    the fight as they need time to recover, and so you really need to maintain a list
    of heroes that are capable of attacking the bad guys, and you simply need to loop
    through this dynamically changing list of heroes to see whether their attacks
    succeed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Each hero could store a list of heroes that subclass a common base class and
    then run an `attack()` function that each hero overrides, but this would require
    the use of inheritance, which might not be desired. We could also use the type
    erasure pattern to wrap each hero and then store pointers to our wrapper's base
    class, but this would be specific to our `attack()` function, and we believe there
    will be other instances where these types of extensions will be needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the delegate pattern, which is an extension to the type erasure pattern.
    With the delegate pattern, we can write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we have defined an instance of two different
    classes that are not alike, and then we have created an array that stores three
    delegates. The delegate's template parameter takes a function signature of `bool(int,
    int)`, while the delegate itself appears to be created from a function pointer
    as well as two member function pointers from the class instances we created earlier.
    We are then able to loop through each of the delegates and call them, effectively
    calling the function pointer and each member function pointer independently.
  prefs: []
  type: TYPE_NORMAL
- en: The delegate pattern provides the ability to encapsulate different callable
    objects into a single object with a common type that is capable of calling the
    callable objects so long as they share the same function signature. More importantly,
    delegates can encapsulate both function pointers and member function pointers,
    providing the user of the API with the ability to store a private state if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain how this works, we will start simple and then build upon our example
    until we reach the final implementation. Let''s start with a base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we have created a template of a pure
    virtual base class. The template arguments are `RET` (which defines a return value)
    and `ARGS...` (which define a variadic list of arguments). We then create a function
    called `func()`, which takes our list of arguments and returns the template return
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define a wrapper that inherits from the base class using the type
    erasure pattern (if you have not read the previous recipe, please do so now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Just like the type eraser pattern, we have a wrapper class that stores an instance
    of our type and then provides a function that the wrapper can call. The difference
    is the function that can be called is not statically defined and instead is defined
    by the template arguments that are provided. Furthermore, we also store a function
    pointer with the same function signature, which is initialized by the wrapper's
    constructor and called in the `func()` function using `std::invoke`.
  prefs: []
  type: TYPE_NORMAL
- en: This additional logic, compared to the typical type erasure example, provides
    the ability to define any function signature that we wish to call from the object
    we are storing in the wrapper instead of defining it ahead of time (meaning the
    function we wish to call can be determined at runtime and not compile time).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create our delegate class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As with the type erasure pattern, we store a pointer to the wrapper, which is
    created from the constructor of the delegate. The important detail to recognize
    here is the `T` type is not defined in the delegate itself. Instead, the `T` type is
    only known during the construction of the delegate which is used to create an
    instantiation of the wrapper. This means that each instance of a delegate is the
    same, even if the delegate is storing a wrapper that wraps different types. This
    allows us to use the delegate as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have two heroes that do not share a common base, but do provide
    an `attack()` function with the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can leverage our delegate class to store an instance of our hero classes
    and call their attack functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36666375-3829-4923-ab93-fc4ef67966c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Although we have already made significant progress in creating our delegate
    (it at least works), there are a few issues with this early implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The delegate's signature is `bool, int, int`, which is misleading as we really
    want a function signature such as `bool(int, int)` so that the code is self-documenting
    (the delegate's type is a single function signature, not three different types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This delegate cannot handle functions marked `const`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to store an instance of the delegated object inside our wrapper, which
    prevents us from creating delegates to more than one function for the same object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not have support for non-member functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's address each of these.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a function signature to our delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although adding a function signature to our delegate as the template parameter
    can be done without the need for C++17, user-defined type deduction in C++17 makes
    this process simple. The following code snippet shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the user-defined type deduction tells
    the compiler how to take our delegate constructor and convert it into the template
    signature that we wish to use. Without this user-defined type deduction guide,
    the `delegate(RET(T::*)(ARGS...))` constructor would result in the delegate being
    deduced as `delegate<RET, ARGS...>`, which is not what we want. Instead, we would
    like the compiler to deduce `delegate<RET(ARGS...)>`. Nothing else about our delegate
    implementation needs to change. We simply need to tell the compiler how to perform
    type deduction.
  prefs: []
  type: TYPE_NORMAL
- en: Adding const support to our delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our delegate currently cannot take a member function marked as `const` as we
    have not provided our delegate with a wrapper capable of doing so. For example,
    our heroes'' `attack()` function currently looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We would, however, like our hero `attack()` functions to look like the following
    since they do not modify any private member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To support this change, we must create a wrapper that supports this, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, this wrapper is the same as our previous wrapper
    with the difference being that the function signature that we store has an added
    `const` instance. For the delegate to use this additional wrapper, we must also
    provide an additional delegate constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we will also need an additional user-defined type deduction guide,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With these modifications, we can now support member functions marked with `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for one-to-many to our delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our wrappers store an instance to each type. This approach is often
    used with type erasure, but in our case, it prevents the ability to create many
    delegates for the same object (that is, no support for one-to-many). To fix this,
    we will store a pointer to an object in our wrappers instead of the object itself,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the only change we have made is we store a pointer
    to the object we are wrapping instead of the object itself, which also means we
    need to initialize this pointer in our constructor. To use this new wrapper, we
    must modify our delegate constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This, in turn, means we must update our user-defined type deduction guides
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With these modifications, we can now create our delegates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, the delegate takes a pointer to each object, which
    means we can create as many of these delegates as we wish, including the ability
    to create delegates to other member function pointers if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for non-member functions to our delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need to modify the delegate to add support for non-member functions.
    Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, we simply need to add another wrapper as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, as with our original wrapper, we store a pointer
    to the function we wish to call, but in this case, we do not need to store a pointer
    to an object as there is no object (as this is a  non-member function wrapper).
    To use this new wrapper, we must add another delegate constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we must also provide another user-defined type deduction guide as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of the modifications, we are finally able to use our delegate as defined
    at the beginning of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59994462-e91d-48fa-bcaf-1538fa6e4e37.png)'
  prefs: []
  type: TYPE_IMG
- en: This delegate could further be extended to support lambda functions by adding
    yet another set of wrappers, and the need for `std::unique_pointer` in the delegate
    could be removed in favor of a placement new, using a small buffer the size of
    the member function wrapper (or, in other words, removing the dynamic memory allocation),
    which is sometimes referred to as a small size optimization.
  prefs: []
  type: TYPE_NORMAL
