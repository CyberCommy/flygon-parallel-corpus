- en: 9\. Connecting to Azure Event Hubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-based integration is a key pattern for implementing **microservices**.
    The idea of a microservices architecture is to decompose a monolithic application
    into a smaller set of services. Events are commonly used to coordinate between
    these different services. When you think about an event, it can be one of many
    things. Financial transactions can be an event, as well as IoT sensor data, web
    page clicks and views, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'A piece of software that is commonly used to handle these types of events is
    Apache Kafka (Kafka for short). **Kafka** was originally developed by LinkedIn,
    and later donated to the Apache Software Foundation. It is a popular open-source
    streaming platform. A streaming platform is a platform that has three core capabilities:
    publishing and subscribing a stream of messages (similar to a queue), storing
    these streams in a durable fashion, and processing these streams as they occur.'
  prefs: []
  type: TYPE_NORMAL
- en: Azure has a similar offer to Apache Kafka, called Azure Event Hubs. **Event
    Hubs** is a managed service that offers real-time data ingestion. It is simple
    to set up and use, and can scale dynamically. Event hub is also integrated with
    other Azure services, such as stream analytics, functions, and databricks. These
    prebuilt integrations make it easier for you to build applications that consume
    events from event hubs.
  prefs: []
  type: TYPE_NORMAL
- en: Event hubs also provide a Kafka endpoint. This means that you can configure
    your existing Kafka-based applications and point them to Event Hubs instead. The
    benefit of using Event Hubs for your Kafka applications is that you no longer
    have to manage your Kafka cluster because you consume it as a managed service.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement microservices on AKS and use
    Event Hubs for loosely coupled integration between applications. You will deploy
    an application that uses Kafka to send events, and you will replace your own Kafka
    cluster with Azure Event Hubs. As you will learn in this chapter, event-based
    integration is one of the key differentiators between monolithic and microservice-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a set of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Event Hubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start this chapter by deploying a set of microservices that builds a
    social network.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a set of microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be deploying a set of microservices from a demo application
    called social network. The application is composed of two main microservices:
    **users** and **friends**. The users service stores all the users in its own data
    store. A user is represented by an ID, and their first and last names. The friends
    service stores the user''s friends. A friend relationship links the user IDs of
    both friends, and also has its own ID.'
  prefs: []
  type: TYPE_NORMAL
- en: The events of adding a user/adding a friend are sent to a message queue. This
    application uses Kafka as the message queue to store events related to users,
    friends, and recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: This queue is consumed by a recommendation service. This service is backed by
    a **Neo4j** database that can then be used to query relationships between users.
    Neo4j is a popular graph database platform. A graph database is different from
    a typical relational database such as MySQL. A graph database is a database that
    is focused on storing the relationship between different elements. You can query
    a graph database with questions, such as *give me the common friends of user X
    and user Y*.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of data flow, you can create users and friendship relationships. Creating
    a user or a friendship relationship will generate a message on the message queue,
    which will result in the data being populated in the Neo4j database. The application
    doesn't have a web interface. You will mainly work with the application using
    the command line, although we can connect to the Neo4j database to verify that
    data was populated in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following section, you will learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Helm to deploy a sample microservice-based application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the service by sending events and watch objects being created and updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by deploying the application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application using Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will deploy the demo application using Helm. This will deploy
    the full application using a local Kafka instance. Once the application is deployed,
    we will generate a small social network and verify that we were able to create
    the social network.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has a lot of resource requirements. To meet them, scale your cluster
    to four nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of this example has been included in the GitHub repo for this book.
    You can find the code in the `social-network` folder under `Chapter09`. Navigate
    to this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Kafka, we also need to run **ZooKeeper**. ZooKeeper is another open-source
    software project by the Apache foundation. It provides naming, configuration management,
    synchronization, and the ability to group services. We will use Kafka and ZooKeeper
    Helm charts from `bitnami`, so let''s add the required Helm repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the output shown in *Figure 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output screen displays two Helm repositories,bitnami and incubator, being
    added to your repositories.](image/Figure_9.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Adding the Helm repositories'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s update the dependencies to make the dependent charts available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you something similar to *Figure 9.2* four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In order to make the dependent charts available, the output screen will display
    individual messages of successfully receiving an update from dependencies such
    as svc-cat, incubator, azure, jetstack, bitnami, and stable four times.](image/Figure_9.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Updating dependencies'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During this example, you might see a warning similar to the following: `walk.go:74:
    found symbolic link in path:`. This is a warning that can safely be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new `namespace` for this application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the kubectl create namespace social-network command, a new namespace
    is created.](image/Figure_9.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Creating a new namespace'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, go ahead and deploy the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the Pods in the deployment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in *Figure 9.4*, it takes about 5 minutes until all of the Pods
    are up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output showsa total of 20 Pods with a status of Running.](image/Figure_9.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Output displaying all of the Pods with a Running status'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When the application has been successfully deployed, you can connect to the
    edge service. To get its IP, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will generate an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![You can obtain the edge-service external IP using the kubectl get service
    -n social-network command.](image/Figure_9.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Getting the edge service external IP'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can do two tests to verify that the application is working correctly. Test
    1 is to connect the edge service on port `9000` in a browser. *Figure 9.6* displays
    the Whitelabel Error Page, showing that the application is running:![The Whitelabel
    Error Page will display a message that the application has no configured error
    view, so you are seeing this as a fallback. This indicates that the application
    is running.](image/Figure_9.6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.6: The Whitelabel Error Page, showing that the application is running'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second test to verify that the application is running, is to actually generate
    a small social network. This will verify that all services are working correctly.
    You can create this network using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will generate a lot of output. The output will start with the
    elements shown in *Figure 9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![While creating a new social network, the initial output screen will display
    the first name, the last name, the date and time it was created, the date and
    time it was last modified, and an ID.](image/Figure_9.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Initial output when creating a new social network'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It will take about a minute to generate a 15-person network. To verify that
    the network has been created successfully, browse to [`http://<external-ip>:9000/user/v1/users/1`](http://<external-ip>:9000/user/v1/users/1)
    in your web browser. This should show you a small JSON object that represents
    a user in the social network, as shown in *Figure 9.8*:![Upon the successful creation
    of the user in the user service, the output screen accessed on <external-ip>:9000/user/v1/users/1
    displays the first and the last name of the user, the date and time it was created,
    and the date and time it was last modified.](image/Figure_9.8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.8: Successful creation of the user in the user service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As a final validation, you can connect to the Neo4j database and visualize
    the social network you created. To be able to connect to Neo4j, you need to first
    expose it as a service. Use the `neo4j-service.yaml` file in the social network
    folder to expose it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get the service''s public IP address. This can take about a minute to
    be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will generate the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output displays the external IP address of the Neo4j service.](image/Figure_9.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Output displaying the external IP address of the Neo4j service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Please note that the external IP of the Neo4j service can differ from the external
    IP of the edge service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your browser to connect to [`http://<external-ip>:7474`](http://<external-ip>:7474).
    This will open a login screen. Use the following information to log in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Connect URL**: `bolt://<external-ip>:7678`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Username**: `neo4j`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: `neo4j`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your connection information should look similar to *Figure 9.10.*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![To log in to the Neo4j service, the user must enter bolt://<external-ip>:7687
    in the Connect URL field,set the username as neo4j, and set the password as neo4j.
    Then they need to click on the connect tab below the password field. This will
    help them log in to the browser.](image/Figure_9.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Logging in to the Neo4j browser'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once you're connected to the Neo4j browser, you can see the actual social network.
    Click on the **Database Information** icon, and then click on **User**. This will
    generate a query that will display the social network you just created. This will
    look similar to *Figure 9.11*:![The output screen of the social network is divided
    into two parts. The left section of the screen displays the Database Information
    such as Node Labels, Relationship Types, Property Keys, and the Database, while
    the remainder of the screen displays the names of User(14) and FRIEND(149). The
    output also contains a graph representation of the social network that was created.](image/Figure_9.11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.11: A view of the social network you just created'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the current example, we have set up the end-to-end application, using Kafka
    running on our Kubernetes cluster as a message queue. Let''s remove that example
    before we move on the next section. To delete the local deployment, use the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will move away from storing events in the cluster and
    store them in Azure Event Hubs. By leveraging native Kafka support on Azure Event
    Hubs and switching to using a more production-ready event store, we will see that
    the process is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Event Hubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running Kafka by yourself on a cluster is possible but can be hard to run for
    production usage. In this section, we will transfer the responsibility of maintaining
    a Kafka cluster to Azure Event Hubs. Event Hubs is a fully managed, real-time
    data ingestion service. It has native support for the Kafka protocol, so, with
    minor modifications, we can update our application from using a local Kafka instance
    to the scalable Azure Event Hubs instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the event hub via the portal and gather the required details to connect
    our microservice-based application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the Helm chart to use the newly created event hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating the event hub.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the event hub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will create the Azure event hub. We will use this event
    hub later to stream the new messages to. Perform the following steps to create
    the event hub:'
  prefs: []
  type: TYPE_NORMAL
- en: To create the event hub on the Azure portal, search for `event hub`, as shown
    in *Figure 9.12*:![In the search bar tab, the user needs to type "event hub" in
    order to create the event hub in the Azure portal.](image/Figure_9.12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.12: Looking for Event Hubs in the search bar'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on **Event Hubs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Event Hubs** tab, click on **Add**, as displayed in *Figure 9.13*:![To
    add a new event hub, the user needs to click on the +Add tab located towards the
    extreme left of the screen.](image/Figure_9.13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.13: Adding a new event hub'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Fill in the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name**: This name should be globally unique. Consider adding your initials
    to the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing tier**: Select the Standard pricing tier. The Basic pricing tier
    does not support Kafka.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Makes this namespace zone redundant**: Disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Subscription**: Select the same subscription as the one hosting your
    Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Group**: Select the resource group we created for the cluster, `rg-handsonaks`
    in our case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**: Select the same location as your cluster. In our case, this is
    `West US 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Throughput Unit**: 1 unit will suffice for this test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto-inflate**: Disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This should give you the create view similar to *Figure 9.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There are various fields that need to be filled in.The Pricing tier should
    be set to Standard, the Make this namespace zone redundant tab should be disabled,
    Throughput unit should be set to 1,the Auto-inflate tab should be disabled, and
    the Name,Subscription, Resource group, and Location fields need to filled in as
    well. At the bottom of these fields you''ll see the Create tab. This is whatthe
    creation of your event hub will look like.](image/Figure_9.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Your event hub creation should look like this'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Hit the **Create** button at the bottom of the wizard to create your event hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the event hub is created, select it, as shown in *Figure 9.15*:![Once the
    event hub is created, you will be directed to a window where you can view the
    event hub on the portal. You need to select it by clicking on your event hub's
    name.](image/Figure_9.15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.15: Clicking on the event hub name once it is created'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on **Shared access policies**, select **RootManageSharedAccessKey**, and
    copy the **Connection string-primary key**, as shown in *Figure 9.16*:![This screen
    shows the process of getting the connection string to the event hub. The first
    step is to click on Shared access policies in the left-hand menu.Step 2 is selecting
    the RootManageSharedAccessKey policy, and step 3 is clicking on the copy icon
    next to the primary connecting string.](image/Figure_9.16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.16: Copying the primary connection string'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using the Azure portal, we have created an event hub that can store and process
    our events as they are generated. We needed to gather the connection strings so
    that we can hook up our microservice-based application. In the next section, we
    will redeploy our social network and configure it to connect to Event Hubs. To
    be able to deploy our social network, we will have to make a couple of changes
    to the Helm charts, in order to point our application to Event Hubs rather than
    to Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Helm files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to switch the microservice deployment from using the local Kafka
    instance to using the Azure-hosted, Kafka-compatible Event Hubs instance. To make
    this change, we will modify the Helm charts to use Event Hubs rather than Kafka:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `values.yaml` file for the social network deployment to disable
    Kafka in the cluster and include the connection details to your event hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to change the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 5, 18, 26, and 34**: Change this to `enabled: false`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 20, 28, and 36**: Change this to your event hub''s name.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 21, 29, and 37:** Change this to your event hub''s connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our demo, we are storing the connection string in a Helm values file. This
    is not a best practice. For a production use case, you should store those values
    as a secret and reference them in your deployment. We will explore this in *Chapter
    10*, *Securing your AKS cluster*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the deployment as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for all the Pods to be up. You can verify that all Pods are up and running
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![14 Pods displayed on the screen show their status as Running.](image/Figure_9.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Output displaying Running status for all the Pods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To verify that you are connected to Event Hubs, and not to local Kafka, you
    can check the event hubs in the portal, and check the different topics. You should
    see a friend and a user topic, as shown in *Figure 9.18*:![When you scroll through
    the menu located on the left side of the screen, you'll see the Entities tab.
    Click on Event Hubs under it. You will see two topics created in your event hub.
    The names of these topics should read friend and user.](image/Figure_9.18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.18: Showing the two topics created in your event hub'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Keep watching the Pods. When all the Pods are up and running, get the external
    IP of the edge service. You can get that IP by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command to verify the creation of the actual social
    network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will again create a social network with 15 users, but will now use Event
    Hubs to send all the user-, friend-, and recommendation-related events.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that activity on the Azure portal. The Azure portal creates detailed
    monitoring graphs for Event Hubs. To access those, click on the **friend** event
    hub, as shown in *Figure 9.19*:![In the navigation pane located on the left side
    of the screen, scroll down to the Entities section. Click on the Event Hubs. You''ll
    see two topics: friend and user. Click on the friend topic to get more metrics.](image/Figure_9.19.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.19: Clicking on the friend topic to get more metrics'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In *Figure 9.20*, you can see that there are three graphs that the Azure portal
    provides you with out of the box: the number of requests, the number of messages,
    and the total throughput:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Azure portal displays three graphs for the topic. These high-level graphs
    provide the number of requests, the number of messages, and the total throughput.
    Each of these graphs has a blue icon at the bottom that indicates the incoming
    requests, the incoming messages, and the incoming bytes. You will also see an
    orange icon that indicates the Successful Requests, Outgoing messages and the
    Outgoing Bytes. The graphs in the picture show an upwards spike.](image/Figure_9.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: Display of the high-level graphs by default per topic'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can drill down further in the individual graphs. For example, click on
    the messages graph. This will bring you to an interactive graph editor in Azure
    monitor. You can see on a minute-by-minute basis how many messages were coming
    in and going out of your event hub, as shown in *Figure 9.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Upon clicking on the second graph,which indicates the number of messages,
    you will see more details.Apart from the blue and orange icons, you will also
    see indigo and teal icons that indicate the captured messages and Capture backlog
    (Sum) respectively.](image/Figure_9.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: Clicking on the graph to get more details'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s make sure to clean up the deployment we just created and scale our cluster
    back down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also delete the event hub in the Azure portal. To delete the Event
    Hub, go to the **Overview** page of the event hub and select the **Delete** button,
    as shown in *Figure 9.22*. You will be asked to repeat the event hub''s name to
    ensure that you don''t delete it accidentally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Click on Overview in the navigation pane located on the left side of the
    screen. You will see the details of the event hub you created. To delete this
    event hub, click on the Delete button located in the toolbar. This button is located
    to the left of the Refresh button.](image/Figure_9.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: Clicking the delete button to delete your event hub'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This concludes our example of using Event Hubs with the Azure Kubernetes Service.
    In this example, we reconfigured a Kafka application to use Azure Event Hubs instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we deployed a microservices-based application that connects
    to Kafka. We used Helm to deploy this sample application. We were able to test
    the application by sending events to a locally created Kafka cluster and watching
    objects being created and updated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered storing events in Azure Event Hubs using Kafka support,
    and we were able to gather the required details to connect our microservice-based
    application and modify the Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover cluster security. We will cover RBAC security, secret
    management, and network security using Istio.
  prefs: []
  type: TYPE_NORMAL
