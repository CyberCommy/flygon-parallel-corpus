- en: Exploring C++ Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索C++类型
- en: In the last two chapters, you have learned how to put together a C++ program,
    learned about the files you use, and the ways to control execution flow. This
    chapter is about the data that you will use in your program: the type of data
    and the variables that will hold that data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，您已经学会了如何组合C++程序，了解了您使用的文件以及控制执行流程的方法。本章是关于您将在程序中使用的数据：数据类型和将保存该数据的变量。
- en: A variable can handle data of a particular format and with a particular behavior,
    and that is determined by the type of the variable. The type of the variable determines
    the operations you can perform on the data and on the format of the data when
    inputted or viewed by the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以处理特定格式和特定行为的数据，这由变量的类型确定。变量的类型确定您可以对数据执行的操作以及用户输入或查看数据的格式。
- en: 'Essentially, you can view three general categories of types: built-in types,
    custom types, and pointers. Pointers in general will be covered in the next chapter,
    and custom types, or classes, and pointers to them, will be covered in [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*. This chapter will cover
    the types that are provided as part of the C++ language.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您可以查看三种一般类型：内置类型、自定义类型和指针。指针通常将在下一章中介绍，自定义类型或类以及指向它们的指针将在第6章《类》中介绍。本章将介绍作为C++语言一部分提供的类型。
- en: Exploring built-in types
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内置类型
- en: C++ provides integer, floating point, and Boolean types. The `char` type is
    an integer but it can be used to hold individual characters and so its data can
    be viewed as a number or as a character. The C++ Standard Library provides the
    `string` class to allow you to use and manipulate strings of characters. Strings
    will be covered in depth in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供整数、浮点和布尔类型。`char`类型是整数，但它可以用于保存单个字符，因此其数据可以被视为数字或字符。C++标准库提供了`string`类，允许您使用和操作字符串。字符串将在第9章《使用字符串》中深入介绍。
- en: As the name suggests, integer types contain integral values where there are
    no fractional parts. If you perform calculations with integers you should expect
    that any fractional parts will be discarded unless you take steps to retain them
    (for example, through the remainder operator `%`). Floating point types hold numbers
    that may have a fractional part; because floating point types can hold numbers
    in a mantissa exponent format, they can hold exceptionally large or exceptionally
    small numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，整数类型包含没有小数部分的整数值。如果使用整数进行计算，您应该期望任何小数部分都将被丢弃，除非您采取措施保留它们（例如，通过取余运算符`%`）。浮点类型保存可能具有小数部分的数字；因为浮点类型可以以尾数指数格式保存数字，所以它们可以保存异常大或异常小的数字。
- en: A variable is an instance of a type; it is the memory allocated to hold the
    data that the type can hold. Integer and floating point variable declarations
    can be modified to tell the compiler how much memory to allocate, and thus the
    limits of the data that the variable can hold and the precision of the calculations
    performed on the variable. In addition, you can also indicate if the variable
    will hold a number where the sign is important. If the number is being used to
    hold bitmaps (where the bits do not make up a number, but have a separate meaning
    of their own) then it usually makes no sense to use a signed type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是类型的实例；它是分配的内存，用于保存类型可以保存的数据。整数和浮点变量声明可以修改以告诉编译器分配多少内存，从而限制变量可以保存的数据和对变量执行的计算的精度。此外，您还可以指示变量是否将保存重要的符号数字。如果数字用于保存位图（其中位不组成数字，而具有自己的独立含义），则通常没有意义使用有符号类型。
- en: In some cases, you will be using C++ to unpack data from a file or a network
    stream so that you can manipulate it. In this case, you will need to know whether
    the data is a floating point or integral, signed or unsigned, how many bytes are
    used and what order those bytes will be in. The order of the bytes (whether the
    first byte in a multi-byte number is the low or high part of the number) is determined
    by the processor which you are compiling for, and in most cases, you will not
    need to worry about it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您将使用C++从文件或网络流中解压数据，以便对其进行操作。在这种情况下，您需要知道数据是浮点还是整数，有符号还是无符号，使用了多少字节以及这些字节的顺序。字节的顺序（多字节数字中的第一个字节是数字的低位还是高位）由您正在编译的处理器确定，在大多数情况下，您不需要担心它。
- en: Similarly, sometimes you may need to know about the size of a variable and how
    it is aligned in memory; in particular, when you are using records of data, known
    in C++ as `structs`. C++ provides the `sizeof` operator to give the number of
    bytes used to hold a variable and the `alignof` operator to determine the alignment
    of the type in memory. For basic types, the `sizeof` and `alignof` operators return
    the same value; it is only necessary to call the `alignof` operator on custom
    types where it will return the alignment of the largest data member in the type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有时您可能需要了解变量的大小以及它在内存中的对齐方式；特别是当您使用C++中称为`structs`的数据记录时。C++提供了`sizeof`运算符来给出用于保存变量的字节数，以及`alignof`运算符来确定内存中类型的对齐方式。对于基本类型，`sizeof`和`alignof`运算符返回相同的值；只有在自定义类型上调用`alignof`运算符时，它才会返回类型中最大数据成员的对齐方式。
- en: Integers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'As the name suggests, an integer holds integral data, numbers that have no
    fractional part. For this reason, it makes little sense to do any arithmetic with
    an integer where the fractional part is important; in this case, you should use
    floating point numbers. An example of this was shown in the last chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，整数保存整数数据，即没有小数部分的数字。因此，在需要重视小数部分的情况下，使用整数进行任何算术运算几乎没有意义；在这种情况下，应该使用浮点数。上一章中展示了一个例子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives an aspect ratio of 1, which is clearly untrue and serves no purpose.
    Even if you assign the result to a floating-point number, you will get the same
    result:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个明显不正确且毫无意义的宽高比。即使将结果分配给浮点数，您也会得到相同的结果：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The reason is that the arithmetic is performed in the expression `width / height`,
    which will use the division operator for integers that will throw away any fractional
    part of the result. To use the floating-point division operator you will have
    to cast one or other of the operands to a floating-point number so the floating-point
    operator is used:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是表达式`width / height`中的算术是在整数上执行的，这将使用整数的除法运算符丢弃结果的任何小数部分。要使用浮点除法运算符，您将需要将操作数之一强制转换为浮点数，以便使用浮点运算符：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will assign a value of 1.3333 (or 4 : 3) to the `aspect_ratio` variable.
    The cast operator used here is the C cast operator, which forces data of one type
    to be used as data of another type. (It is used because we have not yet introduced
    the C++ cast operators, and the syntax of C cast operators is clear.) There is
    no type safety in this cast. C++ provides cast operators, which are discussed
    in the following text, some of which will cast in a type-safe way, which becomes
    important when you use pointers to objects of custom types.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`aspect_ratio`变量分配一个值为1.3333（或4：3）。这里使用的强制转换运算符是C强制转换运算符，它强制将一个类型的数据用作另一个类型的数据。（这是因为我们还没有介绍C++强制转换运算符，并且C强制转换运算符的语法是清晰的。）这种转换没有类型安全性。C++提供了强制转换运算符，下文将讨论其中一些将以类型安全的方式进行转换，当您使用自定义类型的对象指针时，这将变得很重要。
- en: 'C++ provides integer types of various sizes, as summarized in the following
    table. These are the five standard integer types. The standard says that an `int`
    is the natural size of the processor and will have a value between (and including)
    `INT_MIN` and `INT_MAX` (defined in the `<climits>` header file). The size of
    the integer type has *at least as much storage as those preceding it in the list*,
    so an `int` is, at least, as big as a `short int` and a `long long int` types,
    which is at least as big as a `long int` type. The phrase *at least as big as* is
    not much use if the types are all the same size, so the `<climits>` header file
    defines ranges for the other fundamental integer types too. It is implementation-specific
    how many bytes are needed to store these integer ranges. This table gives the
    ranges of the fundamental types and the sizes on x86, 32-bit processors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了各种大小的整数类型，如下表所总结。这些是五种标准整数类型。标准规定`int`是处理器的自然大小，并且其值在（包括）`INT_MIN`和`INT_MAX`之间（在`<climits>`头文件中定义）。整数类型的大小至少与列表中前面的整数类型一样大，因此`int`至少与`short
    int`和`long long int`类型一样大，至少与`long int`类型一样大。短语“至少与”如果这些类型都是相同大小，那么就没有多大用处，因此`<climits>`头文件还为其他基本整数类型定义了范围。存储这些整数范围需要多少字节是依赖于实现的。这个表给出了基本类型的范围和x86，32位处理器上的大小：
- en: '| **Type** | **Range** | **Size in bytes** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **范围** | **字节大小** |'
- en: '| `signed char` | -128 to 127 | 1 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `signed char` | -128到127 | 1 |'
- en: '| `short int` | -32768 to 32767 | 2 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | -32768到32767 | 2 |'
- en: '| `int` | -2147483648 to 2147483647 | 4 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `int` | -2147483648到2147483647 | 4 |'
- en: '| `long int` | -2147483648 to 2147483647 | 4 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `long int` | -2147483648到2147483647 | 4 |'
- en: '| `long long int` | -9223372036854775808 to 9223372036854775807 | 8 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `long long int` | -9223372036854775808到9223372036854775807 | 8 |'
- en: In practice, rather than the `short int` type, you will use `short`; for `long
    int`, you will use `long`; and for `long long int`, you will typically use `long
    long`. As you can see from this table, the `int` and `long int` types are the
    same size, but they are still two different types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您将使用`short`而不是`short int`类型；对于`long int`，您将使用`long`；对于`long long int`，通常会使用`long
    long`。从这个表中可以看出，`int`和`long int`类型的大小相同，但它们仍然是两种不同的类型。
- en: Other than the `char` type, by default integer types are signed, that is, they
    can hold negative as well as positive numbers (for example, a variable of type
    `short` can have a value between -32,768 and 32,767). You can use the `signed`
    keyword to explicitly indicate that the type is signed. You can also have unsigned
    equivalents by using the `unsigned` keyword, which will give you an extra bit,
    but will also mean that bitwise operators and shift operators will work as you
    expect. You may find `unsigned` used without a type, in which case it refers to
    `unsigned int`. Similarly, `signed` used without a type refers to `signed int`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`char`类型，缺省情况下整数类型都是有符号的，也就是说，它们可以保存负数和正数（例如，`short`类型的变量的值可以在-32,768和32,767之间）。您可以使用`signed`关键字显式指示类型为有符号。您还可以使用`unsigned`关键字来获得无符号的等价类型，这将给您一个额外的位，但也意味着按位运算符和移位运算符将按您的预期工作。您可能会发现`unsigned`在没有类型的情况下使用，这种情况下它指的是`unsigned
    int`。类似地，没有类型的`signed`指的是`signed int`。
- en: The `char` type is a separate type to both `unsigned char` and `signed char`.
    The standard says that every bit in a `char` is used to hold character information,
    and so it is implementation-dependent as to whether a `char` can be treated as
    being able to hold negative numbers. If you want a `char` to hold a signed number,
    you should specifically use `signed char`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`类型是`unsigned char`和`signed char`的独立类型。标准规定`char`中的每一位都用于保存字符信息，因此根据实现的不同，`char`是否可以被视为能够保存负数是依赖于实现的。如果您希望`char`保存有符号数，您应该明确使用`signed
    char`。'
- en: The standard is imprecise about the size of the standard integer types and this
    may be an issue if you are writing code (for example, accessing data in a file,
    or a network stream) that contains a stream of bytes. The `<cstdlib>` header file
    defines named types that will hold specific ranges of data. These types have names
    which have the number of bits used in the range (although the actual type may
    require more bits). So, there are types with names such as `int16_t` and `uint16_t`,
    where the first type is a signed integer that will hold a range of 16-bit values
    and the second type is an unsigned integer. There are also types declared for
    8-, 32-, and 64-bit values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 标准对于标准整数类型的大小并不精确，如果您正在编写代码（例如，访问文件中的数据或网络流），这可能是一个问题。`<cstdlib>`头文件定义了将保存特定数据范围的命名类型。这些类型具有包含在范围内使用的位数的名称（尽管实际类型可能需要更多位）。因此，有诸如`int16_t`和`uint16_t`之类的类型，其中第一个类型是将保存16位值范围的有符号整数，第二个类型是无符号整数。还声明了8位、32位和64位值的类型。
- en: 'The following shows the actual sizes of these types determined by the `sizeof`
    operator on an x86 machine:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了在x86机器上使用`sizeof`运算符确定的这些类型的实际大小：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition, the `<cstdlib>` header file defines types with names such as `int_least16_t`
    and `uint_least16_t` using the same naming scheme as before, and with versions
    for 8-, 16-,32-, and 64-bits. The `least` part of the name means that the type
    will hold values with at least the specified number of bits, but there could be
    more. There are also types with names such as `int_fast16_t` and `uint_fast16_t`
    with versions for 8-, 16-, 32-, and 64-bits which are regarded as the fastest
    types that can hold that number of bits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`<cstdlib>`头文件还定义了诸如`int_least16_t`和`uint_least16_t`之类的类型，使用与之前相同的命名方案，并且有8位、16位、32位和64位的版本。名称中的`least`部分表示该类型将保存至少指定数量的位的值，但可能会更多。还有诸如`int_fast16_t`和`uint_fast16_t`之类的类型，具有8位、16位、32位和64位的版本，被视为可以保存该位数的最快类型。
- en: Specifying integer literals
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定整数文字
- en: To assign a value to an integer variable you provide a number that has no fractional
    part. The compiler will identify the type with the nearest precision that the
    number represents and attempt to assign the integer, performing a conversion if
    necessary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要为整数变量赋值，您提供一个没有小数部分的数字。编译器将确定数字表示的最接近精度的类型，并尝试分配整数，必要时执行转换。
- en: 'To explicitly specify that a literal is a `long` value, you use the `l` or
    `L` suffix. Similarly, for an `unsigned long`, you use the suffix `ul` or `UL`.
    For `long long` values, you use `ll` or `LL` suffix, and use `ull` or `ULL` for
    `unsigned long long`. The `u` (or `U`) suffix is for `unsigned` (that is, `unsigned
    int`) and you do not need a suffix for `int`. The following illustrates this,
    using uppercase suffixes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确指定文字是`long`值，您可以使用`l`或`L`后缀。同样，对于`unsigned long`，您可以使用后缀`ul`或`UL`。对于`long
    long`值，您使用`ll`或`LL`后缀，并对于`unsigned long long`使用`ull`或`ULL`。`u`（或`U`）后缀用于`unsigned`（即`unsigned
    int`），对于`int`不需要后缀。以下是使用大写后缀的示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using a 10-based number system to specify a number that is a bitmap is confusing
    and cumbersome. The bits in a bitmap are the powers of 2, so it makes more sense
    to use a number system that is a power of 2\. C++ allows you to provide numbers
    in octal (base 8) or hexadecimal (base 16). To provide a literal in an octal you
    prefix the number with a zero character (`0`). To provide a literal in a hexadecimal
    you prefix the number with the `0x` character sequence. Octal numbers use the
    digits 0 through 7, but hexadecimal numbers need 16 digits, which means 0 through
    9 and a through f (or A through F), where A is 10 in base 10 and F is 15 in base
    10:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用10进制数字系统来指定位图的数字是令人困惑和繁琐的。位图中的位是2的幂，因此更合理的是使用2的幂的数字系统。C++允许您以八进制（基数8）或十六进制（基数16）提供数字。要在八进制中提供文字，您需要使用零字符（`0`）作为前缀。要在十六进制中提供文字，您需要使用`0x`字符序列作为前缀。八进制数字使用数字0到7，但十六进制数字需要16个数字，即0到9和a到f（或A到F），其中A在十进制中是10，F在十进制中是15：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, two 64-bit (in Visual C++) integers are assigned bitmap values,
    with every other bit set to 1\. The first variable starts with the bottom bit
    set, the second variable starts with the bottom bit unset, and the second lowest
    bit set. Before inserting the numbers, the stream is modified with three manipulators.
    The first `hex` indicates that integers should be printed on the console as hexadecimals,
    and `showbase` means that the leading `0x` will be printed. By default, the alphabetic
    digits (A to F) will be given in lowercase and, to specify that uppercase must
    be used, you use `uppercase`. Once the stream has been modified, the setting remains
    until it is changed. To change the stream subsequently to use lowercase for alphabetic
    hexadecimal digits you insert `nouppercase` into the stream and to print the number
    without the base, insert the `noshowbase` manipulator. To use octal digits, you
    insert the `oct` manipulator and to use decimals, insert the `dec` manipulator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，两个64位（在Visual C++中）整数被分配了位图值，其中每隔一位设置为1。第一个变量从底位设置，第二个变量从底位取消设置，并设置次低位。在插入数字之前，流被修改了三个操纵器。第一个`hex`表示整数应以十六进制形式打印在控制台上，`showbase`表示将打印前导的`0x`。默认情况下，字母数字（A到F）将以小写形式给出，要指定必须使用大写形式，您可以使用`uppercase`。一旦流被修改，设置将保持直到被更改。要随后更改流以使用小写字母十六进制数字，您可以在流中插入`nouppercase`，要打印没有基数的数字，插入`noshowbase`操纵器。要使用八进制数字，您可以插入`oct`操纵器，要使用十进制，插入`dec`操纵器。
- en: 'When you specify large numbers like this, it becomes difficult to see if you
    have specified the right number of digits. You can group together digits using
    a single quote (`''`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定这样的大数字时，很难看出您是否已经指定了正确数量的数字。您可以使用单引号（`'`）将数字分组在一起：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler ignores the quote; it is just used as a visual aid. In the first
    example, the quote groups the digits into two byte groups; in the second case
    the quote groups a decimal number in thousands and millions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器忽略引号；它只是用作视觉辅助。在第一个示例中，引号将数字分组为两个字节组；在第二种情况下，引号将小数分组为千位和百万位。
- en: Using bitset to show bit patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位集来显示位模式
- en: 'There is no manipulator to tell the `cout` object to print an integer as a
    bitmap, but you can simulate the behavior using a `bitset` object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有操纵器告诉`cout`对象将整数打印为位图，但是可以使用`bitset`对象模拟该行为：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here the `bitset` class is **parameterized,** which means that you provide a
    parameter through the angle brackets (`<>`) and in this case, 64 is used, indicating
    that the `bitset` object will accommodate 64-bits. In both cases, the initialization
    of the `bitset` object is carried out using a syntax that looks like a function
    call (in fact, it does call a function called a **constructor**) and this is the
    preferred way to initialize an object. Inserting the `bitset` object into the
    stream, prints out each bit starting with the highest bit. (The reason for this
    is that there is an `operator <<` function defined, which takes a `bitset` object,
    as is the case for most of the standard library classes).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bitset`类是**参数化**的，这意味着您通过尖括号（`<>`）提供一个参数，在这种情况下使用64，表示`bitset`对象将容纳64位。在这两种情况下，`bitset`对象的初始化使用看起来像函数调用的语法（实际上，它确实调用了一个称为**构造函数**的函数），这是初始化对象的首选方式。将`bitset`对象插入流中，打印出从最高位开始的每个位。（原因是定义了一个`operator
    <<`函数，它接受一个`bitset`对象，这是大多数标准库类的情况）。
- en: 'The `bitset` class is useful for accessing and setting individual bits as an
    alternative to using bitwise operators:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitset`类对于访问和设置单个位而不使用位运算符是有用的：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `set` function will set the bit in the specified position to a value of
    1\. The `to_ullong` function will return a `long long` number that the `bitset`
    represents.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`函数将在指定位置设置位为1。`to_ullong`函数将返回`bitset`表示的`long long`数字。'
- en: 'The call to the `set` function and the assignment has the same result as the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对`set`函数的调用和赋值具有与以下相同的结果：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Determining integer byte order
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定整数字节顺序
- en: The order of bytes in an integer is implementation-dependent; it depends on
    how the processor handles integers. In most cases, you do not need to know. However,
    if you are reading bytes from a file in binary mode, or bytes from a network stream,
    and you need to interpret two or more bytes as parts of an integer, you will need
    to know what order they are in, and if necessary convert them to the order recognized
    by the processor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 整数中字节的顺序取决于实现；它取决于处理器如何处理整数。在大多数情况下，您不需要知道。但是，如果您以二进制模式从文件中读取字节，或者从网络流中读取字节，并且需要将两个或更多字节解释为整数的一部分，则需要知道它们的顺序，并且必要时将它们转换为处理器识别的顺序。
- en: The C network library (on Windows, it is called the **Winsock** library) contains
    a collection of functions that convert `unsigned short` and `unsigned long` types
    from the network order to the host order (that is, the order used by the processor
    on the current machine) and vice versa. The network order is big endian. **Big
    endian** means that the first byte will be the highest byte in the integer, whereas
    **little endian** means that the first byte is the smallest byte. When you transmit
    an integer to another machine you first convert from the order used by the processor
    of the source machine (the host order) to the network order and the receiving
    machine converts the integer from network order to the host order of the receiving
    machine before using the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C网络库（在Windows上称为**Winsock**库）包含一组函数，用于将`unsigned short`和`unsigned long`类型从网络顺序转换为主机顺序（即当前机器上处理器使用的顺序），反之亦然。网络顺序是大端序。**大端序**意味着第一个字节将是整数中的最高字节，而**小端序**意味着第一个字节是最小字节。当您将整数传输到另一台机器时，您首先将其从源机器的处理器使用的顺序（主机顺序）转换为网络顺序，接收机在使用数据之前将整数从网络顺序转换为接收机的主机顺序。
- en: The functions to change the byte order are `ntohs` and `ntohl`; for converting
    `unsigned short` and `unsigned long` from the network order to the host order
    and `htons` and `htonl` for the conversion from the host order to the network
    order. Knowing the byte order will be important when you view memory when you
    are debugging code (for example, as in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml),
    *Diagnostics and Debugging*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更改字节顺序的函数是`ntohs`和`ntohl`；用于将`unsigned short`和`unsigned long`从网络顺序转换为主机顺序的函数，以及`htons`和`htonl`，用于将主机顺序转换为网络顺序。在调试代码时，了解字节顺序将是重要的（例如，如[第10章](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml)中所述，*诊断和调试*）。
- en: 'It is easy to write code to reverse the byte order:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以反转字节顺序很容易：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This uses bitwise operators to separate the two bytes that are assumed to make
    up the `unsigned short` into the lower byte, which is shifted eight bits left,
    and the upper byte that is shifted eight bits right and these two numbers are
    recombined as an `unsigned short` using the bitwise OR operator, `|`. It is simple
    to write versions of this function for 4-byte and 8-byte integers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用位运算符将假定组成`unsigned short`的两个字节分开为较低字节，将其左移八位，并将右移八位的上字节，然后使用按位或运算符`|`将这两个数字重新组合为`unsigned
    short`。编写此函数的4字节和8字节整数版本很简单。
- en: Floating point types
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'There are three basic floating point types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的浮点类型：
- en: '`float` (single precision)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`（单精度）'
- en: '`double` (double precision)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`（双精度）'
- en: '`long double` (extended precision)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double`（扩展精度）'
- en: 'All of these are signed. The actual format of the number in memory, and the
    number of bytes used, is specific to the C++ implementation, but the `<cfloat>`
    header file gives the ranges. The following table gives the positive ranges and
    number of bytes used on x86, 32-bit processors:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是有符号的。内存中数字的实际格式和使用的字节数是特定于C++实现的，但`<cfloat>`头文件给出了范围。以下表格给出了x86、32位处理器上使用的正数范围和字节数：
- en: '| **Type** | **Range** | **Size in bytes** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **范围** | **字节大小** |'
- en: '| float | 1.175494351e-38 to 3.402823466e+38 | 4 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: 浮点 | 1.175494351e-38 到 3.402823466e+38 | 4
- en: '| double | 2.2250738585072014e-308 to 1.7976931348623158e+308 | 8 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: 双精度 | 2.2250738585072014e-308 到 1.7976931348623158e+308 | 8
- en: '| long double | 2.2250738585072014e-308 to 1.7976931348623158e+308 | 8 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: 长双精度 | 2.2250738585072014e-308 到 1.7976931348623158e+308 | 8
- en: As you can see, in Visual C++ `double` and `long double` have the same ranges,
    but they are still two distinct types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在Visual C++中，`double`和`long double`具有相同的范围，但它们仍然是两种不同的类型。
- en: Specifying floating point literals
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定浮点文字
- en: 'A literal used to initialize a `double` is specified as a floating point by
    using either the scientific format, or simply by providing a decimal point:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用于初始化`double`的文字是通过使用科学格式或简单地提供小数点来指定的浮点数：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first example indicates that the variable `one` is assigned to a floating-point
    value of 1.0\. The trailing zero is not important, as shown in the second variable,
    `two`; however, the trailing zero does make the code more readable since the period
    is easy to overlook. The third example uses scientific notation. The first part
    is the mantissa and can be signed and the part after the `e` is the exponent.
    The exponent is the power-of-10 magnitude of the number (which can be negative).
    The variable is assigned to a value of the mantissa multiplied by 10 and raised
    to the exponent. Although it is not recommended, you can write the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子表明变量`one`被赋予了浮点值1.0。结尾的零并不重要，如第二个变量`two`所示；然而，结尾的零确实使代码更易读，因为很容易忽略句号。第三个例子使用了科学计数法。第一部分是尾数，可以是有符号的，`e`后面的部分是指数。指数是数字的10的幂大小（可以是负数）。变量被赋予尾数乘以10并提升到指数的值。虽然不建议这样做，但您可以写以下内容：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The compiler will interpret the numbers appropriately. The first example is
    perverse, but the second makes some sense; it shows in your code that a billion
    is a thousand million.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将适当地解释这些数字。第一个例子是反常的，但第二个有些意义；它在您的代码中显示了十亿是一千万的意思。
- en: 'These examples assign double precision floating point values to `double` variables.
    To specify a value for single precision variables so that you can assign a `float`
    variable, use the `f` (or `F`) suffix. Similarly, for a `long double` literal
    use the `l` (or `L`) suffix:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例将双精度浮点值分配给`double`变量。要为单精度变量指定值，以便可以分配`float`变量，使用`f`（或`F`）后缀。类似地，对于`long
    double`文字，使用`l`（或`L`）后缀：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you use these suffixes, you still have to provide the number in the right
    format. A literal of `2f` is incorrect; you have to provide a decimal point, `2.f`.
    When you specify floating point numbers with a large number of digits you can
    use the single quote (`''`) to group digits. As stated before, this is just a
    visual aid to the programmer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用这些后缀，仍然必须以正确的格式提供数字。`2f`的文字是不正确的；您必须提供一个小数点，`2.f`。当您指定具有大量数字的浮点数时，可以使用单引号（`'`）来分组数字。如前所述，这只是对程序员的一种视觉辅助：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Characters and strings
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符和字符串
- en: The `string` class and C string functions will be covered in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*; this section covers the basic use of character variables in your
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类和C字符串函数将在[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml)中介绍，*使用字符串*；本节介绍了代码中字符变量的基本用法。'
- en: Character types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符类型
- en: The `char` type is an integer, so `signed char` and `unsigned char` exist too.
    These are three distinct types; the `signed char` and `unsigned char` types should
    be treated as numeric types. The `char` type is used to hold a single character
    in the implementation's character set. In Visual C++, this is an eight-bit integer
    that can hold characters from the ISO-8859 or UTF-8 character set. These character
    sets are able to represent the characters used in English and most European languages.
    Characters from other languages take up more than one byte and C++ provides the
    `char16_t` type to hold 16-bit characters and `char32_t` to hold 32-bit characters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`类型是一个整数，所以也存在`signed char`和`unsigned char`。这是三种不同的类型；`signed char`和`unsigned
    char`类型应该被视为数值类型。`char`类型用于在实现的字符集中保存单个字符。在Visual C++中，这是一个可以容纳ISO-8859或UTF-8字符集中的字符的8位整数。这些字符集能够表示英语和大多数欧洲语言中使用的字符。其他语言的字符占用多个字节，C++提供了`char16_t`类型来保存16位字符和`char32_t`来保存32位字符。'
- en: There is also a type called `wchar_t` (wide character) that will be able to
    hold characters from the largest extended character set. In general, when you
    see a C Runtime Library or C++ Standard Library function with a `w` prefix, it
    will use wide character strings rather than `char` strings. So, the `cout` object
    will allow you to insert `char` strings and the `wcout` object will allow you
    to insert wide character strings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为`wchar_t`（宽字符）的类型，它将能够容纳来自最大扩展字符集的字符。通常，当您看到带有`w`前缀的C运行时库或C++标准库函数时，它将使用宽字符字符串而不是`char`字符串。因此，`cout`对象将允许您插入`char`字符串，而`wcout`对象将允许您插入宽字符字符串。
- en: 'The C++ standard says that every bit in a `char` is used to hold character
    information, and so it is implementation-dependent as to whether a `char` can
    be treated as being able to hold negative numbers. The following illustrates this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准规定`char`中的每个位都用于保存字符信息，因此根据实现，`char`是否可以被视为能够保存负数是依赖于实现的。以下是说明：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The range of a `signed char` is -128 to 127, but this code uses the separate
    type `char` and attempts to use it in the same way. The variable `c` is first
    assigned to the ASCII character `~` (126). When you insert a character into an
    output stream it will attempt to print a character rather than a number, so the
    next line prints this character to the console, to get the numeric value the code
    converts the variable to a `signed short` integer. (Again, a C cast is used for
    clarity.) Next, the variable is incremented by two, that is, the character is
    two characters further in the character set, which means the first character in
    the extended ASCII character set; the result is this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`signed char`的范围是-128到127，但此代码使用了单独的类型`char`并尝试以相同的方式使用它。变量`c`首先被赋值为ASCII字符`~`（126）。当您将字符插入输出流时，它将尝试打印一个字符而不是一个数字，因此下一行将此字符打印到控制台，为了获得数值，代码将变量转换为`signed
    short`整数。（再次，为了清晰起见，使用了C转换。）接下来，变量增加了两个，也就是说，字符在字符集中向后移动了两个字符，这意味着扩展ASCII字符集中的第一个字符；结果是这样的：'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first character in the extended character set is C-cedilla.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字符集中的第一个字符是C-锐音。
- en: It is rather counter-intuitive that a value of 126 incremented by two results
    is a value of -128, and this comes about from overflow calculations with signed
    types. Even if this is intentional, it is best to avoid doing this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值为126增加两个的结果是-128，这相当反直觉，并且这是由于带符号类型的溢出计算导致的。即使这是有意的，最好还是避免这样做。
- en: 'In Visual C++, the C-cedilla character is treated as -128 so you can write
    the following to have the same effect:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual C++中，C-锐音字符被视为-128，因此您可以编写以下内容以达到相同的效果：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is implementation-specific, so for portable code you should not rely upon
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是特定于实现的，因此对于可移植代码，您不应该依赖它。
- en: Using character macros
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符宏
- en: The `<cctype>` header contains various macros that you can use to examine the
    type of character a `char` holds. These are the C runtime macros declared in `<ctype.h>`.
    Some of the more useful macros to test character values are explained in the following
    table. Bear in mind that, since these are C routines, they will not return `bool`
    values; instead they return an `int` with a value of non-zero for `true` and zero
    for `false`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cctype>`头文件包含了各种宏，您可以使用这些宏来检查`char`包含的字符类型。这些是在`<ctype.h>`中声明的C运行时宏。以下表格中解释了一些更有用的测试字符值的宏。请记住，由于这些是C例程，它们不会返回`bool`值；而是返回一个具有非零值的`int`表示`true`，零表示`false`。'
- en: '| **Macro** | **Tests if the character is:** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '**宏** | **测试字符是否为：** |'
- en: '| `isalnum` | An alphanumeric character, A to Z, a to z, 0 to 9 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '`isalnum` | 字母数字字符，A到Z，a到z，0到9 |'
- en: '| `isalpha` | An alphabetic character, A to Z, a to z |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '`isalpha` | 一个字母字符，A到Z，a到z |'
- en: '| `isascii` | An ASCII character, 0x00 to 0x7f |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '`isascii` | 一个ASCII字符，0x00到0x7f |'
- en: '| `isblank` | A space or horizontal tab |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '`isblank` | 一个空格或水平制表符 |'
- en: '| `iscntrl` | A control character, 0x00 to 0x1f or 0x7f |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '`iscntrl` | 一个控制字符，0x00到0x1f或0x7f |'
- en: '| `isdigit` | A decimal digit 0 to 9 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '`isdigit` | 十进制数字0到9 |'
- en: '| `isgraph` | A printable character other than space, 0x21 to 0x7e |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '`isgraph` | 可打印字符，不包括空格，0x21到0x7e |'
- en: '| `islower` | A lowercase character, a to z |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '`islower` | 一个小写字符，a到z |'
- en: '| `isprint` | A printable character, 0x20 to 0x7e |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '`isprint` | 可打印字符，0x20到0x7e |'
- en: '| `ispunct` | A punctuation character, `! " # $ % & '' ( ) * + , - . / : ;
    < = > ? @ [ ] ^ _ ` { &#124; } ~ \` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '`ispunct` | 一个标点字符，`! " # $ % & '' ( ) * + , - . / : ; < = > ? @ [ ] ^ _ `
    { &#124; } ~ \` |'
- en: '| `isspace` | A space |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '`isspace` | 一个空格 |'
- en: '| `isupper` | An uppercase character, A to Z |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '`isupper` | 一个大写字符，A到Z |'
- en: '| `isxdigit` | A hexadecimal digit, 0 to 9, a to f, A to F |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '`isxdigit` | 一个十六进制数字，0到9，a到f，A到F |'
- en: 'For example, the following code loops while reading in a single character from
    the input stream (after each character, you need to press the *Enter* key). The
    loop finishes when a non-numeric value is provided:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码循环读取输入流中的单个字符（在每个字符后，您需要按*Enter*键）。当提供非数字值时，循环结束：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are also macros to change characters. Again, these will return an `int`
    value, which you should convert to a `char`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还有用于更改字符的宏。同样，这些将返回一个`int`值，您应该将其转换为`char`。
- en: '| **Macro** | **Returns** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '**宏** | **返回** |'
- en: '| `toupper` | The uppercase version of the character |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '`toupper` | 字符的大写版本 |'
- en: '| `tolower` | The lowercase version of the character |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '`tolower` | 字符的小写版本 |'
- en: 'In the following code, the character typed at the console is echoed back until
    the user types `q` or `Q`. If the character typed is a lowercase character, the
    echoed character is converted to uppercase:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，从控制台键入的字符被回显，直到用户键入`q`或`Q`为止。如果键入的字符是小写字符，则回显的字符会转换为大写：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Specifying character literals
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定字符文字
- en: You can initialize a `char` variable with literal characters. This will be a
    character from the supported character set. The ASCII character set includes some
    unprintable characters, and so that you can use these, C++ provides two character
    sequences using the backslash character (`\`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用文字字符初始化`char`变量。这将是受支持的字符集中的一个字符。ASCII字符集包括一些不可打印的字符，因此您可以使用这些，C++提供了两个使用反斜杠字符（`\`）的字符序列。
- en: '| **Name** | **ASCII name** | **C++ sequence** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '**名称** | **ASCII名称** | **C++序列** |'
- en: '| Newline | LF | `\n` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: 换行符 | LF | `\n` |
- en: '| Horizontal tab | HT | `\t` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: 水平制表符 | HT | `\t` |
- en: '| Vertical tab | VT | `\v` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: 垂直制表符 | VT | `\v` |
- en: '| Backspace | BS | `\b` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: 退格 | BS | `\b` |
- en: '| Carriage return | CR | `\r` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: 回车 | CR | `\r` |
- en: '| Form feed | FF | `\f` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: 换页符 | FF | `\f` |
- en: '| Alert | BEL | `\a` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: 警报 | BEL | `\a` |
- en: '| Backslash | \ | `\\` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: 反斜杠 | \ | `\\` |
- en: '| Question mark | ? | `\?` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: 问号 | ? | `\?` |
- en: '| Single quote | '' | `\''` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: 单引号 | ' | `\'` |
- en: '| Double quote | " | `\"` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: 双引号 | " | `\"` |
- en: 'In addition, you can give the numeric value of that character as an octal or
    hexadecimal number. To provide an octal number you give the number as three characters
    (prefixed with one or two `0` characters if necessary) prefixed with a backslash.
    For a hexadecimal number, you prefix it with `\x`. The character `M`, is the character
    number 77 in decimal, 115 in octal, and 4d in hexadecimal, so you can initialize
    a character variable with an `M` character in three ways:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以将该字符的数值作为八进制或十六进制数给出。要提供八进制数，您需要使用三个字符（必要时前缀为一个或两个`0`字符）前缀为反斜杠。对于十六进制数，您需要使用`\x`前缀。字符`M`在十进制中是字符编号77，在八进制中是115，在十六进制中是4d，因此您可以用三种方式初始化一个字符变量为`M`字符。
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For completeness, it is worth pointing out that you can initialize a char as
    an integer, so the following will also initialize each variable to an `M` character:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，值得指出您可以将char初始化为整数，因此以下内容也将初始化每个变量为`M`字符：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All of these methods are valid.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都是有效的。
- en: Specifying string literals
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定字符串文字
- en: 'Strings are made up of one or more characters, and you can use the escaped
    characters in string literals too:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串由一个或多个字符组成，您也可以在字符串文字中使用转义字符。
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This rather unreadable string will be printed on the console as `This is C++`
    followed by a newline. The capital C is 43 in hexadecimal and the + symbol is
    2b in hexadecimal and 53 in octal. The `\n` character is a newline. Escaped characters
    are useful for printing characters that are not in the character set your C++
    compiler uses and for some unprintable characters (for example, `\t` to insert
    a horizontal tab). The `cout` object buffers the characters before writing them
    to the output stream. If you use `\n` as a newline it is treated like any other
    character in the buffer. The `endl` manipulator will insert `\n` into the buffer
    and then flush it so the characters are immediately written to the console.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当难读的字符串将被打印在控制台上，后面跟着一个换行符，显示为`This is C++`。大写字母C的十六进制是43，加号的十六进制是2b，八进制是53。`\n`字符是一个换行符。转义字符对于打印不在C++编译器使用的字符集中的字符以及一些不可打印的字符（例如，`\t`插入水平制表符）非常有用。`cout`对象在将字符写入输出流之前会对其进行缓冲。如果您使用`\n`作为换行符，它将被视为缓冲区中的任何其他字符。`endl`操作符将`\n`插入缓冲区，然后刷新缓冲区，使字符立即写入控制台。
- en: The *empty*, or `NULL` character, is a `\0`. This is an important character
    because it is unprintable, and it has no use other than to mark the end of a sequence
    of characters in a string. The empty string is `""`, but since strings are delimited
    by the `NULL` character the memory taken up by a string variable initialized with
    the empty string will have one character, that is `\0`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*空*或`NULL`字符是`\0`。这是一个重要的字符，因为它是不可打印的，并且除了标记字符串中字符序列的结束之外没有其他用途。空字符串是`""`，但由于字符串由`NULL`字符界定，因此使用空字符串初始化的字符串变量占用的内存将有一个字符，即`\0`。'
- en: 'The newline character allows you to put a newline within a string. This is
    useful if the only formatting you''ll do is with paragraphs and you are printing
    short paragraphs:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符允许您在字符串中插入换行符。如果您只对段落进行格式化，并且要打印短段落，这将非常有用。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This prints two lines on the console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这在控制台上打印了两行：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, you may want to initialize a string with a long sequence of characters
    and the limitations of the editor you are using may mean you want to split the
    string over several lines. You do this by putting each fragment of the string
    within double quotes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能希望使用长序列的字符初始化字符串，而您使用的编辑器的限制可能意味着您希望将字符串分割成几行。您可以通过将字符串的每个片段放在双引号内来实现这一点。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see the following on the console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在控制台上看到以下内容：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is no newline printed other than the one explicitly requested at the end
    with `endl`. This syntax allows you to make long strings more readable in your
    code; you can, of course, use the newline characters `\n`, in such strings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在最后使用`endl`明确请求的换行符外，不会打印其他换行符。这种语法允许您在代码中使长字符串更易读；当然，您也可以在这样的字符串中使用换行字符`\n`。
- en: Unicode literals
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode文字
- en: A `wchar_t` variable can also be initialized with a character and the compiler
    will promote the character to a wide character essentially by using the character's
    byte and assigning the remaining (higher) bytes to zero. However, it makes more
    sense to assign such a variable with a wide character, and you do this using the
    `L` prefix.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`wchar_t`变量也可以用字符初始化，编译器将通过使用字符的字节并将剩余（更高的）字节分配为零来将字符提升为宽字符。但是，将这样的变量分配为宽字符更有意义，您可以使用`L`前缀来实现这一点。'
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that, rather than using the `cout` object, this code uses `wcout`, the
    wide character version. The syntax of using the `\u` prefix within the quotes
    indicates that the following character is a Unicode character.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码使用的是`wcout`，而不是`cout`对象，使用引号内的`\u`前缀的语法表示后面的字符是Unicode字符。
- en: 'Bear in mind that, to show the Unicode character, you need to use a console
    that will show Unicode characters and, by default, the Windows console is set
    to **Code Page 850** which will not show Unicode characters. You can change the
    mode of the output console by calling `_setmode` (defined in `<io.h>`) on the
    standard output stream, `stdout`, specifying the UTF-16 file mode (using `_O_U16TEXT`
    defined in `<fcntl.h>`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要显示Unicode字符，您需要使用一个可以显示Unicode字符的控制台，默认情况下，Windows控制台设置为**Code Page 850**，不会显示Unicode字符。您可以通过在标准输出流`stdout`上调用`_setmode`（在`<io.h>`中定义）来更改输出控制台的模式，指定UTF-16文件模式（使用`<fcntl.h>`中定义的`_O_U16TEXT`）：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can find a list of all of the characters supported by Unicode at [http://unicode.org/charts/](http://unicode.org/charts/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://unicode.org/charts/](http://unicode.org/charts/)找到Unicode支持的所有字符的列表。
- en: UTF-16 characters can also be assigned to `char16_t` variables, and UTF-32 characters
    can be assigned to `char32_t` variables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16字符也可以分配给`char16_t`变量，UTF-32字符也可以分配给`char32_t`变量。
- en: Raw strings
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始字符串
- en: When you use a raw string literal you essentially switch off the meaning of
    escape characters. Whatever you type into a raw string becomes its content, even
    if you use whitespace including newlines. The raw string is delimited with `R"(`
    and `)"`. That is, the string is between the inner parentheses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用原始字符串文字时，实质上是关闭了转义字符的含义。无论您输入什么内容到原始字符串中，甚至包括换行符在内，原始字符串都会将其作为内容。原始字符串用`R"(`和`)"`来界定。也就是说，字符串位于内部括号之间。
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that, the `()` is part of the syntax and is not part of the string. The
    preceding code prints the following to the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`()`是语法的一部分，不是字符串的一部分。前面的代码将以下内容打印到控制台：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Normally in a string `\n` is an escaped character and will be translated as
    a newline, but in a raw string it is not translated and is printed as two characters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在字符串中，`\n`是一个转义字符，将被翻译为换行符，但在原始字符串中，它不会被翻译，而是打印为两个字符。
- en: 'In a normal C++ string, you will have to escape some of the characters; for
    example, the double quote will have to be escaped to `\"` and the backslash escaped
    to `\\`. The following will give the same result without using a raw string:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的C++字符串中，您将不得不转义一些字符；例如，双引号必须转义为`\"`，反斜杠必须转义为`\\`。不使用原始字符串，以下将给出相同的结果：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also have newlines in raw strings:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在原始字符串中使用换行符：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this code, the newline after the comma will be printed to the console. Unfortunately,
    all whitespace will be printed on the console, so assuming that in the preceding
    code the indentation is three spaces and the `cout` is indented once, you will
    see the following on the console:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，逗号后面的换行符将被打印到控制台。不幸的是，所有空白字符都将被打印到控制台上，因此假设在前面的代码中缩进为三个空格，`cout`缩进一次，您将在控制台上看到以下内容：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are 14 spaces in front of `its` because there were 14 spaces in front
    of `its` in the source code. For this reason, you should be wary about using raw
    strings.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`its`前面有14个空格，因为在源代码中`its`前面有14个空格。因此，您应该谨慎使用原始字符串。
- en: 'Perhaps, the best use for raw strings is to initialize variables with file
    paths on Windows. The folder separation character in Windows is a backslash, which
    means that for a literal string that represents a file path you will have to escape
    each of these separators; thus, the string will have a lot of double backslashes,
    with the possibility of missing one. With raw strings this escaping is not necessary.
    The two string variables in the following represent the same string:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，原始字符串的最佳用途是在Windows上初始化文件路径的变量。在Windows中，文件夹分隔符是反斜杠，这意味着对于表示文件路径的文字字符串，您将不得不转义每个这些分隔符；因此，字符串将有很多双反斜杠，有可能漏掉一个。使用原始字符串，这种转义是不必要的。以下的两个字符串变量代表相同的字符串：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These two strings have the same contents, but the second one is more readable
    since the C++ literal string does not have escaped backslashes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字符串具有相同的内容，但第二个更易读，因为C++文字字符串没有转义反斜杠。
- en: The requirement for escaping backslashes is only needed for literal strings
    declared in your code; it is an indication to the compiler of how to interpret
    the character. If you obtain a file path from a function (or via `argv[0]`), the
    separator will be backslashes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 转义反斜杠的要求仅适用于在代码中声明的文字字符串；这是对编译器如何解释字符的指示。如果您从函数（或通过`argv[0]`）获取文件路径，分隔符将是反斜杠。
- en: String byte order
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串字节顺序
- en: Extended character sets use more than one byte per character. If such characters
    are stored in a file, the order of the bytes becomes important. In this situation,
    the writer of the character must use the same order that will be used by potential
    readers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字符集使用每个字符超过一个字节。如果这些字符存储在文件中，字节的顺序就变得重要起来。在这种情况下，字符的编写者必须使用与潜在读者将要使用的相同顺序。
- en: One way to do this is to use a **Byte Order Mark** (**BOM**). This is a known
    number of bytes with a known pattern, and is typically placed as the first item
    in a stream so that the reader of the stream can use it to determine the byte
    order of the remaining characters in the stream. Unicode defines the 16-bit character,
    `\uFEFF`, and the non-character, `\uFFFE`, as byte order marks. In the case of
    `\uFEFF`, all bits are set except for bit 8 (if the lowest bit is labeled as bit
    0). This BOM can be prefixed to data that is passed between machines. The destination
    machine can read the BOM into a 16-bit variable and test the bits. If bit 8 is
    zero it means the two machines have the same byte order and so the characters
    can be read as two byte values in the order in the stream. If bit 0 is zero then
    it means that the destination machine reads 16-bit variables in the opposite order
    to the source, and so action must be taken to ensure that, with 16-bit characters,
    the bytes are read in the right order.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用**字节顺序标记**（**BOM**）。这是已知字节数和已知模式的一组字节，通常作为流的第一项放置，以便流的读取者可以使用它来确定流中剩余字符的字节顺序。Unicode定义了16位字符`\uFEFF`和非字符`\uFFFE`作为字节顺序标记。对于`\uFEFF`，除了第8位（如果最低位标记为第0位）之外，所有位都被设置。这个BOM可以作为前缀添加到在机器之间传递的数据中。目标机器可以将BOM读入一个16位变量并测试位。如果第8位为零，这意味着两台机器具有相同的字节顺序，因此字符可以按照流中的顺序读取为两个字节值。如果第0位为零，则意味着目标机器以与源机器相反的顺序读取16位变量，因此必须采取措施确保以正确的顺序读取字节。
- en: 'The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字节顺序标记（BOM）序列化如下（十六进制）：
- en: '| **Character set** | **Byte order mark** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **字符集** | **字节顺序标记** |'
- en: '| UTF-8 | EF BB BF |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8 | EF BB BF |'
- en: '| UTF-16 big endian | FE FF |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16大尾 | FE FF |'
- en: '| UTF-16 little endian | FF FE |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16小尾 | FF FE |'
- en: '| UTF-32 big endian | 00 00 FE FF |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32大尾 | 00 00 FE FF |'
- en: '| UTF-32 little endian | FF FE 00 00 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32小尾 | FF FE 00 00 |'
- en: Bear this in mind that, when you read data from a file. The character sequence,
    FE FF, will be very rare in a non-Unicode file, and so if you read these as the
    first two bytes in a file it means that the file is Unicode. Since `\uFEFF` and
    `\uFFFE` are not printable Unicode characters, it means that a file that starts
    with either of these has a byte order mark, and you can then use the BOM to determine
    how to interpret the remaining bytes in the file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bool` type holds a Boolean value, that is, just one of two values: `true`
    or `false`. C++ allows you to treat 0 (zero) as being `false` and anything non-zero
    as being `true` but this can lead to mistakes, so it is better to get in to the
    habit of explicitly checking values:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The second of these two is preferable, since it is clearer what you are comparing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Note that, even if a pointer is not a `nullptr`, it still may not be a valid
    pointer, but it is common practice to assign a pointer to `nullptr` to convey
    some other meaning, perhaps to say that the pointer operation is not appropriate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: You can insert Boolean values into an output stream. However, the default behavior
    is to treat a Boolean as an integer. If you want `cout` to output `bool` values
    with string names, then insert the manipulator `boolalpha` in to the stream; this
    will make the stream print `true` or `false` to the console. The default behavior
    can be achieved by using the `noboolalpha` manipulator.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you need to indicate that a function does not have parameters
    or will not return a value; in both cases, you can use the keyword `void`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The use of `void` in the parameter list is optional; an empty pair of parentheses
    is acceptable and is preferable. This is the only way to indicate that a function
    returns no value other than returning `void`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `void` is not really a type because you cannot create a `void` variable;
    it is the absence of a type. As you''ll find out in the next chapter, you can
    create pointers of the type `void`, but you will not be able to use the memory
    that such pointers point to without casting to a typed pointer: to use the memory
    you have to decide the type of the data that the memory holds.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Initializers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initializers were touched upon in the last chapter, but we will go into more
    depth here. For built-in types, you must initialize a variable before you use
    it. For custom types, it is possible for the type to define a default value, but
    there are some issues in doing this, which will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'In all versions of C++, there are three ways to initialize a built-in type:
    assignment, function syntax, or calling a constructor. In C++11 another way to
    initialize variables was introduced: construction through a list initializer.
    These four ways are shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first of these three is the clearest; it shows, using an easy to understand
    syntax, that the variable is being initialized to a value. The second example
    initializes a variable by calling the type as if it is a function. The third example
    calls the constructor of the `int` type. This is a typical way to initialize custom
    types, so it is best to reserve this syntax just for custom types.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth syntax is new to C++11 and initializes the variable using an initialize
    list between curly braces (`{}`). Just to confuse things slightly, you can also
    initialize a built-in type using the same syntax as an assignment to a single
    item list:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is really confusing things, the type `n` is an integer, not an array.
    Recall that, in the last chapter, we created an array with the birth dates of
    The Beatles:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This creates an array of four integers; the type of each item is `int` but
    the type of the array variable is `int*`. The variable points to memory that holds
    four integers. Similarly, you can also initialize a variable to be an array of
    one item:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is exactly the same initialization code that C++11 allows to initialize
    a single integer. In addition, the same syntax is used to initialize instances
    of record types (`structs`), adding another level of potential confusion about
    what the syntax means.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: It is best to avoid using the curly brace syntax for variable initialization
    and use it exclusively for initializing lists. However, there are advantages to
    this syntax for casting, as explained shortly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The curly brace syntax can be used to provide the initial values for any of
    the collection classes in the C++ Standard Library, as well as for C++ arrays.
    Even when used to initialize a collection object, there is a potential for confusion.
    For example, consider the `vector` collection class. This can hold a collection
    of the type provided through a pair of angled brackets (`<>`). The capacity of
    an object of this class can grow as you add more items to the object, but you
    can optimize its use by specifying an initial capacity:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first line of this code says: create a `vector` object that can hold integers
    and start by reserving space for 42 integers, each initialized to a value of zero.
    The second line prints the size of the vector to the console (42) and the third
    line prints all the items in the array to the console and it will print 42 zeros.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There is only one change here: the parentheses have been changed to braces
    but it means that the initialization has been changed entirely. The first line
    now means: create a `vector` that can hold integers and initialize it with the
    single integer, 42\. The size of `a2` is 1 and the last line will print just one
    value, 42.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The great power of C++ is that it should be easy to write correct code, and
    to persuade the compiler to help you to avoid mistakes. The use of braces for
    single item initialization increases the possibility of hard-to-find errors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables of built-in types should be initialized before you first use them,
    but there are some situations when the compiler will provide a default value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'If you declare a variable at file scope, or globally in your project, and you
    do not give it an initial value, the compiler will give it a default value. For
    example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This code will compile and run, printing a value of 1; the compiler has initialized
    `outside` to 0, which is then incremented to 1\. The following code will not compile:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The compiler will complain that the increment operator is being used on an uninitialized
    variable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we saw another example of the compiler providing a default
    value: `static`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a simple function that maintains a count. The variable `count` is marked
    with the `static` storage class modifier, meaning that the variable has the same
    lifetime as the application (allocated when the code starts and deallocated when
    the program ends); however, it has internal linkage, meaning the variable can
    only be used within the scope of where it is declared, the `counter` function.
    The compiler will initialize the `count` variable with a default value of zero,
    so that the first time the `counter` function is called it will return a value
    of 1.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'The new initialize list syntax of C++11 provides a way for you to declare a
    variable and specify that you want it initialized by the compiler to the default
    value for that type:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Of course, when reading this code, you have to know what the default value
    for an `int` is (it is zero). Again, it is much easier and more explicit to simply
    initialize the variable to a value:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The rules for default values are simple: a value of zero. Integers and floating
    point numbers have a default value of 0, for a character the default value is
    `\0`, for a `bool` it is `false,` and for a pointer the default is the constant,
    `nullptr`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Declarations without a type
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 introduces a mechanism for declaring that a variable's type should be
    determined from the data it is initialized with, that is, `auto`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: There is a minor confusion here because prior to C++11, the `auto` key was used
    to declare **automatic** variables, that is, variables that are automatically
    allocated on the stack in a function. Other than variables declared at file scope
    or as `static`, all the other variables in this book so far have been automatic
    variables and automatic variables are the most widely used **storage class** (explained
    shortly). Since it was optional and applicable to most variables, the `auto` keyword
    was rarely used in C++, so C++11 took advantage of this, removed the old meaning,
    and gave `auto` a new meaning.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If you are compiling old C++ code with a C++11 compiler and that old code uses
    `auto`, you will get errors because the new compiler will assume `auto` will be
    used with variables with no specified type. If this happens, simply search and
    delete each instance of `auto`; it was redundant in C++ prior to C++11, and there
    was little reason for a developer to use it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auto` keyword means that the compiler should create a variable with the
    type of the data that is assigned to it. The variable can only have a single type,
    the type the compiler decides is the type it needs for the data assigned to it,
    and you cannot use the variable elsewhere to hold data of a different type. Because
    the compiler needs to determine the type from an initializer, it means that all
    `auto` variables must be initialized:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that there is no syntax to specify that an integer value is a single byte
    or two bytes, so you cannot create `unsigned char` variables or `short` variables
    this way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a trivial use of the `auto` keyword and you should not use it this
    way. The power of auto is when you use containers that can result in some fairly
    complicated looking types:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This code uses the `vector` container we have used before, but it stores two
    value items using a `tuple`. The `tuple` class is simple; you declare a list of
    the types of items in the `tuple` object in the declaration between the angle
    brackets. So, the `tuple<string, int>` declaration says that the object will hold
    a string and an integer, in that order. The `make_tuple` function is provided
    by the C++ Standard Library and will create a `tuple` object containing the two
    values. The `push_back` function will put the item into the vector container.
    After the four calls to the `push_back` function, the `beatles` variable will
    contain four items and each one is a `tuple` with a name and birth year.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The range `for` loops through the container and on each loop assigns the `musician`
    variable with the next item in the container. The values in the `tuple` are printed
    to the console in the statements in the `for` loop. An item in the `tuple` is
    accessed using the `get` parameterized function (from `<tuple>`) where the parameter
    in the angle brackets indicates the index of the item (indexed from zero) to get
    from the `tuple` object passed as a parameter in the parentheses. In this example,
    the call to `get<0>` gets the name which is printed out, then a space, and then
    `get<1>` gets the year item in the `tuple`. The result of this code is:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This text has poor formatting because it does not take into account the length
    of the names. This can be addressed using manipulators explained in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at the `for` loop:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The type of musician is `tuple<string, int>;`, this is a fairly simple type,
    and as you use the standard template more you could end up with some complicated
    types (particularly when you use **iterators**). This is where `auto` becomes
    useful. The following code is the same, but easier to read:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The musician variable is still typed, it is a `tuple<string, int>`, but `auto`
    means you do not have to explicitly code this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Storage classes
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When declaring a variable, you can specify its storage class which indicates
    the lifetime, linkage (what other code can access it), and memory location of
    the variable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen one storage class, `static`, which when applied to a variable
    in a function means that the variable can only be accessed within that function,
    but its lifetime is the same as the program. However, `static` can be used on
    variables declared at file scope, in which case it indicates that the variable
    can only be used in the current file, which is called **internal linkage**. If
    you omit the `static` keyword on a variable, defined at file scope, then it has
    an **external linkage,** which means the name of the variable is visible to code
    in other files. The `static` keyword can be used on a data member of a class,
    and on methods defined on a class, both of which have interesting effects that
    will be described in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The `static` keyword says that the variable can only be used in the current
    file. The `extern` keyword indicates the opposite; the variable (or function)
    has external linkage and can be accessed in other files in the project. In most
    cases, you will define a variable in one source file, and then declare it as `extern`
    in a header file so that the same variable can be used in other source files.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The final storage class specifier is `thread_local`. This is new to C++11 and
    it only applies to multithreaded code. This book does not cover threading, so
    only a brief description will be given here.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: A thread is a unit of execution and concurrency. You can have more than one
    thread running in a program, and it is possible to have two or more threads running
    the same code at the same time. This means that two different threads of execution
    could access and alter the same variable. Since concurrent access may have undesirable
    effects, multithreaded code often involves taking action to ensure that only one
    thread can access data at any time. If such code is not written carefully there
    is a danger of deadlocks, where the execution of threads is paused (in the worst
    cases, indefinitely) for exclusive access to the variable, negating the benefit
    of using threads.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The `thread_local` storage class indicates that each thread will have its own
    copy of a variable. So, if two threads access the same function and a variable
    in that function is marked as `thread_local,` it means that each thread only sees
    the changes it makes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: You will sometimes see the storage class `register` used in older C++ code.
    This is now deprecated. It was used as a hint to the compiler that the variable
    has important consequences on the performance of the program and suggests to the
    compiler that if possible it should use a CPU register to hold the variable. The
    compiler could ignore this suggestion. In fact, in C++11 the compiler literally
    does ignore the keyword; code with `register` variables will compile with no errors
    or warnings and the compiler will optimize the code however it feels is necessary.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not a storage class specifier, the `volatile` keyword has an
    effect on compiler code optimization. The `volatile` keyword indicates that a
    variable (perhaps through **Direct Memory Access** (**DMA**) to some hardware)
    can be altered by an external action, and so it is important that the compiler
    *does not* apply any optimizations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: There is one other storage class modifier called `mutable`. This can only be
    used on class members and so it will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Using type aliases
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes the names of types can become quite cumbersome. If you use nested
    namespaces, the name of a type includes all of the namespaces used. If you define
    parameterized types (examples used so far in this chapter are `vector` and `tuple`),
    the parameters increase the name of the type. For example, earlier we saw a container
    for the names and birth years of musicians:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, the container is a `vector` and it holds items that are `tuple` items,
    each of which will hold a string and an integer. To make the type easier to use
    you could define a preprocessor symbol:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now you can use `name_year` instead of the `tuple` in your code, and the preprocessor
    will replace the symbol with the type before the code is compiled:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, because `#define` is a simple search and replace, there can be problems
    as explained earlier in this book. C++ provides the `typedef` statement to create
    an alias for a type:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, an alias called `name_year_t` is created for `tuple<string, int>`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: With a `typedef,` the alias usually comes at the end of the line preceded by
    the type it aliases. This is the opposite order to `#define,` where the symbol
    you are defining comes after `#define`, followed by its definition. Note also
    `typedef` is terminated with a semicolon. It becomes much more complicated with
    function pointers, as you'll see in [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml),
    *Using Functions*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, wherever you want use the `tuple`, you can use the alias:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can `typedef` aliases:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The type of the `beatles2` variable is `vector<tuple<string, int>>`. It is important
    to note that `typedef` creates an alias; it does not create a new type, so you
    can switch between the original type and its alias.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The `typedef` keyword is a well-established way to create aliases in C++.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 introduces another way to create a type alias, the `using` statement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Again, this does not create a new type, it creates a new name for the same type,
    and semantically, this is the same as `typedef`. The `using` syntax can be more
    readable than using a `typedef` and it also allows you to use templates.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The `using` method of creating an alias is more readable than `typedef` because
    the use of the assignment follows the convention used for variables, that is,
    the new name on the left is used for the type on the right of the `=`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating data in record types
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often you will have data that is related and must be used together: an aggregated
    type. Such a record type allows you to encapsulate data into a single variable.
    C++ inherits from C `struct` and `union`, as ways of providing records.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most applications, you will want to associate several data items together.
    For example, you may want to define a time record that has an integer for each
    of the following: the hour, the minute, and the second of the specified time.
    You can declare them like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This approach becomes quite cumbersome and error-prone. There is no encapsulation,
    that is, the `_min` variables can be used in isolation to the other variables.
    Does the *minutes past the hour* make sense when it is used without the hour that
    it refers to? You can define a structure that associates these items:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now you have the three values as part of one record, which means that you can
    declare variables of this type; although you can access individual items it is
    clear that the data is associated with the other members:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we have two variables: one that represents the start time, and the other
    that represents the end time. The members of a `struct` are encapsulated within
    the `struct`, that is, you access the member through the instance of the `struct`.
    To do this, you use the dot operator. In this code, `start_work.sec` means that
    you are accessing the `sec` member of the instance of the `time_of_day` structure
    called `start_work`. The members of a structure are `public` by default, that
    is, code outside the `struct` has access to the members.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Classes and structures can indicate the level of member access, and [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*, will show how to do
    this. For example, it is possible to mark some members of a `struct` as `private`,
    which means that only code that is a member of the type can access the member.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'A helper function called `print_time` is called to print the data to the console:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this case, the `setw` and `setfill` manipulators are used to set the width
    of the next inserted item to two characters and to fill any unfilled places with
    zeros (more details will be given in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*; in effect, `setw` gives the size of the column occupied by the
    next inserted data, and `setfill` specifies the padding character used).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*,
    will go into more detail about the mechanism of passing structures to functions
    and the most efficient way to do it, but for the purpose of this section we will
    use the simplest syntax here. The important point is that the caller has associated
    the three items of data together using a `struct` and all the items can be passed
    to a function as a unit.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Initializing
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to initialize an instance of a structure. The preceding
    code shows one method: accessing the member using the dot operator, and assigning
    it a value. You can also assign values to an instance of a `struct` through a
    specially provided function called a constructor. Since there are special rules
    about how to name a constructor and what you can do in them, this will be left
    until [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also initialize structures using the list initializer syntax using
    curly braces (`{}`). The items in the braces should match the members of the `struct`
    in the order of the members as declared. If you provide fewer values than there
    are members, the remaining members are initialized to zero. Indeed, if you provide
    no items between the curly braces then all members are set to zero. It is an error
    to provide more initializers than there are members. So, use the `time_of_day`
    record type defined previously:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the first example, the `lunch` variable is initialized to 1 PM. Notice that,
    because the `hour` member is declared as the third member in the type, it is initialized
    using the third item in the initialize list. In the second example, all members
    are set to zero, and of course, zero hours is midnight. The third example provides
    two values, so these are used to initialize `sec` and `min`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have a member of a `struct` that is a `struct` itself, and this is
    initialized using nested braces:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Structure fields
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A structure can have members that are as small as a single bit, called a **bit-field**.
    In this case, you declare an integer member with the number of bits that the member
    will take up. You are able to declare unnamed members. For example, you may have
    a structure that holds information about the length of an item, and whether the
    item has been changed (is dirty). The item this refers to has a maximum size of
    1,023, so you need an integer with at least 10 bits of width to hold this. You
    could use an `unsigned short` to hold both the length and the dirty information:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code separates the two pieces of information, and then prints them out.
    A bitmap like this is quite unfriendly to code. You can use a `struct` to hold
    this information using an `unsigned short` to hold the 10 bits of length information
    and a `bool` to hold the dirty information. Using bit fields you can define the
    structure like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `len` member is marked as `unsigned short` but only 10 bits are needed,
    so this is mentioned using the colon syntax. Similarly, a Boolean yes/no value
    can be held in just one bit. The structure indicates that there are five bits
    between the two values that are not used, and so have no name.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields are simply a convenience. Although it looks like the `item_length` structure
    should only take up 16 bits (`unsigned short`), there is no guarantee that the
    compiler will do this. If you receive an `unsigned short` from a file or network
    stream you will have to extract the bits yourself:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using structure names
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you may need to use a type before you have actually defined
    it. As long as you do not use the members, you can declare a type before defining
    it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This could be declared in a header, where it says that there is a function defined
    somewhere else that takes a `time_of_day` record and prints it out. To be able
    to declare the `print_day` function, you have to have declared the `time_of_day`
    name. The `time_of_day` struct must be defined somewhere else in your code before
    the function is defined, otherwise you will get an *undefined type* error.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, an exception: a type can hold pointers to instances of the
    same type before the type is fully declared. This is because the compiler knows
    the size of a pointer, so it can allocate sufficient memory for the member. It
    is not until the entire type has been defined before you can create an instance
    of the type. The classic example of this is a linked list, but since this requires
    using pointers and dynamic allocation, that will be left to the next chapter.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Determining alignment
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the uses of structs is that if you know how data is held in memory you
    can deal with a struct as a block of memory. This is useful if you have a hardware
    device that is mapped into memory, where different memory locations refer to values
    controlling or returning values from the device. One way to access the device
    would be to define a struct that matches the memory layout of the device''s direct
    memory access to C++ types. Further, structs are also useful for files, or for
    packets of data that need to be transmitted over the network: you manipulate the
    struct and then copy the memory occupied by the struct to the file or to the network
    stream.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The members of the struct are arranged in memory in the order that they are
    declared in the type. The items will take up *at least* as much memory as each
    type requires. A member may take more memory than the type requires, and the reason
    for this is a mechanism called **alignment**.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler will place variables in memory in the way that is the most efficient,
    in terms of memory usage, or speed of access. The various types will be aligned
    to alignment boundaries. For example, a 32-bit integer will be aligned to a four-byte
    boundary, and if the next available memory location is not on this boundary the
    compiler will skip a few bytes and put the integer at the next alignment boundary.
    You can test the alignment of a specific type using the `alignof` operator passing
    the type name:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The alignment of an `int` is 4 and this means that an `int` variable will be
    placed at the next four-byte boundary in memory. The alignment of a `double` is
    8 and this makes sense because in Visual C++ a `double` occupies eight bytes.
    So far, it looks like the result of `alignof` is the same as `sizeof`; however,
    this is not so.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This example prints the alignment of the `time_of_day` struct, which we previously
    defined to be three integers. The alignment of this `struct` is 4, that is, the
    alignment of the largest item in the `struct`. This means that an instance of
    `time_of_day` will be placed on a 4-byte boundary; it does not say how the items
    within the `time_of_day` variable will be aligned.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following `struct`, which has four members that
    occupy respectively one, two, four, and eight bytes:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The compiler will tell you that the alignment is 8 (the alignment of the largest
    item, `ull`), but that the size is 16, which may appear a little odd. If every
    item were aligned on 8-byte boundaries, then the size would have to be 32 (four
    times eight). If the items were stored in memory and packed as efficiently possible,
    then the size would be 15\. Instead, what is happening is that the second item
    is aligned on a two-byte boundary, which means that there is one byte of unused
    space between `uc` and `us`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7623b00b-908e-4290-9bc8-897ab73ff91e.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: 'If you want to align the internal items onto, say, the same boundaries as used
    by a `uint32_t` variable, you can mark an item with `alignas` and give the alignment
    that you need. Note that, because 8 is bigger than 4, any item aligned on an 8-byte
    boundary will also be aligned on a 4-byte boundary:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `uc` item will be aligned on a 4-byte boundary already (`alignof(test)`
    will be 8), and it will occupy one byte. The `us` member is a `uint16_t` but it
    is marked with `alignas(uint32_t)` to say that it should be aligned in the same
    way as a `uint32_t`, that is, on a 4-byte boundary. This means that both `uc`
    and `us` will be on 4-byte boundaries with padding provided. Of course, the `ui`
    member will also be aligned on a 4-byte boundary because it is a `uint32_t`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `struct` has just these first three members, then the size would be
    12\. However, the `struct` has another member, the 8-byte `ull` member. This must
    be aligned on an 8-byte boundary, which means 16 bytes from the beginning of the
    `struct`, and to do this there needs to be 4 bytes of padding between `ui` and
    `ull`. As a consequence, the size of `test` is now reported as 24: 4 bytes for
    `uc` and for `us` (because the following item `ui` has to be aligned on the next
    four-byte boundary), 8 bytes for `ull` (because it is an 8-byte integer), and
    8 bytes for `ui` because the following item (`ull`) has to be on the next 8-byte
    boundary.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the location in memory of the various members of
    the `test` type:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f6fc03-7112-4760-a585-5d112f9cc07c.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: You cannot use `alignas` to relax alignment requirements, so you cannot mark
    a `uint64_t` variable to be aligned on a two-byte boundary that is not also an
    eight-byte boundary.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will not need to worry about alignment; however, if you are
    accessing memory-mapped devices, or binary data from files, it is convenient if
    you can directly map this data to a `struct` and in this case, you will find that
    you will have to pay close attention to alignment. This is known as **plain old
    data** and you will often see structs referred to as **POD types**.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: POD is an informal description, and sometimes it is used to describe types that
    have a simple construction and do not have virtual members (see [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*
    and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction to
    Object-Oriented Programming*). The standard library provides a function in `<type_traits>`
    called `is_pod` that tests a type for these members.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in the same memory with unions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A union is a struct where all the members occupy the same memory. The size of
    such a type is the size of the largest member. Since a union can only hold one
    item of data, it is a mechanism to interpret the data in more than one way.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a union is in the `VARIANT` type that is used to pass data between
    **Object Linking and Embedding** (**OLE**) objects in Microsoft''s **Component
    Object Model** (**COM**). The `VARIANT` type can hold data of any of the data
    types that COM is able to transmit between OLE objects. Sometimes OLE objects
    will be in the same process, but it is possible for them to be in different processes
    on the same machine or on different machines. COM guarantees that it can transmit
    `VARIANT` without the developer providing any additional networking code. The
    structure is complicated, but an edited version is shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Notice that you can use a union without a name: this is an anonymous `union`
    and from a member access point of view you access a member of the union as if
    it is a member of the `VARIANT` that contains it. The `union` contains a member
    for every type that can be transmitted between OLE objects, and the `vt` member
    indicates which one is used. When you create a `VARIANT` instance, you have to
    set `vt` to the appropriate value and then initialize the related member:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This record ensures that only the memory that is needed is used, and the code
    that transmits the data from one process to another will be able to read the `vt`
    member to determine how the data needs to be processed so that it can be transmitted:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that you must be disciplined and only initialize the appropriate member.
    When your code receives a `VARIANT,` you must read `vt` to see which member you
    should use to access the data.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, when using unions you should access only the item that you initialize:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Accessing runtime type information
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ provides an operator called `typeid` that will return type information
    about a variable (or a type) at runtime. **Runtime Type Information** (**RTTI**)
    is significant when you use custom types that can be used in a **polymorphic**
    way; details will be left until later chapters. RTTI allows you to check at runtime
    the type of a variable and process the variable accordingly. RTTI is returned
    through a `type_info` object (in the `<typeinfo>` header file):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In both cases, you''ll see int printed as the type. The `type_info` class defines
    comparison operators (`==` and `!=`) so you can compare types:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Determining type limits
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<limits>` header contains a template class called `numeric_limits` and
    this is used through the specializations provided for each of the built-in types.
    The way to use these classes is to provide the type you want information for in
    the angle brackets and then call the `static` members on the class using the scope
    resolution operator (`::`). (Full details of `static` functions on classes will
    be given in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*).
    The following prints the limits of the `int` type to the console:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Converting between types
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you try exceptionally hard to use the correct types in your code, at
    some point you will find that you will have to convert between types. For example,
    you may be using library functions that return a value of a particular type, or
    you may be reading in data from an external source that is a different type to
    your routine.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: With built-in types, there are standard rules about conversion between different
    types, some of which will be automatic. For example, if you have an expression
    like `a + b`, and `a` and `b` are different types, then, if it is possible, the
    compiler will automatically convert one variable's value to the type of the other
    and the `+` operator for that type will be called.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, you may need to force one type to another type so that the right
    operator is called and this will require a cast of some kind. C++ allows you to
    use C-like casts, but these do not have runtime tests, so it is far better to
    use C++ casts, which have various levels of runtime checks and type safety.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Built-in conversions can have one of two outcomes: promotion or narrowing.
    A promotion is when a smaller type is promoted to a larger type and you will not
    lose data. A narrowing conversion happens when a value from a larger type is converted
    to a smaller type with potential loss of data.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Promoting conversions
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a mixed type expression, the compiler will attempt to promote smaller types
    to the larger type. So, a `char` or a `short` can be used in an expression where
    an `int` is needed because it can be promoted to the larger type with no loss
    of data.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function declared as taking a parameter that is an `int`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can write:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here the variable `s` is silently converted to an `int`. There are some cases
    that may appear odd:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Again, the conversion is silent. The compiler assumes you know what you are
    doing and that your intention is that you want `false` treated as 0 and `true`
    treated as 1.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing conversions
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, *narrowing* occurs. Be very careful of this because it loses
    data. In the following, an attempt is made to convert a `double` into an `int`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This is allowed, but the compiler will issue a warning:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This code is clearly wrong, but the mistake is not an error because it may
    be intentional. For example, in the following code we have a function that has
    a parameter that is a floating point, and within the routine the parameter is
    used to initialize an `int`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This may be intentional, but because there will be a loss of precision you should
    document why you are doing this. At the very least, use a cast operator so that
    it is obvious that you understand the consequence of the action.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing to bool
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, pointers, integers, and floating point values can
    be implicitly converted to `bool` where a nonzero value converts to `true` and
    a zero value converts to `false`. This can result in a nasty bug that is difficult
    to notice:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, the compiler sees the assignment expression `x = 1`, which is a bug; it
    should be the comparison `x == 1`. However, this is valid C++ because the value
    of the expression is 1 and the compiler, helpfully, converts this to a `bool`
    value of `true`. This code will compile without even a warning, and not only will
    it produce a result that is the opposite of what you expect (you'll see `not zero`
    printed on the console), but also the assignment will have changed the value of
    the variable propagating the error throughout the program.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to avoid this bug by getting into the habit of always constructing
    a comparison so that the rvalue of a potential assignment is on the left. In a
    comparison, there will be no concept of rvalue or lvalue, so this uses the compiler
    to catch an assignment when it is not intended:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Converting signed types
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Signed to unsigned conversions can happen and can cause unexpected results.
    For example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `unsigned short` variable will be assigned with a value of `0xfffffffd`,
    that is, the two's compliment of 3\. This may be the result you want, but it is
    an odd way of getting it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, if you try and compare these two variables, the compiler will
    issue a warning:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The Visual C++ warning C4018 given here is `''<'': signed/unsigned mismatch`,
    which says that you cannot compare a signed and unsigned type, and to do so would
    need a cast.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you will have to convert between types. For example, this may
    be because the data is provided in a different type to the routines that you use
    to process it. You may have a library that processes floating point numbers as
    `float`, but your data is inputted as `double`. You are aware that the conversion
    will lose precision but know that this will have little effect on the final result
    so you do not want the compiler warning you. What you want to do is tell the compiler
    that the coercion of one type to another is acceptable.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the various cast operations you can use in C++11:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Syntax** |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| Construction | `{}` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| Remove `const` requirement | `const_cast` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| Cast with no runtime checks | `static_cast` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| Bitwise casting of types | `reinterpret_cast` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| Cast between class pointers, with runtime checks | `dynamic_cast` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| C style | `()` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| Function style | `()` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: Casting away const-ness
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the last chapter, the `const` specifier is used to indicate
    to the compiler that an item will not change, and that any attempt by your code
    to change the item is an error. There is another way to use this specifier, which
    will be explored in the next chapter. When `const` is applied to a pointer, it
    indicates that the memory that the pointer points to cannot be changed:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This badly written code tells the compiler to create a string constant with
    the value `0123456` and then put the address of this memory into the string pointer
    `ptr`. The final line attempts to write to the string. This will compile but it
    will cause an access violation at runtime. Applying `const` to the pointer declaration
    will ensure that the compiler will check for such situations:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'More typical cases are applying `const` to pointers that are function parameters
    and the intention is the same: it indicates to the compiler that the data the
    pointer points to should be read-only. However, there may be situations when you
    want to remove the `const` property of such a pointer, and this is carried out
    using the `const_cast` operator:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The syntax is simple. The type that you want to convert to is given in the angle
    brackets (`<>`) and the variable (which is a `const` pointer) is provided in the
    parentheses.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: You can also cast a pointer *to* a `const` pointer. This means that you can
    have one pointer that you can use to access the memory so that you can write to
    it, and then after you have made changes, you create a `const` pointer to the
    memory, in effect making the memory read-only through the pointer.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, once you have cast away the const-ness of a pointer you take responsibility
    for the damage that you do by writing to the memory, so the `const_cast` operator
    in your code is a good marker for you to examine code during a code review.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Casting without runtime checks
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most casts are performed using the `static_cast` operator, and this can be
    used to convert pointers to related pointer types as well as converting between
    numeric types. There are no runtime checks performed so you should be certain
    that the conversion is acceptable:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here a `double` is converted to an `int`, which means that the fractional part
    is discarded. Normally the compiler would issue a warning that data is lost, but
    the `static_cast` operator shows that this is your intention and hence the warning
    is not given.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The operator is often used to convert `void*` pointers to a typed pointer. In
    the following code the `unsafe_d` function assumes that the parameter is a pointer
    to a double value in memory, and so it can convert the `void*` pointer to a `double*`
    pointer. The `*` operator used with the `pd` pointer *dereferences* the pointer
    to give the data that it points to. Thus, the `*pd` expression will return a `double`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This is unsafe because you rely on the caller to ensure that the pointer actually
    points to a `double`. It could be called like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `&` operator returns the memory address of the operand as a typed pointer.
    In the first case, a `double*` pointer is obtained and passed to the `unsafe_d`
    function. The compiler will automatically convert this pointer to the `void*`
    parameter. The compiler does this automatically with no checks that the pointer
    will be used correctly in the function. This is illustrated by the second call
    to `unsafe_d` where the `int*` pointer is converted to the `void*` parameter and
    then in the `unsafe_d` function it is cast by `static_cast` to a `double*` even
    though the pointer points to an `int`. Consequently, the dereference will return
    unpredictable data and `cout` will print nonsense.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Casting pointers without runtime checks
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reinterpret_cast` operator allows pointers to one type to be converted
    to pointers of another type, and it can convert from a pointer to an integer and
    an integer to a pointer:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Unlike `static_cast`, this operator always involves a pointer: converting between
    pointers, converting from a pointer to an integral type, or converting from an
    integral type to a pointer. In this example, a pointer to a `double` variable
    is converted to an `int` and the value printed to the console. In effect, this
    prints out the memory address of the variable.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Casting with runtime checks
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dynamic_cast` operator is used to convert pointers between related classes,
    and for this reason it will be explained in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. This operator involves runtime checks so that the conversion is only
    performed if the operand can be converted to the specified type. If the conversion
    is not possible then the operator returns `nullptr`, giving you an opportunity
    to only use converted pointers that point to an actual object of that type.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Casting with list initializer
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ compiler will allow some implicit conversions; in some cases, they
    may be intentional and in some cases, they may not be. For example, the following
    code is similar to code shown before: a variable is initialized to a `double`
    value and then later in the code it is used to initialize an `int`. The compiler
    will perform the conversion, and will issue a warning:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If you ignore warnings then you may not notice this loss of precision, which
    may cause a problem. One way to get around this issue is to use initialization
    using curly braces:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In this case, if `pi` can be converted to an `int` without loss (for example,
    if `pi` is a `short`) then the code will compile without even a warning. However,
    if `pi` is an incompatible type (in this case, a `double`) the compiler will issue
    an error:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here''s an interesting example. The `char` type is an integer, but the `<<`
    operator for `char` from the `osteam` class interprets a `char` variable as being
    a character, not a number, as per the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This will print `#` on the console, not 35, because 35 is the ASCII code for
    "#". To get the variable to be treated as a number you can use one of the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, the second version (construction) is just as readable, but is
    shorter than the first.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Using C casts
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, you can use C style casts, but these are provided only so that you
    can compile legacy code. You should use one of the C++ casts instead. For completeness,
    the C style casts are shown here:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'There are two versions: the first cast operator has the parentheses around
    the type to cast to, and in the second one the cast looks like a function call.
    In both cases, it would be better to use `static_cast` so that there is compile-time
    checking.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ types
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part of the chapter, we will develop a command-line application
    that allows you to print out the contents of a file in a mixed alphanumeric and
    hex format.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The application must be run with the name of a file, but optionally you can
    specify how many lines to print. The application will print on the console the
    contents of the file, 16 bytes per line. On the left, it gives the hex representation
    and on the right, it gives the printable representation (or a dot if the character
    is not in the printable non-extended ASCII range).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e2cc9a-8fb1-46fe-bb11-17960072dfb7.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'Create a new folder under `C:\Beginning_C++` called `Chapter_03`. Start Visual
    C++ and create a C++ source file, and save it to the folder you just created as
    `hexdump.cpp`. Add a simple `main` function that allows the application to accept
    parameters, and provides support for input and output using C++ streams:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The application will have up to two parameters: the first is the name of the
    file and the second is the number of 16-byte blocks to print on the command-line.
    This means that you''ll need to check that the parameters are valid. Start by
    adding a `usage` function to give the application parameters and, if called with
    a non-null parameter, print out an error message:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Add this function before the `main` function so that you can call it from there.
    The function can be called with a pointer to a C string or with `nullptr`. The
    parameter is `const`, indicating to the compiler that the string will not be changed
    in the function, so if there is any attempt to change the string, the compiler
    will generate an error.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the `main` function:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Compile the file and confirm that there are no typos. Since this application
    uses the C++ Standard Library, you have to provide support for C++ exceptions
    with the `/EHsc` switch:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You can test the application invoking it from the command-line with zero, one,
    two, and then three parameters. Confirm that the application will only allow it
    to be called with one or two parameters on the command-line (which actually means
    two or three parameters since `argc` and `argv` include the application name).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is to determine if the user provided a number to indicate how
    many 16-byte blocks to dump to the console and, if so, convert the string provided
    by the command line into an integer. This code will perform the conversion from
    a string to a number using the `istringstream` class, so you need to include the
    header file where this class is defined. Add the following to the top of the file:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'After the declaration of the `filename` variable add the following highlighted
    code:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: By default, the application will dump one line of data (up to 16 bytes) from
    the file. If the user provided a different number of lines, the string-formatted
    number is converted to an integer by using an `istringstream` object. This is
    initialized with the argument and then the number is extracted from the stream
    object. If the user typed a value of zero, or if they typed a value that cannot
    be interpreted as a string, the code prints an error message. The error string
    is split over two lines, but it is still one string.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, the `if` statement uses short-circuiting; that is, if the first
    part of the expression (`ss.fail()`, meaning the conversion failed), is `true`,
    then the second expression (`0 >= blocks`, that is `blocks` must be greater than
    zero) will not be evaluated.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile this code and try it several times. For example:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The first two should run without an error; the second two should generate an
    error.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry that `readme.txt` does not exist, as it is only here as a test parameter.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll add the code to open a file and process it. Since you''ll use
    the `ifstream` class to input data from a file, add the following header file
    to the top of the file:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Then at the bottom of the `main` function add the code to open the file:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The first line creates a stream object called `file` and this is attached to
    the file specified through the path given in `filename`. If the file cannot be
    found, the `good` function will return `false`. This code negates the value using
    the `!` operator so that if the file *does not exist* the statements in the braces
    following the `if` are executed. If the file exists and the `ifstream` object
    can open it, the data is read 16 bytes at a time in a `while` loop. Notice that
    at the end of this code the `close` function is called on the `file` object. It
    is good practice to explicitly close resources when you have finished with them.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The file will be accessed by the `read16` function on a byte-by-byte basis,
    including non-printable bytes, so that control characters like `\r` or `\n` have
    no special meaning and are still read in. However, the stream class treats the
    `\r` character in a special way: this is treated as the end of a line and normally
    the stream will silently consume this character. To prevent this, we open the
    file in binary mode using `ios::binary`.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the `while` statement again:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: There are two expressions here. The first expression decrements the `blocks`
    variable, which holds the number of 16-byte blocks that will be printed. The postfix
    decrement means that the value of the expression is the value of the variable
    *before* the decrement, so if the expression is called when `blocks` is zero the
    whole expression is short-circuited and the `while` looping ends. If the first
    expression is non-zero, then the `read16` function is called and if this returns
    a value of -1 (the end of the file is reached), the looping finishes. The actual
    work of the loop occurs within the `read16` function, so the `while` loop statement
    is the empty statement.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you must implement the `read16` function just above the `main` function.
    This function will use a constant that defines the length of each block, so add
    the following declaration near the top of the file:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Just before the `main` function, add this code:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This is just skeleton code for the function. You'll add more code in a moment.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: This function will read up to 16 bytes at a time and print the contents of those
    bytes to the console. The return value is the number of bytes that were read or
    -1 if the end of the file was reached. Notice the syntax used to pass the stream
    object to the function. This is a **reference**, a type of pointer to the actual
    object. The reason why a reference is used is because if we do not do this the
    function will get a *copy* of the stream. References will be covered in the next
    chapter and using object references as function parameters will be covered in
    [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: The first line of this function test is to verify whether the end of the file
    has been reached, and if so, no more processing can be done and the value of -1
    is returned. The code will manipulate the `cout` object (for example, inserting
    the `hex` manipulator); and so that you always know the state of this object outside
    of the function, the function ensures that when it returns the `cout` object is
    in the same state as when the function was called. The initial formatting state
    of the `cout` object is obtained by calling the `flags` function, and this is
    used to reset the `cout` object just before the function returns by calling the
    `setf` function.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: This function does nothing, so it is safe to compile the file and confirm that
    you have no typos.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read16` function does three things:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: It reads in, byte-by-byte, up to 16 bytes.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints out the hex value of each byte.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints out the printable value of the byte.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that each line has two parts: the hex part on the left, and the
    printable part on the right. Replace the comment in the function with the highlighted
    code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `for` loop will loop for a maximum of `block_length` times. The first statement
    reads a single character from the stream. This byte is read in as raw data. If
    `get` finds that there are no more characters in the stream, it will set a flag
    in the stream object, and this is tested by calling the `eof` function. If the
    `eof` function returns `true` it means that the end of the file has been reached
    and so the `for` loop finishes, but the function does not return immediately.
    The reason is that *some* bytes may have been read so more processing must be
    carried out.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the statements in the loop do two things:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: There are statements to print the hex value of the character on the console
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a statement to store the character in a printable form in the `line`
    variable
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already set the `cout` object to output hex values, but if the byte
    is less that 0x10 the value will not be printed prefixed with a zero. To get this
    format, we insert the `setw` manipulator to say that the data inserted will take
    up two character positions and `setfill` to say that a `0` character is used to
    pad the string. These two manipulators are available in the `<iomanip>` header,
    so add them to the top of the file:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Normally, when you insert a `char` into a stream the character value is shown,
    so the `char` variable is cast to a `short` so that the stream will print the
    hex numeric value. Finally, a single space is printed between each item.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'The final lines in the `for` loop are shown here:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This code checks to see if the byte is a printable character (" " to "~") using
    the `isprint` macro and if the character is printable it is appended to the end
    of the `line` variable. If the byte is not printable, a dot is appended to the
    end of the `line` variable as a placeholder.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'The code so far will print the hex representation of the bytes to the console
    one after the other and the only formatting is the space between bytes. If you
    want to test the code, you can compile this and run it on the source file:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'You will see something unintelligible, such as the following:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `23` values are #, `20` are spaces, and `0d` and `0a` are returns and newlines.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to print the character representations in the `line` variable and
    carry out some formatting, and add line breaks. After the `for` loop, add the
    following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There will be at least *two* spaces between the hex display and the character
    display. One space will come from the last character printed out in the `for`
    loop, and the second space is provided in the initialization of the `padding`
    variable.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum number of bytes on each line should be 16 bytes (`block_length`)
    and thus 16 hex values printed on the console. If a fewer number of bytes are
    read then extra padding is required so that over successive lines the character
    representations align. The actual number of bytes read, will be the length of
    the `line` variable obtained by calling the `length` function, so the number of
    missing bytes is the expression `block_length - line.length()`. Since every hex
    representation takes up three characters (two for the digits and one space), the
    padding needed is three times the number of missing bytes. To create the appropriate
    number of spaces, the string constructor is called with two parameters: the number
    of copies and the character to copy.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this padding string is printed to the console followed by the character
    representation of the bytes.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point you should be able to compile the code with no errors or warnings.
    When you run the code on the source file, you should see something like this:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now the bytes make more sense. Since the application does not change the files
    it dumps, it is safe to use this tool on binary files, including itself:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The MZ indicates that this is the DOS header part of Microsoft's **Portable
    Executable** (**PE**) file format. The actual PE header starts on the bottom line
    with the characters, PE.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the various built-in types in C++, how
    to initialize them, and how to use them. You also learned how to convert variables
    to different types using casting operators. The chapter also introduced you to
    record types, a topic that will be expanded on in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. Finally, you have seen various examples of pointers, a topic that will
    be examined in greater detail in the next chapter.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
