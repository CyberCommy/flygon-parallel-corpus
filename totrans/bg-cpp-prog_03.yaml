- en: Exploring C++ Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, you have learned how to put together a C++ program,
    learned about the files you use, and the ways to control execution flow. This
    chapter is about the data that you will use in your program: the type of data
    and the variables that will hold that data.
  prefs: []
  type: TYPE_NORMAL
- en: A variable can handle data of a particular format and with a particular behavior,
    and that is determined by the type of the variable. The type of the variable determines
    the operations you can perform on the data and on the format of the data when
    inputted or viewed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, you can view three general categories of types: built-in types,
    custom types, and pointers. Pointers in general will be covered in the next chapter,
    and custom types, or classes, and pointers to them, will be covered in [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*. This chapter will cover
    the types that are provided as part of the C++ language.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring built-in types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ provides integer, floating point, and Boolean types. The `char` type is
    an integer but it can be used to hold individual characters and so its data can
    be viewed as a number or as a character. The C++ Standard Library provides the
    `string` class to allow you to use and manipulate strings of characters. Strings
    will be covered in depth in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, integer types contain integral values where there are
    no fractional parts. If you perform calculations with integers you should expect
    that any fractional parts will be discarded unless you take steps to retain them
    (for example, through the remainder operator `%`). Floating point types hold numbers
    that may have a fractional part; because floating point types can hold numbers
    in a mantissa exponent format, they can hold exceptionally large or exceptionally
    small numbers.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is an instance of a type; it is the memory allocated to hold the
    data that the type can hold. Integer and floating point variable declarations
    can be modified to tell the compiler how much memory to allocate, and thus the
    limits of the data that the variable can hold and the precision of the calculations
    performed on the variable. In addition, you can also indicate if the variable
    will hold a number where the sign is important. If the number is being used to
    hold bitmaps (where the bits do not make up a number, but have a separate meaning
    of their own) then it usually makes no sense to use a signed type.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you will be using C++ to unpack data from a file or a network
    stream so that you can manipulate it. In this case, you will need to know whether
    the data is a floating point or integral, signed or unsigned, how many bytes are
    used and what order those bytes will be in. The order of the bytes (whether the
    first byte in a multi-byte number is the low or high part of the number) is determined
    by the processor which you are compiling for, and in most cases, you will not
    need to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, sometimes you may need to know about the size of a variable and how
    it is aligned in memory; in particular, when you are using records of data, known
    in C++ as `structs`. C++ provides the `sizeof` operator to give the number of
    bytes used to hold a variable and the `alignof` operator to determine the alignment
    of the type in memory. For basic types, the `sizeof` and `alignof` operators return
    the same value; it is only necessary to call the `alignof` operator on custom
    types where it will return the alignment of the largest data member in the type.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, an integer holds integral data, numbers that have no
    fractional part. For this reason, it makes little sense to do any arithmetic with
    an integer where the fractional part is important; in this case, you should use
    floating point numbers. An example of this was shown in the last chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives an aspect ratio of 1, which is clearly untrue and serves no purpose.
    Even if you assign the result to a floating-point number, you will get the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that the arithmetic is performed in the expression `width / height`,
    which will use the division operator for integers that will throw away any fractional
    part of the result. To use the floating-point division operator you will have
    to cast one or other of the operands to a floating-point number so the floating-point
    operator is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will assign a value of 1.3333 (or 4 : 3) to the `aspect_ratio` variable.
    The cast operator used here is the C cast operator, which forces data of one type
    to be used as data of another type. (It is used because we have not yet introduced
    the C++ cast operators, and the syntax of C cast operators is clear.) There is
    no type safety in this cast. C++ provides cast operators, which are discussed
    in the following text, some of which will cast in a type-safe way, which becomes
    important when you use pointers to objects of custom types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ provides integer types of various sizes, as summarized in the following
    table. These are the five standard integer types. The standard says that an `int`
    is the natural size of the processor and will have a value between (and including)
    `INT_MIN` and `INT_MAX` (defined in the `<climits>` header file). The size of
    the integer type has *at least as much storage as those preceding it in the list*,
    so an `int` is, at least, as big as a `short int` and a `long long int` types,
    which is at least as big as a `long int` type. The phrase *at least as big as* is
    not much use if the types are all the same size, so the `<climits>` header file
    defines ranges for the other fundamental integer types too. It is implementation-specific
    how many bytes are needed to store these integer ranges. This table gives the
    ranges of the fundamental types and the sizes on x86, 32-bit processors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Range** | **Size in bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| `signed char` | -128 to 127 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `short int` | -32768 to 32767 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | -2147483648 to 2147483647 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `long int` | -2147483648 to 2147483647 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `long long int` | -9223372036854775808 to 9223372036854775807 | 8 |'
  prefs: []
  type: TYPE_TB
- en: In practice, rather than the `short int` type, you will use `short`; for `long
    int`, you will use `long`; and for `long long int`, you will typically use `long
    long`. As you can see from this table, the `int` and `long int` types are the
    same size, but they are still two different types.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the `char` type, by default integer types are signed, that is, they
    can hold negative as well as positive numbers (for example, a variable of type
    `short` can have a value between -32,768 and 32,767). You can use the `signed`
    keyword to explicitly indicate that the type is signed. You can also have unsigned
    equivalents by using the `unsigned` keyword, which will give you an extra bit,
    but will also mean that bitwise operators and shift operators will work as you
    expect. You may find `unsigned` used without a type, in which case it refers to
    `unsigned int`. Similarly, `signed` used without a type refers to `signed int`.
  prefs: []
  type: TYPE_NORMAL
- en: The `char` type is a separate type to both `unsigned char` and `signed char`.
    The standard says that every bit in a `char` is used to hold character information,
    and so it is implementation-dependent as to whether a `char` can be treated as
    being able to hold negative numbers. If you want a `char` to hold a signed number,
    you should specifically use `signed char`.
  prefs: []
  type: TYPE_NORMAL
- en: The standard is imprecise about the size of the standard integer types and this
    may be an issue if you are writing code (for example, accessing data in a file,
    or a network stream) that contains a stream of bytes. The `<cstdlib>` header file
    defines named types that will hold specific ranges of data. These types have names
    which have the number of bits used in the range (although the actual type may
    require more bits). So, there are types with names such as `int16_t` and `uint16_t`,
    where the first type is a signed integer that will hold a range of 16-bit values
    and the second type is an unsigned integer. There are also types declared for
    8-, 32-, and 64-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the actual sizes of these types determined by the `sizeof`
    operator on an x86 machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the `<cstdlib>` header file defines types with names such as `int_least16_t`
    and `uint_least16_t` using the same naming scheme as before, and with versions
    for 8-, 16-,32-, and 64-bits. The `least` part of the name means that the type
    will hold values with at least the specified number of bits, but there could be
    more. There are also types with names such as `int_fast16_t` and `uint_fast16_t`
    with versions for 8-, 16-, 32-, and 64-bits which are regarded as the fastest
    types that can hold that number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying integer literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To assign a value to an integer variable you provide a number that has no fractional
    part. The compiler will identify the type with the nearest precision that the
    number represents and attempt to assign the integer, performing a conversion if
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explicitly specify that a literal is a `long` value, you use the `l` or
    `L` suffix. Similarly, for an `unsigned long`, you use the suffix `ul` or `UL`.
    For `long long` values, you use `ll` or `LL` suffix, and use `ull` or `ULL` for
    `unsigned long long`. The `u` (or `U`) suffix is for `unsigned` (that is, `unsigned
    int`) and you do not need a suffix for `int`. The following illustrates this,
    using uppercase suffixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a 10-based number system to specify a number that is a bitmap is confusing
    and cumbersome. The bits in a bitmap are the powers of 2, so it makes more sense
    to use a number system that is a power of 2\. C++ allows you to provide numbers
    in octal (base 8) or hexadecimal (base 16). To provide a literal in an octal you
    prefix the number with a zero character (`0`). To provide a literal in a hexadecimal
    you prefix the number with the `0x` character sequence. Octal numbers use the
    digits 0 through 7, but hexadecimal numbers need 16 digits, which means 0 through
    9 and a through f (or A through F), where A is 10 in base 10 and F is 15 in base
    10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code, two 64-bit (in Visual C++) integers are assigned bitmap values,
    with every other bit set to 1\. The first variable starts with the bottom bit
    set, the second variable starts with the bottom bit unset, and the second lowest
    bit set. Before inserting the numbers, the stream is modified with three manipulators.
    The first `hex` indicates that integers should be printed on the console as hexadecimals,
    and `showbase` means that the leading `0x` will be printed. By default, the alphabetic
    digits (A to F) will be given in lowercase and, to specify that uppercase must
    be used, you use `uppercase`. Once the stream has been modified, the setting remains
    until it is changed. To change the stream subsequently to use lowercase for alphabetic
    hexadecimal digits you insert `nouppercase` into the stream and to print the number
    without the base, insert the `noshowbase` manipulator. To use octal digits, you
    insert the `oct` manipulator and to use decimals, insert the `dec` manipulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you specify large numbers like this, it becomes difficult to see if you
    have specified the right number of digits. You can group together digits using
    a single quote (`''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The compiler ignores the quote; it is just used as a visual aid. In the first
    example, the quote groups the digits into two byte groups; in the second case
    the quote groups a decimal number in thousands and millions.
  prefs: []
  type: TYPE_NORMAL
- en: Using bitset to show bit patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no manipulator to tell the `cout` object to print an integer as a
    bitmap, but you can simulate the behavior using a `bitset` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here the `bitset` class is **parameterized,** which means that you provide a
    parameter through the angle brackets (`<>`) and in this case, 64 is used, indicating
    that the `bitset` object will accommodate 64-bits. In both cases, the initialization
    of the `bitset` object is carried out using a syntax that looks like a function
    call (in fact, it does call a function called a **constructor**) and this is the
    preferred way to initialize an object. Inserting the `bitset` object into the
    stream, prints out each bit starting with the highest bit. (The reason for this
    is that there is an `operator <<` function defined, which takes a `bitset` object,
    as is the case for most of the standard library classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bitset` class is useful for accessing and setting individual bits as an
    alternative to using bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `set` function will set the bit in the specified position to a value of
    1\. The `to_ullong` function will return a `long long` number that the `bitset`
    represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to the `set` function and the assignment has the same result as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Determining integer byte order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of bytes in an integer is implementation-dependent; it depends on
    how the processor handles integers. In most cases, you do not need to know. However,
    if you are reading bytes from a file in binary mode, or bytes from a network stream,
    and you need to interpret two or more bytes as parts of an integer, you will need
    to know what order they are in, and if necessary convert them to the order recognized
    by the processor.
  prefs: []
  type: TYPE_NORMAL
- en: The C network library (on Windows, it is called the **Winsock** library) contains
    a collection of functions that convert `unsigned short` and `unsigned long` types
    from the network order to the host order (that is, the order used by the processor
    on the current machine) and vice versa. The network order is big endian. **Big
    endian** means that the first byte will be the highest byte in the integer, whereas
    **little endian** means that the first byte is the smallest byte. When you transmit
    an integer to another machine you first convert from the order used by the processor
    of the source machine (the host order) to the network order and the receiving
    machine converts the integer from network order to the host order of the receiving
    machine before using the data.
  prefs: []
  type: TYPE_NORMAL
- en: The functions to change the byte order are `ntohs` and `ntohl`; for converting
    `unsigned short` and `unsigned long` from the network order to the host order
    and `htons` and `htonl` for the conversion from the host order to the network
    order. Knowing the byte order will be important when you view memory when you
    are debugging code (for example, as in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml),
    *Diagnostics and Debugging*).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to write code to reverse the byte order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This uses bitwise operators to separate the two bytes that are assumed to make
    up the `unsigned short` into the lower byte, which is shifted eight bits left,
    and the upper byte that is shifted eight bits right and these two numbers are
    recombined as an `unsigned short` using the bitwise OR operator, `|`. It is simple
    to write versions of this function for 4-byte and 8-byte integers.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three basic floating point types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float` (single precision)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` (double precision)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long double` (extended precision)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these are signed. The actual format of the number in memory, and the
    number of bytes used, is specific to the C++ implementation, but the `<cfloat>`
    header file gives the ranges. The following table gives the positive ranges and
    number of bytes used on x86, 32-bit processors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Range** | **Size in bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| float | 1.175494351e-38 to 3.402823466e+38 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| double | 2.2250738585072014e-308 to 1.7976931348623158e+308 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| long double | 2.2250738585072014e-308 to 1.7976931348623158e+308 | 8 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, in Visual C++ `double` and `long double` have the same ranges,
    but they are still two distinct types.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying floating point literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A literal used to initialize a `double` is specified as a floating point by
    using either the scientific format, or simply by providing a decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example indicates that the variable `one` is assigned to a floating-point
    value of 1.0\. The trailing zero is not important, as shown in the second variable,
    `two`; however, the trailing zero does make the code more readable since the period
    is easy to overlook. The third example uses scientific notation. The first part
    is the mantissa and can be signed and the part after the `e` is the exponent.
    The exponent is the power-of-10 magnitude of the number (which can be negative).
    The variable is assigned to a value of the mantissa multiplied by 10 and raised
    to the exponent. Although it is not recommended, you can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will interpret the numbers appropriately. The first example is
    perverse, but the second makes some sense; it shows in your code that a billion
    is a thousand million.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples assign double precision floating point values to `double` variables.
    To specify a value for single precision variables so that you can assign a `float`
    variable, use the `f` (or `F`) suffix. Similarly, for a `long double` literal
    use the `l` (or `L`) suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use these suffixes, you still have to provide the number in the right
    format. A literal of `2f` is incorrect; you have to provide a decimal point, `2.f`.
    When you specify floating point numbers with a large number of digits you can
    use the single quote (`''`) to group digits. As stated before, this is just a
    visual aid to the programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Characters and strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `string` class and C string functions will be covered in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*; this section covers the basic use of character variables in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Character types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `char` type is an integer, so `signed char` and `unsigned char` exist too.
    These are three distinct types; the `signed char` and `unsigned char` types should
    be treated as numeric types. The `char` type is used to hold a single character
    in the implementation's character set. In Visual C++, this is an eight-bit integer
    that can hold characters from the ISO-8859 or UTF-8 character set. These character
    sets are able to represent the characters used in English and most European languages.
    Characters from other languages take up more than one byte and C++ provides the
    `char16_t` type to hold 16-bit characters and `char32_t` to hold 32-bit characters.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a type called `wchar_t` (wide character) that will be able to
    hold characters from the largest extended character set. In general, when you
    see a C Runtime Library or C++ Standard Library function with a `w` prefix, it
    will use wide character strings rather than `char` strings. So, the `cout` object
    will allow you to insert `char` strings and the `wcout` object will allow you
    to insert wide character strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ standard says that every bit in a `char` is used to hold character
    information, and so it is implementation-dependent as to whether a `char` can
    be treated as being able to hold negative numbers. The following illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The range of a `signed char` is -128 to 127, but this code uses the separate
    type `char` and attempts to use it in the same way. The variable `c` is first
    assigned to the ASCII character `~` (126). When you insert a character into an
    output stream it will attempt to print a character rather than a number, so the
    next line prints this character to the console, to get the numeric value the code
    converts the variable to a `signed short` integer. (Again, a C cast is used for
    clarity.) Next, the variable is incremented by two, that is, the character is
    two characters further in the character set, which means the first character in
    the extended ASCII character set; the result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first character in the extended character set is C-cedilla.
  prefs: []
  type: TYPE_NORMAL
- en: It is rather counter-intuitive that a value of 126 incremented by two results
    is a value of -128, and this comes about from overflow calculations with signed
    types. Even if this is intentional, it is best to avoid doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual C++, the C-cedilla character is treated as -128 so you can write
    the following to have the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is implementation-specific, so for portable code you should not rely upon
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Using character macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<cctype>` header contains various macros that you can use to examine the
    type of character a `char` holds. These are the C runtime macros declared in `<ctype.h>`.
    Some of the more useful macros to test character values are explained in the following
    table. Bear in mind that, since these are C routines, they will not return `bool`
    values; instead they return an `int` with a value of non-zero for `true` and zero
    for `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Macro** | **Tests if the character is:** |'
  prefs: []
  type: TYPE_TB
- en: '| `isalnum` | An alphanumeric character, A to Z, a to z, 0 to 9 |'
  prefs: []
  type: TYPE_TB
- en: '| `isalpha` | An alphabetic character, A to Z, a to z |'
  prefs: []
  type: TYPE_TB
- en: '| `isascii` | An ASCII character, 0x00 to 0x7f |'
  prefs: []
  type: TYPE_TB
- en: '| `isblank` | A space or horizontal tab |'
  prefs: []
  type: TYPE_TB
- en: '| `iscntrl` | A control character, 0x00 to 0x1f or 0x7f |'
  prefs: []
  type: TYPE_TB
- en: '| `isdigit` | A decimal digit 0 to 9 |'
  prefs: []
  type: TYPE_TB
- en: '| `isgraph` | A printable character other than space, 0x21 to 0x7e |'
  prefs: []
  type: TYPE_TB
- en: '| `islower` | A lowercase character, a to z |'
  prefs: []
  type: TYPE_TB
- en: '| `isprint` | A printable character, 0x20 to 0x7e |'
  prefs: []
  type: TYPE_TB
- en: '| `ispunct` | A punctuation character, `! " # $ % & '' ( ) * + , - . / : ;
    < = > ? @ [ ] ^ _ ` { &#124; } ~ \` |'
  prefs: []
  type: TYPE_TB
- en: '| `isspace` | A space |'
  prefs: []
  type: TYPE_TB
- en: '| `isupper` | An uppercase character, A to Z |'
  prefs: []
  type: TYPE_TB
- en: '| `isxdigit` | A hexadecimal digit, 0 to 9, a to f, A to F |'
  prefs: []
  type: TYPE_TB
- en: 'For example, the following code loops while reading in a single character from
    the input stream (after each character, you need to press the *Enter* key). The
    loop finishes when a non-numeric value is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are also macros to change characters. Again, these will return an `int`
    value, which you should convert to a `char`.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Macro** | **Returns** |'
  prefs: []
  type: TYPE_TB
- en: '| `toupper` | The uppercase version of the character |'
  prefs: []
  type: TYPE_TB
- en: '| `tolower` | The lowercase version of the character |'
  prefs: []
  type: TYPE_TB
- en: 'In the following code, the character typed at the console is echoed back until
    the user types `q` or `Q`. If the character typed is a lowercase character, the
    echoed character is converted to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Specifying character literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can initialize a `char` variable with literal characters. This will be a
    character from the supported character set. The ASCII character set includes some
    unprintable characters, and so that you can use these, C++ provides two character
    sequences using the backslash character (`\`).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **ASCII name** | **C++ sequence** |'
  prefs: []
  type: TYPE_TB
- en: '| Newline | LF | `\n` |'
  prefs: []
  type: TYPE_TB
- en: '| Horizontal tab | HT | `\t` |'
  prefs: []
  type: TYPE_TB
- en: '| Vertical tab | VT | `\v` |'
  prefs: []
  type: TYPE_TB
- en: '| Backspace | BS | `\b` |'
  prefs: []
  type: TYPE_TB
- en: '| Carriage return | CR | `\r` |'
  prefs: []
  type: TYPE_TB
- en: '| Form feed | FF | `\f` |'
  prefs: []
  type: TYPE_TB
- en: '| Alert | BEL | `\a` |'
  prefs: []
  type: TYPE_TB
- en: '| Backslash | \ | `\\` |'
  prefs: []
  type: TYPE_TB
- en: '| Question mark | ? | `\?` |'
  prefs: []
  type: TYPE_TB
- en: '| Single quote | '' | `\''` |'
  prefs: []
  type: TYPE_TB
- en: '| Double quote | " | `\"` |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, you can give the numeric value of that character as an octal or
    hexadecimal number. To provide an octal number you give the number as three characters
    (prefixed with one or two `0` characters if necessary) prefixed with a backslash.
    For a hexadecimal number, you prefix it with `\x`. The character `M`, is the character
    number 77 in decimal, 115 in octal, and 4d in hexadecimal, so you can initialize
    a character variable with an `M` character in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For completeness, it is worth pointing out that you can initialize a char as
    an integer, so the following will also initialize each variable to an `M` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: All of these methods are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying string literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings are made up of one or more characters, and you can use the escaped
    characters in string literals too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This rather unreadable string will be printed on the console as `This is C++`
    followed by a newline. The capital C is 43 in hexadecimal and the + symbol is
    2b in hexadecimal and 53 in octal. The `\n` character is a newline. Escaped characters
    are useful for printing characters that are not in the character set your C++
    compiler uses and for some unprintable characters (for example, `\t` to insert
    a horizontal tab). The `cout` object buffers the characters before writing them
    to the output stream. If you use `\n` as a newline it is treated like any other
    character in the buffer. The `endl` manipulator will insert `\n` into the buffer
    and then flush it so the characters are immediately written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The *empty*, or `NULL` character, is a `\0`. This is an important character
    because it is unprintable, and it has no use other than to mark the end of a sequence
    of characters in a string. The empty string is `""`, but since strings are delimited
    by the `NULL` character the memory taken up by a string variable initialized with
    the empty string will have one character, that is `\0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The newline character allows you to put a newline within a string. This is
    useful if the only formatting you''ll do is with paragraphs and you are printing
    short paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints two lines on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you may want to initialize a string with a long sequence of characters
    and the limitations of the editor you are using may mean you want to split the
    string over several lines. You do this by putting each fragment of the string
    within double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There is no newline printed other than the one explicitly requested at the end
    with `endl`. This syntax allows you to make long strings more readable in your
    code; you can, of course, use the newline characters `\n`, in such strings.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `wchar_t` variable can also be initialized with a character and the compiler
    will promote the character to a wide character essentially by using the character's
    byte and assigning the remaining (higher) bytes to zero. However, it makes more
    sense to assign such a variable with a wide character, and you do this using the
    `L` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, rather than using the `cout` object, this code uses `wcout`, the
    wide character version. The syntax of using the `\u` prefix within the quotes
    indicates that the following character is a Unicode character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that, to show the Unicode character, you need to use a console
    that will show Unicode characters and, by default, the Windows console is set
    to **Code Page 850** which will not show Unicode characters. You can change the
    mode of the output console by calling `_setmode` (defined in `<io.h>`) on the
    standard output stream, `stdout`, specifying the UTF-16 file mode (using `_O_U16TEXT`
    defined in `<fcntl.h>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can find a list of all of the characters supported by Unicode at [http://unicode.org/charts/](http://unicode.org/charts/).
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16 characters can also be assigned to `char16_t` variables, and UTF-32 characters
    can be assigned to `char32_t` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Raw strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use a raw string literal you essentially switch off the meaning of
    escape characters. Whatever you type into a raw string becomes its content, even
    if you use whitespace including newlines. The raw string is delimited with `R"(`
    and `)"`. That is, the string is between the inner parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, the `()` is part of the syntax and is not part of the string. The
    preceding code prints the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Normally in a string `\n` is an escaped character and will be translated as
    a newline, but in a raw string it is not translated and is printed as two characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a normal C++ string, you will have to escape some of the characters; for
    example, the double quote will have to be escaped to `\"` and the backslash escaped
    to `\\`. The following will give the same result without using a raw string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have newlines in raw strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the newline after the comma will be printed to the console. Unfortunately,
    all whitespace will be printed on the console, so assuming that in the preceding
    code the indentation is three spaces and the `cout` is indented once, you will
    see the following on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are 14 spaces in front of `its` because there were 14 spaces in front
    of `its` in the source code. For this reason, you should be wary about using raw
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, the best use for raw strings is to initialize variables with file
    paths on Windows. The folder separation character in Windows is a backslash, which
    means that for a literal string that represents a file path you will have to escape
    each of these separators; thus, the string will have a lot of double backslashes,
    with the possibility of missing one. With raw strings this escaping is not necessary.
    The two string variables in the following represent the same string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These two strings have the same contents, but the second one is more readable
    since the C++ literal string does not have escaped backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: The requirement for escaping backslashes is only needed for literal strings
    declared in your code; it is an indication to the compiler of how to interpret
    the character. If you obtain a file path from a function (or via `argv[0]`), the
    separator will be backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: String byte order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extended character sets use more than one byte per character. If such characters
    are stored in a file, the order of the bytes becomes important. In this situation,
    the writer of the character must use the same order that will be used by potential
    readers.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to use a **Byte Order Mark** (**BOM**). This is a known
    number of bytes with a known pattern, and is typically placed as the first item
    in a stream so that the reader of the stream can use it to determine the byte
    order of the remaining characters in the stream. Unicode defines the 16-bit character,
    `\uFEFF`, and the non-character, `\uFFFE`, as byte order marks. In the case of
    `\uFEFF`, all bits are set except for bit 8 (if the lowest bit is labeled as bit
    0). This BOM can be prefixed to data that is passed between machines. The destination
    machine can read the BOM into a 16-bit variable and test the bits. If bit 8 is
    zero it means the two machines have the same byte order and so the characters
    can be read as two byte values in the order in the stream. If bit 0 is zero then
    it means that the destination machine reads 16-bit variables in the opposite order
    to the source, and so action must be taken to ensure that, with 16-bit characters,
    the bytes are read in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character set** | **Byte order mark** |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-8 | EF BB BF |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 big endian | FE FF |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 little endian | FF FE |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 big endian | 00 00 FE FF |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 little endian | FF FE 00 00 |'
  prefs: []
  type: TYPE_TB
- en: Bear this in mind that, when you read data from a file. The character sequence,
    FE FF, will be very rare in a non-Unicode file, and so if you read these as the
    first two bytes in a file it means that the file is Unicode. Since `\uFEFF` and
    `\uFFFE` are not printable Unicode characters, it means that a file that starts
    with either of these has a byte order mark, and you can then use the BOM to determine
    how to interpret the remaining bytes in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bool` type holds a Boolean value, that is, just one of two values: `true`
    or `false`. C++ allows you to treat 0 (zero) as being `false` and anything non-zero
    as being `true` but this can lead to mistakes, so it is better to get in to the
    habit of explicitly checking values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The second of these two is preferable, since it is clearer what you are comparing.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, even if a pointer is not a `nullptr`, it still may not be a valid
    pointer, but it is common practice to assign a pointer to `nullptr` to convey
    some other meaning, perhaps to say that the pointer operation is not appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: You can insert Boolean values into an output stream. However, the default behavior
    is to treat a Boolean as an integer. If you want `cout` to output `bool` values
    with string names, then insert the manipulator `boolalpha` in to the stream; this
    will make the stream print `true` or `false` to the console. The default behavior
    can be achieved by using the `noboolalpha` manipulator.
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you need to indicate that a function does not have parameters
    or will not return a value; in both cases, you can use the keyword `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The use of `void` in the parameter list is optional; an empty pair of parentheses
    is acceptable and is preferable. This is the only way to indicate that a function
    returns no value other than returning `void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `void` is not really a type because you cannot create a `void` variable;
    it is the absence of a type. As you''ll find out in the next chapter, you can
    create pointers of the type `void`, but you will not be able to use the memory
    that such pointers point to without casting to a typed pointer: to use the memory
    you have to decide the type of the data that the memory holds.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initializers were touched upon in the last chapter, but we will go into more
    depth here. For built-in types, you must initialize a variable before you use
    it. For custom types, it is possible for the type to define a default value, but
    there are some issues in doing this, which will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all versions of C++, there are three ways to initialize a built-in type:
    assignment, function syntax, or calling a constructor. In C++11 another way to
    initialize variables was introduced: construction through a list initializer.
    These four ways are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first of these three is the clearest; it shows, using an easy to understand
    syntax, that the variable is being initialized to a value. The second example
    initializes a variable by calling the type as if it is a function. The third example
    calls the constructor of the `int` type. This is a typical way to initialize custom
    types, so it is best to reserve this syntax just for custom types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth syntax is new to C++11 and initializes the variable using an initialize
    list between curly braces (`{}`). Just to confuse things slightly, you can also
    initialize a built-in type using the same syntax as an assignment to a single
    item list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is really confusing things, the type `n` is an integer, not an array.
    Recall that, in the last chapter, we created an array with the birth dates of
    The Beatles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an array of four integers; the type of each item is `int` but
    the type of the array variable is `int*`. The variable points to memory that holds
    four integers. Similarly, you can also initialize a variable to be an array of
    one item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the same initialization code that C++11 allows to initialize
    a single integer. In addition, the same syntax is used to initialize instances
    of record types (`structs`), adding another level of potential confusion about
    what the syntax means.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to avoid using the curly brace syntax for variable initialization
    and use it exclusively for initializing lists. However, there are advantages to
    this syntax for casting, as explained shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The curly brace syntax can be used to provide the initial values for any of
    the collection classes in the C++ Standard Library, as well as for C++ arrays.
    Even when used to initialize a collection object, there is a potential for confusion.
    For example, consider the `vector` collection class. This can hold a collection
    of the type provided through a pair of angled brackets (`<>`). The capacity of
    an object of this class can grow as you add more items to the object, but you
    can optimize its use by specifying an initial capacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of this code says: create a `vector` object that can hold integers
    and start by reserving space for 42 integers, each initialized to a value of zero.
    The second line prints the size of the vector to the console (42) and the third
    line prints all the items in the array to the console and it will print 42 zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one change here: the parentheses have been changed to braces
    but it means that the initialization has been changed entirely. The first line
    now means: create a `vector` that can hold integers and initialize it with the
    single integer, 42\. The size of `a2` is 1 and the last line will print just one
    value, 42.'
  prefs: []
  type: TYPE_NORMAL
- en: The great power of C++ is that it should be easy to write correct code, and
    to persuade the compiler to help you to avoid mistakes. The use of braces for
    single item initialization increases the possibility of hard-to-find errors.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables of built-in types should be initialized before you first use them,
    but there are some situations when the compiler will provide a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you declare a variable at file scope, or globally in your project, and you
    do not give it an initial value, the compiler will give it a default value. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will compile and run, printing a value of 1; the compiler has initialized
    `outside` to 0, which is then incremented to 1\. The following code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will complain that the increment operator is being used on an uninitialized
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we saw another example of the compiler providing a default
    value: `static`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple function that maintains a count. The variable `count` is marked
    with the `static` storage class modifier, meaning that the variable has the same
    lifetime as the application (allocated when the code starts and deallocated when
    the program ends); however, it has internal linkage, meaning the variable can
    only be used within the scope of where it is declared, the `counter` function.
    The compiler will initialize the `count` variable with a default value of zero,
    so that the first time the `counter` function is called it will return a value
    of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new initialize list syntax of C++11 provides a way for you to declare a
    variable and specify that you want it initialized by the compiler to the default
    value for that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, when reading this code, you have to know what the default value
    for an `int` is (it is zero). Again, it is much easier and more explicit to simply
    initialize the variable to a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The rules for default values are simple: a value of zero. Integers and floating
    point numbers have a default value of 0, for a character the default value is
    `\0`, for a `bool` it is `false,` and for a pointer the default is the constant,
    `nullptr`.'
  prefs: []
  type: TYPE_NORMAL
- en: Declarations without a type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 introduces a mechanism for declaring that a variable's type should be
    determined from the data it is initialized with, that is, `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a minor confusion here because prior to C++11, the `auto` key was used
    to declare **automatic** variables, that is, variables that are automatically
    allocated on the stack in a function. Other than variables declared at file scope
    or as `static`, all the other variables in this book so far have been automatic
    variables and automatic variables are the most widely used **storage class** (explained
    shortly). Since it was optional and applicable to most variables, the `auto` keyword
    was rarely used in C++, so C++11 took advantage of this, removed the old meaning,
    and gave `auto` a new meaning.
  prefs: []
  type: TYPE_NORMAL
- en: If you are compiling old C++ code with a C++11 compiler and that old code uses
    `auto`, you will get errors because the new compiler will assume `auto` will be
    used with variables with no specified type. If this happens, simply search and
    delete each instance of `auto`; it was redundant in C++ prior to C++11, and there
    was little reason for a developer to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auto` keyword means that the compiler should create a variable with the
    type of the data that is assigned to it. The variable can only have a single type,
    the type the compiler decides is the type it needs for the data assigned to it,
    and you cannot use the variable elsewhere to hold data of a different type. Because
    the compiler needs to determine the type from an initializer, it means that all
    `auto` variables must be initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no syntax to specify that an integer value is a single byte
    or two bytes, so you cannot create `unsigned char` variables or `short` variables
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a trivial use of the `auto` keyword and you should not use it this
    way. The power of auto is when you use containers that can result in some fairly
    complicated looking types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `vector` container we have used before, but it stores two
    value items using a `tuple`. The `tuple` class is simple; you declare a list of
    the types of items in the `tuple` object in the declaration between the angle
    brackets. So, the `tuple<string, int>` declaration says that the object will hold
    a string and an integer, in that order. The `make_tuple` function is provided
    by the C++ Standard Library and will create a `tuple` object containing the two
    values. The `push_back` function will put the item into the vector container.
    After the four calls to the `push_back` function, the `beatles` variable will
    contain four items and each one is a `tuple` with a name and birth year.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range `for` loops through the container and on each loop assigns the `musician`
    variable with the next item in the container. The values in the `tuple` are printed
    to the console in the statements in the `for` loop. An item in the `tuple` is
    accessed using the `get` parameterized function (from `<tuple>`) where the parameter
    in the angle brackets indicates the index of the item (indexed from zero) to get
    from the `tuple` object passed as a parameter in the parentheses. In this example,
    the call to `get<0>` gets the name which is printed out, then a space, and then
    `get<1>` gets the year item in the `tuple`. The result of this code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This text has poor formatting because it does not take into account the length
    of the names. This can be addressed using manipulators explained in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of musician is `tuple<string, int>;`, this is a fairly simple type,
    and as you use the standard template more you could end up with some complicated
    types (particularly when you use **iterators**). This is where `auto` becomes
    useful. The following code is the same, but easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The musician variable is still typed, it is a `tuple<string, int>`, but `auto`
    means you do not have to explicitly code this.
  prefs: []
  type: TYPE_NORMAL
- en: Storage classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When declaring a variable, you can specify its storage class which indicates
    the lifetime, linkage (what other code can access it), and memory location of
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen one storage class, `static`, which when applied to a variable
    in a function means that the variable can only be accessed within that function,
    but its lifetime is the same as the program. However, `static` can be used on
    variables declared at file scope, in which case it indicates that the variable
    can only be used in the current file, which is called **internal linkage**. If
    you omit the `static` keyword on a variable, defined at file scope, then it has
    an **external linkage,** which means the name of the variable is visible to code
    in other files. The `static` keyword can be used on a data member of a class,
    and on methods defined on a class, both of which have interesting effects that
    will be described in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: The `static` keyword says that the variable can only be used in the current
    file. The `extern` keyword indicates the opposite; the variable (or function)
    has external linkage and can be accessed in other files in the project. In most
    cases, you will define a variable in one source file, and then declare it as `extern`
    in a header file so that the same variable can be used in other source files.
  prefs: []
  type: TYPE_NORMAL
- en: The final storage class specifier is `thread_local`. This is new to C++11 and
    it only applies to multithreaded code. This book does not cover threading, so
    only a brief description will be given here.
  prefs: []
  type: TYPE_NORMAL
- en: A thread is a unit of execution and concurrency. You can have more than one
    thread running in a program, and it is possible to have two or more threads running
    the same code at the same time. This means that two different threads of execution
    could access and alter the same variable. Since concurrent access may have undesirable
    effects, multithreaded code often involves taking action to ensure that only one
    thread can access data at any time. If such code is not written carefully there
    is a danger of deadlocks, where the execution of threads is paused (in the worst
    cases, indefinitely) for exclusive access to the variable, negating the benefit
    of using threads.
  prefs: []
  type: TYPE_NORMAL
- en: The `thread_local` storage class indicates that each thread will have its own
    copy of a variable. So, if two threads access the same function and a variable
    in that function is marked as `thread_local,` it means that each thread only sees
    the changes it makes.
  prefs: []
  type: TYPE_NORMAL
- en: You will sometimes see the storage class `register` used in older C++ code.
    This is now deprecated. It was used as a hint to the compiler that the variable
    has important consequences on the performance of the program and suggests to the
    compiler that if possible it should use a CPU register to hold the variable. The
    compiler could ignore this suggestion. In fact, in C++11 the compiler literally
    does ignore the keyword; code with `register` variables will compile with no errors
    or warnings and the compiler will optimize the code however it feels is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not a storage class specifier, the `volatile` keyword has an
    effect on compiler code optimization. The `volatile` keyword indicates that a
    variable (perhaps through **Direct Memory Access** (**DMA**) to some hardware)
    can be altered by an external action, and so it is important that the compiler
    *does not* apply any optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other storage class modifier called `mutable`. This can only be
    used on class members and so it will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Using type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes the names of types can become quite cumbersome. If you use nested
    namespaces, the name of a type includes all of the namespaces used. If you define
    parameterized types (examples used so far in this chapter are `vector` and `tuple`),
    the parameters increase the name of the type. For example, earlier we saw a container
    for the names and birth years of musicians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the container is a `vector` and it holds items that are `tuple` items,
    each of which will hold a string and an integer. To make the type easier to use
    you could define a preprocessor symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use `name_year` instead of the `tuple` in your code, and the preprocessor
    will replace the symbol with the type before the code is compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because `#define` is a simple search and replace, there can be problems
    as explained earlier in this book. C++ provides the `typedef` statement to create
    an alias for a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, an alias called `name_year_t` is created for `tuple<string, int>`.
  prefs: []
  type: TYPE_NORMAL
- en: With a `typedef,` the alias usually comes at the end of the line preceded by
    the type it aliases. This is the opposite order to `#define,` where the symbol
    you are defining comes after `#define`, followed by its definition. Note also
    `typedef` is terminated with a semicolon. It becomes much more complicated with
    function pointers, as you'll see in [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml),
    *Using Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, wherever you want use the `tuple`, you can use the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can `typedef` aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The type of the `beatles2` variable is `vector<tuple<string, int>>`. It is important
    to note that `typedef` creates an alias; it does not create a new type, so you
    can switch between the original type and its alias.
  prefs: []
  type: TYPE_NORMAL
- en: The `typedef` keyword is a well-established way to create aliases in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 introduces another way to create a type alias, the `using` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Again, this does not create a new type, it creates a new name for the same type,
    and semantically, this is the same as `typedef`. The `using` syntax can be more
    readable than using a `typedef` and it also allows you to use templates.
  prefs: []
  type: TYPE_NORMAL
- en: The `using` method of creating an alias is more readable than `typedef` because
    the use of the assignment follows the convention used for variables, that is,
    the new name on the left is used for the type on the right of the `=`.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating data in record types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often you will have data that is related and must be used together: an aggregated
    type. Such a record type allows you to encapsulate data into a single variable.
    C++ inherits from C `struct` and `union`, as ways of providing records.'
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most applications, you will want to associate several data items together.
    For example, you may want to define a time record that has an integer for each
    of the following: the hour, the minute, and the second of the specified time.
    You can declare them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach becomes quite cumbersome and error-prone. There is no encapsulation,
    that is, the `_min` variables can be used in isolation to the other variables.
    Does the *minutes past the hour* make sense when it is used without the hour that
    it refers to? You can define a structure that associates these items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have the three values as part of one record, which means that you can
    declare variables of this type; although you can access individual items it is
    clear that the data is associated with the other members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two variables: one that represents the start time, and the other
    that represents the end time. The members of a `struct` are encapsulated within
    the `struct`, that is, you access the member through the instance of the `struct`.
    To do this, you use the dot operator. In this code, `start_work.sec` means that
    you are accessing the `sec` member of the instance of the `time_of_day` structure
    called `start_work`. The members of a structure are `public` by default, that
    is, code outside the `struct` has access to the members.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and structures can indicate the level of member access, and [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*, will show how to do
    this. For example, it is possible to mark some members of a `struct` as `private`,
    which means that only code that is a member of the type can access the member.
  prefs: []
  type: TYPE_NORMAL
- en: 'A helper function called `print_time` is called to print the data to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `setw` and `setfill` manipulators are used to set the width
    of the next inserted item to two characters and to fill any unfilled places with
    zeros (more details will be given in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*; in effect, `setw` gives the size of the column occupied by the
    next inserted data, and `setfill` specifies the padding character used).
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*,
    will go into more detail about the mechanism of passing structures to functions
    and the most efficient way to do it, but for the purpose of this section we will
    use the simplest syntax here. The important point is that the caller has associated
    the three items of data together using a `struct` and all the items can be passed
    to a function as a unit.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to initialize an instance of a structure. The preceding
    code shows one method: accessing the member using the dot operator, and assigning
    it a value. You can also assign values to an instance of a `struct` through a
    specially provided function called a constructor. Since there are special rules
    about how to name a constructor and what you can do in them, this will be left
    until [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also initialize structures using the list initializer syntax using
    curly braces (`{}`). The items in the braces should match the members of the `struct`
    in the order of the members as declared. If you provide fewer values than there
    are members, the remaining members are initialized to zero. Indeed, if you provide
    no items between the curly braces then all members are set to zero. It is an error
    to provide more initializers than there are members. So, use the `time_of_day`
    record type defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the `lunch` variable is initialized to 1 PM. Notice that,
    because the `hour` member is declared as the third member in the type, it is initialized
    using the third item in the initialize list. In the second example, all members
    are set to zero, and of course, zero hours is midnight. The third example provides
    two values, so these are used to initialize `sec` and `min`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have a member of a `struct` that is a `struct` itself, and this is
    initialized using nested braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Structure fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A structure can have members that are as small as a single bit, called a **bit-field**.
    In this case, you declare an integer member with the number of bits that the member
    will take up. You are able to declare unnamed members. For example, you may have
    a structure that holds information about the length of an item, and whether the
    item has been changed (is dirty). The item this refers to has a maximum size of
    1,023, so you need an integer with at least 10 bits of width to hold this. You
    could use an `unsigned short` to hold both the length and the dirty information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This code separates the two pieces of information, and then prints them out.
    A bitmap like this is quite unfriendly to code. You can use a `struct` to hold
    this information using an `unsigned short` to hold the 10 bits of length information
    and a `bool` to hold the dirty information. Using bit fields you can define the
    structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `len` member is marked as `unsigned short` but only 10 bits are needed,
    so this is mentioned using the colon syntax. Similarly, a Boolean yes/no value
    can be held in just one bit. The structure indicates that there are five bits
    between the two values that are not used, and so have no name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields are simply a convenience. Although it looks like the `item_length` structure
    should only take up 16 bits (`unsigned short`), there is no guarantee that the
    compiler will do this. If you receive an `unsigned short` from a file or network
    stream you will have to extract the bits yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Using structure names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you may need to use a type before you have actually defined
    it. As long as you do not use the members, you can declare a type before defining
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This could be declared in a header, where it says that there is a function defined
    somewhere else that takes a `time_of_day` record and prints it out. To be able
    to declare the `print_day` function, you have to have declared the `time_of_day`
    name. The `time_of_day` struct must be defined somewhere else in your code before
    the function is defined, otherwise you will get an *undefined type* error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, an exception: a type can hold pointers to instances of the
    same type before the type is fully declared. This is because the compiler knows
    the size of a pointer, so it can allocate sufficient memory for the member. It
    is not until the entire type has been defined before you can create an instance
    of the type. The classic example of this is a linked list, but since this requires
    using pointers and dynamic allocation, that will be left to the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the uses of structs is that if you know how data is held in memory you
    can deal with a struct as a block of memory. This is useful if you have a hardware
    device that is mapped into memory, where different memory locations refer to values
    controlling or returning values from the device. One way to access the device
    would be to define a struct that matches the memory layout of the device''s direct
    memory access to C++ types. Further, structs are also useful for files, or for
    packets of data that need to be transmitted over the network: you manipulate the
    struct and then copy the memory occupied by the struct to the file or to the network
    stream.'
  prefs: []
  type: TYPE_NORMAL
- en: The members of the struct are arranged in memory in the order that they are
    declared in the type. The items will take up *at least* as much memory as each
    type requires. A member may take more memory than the type requires, and the reason
    for this is a mechanism called **alignment**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler will place variables in memory in the way that is the most efficient,
    in terms of memory usage, or speed of access. The various types will be aligned
    to alignment boundaries. For example, a 32-bit integer will be aligned to a four-byte
    boundary, and if the next available memory location is not on this boundary the
    compiler will skip a few bytes and put the integer at the next alignment boundary.
    You can test the alignment of a specific type using the `alignof` operator passing
    the type name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The alignment of an `int` is 4 and this means that an `int` variable will be
    placed at the next four-byte boundary in memory. The alignment of a `double` is
    8 and this makes sense because in Visual C++ a `double` occupies eight bytes.
    So far, it looks like the result of `alignof` is the same as `sizeof`; however,
    this is not so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This example prints the alignment of the `time_of_day` struct, which we previously
    defined to be three integers. The alignment of this `struct` is 4, that is, the
    alignment of the largest item in the `struct`. This means that an instance of
    `time_of_day` will be placed on a 4-byte boundary; it does not say how the items
    within the `time_of_day` variable will be aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following `struct`, which has four members that
    occupy respectively one, two, four, and eight bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will tell you that the alignment is 8 (the alignment of the largest
    item, `ull`), but that the size is 16, which may appear a little odd. If every
    item were aligned on 8-byte boundaries, then the size would have to be 32 (four
    times eight). If the items were stored in memory and packed as efficiently possible,
    then the size would be 15\. Instead, what is happening is that the second item
    is aligned on a two-byte boundary, which means that there is one byte of unused
    space between `uc` and `us`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7623b00b-908e-4290-9bc8-897ab73ff91e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to align the internal items onto, say, the same boundaries as used
    by a `uint32_t` variable, you can mark an item with `alignas` and give the alignment
    that you need. Note that, because 8 is bigger than 4, any item aligned on an 8-byte
    boundary will also be aligned on a 4-byte boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `uc` item will be aligned on a 4-byte boundary already (`alignof(test)`
    will be 8), and it will occupy one byte. The `us` member is a `uint16_t` but it
    is marked with `alignas(uint32_t)` to say that it should be aligned in the same
    way as a `uint32_t`, that is, on a 4-byte boundary. This means that both `uc`
    and `us` will be on 4-byte boundaries with padding provided. Of course, the `ui`
    member will also be aligned on a 4-byte boundary because it is a `uint32_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `struct` has just these first three members, then the size would be
    12\. However, the `struct` has another member, the 8-byte `ull` member. This must
    be aligned on an 8-byte boundary, which means 16 bytes from the beginning of the
    `struct`, and to do this there needs to be 4 bytes of padding between `ui` and
    `ull`. As a consequence, the size of `test` is now reported as 24: 4 bytes for
    `uc` and for `us` (because the following item `ui` has to be aligned on the next
    four-byte boundary), 8 bytes for `ull` (because it is an 8-byte integer), and
    8 bytes for `ui` because the following item (`ull`) has to be on the next 8-byte
    boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the location in memory of the various members of
    the `test` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f6fc03-7112-4760-a585-5d112f9cc07c.png)'
  prefs: []
  type: TYPE_IMG
- en: You cannot use `alignas` to relax alignment requirements, so you cannot mark
    a `uint64_t` variable to be aligned on a two-byte boundary that is not also an
    eight-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will not need to worry about alignment; however, if you are
    accessing memory-mapped devices, or binary data from files, it is convenient if
    you can directly map this data to a `struct` and in this case, you will find that
    you will have to pay close attention to alignment. This is known as **plain old
    data** and you will often see structs referred to as **POD types**.
  prefs: []
  type: TYPE_NORMAL
- en: POD is an informal description, and sometimes it is used to describe types that
    have a simple construction and do not have virtual members (see [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*
    and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction to
    Object-Oriented Programming*). The standard library provides a function in `<type_traits>`
    called `is_pod` that tests a type for these members.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in the same memory with unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A union is a struct where all the members occupy the same memory. The size of
    such a type is the size of the largest member. Since a union can only hold one
    item of data, it is a mechanism to interpret the data in more than one way.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a union is in the `VARIANT` type that is used to pass data between
    **Object Linking and Embedding** (**OLE**) objects in Microsoft''s **Component
    Object Model** (**COM**). The `VARIANT` type can hold data of any of the data
    types that COM is able to transmit between OLE objects. Sometimes OLE objects
    will be in the same process, but it is possible for them to be in different processes
    on the same machine or on different machines. COM guarantees that it can transmit
    `VARIANT` without the developer providing any additional networking code. The
    structure is complicated, but an edited version is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you can use a union without a name: this is an anonymous `union`
    and from a member access point of view you access a member of the union as if
    it is a member of the `VARIANT` that contains it. The `union` contains a member
    for every type that can be transmitted between OLE objects, and the `vt` member
    indicates which one is used. When you create a `VARIANT` instance, you have to
    set `vt` to the appropriate value and then initialize the related member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This record ensures that only the memory that is needed is used, and the code
    that transmits the data from one process to another will be able to read the `vt`
    member to determine how the data needs to be processed so that it can be transmitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that you must be disciplined and only initialize the appropriate member.
    When your code receives a `VARIANT,` you must read `vt` to see which member you
    should use to access the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, when using unions you should access only the item that you initialize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Accessing runtime type information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ provides an operator called `typeid` that will return type information
    about a variable (or a type) at runtime. **Runtime Type Information** (**RTTI**)
    is significant when you use custom types that can be used in a **polymorphic**
    way; details will be left until later chapters. RTTI allows you to check at runtime
    the type of a variable and process the variable accordingly. RTTI is returned
    through a `type_info` object (in the `<typeinfo>` header file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, you''ll see int printed as the type. The `type_info` class defines
    comparison operators (`==` and `!=`) so you can compare types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Determining type limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<limits>` header contains a template class called `numeric_limits` and
    this is used through the specializations provided for each of the built-in types.
    The way to use these classes is to provide the type you want information for in
    the angle brackets and then call the `static` members on the class using the scope
    resolution operator (`::`). (Full details of `static` functions on classes will
    be given in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*).
    The following prints the limits of the `int` type to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Converting between types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you try exceptionally hard to use the correct types in your code, at
    some point you will find that you will have to convert between types. For example,
    you may be using library functions that return a value of a particular type, or
    you may be reading in data from an external source that is a different type to
    your routine.
  prefs: []
  type: TYPE_NORMAL
- en: With built-in types, there are standard rules about conversion between different
    types, some of which will be automatic. For example, if you have an expression
    like `a + b`, and `a` and `b` are different types, then, if it is possible, the
    compiler will automatically convert one variable's value to the type of the other
    and the `+` operator for that type will be called.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, you may need to force one type to another type so that the right
    operator is called and this will require a cast of some kind. C++ allows you to
    use C-like casts, but these do not have runtime tests, so it is far better to
    use C++ casts, which have various levels of runtime checks and type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Built-in conversions can have one of two outcomes: promotion or narrowing.
    A promotion is when a smaller type is promoted to a larger type and you will not
    lose data. A narrowing conversion happens when a value from a larger type is converted
    to a smaller type with potential loss of data.'
  prefs: []
  type: TYPE_NORMAL
- en: Promoting conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a mixed type expression, the compiler will attempt to promote smaller types
    to the larger type. So, a `char` or a `short` can be used in an expression where
    an `int` is needed because it can be promoted to the larger type with no loss
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function declared as taking a parameter that is an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the variable `s` is silently converted to an `int`. There are some cases
    that may appear odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Again, the conversion is silent. The compiler assumes you know what you are
    doing and that your intention is that you want `false` treated as 0 and `true`
    treated as 1.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, *narrowing* occurs. Be very careful of this because it loses
    data. In the following, an attempt is made to convert a `double` into an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This is allowed, but the compiler will issue a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is clearly wrong, but the mistake is not an error because it may
    be intentional. For example, in the following code we have a function that has
    a parameter that is a floating point, and within the routine the parameter is
    used to initialize an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This may be intentional, but because there will be a loss of precision you should
    document why you are doing this. At the very least, use a cast operator so that
    it is obvious that you understand the consequence of the action.
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing to bool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, pointers, integers, and floating point values can
    be implicitly converted to `bool` where a nonzero value converts to `true` and
    a zero value converts to `false`. This can result in a nasty bug that is difficult
    to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here, the compiler sees the assignment expression `x = 1`, which is a bug; it
    should be the comparison `x == 1`. However, this is valid C++ because the value
    of the expression is 1 and the compiler, helpfully, converts this to a `bool`
    value of `true`. This code will compile without even a warning, and not only will
    it produce a result that is the opposite of what you expect (you'll see `not zero`
    printed on the console), but also the assignment will have changed the value of
    the variable propagating the error throughout the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to avoid this bug by getting into the habit of always constructing
    a comparison so that the rvalue of a potential assignment is on the left. In a
    comparison, there will be no concept of rvalue or lvalue, so this uses the compiler
    to catch an assignment when it is not intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Converting signed types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Signed to unsigned conversions can happen and can cause unexpected results.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `unsigned short` variable will be assigned with a value of `0xfffffffd`,
    that is, the two's compliment of 3\. This may be the result you want, but it is
    an odd way of getting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, if you try and compare these two variables, the compiler will
    issue a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The Visual C++ warning C4018 given here is `''<'': signed/unsigned mismatch`,
    which says that you cannot compare a signed and unsigned type, and to do so would
    need a cast.'
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you will have to convert between types. For example, this may
    be because the data is provided in a different type to the routines that you use
    to process it. You may have a library that processes floating point numbers as
    `float`, but your data is inputted as `double`. You are aware that the conversion
    will lose precision but know that this will have little effect on the final result
    so you do not want the compiler warning you. What you want to do is tell the compiler
    that the coercion of one type to another is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the various cast operations you can use in C++11:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Syntax** |'
  prefs: []
  type: TYPE_TB
- en: '| Construction | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove `const` requirement | `const_cast` |'
  prefs: []
  type: TYPE_TB
- en: '| Cast with no runtime checks | `static_cast` |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise casting of types | `reinterpret_cast` |'
  prefs: []
  type: TYPE_TB
- en: '| Cast between class pointers, with runtime checks | `dynamic_cast` |'
  prefs: []
  type: TYPE_TB
- en: '| C style | `()` |'
  prefs: []
  type: TYPE_TB
- en: '| Function style | `()` |'
  prefs: []
  type: TYPE_TB
- en: Casting away const-ness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the last chapter, the `const` specifier is used to indicate
    to the compiler that an item will not change, and that any attempt by your code
    to change the item is an error. There is another way to use this specifier, which
    will be explored in the next chapter. When `const` is applied to a pointer, it
    indicates that the memory that the pointer points to cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This badly written code tells the compiler to create a string constant with
    the value `0123456` and then put the address of this memory into the string pointer
    `ptr`. The final line attempts to write to the string. This will compile but it
    will cause an access violation at runtime. Applying `const` to the pointer declaration
    will ensure that the compiler will check for such situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'More typical cases are applying `const` to pointers that are function parameters
    and the intention is the same: it indicates to the compiler that the data the
    pointer points to should be read-only. However, there may be situations when you
    want to remove the `const` property of such a pointer, and this is carried out
    using the `const_cast` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is simple. The type that you want to convert to is given in the angle
    brackets (`<>`) and the variable (which is a `const` pointer) is provided in the
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: You can also cast a pointer *to* a `const` pointer. This means that you can
    have one pointer that you can use to access the memory so that you can write to
    it, and then after you have made changes, you create a `const` pointer to the
    memory, in effect making the memory read-only through the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, once you have cast away the const-ness of a pointer you take responsibility
    for the damage that you do by writing to the memory, so the `const_cast` operator
    in your code is a good marker for you to examine code during a code review.
  prefs: []
  type: TYPE_NORMAL
- en: Casting without runtime checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most casts are performed using the `static_cast` operator, and this can be
    used to convert pointers to related pointer types as well as converting between
    numeric types. There are no runtime checks performed so you should be certain
    that the conversion is acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here a `double` is converted to an `int`, which means that the fractional part
    is discarded. Normally the compiler would issue a warning that data is lost, but
    the `static_cast` operator shows that this is your intention and hence the warning
    is not given.
  prefs: []
  type: TYPE_NORMAL
- en: The operator is often used to convert `void*` pointers to a typed pointer. In
    the following code the `unsafe_d` function assumes that the parameter is a pointer
    to a double value in memory, and so it can convert the `void*` pointer to a `double*`
    pointer. The `*` operator used with the `pd` pointer *dereferences* the pointer
    to give the data that it points to. Thus, the `*pd` expression will return a `double`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This is unsafe because you rely on the caller to ensure that the pointer actually
    points to a `double`. It could be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `&` operator returns the memory address of the operand as a typed pointer.
    In the first case, a `double*` pointer is obtained and passed to the `unsafe_d`
    function. The compiler will automatically convert this pointer to the `void*`
    parameter. The compiler does this automatically with no checks that the pointer
    will be used correctly in the function. This is illustrated by the second call
    to `unsafe_d` where the `int*` pointer is converted to the `void*` parameter and
    then in the `unsafe_d` function it is cast by `static_cast` to a `double*` even
    though the pointer points to an `int`. Consequently, the dereference will return
    unpredictable data and `cout` will print nonsense.
  prefs: []
  type: TYPE_NORMAL
- en: Casting pointers without runtime checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reinterpret_cast` operator allows pointers to one type to be converted
    to pointers of another type, and it can convert from a pointer to an integer and
    an integer to a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `static_cast`, this operator always involves a pointer: converting between
    pointers, converting from a pointer to an integral type, or converting from an
    integral type to a pointer. In this example, a pointer to a `double` variable
    is converted to an `int` and the value printed to the console. In effect, this
    prints out the memory address of the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Casting with runtime checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dynamic_cast` operator is used to convert pointers between related classes,
    and for this reason it will be explained in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. This operator involves runtime checks so that the conversion is only
    performed if the operand can be converted to the specified type. If the conversion
    is not possible then the operator returns `nullptr`, giving you an opportunity
    to only use converted pointers that point to an actual object of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Casting with list initializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ compiler will allow some implicit conversions; in some cases, they
    may be intentional and in some cases, they may not be. For example, the following
    code is similar to code shown before: a variable is initialized to a `double`
    value and then later in the code it is used to initialize an `int`. The compiler
    will perform the conversion, and will issue a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ignore warnings then you may not notice this loss of precision, which
    may cause a problem. One way to get around this issue is to use initialization
    using curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, if `pi` can be converted to an `int` without loss (for example,
    if `pi` is a `short`) then the code will compile without even a warning. However,
    if `pi` is an incompatible type (in this case, a `double`) the compiler will issue
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an interesting example. The `char` type is an integer, but the `<<`
    operator for `char` from the `osteam` class interprets a `char` variable as being
    a character, not a number, as per the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print `#` on the console, not 35, because 35 is the ASCII code for
    "#". To get the variable to be treated as a number you can use one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the second version (construction) is just as readable, but is
    shorter than the first.
  prefs: []
  type: TYPE_NORMAL
- en: Using C casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, you can use C style casts, but these are provided only so that you
    can compile legacy code. You should use one of the C++ casts instead. For completeness,
    the C style casts are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two versions: the first cast operator has the parentheses around
    the type to cast to, and in the second one the cast looks like a function call.
    In both cases, it would be better to use `static_cast` so that there is compile-time
    checking.'
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part of the chapter, we will develop a command-line application
    that allows you to print out the contents of a file in a mixed alphanumeric and
    hex format.
  prefs: []
  type: TYPE_NORMAL
- en: The application must be run with the name of a file, but optionally you can
    specify how many lines to print. The application will print on the console the
    contents of the file, 16 bytes per line. On the left, it gives the hex representation
    and on the right, it gives the printable representation (or a dot if the character
    is not in the printable non-extended ASCII range).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e2cc9a-8fb1-46fe-bb11-17960072dfb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new folder under `C:\Beginning_C++` called `Chapter_03`. Start Visual
    C++ and create a C++ source file, and save it to the folder you just created as
    `hexdump.cpp`. Add a simple `main` function that allows the application to accept
    parameters, and provides support for input and output using C++ streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will have up to two parameters: the first is the name of the
    file and the second is the number of 16-byte blocks to print on the command-line.
    This means that you''ll need to check that the parameters are valid. Start by
    adding a `usage` function to give the application parameters and, if called with
    a non-null parameter, print out an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Add this function before the `main` function so that you can call it from there.
    The function can be called with a pointer to a C string or with `nullptr`. The
    parameter is `const`, indicating to the compiler that the string will not be changed
    in the function, so if there is any attempt to change the string, the compiler
    will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the file and confirm that there are no typos. Since this application
    uses the C++ Standard Library, you have to provide support for C++ exceptions
    with the `/EHsc` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: You can test the application invoking it from the command-line with zero, one,
    two, and then three parameters. Confirm that the application will only allow it
    to be called with one or two parameters on the command-line (which actually means
    two or three parameters since `argc` and `argv` include the application name).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is to determine if the user provided a number to indicate how
    many 16-byte blocks to dump to the console and, if so, convert the string provided
    by the command line into an integer. This code will perform the conversion from
    a string to a number using the `istringstream` class, so you need to include the
    header file where this class is defined. Add the following to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'After the declaration of the `filename` variable add the following highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: By default, the application will dump one line of data (up to 16 bytes) from
    the file. If the user provided a different number of lines, the string-formatted
    number is converted to an integer by using an `istringstream` object. This is
    initialized with the argument and then the number is extracted from the stream
    object. If the user typed a value of zero, or if they typed a value that cannot
    be interpreted as a string, the code prints an error message. The error string
    is split over two lines, but it is still one string.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, the `if` statement uses short-circuiting; that is, if the first
    part of the expression (`ss.fail()`, meaning the conversion failed), is `true`,
    then the second expression (`0 >= blocks`, that is `blocks` must be greater than
    zero) will not be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile this code and try it several times. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The first two should run without an error; the second two should generate an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry that `readme.txt` does not exist, as it is only here as a test parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll add the code to open a file and process it. Since you''ll use
    the `ifstream` class to input data from a file, add the following header file
    to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Then at the bottom of the `main` function add the code to open the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a stream object called `file` and this is attached to
    the file specified through the path given in `filename`. If the file cannot be
    found, the `good` function will return `false`. This code negates the value using
    the `!` operator so that if the file *does not exist* the statements in the braces
    following the `if` are executed. If the file exists and the `ifstream` object
    can open it, the data is read 16 bytes at a time in a `while` loop. Notice that
    at the end of this code the `close` function is called on the `file` object. It
    is good practice to explicitly close resources when you have finished with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file will be accessed by the `read16` function on a byte-by-byte basis,
    including non-printable bytes, so that control characters like `\r` or `\n` have
    no special meaning and are still read in. However, the stream class treats the
    `\r` character in a special way: this is treated as the end of a line and normally
    the stream will silently consume this character. To prevent this, we open the
    file in binary mode using `ios::binary`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the `while` statement again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: There are two expressions here. The first expression decrements the `blocks`
    variable, which holds the number of 16-byte blocks that will be printed. The postfix
    decrement means that the value of the expression is the value of the variable
    *before* the decrement, so if the expression is called when `blocks` is zero the
    whole expression is short-circuited and the `while` looping ends. If the first
    expression is non-zero, then the `read16` function is called and if this returns
    a value of -1 (the end of the file is reached), the looping finishes. The actual
    work of the loop occurs within the `read16` function, so the `while` loop statement
    is the empty statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you must implement the `read16` function just above the `main` function.
    This function will use a constant that defines the length of each block, so add
    the following declaration near the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Just before the `main` function, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This is just skeleton code for the function. You'll add more code in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: This function will read up to 16 bytes at a time and print the contents of those
    bytes to the console. The return value is the number of bytes that were read or
    -1 if the end of the file was reached. Notice the syntax used to pass the stream
    object to the function. This is a **reference**, a type of pointer to the actual
    object. The reason why a reference is used is because if we do not do this the
    function will get a *copy* of the stream. References will be covered in the next
    chapter and using object references as function parameters will be covered in
    [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of this function test is to verify whether the end of the file
    has been reached, and if so, no more processing can be done and the value of -1
    is returned. The code will manipulate the `cout` object (for example, inserting
    the `hex` manipulator); and so that you always know the state of this object outside
    of the function, the function ensures that when it returns the `cout` object is
    in the same state as when the function was called. The initial formatting state
    of the `cout` object is obtained by calling the `flags` function, and this is
    used to reset the `cout` object just before the function returns by calling the
    `setf` function.
  prefs: []
  type: TYPE_NORMAL
- en: This function does nothing, so it is safe to compile the file and confirm that
    you have no typos.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read16` function does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: It reads in, byte-by-byte, up to 16 bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints out the hex value of each byte.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints out the printable value of the byte.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that each line has two parts: the hex part on the left, and the
    printable part on the right. Replace the comment in the function with the highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop will loop for a maximum of `block_length` times. The first statement
    reads a single character from the stream. This byte is read in as raw data. If
    `get` finds that there are no more characters in the stream, it will set a flag
    in the stream object, and this is tested by calling the `eof` function. If the
    `eof` function returns `true` it means that the end of the file has been reached
    and so the `for` loop finishes, but the function does not return immediately.
    The reason is that *some* bytes may have been read so more processing must be
    carried out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the statements in the loop do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: There are statements to print the hex value of the character on the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a statement to store the character in a printable form in the `line`
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already set the `cout` object to output hex values, but if the byte
    is less that 0x10 the value will not be printed prefixed with a zero. To get this
    format, we insert the `setw` manipulator to say that the data inserted will take
    up two character positions and `setfill` to say that a `0` character is used to
    pad the string. These two manipulators are available in the `<iomanip>` header,
    so add them to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Normally, when you insert a `char` into a stream the character value is shown,
    so the `char` variable is cast to a `short` so that the stream will print the
    hex numeric value. Finally, a single space is printed between each item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final lines in the `for` loop are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This code checks to see if the byte is a printable character (" " to "~") using
    the `isprint` macro and if the character is printable it is appended to the end
    of the `line` variable. If the byte is not printable, a dot is appended to the
    end of the `line` variable as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code so far will print the hex representation of the bytes to the console
    one after the other and the only formatting is the space between bytes. If you
    want to test the code, you can compile this and run it on the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see something unintelligible, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `23` values are #, `20` are spaces, and `0d` and `0a` are returns and newlines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to print the character representations in the `line` variable and
    carry out some formatting, and add line breaks. After the `for` loop, add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: There will be at least *two* spaces between the hex display and the character
    display. One space will come from the last character printed out in the `for`
    loop, and the second space is provided in the initialization of the `padding`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum number of bytes on each line should be 16 bytes (`block_length`)
    and thus 16 hex values printed on the console. If a fewer number of bytes are
    read then extra padding is required so that over successive lines the character
    representations align. The actual number of bytes read, will be the length of
    the `line` variable obtained by calling the `length` function, so the number of
    missing bytes is the expression `block_length - line.length()`. Since every hex
    representation takes up three characters (two for the digits and one space), the
    padding needed is three times the number of missing bytes. To create the appropriate
    number of spaces, the string constructor is called with two parameters: the number
    of copies and the character to copy.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this padding string is printed to the console followed by the character
    representation of the bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point you should be able to compile the code with no errors or warnings.
    When you run the code on the source file, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the bytes make more sense. Since the application does not change the files
    it dumps, it is safe to use this tool on binary files, including itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The MZ indicates that this is the DOS header part of Microsoft's **Portable
    Executable** (**PE**) file format. The actual PE header starts on the bottom line
    with the characters, PE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the various built-in types in C++, how
    to initialize them, and how to use them. You also learned how to convert variables
    to different types using casting operators. The chapter also introduced you to
    record types, a topic that will be expanded on in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. Finally, you have seen various examples of pointers, a topic that will
    be examined in greater detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
