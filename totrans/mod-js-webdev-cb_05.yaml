- en: Testing and Debugging Your Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging with Winston
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding HTTP logging with Morgan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your server for different environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring your test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing simple services from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing more complex sequences of calls with Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting and testing your REST API with Swagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we installed `Node` and created a RESTful server.
    Is everything ready? Usually, things don't work out that well—bugs will creep
    in, and you'll have to find out how to fix your code. In this chapter, we'll be
    getting into practical details, such as testing and debugging your server.
  prefs: []
  type: TYPE_NORMAL
- en: So, after this chapter, you'll have your `Node` RESTful server ready for deployment
    and for official production work. Let's get into the necessary tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging with Winston
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple, basic need: *logging*. Having solid, correct logging
    set up can help you find problems quickly, while incomplete or otherwise lacking
    logging can make you look for hours for what could be a simple, trivial problem.
    A basic rule for any application is to ensure that proper login is set up so that
    you can be confident that any situation that comes up will at least be recognized
    and recorded for future analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first idea you could have is to just use the console family of functions,
    such as `console.log()`, `console.warn()`, `console.info()`, and more. (For a
    complete reference, check out [https://developer.mozilla.org/en-US/docs/Web/API/console](https://developer.mozilla.org/en-US/docs/Web/API/console).)
    While these are good for quick debugging, they just don''t do it for application-level
    logging. You should be able to select what kind of logs you want (everything?
    Errors only?) to decide what logs you see depending on your environment (for example,
    you''d want to see some kinds of logs in development but not in production), or
    even to enable or disable logging. And, finally, we want to have some control
    over the provided information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Timestamping*,to learn at what time each log was written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Text formatting*,so logging can be understandable by humans, but also parseable
    by applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Level setting*, usually on a scale ranging from *error* (the most serious)
    through *warning*, *informative*, *verbose*, and ending with *debugging* and *silly*
    (yes, truly!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destination picking*, like `stdout` or `stderr`, the filesystem, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you look around in the `npm` listings, you''ll find many modules that can
    do logging: some are generic tools, and other are more specific ones. In our case,
    we''ll use `Winston` for generic, application-level logging, and we''ll turn to
    a different tool, `Morgan`, which is specifically tailored for HTTP traffic logging,
    as we''ll see in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about `Winston` at [https://github.com/winstonjs/winston](https://github.com/winstonjs/winston).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to install `Winston`, so the first step will be to apply the time-honored
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, version 3.0 is in beta, but by the time you get this book, it will
    almost certainly be out of beta and ready for production. (By the way, I installed
    the beta version by using a slightly changed command: `npm install winston@next
    --save`; otherwise, I''d have gotten a 2.x.x version.)'
  prefs: []
  type: TYPE_NORMAL
- en: For (thorough!) documentation on `Winston`, check its own GitHub page at [https://github.com/winstonjs/winston](https://github.com/winstonjs/winston).
    Be careful with articles on the web, though, because there are some important
    changes in version 3, so most code won't work without some updating.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to look at a simple example about the usage of `Winston`. This package
    has many configuration parameters, so let''s try to get a basic, sane configuration
    going, which you''ll be able to extend on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Winston` can handle several transports at the same time, and by *transport*,
    it means a storage device for whatever you log. A single logger may have multiple
    transports, but configured differently: for example, you may want to show all
    logs at the console, but only write a file with warnings and errors, and yet more
    possibilities include writing a database or sending data to some URL. Formats
    may also vary (text lines for the console, possibly JSON for a file?), so you
    have lots of flexibility regarding configuring where your messages will go.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are creating three transports:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A console output*, for all messages marked as `"info"` and above, using colorized
    output (we''ll see it in a short while), emitting output with a timestamp, a label
    (`"serv"`, to help distinguish the server''s messages from others that might show
    up in the console, coming from other applications), the error level, and a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A file output*, for all messages marked as `"warn"` and above, in text format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Another file output*, for the same messages, but in JSON format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at how to adapt logging (and other features) later in this chapter,
    in the *Configuring your server for different environments* section, so you'll
    be able to be even more flexible in logging and other features.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having created the logger and defined the transports, all we have to
    do is use it, wherever we want. I''ll start with a very basic server so that we
    can focus on getting logging to work: we''ll just handle two routes—`/`, which
    will send back a message, and `/xyzzy`, which will simulate some program failure,
    instead of sending back a `"Nothing happens"` message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning, we could log every request by hand—though we''ll get a better
    output with `Morgan`, as we''ll see afterwards. The following code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for each route, we can add some `info` or `debug` messages, as we may
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling wrong routes might produce a `warn` message, and in other unplanned
    situations, a direct `error`. For the former, I''m only listing the required route,
    and for the latter, both the error message and the traceback stack, to help in
    future debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We're set! Let's try it out.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After building the project, I ran the `Winston` logging code to catch all the
    produced logs. I tried it out with a sequence of calls, simulated with `curl`;
    we''ll be looking at how to do this in more complex tasks in later sections in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output on the console can be seen in the following screenshot. The normal
    lines are in green (yes, hard to see in a black and white book—sorry about that!),
    the warnings are yellow, and the errors are in red. The request for the non-existing
    `/invented` path ended in a warning, and the one for `/xyzzy` produced an error,
    since we tried to call a non-existent function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bacbfc1-3d5f-4ee8-a6f9-295db6fe93b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Winston's console output for a few dummy requests
  prefs: []
  type: TYPE_NORMAL
- en: 'What got logged to the different log files? According to our specification,
    only the warning and the error messages were stored. The text file is basically
    the same as the console output, and that makes sense because the format specification
    we selected for those two transports is exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON file, on the other hand, is a bit reduced: each line includes an object
    with the `message` and `level` attributes, because we didn''t specify that anything
    in particular should be added. However, you can change that: read Winston''s documentation
    at [https://github.com/winstonjs/winston/blob/master/README.md](https://github.com/winstonjs/winston/blob/master/README.md),
    and you''ll have plenty of available possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, we have a flexible way to log just about whatever we want to, but our HTTP
    logging was, in particular, a bit too skimpy, and that's a good reason to include
    `Morgan`, as we'll see.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may also be interested in looking at other packages, such as `Bunyan` ([https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan))
    or `Pino` ([https://github.com/pinojs/pino](https://github.com/pinojs/pino));
    the latter is said to be the logging package with the best performance, but don't
    take my word for it—try it out! Finally, should you work on developing `npm` packages,
    then `debug` ([https://github.com/visionmedia/debug](https://github.com/visionmedia/debug)),
    which is basically a wrapper around `console` methods, could be your package of
    choice—and being quite simple, it also works for web applications and `Node`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding HTTP logging with Morgan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we managed to provide a very basic HTTP logging feature
    when we included some middleware that did `Winston` logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While this worked, there is much more information that we could desire, such
    as the HTTP status code for the response, the processing time it required, and
    more, so let's add `Morgan` into the mix, since that package is specific for requests
    logging.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about `Morgan` at [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll add `Morgan` to our software stack so that we can get
    better logs for all the processed requests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by installing `Morgan` with the usual method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must include it in our server, and we''ll also require the `fs` package
    in order to write `Morgan`''s logs to a file. Note that I''m adding to our previous
    server, so the `Winston` parts will be in place, unchanged from what we saw in
    the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to do some general logging to a file, and also all errors (HTTP status
    code 400 and higher) to the console, so we''ll have to add `morgan` twice to our
    middleware stack. The first parameter to `morgan` defines how the log messages
    will be formed: you have to provide either a function to generate the message
    that will be logged, or a string with tokens that `morgan` will replace at runtime.
    In the following code snippet, I used both styles, just for variety: a function
    for the file output, and a string for the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option to `morgan` lets you add some options, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`immediate`, meaning that requests will be logged as soon as they come in (`immediate:true`)
    or after they''ve been processed (`immediate:false`). The advantage of the former
    is that you are sure that all requests will be logged, even in the case of a serious
    crash, but the latter provides more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip()`, a function that lets you decide whether to log a given request or
    not. In our case, we''ll use it to just log requests that get a 400 or higher
    status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream`, to which the output should be written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When specifying the output format, you have access to several pieces of data,
    called *tokens* in Morgan''s parlance, such as the following, but check the documentation
    for the full list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `:date[format]` | Current date and time in UTC, in several formats |'
  prefs: []
  type: TYPE_TB
- en: '| `:http-version` | HTTP version of the request |'
  prefs: []
  type: TYPE_TB
- en: '| `:method` | HTTP method of the request |'
  prefs: []
  type: TYPE_TB
- en: '| `:remote-addr` | Remote address of the request |'
  prefs: []
  type: TYPE_TB
- en: '| `:req[header]` | The given header of the request, or "-" if the header isn''t
    present |'
  prefs: []
  type: TYPE_TB
- en: '| `:res[header]` | The given header of the response, or "-" if the header isn''t
    present  |'
  prefs: []
  type: TYPE_TB
- en: '| `:response-time` | Processing time, in milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `:status` | HTTP status of the response |'
  prefs: []
  type: TYPE_TB
- en: '| `:url` | URL of the request |'
  prefs: []
  type: TYPE_TB
- en: You can see that I used several of these tokens when setting up `Morgan`'s output.
    Now, let's see this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s give this a whirl, using the same examples that we used for `winston`.
    Since we set the console output to show only warnings and errors, we''ll just
    see an added pair of lines. Displaying `[http]` instead of `[serv]` helps finding
    them, among the rest of the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The (complete) HTTP log went into a file, and is just a list of all of the
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we opted to do an immediate logging, which means that all requests—even
    those that might cause everything to crash—get logged, but the outcome itself
    of the request is then not available. If you wish to also get that information—but,
    say, only for requests that caused some error—you might add a third `morgan` destination,
    sharing the same file stream, but only for errors, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, the log would then include more data, but only for the requests
    you picked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish, you can make `Morgan`''s output to go into `Winston`''s to get
    a single common logging stream, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Some output could be as follows; I highlighted the `morgan` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A few details about the changes I made are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding `.trim()` gets rid of a possible extra new line character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since all messages are sent through `winston`, you don't get your `[http]` distinguishing
    text in the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to send warnings for status like 400 or above, you'll have to write
    a more complex function that will scan the message text and decide whether to
    use `logger.info()` or some other method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your server for different environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No matter what you develop, it''s certain that you''ll work at least with a
    couple of environments, *development* and *production*, and settings for your
    code won''t be the same. For example, you won''t use the same configuration for
    security, to access a database, to log errors, or to connect to analytics services,
    and so on: when running in your development environment, you''ll need a certain
    setup, and for production there may be many changes.'
  prefs: []
  type: TYPE_NORMAL
- en: You could set everything up in your code, but having users, passwords, IPs,
    and other sensitive data in plain text and saved in a source code repository that
    might get hacked isn't a good recipe for security. You should deal exclusively
    with your development configuration and leave the actual deployment to production
    to a different team, which will safely deal with that configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Node lets you access environment variables and use them for configuration so
    that you can move that setup outside of your code. In this chapter, let's look
    at some ways to deal with all this, which will also indirectly help with our testing,
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are developing software, you'll obviously work in a different environment
    than for production; in fact, you could have several environments such as *development*,
    *testing*, *preproduction*, *production*, and so on. We'll also do this; let's
    start by going over some of the configurations we have already seen in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Getting a connection* section of [Chapter 3](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml),
    *Developing with Node*, when we created our services, we defined four constants
    to access the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, in the *Adding Authentication with JWT* section, we
    had a secret that we used for signing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, in this very chapter, we decided what levels of logging should
    be done. However, we hardcoded those levels, without the possibility of making
    things different in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also wrote the following, with some hardcoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It's worth pointing out that changes between development and production need
    not be limited to listing or not listing; you could also change the logging format,
    the files where logs should be written, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to changing configurations *on the fly* is the usage of environment
    variables, which are provided via the `process.env` object. Every configuration
    variable in your environment will appear as a property of that object. If we write
    and run a program that just consists of a single `console.log(process.env)` line
    (or if we do `node -e "console.log(process.env)"` at the command line) you''ll
    get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Read more about `process.env` and its contents at [https://nodejs.org/api/process.html#process_process_env](https://nodejs.org/api/process.html#process_process_env).
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of taking advantage of this. We can either use an `environment`
    variable to check whether we are in development, in production, or in any other
    situation, and depending on that we can set some properties, or we can directly
    get the values for those properties from the environment itself. Any of these
    two solutions will help you unlink the code from the environment; let's see how
    this works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by determining the environment. The standard is to set an environment
    variable called `NODE_ENV` with the name of the environment, before running the
    `Node` server itself. How to do that would depend on your actual machine, but
    in Linux, it would be something akin to the following, while in Windows the `SET`
    command would be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In your code, you could set a `isDev` variable to true if you are running in
    development (and false otherwise) with just two lines. If no environment was specified,
    the first line makes it default to `"development"`, which is most likely the safest
    choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the log file would also be simple, along the same lines as the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This style works, but it still has a couple of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Any change in the environment requires changing the (hardcoded) server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths, tokens, passwords, and more, all reside in the source code, in a
    very viewable state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can do even better by directly taking the values for our internal variables
    directly from the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for logging, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to simplify working in development, but also make it easy for others
    when pushing code to production or other environments, you may want to look into
    `dotenv`, an `npm` package that lets you work with environment variables in text
    files. Install the package with `npm install dotenv --save`, and then create a
    file at the root of your project with the `.env` extension, which contains the
    desired variables values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your code, you only need to add a single line, and that will load
    and merge all the definitions in your `.env` file into `process.env`. Of course,
    if you only want to use this feature in development (as it was originally intended
    by the creator of `dotenv`) you could previously check the `isDev` variable, as
    we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Environment files should never be uploaded to source control, so it makes sense
    to add a line with `**/*.env` to your `.gitignore` file. You can, however, upload
    a sample file (say, `config.env.example`), but without the actual values for the
    environment variables; this will help new developers get the necessary files,
    but preserve security.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about `dotenv` at [https://github.com/motdotla/dotenv](https://github.com/motdotla/dotenv).
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best practices to ensure quality and to protect yourself from regression
    bugs (those that happen when you modify something, and reintroduce an earlier,
    previously corrected, bug) is to make sure that your code is *unit tested*. There
    are three types of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unit testing*, which applies to each component, on their own'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integration testing*, which applies to components working together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***End-to-end*** (**E2E**) *testing*, which applies to the system as a whole'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing is good—not only because it helps try out your code, but because
    if done well, as in **Test-Driven Design** (**TDD**), in which you basically first
    set up the tests, and only then write the code—as it will help produce code of
    a better quality, and this will surely have an impact on reducing bugs all over
    your system. (Finding bugs even before any testing work begins is also a money
    saver; the earlier you find and fix bugs, the less costly it is.) So, let's focus
    on how you can use unit testing for your Node work.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's well-known that *testing can prove the existence of bugs, but
    not their absence*, so no matter how much testing you do, some bugs will fall
    through! And, when that happens, TDD will make you first create some new unit
    tests that pinpoint the bug, and only then work at actually fixing it; at least,
    that specific bug won't reappear, because it will be detected.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of tools and frameworks for unit testing, and in this book
    we'll be using `Jest`, a modern tool for *Delightful JavaScript Testing* as its
    lemma goes, which was developed by Facebook. We'll have the additional advantage
    of being able to also use it with React or React Native. Installation is quite
    simple, requiring just `npm install jest --save-dev`. After doing that, we'll
    be able to write our tests; let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `Jest` at the official web page, at [https://facebook.github.io/jest/](https://facebook.github.io/jest/).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll look at how to write unit tests for `Node` and get valid
    experience for future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing unit tests can be simpler or harder, depending on how you designed your
    code. If you work in a clear, side effects-free style, then writing functional
    tests will be quite simple. If you start adding complexities such as callbacks
    or promises and databases or filesystems, then you'll require more work, because
    you'll have to *mock* some of those elements; after all, you don't want to run
    tests on a production database, do you?
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll look at how we can write unit tests and learn
    how to work with some specific concepts such as *mocks* or *spies*.
  prefs: []
  type: TYPE_NORMAL
- en: Doing functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s see a simple, basic set of functional tests, and for that, let''s
    go back to the rounding library we wrote in the *Working with modules* section
    of [Chapter 3](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml), *Developing with Node*. When
    you test a module, you only test the exported functions to see if they perform
    according to their specs. The interesting part to test is, then, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These four functions are totally functional, insofar that their computed results
    depend only on their input parameters, and they have absolutely no side effects.
    Writing tests requires (1) defining groups of tests, and (2) including one or
    more tests in each group. Here, it makes sense to write a group for each function,
    so let''s see how the code could go; we could start with the `addR()` function,
    and write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The most usual style is naming the unit test file in the same way as the tested
    file, but adding `"test"` or `"spec"` before the file extension. In our case,
    for `roundmath.js`, we named the unit test file as `roundmath.test.js`. As for
    placement, `Jest` is able to find your tests no matter where you place them, so
    the usual practice is to place this new file alongside the original one so that
    it will be easy to find.
  prefs: []
  type: TYPE_NORMAL
- en: Each `describe()` call defines a group, and each `it()` call within defines
    a specific test. Should a test fail, Jest will report it, giving the group's and
    test's descriptions, as in `"addR should add first and round later"`. Tests consist
    of (1) setting things up, if needed; (2) actually running the test by calling
    the function; and (3) checking whether the function did as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: The first test we wrote verifies that, when adding numbers, addition should
    be done first, and only then rounding; rounding first and then adding wouldn't
    be right. We test this by calling `addR(1.505, 2.505)`, and we expect the result
    to be `4.01`; if the function had been rounded first, the result would have been
    `4.02`. Each test should be good at verifying at least one property of the function;
    our second test checks that `addR()` can handle negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The style in which you write your assumptions about the code is meant to be
    easy to read: *expect so-and-so to be such-value*. Methods such as `toBe()` or
    `toThrow()` (see our next example) are called matchers; see the quite long list
    at [https://facebook.github.io/jest/docs/en/expect.html](https://facebook.github.io/jest/docs/en/expect.html) for
    more information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, just a couple of tests would probably not be enough for complex
    code, and you''ll usually have more tests, but as an example, these will do. Note
    that we should write tests for all functions; for example, `divR()` could use
    something like this. While the first test is quite straightforward (similar to
    one for `addR()`), in the second one, we verify that calling `divR()` with a zero
    divisor should throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you miss some functions or part of them, later in this chapter, we'll look
    at ways to detect that; don't worry just now. At this point in time, we'll keep
    writing tests, and then we'll run the complete suite.
  prefs: []
  type: TYPE_NORMAL
- en: Using spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The functional tests we wrote are quite good, but just won''t do for some situations,
    such as when you work with callbacks. Let''s turn to another piece of code we
    wrote: the user validation routine we used for JWT. Basically, this function received
    a username, a password, and an error-first callback, which was used to signal
    whether the username really had that password or not. We wrote very basic validation
    code (a single user was accepted!), but that doesn''t matter here; we want to
    look at how we can deal with the callback. The important parts we care about now
    are highlighted in the following code extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing this would require actually passing a callback, and then trying to
    see how it was called; this can be done, but the details would be messy. Alternatively,
    we can have a spy—a dummy function, which we can later interrogate to see if it
    was called or not, with which parameters it was called, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create such a spy by calling `jest.fn()`. Since we''ll need a new spy
    for each test we''ll write, we can take advantage of a `beforeEach()` function,
    which Jest will call automatically before running each individual test; this will
    save some extra writing. There are actually four functions you can use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeAll()` will be called only once, before starting with your tests; for
    example, you could set up a test database here and fill it with certain data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach()` will be called before each test, as we did in our example to
    create a spy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach()` will be called after each test, to *clean up*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterAll()` will be called after running all tests; for example, you could
    destroy a test database you had created for testing purposes only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three tests are similar; we will pick the first one. We call the validation
    routine, but pass an empty parameter. In terms of the validation specification,
    that should create an error. By doing this, we can test that the callback was
    actually called, and that it was called by passing an error as the first parameter,
    and nothing as the second.
  prefs: []
  type: TYPE_NORMAL
- en: (Of course, the first test, using the `.toHaveBeenCalled()` matcher, is not
    needed given the second one that tests if it was called with specific values,
    but we just wanted to show a new pair of matchers.)
  prefs: []
  type: TYPE_NORMAL
- en: Using spies is quite practical if we only care about seeing if a given function
    was called or not, but what would happen if the function under test actually required
    some value back from our spy? We can also solve that; let's get into a more complex
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Working with mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish by working with a more complex example—a part of the REST code
    that worked with regions, which requires a database and uses promises, among several
    complications. Let''s take the `DELETE` method handler as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We did something right by passing the database connection (`dbConn`) as a parameter
    to the function. This means that we can *mock* it—meaning, provide an alternative
    version that will behave as we may want it, but without actually using any database.
    Similarly, processing our request will need to simulate a response object (`res`)
    whose status code we'll want to check; we could code it by hand, but using the
    `node-mocks-http` package is simpler, so just install it with `npm install node-mocks-http
    --save`. Check out its documentation at [https://github.com/howardabrams/node-mocks-http](https://github.com/howardabrams/node-mocks-http),
    for more information—it can do much more!
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the `DELETE` method should (1) confirm that the region to be deleted
    must have no cities, and (2) if true, then actually delete the region. How can
    we test if the first check works? Let''s provide `deleteRegion()` with a mock
    that will say that the region we want to delete actually has some cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We could program a complete mock database that would analyze the incoming query
    and then provide some expected answer, but in this case, a little knowledge about
    how the code checks for cities is good. We can create a mock database object with
    a query attribute (`mDb.query`) and set it so that when `mDb.query()` is called
    for the first time, it will return a promise resolved to an array with a single
    1—for that's what the actual SQL statement would have produced when checking a
    region that actually includes some cities. We'll also create a mock response object
    (`mRes`) that will get the routine's answer.
  prefs: []
  type: TYPE_NORMAL
- en: What's left to do? You just have to call the `deleteRegion()` function with
    all the parameters, `await` its results, and verify that the response status code
    is 405, as expected; then, you're done!
  prefs: []
  type: TYPE_NORMAL
- en: 'The other tests are similar, but we have to simulate two SQL accesses, not
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting thing is that we can set up a mock function to produce different
    answers each time it is called, according to what we need. Thus, in order to test
    whether `deleteRegion()` would correctly delete a region without cities, our mock
    DB object must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, return an empty array, showing that the region to be deleted has no cities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, return an object with `affectedRows:1`, showing that the (supposed)
    `DELETE` SQL command was successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting things up in this way, the rest of the code is like our first
    case; await the function and check the status code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the tests, we''ll have to edit a script in `package.json`. Change the
    `"test"` script, which up till now had just an error message, so it will read
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"test"` script can be run just by typing `npm` test. In our case, since
    our output code goes into the `out/` directory we are telling Jest to inspect
    that directory, and run all tests (`*.test.js` files, by default) that it can
    find. You can modify Jest''s configuration for more specific cases, but in general,
    it works well with *zero configuration*. The output is short and practical, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2759c870-b28f-4bad-9c53-ca83f4232aaf.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of the npm test command is short and to the point
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, matching what we did, it shows that we ran three suites of tests,
    including a total of 10 tests, and they all passed. Had one or more tests produced
    a wrong result, we''d have gotten another sort of result, with lots of red. I
    modified a test on purpose so that it would fail, and the following output was
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23ee0762-814f-48a3-9f1f-db97e5f150e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Modifying a test to make it fail, and running Jest, produces a listing including
    the missed expectations, the failed test, and more
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that one test failed, in the `restful_regions.test.js`
    file, showing that a 204 result was expected, but a 404 error was received instead.
    The file is marked with a red `FAIL` message; the other two files are marked with `PASS`,
    in green. In our case, it happened because we purposefully wrote a failing test,
    but in real life, if the test had been running fine before, and now failed, it
    would mean that someone messed with the code and accidentally introduced a bug.
    (To be fair, there also exists the possibility that the test was not totally correct
    then, and the tested function was actually right!) In any case, getting a red
    result means that the code cannot be considered ready, and more work is needed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more....
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Should you need to mock some package that you cannot (or won''t) inject as
    a parameter into a function, you can provide Jest with a complete mocked version.
    Suppose you wanted to mock the `"fs"` package: you''d start by creating a `__mocks__`
    directory at the same level of the `node_modules` one, then you would write and
    place your manual mock code there, and finally you would specify `jest.mock("fs")`
    at the beginning of your test file so that `Jest` will use your module rather
    than the standard one.'
  prefs: []
  type: TYPE_NORMAL
- en: All of this can become a chore, so you'd better try to provide all of the modules
    as parameters to your functions (as we did with `dbConn` when deleting regions)
    so that standard mocks can be used. However, if you can't do that, check out [https://facebook.github.io/jest/docs/en/manual-mocks.html](https://facebook.github.io/jest/docs/en/manual-mocks.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring your test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, so you have written a lot of tests, but how much of your code base are you
    actually testing? This measure of the quality (breadth) of your testing is called
    *coverage*, and it's easy to determine; in this recipe, let's find out how to
    do this. Fortunately, given all the work that we have done, it will be a very
    simple recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have `Jest` produce a coverage report, showing what parts of your code were
    (and weren''t) covered by your tests, all you have to do is add a pair of parameters
    to the corresponding script in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, the first parameter, `--coverage`, tells `Jest`
    to collect all of the necessary information, and the second parameter, `--no-cache`,
    ensures that all information will be fresh; in certain situations, not totally
    correct results have been produced when this parameter was omitted. How does this
    affect the testing? Let's see!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key difference when running `Jest` with coverage is that a different report
    is added at the console, and also a HTML page is built. First, let''s check the
    former: check out the following screenshot —and once again, I accept that seeing
    colors in black and white is really hard!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d757eb05-b88d-4248-996e-0e0cd50becf5.png)'
  prefs: []
  type: TYPE_IMG
- en: Including coverage options when running Jest produces a more detailed analysis
    of your tests
  prefs: []
  type: TYPE_NORMAL
- en: 'For each file, you get the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%Stmts`: The percentage of statements that were executed at least once because
    of your tests. Ideally, each and every statement should have been executed at
    least once; otherwise, whatever statement wasn''t executed could be anything,
    and you wouldn''t realize it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%Branch`: The percentage of branches that were taken. The reasoning for this
    is similar to that of `%Stmts`—if there are some branches (for example, an else)
    that were never taken, that means that there are some paths in your code that
    could do anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%Funcs`: The percentage of functions in the file that were called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%Lines`: The percentage of lines that were covered. Note that a line may have
    several statements, so `%Lines` will always be greater or equal to `%Stmts`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uncovered Line #s`: This is NOT the number of lines (several billion!?), but
    the numbers of specific lines that were never executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we find that all of the functions were tested in `validate_user.js`,
    but half the functions were missed in `roundmath.js` (we tested `addR()` and `divR()`,
    but forgot about `subR()` and `multR()`, so that's correct) and only one function
    (the `DELETE` handler) was tested in `restful_regions.js`. Getting better coverage
    numbers means more work, and it may not always be wise, in economic terms, to
    aim for 100% (80%-90% is common), but 25% or 50% is definitely too low, so more
    work is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more interesting part is that you can analyze in depth how tests ran by
    looking into the `coverage/lcov_report/` directory of your project and opening
    `index.html` in a browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a5cc820-34f4-46f8-ac51-3d304b3e030b.png)'
  prefs: []
  type: TYPE_IMG
- en: The main page of the web coverage report shows essentially the same data as
    the console run
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can see the files in different colors: as usual, red means a not-too-good
    result, and green is the best result. The interesting part is that if you click
    on a file, you''ll get a detailed analysis, including each line, if it was executed
    or not, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b33abb0b-42aa-4653-8a5b-b1874ca5dae5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see which lines were executed, and which were missed, and why 100% wasn't
    achieved
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, even if we thought we had covered all of the cases in `deleteRegion()`,
    the screen shows us that we missed a possible situation: the SQL server failing
    to answer. Of course, whether we include a specific test for this or not is a
    decision you''ll have to take: at least we can see that all of the most important
    code was covered, but don''t forget the other functions in the same file, which
    weren''t tested at all!'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point or another, you'll have to debug your code. You might do well
    enough with just a bit of logging (using the console object, as we saw earlier
    at the beginning of the *Adding logging with Winston* section), but using a more
    powerful debugger is a great help. In this recipe, let's see how you can do real-time
    debugging with breakpoints, inspection of variables, and so on, so that you won't
    be limited to just trying to deduce what's wrong by looking at console logs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways of doing debugging; let's see both methods here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to stay in your IDE, Visual Studio Code lets you directly
    start a debugging session. Just click on the code you want to run (a reminder:
    pick the code in the out/ directory, and don''t forget to use `npm run build`)
    and pick Debug | Start Debugging in the menu. The window will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/581706b5-7073-4c25-9a07-27c979ddf08d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can start a debugging session right in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you'd rather keep using your favorite developer tools from
    Chrome, there's an alternative you can use. First, in Chrome, look for `N.I.M.`,
    the *Node.js V8 Inspector Manager*, which can be found at [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj),
    and add it to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'After doing that, open the `N.I.M.` console by going to `about:inspect`, and
    you''ll get something like what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6771ba-1e14-40f8-804d-f7125f58e909.png)'
  prefs: []
  type: TYPE_IMG
- en: The N.I.M. extension lets you debug Node sessions using Chrome's developer tools
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do now is go to VSC, or a shell session, and run your code.
    Before doing this, add the `--inspect` option, as in `node --inspect out/restful_server.js`.
    You will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d034af3-ca27-4439-ba1a-cdf3a2594935.png)'
  prefs: []
  type: TYPE_IMG
- en: To connect Node to Chrome's developer tools, you must run your code with an
    extra `--inspect` option
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, a window will open, and you''ll have full access to Chrome''s debugger
    console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: If you examine the URL in Chrome's debugger, you'll see something like `chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=...`,
    followed by a URL and a (long) hexadecimal number. These values are listed after
    running `Node` with `--inspect`, in the line starting with "Debugger listening
    on ws...".
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7aa4099c-240d-43ae-bee1-e6ed3be30038.png)'
  prefs: []
  type: TYPE_IMG
- en: If N.I.M. is enabled, your Node session will connect to it, and you'll be able
    to debug your code from within Chrome
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in any case, you are ready to start a serious debugging session; let's
    see what you can do.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn about how code inspection works, read the following article: [https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/).
    This also gives you tips for debugging with other IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding screenshots, both with VSC and Chrome, I opened the `out/restful_regions.js`
    file and set a breakpoint at the place where a `SELECT` is done in order to get
    some regions. Doing a request for `/regions/uy` caused the run to pause at the
    point. You can then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine all variables, including block, local, and global ones—this includes
    the possibility of modifying their values, if you want to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add some variables or expressions to watch; whenever execution pauses, you'll
    see their values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the call stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set some specific breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As for program execution, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop execution at any breakpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step through your code, with the option of *drilling* *down* to analyze function
    calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use Chrome, you'll be able to get some extra options, like memory usage
    analysis or code execution profiling, but clearly the web-specific options won't
    do any good. However, debugging your code by using the inspection option is a
    very good aid for bug chasing, so get used to it; you'll appreciate it a lot!
  prefs: []
  type: TYPE_NORMAL
- en: Testing simple services from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you create services, you will need some way of testing them. So far,
    we have seen some examples of doing just that with `curl`. So, in this recipe,
    let''s go a bit deeper and check out some options that you may find useful. Alternatively,
    you could opt for another tool, such as `wget`. For our purposes, both options
    are roughly equivalent, allowing us to do everything we need for RESTful services
    testing: they are scriptable, they can download things, and they can also send
    requests posting data, so what you use will be mostly a question of personal preference.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read more about `curl`, check out its site at [https://curl.haxx.se/](https://curl.haxx.se/),
    or the source code at [https://github.com/curl/curl](https://github.com/curl/curl).
    You may also be interested in *Everything Curl*, a book that details all there
    is to know about this tool, and which is freely available at [https://www.gitbook.com/download/pdf/book/bagder/everything-curl](https://www.gitbook.com/download/pdf/book/bagder/everything-curl)—however,
    do take into account that it's over 300 pages long!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How to install `curl` will depend on your operating system, but it''s available
    for practically every platform you are likely to work with; just check out all
    the downloads at [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
    The command has dozens of possible options, but for our intents, we will be looking
    at the following table. Note that most options have two versions: a short, single
    character one, and a longer one, intended to be clearer for understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-K filename``--config filename` | Lets you specify the name of a file that
    has options in it so that your command is shorter. In the given file, each option
    will be in a different line. |'
  prefs: []
  type: TYPE_TB
- en: '| `-d key=value``--data key=value` | Allows you to send data in the body of
    the request. If you use this option several times, `curl` will use `&` as a separator,
    as standard. |'
  prefs: []
  type: TYPE_TB
- en: '| `--data-binary someData` | Similar to `--data`, but used to send binary data.
    Most frequently it is followed by `@filename`, meaning that the contents of the
    named file will be sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `-D filename``--dump-header filename` | Dumps the headers of the received
    data into a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-H "header:value"``--header "header:value"` | Allows you to set and send
    some header with a request. You can use this option several times to set many
    headers. |'
  prefs: []
  type: TYPE_TB
- en: '| `-i``--include` | Includes headers of the received data in the output. |'
  prefs: []
  type: TYPE_TB
- en: '| `-o filename``--output filename` | Stores the received data in the given
    file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s``--silent` | Minimizes output to the console. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v``--verbose` | Maximizes output to the console. |'
  prefs: []
  type: TYPE_TB
- en: '| `-X method``--request method` | Specifies which HTTP method will be used,
    such as `GET`, `POST`, `PUT`, and so on. |'
  prefs: []
  type: TYPE_TB
- en: Finally, if you need help, use `curl --help` or `curl --manual`, and you'll
    get a full description of the utility and its options. Now let's look at how we
    can use `curl` to test our services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a complete set of tests for the RESTful server we created in the
    previous chapter, with all options enabled, including JWT—which, as you''ll remember,
    we removed in order to simplify our code! Let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we may verify that the server is up and running; the `/` route had
    no token requirement. Remember that we are using `8443`, and actual HTTPS: requests
    will be sent to that port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to access some region, we''ll be refused, because of the lack
    of an authorizing JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If the line starts with `*`, it's some information from `curl` itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the line starts with `>`, it's a header sent with the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the line starts with `<`, it's a received header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following listing, I highlighted the incoming data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get a token by using the `/gettoken` route and providing `user` and
    `password` values. Let''s store the received token in a file to simplify future
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try a simple `GET`. We can either cut-and-paste the token in a header,
    or use some shell features, at least in Linux-based systems, and take advantage
    of the back tick option to include the token file''s contents in the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''ve got left is to try out the other routes and methods. Let''s change
    the name of Montevideo to MVD, which actually is the IATA code for its international
    airport; we''ll do a `PUT` first (which should produce a 204 status code) and
    then a `GET` to verify the update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In one experiment, I created a new region, numbered 20\. Let''s delete it and
    verify that it''s gone with yet another `GET`. The first request should get a
    204 status, and the second should get a 404, because the region will no longer
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s invent a new region to verify that `POST` also works; a 201
    status should be returned, as well as the new ID (which would be 20, after we
    deleted the previous invented 20th Uruguayan region):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, by using `curl` and some console work, we can set out to test any kind of
    services. However, at some point, you may need to work with more complex sequences
    of service calls, and doing all this work by hand could become a chore. Indeed,
    by careful scripting you may simplify your job, but let's consider another tool,
    Postman, that's more apt for that kind of work.
  prefs: []
  type: TYPE_NORMAL
- en: Testing more complex sequences of calls with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing services manually, or even with a carefully crafted shell script, isn't
    really easy. Furthermore, if you require some kind of complex test, using scripting
    may prove to be just too hard. `Postman` can be used to write tests for services,
    to organize them into full testing suites, and to document the way your RESTful
    API works. You can also use it to mock services or as a help in development, but
    we won't be getting into that here. In this recipe, we'll focus on the testing
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download `Postman` from [https://www.getpostman.com/](https://www.getpostman.com/),
    and install it according to the instructions for each platform. Remember to take
    a look at its documentation for more features that we won't be seeing here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Postman lets you create requests that you can store in collections. Before and
    after each request, you may execute JavaScript code, either to set up the upcoming
    request, to process the resulting response, or to store some information for future
    requests in a test sequence. Let's take a look at the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Doing basic requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we'll start with a simple test to get a JWT, which we'll then store so
    that we can use it in upcoming tests. Open the `Postman` application and click
    on New to create a request. Give it a name and a description, and either select
    or create a collection or folder to save it. Don't worry too much about the actual
    placement; you'll be able to move requests around, edit them, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to get a token, we need a `POST`, so set the method appropriately. Select
    the BODY tab, pick the `x-www-form-urlencoded` option, and add two values, `user`
    and `password`, which will be sent with the request. (For other situations, you
    might send raw data such as XML or JSON, or binary data such as a file.) Check
    out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3487874e-670b-4b7c-a13d-f3f44f017af6.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a POST request to get a JWT
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you test it out by clicking on Send, the request will go to your server,
    and the answer will appear at the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf772a36-3196-4c25-acfe-e4f755049fa1.png)'
  prefs: []
  type: TYPE_IMG
- en: A test run of our request shows that everything is working fine
  prefs: []
  type: TYPE_NORMAL
- en: Adding some checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, that''s not enough. We don''t just want to check whether the `/gettoken`
    endpoint works—we''d like to test if the token looks right, and if so, store it
    so that later requests can use it. We will create an environment (click on the
    gear at the upper right corner) and add a `token` entry so that we can store and
    retrieve the value we got from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6954463-3113-468a-866b-b12194276ba3.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating an environment is one way you can share data between requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s write some tests for the token, and also store its value in
    the environment. Writing the tests themselves is sort of similar to what we already
    did, but you''ll have to look into the documentation to see what objects and methods
    are available. As for the tests themselves, they use `Chai` (see [http://www.chaijs.com/](http://www.chaijs.com/)),
    which is similar to `Jest` when it comes to writing your expectations, but not
    exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will test that the answer should be at least 40 bytes long; tokens
    have no special size limits, but 40 characters is on the low side. Then, a second
    test will check that the token is comprised of three parts, separated by periods.
    Finally, we will store the response itself in the environment, for future use.
    If you check the TESTS tab, you''ll see that both our tests passed, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f82702e-4cd4-4d3e-b00d-6047f7b378d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Both tests we created were successful
  prefs: []
  type: TYPE_NORMAL
- en: Chaining requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you check the environment, you''ll see that the token was stored. Now let''s
    write a second test, a `GET`, that will use the token. I went through a similar
    sequence by doing a request for `/regions/uy`, but I added a line in the headers,
    with the `Authorization` key and the `Bearer {{token}}` value, so that the previously
    stored token value would be replaced in the header. I also added a couple of tests
    to make sure (1) I got a successful JSON answer, and (2) the answer was an array
    of at least 19 regions. (Yes, I know my country, Uruguay, has exactly 19 regions,
    but sometimes, for test purposes, I may add some new ones!) The tests show some
    features we haven''t seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this fashion, you can create complete sequences of requests; make sure that
    getting the JWT is placed earlier in the list. In a collection, you can also have
    many folders, each with a distinct sequence of steps. (You may also change the
    sequence programatically, but we won't get into that here; check out [https://www.getpostman.com/docs/v6/postman/scripts/branching_and_looping](https://www.getpostman.com/docs/v6/postman/scripts/branching_and_looping)
    for more information.)
  prefs: []
  type: TYPE_NORMAL
- en: I created two folders to test some `GET`s and a `DELETE`—but, of course, you
    should be writing even more tests to verify every method, and as many different
    sequences as possible. Let's see how we can make them run.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have organized your requests in folders, you can run any given sequence
    by clicking on it at the sidebar on the left. If everything is OK, you''ll get
    green marks for all tests; a red mark highlights an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c6ba089-e7b6-4de0-8c9f-acaabd7f706b.png)'
  prefs: []
  type: TYPE_IMG
- en: Running a collection runs every test in it. Green blocks show successes; red
    ones mark errors.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you already have a good tool for documenting your API (make sure
    that every test and field has an explanation) and for making sure that it keeps
    working, going beyond the unit testing into full **end-to-end** (**E2E**) testing.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your `Postman` account, you can also set things up to get periodical
    monitoring of your API; check out [https://www.getpostman.com/docs/v6/postman/monitors/intro_monitors](https://www.getpostman.com/docs/v6/postman/monitors/intro_monitors) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `newman` package (install it with `npm install newman --save-dev`),
    you can run your `Postman` tests from the command line, which could also allow
    you to include them in a continuous integration workflow. First, export your collection
    from `Postman` (uninspiredly, I called mine `postman_collection.json`), and then
    add a new script to your `package.json` file called `"newman":"newman run postman_collection.json"`.
    Using `npm run newman` will then produce an output like the one shown in the following
    code snippet. You could also test whether all of the tests ran satisfactorily
    or whether there was a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Documenting and testing your REST API with Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s focus more on documentation and testing with a well-known tool:
    `Swagger`. This is a tool that''s meant to help you design, model, and test APIs.
    The key idea is that you''ll end up by having an online, interactive document
    that will describe in detail all of your API calls, the parameter types and restrictions,
    the required and optional values, and so on, even letting you try calls *on the
    fly* to better understand how the API is meant to be used.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first—and hardest!—part of setting up `Swagger` is preparing the specification
    for your complete API. This is meant to be written in **YAML Ain't Markup Language** (**YAML**),
    and can be difficult to get right. However, you can use a web editor, which you
    can run at your own server (go to [https://swagger.io/tools/swagger-editor/](https://swagger.io/tools/swagger-editor/) for
    the necessary download) or online at [https://editor.swagger.io](https://editor.swagger.io).
    After writing that, however, setting everything up will be truly easy, needing
    just three lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: YAML is a recursive acronym that stands for *YAML Ain't Markup Language*. If
    you want to learn more about it, visit [http://yaml.org/](http://yaml.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Writing our specs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We won''t be able to introduce the full rules for writing API specs here, and
    also won''t be able to include all of its features in our example. Furthermore,
    a complete description for any API can be hundreds of lines long, and that''s
    another problem. So, let''s just go over some basic definitions, as well as a
    couple of the services, to get a taste of what needs to be done. First, we''ll
    need some basic data about our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we must describe the tags (think *sections*) that our documentation will
    be divided into. We work with tokens (for security), plus countries, regions,
    and cities, so those seem to be the needed definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `/gettoken` route. We define a POST request, which
    gets body encoded parameters, and returns plain text. Two string parameters, `user`
    and `password`, are required. The API may either return a 200 status if everything
    was OK, or 401 otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting regions for a country would get a similar specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Enabling Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable the `Swagger` documentation, we need the `swagger-ui-express` package,
    and also need to load the JSON version of the YAML specs, so you''ll need a couple
    of lines of code. First, install the package with the usual `npm install swagger-ui-express
    --save`, and then add the following lines to your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server, we must also add a line for enabling the new route, at the beginning,
    after other `app.use()` statements. We are adding `Swagger` to our RESTful API,
    and without a token: you might prefer to set up a different server, only providing
    access to the API, and possibly also enabling authorization, but both changes
    will be easy to accomplish. So, let''s go with the simpler version here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You're all set! After you rebuild the project and start the server, the new
    route will be available, providing online documentation for your server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you start the server, accessing the `/api-docs` route will provide access
    to the main `Swagger` screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f6622a-7084-4a05-9343-0dc3f4b2c694.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger produces a main page, with access to every route you defined
  prefs: []
  type: TYPE_NORMAL
- en: 'Interaction is easy: select an area, click on a given request, and you''ll
    get the list of all routes and operations. Let''s see, for example, how to get
    the regions for Uruguay. First, we must get a token, so we want to open the token
    area and enter the necessary user and password, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92c311dd-05dc-4a78-9d05-fa6e9b34e8fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Doing a request is just a matter of filling the fields and executing the query
  prefs: []
  type: TYPE_NORMAL
- en: 'When the process runs, you''ll get the answer, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd190496-fc79-4ed7-958f-02e56334257f.png)'
  prefs: []
  type: TYPE_IMG
- en: A successful request returned the security token
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the equivalent `curl` request at the top, which matches what we
    did earlier in this chapter, in the *Testing simple services from the command
    line* section. Now, copying that token and pasting it into the `/regions/uy` endpoint
    means that we''re ready to do that query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66b6e274-3f42-40c4-8064-12c47c3f01a5.png)'
  prefs: []
  type: TYPE_IMG
- en: After getting a token, we can set up the query to get all of the regions of
    a country
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left to do is execute that query, and we''ll get the desired results,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f361107e-a79d-47b2-97e6-300869feaa4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Doing sequences of calls is possible, and Swagger lets you experiment easily
    with different endpoints
  prefs: []
  type: TYPE_NORMAL
- en: What can we point out? First, obviously, `Swagger` is a very good tool, in terms
    of documentation. You can add descriptions to methods, parameters, results, and
    even include sample values and results. This means that developers who need to
    use your API will have a very good way of learning about how to use it. In terms
    of actually using your API, `Swagger` is simpler than `curl` or `Postman`, but
    it cannot chain operations, which you'll have to do on your own. You should really
    think about starting your development with this tool, and only moving forward
    with actual coding once you have everything documented; give it a try!
  prefs: []
  type: TYPE_NORMAL
