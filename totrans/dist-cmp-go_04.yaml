- en: The RESTful Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we looked at two of the most important components
    of Go—goroutines and channels. In the following chapters, we will build a distributed
    application using Go, and it is very important to understand how to write applications
    for the internet or, in our case, the web. In this chapter, we shall look at a
    particular way of building web applications using the REST web protocol. We shall
    also look at how to interact with a REST-based web application. We shall be covering
    them in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief look at HTTP and sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentals to build a REST server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a simple REST server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools to interact with a REST server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP and sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we will take a brief look at the HTTP protocol and how it has
    evolved over time. Also discuss how servers keep track of user state using HTTP
    sessions. This knowledge will come in handy when we try to understand how REST
    protocol works.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to better understand the advantages of the REST protocol, let us take
    a small detour into how the internet was used before the REST web protocol came
    onto the scene. The internet in 1990s was mostly used to store and share documents
    as marked up documents using **HTTP** (**Hypertext Transfer Protocol**). For this
    chapter, HTTP can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a network communication protocol that starts with an HTTP request and
    ends with an HTTP response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP responses during the early periods consisted of plain text documents, but
    soon the HTML format gained traction as it allowed for more stylized documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web browsers brought in a new age of internet: merely displaying text documents
    with different font weights wasn''t enough. CSS and JavaScript came to the fore
    to make these documents customizable and more interactive. All these advancements
    led to what we now call the *web*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One could interact with a web server using a URL and an HTTP method. There
    are nine HTTP methods, but, for the purpose of this book, we are only interested
    in five of them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: This is used when sending simple HTTP requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` : This is used when we want to include valuable information while sending
    HTTP requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`, `PATCH`, and `DELETE`: Technically, they are identical to, `POST` method,
    although they differ in functionally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall revisit these HTTP methods in the next section and explore them in
    greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTTP protocol in itself is stateless; that is, it has no idea of what is
    accessing a web page, who can POST to a page, and so on. For the majority of HTTP
    servers during this period (1990s), they could be thought of as file server; that
    is, they serve static files over the internet. However, the modern web experience
    is more expansive. Consider visiting Gmail or Facebook, and the website knows
    who we are and we are shown customized content that is dynamically generated for
    us. They maintain the "state" of which article we are reading or the mail we are
    writing. If we were to close the browser and return to the website after a while,
    it can drop us right back to where we left off. Given that the HTTP protocol and
    HTTP servers are stateless, how do these websites keep track of all these things
    and link them back to the correct user? The answer is an HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: When we log onto a website from a browser, we provide it with credentials to
    identify ourselves. The server responds back with a response that also consists
    of a token, which will be used to identify us in the near future. The token can
    be in the form of a session ID, cookie, authentication header, and so on. A web
    server maintains a table of such tokens and the corresponding user IDs. After
    we have logged onto a website, the browser always sends the corresponding token
    in the headers to the server with every request. As a result, the web server is
    able to keep track of each user and show correct content to any given user. How
    does the server do this? It maintains all the state information on the server
    side!
  prefs: []
  type: TYPE_NORMAL
- en: The REST protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even in the 1990s, the computers and internet technology kept advancing rapidly
    and the web browsers kept evolving simultaneously. This meant that the web servers
    themselves could start offloading some of the work to the web client; that is,
    the web browser. Slowly this began to lead developers to experiment with different
    software architectures for developing web applications. By 2010, the REST protocol
    became the most prevalent way to design a modern web application.
  prefs: []
  type: TYPE_NORMAL
- en: '**REST** (**Representation State Transfer Protocol**) was first described by
    *Roy Fielding* in his seminal paper titled, *Architectural Styles and the Design
    of Network-based Software Architectures* ([https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)).
    This way of designing a web application has many advantages. It is practical,
    efficient in CPU usage and network load, scales better for increasing internet
    traffic, and so on. The following are some of the properties and benefits of using
    REST software architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The server and client architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *HTTP sessions* section, we described a server that was doing most of
    the work and browser was responsible for relaying user inputs to the server, parsing
    the HTML document returned back from the server, and rendering it in the browser
    for the user. REST allows us to split the application into a server and client.
    A server (backend) is responsible for executing business logic, and a client (frontend)
    is responsible for communicating user interaction to the server. It might sound
    like not much has changed; however, the remaining properties of REST architecture
    will be more apparent.
  prefs: []
  type: TYPE_NORMAL
- en: The standard data format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REST revolves around the communication state and data between the backend and
    frontend using a standard data format. This results in the decoupling of backend
    and frontend. This means that we are no longer bound to using only a web browser
    to communicate with the server, and this in turn means that our servers are now
    capable of being used to interact with web applications, command-line applications,
    and so on. REST allows us to use any type of data format for communication, although
    JSON format has become the lingua franca for communication over REST protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since our frontend and backend are separate, we need to communicate the state
    and data between the two. In the frontend, we will need to show all available
    entities for the service we are providing. These entities are called **resources**.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a server that provides us with a REST interface (REST API) that has
    a list of books in our personal library. In this case, *list of books* are resources
    and we can request information about each of them from the backend at particular
    endpoints. For our example, the endpoint can be `<URL>/api/books`. `/api` prefix
    is a convention generally used in REST applications to express that we are interacting
    with the backend URLs. The resources can generally be thought of as a collection
    of data, like rows of a database table.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing the HTTP protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We defined endpoints in the previous subsection, *Resources*, but how do we
    interact with them? REST is built on top of the HTTP protocol and it uses HTTP
    methods, or verbs in the case of REST, to interact with the server. Let's take
    our endpoint from the previous example, `/api/books`, to understand how it is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'REST uses the `GET` verb to retrieve items of the specific resource type. Given
    that we have a lot of items, it is possible to retrieve a specific resource item
    and to retrieve all the available resource items. Retrieval of a specific resource
    item is generally done by providing the id of the item. The following shows the
    two forms of `GET` used for retrieval:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/books`: This returns a list of all books in the library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/books/<id>` : This returns information about a particular book in the
    library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: REST uses the `POST` verb to create a new item of the specific resource type.
    Resource creation might require extra information, which is provided in the body
    of the `POST` request. The information being provided as part of the body has
    to be in the data format the REST server can handle. POSTing to `/api/books` signifies
    that we want to add a new book to the list of books in our library.
  prefs: []
  type: TYPE_NORMAL
- en: PUT and PATCH
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These take the form `/api/books/<id>`. These methods are only applicable for
    an already existing resource. They will update a given resource with the data
    or new state of the resource provided in the request's body. `PUT` expects a resource's
    new state to be provided in completion, including fields that haven't changed.
    `PATCH` can be thought of as a more relaxed version of `PUT` because we do not
    need to provide the complete new state but only the fields that need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: REST uses the `DELETE` verb to remove a specific resource item. It takes the
    form of `/api/resource/<id>`. It deletes a particular resource based on `<id>`.
    REST supports deletion of all items of a given resource type, although this doesn't
    make sense as it is now possible for a user to accidentally delete all items of
    the resource type. For this and many other reasons, no server actually implements
    this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Upgradable components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the case where we need to make changes to the UI and this is not going
    to affect the server logic. If a website was not split according to client and
    server architecture, we would have to upgrade the complete website and this would
    be quite a time-consuming task. Thanks to the split of frontend and backend, we
    can make changes and upgrade only the required system. Thus, we can ensure minimal
    disruption of service.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of a REST server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have an understanding of how a REST application should behave, let's
    build one! We shall start out by first building a simple web server, then design
    the books REST server by describing design decisions and API definitions, and
    finally build a REST server based on the design.
  prefs: []
  type: TYPE_NORMAL
- en: A simple web server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go provides us with an inbuilt library for building web servers, `net/http`.
    For every endpoint we want to create on our server, we have to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a handler function for the endpoint, which accepts two parameters, one
    for writing to response and one to handle the incoming Request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the endpoint using `net/http.HandleFunc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following is a simple web server that accepts all incoming requests, logs
    them on to the console, and then returns a `Hello, World!` message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some sample requests and responses when requesting the URL in the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is the server output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that even though we have provided multiple paths, they are all defaulting
    to the `/` path.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a REST API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have looked at the history behind HTTP and the core concepts behind the REST
    protocol. We built a simple web server to show some of the server-side code needed
    to build a REST server. It is time for us to design and build a REST server using
    everything we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by defining the data format for our REST API, and then we will
    create a web server that works as per the REST API specifications we defined.
  prefs: []
  type: TYPE_NORMAL
- en: The data format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we will describe the format of the book resource, and then
    we will start defining each of the REST API interactions as well as the expected
    result from these interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The book resource
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following is the basic definition of a book resource. It is a JSON array
    with the format `"<key>": "<value-type>"`, though the actual entities used in
    the application will consist of real values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: GET /api/books
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This REST API call will retrieve a list of all items of the book resource type.
    The response's JSON format in our example consists of an array of the book resource
    type. However, this return format is not the only way to return items. An alternate
    but more popular format consists of a JSON object with key "data" that consists
    of the actual results and any further keys that the server might want to send
    back in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the simple format we will be using in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: GET /api/books/<id>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This form of the `GET` call will retrieve a single book resource item based
    on the `<id>` provided. In general the response's JSON object will be of the defined
    resource type, though a server might decide to add or remove certain fields based
    on the service's logic. For our API, we will return all the fields defined in
    our resource type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example when we try to retrieve a book resource with id `"1"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: POST /api/books
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This REST API call will create a new item of book resource type. However, in
    order to create a new item, we would need to provide all the necessary data. It
    is possible to have `POST` requests that do not require any extra information.
    But in our case, we need to send information such as the `title` and `link` to
    the book as request's payload.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we want to create a book item with the title `"book5"` and
    link `"http://link-to-book5.com"`. Note that since our server already has two
    items of the book resource type, the new item is created with id of `"3"`; this
    is the implementation as per our server. Other REST servers might behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: PUT /api/books/<id>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We will use `PUT` in our REST API to update a specific resource type. `PUT`
    defined in our API is stringent with accepting the payload without complete data,
    that is, it will reject with incomplete payloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will modify the newly created book `"3"` and change its
    link to point at `"http://link-to-book-15.com"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: DELETE /api/books/<id>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the REST API call used to delete a specific book resource. This kind
    of request doesn't need a body and only requires the book id as part of the URL
    as shown in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will delete book `2`. Note that we do not return anything
    in response; other REST servers might return the deleted item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unsuccessful requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is possible that we could send ill-constructed requests, requests on unavailable
    entities, or bad incomplete payloads. For all such instances, we will send relevant
    HTTP error codes. Depending upon a server's implementation, it is possible to
    return a single error code. Some servers return a standard error code "404" for
    added security to not let malicious users try to find items of resource type they
    do not own.
  prefs: []
  type: TYPE_NORMAL
- en: Design decisions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have defined our REST API and next we would like to implement the server.
    It is important to formulate what we want our server to accomplish before writing
    any code. The following are some of the specifications for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to extract `<id>` for `PUT`, `DELETE`, and single resource `GET` Requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to log every incoming request similar to the `helloWorldHandler`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be tedious and bad coding practice to duplicate so much effort. We
    can make use of closures and function literals to create new functions for us
    that will combine the tasks from previous two points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to keep the example simple, we shall be using a `map[string]bookResource`
    to store the state of all book resources. All operations will be done on this
    map. In real-world servers, we would generally be using a database to store these
    resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go server can handle concurrent requests, and this means that we should ensure
    that the map of book resources is safe from race conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at what the code might look like based on the design we came up with.
  prefs: []
  type: TYPE_NORMAL
- en: The REST server for books API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have divided our program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at the source code of each file.
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `main.go` source file consists of code mostly responsible for assembling
    and running the web server. The logic to actually respond to HTTP requests are
    distributed across other files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: books-handler/common.go
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The code in this source file is generic logic, which might be shared across
    multiple requests:'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally a good practice to identify the logic that is not tied to one
    particular handler and then move it into `common.go` or similar source files,
    as this would make them easier to find and reduce duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: books-handler/actions.go
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This source file consists of functions to handle each of the HTTP request''s
    method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: books-handler/handler.go
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `handler.go` source file consists of all logic required to work with and
    handle book requests. Note that apart from consisting the logic for handling HTTP
    requests, it also deals with maintaining the state of books on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have created a REST server from scratch, this is not a complete
    REST server. To make writing a REST server feasible, a lot of important details
    have been left out. But in reality, we should use one of the existing libraries
    that will help us build a proper REST server.
  prefs: []
  type: TYPE_NORMAL
- en: So far so good but how do we interact with a REST server and with the server
    based on the code we have seen so far? Let's look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to make REST calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have used the web browser to make HTTP requests. This works
    for a normal HTTP server or to make simple `GET` Requests to a REST server. However,
    the browser will not be able to make other type of REST calls on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Most web applications use JavaScript, Ajax, and other frontend technologies
    to interact with a REST server. However, we do not have to create a full-blown
    web frontend to interact with a REST server; we can make use of a few tools and
    also write programs to make REST calls for us.
  prefs: []
  type: TYPE_NORMAL
- en: cURL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: cURL is a free command-line tool used to interact over a computer network. It
    can be used to communicate over multiple protocols including HTTP, HTTPS, FTP,
    SCP, and so on. Let's make REST calls to the server created in the previous section.
    To improve readability, we can make use of the `jq` library.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s now look at cURL commands to make HTTP requests. Depending on the state
    of your server, the output on making the `GET` Request might be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Assuming that we have a book with the id `"2"`, we can delete it using cURL,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: PUT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s update an existing book resource with the id `"4"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: POST
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we know how to send payload to a server using cURL, let''s create
    a new book resource item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the commands for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`curl -L localhost:8080/api/books | jq # GET CALL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl localhost:8080/api/books/3 | jq # GET a single resource.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl -LX DELETE localhost:8080/api/books/2 | jq # DELETE a resource.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl -H "Content-Type: application/json" -LX PUT -d ''{"title": "New Book
    Title", "link": "New Link"}'' localhost:8080/api/books/4 | jq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl -H "Content-Type: application/json" -LX POST -d ''{"title":"Ultra New
    Book", "link": "Ultra New Link"}'' localhost:8080/api/books/ | jq # POST ie.,
    create a new resource.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the following is the server''s console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to keep in mind is that even though we use redirection flag
    `-L`, for POST requests the body will not be sent. We need to make sure that we
    are sending it to finally resolved endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: This should give us the basic idea of how to use a REST client.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now look at a GUI-based tool that can be used to make REST calls called
    **Postman** ([https://www.getpostman.com/](https://www.getpostman.com/)). For
    the sake of brevity, we shall look at a `GET` and a `POST` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates how to make a `GET` request using Postman.
    Note how Postman allows us to view the returned JSON in an easy-to-read format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2ca97d8-66c9-4629-b037-cdf38406349c.png)'
  prefs: []
  type: TYPE_IMG
- en: GET /api/books
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how to make a `POST` request. Note that we could
    easily provide it with a JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a96d1b37-ddb5-4eb0-b640-5e525e3e100e.png)'
  prefs: []
  type: TYPE_IMG
- en: POST /api/books
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the previous sections and these screenshots are sufficient to get
    an understanding of how to use Postman.
  prefs: []
  type: TYPE_NORMAL
- en: net/http
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at how to send `GET` and `POST` from Go programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the console output from running the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Further details regarding the `net/http` library can be found at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed the brief history of HTTP and sessions. Next,
    we looked at the problems REST protocols were designed to solve and how they came
    into prominence. Then, we developed a deep understanding of what a REST protocol
    is, how to design an application based around it, how to build a REST server based
    on our design, and finally we looked at different ways to interact with a REST
    server using cURL, Postman, and Go programs. You're free to use whichever you
    want to interact with a REST server. However, for the remainder of the book, we
    will see interactions with REST servers using cURL.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed all the important topics that are fundamental to
    develop distributed and web-oriented applications. In the next chapter, [Chapter
    5](../Text/Ch05.xhtml), *Introducing Goophr* we can start discussing what a distributed
    document indexer is on a conceptual level and how to design it, plan for data
    communication, and so on.
  prefs: []
  type: TYPE_NORMAL
