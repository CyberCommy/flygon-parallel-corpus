- en: Never Stop Aiming for Better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you want code that is easier to maintain? How about easier to test? Easier
    to extend? **Dependency Injection** (**DI**) might be just the tool you need.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will define DI, perhaps in a somewhat atypical way, and
    explore the code smells that could indicate you need DI. We will also talk briefly
    about Go and how I would like you to approach the ideas presented in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to join me on a journey to better Go code?
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why does DI matter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should I apply DI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I improve as a Go programmer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you will have Go installed. It is downloadable from [https://golang.org/](https://golang.org/) or
    your preferred package manager.
  prefs: []
  type: TYPE_NORMAL
- en: All code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch01](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch01).
  prefs: []
  type: TYPE_NORMAL
- en: Why does DI matter?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As professionals, we should never stop learning. Learning is the one true way
    to ensure we stay in demand and continue delivering value to our customers. Doctors,
    lawyers, and scientists are all highly respected professionals and all focus on
    continuously learning. Why should programmers be different?
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will take a journey that will start with some code that *gets
    the job done* and, by selectively applying various DI methods available in Go,
    together, we will transform it into something a hell of a lot easier to maintain,
    test, and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Not everything in this book is *traditional* or perhaps even *idiomatic*, but
    I would ask you to *try it before you deny it*. If you like it, fantastic. If
    not, at least you learned what you don't want to do.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do I define DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is *coding in such a way that those resources (that is, functions or structs)
    that we depend on are abstractions*. Because these dependencies are abstract,
    changes to them do not necessitate changes to our code. The fancy word for this
    is **decoupling**.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the word abstraction here may be a little misleading. I do not mean
    an abstract class like you find in Java; Go does not have that. Go does, however,
    have interfaces and function literals (also known as **closures**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of an interface and the `SavePerson()` function
    that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, what does `Saver` do? It saves some `bytes` somewhere.
    How does it do this? We don't know and, while working on the `SavePerson` function,
    we don't care.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example that uses a function literal**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What does `decodePerson` do? It converts the `bytes` into a person. How? We
    don't need to know to right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first advantage of DI that I would highlight to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DI reduces the knowledge required when working on a piece of code, by expressing
    dependencies in an abstract or generic manner**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's say that the preceding code came from a system that stored data in
    a **Network File Share** (**NFS**). How would we write unit tests for that? Having
    access to an NFS at all times would be a pain. Any such tests would also fail
    more often than they should due to entirely unrelated issues, such as network
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, by relying on an abstraction, we could swap out the code
    that saves to the NFS with fake code. This way, we are only testing our code in
    isolation from the NFS, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if the preceding code looks unfamiliar; we will examine all of the
    parts in depth later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which brings us to the second advantage of DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DI enables us to test our code in isolation of our dependencies**'
  prefs: []
  type: TYPE_NORMAL
- en: Considering the earlier example, how could we test our error-handling code?
    We could shut down the NFS through some external script every time we run the
    tests, but this would likely be slow and would definitely annoy anyone else that
    depended on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we could quickly make a fake `Saver` that always failed,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above test is fast, predictable, and reliable. Everything we could want
    from tests!
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the third advantage of DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DI enables us to quickly and reliably test situations that are otherwise
    difficult or impossible**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s not forget about the traditional sales pitch for DI. Tomorrow, if we
    decided to save to a NoSQL database instead of our NFS, how would our `SavePerson` code
    have to change?  Not one bit. We would only need to write a new `Saver` implementation,
    giving us the fourth advantage of DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DI reduces the impact of extensions or changes**'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, DI is a tool—a handy tool, but no magic bullet. It's
    a tool that can make code easier to understand, test, extend, and reuse—a tool
    that can also help reduce the likelihood of circular dependency issues that commonly
    plague new Go developers.
  prefs: []
  type: TYPE_NORMAL
- en: Code smells that indicate you might need DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The saying *to a man with only a hammer, every problem looks like a nail* is
    old and yet is never truer than in programming. As professionals, we should be
    continually striving to acquire more tools to be better equipped for whatever
    our job throws at us. DI, while a highly useful tool, is useful only for particular
    nails. In our case, these nails are **code smells**. Code smells are indications
    in the code of a potentially deeper problem.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different types of code smell; in this section, we will examine
    only those that can be alleviated by DI. In later chapters, we will reference
    these smells as we attempt to remove them from our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code smells generally fall into four different categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Code bloat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resistance to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wasted effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tight coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code bloat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code bloat smells are cases where unwieldy slabs of code have been added to
    structs or functions so that they have become hard to understand, maintain, and
    test. Frequently found in older code, they are often the result of a gradual degradation
    and lack of maintenance rather than intentional choices.
  prefs: []
  type: TYPE_NORMAL
- en: They can be found with a visual scan of the source code or by employing a cyclomatic
    complexity checker (a software metric that indicates the complexity of a piece
    of code) such as gocyclo ([https://github.com/fzipp/gocyclo](https://github.com/fzipp/gocyclo)).
  prefs: []
  type: TYPE_NORMAL
- en: 'These smells include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long methods**: While the code is run on computers, it is written for humans.
    Any method of more than about 30 lines should be split into smaller chunks. While
    it makes no difference to the computer, it makes it easier for us humans to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long structs**: Similar to long methods, the longer a struct, the harder
    it is to understand and therefore maintain. Long structs typically also indicate
    the struct is doing too much. Splitting one struct into several smaller ones is
    also a great way to increase the reusability potential of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long parameter lists**: Long parameter lists also indicate that the method
    is likely doing more than it should. When adding new features, it is tempting
    to add a new parameter to an existing function to account for the new use case.
    This is a slippery slope. This new parameter is either optional/unnecessary for
    the existing use cases or is an indication of a significant increase in complexity
    in the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long conditional blocks**: Switch statements are amazing. The problem is
    they are very easy to abuse and tend to multiply like proverbial rabbits. Perhaps
    the most significant problem, however, is their effect on the readability of the
    code. Long conditional blocks take up a lot of space and interrupt the readability
    of the function. Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By taking `interface{}` as input, anywhere we wish to use it, we are almost
    forced to have a switch like this one. We would be better off changing from `interface{}`
    to an interface and then adding the necessary operations to the interface. This
    approach is better illustrated by the `json.Marshaller` and `driver.Valuer` interfaces
    in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Applying DI to these smells will typically reduce the complexity of individual
    pieces of code by breaking them into smaller, separate pieces, which in turn makes
    them easier to understand, maintain, and test.
  prefs: []
  type: TYPE_NORMAL
- en: Resistance to change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are cases where it is difficult and/or slow to add new features. Similarly,
    tests are often harder to write, especially tests for failure conditions. Similar
    to code bloat, these smells can be the result of a gradual degradation and lack
    of maintenance, but they can also be caused by a lack of up-front planning or
    poor API design.
  prefs: []
  type: TYPE_NORMAL
- en: They can be found by examining the pull request log or commit history and, in
    particular, determining if new features require many small changes in different
    parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: If your team tracks feature velocity and you notice it is declining, this is
    also a likely cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'These smells include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shotgun surgery**: This is when small changes made to one struct necessitate
    changes in other structs. These changes imply that the organisation or abstraction
    used was incorrect. Typically, all of these changes should be in one class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, you can see how adding an email field to the person
    data would result in changing all three structs (`Presenter`, `Validator`, and
    `Saver`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Leaking implementation details**: One of the more popular idioms in the Go
    community is *accept interfaces, return structs*. It''s a catchy turn of phrase,
    but its simplicity masks its cleverness. When a function accepts a struct, it
    ties the user to a particular implementation—a strict relationship that makes
    future changes or additional usage difficult. By extension, if that implementation
    detail were to change, the API changes and forces changes on its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying DI to these smells is typically a good investment in the future. While
    not fixing them is not fatal, the code will progressively degrade until you are
    dealing with the proverbial *big ball of mud*. You know the type—a package that
    no-one understands, no-one trusts, and only the brave or stupid are willing to
    make changes to. DI enables you to decouple from the implementation choices, thereby
    making it easier to refactor, test, and maintain small chunks of code in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Wasted effort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These smells are cases where the cost to maintain the code is higher than it
    needs to be. They are typically caused by laziness or lack of experience. It's
    always easier to copy/paste code than to carefully refactor it. The problem is,
    coding like this is like eating unhealthy snacks. It feels great in the moment,
    but the long-term consequences suck.
  prefs: []
  type: TYPE_NORMAL
- en: They can be found by taking a critical look at the source code and asking yourself
    *do I really need this code?* Or, *can I make this easier to understand?*
  prefs: []
  type: TYPE_NORMAL
- en: Using tools such as dupl ([https://github.com/mibk/dupl](https://github.com/mibk/dupl)) or
    PMD ([https://pmd.github.io/](https://pmd.github.io/)) will also help you identify
    areas of the code to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'These smells include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excessive duplicated code**: Firstly, please, please do not become a zealot
    about this one. While in most cases, duplicated code is a bad thing, sometimes
    copying code can result in a system that is easier to maintain and can evolve.
    We will deal with a common source of this smell in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excessive comments**: Leaving a note for those that come after you, even
    it is only you 6 months from now, is a friendly and professional thing to do.
    But when that note becomes an essay, then it''s time to refactor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Overly complicated code**: The harder code is for other people to understand,
    the worse it is. Typically, this is the result of someone trying to be too fancy
    or not putting enough effort into structure or naming. Taking a more selfish view,
    if you are the only one who understands a piece of code, you are the only one
    that can work on it. Meaning, you are doomed to maintain it forever. What does
    the following code do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**DRY/WET code**: The **Don''t Repeat Yourself** (**DRY**) principle is aimed
    at reducing duplicated efforts by grouping responsibilities together and providing
    clean abstractions. By contrast, in WET code, sometimes called **Waste Everyone''s
    Time** code, you will find the same responsibility in many places. This smell
    often appears in formatting or conversion code. This sort of code should exist
    at the system boundaries, that is, converting user input or formatting output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While many of these smells can be fixed without DI, DI provides an easier way
    to *lift and shift* the duplication into an abstraction that can then be used
    to reduce the duplication and improve the readability and maintainability of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Tight coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For people, tight coupling might be a good thing. For Go code, it's really not.
    Coupling is a measure of how objects relate to or depend on each other. When the tight
    coupling is present, this interdependence forces the objects or packages to evolve
    together, adding complexity and maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling-related smells are perhaps the most insidious and obstinate but by
    far the most rewarding when dealt with. They are often the result of a lack of
    object-oriented design or insufficient use of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, I don't have a handy tool to help you find these smells but I am confident
    that, by the end of this book, you will have no trouble spotting and dealing with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, I find it useful to implement a feature in a tightly coupled form
    first and then work backward to decouple and thoroughly unit test my code before
    submitting it. For me, it is especially helpful in cases where the correct abstractions
    are not obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'These smells include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependence on God objects**: These are large objects that *know too much* or
    *do too much*. While this is a general code smell and something that should be
    avoided like the plague, the problem from a DI perspective is that too much of
    the code is dependent on this one object. When they exist and we are not careful,
    it won''t be long before Go will be refusing to compile due to a circular dependency.
    Interestingly, Go considers dependencies and imports not at an object level but
    at a package level. So we have to avoid God packages as well.  We will address
    a very common God object problem in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular dependencies**: These are where package A depends on package B,
    and package B depends on package A. This is an easy mistake to make and sometimes
    a hard one to get rid of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, while the config is arguably a `God` object and therefore
    a code smell, I am hard pressed to find a better way to import the config from
    a single JSON file. Instead, I would argue that the problem to be solved is the
    use of the `config` package by `orders` package. A typical config God object follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the attempted usage of the `config` package, you can see that the `Currency`
    type belongs to the `Package` package and so including it in `config`, as shown
    in the preceding example, causes a circular dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Object orgy**: These occur when an object has too much knowledge of and/or
    access to the internals of another or, to put it another way, *insufficient encapsulation
    between objects*. Because the objects are *joined at the hip*, they will frequently
    have to evolve together, increasing the cost of understanding the code and maintaining
    it. Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `PageLoader` repeatably calls the member variable of the `Fetcher`.
    So much so that, if the implementation of `Fetcher` changed, it's highly likely
    that `PageLoader` would be affected. In this case, these two objects should be
    merged together as `PageLoader` has no extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Yo-yo problem**: The standard definition of this smell is *when the inheritance
    graph is so long and complicated that the programmer has to keep flipping through
    the code to understand it*. Given that Go doesn''t have inheritance, you would
    think we would be safe from this problem. However, it is possible if you try hard
    enough, with excessive composition. To address this issue, it''s better to keep
    relationships as shallow and abstract as possible. In this way, we can concentrate
    on a much smaller scope when making changes and compose many small objects into
    a larger system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature envy**: When a function makes extensive use of another object, it
    is envious of it. Typically, an indication that the function should be moved away
    from the object it is envious of. DI may not be the solution to this, but this
    smell does indicate high coupling and, therefore, is an indicator to consider
    applying DI techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As your code becomes less coupled, you will find the individual parts (packages,
    interfaces, and structs) will become more focused. This is referred to as having
    **high cohesion**. Both low coupling and high cohesion are desirable as they make
    the code easier to understand and work with.
  prefs: []
  type: TYPE_NORMAL
- en: Healthy skepticism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we journey through this book, you will look at some fantastic coding techniques
    and some not so great. I would ask you to spend some time pondering which is which. Continuous
    learning should be tempered with a healthy dose of skepticism. For each technique,
    I will lay out the pros and cons, but I would ask you to dig deeper. Ask yourself
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is this technique trying to achieve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would my code look like after I apply this technique?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I really need it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any downsides to using this method?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even when your inner skeptic dismisses the technique, you've at least learned
    to identify something you don't like and don't want to use, and learning is always
    a win.
  prefs: []
  type: TYPE_NORMAL
- en: A quick word about idiomatic Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Personally, I try to avoid using the term **idiomatic Go** but a Go book is
    arguably not complete without addressing it in some form. I avoid it because I
    have seen it too often used as a stick to beat people. Essentially, *this is not
    idiomatic, therefore it's wrong* and, by extension, *I am idiomatic and therefore
    better than you*. I believe that programming is a craft and, while a craft should
    have some form of consistency in its application, it should, as with all crafts,
    be flexible. After all, innovation is often found by bending or breaking the rules.
  prefs: []
  type: TYPE_NORMAL
- en: So what does idiomatic Go mean to me?
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll define it as loosely as I can:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Format your code with** `gofmt`: Truly one less thing for us programmers
    to argue about. It''s the official style, supported with official tools. Let''s
    find something more substantive to argue about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read, apply, and regularly revisit the ideas in *Effective Go* ([https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)) and
    *Code Review Comments* ([https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments))**: There
    is a huge amount of wisdom in these pages, so much so that it''s perhaps impossible
    to glean it all from just one reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggressively apply the *Unix philosophy***: It state that we should *design
    code that does a single thing, but to does it well and works well together well
    with other code**.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While these three things are the minimum for me, there are a couple of other
    ideas that resonate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accepting interfaces and returning structs**: While accepting interfaces
    leads to nicely decoupled code, the returning structs might strike you as a contradiction.
    I know they did with me at first. While outputting an interface might feel like
    it''s more loosely coupled, it''s not. Output can only be one thing—whatever you
    code it to be. Returning an interface is fine if that''s what you need, but forcing
    yourself to do so just ends up with you writing more code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reasonable defaults**: Since switching to Go, I''ve found many cases where
    I want to offer my user the ability to configure the module but such configuration
    is frequently not used. In other languages, this could lead to multiple constructors
    or seldom used parameters, but by applying this pattern we end up with a much
    cleaner API and less code to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave your baggage at the door
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to ask me *what is the most frequent mistake new Go programmers
    make*?, I would not hesitate to tell you that it's bringing other language patterns
    into Go. I know this was my biggest early mistake. My first Go service looked
    like a Java app written in Go. Not only was the result subpar but it was rather
    painful, particularly while I was trying to achieve things such as inheritance.
    I've had a similar experience programming Go in a functional style, as you might
    see in `Node.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In short, please don't do it. Re-read *Effective Go* and Go blogs as often as
    you need to until you find yourself using small interfaces, firing off Go routines
    without reservation, loving channels, and wondering why you ever needed more than
    composition to achieve nice polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started a journey—a journey that will lead to code that
    is easier to maintain, extend, and test.
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining DI and examining some of the benefits it can bring us.
    With the help of a few examples, we saw how this might look in Go.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we started identifying code smells to look out for and that could
    be addressed or alleviated by applying DI.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined what I believe Go code looks like, and I challenged you
    to be skeptical and apply a critical eye to techniques presented in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is DI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four highlighted advantages of DI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What sorts of issues does it address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to be skeptical?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does idiomatic Go mean to you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has many other great resources for learning about DI and Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/java-9-dependency-injection](https://www.packtpub.com/application-development/java-9-dependency-injection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/dependency-injection-net-core-20](https://www.packtpub.com/application-development/dependency-injection-net-core-20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/networking-and-servers/mastering-go](https://www.packtpub.com/networking-and-servers/mastering-go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
