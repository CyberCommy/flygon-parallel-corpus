- en: Build an Application Exploring TDD Using Jest and Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep your application maintainable, it is good practice to have testing set
    up for your project. Where some developers hate writing tests and therefore try
    to avoid writing them, other developers like to make testing the core of their
    development process by implementing a **test-driven development** (**TDD**) strategy.
    There are many opinions about testing your applications and how to do this. Luckily,
    when building an application with React, many great libraries can help you with
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll use two libraries to unit test React applications. The
    first one is Jest, which is maintained by Facebook itself and ships with Create
    React App. The other tool is called Enzyme, which has more functionality than
    Jest and can be used to test entire life cycles within your components. Together,
    they are a great fit for testing most React applications if you want to test whether
    functions or components behave as expected when they're given a certain input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering React components for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with Enzyme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a hotel review application that has unit and
    integration testing in place with Jest and Enzyme. The application has been prebuilt
    and uses the same patterns that we've looked at in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application for this chapter builds upon an initial version, which can be
    found at [https://github.com/PacktPublishing/React-Projects/tree/ch6-initial](https://github.com/PacktPublishing/React-Projects/tree/ch6-initial). The
    complete code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch6](https://github.com/PacktPublishing/React-Projects/tree/ch6).
  prefs: []
  type: TYPE_NORMAL
- en: Start by downloading the initial project from GitHub and move into the root
    directory for this project, where you must run the `npm install` command. Since
    this project builds upon Create React App, running this command will install `react`, `react-dom`, and `react-scripts`.
    Also, `styled-components` and `react-router-dom` will be installed so that they
    can handle styling and routing for the application. After finishing the installation
    process, you can execute the `npm start` command to run the application so that
    you can visit the project in the browser at `http://localhost:3000`. Just like
    with the applications you've built in the previous chapters, this application
    functions as a PWA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial application consists of a simple header and a list of hotels. These
    hotels have a title and meta information, like a thumbnail. This page will look
    as follows. If you click on any of the hotels in the list, a new page will open
    with a list of reviews for this hotel. By clicking the button at the top left
    of this page, you can move back to the previous page, and with the button at the
    top right, a page with a form where you can add a review will open. If you add
    a new review, this data will be stored in a global Context and sent to a mock
    API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c25bf83e-16c2-42a4-a572-8dffff5127ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the project''s structure, you''ll see that it''s using the same
    structure as the projects we created previously. The entry point of this application
    is a file called `src/index.js`, which renders a component called `App`. In this `App` component,
    all the routes are declared and wrapped within a router component. Also, the component
    that holds the global Context and the Providers is declared here. Compared to
    the applications you created previously, the container component pattern isn''t
    used in this application. Instead, all the data fetching is done by the Context
    components. Life cycles are accessed using Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding project structure, you can see there are also two files in
    the `public/assets` directory, which are the thumbnails for the hotels. To make
    them available in the rendered application, you can place them in the `public` directory.
    Also, there is a file called `api.js` in `src` that exports the functions so that `GET` and `POST` requests
    can be sent to an API.
  prefs: []
  type: TYPE_NORMAL
- en: Hotel review application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add unit and integration testing to the hotel review
    application that was created in Create React App. This application lets you add
    reviews to a list of hotels and controls this data from a global Context. Jest
    and Enzyme will be used to render React components without a DOM and test assertions
    on these components.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is an important part of your application since you want to know
    that your functions and components behave as expected, even when you make code
    changes. For this, you're going to use Jest, an open source testing package for
    JavaScript applications that was created by Facebook. With Jest, you can test
    assertions, for example, if the output of a function matches the value you expected.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Jest, you don't have to install anything; it's part of Create
    React App. If you look at the `package.json` file, you will see that a script
    is already there for running tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if you execute the following command from your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a message saying `No tests found related to files changed
    since last commit.`, which means Jest is running within watch mode and only running
    tests for files that have been changed. By pressing the `a` key, you can run all
    the tests, even if you haven''t modified any files. If you press this key, the
    following message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This message states that `26` files have been investigated, but no tests have
    been found. It also states that it's looking for JavaScript or JSX files in directories
    called `__tests__` in your project and files that have the `spec` or `test` suffix.
    The `node_modules` directory, which is where all the `npm` packages are installed,
    is ignored. From this message, you may have noticed that Jest automatically detects
    files with tests for you.
  prefs: []
  type: TYPE_NORMAL
- en: Creating these tests can be done with Jest, which will be demonstrated in the
    first part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since there are multiple ways Jest can detect which file contains a test, let''s
    choose the structure where every component has a separate test file. This test
    file will have the same name as the file that holds the component, with the `.test` suffix.
    If we choose the `SubHeader` component, we can create a new file called `SubHeader.test.js` in
    the `src/components/Header` directory. Add the following code to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Two global functions from Jest are used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describe`: This is used to define a block of related tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it`: This is used to define a test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the definition of a test, you can add assumptions such as `toEqual` or
    `toBe`, which check whether the value is exactly equal to something or whether
    just the types match, respectively. The assumptions can be added within the callback
    of the `it` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you still have the test script running in your Terminal, you will see that
    Jest has detected your test. The test succeeds since `1+2` is indeed `3`. Let''s
    go ahead and change the assumption to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, the test will fail as the second assumption doesn't match. Although `1+2` still
    equals `3`, it's assumed that a string type with a value pf `3` is returned, while
    in fact a number type is returned. This helps you when you're writing your code
    as you can make sure that your application doesn't change the types of its values.
  prefs: []
  type: TYPE_NORMAL
- en: However, this assumption has no actual usage as it doesn't test your component.
    To test your component, you need to render it. Rendering components so that you
    can test them will be handled in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a React component for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jest is based upon Node.js, meaning that it can''t use the DOM to render your
    component and test its functionality. Therefore, you need to add a React core
    package to your project, which can help you render the component without a DOM.
    Let''s take a look at this here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Terminal, execute the following command, which will install `react-test-renderer`
    in your project. It can be installed as a devDependency as you don''t need to
    run tests on the build version of your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With `react-test-renderer` installed, you can now import this package into
    the `src/components/Header/SubHeader.test.js` file. This package returns a method
    called `ShallowRenderer` that lets you render the component. With Shallow rendering,
    you only render a component at its first level, thereby leaving out any possible
    children components. You also need to import React and the actual component you
    want to test since these are used by `react-test-renderer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In your test, you can now render the component with `ShallowRenderer` and get
    the output of this component. With the Jest `toMatchSnapshot` assumption, you
    can test the structure of the component. `ShallowRenderer` will render the component
    and `toMatchSnapshot` will create a snapshot from this render and compare it to
    the actual component every time this test is run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `src/components/Header` directory, a new directory called `__snapshots__`
    has now been created by Jest. Inside this directory is a file called `SubHeader.test.js.snap`,
    which includes the snapshot. If you open this file, you will see that a rendered
    version of the `SubHeader` component is stored here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The components that have been created with `styled-components` cannot be rendered
    by `react-test-renderer` because of how they're exported by `styled-components`.
    If you look at the code for the `SubHeader` component, you will see that the `ForwardRef` components
    represent `SubHeaderWrapper` and `Title`. Later in this chapter, we will use Enzyme
    for testing, which handles this test scenario better.
  prefs: []
  type: TYPE_NORMAL
- en: 'No actual values are being rendered by `react-test-renderer` since no props
    have been passed to the `SubHeader` component. You can inspect how the snapshot
    works by passing, for instance, a `title` prop to the `SubHeader` component. To
    do this, create a new test scenario, which should render `SubHeader` with a title.
    Also, move the creation of the `renderer` constant to the `describe` function,
    so that it can be used by all the test scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time the tests are run, a new snapshot will be added to the `src/components/Header/__snapshots__/SubHeader.test.js.snap` file.
    This snapshot has a value rendered for the `title` prop. If you change the `title` prop
    that is displayed by the `SubHeader` component in your test file, the rendered
    component will no longer match the snapshot. You can try this by changing the
    value for the `title` prop in the test scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Jest will return the following message in the Terminal, where it specifies
    which lines have changed in comparison to the snapshot. In this case, the title
    that''s being displayed is no longer `Test Application` but `Test Application
    Test`, which doesn''t match the title in the snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By pressing the `u` key, you can update the snapshot to handle this new test
    scenario. This is an easy way to test the structure of your component and see
    if the title has been rendered. With the preceding test, the initially created
    snapshot still matches the rendered component for the first test. Also, another
    snapshot was created for the second test, where a `title` prop was added to the
    `SubHeader` component.
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same for the other props that are passed to the `SubHeader` component,
    which renders differently if you do or don't pass certain props to it. Next to
    `title`, this component takes `goBack` and `openForm` as props, where the `openForm` prop
    has a default value of false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just like we did for the `title` prop, we can also create test scenarios for
    the two other props. When there''s a value for `goBack`, a button is created that
    takes us back to the previous page, while when there''s a value for `openForm`,
    a button is created that allows us to proceed to the next page so that we can
    add a new review. You need to add these two new test scenarios to the `src/components/Header/SubHeader.test.js` file
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve now created two more snapshots for the `SubHeader` component, which
    leads to a total of four snapshots. Something else that Jest does is show you
    how many lines of code have been covered by your tests. The higher your testing
    coverage, the more reason to assume your code is stable. You can check the test
    coverage of your code by executing the `test` script command with the `--coverage`
    flag, or use the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will run your tests and generate a report with all the test coverage
    information about your code per file. After adding the tests for `SubHeader`,
    this report will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Testing coverage only tells us something about the lines and the functions of
    your code that have been tested and not their actual implementation. Having a
    test coverage of 100% doesn't mean there aren't any bugs in your code as there
    will always be edge cases. Also, getting to a testing coverage of 100% means you
    may end up spending more time on writing tests than on actual code. Usually, a
    testing coverage above 80% is considered good practice.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the test coverage for the component is 100%, meaning that all
    the lines are covered in your test. However, this method of testing with snapshots
    will create a lot of new files and lines of code. We'll look at other ways we
    can test our components in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components with assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, snapshot testing is not necessarily bad practice; however, your files
    can get quite big over time. Also, since you're not explicitly telling Jest what
    part of the component you want to test, you might need to update your code regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, using snapshots isn't the only method we can use to test whether our
    components are rendering the correct props. Instead, you can also directly compare
    which props are being rendered by checking the value of the component and making
    assertions. The big advantage of testing with assertions is that you can test
    a lot without having to dig deeper into the logic of the component you're testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can see what the children that are being rendered look like.
    Let''s take a look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a snapshot test for the `Button` component to compare
    the impact of test coverage. Create a new file called `src/components/Button/Button.test.js`.
    In this file, you need to insert a test that creates a snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the tests with the `--coverage` flag, a new test coverage report
    will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This report generates the following report, which shows the coverage for the
    `Button` component, which is 100%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the snapshot for the `Button` component, which is in the `src/components/Button/__snapshots__/Button.test.js.snap` file,
    you will see that the only thing that''s been rendered within the button (represented
    by `ForwardRef`) is the `children` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the testing coverage is at 100%, there are other ways to test whether
    the correct children have been rendered. For this, we can create a new test that
    also uses `ShallowRenderer` and tries to render the `Button` component with a
    child. This test has the assertion that the rendered `children` prop is equal
    to the actual `children` prop that was rendered by `Button`. You can remove the
    snapshot test since you only want to test the children with assertions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From your Terminal, run `npm run test --coverage` again to check the impact
    this testing method has on the test coverage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding report, you can see that the testing coverage is still 100%,
    meaning that this testing method has the same outcome. But this time, you're specifically
    testing whether the children are equal to that value. The upside is that you don't
    have to update snapshots every time you make code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, a message noting `1 snapshot obsolete` is shown. By running `npm run
    test` with the `-u` flag, the snapshot for the `Button` component is removed by
    Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides us with the following output, which shows us that the snapshot
    has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, the `Button` component doesn't just take the `children` prop – it also
    takes the `onClick` prop. If you want to test whether this `onClick` prop is triggered
    when you click on the button, you need to render the component differently. This
    can be done by using `react-test-renderer`, but the React documentation also notes
    that you can use Enzyme for this.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll use the shallow render function from Enzyme, which
    has more options than `ShallowRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Enzyme for testing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ShallowRenderer` from `react-test-renderer` allows us to render the structure
    of a component but doesn't show us how a component interacts in certain scenarios,
    such as when an `onClick` event is being triggered. To simulate this, we'll use
    a more complex tool called Enzyme.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow rendering with Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enzyme is an open source JavaScript testing library that was created by Airbnb
    and works with almost every JavaScript library or framework. With Enzyme, you
    can also shallow render components to test the first level of the component, as
    well as render nested components, and simulate life cycles for integration tests.
    The Enzyme library can be installed with `npm`, and also needs an adapter to simulate
    React features. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Enzyme, you need to run the following command from your Terminal,
    which installs Enzyme and the specific adapter for the version of React you''re
    using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing Enzyme, you need to create a setup file that tells Enzyme
    what adapter should be used to run the tests. Normally, you''d need to specify
    which file holds this configuration in your `package.json` file, but, when you''re
    using Create React App, this is already done for you. The filename that''s automatically
    being used as the configuration file for testing libraries is called `setupTests.js`
    and should be created in the `src` directory. Once you''ve created the file, paste
    the following code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the installation of Enzyme, you can no longer use the test scenarios that
    use `react-test-renderer`. Therefore, you need to change the tests for the `SubHeader` and
    `Button` components. As we mentioned previously, Enzyme has a method that allows
    us to shallow render components. Let''s try this for the `SubHeader` component
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of importing `react-test-renderer`, you need to import `shallow` from
    Enzyme. The `ShallowRender` method should no longer be added to the `renderer`
    constant, so you can delete this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Each test scenario should be changed so that it uses the shallow render function
    from Enzyme. We can do this by replacing `renderer.render` with `shallow`. The
    function that we use to get the output of this render can be deleted as well.
    The `shallow` render from Enzyme will instantly create a result that can be tested
    by Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we did in the first test scenario, we must replace the other test
    scenarios; otherwise, the tests won''t run. This happens because we''ve already
    deleted the setup for `react-test-renderer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the Terminal, you can now run the test again by running `npm run test`. Since
    the tests are running in watch mode, the tests for the `Button` component will
    probably start running as well. You can specify which tests should be run by pressing
    the `p` key and then type `SubHeader` in the Terminal. Now, Jest will only run
    the tests for the `SubHeader` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The tests will fail as your snapshots are no longer the snapshots that were
    created by `react-test-renderer`. Enzyme''s shallow render has a better understanding
    of the exports from `styled-components` and no longer renders those components
    as a `ForwardRef` component. Instead, it returns, for instance, a component called
    `styled.div` or `styled.h2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By pressing the `u` key, all the snapshots that were created by `react-test-renderer`
    will be replaced by the new snapshots from Enzyme.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be done for the `Button` component, where no snapshot is used
    for testing. Instead, an assertion is used. In your test scenario, in the `src/components/Button/Button.test.js`
    file, replace `ShallowRenderer` with the shallow render from Enzyme. Also, the
    value for `component.props.children` is no longer present due to how Enzyme renders
    the component. Instead, you need to use the `props` method, which is available
    on the shallow rendered component, to get the `children` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All the tests should now succeed when you run the tests, and the testing coverage
    should be unaffected as you're still testing whether the props are rendered on
    your components. However, with the snapshots from Enzyme, you've got more information
    about the structure of the component that's being rendered. Now, you can test
    even more and find out how, for example, `onClick` events are being handled.
  prefs: []
  type: TYPE_NORMAL
- en: However, snapshots aren't the only way of testing your React components, as
    we'll see in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing assertions with shallow rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than `react-test-renderer`, Enzyme can handle `onClick` events on the
    shallow rendered component. To test this, you have to create a mocked version
    of the function, which should be fired once the component is clicked. After this,
    Jest can check whether or not the function was executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Button` component that you tested previously doesn''t just take `children`
    as a prop – it also takes the `onClick` function. Let''s try and see if this can
    be tested using Jest and Enzyme by creating a new test scenario in the file for
    the `Button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test scenario, a mocked `onClick` function was created with
    Jest, which is passed as a prop to the shallow rendered `Button` component. Then,
    a `simulate` method with a click event handler is invoked on that component. Simulating
    a click on the `Button` component should execute the mocked `onClick` function,
    which you can confirm by checking the test results for this test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests for the `SubHeader` component can also be updated since two buttons
    with an `onClick` event are rendered by it. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to make some changes to the file for the `SubHeader` component
    in `src/components/Header/SubHeader.js` since you need to export the components
    that have been created with `styled-components`. By doing this, they can be used
    for testing in your test scenario for `SubHeader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once they''ve been exported, we can import these components into our test file
    for `SubHeader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it possible to find these components from any of our tests. In this
    scenario, the rendering of the `title` prop is tested with a snapshot, but you
    can also directly test whether the `title` prop is being rendered by the `Title` component
    in `SubHeader`. To test this, change the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A new constant for the `title` prop is created here and passed to the `SubHeader` component.
    Instead of using a snapshot as an assertion, a new one is created that tries to
    find the `Title` component and checks whether the text inside this component is
    equal to the `title` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the `title` prop, you can also test for the `goBack` (or `openForm`)
    prop. If this prop is present, a button will be rendered that has the `goBack`
    prop as an `onClick` event. This button is rendered as a `SubHeaderButton` component.
    Here, we need to change the second test scenario so that it has a mocked function
    for the `goBack` prop and then create an assertion to check for the existence
    of `SubHeaderButton` in the rendered component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only do we want to test whether the button with the `goBack` prop is being
    rendered, but we also want to test whether this function is being called once
    we click on the button. Just like we did for the `Button` component test, we can
    simulate a click event and check whether the mocked `goBack` function was called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be done for the `openForm` prop if we replace the assertion that''s
    testing the snapshot with two assertions that test for the existence of the button
    and if it fired the mocked `openForm` function. Instead of adding this to the
    existing test scenario, we can extend the test scenario for the `goBack` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The component that is now being rendered for the `SubHeader` should have both
    a button to go back to the previous page and a button to open the form. However,
    they''re both using the `SubHeaderButton` component to render. The button to go
    back is rendered in the component tree first since it''s placed on the left-hand
    side of `SubHeader`. Therefore, we need to specify which rendered `SubHeaderButton` is
    which button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After these changes, all the test scenarios that use snapshots are removed and
    replaced with more concrete tests that are less vulnerable once we change any
    of the code. Apart from snapshots, these tests will keep working if we change
    any props that make refactoring easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've created unit tests that will test a specific part of
    our code. However, it can be interesting to test how different parts of our code
    work together. For this, we'll add integration tests to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing with Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tests that we''ve created all use shallow rendering to render components,
    but, with Enzyme, we also have the option to mount components. When using this,
    we can enable lifecycles and test larger components deeper than just the first
    level. When we want to test multiple components at once, this is called integration
    testing. In our application, the components that are rendered directly by the
    routes are rendering other components as well. A good example of this is the `Hotels` component,
    which renders the list of hotels that were returned by the Context. Let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, the starting point is to create a new file with the `.test` suffix
    in the same directory that the component we want to test is located. Here, we
    need to create the `Hotels.test.js` file in the `src/components/Hotels` directory.
    In this file, we need to import `mount` from Enzyme, import the component that
    we want to test, and create a new test scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '2\. The `Hotels` component is using the `useContext` Hook to get the data it
    needs to display the hotels. However, since this is a test for this specific component,
    that data needs to be mocked. Before we can mock this data, we need to create
    a mock function for the `useContext` Hook. If we have multiple test scenarios
    that use this mock, we also need to use the `beforeEach` and `afterEach` methods
    to create and reset this mock function for every scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the mocked `useContextMock` function to generate the data that
    will be used as a mock for the Context by the `Hotels` component. The data that
    will be returned should also be mocked, which can be done by invoking the `mockReturnValue` function,
    which is available on the mocked function. If we take a look at the actual code
    for the `Hotels` component, we will see that it takes four values from the Context: `loading`,
    `error`, `hotels`, and `getHotelsRequest`. These values should be mocked and returned
    by `mockReturnValue` in the first test scenario that we will create to check the
    behavior when the Context is loading the hotels'' data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This first test scenario checks whether the `Hotels` component will call the
    `getHotelsRequest` function from the Context when it first mounts. This means
    that the `useEffect` Hook that's used in `Hotels` has been tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the data is still loading here, we can also test whether the `Alert` component
    is rendering the `loading` value from the Context and displaying a loading message.
    Here, we need to export this component from `Hotels` in `src/components/Hotels/Hotels.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can import this component in the test file and write the assertion
    to check whether it''s displaying the value from the Context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `Hotels` component has mounted and the data has been fetched, the
    values for `loading`, `error`, and `hotels` in the Context will be updated. When
    the values for `loading` and `error` are `false`, the `HotelItemsWrapper` component
    will be rendered by `Hotels`. To test this, we need to export `HotelItemsWrapper` from
    `Hotels`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the testing file, this component can now be imported, which means we can
    add the new test scenario that checks whether this component is being rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the test, we''ll get an error saying `Invariant failed: You
    should not use <Link> outside a <Router>` since Enzyme can''t render the `Link` component,
    which is used to navigate when we click on a hotel. Due to this, we need to wrap
    the `Hotels` component within a router component from `react-router`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This test will now pass, as Enzyme can render the component, including the `Link` to
    navigate to a hotel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `HotelItemsWrapper` component is a `map` function that iterates
    over the hotel data from the Context. For every iteration, a `HotelItem` component
    will be rendered. In these `HotelItem` components, the data will be displayed
    in, for instance, a `Title` component. We can test whether the data that will
    be displayed in these components is equal to the mocked Context data. The component
    that displays the title of the hotel should be exported from `src/components/Hotels/HotelItem.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the `HotelItem` component, this should be imported into the test
    for `Hotels`. In the test scenario, we can now check for the existence of the
    `<HotelItem` component and check whether this component has a `Title` component.
    The value that''s displayed by this component should be equal to the mocked Context
    value for the title of the first row in the array of `hotels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the tests again with the `--coverage` flag, we will be able to
    see what impact writing this integration test has on our coverage. Since an integration
    test not only tests one specific component but multiple at once, the testing coverage
    for `Hotels` will be updated. This test also covers the `HotelItem` component,
    which we will be able to see in the coverage report after running `npm run test
    --coverage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The coverage for `Hotels` is close to 100%. The test coverage for `HotelItems` has
    also got to 100%. This means that we can skip writing unit tests for `HotelItem`,
    assuming that we only use this component within the `Hotels` component.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of having integration tests over unit tests is that they're
    harder to write as they usually contain more complex logic. Also, these integration
    tests will run slower than unit tests because of them having more logic and bringing
    together multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered testing for React applications using Jest in combination
    with either `react-test-renderer` or Enzyme. Both packages are a great resource
    to every developer that wants to add test scripts to their application, and they
    also work well with React. The advantages of having tests for your application
    were discussed in this chapter, and hopefully, you now know how to add test scripts
    to any project. Also, the differences between unit tests and integration tests
    were shown.
  prefs: []
  type: TYPE_NORMAL
- en: Since the application that was tested in this chapter has the same structure
    as the applications from the previous chapters, the same testing principles can
    be applied to any of the applications we've built in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will combine a lot of the patterns and libraries we've already
    used in this book as we'll be creating a full-stack e-commerce store with React,
    GraphQL, and Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enzyme shallow rendering: [https://airbnb.io/enzyme/docs/api/shallow.html](https://airbnb.io/enzyme/docs/api/shallow.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enzyme mount: [https://airbnb.io/enzyme/docs/api/mount.html](https://airbnb.io/enzyme/docs/api/mount.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
