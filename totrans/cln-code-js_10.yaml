- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter on *dynamic typing*, we explored topics such as type-coercion
    and detection; we also covered several operators. In this chapter, we'll continue
    this exploration by delving into every single operator that the JavaScript language
    makes available. Having a rich understanding of JavaScript's operators will make
    us feel utterly empowered in a language that can, at times, appear confusing.
    There is, unfortunately, no shortcut to understanding JavaScript, but as you begin
    to explore its operators, you will see patterns emerge. For example, many of the
    multiplicative operators work in a similar manner, as do the logical operators.
    Once you are comfortable with the main operators, you will begin to see that there
    is a grace underlying the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: It may be useful to treat this chapter as more of a reference if you're pressed
    for time. Do not feel like you need to exhaustively retain every detail of every
    operator's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an operator?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic and numeric operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparative operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property access operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other operators and syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''re ready to dive in, the very first question we need to ask ourselves
    is: what even *is* an operator?'
  prefs: []
  type: TYPE_NORMAL
- en: What is an operator?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operator in JavaScript is a standalone piece of syntax that forms an *expression*
    and is typically used to derive something or compute a logical or mathematical
    output from a set of inputs (called **operands**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see an expression containing an operator (`+`) with two operands
    (`3` and `5`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Any operator can be said to have four characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Its arity**: how many operands the operator accepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Its function**: what the operator does with its operands and what it evaluates
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Its precedence**: how the operator will be grouped when used in combination
    with other operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Its associativity**: how the operator will behave when neighbored with operators
    of the same precedence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to understand these foundational characteristics as it will vastly
    aid your usage of operators in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Operator arity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arity refers to how many operands (or inputs) an operator can receive. An *operand* is
    a formal term for the value(s) that you can give or pass to an operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the greater-than operator (`>`), it receives two operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `a` is its first operand (or left-side operand). And `b` is
    its second (or right-side operand). Since it receives two operands, the greater-than
    operator is considered a binary operator. In JavaScript, we have unary, binary, and ternary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one ternary operator in JavaScript, the conditional operator (`a
    ? b : c`). Since it is the only ternary operator, it is sometimes simply referred
    to as the ternary operator instead of its formal name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing about the arity of a given operator is vital—just as it would be vital
    to know how many arguments to pass a function. It''s also important to consider
    how we are communicating our intent when we compose operations. Since operations
    can appear in series, it can sometimes be unclear which operator refers to which
    operand. Consider this confusing expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid confusion in understanding operations like this, it is conventional
    to move unary operators closer to their operands and even to employ parentheses
    to make it absolutely crystal clear what the intent is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As with all of the parts of code, operators must be wielded with care and concern
    for the individual or individuals (including your future self) who'll have to
    encounter, understand, and maintain the code going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Operator function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operator's function is simply what it does and what it evaluates to. We'll
    be going over each operator individually, so there's not a lot to say here beyond
    a few basic assumptions you can carry with you when working with operators.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, every operator is its own entity and is not tied to the type
    of operands it is operated on. This is in contrast to some other languages where
    operators are mapped to overridable functions or are somehow attached to the operands
    themselves. In JavaScript, operators are their own syntactic entity and have non-overridable
    functionality. Their functionality is, however, extensible in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using any of the following types of operators, the language will internally
    attempt coercion:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators (namely, `+`, `*`, `/`, `-`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment operators (namely, `++` and `--`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operators (namely,`~`, `<<`, `|`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed member access operator (that is, `...[...]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-strict comparative operators (namely, `>`, `<`, `>=`, `<=`, and `==`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And to specifically override these mechanisms of coercion, you can supply `valueOf()`, `toString()`,
    or  `[Symbol.toPrimitive]()` methods to any objects you intend to use as operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we covered in the previous chapter's *Conversion to a primitive* section,
    these methods will be called in a specific order depending on the exact operator
    or language construct used. In the case of all arithmetic operators, for example, `valueOf` will
    be attempted before `toString`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence and associativity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of operation when multiple operators are used in combination is defined
    by two mechanisms: *precedence* and *associativity*. An operator's precedence
    is a number from `1` to `20`, and defines the order in which a series of operators
    will run. Some operators share the same precedence. Associativity defines the
    order in which operators of the same precedence will be operated on (either left-to-right
    or right-to-left).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, these specific mathematic operators have the following precedences:'
  prefs: []
  type: TYPE_NORMAL
- en: The addition operator (`+`) has a precedence of `13`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The multiplication operator (`*`) has a precedence of `14`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The division operator (`/`) has a precedence of `14`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subtraction operator (`-`) has a precedence of `13`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And all of them have *left-to-right* associativity. Since operators of higher
    precedence occur first and operators of the same precedence will occur according
    to their associativity, we can say that our example operation occurs in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication (left most amongst operators with a precedence of `14`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Division (next on the left amongst operators with a precedence of `14`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Addition (left most amongst operators with a precedence of `13`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtraction (next on the left amongst operators with a precedence of `13`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we were to group our operation explicitly using parentheses, it would, therefore,
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Every operator, even non-mathematical ones, have specific precedences and associativities.
    The `typeof` operator, for example, has a precedence of `16`. This can cause a
    headache if you use it in combination with a lower-precedence operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the `+` operator having a lower precedence than `typeof`, JavaScript
    would internally run this operation like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This, therefore, results in `typeof 1` (that is, `"number"`) being concatenated
    with `2` (producing `"number2"`). To avoid this, we must force the order using
    our own parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Incidentally, this is why you may often see `typeof` with parentheses (`typeof(...)`),
    which can make it look like a function being invoked. It is, however, an operator,
    and the parentheses are only there to force a specific order of operation.
  prefs: []
  type: TYPE_NORMAL
- en: You can discover the exact precedences of every operator by reading the ECMAScript
    specification or searching online for `JavaScript operator precedences`. Note
    that the numbers used to indicate precedence between `1` and `20` are not from
    the ECMAScript specification itself but are rather just a useful way of understanding
    precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the precedences and associativities of every operator is not something
    we should expect of our colleagues. It may be reasonable to assume that they know
    the precedences of some basic mathematical operators, but knowledge beyond that
    should not be considered guaranteed. Therefore, it is often necessary to provide
    clarity by employing parentheses even in situations where they may not be strictly
    necessary. This is especially crucial in complex operations where there are a
    large number of consecutive operators, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the parentheses wrapping `(2 * horizontalPadding)` is technically unnecessary
    as the multiplication operator naturally has a higher precedence than the addition
    operator. However, it is useful to provide extra clarity. Programmers reading
    this code will be grateful to spend less cognitive energy discerning the exact
    order of operations. As with many well-intended things, however, this can be taken
    too far. Parentheses that provide neither clarity nor a different forced order
    of operation should not be included. An example of such redundancy might be wrapping
    the entire `return` expression in additional parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This should ideally be avoided, as if it''s taken too far, it can introduce
    additional cognitive load for the reader of the code. A good guide for such situations
    is if you''re inclined to add additional parentheses for clarity, you should probably
    split the operation into multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These added lines provide not only clarity around the order of operations but
    also the purpose of each individual operation by usefully assigning each operation
    to a descriptive variable.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing every single operator's precedence and associativity is not necessarily
    vital, but knowing how these mechanisms underly every operation is very useful.
    Most of the time, as you've seen, it's preferable to split operations into self-contained
    lines or groups for clarity, even when the internal precedence or associativity
    of our operators does not demand it. Above all, we must always consider whether
    we are clearly communicating our intent to the readers of our code.
  prefs: []
  type: TYPE_NORMAL
- en: The average JavaScript programmer will not have an encyclopedic knowledge of
    the ECMAScript specification, and as such, we should not demand such knowledge
    to comprehend the code we have written.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of the mechanisms underlying operators paves the way for us to now
    explore individual operators within JavaScript. We'll begin by exploring arithmetic
    and numeric operators.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and numeric operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are eight arithmetic or numeric operators in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition**: `a + b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtraction**: `a - b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division**: `a / b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplication**: `a * b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remainder**: `a % b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exponentiation**: `a ** b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unary plus**: `+a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unary minus**: `-a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic and numeric operators will typically coerce their operands to numbers.
    The only exception is the `+` addition operator, which will, if passed a non-numerical
    operand, assume the function of string concatenation instead of addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one guaranteed outcome of all of these operations that is worth knowing
    about beforehand. An input of `NaN` guarantees an output of `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Beyond that basic assumption, each of these operators behaves in a slightly
    different way, so it's worth going over each of them individually.
  prefs: []
  type: TYPE_NORMAL
- en: The addition operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The addition operator is a dual-purpose operator:'
  prefs: []
  type: TYPE_NORMAL
- en: If either operand is `String`, then it'll concatenate both operands together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither operand is `String`, then it'll add both operands as numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To accomplish its dual purpose, the `+` operator first needs to discern whether
    the operands you've passed can be considered strings. Obviously, a primitive `String`
    value is clearly a string, but for non-primitives, the `+` operator will attempt
    to convert your operands into their primitive representations by relying on the
    internal `ToPrimitive` procedure that we detailed in the last chapter, in the *Conversion
    to a primitive* section. If the output of `ToPrimitive` for either of our `+` operands
    is a string, then it will concatenate both operands as strings. Otherwise, it'll
    add them as numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the `+` operator caters to both numeric addition and concatenation
    can make it quite complicated to understand, so it's helpful for us to walk through
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Both operands are numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Explanation**: When both operands are primitive numbers, the `+` operator
    very simply adds them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Both operands are strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Explanation**: When both operands are primitive strings, the `+` operator
    very simply concatenates them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One operand is a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Explanation**: When only one operand is a primitive string, the `+` operator
    will coerce the other into `String` and will then concatenate both resulting strings
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One operand is a non-primitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Explanation**: When either operand is a non-primitive, the `+` operator will
    convert it into a primitive, and then act as it usually would with that new primitive
    representation. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, JavaScript will convert `[123]` into its primitive value by using
    the return value of `[123].toString()` (that is, `"123"`). Since the primitive
    representation of an array is its `String` representation, the `+` operator will
    operate as if we were simply doing `"123" + 123`, which, as we know, evaluates
    to `"123123"`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion – know your operands!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `+` operator, it's especially vital to know what operands you're
    dealing with. If you don't, then the outcome of your operation may be unexpected.
    The `+` operator is probably one of the more complex operators since it has a
    dual purpose. Most operators aren't as complex. The subtraction operator, which
    we'll explore next, is thankfully far simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The subtraction operator (`-`) does what it says on the tin. It takes two operands,
    subtracting the right-side operand from the left-side operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If either operand is not a number, it will be coerced into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This includes non-primitive types too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re seeing two arrays, each with a single element, being subtracted
    from each other. This seemingly makes no sense until we recall that the primitive
    representation of an array is its joined elements as a string, that is, `"5"` and `"3"` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These will then be converted into their numerical representations, `5` and `3`,
    via an operation that is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we are left with the intuitive operation of `5` minus `3`, which
    we know is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: The division operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The division operator, much like the subtraction operator, accepts two operands
    that it will coerce to numbers. It will divide its left-side operand by its right-side
    operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The two operands are formally called the dividend and the divisor (`DIVIDEND
    / DIVISOR`) and will always evaluate according to floating-point math. Integer
    division does not exist in JavaScript, which means, effectively, that the results
    of your divisions may always include decimal points, and may hence be liable to
    the error margin of `Number.EPSILON`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Watch out when dividing by zero, as you may end up with either `NaN` (when
    dividing zero by zero) or `Infinity` (when dividing a non-zero number by zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If your divisor is `Infinity`, your division will always evaluate to zero (`0` or `-0`),
    unless your dividend is also `Infinity`, in which case, you''ll receive `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In circumstances where you expect a divisor or dividend of zero, `NaN` or `Infinity`,
    it is best to be defensive and either check for those values explicitly beforehand
    or following the operation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The edge cases of division may seem scary but they're not frequently encountered
    in everyday applications. If we were, however, authoring a medical or financial
    program, then it'd be absolutely vital to carefully consider our operations' potential
    error states.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplication operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The multiplication operator behaves similarly to the division operator, apart
    from the obvious fact that it performs multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It is necessary to watch out for effects of coercion and situations where either
    operand is `NaN` or `Infinity`. Rather intuitively, multiplying any non-zero finite
    value by `Infinity` will always result in `Infinity` (with the appropriate sign):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, multiplying zero by `Infinity` will always result in `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Outside of these cases, most usages of the multiplication operator are fairly
    intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The remainder operator (`%`), also known as the **modulo operator**, is similar
    to the division operator. It accepts two operands: a dividend, on the left side,
    and a divisor on the right side. It will return the remainder following an implied
    division operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the divisor is zero, the dividend is `Infinity`, or either operand is `NaN`,
    then the operation will evaluate to `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And if the divisor is `Infinity`, then the result will be equal to the dividend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The modulo operator is useful in situations where you wish to know whether
    a number *goes into* another number squarely, such as when wishing to establish
    the *evenness* or *oddness* of an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As with all other arithmetic operators, it's useful to be aware of how your
    operands will be coerced. Most usages of the remainder operator are straightforward,
    so outside of its coercive behaviors and its treatment of `NaN` and `Infinity`,
    you should find its behavior intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: The exponentiation operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exponentiation operator (`**`) takes two operands, a base on the left side
    and an exponent on the right side. It will evaluate to the base raised to the
    power of the exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is functionally identical to using the `Math.pow(a, b)` operation, although
    is more succinct. As with other arithmetic operations, it will internally coerce
    its operands to the `Number` type, and passing in any operands of `NaN`, `Infinity`, or
    zero will result in possibly unexpected outcomes, so you should try to avoid such
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'One curious case worth mentioning is that, if the exponent is zero, then the
    result will always be `1`, regardless of what the base is. So, the base could
    even be `Infinity`, `NaN`, or anything else, and the result would still be `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'All other arithmetic operators will evaluate to `NaN` if one of their operands
    is `NaN`, so the behavior of `**` here is quite unique. Another unique behavior
    is that it will throw `SyntaxError` if your first operand is itself a unary operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is to prevent ambiguity for the programmer. Depending on their previous
    exposure to other languages (or strict mathematical notation), they may expect
    cases such as `-2 ** 2` to be either `4` or `-4`. As such, JavaScript will throw
    in such cases, hence forcing you to be more explicit with either `(-2) ** 2` or `-(2
    ** 2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these unique characteristics, the exponentiation operator can be
    considered similar to other binary (two-operand) arithmetic operators. As always:
    be aware of your operands'' types and how they may be coerced!'
  prefs: []
  type: TYPE_NORMAL
- en: The unary plus operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The unary plus operator (`+...`) will convert its operand into `Number` as
    if it were passed to `Number(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, our cherished internal `ToPrimitive` procedure will be utilized,
    as discussed in the last chapter, in the *Conversion to a primitive* section.
    Its result will then be re-coerced into `Number` if it is not already `Number`.
    So, if `ToPrimitive` were to return `String`, that `String` would be converted
    into `Number`, meaning that non-numeric strings will result in `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And naturally, if `String` from `ToPrimitive` can be converted into `Number`, then
    that is what the unary `+` operator will evaluate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is more realistically observed when coercing an array via `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The unary `+` operator is usually used in places where a programmer wishes to
    cast a number-like object to `Number` so that they can then use it with other
    numeric operations. Usually, however, it is preferable to explicitly use `Number(...)` as
    it is much clearer what the intention is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unary `+` operator can sometimes be confused with other operations. Consider
    this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To someone unfamiliar with the unary plus or someone not attuned to seeing
    it regularly, this code may look like it contains a typo. We could potentially
    wrap the entire unary operation in its own parentheses to make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could instead use the much clearer `Number(...)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In summary, the unary `+` operator is a convenient shortcut to `Number(...)`.
    It's useful and quick, though in most cases, we should prefer to communicate our
    intent more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: The unary minus operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The unary minus operator (`-...`) will first convert its operand into `Number`
    in the same way as the unary `+` operator, detailed in the last section, and will
    then negate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Its usage is fairly straightforward and intuitive, although, as with unary `+`,
    it''s useful to disambiguate cases where you have a unary operator next to its
    binary operator counterpart. Cases like these can be confusing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It is best, in these situations, to lend clarity with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The unary minus operator is usually only used directly with a literal number
    operand to specify a negative value. As with all other arithmetic operators, we
    should ensure that our intent is clear and that we are not confusing people with
    long or confusing expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored arithmetic operators, we can begin to look into logical
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logical operators are typically used to build logical expressions where the
    result of the expression informs some action or inaction. There are three logical
    operators in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: The NOT operator (`!a`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AND operator (`a && b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OR operator (`a || b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with most other operators, they can accept a variety of types and will coerce
    as necessary. The AND and OR operators, unusually, do not always evaluate to a `Boolean` value,
    and both utilize a mechanism called **short-circuit evaluation** to only execute
    both operands if some condition is met. We'll learn more about this as we explore
    each individual logical operator.
  prefs: []
  type: TYPE_NORMAL
- en: The logical NOT operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NOT operator is a unary operator. It accepts only a single operand and
    converts that operand into its Boolean representation, then inverts it, so that
    truthy items become `false` and falsy items become `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the NOT operator will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cast the operand to a Boolean (`Boolean(operand)`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the resulting value is `true`, then return `false`; otherwise, return `true`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As discussed in the *Conversion to a Boolean* section in the last chapter, a
    typical idiom for converting a value to its Boolean representation is the double
    NOT (that is, `!!value`) as this effectively reverses the truthiness or falsiness
    of the value twice and evaluates to a Boolean. The more explicit and slightly
    more preferred idiom is to use `Boolean(value)`, as the intention is far clearer
    than with `!!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of there being only seven falsy values in JavaScript, the NOT operator
    can only evaluate to `true` in these seven scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript's rigid definition of falsiness and truthiness is reassuring. It
    means that even if someone constructs an object with all manner of primitive representations
    (imagine an object with `valueOf()` that returns a falsy value), all internal
    Boolean coercions will still only ever return `false` for the seven falsy values
    and nothing else. That means we only need to worry about those seven (*it could
    be much worse...*).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the whole, usage of the logical NOT operator is very straightforward. It''s
    a well-understood syntax across programming languages with clear semantics. As
    such, there is not a lot in the way of *best practices* concerning it. At the
    very least, it''s best to avoid too many double negatives in your code. A double
    negative is when an already negatively-named variable is applied to the NOT operator,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is cognitively expensive for those who read your code and is therefore
    liable to misunderstanding. It''s best to use positively-named Boolean variable
    names so that any logical operations using them are straightforward to comprehend.
    In this situation, we would simply rename our variable and reverse the operation,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The logical NOT operator, in summary, is most useful in Boolean contexts such
    as `if()` and `while()`, though is also idiomatically found in the double-NOT `!!`
    operation. And it is technically the only operator in JavaScript that is guaranteed
    to return a `Boolean` value regardless of its operand's type. Next, we'll explore
    the AND operator.
  prefs: []
  type: TYPE_NORMAL
- en: The logical AND operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logical AND operator (`&&`) in JavaScript accepts two operands. If its
    *left-side* operand is truthy, then it will evaluate and return the *right-side*
    operand; otherwise, it will return the *left-side* operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be a confusing operator for many people because they wrongfully assume
    that it is equivalent to the question *Are both A and B true?* when, in fact,
    it is more akin to *If A is truthy then give me B; otherwise, I''ll settle for
    A*. People may have an assumption that JavaScript will evaluate both operands,
    but it in fact will only evaluate the right-side operand if the left-side operand
    is truthy. This is known as **short-circuit evaluation**. And JavaScript will
    not cast the resulting value of the operation to `Boolean`: instead, it''ll just
    give us that value back, unchanged. If we were to implement the operation ourselves,
    it might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a simple operation, such as making an `if(...)` statement conditional
    upon two values being truthy, the `&&` operator will behave in an entirely unsurprising
    and expected way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `&&` operator can be used in more interesting ways too, such as
    when needing to return a value but only if some prior condition is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `&&` operator is being used in a non-Boolean context, where there
    is no coercion of its result occurring. In this case, if its left-side operand
    is falsy (that is, if `user` is falsy), then it will return that; otherwise, it
    will return the right-side operand (that is, `user.favoriteDrink`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getFavoriteDrink` function behaves in a way that fulfills a basic contract,
    returning `favoriteDrink` if the `user` object is available and if the `favoriteDrink` property
    appears on that object, although its actual functionality is a little more chaotic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Our `getFavoriteDrink` function is not making any deliberations about the specific
    nature of the user or `favoriteDrink` values; it is just blindly yielding to the `&&` operator,
    returning either its left-side or its right-side operand. If we are confident
    in the potential values of our operands, then this approach may be fine.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to take the time to consider the possible ways that `&&` will
    evaluate the operands you provide it with. Take into consideration the fact that
    it is not guaranteed to return `Boolean` and is not guaranteed to even evaluate
    the right-side operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `&&` operator, thanks to its short-circuiting nature, can also be used
    to express control flow. Let''s consider a scenario in which we wish to call `renderFeature()`
    if the `isFeatureEnabled` Boolean is truthy. Conventionally, we may employ an
    `if` statement to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'But we could also employ `&&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This and other unconventional usages of `&&` are typically frowned upon because
    they can obscure the intention of the programmer and create confusion for readers
    of your code who may not have such a thorough understanding of how `&&` operates
    in JavaScript. Nonetheless, the `&&` operator is truly powerful and should be
    used when well-suited to the task at hand. You should feel empowered to use it
    as you wish but always be aware of how the typical reader of your code may see
    the operation and always consider the prospective values that the operation may
    produce.
  prefs: []
  type: TYPE_NORMAL
- en: The logical OR operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logical OR operator (`||`) in JavaScript accepts two operands. If its left-side
    operand is truthy, then it will return that immediately; otherwise, it will evaluate
    and return the right-side operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like the `&&` operator, the `||` operator is flexible in that it does
    not cast what it returns to `Boolean`, and it evaluates in a short-circuited manner,
    meaning that it only evaluates the right-hand side operand if the left-side operand
    meets a condition—in this case, if the right-side operand is falsy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Conventionally, a programmer may assume that the logical OR operator is akin
    to the question *Are either A or B true?* but in JavaScript, it is more akin to: *If
    A is falsy, then give me B; otherwise, I''ll settle for A*. If we were to implement
    this operation ourselves, it might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with `&&`, this means that `||` can be used flexibly to provide control
    flow or to evaluate specific expressions conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As such, it should be used cautiously in a way that considers what readers of
    the code are familiar with, and in a way that considers all prospective operands
    and the resulting values from the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Comparative operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparative operators are a collection of binary operators that always return `Boolean` derived
    from a comparison between the two operands:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract equality (`a == b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract inequality (`a != b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict equality (`a === b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict inequality (`a !== b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than (`a > b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than or equal to (`a >= b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than (`a < b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than or equal to (`a <= b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance of (`a instanceof b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In (`a in b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these operators has slightly different functions and coercive behavior
    so it's useful to go through each of them individually.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract equality and inequality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract equality (`==`) and inequality (`!=`) operators rely on the same
    algorithm internally, which is responsible for determining whether two values
    can be considered equal. In this section, our examples will only explore `==`,
    but rest assured that `!=` will always simply be the opposite of whatever `==` is.
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, it is not advisable to rely on abstract equality
    because its mechanism can create unexpected results. Most of the time, you'll
    want to opt for strict equality (that is, `===` or `!==`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Where both operands, the left-side and the right-side, are of the same type,
    then the mechanism is quite simple—the operator will check whether the two operands
    are identical values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When both operands are of the same type, abstract equality (`==`) is exactly
    identical to strict equality (`===`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all non-primitives in JavaScript are of the same type (`Object`), abstract
    equality ( `==`) will always return `false` if you try to compare two non-primitives
    (two objects) that don''t refer to the exact same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: However, where both operands are of different types, for example, where you
    are comparing a `Number` type to a `String` type or an `Object` type to a `Boolean` type,
    the exact behavior of abstract equality will depend on the operands themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either operand is `Number`, and the other is `String`, then the `a == b` operation is
    equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note how, as discussed in the *Conversion to a number* section in the last chapter,
    the `"1e3"` string will be internally converted to the number `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing down the rabbit hole—if only one operand to the `==` operator is `Boolean`,
    then the operation is, once again, equivalent to `Number(a) === Number(b)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if previous conditions are not met, and if either operand is `Object` (not
    a primitive), then it will compare the primitive representation of that object
    to the other operand. As discussed in the last chapter, in the *Conversion to
    a primitive* section, this will attempt to call the `[Symbol.toPrimitive]()`, `valueOf()`, and
    then `toString()` methods to establish the primitive. We can see this in action
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Due to their complicated coercive behaviors, the *abstract equality* and *inequality*
    operators are best avoided. Anyone reading code littered with these operators
    won't be able to have a good level of confidence in the conditions and control
    flow of the program because there are simply too many odd edge cases where abstract
    equality can bite.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself wanting to use abstract equality, for example, when one
    operand is a number and another is a string, consider whether it might be clearer
    and less error-prone to use a combination of stricter checks or to explicitly
    cast your values for clarity; for example, instead of `aNumber == aNumericString`, you
    could do `aNumber === Number(aNumericString)`.
  prefs: []
  type: TYPE_NORMAL
- en: Strict equality and inequality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *strict equality* (`===`) and *strict inequality* (`!==`) operators in JavaScript
    are a staple of clean code. Unlike their abstract equality cousins, they provide
    certainty and simplicity in how they treat their operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `===` operator will only ever return `true` if both of its operands are
    identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The only exception to this rule is when either operand is `NaN`, in which case,
    it''ll return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'No internal coercion will ever occur with strict equality, so even if you have
    two primitives that could be coerced to the same number, for example, they will
    still be considered inequal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of non-primitives, both operands must refer to the exact same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if the object is of the equivalent structure or shares other characteristics,
    if it is not a reference to the same exact object, it''ll return `false`. We can
    illustrate this by attempting to compare a wrapped `Number` instance with a value
    of `3` to the numeric literal, `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract equality operator (`==`) would evaluate to true in such a case.
    You may consider the coercion of `new Number(3)` to `3` to be preferable, but
    it''s far better to explicitly set up your operands so that they are of the desired
    types before comparison. So, in the example of `String` that contains a numerical
    value that we wish to compare to `Number`, it would be best to first explicitly
    cast it via `Number()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: It is always advisable to use strict equality instead of abstract equality.
    It provides far more certainty and reliability in the outcome of every operation
    and allows you to free your mind from the myriad coercive behaviors that abstract
    equality entails.
  prefs: []
  type: TYPE_NORMAL
- en: Greater than and less than
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *greater-than* (`>`), *less-than* (`<`), *greater-than-or-equal-to* (`>=`),
    and *less-than-or-equal-to* (`<=`) operators all operate in a similar manner.
    They follow an algorithm similar to abstract equality, although how values are
    coerced is slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that all operands to these operators will first be
    coerced to their primitive representation. Following that, if their primitive
    representations are both strings, then they'll be compared lexicographically.
    If their primitive representations are not both strings, then they'll be coerced
    from whatever they are to numbers and then compared. This means that even if only
    one of your operands is a string, they'll both be compared numerically.
  prefs: []
  type: TYPE_NORMAL
- en: Lexicographic comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lexicographic comparison occurs when both operands are strings, and involves
    the character-by-character comparison of each string. Broadly, strings that are
    *greater* are those that would appear later in a dictionary. Therefore, *banana*
    would be lexicographically greater than *apple*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discovered in [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml),
    *Primitive and Built-In Types*, JavaScript uses UTF-16 to encode strings and therefore
    each codeunit is a 16-bit integer. The UTF-16 codeunits from `65` (`U+0041`) to `122` (`U+007A`) are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Those characters appearing later are represented by larger UTF-16 integers.
    To compare any two given codeunits, JavaScript will simply compare their integer
    values. For the case of comparing `B` to `A`, this might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Every character in each operand string must be compared. To do this, JavaScript
    will go codeunit-by-codeunit. At each index of each string, if codeunits differ,
    the larger codeunit will be considered greater, and that string will, therefore,
    be considered greater than the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And if one operand is equal to the prefix of the other, then it will always
    be considered *less than*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have spotted, the lowercase English letters occupy higher UTF-16
    integers than uppercase letters. This has the effect of meaning that uppercase
    is considered less than lowercase and would, therefore, appear before it in a
    lexicographic ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also notice that the codeunits from `91` to `96` include the punctuation
    characters, `[\]^_``. This will also affect our lexicographic comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Unicode tends to be arranged in a way that any given language''s characters
    will be naturally sorted lexicographically so that the first symbols in a language''s
    alphabet are expressed by lower 16-bit integers than the later symbols. Here,
    we see, for example, the word for chicken (`"ไก่"`) in Thai is lexicographically
    less than the word for egg (`"ไข่"`) since the `ก` character appears before `ข` in
    the Thai alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The natural order of Unicode may not always yield a sensible lexicographic
    order. As we learned in the previous chapter, complex symbols can be expressed
    by combining together multiple codeunits into combining character pairs, surrogate
    pairs (creating *code points*), or even grapheme clusters. This can create various
    difficulties. One example would be the following case where a given symbol, in
    this case, *LATIN CAPITAL LETTER A WITH CIRCUMFLEX*, can be expressed either via
    the lone Unicode code-point `U+00C2` or via combining the capital letter `"A"` (`U+0041`)
    with the *COMBINING CHARACTER ACCEN**T* (`U+0302`). Symbolically and semantically,
    these are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since `U+00C2` (decimal: `194`) is technically larger than `U+0041` (decimal: `65`),
    it will be considered *greater than* in a lexicographic comparison, even though
    they are symbolically and semantically identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: There are thousands of these potential discrepancies to watch out for, so if
    you ever find yourself needing to compare lexicographically, be mindful that JavaScript's *greater-than* and *less-than* operators
    will be limited by Unicode's inherent ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numeric comparison using JavaScript''s greater-than and less-than operators
    is fairly intuitive. As mentioned, your operands will be coerced first to their
    primitive representations, and then coerced a second time, explicitly, to a number.
    For cases where both operands are numbers, the result is entirely intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'And for `NaN` and `Infinity`, the following assertions can be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If one operand has a primitive representation that is not `Number`, then it
    will be coerced to `Number` before comparison. If you were to accidentally pass `Array` as
    an operand to `>`, then it would first coerce it to its primitive representation,
    which for arrays, is `String` with all individual coerced elements joined with
    a comma, and then attempt to coerce that to `Number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Due to the potentially complicated coercions that may occur, it is always best
    to pass operands of the same type to `>`, `<`, `>=`, and `<=`.
  prefs: []
  type: TYPE_NORMAL
- en: The instanceof operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `instanceof` operator in JavaScript allows you to detect whether an object
    is an instance of a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This operation will climb the `[[Prototype]]` chain of its left-side operand
    looking for a specific `constructor` function. It will then check whether this
    constructor is equal to the right-side operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it climbs the `[[Prototype]]` chain, it can work safely with multiple
    inheritances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *right-side* operand is not a function (that is, is not callable as
    a constructor), then `TypeError` will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instanceof` operator is sometimes useful in discerning native types such
    as whether an object is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This usage, however, has been largely replaced by `Array.isArray()`, which is
    generally more trustworthy as it will work correctly in rare cases where `Array` has
    been passed to you from another native context such as a frame (within the browser).
  prefs: []
  type: TYPE_NORMAL
- en: The in operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `in` operator will return `true` if a property can be found in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The *left-side* operand will be coerced to its primitive representation, which,
    if not `Symbol`, will be coerced to `String`. Here, we can see how a left-side
    operand that is `Array` will be coerced into a comma-separated serialization of
    its contents (the native and default way that arrays are coerced to primitives,
    thanks to `Array.prototype.toString`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'All seemingly numeric property names in JavaScript are stored as strings, so
    accessing `someArray[0]` is equal to `someArray["0"]`, and therefore enquiring
    as to whether an object has a numeric property with `in` will also consider both `0` and `"0"` equally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'When establishing whether a property is in a given object, the `in` operator
    will traverse the entire `[[Prototype]]` chain, hence returning `true` for all
    accessible methods and properties at all levels of the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that if you''re looking to distinguish between the concepts of *having
    a property* and *having a property on itself*, you should instead use `hasOwnProperty`,
    a method inherited from `Object.prototype` that will only check the object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: On the whole, it is best to only use `in` if you're confident that there are no
    collisions with the property names you expect to use and properties provided by
    the object's `[[Prototype]]` chain. Even if you're just using plain objects, you
    still need to worry about the native prototype. If it's been modified in any way
    (by a utility library, for example), then you can no longer have a high level
    of trust in the results of your `in` operations and should hence use `hasOwnProperty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In older library code, you may even find code that chooses not to rely on `hasOwnProperty` on
    the object of inquiry, fearing that it may have been overridden. Instead, it''ll
    opt for using the `Object.prototype.hasOwnProperty` method directly and calls
    it with that object as its execution context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This is likely overly-cautious though. It's safe enough in most code bases and
    environments to trust and use the inherited `hasOwnProperty`. The `in` operator
    as well, if you've considered the risks, is usually safe enough to use.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An assignment operator will assign the value of its right-side operand to its
    left-side operand and will return the newly assigned value. The left-side operand
    of an assignment operation must always be an assignable and valid identifier or
    property. Examples of this would include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You can additionally use *destructuring assignment,* which enables you to declare
    your *left-side* operand as either an object-literal-like or array-like structure
    that designates the identifiers you wish to assign and the values you wish to
    be assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: We will explore *destructuring assignment* further in a little bit. For now,
    it's only important to know that it, along with regular identifiers (`foo=...`)
    and property accessors (`foo.baz = ...`, `foo[baz] = ...`), can be used as the
    left-side operand to an assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are technically a large number of assignment operators because JavaScript
    combines regular operators with the basic assignment operator to create more succinct
    assignment operations in the common case of needing to mutate the value referred
    to by an existing variable or property. The assignment operators in JavaScript
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct assignment**: `=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additive assignment**: ``+=``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtractive assignment**: `-=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplicative assignment**: `*=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divisive assignment**: `/=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remainder assignment**: `%=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise left-shift assignment**: `<<=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise right-shift assignment**: `>>=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise unsigned right-shift assignment**: `>>>=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise AND assignment**: `&=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise XOR assignment**: `^=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise OR assignment**: `|=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All assignment operators, apart from the direct assignment `=` operator, will
    conduct the operation that is indicated by the operator preceding `=`. So, in
    the case of `+=`, the `+` operator will be applied to the left-and right-side operands,
    the result of which will then be assigned to the left-side operand. So, consider
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The same follows for all other assignment operators that are of the combined
    type. The addition operator, as we know, will concatenate its operands if either
    is a string. And the exponentiation operator (`**`) will always evaluate to `1` if
    the exponent operand is zero (`2 ** 0 === 1`). We can rely on this and other existing
    knowledge to know how such operators will work when combined with assignment.
    We, therefore, don't need to individually explore all of these assignment operator
    variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment conventionally occurs in the context of a singular line. It''s typical
    to see an assignment statement on its own terminated by a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'But there''s nothing implicit in the assignment operator that requires this.
    In fact, you can embed an assignment anywhere where you would be able to embed
    any expression within the language. The following syntax would be entirely legal,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This is carrying out an addition combined with an assignment, and then passing
    the resulting value to the `processStep` function. It is exactly equivalent to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Note here how it is `nextValue` that is passed to `processStep`. The result
    of an assignment operation expression is always the value being assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'It is common to see assignment in contexts of `for` and `while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This and other patterns of assignment are totally fine as they are so widely
    used they have become idiomatic of JavaScript. But in most other situations, it
    is preferable not to embed assignment within other language constructs. Code such
    as `fn(a += b)` is potentially unintuitive to some, as it may not be clear what
    value is actually passed to `fn()`.
  prefs: []
  type: TYPE_NORMAL
- en: In regard to clean code, the only question we need to ask ourselves when assigning
    values is whether the reader of our code (*including us!*) will find it obvious
    that assignment is occurring and whether they'll understand *what* is being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Increment and decrement (prefix and postfix) operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These four operators technically fall under the umbrella of assignment but
    they are unique enough to warrant their own section:'
  prefs: []
  type: TYPE_NORMAL
- en: The postfix increment operator (`value++`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The postfix decrement operator (`value--`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix increment operator (`++value`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix decrement operator (`--value`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These will simply increment or decrement the value by `1`. They're usually found
    in iteration contexts such as `for` or `while` loops. They are best thought of
    as succinct alternatives to additive and subtractive assignment (that is, `value
    += 1` or `value -= 1`). However, they have a couple of unique characteristics
    that are worth covering.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix increment/decrement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The prefix increment and decrement operators allow you to increment or decrement
    any given value and will evaluate to the newly incremented value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`++n` would technically be equivalent to the following additive assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the current value of `n` is first converted into `Number`. This is
    the nature of both the increment and decrement operators: they operate strictly
    on numbers. So, if `n` were `String`, that could not be coerced successfully,
    then the new incremented or decremented value of `n` would be `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can observe how, since the coercion of `foo` to a `Number` fails, the
    attempted incrementation of it also fails, returning `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: Postfix increment/decrement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The postfix variants of the increment and decrement operators are identical
    to the prefix variants, except for one fact: the postfix variants will evaluate
    to the old value, not the newly incremented/decremented value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This is crucial and can, if not used intentionally, lead to undesirable bugs.
    Increment and decrement operators are usually used in contexts where this difference
    is irrelevant. For example, when used in the last expression of a `for (_;_;_)` statement,
    the return value is not used anywhere, so we''d see no difference between the
    two following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in other circumstances, the evaluated value is absolutely key. In
    the following `while` loop, for example, the `++i < array.length` expression is
    evaluated on every iteration, meaning that the newly incremented value is compared
    to `array.length`. If we swapped this for `i++ < array.length`, then you''d be
    comparing the value before incrementing, meaning that it''d be one less and hence
    we''d get an additional (unwanted!) iteration. You can observe the difference
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a rare occurrence, especially with more modern iteration techniques
    available in the language. But the increment and decrement operators are still
    very popular in other contexts, so it's useful to appreciate the difference between
    their prefix and postfix variants.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As briefly mentioned, the left-side operand of an assignment operator (`...
    =`) can be specified as a destructuring object or array pattern, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: These patterns typically look like `Object` or `Array` literals as they start
    and end with `{}` and `[]` respectively. They are, however, slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the destructuring object pattern, where you want to declare the identifier
    or property you wish to assign to, you must place it as if it were a value in
    an object literal. That is, where `{ foo: bar }` usually means assign `bar` *to*
    `foo`, in a *destructuring pattern*, it means *assign the value of* `foo` *to
    the identifier, *`bar`. It is reversed. Where the name of the property of the
    value you wish to access matches the name that you wish to be assigned in the
    local scope, you can use a shorter syntax of simply `{ foo }`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'For arrays, the slots of syntax where you would usually designate the values
    (that is, `[here, here, and here]`) are used to designate the identifiers to which
    you wish to assign your values, so each identifier in a sequence relates to the
    same index elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the rest operator (`...foo`) to instruct JavaScript to assign
    the *rest* of the properties to a given identifier. Here''s an example of using
    it within the *destructuring array pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s an example of using it within the* destructuring object pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Only destructure your assignments when it provides *genuine* increased readability
    and simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring can also occur for object structures that involve multiple levels
    of hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to extract the `inhabitants` array and assign it to a variable of
    the same name, then we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'And a *destructuring array pattern* can be embedded in a *destructuring object
    pattern* and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '*Destructuring assignment* is very useful in avoiding otherwise length, assignments
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it should be used with reservation as it can sometimes overcomplicate
    things for those who have to read your code. While it may appear intuitive when
    writing it for the first time, *destructuring assignments* are notoriously difficult
    to untangle. Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This is cognitively expensive to untangle. It would, perhaps, be more intuitive
    to express this logic traditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: On the whole, *destructuring assignment* is an exciting and useful feature of
    the JavaScript language, but it should be used in a guarded way with consideration
    of the possibility of the confusion it can cause.
  prefs: []
  type: TYPE_NORMAL
- en: Property access operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accessing properties in JavaScript is achieved by using one of two operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct property access**: `obj.property`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computed property access**: `obj[property]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct  property access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for directly accessing a property is a single period character,
    with a *left-side* operand that is the object you wish to access, and with a *right-side*
    operand that is the property name you wish to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The *right-side* operand must be a valid JavaScript identifier, and as such,
    cannot start with a number, cannot contain whitespace, and in general, cannot
    contain any punctuation characters that exist elsewhere within the JavaScript
    specification. You can, however, have properties that are named with so-termed
    exotic Unicode characters such as π (`PI`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This is an unconventional practice and is usually only used in novelty settings.
    It may, however, be genuinely useful in code that is embedded in problem domains
    where there are legitimate exotic symbols with existing meanings (*mathematics*,
    *physics*, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Computed property access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In cases where you cannot directly access a property via *direct property access*,
    it is possible to compute the property name you wish to access, delimiting it
    with square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a *right-si**de* operand of any expression, meaning that you can freely
    compute some value that''ll then be coerced to a string (if it is not already
    a string) and used as the property name to access the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically this is used to access property names that contain characters that
    make them invalid identifiers, and hence illegal to use with the *direct property
    access* operator. This would include numeric property names (such as those found
    in an array), names with whitespace, or names with punctuation or keywords that
    exist elsewhere in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: It is best to only rely on computed property access in scenarios when you have
    no other choice. If there is the possibility of just accessing the property directly
    (that is, `object.property`), then you should prefer that. Likewise, if you're
    deciding what properties an object might contain, it's best to use names that
    are valid identifiers within the language so they can be directly accessed with
    ease.
  prefs: []
  type: TYPE_NORMAL
- en: Other operators and syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few remaining operators and pieces of syntax that we have yet to
    explore and that don''t fall into any other operator category:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The delete operator**: `delete VALUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The void operator**: `void VALUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The new operator**: `new VALUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spread syntax**: `... VALUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping**: `(VALUE)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The comma operator**: `VALUE, VALUE, ...`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delete operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` operator can be used to remove properties from objects, as such
    its only operand usually takes the form of a property accessor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Only properties that are deemed configurable can be deleted in this manner.
    All properties added conventionally are, by default, configurable and can, therefore,
    be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the property has been added via `defineProperty` with `configurable` set
    to `false`, then it''ll not be deletable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `delete` operator evaluates to `true` or `false` depending
    on whether the property has been successfully deleted. Following successful deletion,
    the property is not merely set to `undefined` or `null` but is entirely removed
    from the object so that checking its existence via `in` will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` operator can technically be used to delete any variable (or so-termed
    *environment record binding* internally), but attempting to do so is considered
    a deprecated behavior and will produce `SyntaxError` in strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The `delete` operator has historically been the subject of many inconsistencies
    between JavaScript implementations, most especially between different browsers.
    Because of this, only its conventional usage of deleting properties on objects
    is advisable.
  prefs: []
  type: TYPE_NORMAL
- en: The void operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `void` operator will evaluate to `undefined` regardless of its operand.
    Its operand can be any valid reference or expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't have many uses nowadays, although `void 0` is sometimes used as an
    idiom for `undefined` either for succinctness or to avoid issues in legacy environments
    where `undefined` was an untrusted mutable value.
  prefs: []
  type: TYPE_NORMAL
- en: The new operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new` operator is used to form an instance from a constructor. Its *right-side*
    operand must be a valid constructor, either provided by the language (for example, `new
    String()`) or by ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'By *instance,* what we truly mean is an object that has a `[[Prototype]]` equal
    to the constructor''s `prototype` property, and that has been passed to the constructor
    as its `this` binding so that the constructor can fully prepare it for its purpose.
    Observe here how, whether we define our constructor via a class definition or
    conventional syntax, we can make the same assertions about the produced instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new` operator only cares that its *right-side* operand is constructible.
    This means it cannot be a function formed by an arrow function, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as you''ve defined your constructor using a function expression or
    declaration, it''ll work fine. You can even instantiate an anonymous inline constructor
    if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new` operator does not formally require the calling parentheses. They
    only need to be included if you are passing arguments to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'When you wish to instantiate something and then immediately access a property
    or method, however, you''d need to disambiguate by providing the calling parentheses
    and *then* accessing the property following that; otherwise, you''d receive `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the `new` operator is usually very straightforward. Semantically,
    it is understood to relate to the construction of an instance and should therefore
    ideally only be used to do that. It''s also, therefore, assumed that anything
    being referenced by the *right-side* operand of `new` is identified with a name
    beginning with a capital letter and is a noun. These naming conventions indicate
    that it is a constructor, providing a useful hint to any programmers who may wish
    to use it. Here are some examples of both good and bad constructor names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The correct naming of a constructor is crucial. It makes our fellow programmers
    immediately aware of what *contract* a specific abstraction fulfills. If we name
    a constructor so that it appears like a regular function, then our colleagues
    may try to invoke it incorrectly and suffer possible errors as a result. It, therefore,
    makes perfect sense to take advantage of a name's ability to communicate *contract*,
    as discussed in the earlier chapter on naming ([Chapter 5](cf2c2cfc-6b5e-48a3-a7ef-99169bd9067d.xhtml), *Naming
    Things is Hard*).
  prefs: []
  type: TYPE_NORMAL
- en: The spread syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *spread syntax* (also known as *rest syntax*) is composed of three dots
    followed by an operand expression (`...expression`). It allows the expression
    to be expanded in places where either multiple arguments or multiple array elements
    are expected. It technically exists in five distinct areas of the language:'
  prefs: []
  type: TYPE_NORMAL
- en: In *array literals*, of the form `array = [a, b, c, ...otherArray]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *object literals*, of the form `object = {a, b, c, ...otherObject}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *function parameter lists*, in the form `function(a, b,  c, ...otherArguments)
    {}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *destructuring array patterns*, in the form `[a,  b, c, ...others] = array`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *destructuring object patterns*, in the form `{a, b, c, ,,,otherProps} =
    object`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of a *function parameter list*, the *spread syntax* must be
    the very last parameter and would indicate that you wish for all arguments passed
    to the function from that point onward to be collected into a singular array by
    the name indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to use it amid other parameters, then you will receive `SyntaxError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of an *array literal* or a *destructuring array pattern*, the
    *spread syntax* is similarly used to indicate that the values referred to should
    be spread out. It''s best to see these as two opposites, *deconstruction* and *reconstruction*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in the context of an *array literal* or a *destructuring array pattern*, the
    *spread syntax* must refer to an iterable value. This doesn''t necessarily have
    to be an array. Strings, as an example, are iterable, so the following also works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of an *object literal* or a *d**estructuring object pattern*,
    the *spread syntax* is similarly used to spread out all properties of any given
    object into the receiving object. Once again, we can see this as processes of *deconstruction* and *reconstruction*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in this context, the value of the right side of the *spread syntax*
    must be either an object or a primitive that can be wrapped as an object (for
    example, `Number` or `String`). This means that all values in JavaScript are permissible
    except `null` and `undefined`, both of which, as we know, cannot be wrapped as
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: It's, therefore, best to only use the *spread syntax* in an object context when
    you're confident that the value is an object.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the *spread syntax*, as we've seen, is remarkably useful in a
    variety of different situations. Its main advantage is that it reduces the amount
    of syntax required to extract and designate values.
  prefs: []
  type: TYPE_NORMAL
- en: The comma operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The comma operator (`a, b`) accepts a left-side and right-side operand and will
    always evaluate to its right-side operand. It is sometimes not considered an operator
    since it does not technically operate on its operands. It's also quite rare.
  prefs: []
  type: TYPE_NORMAL
- en: The comma operator should not be confused with the comma we use to separate
    arguments when declaring or invoking a function (for example `fn(a,b,c)`), the
    comma used when creating array literals and object literals (for example `[a,
    b, c]`), or the comma used when declaring variables (for example `let a, b, c;`).
    The comma operator is distinct from all of these.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s most commonly seen in the iteration statement portion of a `for(;;)` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how three increment operations are occurring in the third statement (which
    occurs at the end of each iteration in a conventional `for(;;)` statement), and
    that they are each separated by a comma. In this context, the comma is used merely
    to ensure that all of these individual operations will occur, regardless of each
    other, within the context of a singular statement. In regular code outside a `for(;;)` statement,
    you would likely just have these each dedicated to their own line and statement,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: However, due to the constraints of the `for(;;)` syntax, they must all exist
    within a singular statement and so the comma operator becomes necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the comma operator evaluates to its *right-side* operand is not
    important in this context, but in other contexts, it may be important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `processThings`, when invoked, will first call `firstThing` and then `secondThing` and
    will return whatever `secondThing` returns. It is therefore equivalent to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: It is rare to see the comma operator used, even in scenarios like this, as it
    tends to unnecessarily obscure code that could be more clearly expressed. It's
    useful to know that it exists and how it behaves, but we shouldn't expect it to
    be an everyday operator.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Grouping*, or parenthesizing, is achieved by using regular brackets ( `(...)` ).
    This should not be mistaken for other pieces of syntax that use parentheses, such
    as function invocation (`fn(...)`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The grouping parentheses can be considered an operator just like all of the
    others we''ve learned about. They accept one operand—an expression of any form—and
    will evaluate to whatever resides within them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'As it simply evaluates its contents, you may wonder what the purpose of a group
    is. Earlier, we covered the concepts of operator precedence and associativity.
    Sometimes, if you''re using a series of operators and wish to force a specific
    order of operations, then the only way to do that is by wrapping them in a group,
    which, when used in combination with other operators, has the highest precedence
    of all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s wise to use a group when the order of operations is either not what you
    desire or has the potential to be unclear to readers of the code. For example,
    it is sometimes common to wrap items being returned from a function in a group
    to provide aesthetic containment and clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Another obvious solution to this may be to merely indent the items you wish
    to contain, but the issue with this is that the JavaScript `return` statement
    will not know to look beyond its own line for the start of the expression or value
    it must return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The `return` statement in the preceding code effectively terminates itself
    with a semicolon when the parser observes that there is no value or expression
    on the same line. This is known as **Automatic Semicolon Insertion** (**ASI**)
    and its existence means we often have to use groups to make it obvious to the
    parser what our intentions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: In summary, *grouping* is a useful tool for containment and re-ordering operations,
    and it is a cheap and easy way to increase the clarity and readability of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript has seven bitwise operators. The term *bitwise* here means *to operate
    on binary numbers*. These operators are rarely utilized but are useful to know
    about nonetheless:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitwise unsigned right-shift operator**: `>>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise left-shift operator**: `<<`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise right-shift operator**: `>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise OR**: `|`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise AND**: `&`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise XOR**: `^`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise NOT**: `~` (a unary operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operations are incredibly rare in JavaScript since you're usually dealing
    with higher-level sequences of bits like strings or numbers. However, it's worth
    having at least a cursory understanding of bitwise operations so that if you encounter
    the need, you can cope.
  prefs: []
  type: TYPE_NORMAL
- en: 'All bitwise operators in JavaScript will first coerce their operands (or a
    singular operand, in the case of bitwise NOT `~`) to a 32-bit integer representation.
    This means that, internally, a number such as `250` would be manifested as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The last eight bits, in this case of `250`, contain all of the information
    regarding the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Adding together all of the bits will get us a decimal integer value of `250`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every bitwise operator available will operate on these bits and derive a new
    value. A bitwise AND operation, for example, will yield a bit value of `1` for
    every pair of bits that are both *on*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: We can see that only the fifth bit from the right (that is, `16`) is *on* in
    both `250` and `20`, therefore the AND operation will result in only that bit
    being left on.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators should only be utilized when you are carrying out binary mathematics.
    Outside of that, any usage of bitwise operators (for example, for side-effects)
    should be avoided because it drastically limits the clarity and comprehensibility
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: It was not uncommon, for a time, to see bitwise operators such as `~` and `|` being
    used in JavaScript because they were popular for succinctly deriving the integer
    floor of a number (for example, `~34.6789 === 34`). It goes without saying that
    this approach, while clever and ego-boosting, created unreadable and unfamiliar
    code. It remains preferable to use more explicit techniques. In the case of flooring,
    using `Math.floor()` is ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have exhaustively covered the operators available in JavaScript.
    Collectively, the last past three chapters have given us an incredibly strong
    foundational understanding of JavaScript syntax, enabling us to feel utterly comfortable
    when constructing expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to explore the language by applying our
    existing knowledge of types and operators to the landscapes of declaration and
    control flow. We'll be exploring how to use larger language constructs to craft
    clean code and will be discussing many of the traps and idiosyncrasies present
    in those constructs.
  prefs: []
  type: TYPE_NORMAL
