- en: Building a Flask Application with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned about automating the deployment process using
    Zappa, since Zappa helps us to deploy a Python application on the AWS Serverless
    infrastructure. We used this to develop a Python application using some of the
    Python web frameworks. In this chapter, we going to develop a Flask-based application
    as a serverless application on AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Zappa is useful for performing serverless
    deployments and how it makes it easy to deploy with a single command. Now, it's
    time to see the larger application deployed by Zappa, since it's really important
    to see how an application is configured and moved to AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Flask?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal Flask application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring with Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and deploying on AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete Flask Todo application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before making headway, let''s understand the technical requirements and configure
    the development environment. This chapter does have a conceptual demonstration
    of an application development. Hence, there are some prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04/macOS/Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have configured Python 3.6 and installed the Pipenv tool, you can create
    a virtual environment and install these packages. We are going to explore the
    installation and configuration of this in a later section. Let's move on and understand
    some basic concepts of Python-based frameworks and their related implementation.
  prefs: []
  type: TYPE_NORMAL
- en: What is Flask?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a well-known Python micro web framework in the Python community. It's
    adopted and preferable because of its extensible nature. Flask aims to keep the
    code simple but extensible.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Flask does not include any database abstraction layer, form validation,
    or any other specific functionality. Instead, Flask supports extensions to add
    any well-defined functionality to your application. Numerous extensions are available
    to provide database integration, form validation, file upload handling, authentication,
    and more. The Flask core team reviews extensions and ensures that they won't break
    the future release.
  prefs: []
  type: TYPE_NORMAL
- en: Flask allows you to define the design as per your application needs. You are
    not bound to follow some strict rule by Flask. You can write your application
    code in a single file or in a modular manner. Flask supports built-in development
    servers and fast debuggers, unit testing, RESTful request dispatching, Jinja2
    templating, and secure cookies (for client-side sessions), all of which are WSGI
    1.0-compliant and Unicode-based.
  prefs: []
  type: TYPE_NORMAL
- en: That's why many in the Python community prefer to use the Flask framework as
    their first choice. Let's make headway and explore the Flask-based application
    development process with actual implemention along with a serverless approach.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask mainly depends on two external libraries such as Werkzeug and Jinja2\.
    Werkzeug provides a Python standard **WSGI** (**Web Server Gateway Interface**)
    that enables a Python application to interact with HTTP. Jinja2 is a templating
    engine that enables you to render an HTML template with your own customized context.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and install Flask. All its dependencies will be automatically
    installed; you don't need to install dependencies manually.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended that you use `virtualenv` to install Flask, since `virtualenv`
    enables you to install Python packages in parallel for different Python projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have `virtualenv`, then you can simply install it by using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have installed `virtualenv`, you need to create a new environment
    for your Flask project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will be using `virtualenv` in the upcoming sections. Now, let''s install
    Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to have fun with Flask. We will be creating a minimal Flask application
    to demonstrate the Flask application workflow.
  prefs: []
  type: TYPE_NORMAL
- en: A minimal Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see what a minimal Flask application looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's it, we are done with the minimal Flask application. It's very simple
    to configure and create a microservice with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss what exactly the preceding code is doing and how we would run
    the program:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we imported a Flask class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we created an instance of the Flask class. This instance will be our WSGI
    application. This first argument will be the name of the module or package. Here,
    we created a single module, hence we used `__name__`. This is needed so that Flask
    knows where to look for templates, static, and other directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we used `app.route` as a decorator with a URL name as a parameter. This
    will define and map the route with the specified function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function will be invoked to the HTTP request with the URL specified in the
    route decorator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run this program, you can either use the `flask` command or `python -m flask`,
    but before that, you need to set an environment variable as `FLASK_APP` with a
    module file name of where the Flask instance was defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This launches a built-in server that is good enough for testing and debugging
    locally. The following is a screenshot of the localhost running in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, it wouldn't work with production, but Flask provides numerous options
    for deployment. You can have a look at [http://flask.pocoo.org/docs/0.12/deploying/#deployment](http://flask.pocoo.org/docs/0.12/deploying/#deployment)
    for more information, but in our case, we are going to deploy to a serverless
    environment on AWS Lambda and API Gateway using Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to configure Zappa, it's required that you have Zappa installed, as
    mentioned in the previous chapter. Zappa provides the `zappa init` command, which
    enables a user interactive mode initialization so that we can configure the Python
    application.
  prefs: []
  type: TYPE_NORMAL
- en: I followed the default configuration settings that were suggested by the `zappa
    init` command. This generates the `zappa_settings.json` file, which is the backbone
    for configuring any Python application with Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of the `zappa_settings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, during initialization, Zappa has the ability to identify the type of your
    Python application and generate the set attributes accordingly. In our case, Zappa
    detected the Python program as a Flask application. Hence, it asked for the Flask
    instance path, which we initialized as `app = Flask(__name__)` in the `hello_world.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Zappa configuration has been completed as per our basic needs,
    it's time to deploy it on AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and deploying on AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We described the basic uses of Zappa with some basic commands in the previous
    chapter. Using these commands, we can build the deployment package, deploy the
    application, and perform other basic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the `zappa_settings.json` file in place with all of the valid
    attributes, you can start the deployment process by using the `zappa deploy <stage_name>`
    command. As per our `zappa_settings.json` file, we have one stage defined as `dev`,
    so, to start the deployment, we can run the `deploy` command, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot describes the deployment flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the Zappa deployment is complete, it generates a random API gateway endpoint.
    Zappa configures AWS Lambda with API Gateway based on the `zappa_settings.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the Flask application is available through the previously generated API.
    Let''s test it to see the Hello World! response from the Flask application. You
    can hit the URL in the browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move on to the next section to see an application development using
    the Flask framework.
  prefs: []
  type: TYPE_NORMAL
- en: A complete Flask Todo application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen how Zappa makes it super easy to deploy the Flask application,
    it's time to see the complete workflow that we may need while developing a Flask-based
    application. We are going to develop a Flask-based modularized application, where
    each functionality will be an independent module, such as authentication, Todo
    application, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication module will be responsible for maintaining the authentication
    and authorization mechanism. It will also include the implementation of the login
    and sign up process.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas the `todo` module will have a basic implementation of todo operations,
    this operation flow will be authorized by the authentication module. With the
    help of Flask extensions, we are going to manage and configure these modules.
    Apart from these core modules, we are also going to see the implementation related
    to the user interface, database configuration, and static file integration.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to set up the development environment, we need to perform some configurations
    related to `virtualenv` and the required packages.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start working on the project, let''s create a virtual environment
    and enable it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Flask extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a microframework, but it has an extensible nature wherein you can add
    more features as per your needs. To develop a Todo application, we may need some
    basic features such as data persistence and a user authentication mechanism. So,
    while working on a Flask application, we are going to use some Flask extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flask registry provides numerous extensions, which are standalone packages,
    and you can easily configure them with your Flask application instance. You can
    see the complete list of Flask extensions at: [http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the following Flask and Flask extensions packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flask==0.12.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flask-Login==0.4.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flask-SQLAlchemy==2.3.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flask-WTF==0.14.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flask-Migrate==2.1.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I would recommend listing these packages in a separate file named `requirements.txt` and
    then installing them in one go, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will install all of the listed packages with their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While implementing any project from scratch, you are free to design the scaffolding
    of your project. We are going to follow the scaffolding shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at each directory and its uses in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.env`: This is our `virtualenv` directory, which has been created by the `virtualenv`
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth`: We are going to create a standalone generic authentication module using
    the `Flask-Login` and `Flask-SqlAlchemy` extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: Here, we are going to create some configuration and generic database
    models, which may be needed by other modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static`: It''s Flask standard practice to put the static content under the
    `static` directory. Hence, we will be using this directory for all required static
    content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: Flask has built-in support for the Jinja2 template engine and
    follows the standard layout for the template files based on the modules'' names.
    We will see a detailed description of this later, when we actually utilize the
    templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo`: This is a standalone Flask module or package which has the basic to-do
    functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__.py`: This is Python''s standard file that is required under a directory
    to build a Python package. We are going to write code here to configure our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`migrations`: This directory is autogenerated by `Flask-Migrate`. In a future
    section, we will see how `Flask-Migrate` works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gitignore`: This contains a list of files and directories that should be
    ignored by Git versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`: I have created a Git repository using GitHub and included an MIT
    license for our `flask_todo` repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: This file is used to describe information about the repository
    on GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.txt`: This is the file where we listed all the required packages
    mentioned in the preceding section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.py`: Here, we are going to create the final instance of our Flask application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zappa_settings.json`: This file gets generated by Zappa and has Zappa-related
    configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at a detailed explanation of the code in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While implementing any project, we may be required to have some configurations
    that are specific to different environments, such as toggling the debug mode in
    the development environment and monitoring in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Flask has a flexible way of overcoming the configuration handling mechanism.
    Flask provides a `config` object on its instance. This `config` object is built
    by extending the Python `dictionary` object but with some additional features
    such as loading the configuration from a file, object, and default built-in configurations.
    You can look at a detailed description of the `config` mechanism at [http://flask.pocoo.org/docs/0.12/config/](http://flask.pocoo.org/docs/0.12/config/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to maintain the configuration based on environments, we are going
    to create a file called `config/config.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `Config` object as a base class that has some generic configuration
    and `Flask-SqlAlchemy` configurations. Then, we extended the base `Config` class
    with environment-specific classes. Finally, we created a mapping object, which
    we will use from the aforementioned keys.
  prefs: []
  type: TYPE_NORMAL
- en: Base model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLAlchemy is most famous for its **object-relational mapper** (**ORM**), an
    optional component that provides the data mapper pattern, where classes can be
    mapped to the database in open-ended, multiple ways, allowing the object model
    and database schema to develop in a cleanly decoupled way from the beginning.
    We are using the `Flask-SQLAlchemy` extension here, which extends the support
    of SQLAlchemy. `Flask-SQLAlchemy` enhances the features that may need to be integrated
    with the Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to combine the generic SQL operations which are required to interact
    by using `Flask-SQLAlchemy`. Hence, we are going to create a base model class
    and will use this class for other modules' model classes. That's the reason we
    are putting it under the `config` directory. Here is the `models.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`config/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that we group the database operations that are required by
    all models. The `db` instance was created in the `app/__init__.py` file using
    the `Flask-SQLAlchemy` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have implemented the `save` and `delete` methods. `db.Model` defines
    a generic pattern to create a model class that represents the database table.
    In order to save and delete, we need to follow some predefined operations such
    as `db.session.add()`, `db.session.delete()`, and `db.session.commit()`.
  prefs: []
  type: TYPE_NORMAL
- en: So, we grouped the generic operations under the `save` and `delete` methods.
    These methods will be called from a model class that will inherit them. We will
    look at this later when we create a model class by extending `BaseModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to develop an authentication module, we are going to use the `Flask-Login`
    extension. The `Flask-Login` extension provides a user session management mechanism.
    It handles the common tasks for managing user sessions such as logging in, logging
    out, and remembering the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate `Flask-Login`, you need to create the instance and define some
    default parameters, as described in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create an authentication module as an `auth` package. An `auth`
    package will have basic scaffolding, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into a detailed description of each file, let's have a look at
    the instantiation Flask mechanism. As you already know, we are creating a submodule
    as an independent module under the `root` module. Flask introduces the concept
    of blueprint for making the submodule components under a common pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Flask blueprint instance is very similar to a Flask instance, but it's not
    an application object. Instead, it has the ability to construct and extend the
    parent application. With the help of blueprint, you can design a modular application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it has very similar characteristics to the `Flask` class and
    follows a similar pattern. Now, we will be using the `auth` instance of the `blueprint`
    in views to register routes. To execute the application, we need to bind the `blueprint`
    object with the Flask application instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the `register_blueprint` method, we are registering the `auth`
    module blueprint and we can add the URL prefix as well. We will have the complete
    description of this file after we look at the `todo` module explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating the `User` model with basic functionality. The following
    is a code snippet of the user model.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`auth/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have created the `User` model, but how does it relate or map with the
    `Flask-Login` extension? The answer to this is the `load_user` method, which is
    wrapped by the `login_manager.user_loader` decorator. Flask provides this method
    to load the user into the session. This method is called with the `user_id` that's
    present in the session.
  prefs: []
  type: TYPE_NORMAL
- en: We can persist the user's data into the database with the help of the `User`
    model. As a web application, user data needs to enter through a user interface
    such as HTML. As per our requirements, we need two types of HTML forms for login
    and sign up functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section and learn about rendering HTML forms through
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flask-WTF` extensions provide the ability to develop forms in Flask and render
    them through Jinja2 templates. `Flask-WTF` extends the `WTForms` library, which
    has standard patterns to design a form.'
  prefs: []
  type: TYPE_NORMAL
- en: We need two forms for this, such as `SignupForm` and `LoginForm`. The following
    is the code for creating forms classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`auth/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create the forms with some validations. Now, we are going to use these
    forms in the views section, where we are going to render the templates along with
    the forms context.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask implemented the views in a very flexible way, where you can define the
    routes along with them. Flask's generic views implementation is inspired by Django's
    generic views. We will look at a detailed description of method views in a further
    section, but here, we are going to use simple views.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the views snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`auth/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created the `/login`, `/signup`, and `/logout` routes, which we invoke
    based on HTTP requests. We are rendering an empty form instance on the HTTP `GET`
    request and processing the data on the `POST` request by using the `Flask-WTF`
    method and the `validate_on_submit()` method. While rendering the template, we
    are passing the form instance and redirect based on required actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the templates mechanism in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask has built-in support for Jinja2 templating. Jinja2 templating has a standard
    defined pattern for rendering the HTML. We can place dynamic content by passing
    the context argument. Jinja2 gives an ability to render HTML with some expressions
    and conditions, extending and including template features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask follows a standard templating scaffolding structure to lay out all template
    files. The following is the scaffolding we followed by creating a `templates`
    directory under the project''s root directory and then creating subdirectories
    based on other module names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have created templates as per the module and put the generic templates
    under the root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we have maintained the static file''s scaffolding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We kept the static libraries and modules-related files. With the help of the
    `url_for` method, we can get the relative path of any static files and routes.
    Hence, in the following template, we included all static files using a `url_for`
    method, such as `<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap/css/bootstrap.min.css')}}">`.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, we are going to include all static files in the base template.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`templates/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We defined all generic HTML that is required on all other templates. We also
    created a basic bootstrap navbar and kept this in `navbar.html`, which is included
    in the `base.html` template by `{% include 'navbar.html' %}`. As you can see,
    Jinja2 templating makes it super easy to maintain the templates and provide a
    standard pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`templates/navbar.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While designing `navbar.html`**,** we added some conditional statements to display
    the logged-in user's information and logout options when the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the sign up and login page. The following is the code snippet
    for the sign up page.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`templates/auth/signup.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the Sign Up page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the HTTP `GET` request on the `auth.signup` view, this will return an empty
    form and render it through the `signup.html` template. We also added code to receive
    the sign up data on the HTTP `POST` request in the sign up view. We persist the
    user data on the sign up process using the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the login template.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`templates/auth/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the user can proceed and log in to the system, For login, we have created
    the login form and rendered it through the `auth.login` view. The following is
    a screenshot of the Login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the HTTP `POST` request, we are processing the user login mechanism using
    the `Flask-Login` extension, which provides a function called `login_user` and
    performs the login process. It creates a session and adds `user_id` into the session
    to remember the user for the further request until we remove the user from the
    session or perform the logout with the `logout_user` method, as mentioned in the
    `auth.logout` view.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication process completes here, as the user login executes successfully
    and redirects the user to another page or template. Now, it's time to move on
    to the `todo` module.
  prefs: []
  type: TYPE_NORMAL
- en: Todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Todo program is considered to be a straightforward and simple application,
    and it is widely used to explain any language or framework after hello world!.
    We follow the same scaffolding structure for the `todo` module as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the scaffolding for the `todo` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see the detailed description for each file in the `todo` module.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask introduces the concept of blueprint for developing application components
    and command patterns in an application or across multiple applications. It helps
    to comprehend large-scale applications by centralizing the root Flask application
    object. Blueprint acts as a separate Flask application without creating an actual
    Flask application object, and is able to instantiate application objects, initialize
    several extensions, and register a collection. It also provides template filters,
    static files, templates, and other utilities.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the `auth` module, we will also create the `Blueprint` instance
    for the Todo application. This will be configured in the `app.__init__.py` file,
    which is where we created the Flask application instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`todo/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once we have created the `blueprint` object of the `todo` module, we can use
    it to add routes in views and register the blueprint with the Flask application
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use `Flask-SQLAlchemy` to create a todo model. It will have
    a relationship with the `User` model with a backward reference, so that we can
    query the `todo` data that's related to the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code snippet for the todo model.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`todo/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created the todo model with basic functionality and validation. Now,
    we will use this model to persist the `todo` data. However, we also need to have
    a UI for users to enter the `todo` data and perform some actions.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will have a simple todo form in which we have a textbox with a Submit button.
    It should also contain the list view to display the todo data.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a code snippet of the Todo form.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`todo/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our Todo form is straightforward with some basic validation.
    It's time to use this form in views to render them into HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the instance of a blueprint for todo, and we will use this instance
    to create the routes in views. The following is the code snippet for views.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`todo/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We defined three routes here. We have already used `todos` as the prefix while
    registering the todo blueprint on the Flask application object. Keeping that in
    mind, we have decided to use the route URLs.
  prefs: []
  type: TYPE_NORMAL
- en: To persist the todo data, we need to perform four types of action, which are—create
    a todo item, list todo items, update any specific item, and delete any specific
    todo item. These actions are nothing but a standard form of **CRUD** (**Create**,
    **Retrieve**, **Update**, **Delete**) operations.
  prefs: []
  type: TYPE_NORMAL
- en: CREATE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For creating an action, we decided to have the URL as `/`, but with the prefix,
    it would become `todos/`. On the HTTP `POST` request, we expect the todo data
    from the user, and based on the submitted data, we will create the todo data using
    the todo model, for example, `Todo(form.description.data, creator=current_user.email).save()`.
  prefs: []
  type: TYPE_NORMAL
- en: RETRIEVE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: UPDATE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the todo data, we would use the HTTP `PATCH` request for the route
    `todos/<todo_id>`. But, this time, we don't have any form and we are required
    to pass the data, hence we are using jQuery to make an Ajax query for the `PATCH`
    request.
  prefs: []
  type: TYPE_NORMAL
- en: We defined some attributes and methods to mark the todo data as finished, so
    based on the update data, we would use these methods to update the todo record.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to deleting the todo record from the database, we need to use the
    todo model's query methods, such as `Todo.query.filter_by(id=int(todo_id)).delete()`.
    As you can see, the routing views are straightforward. Now, let's have a look
    at templates.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of work needs to be done to accomplish the todo workflow. We defined the
    `templates/todo/list.html` template to display the todo form and a list of todo
    records. In a previous section, we described how we rendered and passed the context
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code snippet for the todo list template.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`templates/todo/list.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We used the context data to display the todo form and list of records. There
    are some operations that we need to write jQuery code for, such as updating the
    todo based on the checkbox action, and removing the todo based on the delete button
    action.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the jQuery code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`static/todo/list.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While making the Ajax request, we also added support for CSRF. Ajax requests
    are simple and straightforward as these are requests that are being served through
    the previously mentioned todo routes. The following is a screenshot of the todo
    list page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are done with the `todo` module, and it's time to configure the todo
    blueprint with a Flask application object.
  prefs: []
  type: TYPE_NORMAL
- en: FLASK_APP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any Flask project, we create the Flask application object and refer to the
    file path with a value to the `FLASK_APP` argument or environment variable. In
    our case, we created a modular application that has separate modules defined for
    specific operations, but now we need to combine all of these modules in one place.
    We have already seen the `blueprint` objects and their integration. Here, we will
    look at the actual process of combining the blueprint and other required extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code snippet for the Flask application object.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are configuring the extensions and blueprints, but under a method called
    `create_app`. This method needs an argument to set up the environment-specific
    configuration, hence it's really good to have this function and get the Flask
    application instance for a specific configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`flask_todo/run.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `dev` environment configuration. You can use this file as
    your `FLASK_APP` parameter, for example, `FLASK_APP=run.py flask run`.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the todo app development, so now it's time to proceed with
    deployment using Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to initiate the deployment using Zappa. To configure Zappa, you
    need to have Zappa installed and configured with your AWS credentials by using
    AWS CLI. Once we have installed Zappa and dealt with the AWS CLI configuration,
    we can move ahead and deploy the Todo application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the `zappa init` command process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When we run the `zappa init` command, Zappa automatically identifies the framework
    type and suggests the required parameters. In our case, we kept the `app_function`
    name as `run.app` because we are initiating the `flask app` object through the
    `create_app` method in `run.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The `zappa init` command creates the `zappa_settings.json` file, which has all
    the configured parameters. You are free to modify it as per your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to execute the deployment process using the `zappa deploy <stage_name>`
    command. Initially, we would use the `zappa deploy` command. Once our app has
    been deployed, we can't use the **`zappa deploy`** command. Instead, we need to
    use the `zappa update <stage_name>` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `zappa deploy dev` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We are done with deployment and are able to access the Todo application on a
    generated URL, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output after visiting the URL ([https://m974nz8zld.execute-api.ap-south-1.amazonaws.com/dev/auth/signup](https://m974nz8zld.execute-api.ap-south-1.amazonaws.com/dev/auth/signup)[)](https://p2wdbhjwd6.execute-api.ap-south-1.amazonaws.com/dev/auth/signup):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I am going to keep the `flask_todo` Lambda function live so that you can try
    it anytime. I have created a GitHub repository ([https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_3](https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_3))
    and pushed all of the code base to it for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the workflow of creating a Flask-based application
    and deploying it over a serverless environment using Zappa. With the help of Zappa,
    we moved the application to AWS Lambda and performed operations to maintain the
    deployment. While deploying the application, we don't need to configure the traditional
    server software; instead, we just use a JSON file to configure the deployment
    with multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see REST API's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Amazon API Gateway?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of `function_name` in `zappa_settings.json`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
