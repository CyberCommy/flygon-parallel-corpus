- en: Deploying with Cloud-Based Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inevitably, you'll want the application you've been building to be online and
    available to the world, whether you want to host your application online during
    its development process or when it's complete and ready for production. There
    are a number of different hosting options currently available for Node.js and
    MongoDB-based apps, and in this chapter, we'll take a look at deploying to a few
    different popular services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud versus traditional web hosting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Git source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application with Nodejitsu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application with Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application with Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application with Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief look at DigitalOcean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud versus traditional hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any previous experience with website hosting, which I'll refer to
    as traditional hosting, you're probably pretty familiar with the process of using
    FTP to upload your web files to your hosting provider. With traditional web hosting,
    service providers typically offer shared space to every user, each configured
    with their own public folder that houses the web files. In a scenario like this,
    every customer hosts the same kind of website, and their files are all stored
    and served from a single web server.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional web hosting is fairly inexpensive because a single web server can
    host literally hundreds, if not thousands, of individual websites. Scaling is
    typically a problem with traditional hosting because if your website demanded
    more power, it would need to be moved to another server (with more hardware) and
    could experience potential downtime during this move. As a side effect, if a website
    on the same server as your own is being particularly demanding of the hardware,
    every site on that server could suffer.
  prefs: []
  type: TYPE_NORMAL
- en: With cloud-based hosting, every instance of a website or service is hosted on
    its own **Virtual Private Server** (**VPS**). When a customer uploads a copy of
    their website, that website is running in its own isolated environment, and the
    environment is specifically designed to run only that website. Virtual private
    servers are instances of a server, typically all running simultaneously on the
    same hardware. Due to its isolated nature, a VPS scales very well because settings
    simply need to be changed for hardware allocation, and the server restarts. If
    your VPS is hosted on the same hardware as others, and they are experiencing high-volume
    spikes, your website will not suffer because of the isolated nature of the VPS.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as a Service versus Platform as a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of the cloud is that the level and amount of service one can obtain
    varies greatly. For something as simple as a basic hosting plan to run your web
    application, you can use any number of services that are considered a **Platform
    as a Service** (**PaaS**). This is a service that provides a platform for you
    to host and run your web application. Increasing in scale and complexity, you
    can turn to an **Infrastructure as a Service** (**IaaS**) provider, which offers
    an entire cloud-based data center at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the differences between IaaS, PaaS, and **Software
    as a Service** (**SaaS**) by reading a detailed article available at [http://www.rackspace.com/knowledge_center/whitepaper/understanding-the-cloud-computing-stack-saas-paas-iaas](http://www.rackspace.com/knowledge_center/whitepaper/understanding-the-cloud-computing-stack-saas-paas-iaas).
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based hosting costs can vary greatly because of the simple fact that they
    are so scalable. Your costs can fluctuate throughout a single month dramatically,
    depending directly on your need for power (that is, during more demanding times
    of the month and/or with big social media hits such as HackerNews or Reddit).
    On the flip side, if you require very little power for a server, you can often
    get cloud hosting for free!
  prefs: []
  type: TYPE_NORMAL
- en: Traditional web hosting service providers include GoDaddy, Dreamhost, 1&1, HostGator,
    and Network Solutions. Popular cloud-based hosting options include Nodejitsu (PaaS),
    Heroku (PaaS), Amazon Web Services (IaaS), Microsoft Azure (IaaS), and Digital
    Ocean.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With traditional hosting providers, the standard method for connecting to your
    server and uploading your files was to use **File Transfer Protocol** (**FTP**).
    You would connect using any standard FTP software and push a copy of your files
    to the server, and those changes would be reflected online instantly when accessing
    your website URL. With cloud-based hosting providers, the standard is typically
    to use the Git source control. Git is a source control technology that allows
    you to track changes and history with your project source code, as well as to
    provide an easy-use means of collaboration with multiple developers. The most
    popular Git online code repository provider is currently [www.github.com](http://www.github.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Git in order to track our application project source code and the
    method of pushing our code up to the various cloud-hosting providers. When you
    push code using Git, you are effectively transferring all or only the changed
    version of your code to an online repository (for example, Git and [www.github.com](http://www.github.com)
    are relatively easy to get into, but can seem intimidating and complex). If you''re
    unfamiliar with Git and/or [https://GitHub.com](https://GitHub.com), I would strongly
    suggest taking a moment to get acquainted by checking out the following guides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://help.github.com/articles/set-up-git](https://help.github.com/articles/set-up-git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gist.github.com/andrewpmiller/9668225](https://gist.github.com/andrewpmiller/9668225)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The guides will take you through the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering an account at [https://github.com](https://github.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating your machine with [https://github.com](https://github.com) and
    creating your first repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing your project source code to the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have your project source code configured as a local Git repository
    and all of the code committed to the master branch, proceed to the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have your project set up as a local GitHub repository, it's time
    to take that code and get it online! The following sections will each cover the
    process of deploying your application to a few different popular cloud-based hosting
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to explore and experiment with each, as most have free or relatively
    inexpensive plans. Each provider has its strengths and weaknesses, so I'll leave
    it up to you to decide which to stick to for your particular needs. The services
    that we cover aren't presented in any particular order.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this chapter, I will consistently name my app `imgploadr`;
    however, your app name needs to be different and unique. Wherever I include `imgploadr`
    in this chapter, you should replace it with your own app's unique name.
  prefs: []
  type: TYPE_NORMAL
- en: Nodejitsu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with Nodejitsu, visit [www.nodejitsu.com](http://www.nodejitsu.com)
    and register for a free account first. After providing your email address, username,
    and password, you will be presented with a pricing plan page where you can configure
    your service. If you just want to create the free account and experiment, simply
    click on the No Thanks button and the registration process is complete. Then,
    simply click on the Login button in the upper-right corner to log in and proceed
    to your Apps dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7398050-dfa5-4944-99b2-a69b657b3c89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Deploying your app to Nodejitsu will require a new command-line interface tool;
    specifically, the `jitsu` CLI. Clicking on the big blue Deploy an app with jitsu
    button will take you to the [www.github.com](http://www.github.com) repository
    for this tool. You can skip that step and just install the CLI manually, using
    the following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `sudo` part of the command to install an `npm` package globally (using the
    `-g` flag) is sometimes required. Depending on the access level of the machine
    you are using, you may or may not need to include `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `jitsu` CLI is installed, you can use this handy tool to log in
    to your Nodejitsu account, create an app, and deploy your project code. First,
    let''s log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that after successfully providing your username and password, you
    are now authenticated with Nodejitsu and are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can deploy the actual application, we need to configure the MongoDB
    database in our Nodejitsu dashboard. Switch back to your browser, and on the Nodejitsu
    Apps dashboard, switch sections by clicking on the Databases tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/135e760f-d109-4013-8f8f-94fd238cc1eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's choose MongoHQ for our needs by clicking on the large MongoHQ button.
    You will be prompted for a name for the new database, and then it will be listed
    at the bottom of the screen in the Your databases section. The important part
    we need is the connection string, and there's a convenient copy link right next
    to it to copy it to your clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `server.js` file and update the `mongoose.connect` line to use the
    new connection string you copied for your Nodejitsu database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing remaining is to open a Terminal, change directories to your
    project home, and execute the following command to package up your app and push
    it to Nodejitsu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After executing `jitsu deploy`, the CLI first prompts you to confirm what the
    subdomain will be under the [www.nodejitsu.com](http://www.nodejitsu.com) domain.
    Feel free to change this to whatever you like (it will check to confirm availability).
    It then makes a few minor modifications to your `package.json` file, specifically
    including the `subdomain` option with whatever value you provided. Finally, it
    uploads your source code and performs a remote `npm install` operation. Assuming
    that all went well, the app should be deployed and a confirmation of the URL should
    output to the screen. Feel free to open that URL in your browser to view the app
    online!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can also see that the app is listed in your Apps dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40844f95-248b-4505-93e8-5dc413ba1d82.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the application has been successfully uploaded, launch it via its
    URL and give it a test run by attempting to upload a new image. The first thing
    you should note is that attempting to upload an image fails with a fairly useless
    error (you can see the following error by accessing the Logs tab from your app''s
    dashboard):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This error is far from helpful! Basically, what's happening here is that the
    application is attempting to upload and save the image to the `temp` folder, which
    doesn't actually exist! We need to add a snippet of code to our application to
    check for this condition and create the folders, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `server/configure.js` file and insert the following code snippet between
    `routes (app);` and `return app;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using the filesystem `fs` module to create both the parent `upload`
    folder and the `temp` subfolder. Don''t forget to `require` the `fs` module at
    the top of the file, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is an `npm` module called `node-mkdirp` that will perform a recursive
    `mkdir`, which will basically accomplish the double `mkdir` we called in the preceding
    example. The only reason I didn't include it was for brevity and to not include
    additional instructions to install the module, require it, and use it unnecessarily.
    More information can be found at [https://www.npmjs.org/package/mkdirp](https://www.npmjs.org/package/mkdirp).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the mentioned changes made to your code, you need to deploy your application
    again. Simply execute another `jitsu deploy`, and a fresh copy of your code will
    be uploaded to your instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Open your app URL again, and this time you should be able to interact with the
    application and successfully upload a new image! Congratulations, you have successfully
    deployed your application, and it is now online using the Nodejitsu hosting service!
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular cloud-based hosting provider for Node.js apps is [www.Heroku.com](http://www.Heroku.com).
    The one thing that sets Heroku apart from other providers is the number of powerful
    add-ons that are available. Any kind of service you can imagine that your application
    will require is available as an add-on, including data stores, search, logging
    and analytics, email and SMS, workers and queuing, monitoring, and media. Each
    of these add-ons can be quickly and easily added to your service and integrated
    into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Like Nodejitsu, Heroku allows you to register for a free account and work within
    the confines of their *sandbox* pricing plans. The plans are free, but limited
    in scope with regard to bandwidth, processing power, and so on. Most, if not all,
    of the add-ons typically also offer some sort of free sandbox or trial-based plan.
    Just like Nodejitsu, one of the add-ons we will be using with our Heroku app is
    MongoHQ, a cloud-based MongoDB service provider.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, first go to [http://heroku.com](http://heroku.com) and sign
    up for your free account. While registration doesn't require a credit card, in
    order to include any add-ons with your application, you will have to have a credit
    card on file (even though you won't be charged unless you choose to scale up the
    services). After registering, click on the link in the confirmation email and
    provide a password; you will be presented with your Apps dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eed40703-a4d0-4d18-8035-9968d35e4bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll note that the first thing you need to do is to download the Heroku Toolbelt
    (again, much like the `jitsu` CLI for Nodejitsu). Click on the Download button
    to download and install the Toolbelt. The Toolbelt is a CLI specifically used
    to create and deploy apps to Heroku, and gives you the `heroku` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the Toolbelt installed, open a command-line Terminal and change
    directories to your project's root. From there, execute the following command
  prefs: []
  type: TYPE_NORMAL
- en: 'to log in to Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that you're logged in, you can issue commands directly to your Heroku
  prefs: []
  type: TYPE_NORMAL
- en: account and use those commands to create an application, install add-ons, and
    deploy your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you''ll want to do is to create a new application. Do so by
    executing `heroku create` from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the app, Heroku randomly assigns it a unique name; in my case,
    `secret-shore-2839` (don''t worry, though, as this can easily be changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's address the last part next. Heroku relies on the Git source control on
    your machine in order to push your project source code up to your server, unlike
    Nodejitsu, which uses its own file transfer mechanism. Assuming that you followed
    the directions earlier with regard to Git and [www.github.com](http://www.github.com),
    your project source code should be all set and committed to the master branch
    and ready to go. What we need to do next is to add a new remote for Git on your
    machine to point to Heroku; specifically, your new app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `git init` to initialize `git` in the current working directory
    and then execute the following command to create a new remote for Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Before you can push your source code up to your Heroku account, we need to take
    care of a few things.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special file is required before your application will be able to run on your
    Heroku server. This file is called `Procfile`, and it specifically contains the
    command necessary to launch your application. Create this new file named `Procfile`
    (no extension) in the root of your project and include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! With that file, Heroku will use that command to launch your application.
    Now that you have `Procfile` set up and your project source code ready, there''s
    only one thing left to do--install the MongoHQ add-on and configure your app to
    use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the MongoHQ add-on added, you can now configure the database itself and
    retrieve the connection string (much like you did earlier with Nodejitsu). Access
    your [http://heroku.com](http://heroku.com) Apps dashboard, and it should look
    something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4991395a-bda2-4621-980b-56564bf02f32.png)'
  prefs: []
  type: TYPE_IMG
- en: The app's dashboard screen is a great place to get a snapshot of your application
    and a quick glance at its current cost. Since I'm using the sandbox and/or free
    plans for my application and add-ons, my current estimated monthly cost is $0.00\.
    However, you can quickly and easily scale your apps, should you demand more power.
    Pay attention, as you can also just as quickly and easily escalate your monthly
    cost through the roof! (Scaling everything to maximum, I was able to get my estimated
    cost to roughly $60,000 per month!).
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure your MongoHQ database, simply click on the MongoHQ link under
    the Add-ons section of your app''s dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ae6d0cd-0d61-4134-8027-2e0245c59c21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Admin tab with the gear icon below the Collections tab. Click on
    the Users tab and provide a username and password that your application will use
    to connect with your MongoHQ database. This will create the `imgploadrdb` username
    with a secure password. With the new user added, switch back to the Overview tab
    and copy the Mongo URI string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, just like with Nodejitsu, edit the `server.js` file in your project
    and replace the `mongoose.connect` string with the new URI you just copied. Edit
    the string and replace `<username>` and `<password>` with the appropriate values,
    based on the new user account you just created. The `server.jsmongoose.connect`
    code should look as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you just made changes to your project''s source code, you need to remember
    to commit those changes to your Git repository master branch so that they can
    be uploaded to Heroku. Execute the following command to permanently commit these
    changes to your source code and upload your code to your Heroku server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step to get your application up and running is to create an instance
    of your server (basically, the equivalent of turning it on). To do this, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Success! Hopefully, your browser launched and your website is up and running.
    Go ahead, give it a try and upload an image! Thanks to the bug we caught during
    the Nodejitsu deployment, this updated version of the application should work
    just fine.
  prefs: []
  type: TYPE_NORMAL
- en: While deploying with Heroku seems more complicated than Nodejitsu, this is probably
    because it uses Git source control to facilitate the transfer of your project
    files. Also, because Heroku is so flexible with the power of its scaling and add-ons,
    the Toolbelt CLI is a little more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Nodejitsu and Heroku can be considered developer-level service providers
    because they are PaaS, Amazon Web Services (and Microsoft Azure) will be considered
    enterprise-level services because they are more IaaS. The sheer volume of options
    and services available with AWS and Azure is staggering. These are definitely
    top-tier services and hosting an application like ours is kind of like using a
    bazooka to kill a fly!
  prefs: []
  type: TYPE_NORMAL
- en: AWS does provide its own NoSQL database, called DynamoDB, but for our purposes,
    we want to continue working with MongoDB and use Mongoose in our app. To do this,
    we can use a third-party MongoDB provider. If you recall, when we originally set
    up Nodejitsu, one of the MongoDB providers listed was MongoLab. MongoLab provides
    **MongoDB-as-a-Service**, which means we can use its service to host our MongoDB
    database, but use all of the power of AWS to host our Node.js application (this
    is not unlike what's already happening with Nodejitsu and Heroku; they just streamline
    the process a little better). Remember that AWS is an IaaS provider, so you can
    also just create another server instance and install MongoDB on it yourself and
    use that as your data source. However, that's slightly beyond the scope of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MongoLab account and database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use MongoLab with our app in AWS, we first need to register a new
    account on [https://mlab.com/](https://mlab.com/) and create an AWS database subscription.
    After you register a new account and activate it using the link they send you
    via email, you can create your first database subscription.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bd62362-3612-43b7-88d0-ff9e03c301de.png)'
  prefs: []
  type: TYPE_IMG
- en: From your main dashboard, click on the Create new button (with the lightning
  prefs: []
  type: TYPE_NORMAL
- en: bolt icon).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Create new subscription page, configure the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud provider: amazon web services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Location: Whichever region you prefer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plan: Select Single-node (development)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select Sandbox (shared/free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB version: `2.4.x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database name: `anything_you_want` (I chose `imgploadr`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm that the price is $0 per month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Create new MongoDB deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going back to your main dashboard, you should now see that your new database
    has been created and is ready to go. The next thing we need to do is to create
    a user account that our app will use to connect to the server. Click on the database
    listed on the main dashboard and then select the Users tab. Provide a new username
    and password. After the new user account has been added, copy the URI located
    at the top of the screen (it only appears after a user has been added) that starts
    with `mongodb://`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have the new URI connection string, we need to update `server.js`
    to include this new connection string in our `mongoose.connect`. Edit the file
    and update it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you replace `<username>` and `<password>` with the appropriate information
    from the user account you created on the MongoLab dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: With our application code updated to point to the new MongoLab database connection
    string, we need to zip up the project files so that they can be uploaded via the
    AWS dashboard. From your computer's file browser, locate the project root that
    contains all of your applications' source code files, select all of them, and
    right-click on them to add to an archive or ZIP file. The name of the ZIP file
    can be whatever you choose. One thing to note is that you shouldn't include the
    `node_modules` folder with this ZIP file (the easiest solution might be to simply
    delete the folder altogether). The AWS online docs have a great write-up on creating
    ZIP files, if you need more information ([https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.deployment.source.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.deployment.source.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Once your source code has been updated to use the new MongoLab connection string
    and you've created a ZIP file of the entire project (excluding the `node_modules`
    folder), you're ready to create the new AWS application and deploy your app.
  prefs: []
  type: TYPE_NORMAL
- en: Create and configure the AWS environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't already have an account with Amazon, you will need one to use their
    AWS services. Point your browser to [http://aws.amazon.com](http://aws.amazon.com)
    and click on Sign Up (even if you already have an Amazon account). From the screen
    that follows, you can log in using your existing Amazon account or register for
    a new account. Once you've registered and logged in, you should be presented with
    the entire suite of cloud services AWS has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary service we''re interested in is Elastic Beanstalk (located under
    Deployment and Managed with a green icon):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bbff13f-5a46-4007-8623-7fb52c338d51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this screen, click on the Create New Application link in the upper-right
    corner. The screens that follow will walk you through a multistep wizard process,
    where you will configure the environment in which the application will reside.
    Configure the following settings, where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Application Information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application name: `anything_you_want`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment Type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment tier: `Web Server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Predefined configuration: `Node.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment type: `Load balancing`, `autoscaling`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application Version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload your own (choose the ZIP file that you created earlier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment Information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment name: `anything_you_want`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment URL: `anything_you_want` (this is the subdomain for your app)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration Details:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instance type: `t1.micro`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining fields can be left blank or at their default values
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment Tags: Skip this step; it is unnecessary for this app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final step is to review the configuration settings and then launch the environment
    (by clicking on the blue Launch button).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c084bb2c-9f8f-4c84-9c31-0ec876a31f7f.png)'
  prefs: []
  type: TYPE_IMG
- en: It might take a few minutes for Elastic Beanstalk to configure and launch your
    environment
  prefs: []
  type: TYPE_NORMAL
- en: and application, so you might need to sit tight. With the environment officially
    launched and the application online, go ahead and open your app (by clicking on
    the link at the top of the page) and give it a test run. Assuming that everything
    went according to plan, your application should be up and running and should be
    working just fine!
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft's Azure service is very similar to Amazon's AWS. Both can be considered
    enterprise-level services, and both offer a tremendous level of flexibility and
    power, with a really slick UI. Surprisingly, even though it's a Microsoft product,
    you can spin up instances of Linux environments using Azure, as well as host your
    Node.js and MongoDB apps.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you will need, like with any other service, is a registered
    account at [http://azure.microsoft.com](http://azure.microsoft.com). You can use
    an existing Microsoft Live login if you have one; otherwise, you can register
    for a new account fairly easily. Once you're logged in to the Azure service, the
    first thing you'll be presented with is your primary dashboard. The icons to the
    left are all the various services and options available with Azure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e6ff7d5-9fb1-45cd-9820-6b1e4f130ae7.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the +NEW icon at the bottom-left corner will present you with the
  prefs: []
  type: TYPE_NORMAL
- en: main dialog that you can use to add any new service. For our purposes, we want
    to
  prefs: []
  type: TYPE_NORMAL
- en: 'add a website:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Compute, Web Site, and From Gallery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Node JS Empty Site from the long list of gallery options. This will create
    the necessary environment so that you have somewhere you can put your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the screen that follows, provide the URL for your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the remaining fields as their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the checkmark icon to complete the setup process, and your website
    will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to set up the database server. Again, similar to AWS or Nodejitsu,
    we will once again select MongoLab as our database service provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the +NEW icon again, select Store, and browse the list until you find
    and select MongoLab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the next arrow and browse through the various plans. For our needs,
    we will leave Sandbox selected (since it's free).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name for your database; in my case, I entered `imgploadrdb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next again to review and confirm the plan and monthly price (which
    should be $ 0.00 per month).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the checkmark icon to Purchase this new subscription plan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a few seconds, you should be taken back to your dashboard, where you
    will see entries for both the website and database app service listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb1656ca-1da9-4573-889b-d0efd47375c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the database has been created and is ready, we need to include its
    connection string in our application before we can upload our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the database row to select it and go to its overview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bottom of this screen will contain a few icons, one of which is labeled
    as Connection Info (and has an icon that looks like >i). Click on that icon for
    a modal window, which contains the connection string URI for your new MongoLab
    database server, to pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy that URI to your clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `server.js` in your local app and replace the `mongoose.connect` connection
    string with the new string you just copied. There is no need to update the `username`,
    and `password` as Azure has already taken care of this for you using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that change has been made, save the file, and don''t forget to update
    your local Git repository with the change, as we''ll be using Git in the next
    section to push your code to Azure (just like we did earlier with Heroku):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Back at the Azure dashboard, click on Web Site in the All Items list (or filter
    by websites using the icons on the left toolbar). From this overview screen, locate
    the Integrate source control section toward the bottom and click on the Set up
    deployment from source control link. The following screenshot shows what you should
    see at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29b5fb99-253e-447f-b760-bd49458a4fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: Select Local Git repository and then continue by clicking on the next arrow
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen that follows will present instructions on how to push your local
    code to the remote Git repository that has just been created for your Azure website.
    The gist is to add a new Git remote (much like we did earlier with Heroku) that
    points to your Azure repository, and then push your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You should notice the Git information screen in your Azure dashboard update
    in real time as your code starts to push up after the `git push` command. From
    the command line, you will see a lot of remote `npm install` output as well. Once
    completed, the deployment history in your Azure dashboard will update, showing
    the information for the last active deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b10af1f-3a09-42c9-8a3e-a5a4640d65f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that your code has been deployed to your Azure website and your website
    connection string is pointing to your MongoLab Azure app service, you're ready
    to give the website a test run. Launch it by pointing your browser to [http://yourappname.azurewebsites.net](http://yourappname.azurewebsites.net).
    Azure does a lot of things right, (UI/UX) and has some really powerful options
    and scaling features available! Taking a quick glance at the dashboard for a website
    (the preceding screenshot), you can see that there is a lot going on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfa39f54-7930-4030-9a86-f10cbfb1c16f.png)'
  prefs: []
  type: TYPE_IMG
- en: There are many different configuration options, as well as health monitoring
    and general information (FTP settings, website URLs, usage metrics, and so on),
    so feel free to poke around and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Digital Ocean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last service I wanted to mention and briefly take a look at is Digital Ocean--[http://digitalocean.com](http://digitalocean.com).
    Digital Ocean is a true **Virtual Private Server** (**VPS**) service provider
    and is a good example of a service that gets you just about as *close to the metal*
    as possible. What this means is that Digital Ocean doesn't really have all the
    bells and whistles that the other services that we've seen offer. What Digital
    Ocean does offer, however, is direct, unfiltered access to the Linux server instance
    you spin up, referred to as **Droplets** in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Digital Ocean allows you to boot up new Linux; virtual server instances very
    quickly. They offer very competitive prices, and they're a great service if you
    need to get a Linux server superfast because you only need one for a short period
    of time, or you want to boot up your own Linux server that you plan to use to
    host a production environment. The only *downside* (if I had to refer to it as
    such) is that you have to be pretty familiar with Linux; specifically, with administering
    a server and all the responsibilities that come with that.
  prefs: []
  type: TYPE_NORMAL
- en: You can very easily clone your project using Git on a new Droplet, but an example
    of the actual raw nature of a new Droplet is that Git is not installed on the
    server by default. You need to manually install Git before you can clone your
    repository. Depending on which image you decided to clone when creating a new
    Droplet, you might need to install and configure Node.js as well as MongoDB. Fortunately,
    Digital Ocean offers a number of predefined servers you can choose from when creating
    a new server, one of which includes the **MongoDB, Express, Angular,** and **Node.js**
    (**MEAN**) stacks. Beyond that, actually launching your app will only run as a
    process during your currently logged in session; once you log out, your application
    will go down. You will need to further administer the server to configure your
    app to run as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital Ocean allows you to connect directly to your server using the console
    access tool within the website itself, or by using SSH directly from a Terminal
    on your own machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/551b8d9d-c20d-48d3-b477-6e98e6307c0f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I mention Digital Ocean only because a lot of people will find this kind of
    raw power quite refreshing and will want to do their own hands-on kind of configuration
    and maintenance on their server. Digital Ocean is an awesome service, but it's
    not for everyone. I wanted to talk about it specifically because I feel that it
    rounds out and completes the list of services we've covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered the full spectrum of cloud-based hosting service providers and
    walked through configuring your service and deploying your project code. Nodejitsu
    and Heroku are great services that cater more to developers and give them a lot
    of power through very accessible and slick user interfaces. Amazon and Microsoft,
    both industry juggernauts, are representatives of the kind of power and sophistication
    you'd expect with enterprise-level service providers. Digital Ocean is a no-frills,
    *close to the metal*, cloud-based VPS provider that sacrifices bells and whistles
    for raw and direct access to the server.
  prefs: []
  type: TYPE_NORMAL
- en: All the hosting options we covered are great, and not the only choices out there.
    They're just a sample, but they speak to the power of the cloud! Within a few
    minutes and with very little to no cost at all, you can have an environment configured,
    and your website up and running online!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the concept of Single-Page Applications
    and popular client-side development frameworks and tools.
  prefs: []
  type: TYPE_NORMAL
