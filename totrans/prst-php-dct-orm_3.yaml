- en: Chapter 3. Associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use Doctrine annotations to add mapping
    information to an entity class. We used code and database schema generators provided
    by Doctrine command-line tools, and we created a minimalist blog software that
    uses an `EntityManager` class to create, update, delete, and display blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third chapter, we will learn how to handle associations between entities
    through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Doctrine associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the @ManyToOne and @OneToMany annotations with the comment system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the @ManyToMany annotation with tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with the Doctrine associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will specify Doctrine associations, such as other mapping information, using
    annotations (other methods such as XML and YAML configuration files are also supported.
    See [Chapter 2](ch02.html "Chapter 2. Entities and Mapping Information"), *Entities
    and Mapping Information*). Doctrine supports the following association types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-To-One**: One entity is linked to one entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-To-One**: Several entities are linked to one entity (only available
    for bidirectional associations and always the inverse side of a One-To-Many association)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-To-Many**: One entity is linked to several entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-To-Many**: Several entities are linked to several entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An association can be unidirectional or bidirectional. Unidirectional associations
    only have an owning side while bidirectional associations have both an owning
    side and an inverse side. In other words they can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A unidirectional association can be used in only one way: related entities
    are retrievable from the main entities. For example, a user has associated addresses.
    Addresses can be retrieved from the user, but the user cannot be retrieved from
    an address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A bidirectional association can be used in two ways: related entities are retrievable
    from main entities, and main entities are retrievable from related entities. For
    example, a user has associated orders. Orders can be retrieved from the user,
    and the user can be retrieved from an order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doctrine only manages the owning side of an association. This means that you
    always need to set the owning side; otherwise, if you only set the inverse side
    of an association, it will not be persisted with by the `EntityManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: There is an easy way to identify the side of a bidirectional association. The
    owning side must have an `inversedBy` attribute, and the inverse side must have
    a `mappedBy` attribute. These attributes refer to the related entity class.
  prefs: []
  type: TYPE_NORMAL
- en: By default, One-To-One and Many-To-One associations are persisted with at the
    SQL level using a column storing the related ID and a foreign key. Many-To-Many
    associations always use an association table.
  prefs: []
  type: TYPE_NORMAL
- en: The names of columns and tables (if applicable) are generated automatically
    by Doctrine. Names can be changed using the `@JoinColumn` annotation, and the
    use of an association table can be forced with the `@JoinTable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the @ManyToOne and @OneToMany annotations with the comment system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the comments. Visitors to our blog should be able to react
    to our posts. We have to create a new `Comment` Doctrine entity type storing the
    reader's comments. `Comment` entities will be linked to one `Post` entity. One
    post can have many comments, and one comment is associated with a sole post.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following E-R diagram represents the MySQL schema that will be generated
    using mapping information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the @ManyToOne and @OneToMany annotations with the comment
    system](graphics/4104_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Comment entity class (owning side)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Comment` entity has the following four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is a unique identifier of the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: This represents the comment''s text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publicationDate`: This is the date of publication of the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_id`: This represents the post related to the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is the first code snippet of the `Comment` entity, containing annotated
    properties. It must be placed in the `Comment.php` file at the `src/Blog/Entity/`
    location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This entity class is similar to the `Post` entity class created in [Chapter
    2](ch02.html "Chapter 2. Entities and Mapping Information"), *Entities and Mapping
    Information*. We use the `@ManyToOne` annotation to create a Many-To-One association
    between the `Comment` and `Post` entities. The related entity class is specified
    using the `targetEntity` attribute. This attribute is mandatory for every association.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to retrieve comments directly from the `Post` entity, this association
    must be bidirectional. The `inversedBy` attribute marks this association as bidirectional
    and indicates the property of the `Post` entity class that owns the inverse side
    of this association. Here, this is the `$comments` property of `Post`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for every entity class with `private` or `protected` properties, the `Comment`
    class must expose getters and setters to access them. We will generate getters
    and setters for every entity class of our app later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the inverse side to the Post entity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to modify the `Post` entity class to add the inverse side of this
    association. The following steps need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Post.php` file at the `src/Blog/Entity/` location, and add the use
    statements from the previous code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `$comments` property as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add its initialization code in the constructor as shown in the next code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the entity generator provided by Doctrine command-line tools to create
    getters and setters of the properties we have just added to the `Comment` and
    `Post` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the generated `addComment()` method, add the highlighted line of the following
    code snippet to automatically set the owning side of the association:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `$comments` property holds the collection of comments associated with the
    `Post` entity. We use the `@OneToMany` annotation to mark this property as the
    inverse side of the association, defined earlier in the `$post` property of `Comment`.
    We have already explained the `targetEntity` attribute. The `mappedBy` attribute
    is an equivalent of the `inversedBy` attribute for the inverse side of an association.
    It indicates the property of the related entity class owning the other side of
    the association.
  prefs: []
  type: TYPE_NORMAL
- en: To allow Doctrine to manage the collection of elements properly, a special class
    provided by the Doctrine Common component must be used. The `$comments` property
    of the `Post` entity is initialized in the constructor as an instance of `Doctrine\Common\Collections\ArrayCollection`.
    `ArrayCollection` implements the `Doctrine\Common\Collections\Collection` interface.
    This will enable Doctrine to populate and manage the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine `Collection` class implements the `Countable`, `IteratorAggregate`,
    and `ArrayAccess` interfaces (these interfaces are predefined in PHP or in the
    SPL). With that, Doctrine collections can be used like the standard PHP arrays
    and iterated transparently in the foreach loops.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information about predefined interfaces and interfaces provided by the
    Standard PHP Library (SPL) can be found in the following PHP manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/reserved.interfaces.php](http://php.net/manual/en/reserved.interfaces.php)
    and [http://php.net/manual/en/spl.interfaces.php](http://php.net/manual/en/spl.interfaces.php)'
  prefs: []
  type: TYPE_NORMAL
- en: The `addComment()` and `removeComment()` methods generated by Doctrine command-line
    tools demonstrate the ways to use the methods of a Doctrine `Collection` class
    to add and remove items.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The full list of available methods is documented on the Doctrine website as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/reference/working-with-associations.html](http://docs.doctrine-project.org/en/latest/reference/working-with-associations.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing, as already explained, is that Doctrine only manages
    the owning side of an association. This is why we call the `setPost()` method
    of the `Comment` entity in the `addComment()` method. This allows persisting with
    an association from the inverse side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This works only if the change-tracking policy of the entity is Deferred Implicit
    (This is the case by default). The deferred implicit policy is the most convenient
    one to use but can have negative effects on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, refer to the Doctrine documentation at the following website to learn
    more about the different change-tracking policies that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html](http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In a moment, we will update our UI to add the comment feature. First the database
    schema must be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the database schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with other annotations, Doctrine is able to automatically create the columns
    and foreign keys needed to store associations at the SQL layer. Run the `orm:schema-tool:update`
    command again bundled with the command-line tools as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Doctrine will automatically detect changes done to the mapping and will update
    the SQL schema accordingly. The `--force` flag can be added to effectively execute
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `orm:schema-tool:update` command must not be used in production. It can
    permanently delete data (when columns are dropped for instance). Instead, the
    Doctrine Migrations library should be used to properly handle complicated migrations.
    Even if this library is not considered stable yet, it is very convenient. We can
    find this library at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html](http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding fixtures for the comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for posts, we will create some fixtures for the comments. Create a new file,
    `LoadCommentData.php` in the `src/Blog/DataFixtures/` location. The next code
    snippet is used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use the `EntityManager` class to retrieve the `Post` entity repository, and
    then we use this repository to retrieve all the posts. We add five comments to
    each post. This data fixture class implements the `Doctrine\Common\DataFixtures\DependentFixtureInterface`
    interface (the `getDependencies()` method). It tells the data loader to load `LoadPostData`
    first because this data fixture class is dependent on it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and creating comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time to update the UI. Create a file, `view-post.php` in the `web/` location.
    This page displays a single post with all its comments and a form to add a new
    comment, and handles the comment creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to retrieve the post and handle the comment creation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, managing simple associations with Doctrine is easy. Setting
    a relation is as simple as calling a setter with the entity to the link in the
    parameter. Related entities are accessible using getters. The code to display
    details of the post, associated comments, and a form to publish a new comment
    (put it at the bottom of the same file) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By default, Doctrine lazyloads the associated entities. It means that, in our
    example, Doctrine sends a first query to the DBMS to retrieve the post and then
    another to retrieve associated comments when `getComments()` is called. The benefit
    is that the query to retrieve the associated comments is never executed if the
    `getComments()` method is not called. But when the associated comments are always
    fetched, this is a useless overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make the lazyloading feature work, Doctrine internally wraps the entities
    into proxy classes. Proxy classes are responsible for getting the data of associated
    entities not already loaded from the database, when requested. Some details about
    that can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/reference/working-with-objects.html#entity-object-graph-traversal](http://docs.doctrine-project.org/en/latest/reference/working-with-objects.html#entity-object-graph-traversal)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change this behavior by setting a `fetch` attribute on the association
    annotation. This attribute can take the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EAGER`: The related entities are generally fetched in the first query using
    a SQL join.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LAZY`: The related entities are fetched only if requested with another SQL
    query. This is the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXTRA_LAZY`: This allows performing some operations such as counting on collections
    that are not already fetched without loading the entire collection in the memory.
    To learn more about this topic, consult the following tutorial:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/tutorials/extra-lazy-associations.html](http://docs.doctrine-project.org/en/latest/tutorials/extra-lazy-associations.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to eagerload the related entities is to use the Doctrine Query Builder
    to customize the generated request. We will demonstrate the power of the Query
    Builder in [Chapter 4](ch04.html "Chapter 4. Building Queries"), *Building Queries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By deleting comments in the `view-post.php` page, we have created a link allowing
    the deletion of comments. The code to put in the `delete-comment.php` file in
    the `web/` location to make this feature work is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This file is very similar to the `delete-post.php` file in the `web/` location
    created in [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine 2"),
    *Getting Started with Doctrine 2*. It retrieves the repository through the `EntityManager`
    class, uses it to retrieve the comment to delete, calls `remove()`, and persists
    with the change to DBMS with `flush()`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update the `index.php` file in the `web/` location to create a link to the
    new, detailed post view as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our comment feature ready, replace the preceding code with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the @ManyToMany annotation with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tags group posts by topics. A tag contains several posts, and a post has several
    tags. This is a Many-To-Many bidirectional association. Doctrine manages transparently
    the association table needed to store Many-To-Many relations at the SQL level.
    The MySQL schema that will be generated is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the @ManyToMany annotation with tags](graphics/4104_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Tag entity class (inverse side)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Tag` entity class has only two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the name of the tag, it is unique, and is the identifier of
    the entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`posts`: This is the collection of posts associated with this tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the steps to create the `Tag` entity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Tag.php` file in the `src/Blog/Entity/` location that contains the
    entity class using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate getters and setters using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line of code to set the owning side of the association after
    `$this->posts[] = $posts;` in the `addPost()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The property `$name` is the identifier of the `Tag` entity. Unlike the `Post`
    and `Comment` entities, its value is not automatically generated by DBMS; it's
    the name of the tag. That's why the `@GeneratedValue` annotation is not used here.
    The name of the tag must be unique and must be set by the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ManyToMany` annotation is used to mark the association. The meanings of
    the `targetEntity` and `mappedBy` attributes are the same as for the `@OneToMany`
    annotation. The `@ManyToMany` annotation accepts a `mappedBy` attribute for the
    inverse side and `inversedBy` for the owning side. The owning side of this association
    is on the `Post` entity. As for any Doctrine collection, the `$posts` property
    is initialized in the constructor. We also create a `__toString()` method returning
    the name of the tag to be able to cast instances of `Tag` to the string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `__toString()` magic method allows us to convert an object to a string.
    For more details we can refer to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.php.net/manual/en/language.oop5.magic.php#object.tostring](http://www.php.net/manual/en/language.oop5.magic.php#object.tostring)'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Post entity class (owning side)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the `Post.php` file in the `src/Blog/Entity/` location to add the owning
    side of the association using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following use statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `mapped` property using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the property in the constructor as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate getters and setters, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Two new attributes of the `@ManyToMany` annotation are introduced here, that
    is, `cascade` and `orphanRemoval`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the associated entities are not automatically set to the managed
    state when the main entity is set. This must be done manually with a call to the
    `persist()` method of the `EntityManager` class for each associated entity. If
    the `cascade` attribute is used with `persist` as value, the related entities
    will be automatically persisted with when the main entity is persisted with.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the related tags will be persisted with when the `Post` entity is persisted
    with. The `cascade` attribute can take other values, the most useful of which
    is `remove`. When `remove` is used, the related entities will be deleted when
    the main entity is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The `CASCADE` operations are handled in memory by **Object Relational Mapper
    (ORM)** . They are not equivalent to the SQL `DELETE CASCADE` operations and can
    use a lot of memory. They should be used with parsimony to preserve the performance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL `DELETE CASCADE` operations can be added through the `onDelete` attribute
    of the `@JoinColumn` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: With the `orphanRemoval` attribute set to `true`, Doctrine will automatically
    delete the entities not linked with the main entity anymore. If the `Tag` entity
    is removed from the `$tags` collection of a `Post` entity, and this `Post` entity
    was the only one linked to the `Tag` entity, the `Tag` entity will be permanently
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch` attribute has already been explained earlier in the chapter. With
    the `EAGER` value, it tells Doctrine to automatically retrieve the related tags
    with a `JOIN` query when the posts are retrieved. This is useful in the context
    of our app because the tags of the `Post` entity are displayed every time the
    post is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Because the identifier of `Tag` is not marked with the `@GeneratedValue` annotation,
    Doctrine will not be able to guess it. The `@JoinTable` and `@JoinColumn` annotations
    are here to override the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We set a custom `JOIN` column with `@JoinColumn` for the tag-related side of
    the association (inverse side) through the `inverseJoinColumns` attribute of `@JoinTable`.
    The `referencedColumnName` attribute of `@JoinColumn` tells Doctrine to look for
    the `$name` property (instead of `$id` by default) for the identifier of `Tag`.
    The `name` attribute sets the name of the column holding the identifier of `Tag`
    in the SQL level association table to `tag_name` (instead of `tag_id` by default).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the schema again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to update the SQL schema again to match our changes. We use the
    following command on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating tag fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `LoadTagData.php` file at `src/Blog/DataFixtures/`, which contains
    tag fixtures using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `persist` attribute, we can add tags to posts without manually
    persisting with them.
  prefs: []
  type: TYPE_NORMAL
- en: After the fixtures, we have to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the tags of a post
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `edit-post.php` file at the `web/` location, and add the code to manage
    the tags with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `use` statement at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this code after `to extract` and manage the submitted tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following form widget after `to display` and update the tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Each tag name is extracted from the submitted string. The corresponding `Tag`
    entity is retrieved from the repository or created if not found.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to its `toArray()` method, the `tag` collection of the `Post` object
    is converted to a standard PHP array.
  prefs: []
  type: TYPE_NORMAL
- en: The standard `array_diff()` function is used to identify removed and added `Tag`
    objects. The arguments of `array_diff()` must be arrays of objects that can be
    converted to a string. It is okay here because our `Tag` class implements the
    `__toString()` magic method.
  prefs: []
  type: TYPE_NORMAL
- en: Deleted tags are removed through the `Post::removeTag()` function, and new tags
    are added through `Post::addTag()`.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `CASCADE` attribute defined in the `Post` entity class, we don't
    need to persist individually with each new tag.
  prefs: []
  type: TYPE_NORMAL
- en: In the template, the tag list is transformed to a string following the pattern
    "tagname1, tagname2, tagname3".
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to manage all types of associations supported
    by the Doctrine ORM. We learned about unidirectional and bidirectional associations
    and the concept of owning side and inverse side. We also used what we have learned
    in previous chapters, especially the `EntityManager` class, the fixture loader,
    and generators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create complex queries with DQL and
    Query Builder.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to them, we will create lists of posts grouped by their tags. We will
    also take a look at the aggregate functions.
  prefs: []
  type: TYPE_NORMAL
