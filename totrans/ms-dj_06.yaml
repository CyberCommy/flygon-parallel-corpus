- en: Chapter 6. Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML forms are the backbone of interactive websites, from the simplicity of
    Google's single search box to ubiquitous blog comment submission forms to complex
    custom data-entry interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers how you can use Django to access user-submitted form data,
    validate it and do something with it. Along the way, we'll cover `HttpRequest`
    and `Form` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from the Request Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I introduced `HttpRequest` objects in [Chapter 2](ch02.xhtml "Chapter 2. Views
    and URLconfs"), *Views and URLconfs*, when we first covered view functions, but
    I didn''t have much to say about them at the time. Recall that each view function
    takes an `HttpRequest` object as its first parameter, as in our `hello()` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpRequest` objects, such as the variable `request` here, have a number of
    interesting attributes and methods that you should familiarize yourself with,
    so that you know what''s possible. You can use these attributes to get information
    about the current request (that is, the user/web browser that''s loading the current
    page on your Django-powered site), at the time the view function is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Information about the URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HttpRequest` objects contain several pieces of information about the currently
    requested URL (*Table 6.1*).'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute/method | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| `request.path` | The full path, not including the domain but including the
    leading slash. | `"/hello/"` |'
  prefs: []
  type: TYPE_TB
- en: '| `request.get_host()` | The host (that is, the "domain," in common parlance).
    | `"127.0.0.1:8000"` or `"www.example.com"` |'
  prefs: []
  type: TYPE_TB
- en: '| `request.get_full_path()` | The `path`, plus a query string (if available).
    | `"/hello/?print=true"` |'
  prefs: []
  type: TYPE_TB
- en: '| `request.is_secure()` | `True` if the request was made via HTTPS. Otherwise,
    `False`. | `True` or `False` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: HttpRequest methods and attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Always use these attributes/methods instead of hard-coding URLs in your views.
    This makes for more flexible code that can be reused in other places. A simplistic
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Other information about the Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`request.META` is a Python dictionary containing all available HTTP headers
    for the given request-including the user''s IP address and user agent (generally
    the name and version of the web browser). Note that the full list of available
    headers depends on which headers the user sent and which headers your web server
    sets. Some commonly available keys in this dictionary are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTP_REFERER`: The referring URL, if any. (Note the misspelling of `REFERER`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_USER_AGENT`: The user''s browser''s user-agent string, if any. This looks
    something like: `"Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829
    Firefox/2.0.0.17"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REMOTE_ADDR`: The IP address of the client, for example, `"12.345.67.89"`.
    (If the request has passed through any proxies, then this might be a comma-separated
    list of IP addresses, for example, `"12.345.67.89,23.456.78.90"`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that because `request.META` is just a basic Python dictionary, you''ll
    get a `KeyError` exception if you try to access a key that doesn''t exist. (Because
    HTTP headers are external data-that is, they''re submitted by your users'' browsers-they
    shouldn''t be trusted, and you should always design your application to fail gracefully
    if a particular header is empty or doesn''t exist.) You should either use a `try`/`except`
    clause or the `get()` method to handle the case of undefined keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I encourage you to write a small view that displays all of the `request.META`
    data so you can get to know what''s in there. Here''s what that view might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another good way to see what sort of information that the request object contains
    is to look closely at the Django error pages when you crash the system-there is
    a wealth of useful information in there, including all the HTTP headers and other
    request objects (`request.path` for example).
  prefs: []
  type: TYPE_NORMAL
- en: Information about submitted data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond basic metadata about the request, `HttpRequest` objects have two attributes
    that contain information submitted by the user: `request.GET` and `request.POST`.
    Both of these are dictionary-like objects that give you access to `GET` and `POST`
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` data generally is submitted from an HTML `<form>`, while `GET` data
    can come from a `<form>` or the query string in the page''s URL.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dictionary-like objects**'
  prefs: []
  type: TYPE_NORMAL
- en: When we say `request.GET` and `request.POST` are *dictionary-like* objects,
    we mean that they behave like standard Python dictionaries but aren't technically
    dictionaries under the hood. For example, `request.GET` and `request.POST` both
    have `get()`, `keys()` and `values()` methods, and you can iterate over the keys
    by doing `for key in request.GET`. So why the distinction? Because both `request.GET`
    and `request.POST` have additional methods that normal dictionaries don't have.
    We'll get into these in a short while. You might have encountered the similar
    term *file-like objects*-Python objects that have a few basic methods, like `read()`,
    that let them act as stand-ins for "real" file objects.
  prefs: []
  type: TYPE_NORMAL
- en: A simple form-handling example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuing the ongoing example of books, authors and publishers, let''s create
    a simple view that lets users search our book database by title. Generally, there
    are two parts to developing a form: the HTML user interface and the backend view
    code that processes the submitted data. The first part is easy; let''s just set
    up a view that displays a search form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you learned in [Chapter 3](ch03.xhtml "Chapter 3. Templates"), *Templates*,
    this view can live anywhere on your Python path. For sake of argument, put it
    in `books/views.py`. The accompanying template, `search_form.html`, could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file to your `mysite/templates` directory you created in [Chapter
    3](ch03.xhtml "Chapter 3. Templates"), *Templates*, or you can create a new folder
    `books/templates`. Just make sure you have `''APP_DIRS''` in your settings file
    set to `True`. The URLpattern in `urls.py` could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '(Note that we''re importing the `views` module directly, instead of something
    like `from mysite.views import search_form`, because the former is less verbose.
    We''ll cover this importing approach in more detail in [Chapter 7](ch07.xhtml
    "Chapter 7. Advanced Views and URLconfs"), *Advanced Views and Urlconfs*). Now,
    if you run the development server and visit `http://127.0.0.1:8000/search-form/`,
    you''ll see the search interface. Simple enough. Try submitting the form, though,
    and you''ll get a Django 404 error. The form points to the URL `/search/`, which
    hasn''t yet been implemented. Let''s fix that with a second view function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment, this merely displays the user''s search term, so we can make
    sure the data is being submitted to Django properly, and so you can get a feel
    for how the search term flows through the system. In short:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML `<form>` defines a variable `q`. When it's submitted, the value of
    `q` is sent via `GET` (`method="get"`) to the URL `/search/`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django view that handles the URL `/search/` (`search()`) has access to the
    `q` value in `request.GET`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important thing to point out here is that we explicitly check that `''q''`
    exists in `request.GET`. As I pointed out in the `request.META` section preceding,
    you shouldn''t trust anything submitted by users or even assume that they''ve
    submitted anything in the first place. If we didn''t add this check, any submission
    of an empty form would raise `KeyError` in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Query string parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because `GET` data is passed in the query string (for example, `/search/?q=django`),
    you can use `request.GET` to access query string variables. In [Chapter 2](ch02.xhtml
    "Chapter 2. Views and URLconfs"), *Views and Urlconfs*, introduction of Django's
    URLconf system, I compared Django's pretty URLs to more traditional PHP/Java URLs
    such as `/time/plus?hours=3` and said I'd show you how to do the latter in [Chapter
    6](ch06.xhtml "Chapter 6. Forms"), *Forms*. Now you know how to access query string
    parameters in your views (like `hours=3` in this example)-use `request.GET`.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` data works the same way as `GET` data-just use `request.POST` instead
    of `request.GET`. What''s the difference between `GET` and `POST`? Use `GET` when
    the act of submitting the form is just a request to get data. Use `POST` whenever
    the act of submitting the form will have some side effect-*changing* data, or
    sending an e-mail, or something else that''s beyond simple *display* of data.
    In our book search example, we''re using `GET` because the query doesn''t change
    any data on our server. (See the http://www.w3.org/2001/tag/doc/whenToUseGet.html
    site) if you want to learn more about `GET` and `POST`.) Now that we''ve verified
    `request.GET` is being passed in properly, let''s hook the user''s search query
    into our book database (again, in `views.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of notes on what we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from checking that `'q'` exists in `request.GET`, we also make sure that
    `request.GET['q']` is a non-empty value before passing it to the database query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're using `Book.objects.filter(title__icontains=q)` to query our book table
    for all books whose title includes the given submission. The `icontains` is a
    lookup type (as explained in [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*,
    and [Appendix B](apb.xhtml "Appendix B. Database API Reference"), *Database API
    Reference*), and the statement can be roughly translated as "Get the books whose
    title contains `q`, without being case-sensitive."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very simple way to do a book search. We wouldn't recommend using a
    simple `icontains` query on a large production database, as it can be slow. (In
    the real world, you'd want to use a custom search system of some sort. Search
    the web for *open-source full-text search* to get an idea of the possibilities.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We pass `books`, a list of `Book` objects, to the template. The `search_results.html`
    file might include something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note usage of the `pluralize` template filter, which outputs an "s" if appropriate,
    based on the number of books found.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our simple form-handling example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in previous chapters, I've shown you the simplest thing that could possibly
    work. Now I'll point out some problems and show you how to improve it. First,
    our `search()` view's handling of an empty query is poor-we're just displaying
    a **Please submit a search term.** message, requiring the user to hit the browser's
    back button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is horrid and unprofessional, and if you ever actually implement something
    like this in the wild, your Django privileges will be revoked. It would be much
    better to redisplay the form, with an error preceding to it, so that the user
    can try again immediately. The easiest way to do that would be to render the template
    again, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '(Note that I''ve included `search_form()` here so you can see both views in
    one place.) Here, we''ve improved `search()` to render the `search_form.html`
    template again, if the query is empty. And because we need to display an error
    message in that template, we pass a template variable. Now we can edit `search_form.html`
    to check for the `error` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can still use this template from our original view, `search_form()`, because
    `search_form()` doesn''t pass `error` to the template-so the error message won''t
    show up in that case. With this change in place, it''s a better application, but
    it now begs the question: is a dedicated `search_form()` view really necessary?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it stands, a request to the URL `/search/` (without any `GET` parameters)
    will display the empty form (but with an error). We can remove the `search_form()`
    view, along with its associated URLpattern, as long as we change `search()` to
    hide the error message when somebody visits `/search/` with no `GET` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this updated view, if a user visits `/search/` with no `GET` parameters,
    they'll see the search form with no error message. If a user submits the form
    with an empty value for `'q'`, they'll see the search form with an error message.
    And, finally, if a user submits the form with a non-empty value for `'q'`, they'll
    see the search results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make one final improvement to this application, to remove a bit of redundancy.
    Now that we''ve rolled the two views and URLs into one and `/search/` handles
    both search-form display and result display, the HTML `<form>` in `search_form.html`
    doesn''t have to hard-code a URL. Instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `action=""` means *Submit the form to the same URL as the current page.*
    With this change in place, you won't have to remember to change the `action` if
    you ever hook the `search()` view to another URL.
  prefs: []
  type: TYPE_NORMAL
- en: Simple validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our search example is still reasonably simple, particularly in terms of its
    data validation; we''re merely checking to make sure the search query isn''t empty.
    Many HTML forms include a level of validation that''s more complex than making
    sure the value is non-empty. We''ve all seen the error messages on websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please enter a valid e-mail address. ''foo'' is not an e-mail address.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Please enter a valid five-digit U.S. ZIP code. ''123'' is not a ZIP code.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Please enter a valid date in the format YYYY-MM-DD.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Please enter a password that is at least 8 characters long and contains at
    least one number.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's tweak our `search()` view so that it validates that the search term is
    less than or equal to 20 characters long. (For sake of example, let's say anything
    longer than that might make the query too slow.) How might we do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest possible thing would be to embed the logic directly in the view,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try submitting a search query greater than 20 characters long,
    it won''t let you search; you''ll get an error message. But that error message
    in `search_form.html` currently says `"Please submit a search term".`-so we''ll
    have to change it to be accurate for both cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's something ugly about this. Our one-size-fits-all error message is potentially
    confusing. Why should the error message for an empty form submission mention anything
    about a 20-character limit?
  prefs: []
  type: TYPE_NORMAL
- en: 'Error messages should be specific, unambiguous and not confusing. The problem
    is in the fact that we''re using a simple Boolean value for `error`, whereas we
    should be using a list of error message strings. Here''s how we might fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need make a small tweak to the `search_form.html` template to reflect
    that it''s now passed an `errors` list instead of an `error` Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Making a contact form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we iterated over the book search form example several times and improved
    it nicely, it''s still fundamentally simple: just a single field, `''q''`. As
    forms get more complex, we have to repeat the preceding steps over and over again
    for each form field we use. This introduces a lot of cruft and a lot of opportunities
    for human error. Lucky for us, the Django developers thought of this and built
    into Django a higher-level library that handles form-and validation-related tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Your first form class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django comes with a form library, called `django.forms`, that handles many of
    the issues we've been exploring this chapter-from HTML form display to validation.
    Let's dive in and rework our contact form application using the Django forms framework.
  prefs: []
  type: TYPE_NORMAL
- en: The primary way to use the forms framework is to define a `Form` class for each
    HTML `<form>` you're dealing with. In our case, we only have one `<form>`, so
    we'll have one `Form` class. This class can live anywhere you want-including directly
    in your `views.py` file-but community convention is to keep `Form` classes in
    a separate file called `forms.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create this file in the same directory as your `mysite/views.py`, and enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty intuitive, and it''s similar to Django''s model syntax. Each
    field in the form is represented by a type of `Field` class-`CharField` and `EmailField`
    are the only types of fields used here-as attributes of a `Form` class. Each field
    is required by default, so to make `email` optional, we specify `required=False`.
    Let''s hop into the Python interactive interpreter and see what this class can
    do. The first thing it can do is display itself as HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Django adds a label to each field, along with `<label>` tags for accessibility.
    The idea is to make the default behavior as optimal as possible. This default
    output is in the format of an HTML `<table>`, but there are a few other built-in
    outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the opening and closing `<table>`, `<ul>`, and `<form>` tags aren''t
    included in the output, so that you can add any additional rows and customization
    if necessary. These methods are just shortcuts for the common case of "display
    the entire form." You can also display the HTML for a particular field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The second thing `Form` objects can do is validate data. To validate data,
    create a new `Form` object and pass it a dictionary of data that maps field names
    to data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve associated data with a `Form` instance, you''ve created a **bound**
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `is_valid()` method on any bound `Form` to find out whether its data
    is valid. We''ve passed a valid value for each field, so the `Form` in its entirety
    is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t pass the `email` field, it''s still valid, because we''ve specified
    `required=False` for that field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if we leave off either `subject` or `message`, the `Form` is no longer
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can drill down to get field-specific error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Each bound `Form` instance has an `errors` attribute that gives you a dictionary
    mapping field names to error-message lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for `Form` instances whose data has been found to be valid, a `cleaned_data`
    attribute is available. This is a dictionary of the submitted data, "cleaned up".
    Django''s forms framework not only validates data; it cleans it up by converting
    values to the appropriate Python types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our contact form only deals with strings, which are "cleaned" into string objects-but
    if we were to use an `IntegerField` or `DateField`, the forms framework would
    ensure that `cleaned_data` used proper Python integers or `datetime.date` objects
    for the given fields.
  prefs: []
  type: TYPE_NORMAL
- en: Tying form objects into views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our contact form is not much good to us unless we have some way of displaying
    it to the user. To do this, we need to first update our `mysite/views`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to create our contact form (save this to `mysite/templates`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we need to change our `urls.py` to display our contact form at
    `/contact/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since we're creating a `POST` form (which can have the effect of modifying data),
    we need to worry about Cross Site Request Forgeries. Thankfully, you don't have
    to worry too hard, because Django comes with a very easy-to-use system for protecting
    against it. In short, all `POST` forms that are targeted at internal URLs should
    use the `{% csrf_token %}` template tag. More details about
  prefs: []
  type: TYPE_NORMAL
- en: '`{% csrf_token %}` can be found in [Chapter 19](ch19.xhtml "Chapter 19. Security
    in Django"), *Security in Django*.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this locally. Load the form, submit it with none of the fields filled
    out, submit it with an invalid e-mail address, then finally submit it with valid
    data. (Of course, unless you have configured a mail-server, you will get a `ConnectionRefusedError`
    when `send_mail()` is called.)
  prefs: []
  type: TYPE_NORMAL
- en: Changing how fields are rendered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the first thing you''ll notice when you render this form locally is
    that the `message` field is displayed as an `<input type="text">`, and it ought
    to be a `<textarea>`. We can fix that by setting the field''s widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The forms framework separates out the presentation logic for each field into
    a set of widgets. Each field type has a default widget, but you can easily override
    the default, or provide a custom widget of your own. Think of the `Field` classes
    as representing **validation logic**, while widgets represent **presentation logic**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a maximum length
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common validation needs is to check that a field is of a certain
    size. For good measure, we should improve our `ContactForm` to limit the `subject`
    to 100 characters. To do that, just supply a `max_length` to the `CharField`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An optional `min_length` argument is also available.
  prefs: []
  type: TYPE_NORMAL
- en: Setting initial values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an improvement to this form, let''s add an initial value for the `subject`
    field: `I love your site!` (A little power of suggestion can''t hurt.) To do this,
    we can use the `initial` argument when we create a `Form` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `subject` field will be displayed prepopulated with that kind statement.
    Note that there is a difference between passing initial data and passing data
    that binds the form. The biggest difference is that if you're just passing initial
    data, then the form will be unbound, which means it won't have any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine we''ve launched our feedback form, and the e-mails have started tumbling
    in. There''s just one problem: some of the submitted messages are just one or
    two words, which isn''t long enough for us to make sense of. We decide to adopt
    a new validation policy: four words or more, please.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to hook custom validation into a Django form. If
    our rule is something we will reuse again and again, we can create a custom field
    type. Most custom validations are one-off affairs, though, and can be tied directly
    to the `Form` class. We want additional validation on the `message` field, so
    we add a `clean_message()` method to our `Form` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Django's form system automatically looks for any method whose name starts with
    `clean_` and ends with the name of a field. If any such method exists, it's called
    during validation. Specifically, the `clean_message()` method will be called after
    the default validation logic for a given field (in this case, the validation logic
    for a required `CharField`).
  prefs: []
  type: TYPE_NORMAL
- en: Because the field data has already been partially processed, we pull it out
    of `self.cleaned_data`. Also, we don't have to worry about checking that the value
    exists and is non-empty; that's done by the default validator. We naively use
    a combination of `len()` and `split()` to count the number of words. If the user
    has entered too few words, we raise a `forms.ValidationError`.
  prefs: []
  type: TYPE_NORMAL
- en: The string attached to this exception will be displayed to the user as an item
    in the error list. It's important that we explicitly return the cleaned value
    for the field at the end of the method. This allows us to modify the value (or
    convert it to a different Python type) within our custom validation method. If
    we forget the return statement, then `None` will be returned, and the original
    value will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the labels on Django''s auto-generated form HTML are created by
    replacing underscores with spaces and capitalizing the first letter-so the label
    for the `email` field is "`Email`". (Sound familiar? It''s the same simple algorithm
    that Django''s models use to calculate default `verbose_name` values for fields.
    We covered this in [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*). But,
    as with Django''s models, we can customize the label for a given field. Just use
    `label`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Customizing form design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `contact_form.html` template uses `{{ form.as_table }}` to display the form,
    but we can display the form in other ways to get more granular control over display.
    The quickest way to customize forms' presentation is with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error lists, in particular, could do with some visual enhancement, and the
    auto-generated error lists use `<ul class="errorlist">` precisely so that you
    can target them with CSS. The following CSS really makes our errors stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: While it's convenient to have our form's HTML generated for us, in many cases
    you'll want to override the default rendering. `{{ form.as_table }}` and friends
    are useful shortcuts while you develop your application, but everything about
    the way a form is displayed can be overridden, mostly within the template itself,
    and you'll probably find yourself doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Each field's widget (`<input type="text">`, `<select>`, `<textarea>`, and so
    on.) can be rendered individually by accessing `{{ form.fieldname }}` in the template,
    and any errors associated with a field are available as `{{ form.fieldname.errors
    }}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we can construct a custom template for our contact form
    with the following template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`{{ form.message.errors }}` displays a `<ul class="errorlist">` if errors are
    present and a blank string if the field is valid (or the form is unbound). We
    can also treat `form.message.errors` as a Boolean or even iterate over it as a
    list. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the case of validation errors, this will add an "errors" class to the containing
    `<div>` and display the list of errors in an unordered list.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concludes the introductory material in this book-the so-called
    *core curriculum* The next section of the book, [Chapters 7](ch07.xhtml "Chapter 7. Advanced
    Views and URLconfs"), *Advanced Views and URLconfs*, to [Chapter 13](ch13.xhtml
    "Chapter 13. Deploying Django"), *Deploying Django*, goes into more detail about
    advanced Django usage, including how to deploy a Django application ([Chapter
    13](ch13.xhtml "Chapter 13. Deploying Django"), *Deploying Django*). After these
    first seven chapters, you should know enough to start writing your own Django
    projects. The rest of the material in this book will help fill in the missing
    pieces as you need them. We'll start in [Chapters 7](ch07.xhtml "Chapter 7. Advanced
    Views and URLconfs"), *Advanced Views and URLconfs*, by doubling back and taking
    a closer look at views and URLconfs (introduced first in [Chapter 2](ch02.xhtml
    "Chapter 2. Views and URLconfs"), *Views and URLconfs*).
  prefs: []
  type: TYPE_NORMAL
