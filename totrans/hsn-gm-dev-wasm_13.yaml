- en: Game Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have some physics in our game. Each of our ships has a velocity and
    an acceleration. They also obey at least some of Newton's laws and conserve momentum.
    All of this was added earlier without much fanfare. Physics in computer games
    dates back to the original computer game, *Space War!*, which is the game that
    inspired the one we are currently writing. In the original version of *Space War!,*
    the spaceships conserved momentum, as we currently do in our game. A black hole
    gravitationally attracted the ships to the center of the play area. Before creating
    the classic game *Pong*, Nolan Bushnell created an arcade clone of *Space War!*,
    called *Computer Space*. *Computer Space* was not a hit like *Pong*, and Nolan
    Bushnell blamed Newton's laws and the public's lack of understanding of basic
    physics as some of the reasons for the game's commercial failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to The Ultimate History of Video Games: from Pong to Pokemon and
    Beyond, by Steven Kent, "Computer Space obeys the first law—maintenance of momentum.
    (Bushnell is probably referring to Sir Isaac Newton''s first law—objects maintain
    constant velocity unless acted upon by an external force.) And so that was really
    hard for people who didn''t understand that."'
  prefs: []
  type: TYPE_NORMAL
- en: – Nolan Bushnell
  prefs: []
  type: TYPE_NORMAL
- en: Physics is common in games, but far from universal. The kind of physics required
    by a game is highly dependent on the kind of game it is. There is a 3D physics
    library called *Bullet Physics* that has been ported, but, because it is 3D, Bullet
    is a rather large library for the kinds of physics we will be using in this game.
    Instead, we will integrate some simple Newtonian physics into our game for some
    extra flavor. We already have a simple implementation of Newton's first law in
    our game. When we accelerate our spaceship, it moves in the same direction until
    we either decelerate it by using the down arrow, or we *flip and burn* by turning
    our ship around and accelerating in the opposite direction of our current velocity.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to include several images and audio files in your build to make
    this project work. Make sure that you include the `/Chapter13/sprites/` folder
    as well as the `/Chapter13/audio/` folder from the project's GitHub. If you haven't
    yet downloaded the GitHub project, you can get it online at [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be applying the following aspects of physics:'
  prefs: []
  type: TYPE_NORMAL
- en: Elastic collisions between asteroids, projectiles, and spaceships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our spaceships shoot, there should be a recoil (Newton's third law).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gravity from the star should attract the player's spaceship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newton's third law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Newton's third law is commonly stated as, *For every action, there is an equal
    and opposite reaction*. What this means is that, when object *A* exerts a force
    on object *B*, object *B* exerts that same force right back on object *A*. An
    example of this is firing a bullet from a gun. When a human holding a gun fires
    a bullet, the gun recoils with the same force of the bullet leaving the gun. That
    may sound counter-intuitive, because the bullet can kill a human, but the gun's
    recoil does not kill the human firing the gun. That is because the gun is significantly
    larger than the bullet, and Newton's first law states that *F = ma*, or force
    equals mass times acceleration. In other words, if the gun is 50 times larger
    than the bullet, then the same force will only make it accelerate to 1/50 the
    speed. We will be modifying our spaceship so that, whenever it shoots a projectile,
    it accelerates in the opposite direction of the shot based on the relative masses
    of the spaceship and the projectile. This will give our ship's cannon a recoil.
  prefs: []
  type: TYPE_NORMAL
- en: Adding gravity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we add the recoil to our spaceship's cannon, I would also like to add
    a gravitational effect on the spaceships in our game that will draw the ships
    toward the star when they are within a certain distance of that star. The gravitational
    force decreases with the square of the distance between the two objects. That
    is convenient because it means that we can calculate the gravitational effect
    with the `MagSQ` function, which runs quite a bit faster than the `Magnitude`
    function. I have chosen not to add a gravitational effect on the projectiles and
    asteroids out of personal preference. It will not be hard to add that effect if
    you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Improving collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to improve the collisions between our spaceship and the asteroids
    and projectiles in the game. To simplify things, we will use elastic collisions.
    An elastic collision is a collision that preserves all of the kinetic energy.
    In reality, collisions always lose some energy to heat or friction, even ones
    that are close to elastic collisions, such as billiard balls. However, making
    our collisions perfectly elastic simplifies the math. In games, simpler math usually
    means faster algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on elastic collisions, Wikipedia has an excellent article
    ([http](https://en.wikipedia.org/wiki/Elastic_collision)[s://en.wikipedia.org/wiki/Elastic_collision](https://en.wikipedia.org/wiki/Elastic_collision))
    that discusses the math we will use to implement our elastic collision function.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to make some changes to our game objects. We will
    need to add mass and elastic collisions to our `collider` class. Our star should
    be able to generate gravity and attract the player and enemy spaceship with a
    force that decreases based on the square of the distance. We will need to modify
    our collisions function to add elastic collisions between our spaceships, asteroids,
    and the projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the game.hpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get physics into our game, we will need to modify several class definitions
    and add new `#define` macros. Let''s start by updating our `game.hpp` file. The
    first thing we need to add is `#define` in order to set up a constant value for
    our star''s mass. I want to have a large constant value for the star mass that
    we will check against in our `ElasticCollision` function. If the mass of either
    object in our elastic collision is the same value as `STAR_MASS`, we do not want
    to accelerate that object. In reality, if you were to throw a rock into the sun,
    you would accelerate the sun a tiny, tiny amount in the direction you threw the
    rock. This amount would be so small relative to the sun that it would be undetectable.
    We will have a fixed value for the star''s mass where any objects with a mass
    that size will not accelerate when hit by any objects in our game. To do this,
    we will need to add the following `#define`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the `#define`, we will need to modify our `Collider` class, giving
    it a new `ElasticCollision` function. This function will take in a second `Collider`
    object and use the velocity and masses of those two objects to determine what
    their new velocities will be. We will also need to add a mass attribute that we
    will name `m_Mass`. Finally, we need to move two attributes into our `Collider`
    class that was previously in the child classes of `Collider`. These variables
    are the 2D `m_Direction` and `m_Velocity` vectors because our elastic collision
    function will need this data to calculate the new velocities. This is what the
    new version of the `Collider` class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The four lines we added are near the center of this new version of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding `m_Direction` and `m_Velocity` to our `Collider` class, we need
    to remove `m_Velocity` from three of the child classes where we had that code
    in previous versions of our game. We need to remove those attributes from the
    `Asteroid`, `Ship`, and `Projectile` classes. Here are the two lines we need to
    remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we have the `Asteroid` class after you have
    removed those two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the `Ship` class will look like after you have removed those two
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is what the `Projectile` class will look like after you have
    removed those two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last class we must change is our `Star` class. The `Star` class is now
    going to be able to attract the spaceships in our game gravitationally. To do
    this, we will be adding a constant attribute that defines the maximum range of
    our gravitational force. In reality, gravity extends on forever, but for our game,
    we do not want the gravity to affect our spaceships when the star is off-screen
    (or at least very far off-screen). Because of this, we are going to limit the
    distance of the gravitational effect to 500 pixels. We will also add a new function
    to our class called `ShipGravity`. We will be passing a `Ship` object into this
    function, and the function will modify the velocity of the ship based on the squared
    distance to the `Star` object. This is what the new version of the `Star` class
    definition will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Changing collider.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next file we will change is the `collider.cpp` file, which holds the functions
    we declared in our `Collider` class definition. The only change will be the addition
    of a single function, `ElasticCollision`. This function modifies the position
    and velocity of our two colliders based on the mass and the starting velocities
    of those objects. This is what the `ElasticCollision` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing the function does is check to see whether either collider has
    the mass of a star. If either is a star, we do not change their velocities. The
    star''s velocity does not change, because it is too massive to move, and the object
    colliding with the star does not change its mass because it is destroyed in the
    collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the mass check, we need to adjust the position of the colliders so that
    they are not overlapping. Overlap can happen because the position of our objects
    changes every frame and is not continuous. Because of this, we need to move the
    position of one of our objects so that it is barely touching the other object.
    A more accurate way to do this would have been to modify the position of both
    objects by half the amount we modify the one object, but in different directions.
    For simplicity, we will only be changing the position of one of the colliders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will modify the velocities of the two collider objects using
    the masses and the starting velocities of those two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about the formula we used to calculate the new velocities,
    check out the Wikipedia article regarding elastic collisions at [https://en.wikipedia.org/wiki/Elastic_collision](https://en.wikipedia.org/wiki/Elastic_collision).
  prefs: []
  type: TYPE_NORMAL
- en: Changes to star.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `star.cpp` file, we will need to modify our `Star` class''s constructor
    function, as well as its `Move` function. We will also need to add a new function
    called `ShipGravity`. The first thing we will do is add the following line somewhere
    in our `Star` class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will need to define our `ShipGravity` function. The following
    code defines that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates a `dist_vec` vector, which is a vector representing
    the distance between the star''s position and the ship''s position. The second
    line gets the squared distance between the star and the ship. After that, we have
    an `if` block that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `if` block is checking the square distance against the maximum distance
    where gravity affects the ship, which we defined in the `c_MaxGravityDistSQ` constant.
    Because gravity decreases with the square of the distance between the star and
    our ship, we compute the scalar force by dividing the maximum gravitation distance
    by 50 times the distance squared to our spaceship. The value of 50 was picked
    rather arbitrarily and was the result of me playing around with the numbers until
    the force of gravity felt right to me. You may choose a different value if you
    would prefer your gravitational force to be different. You may also choose to
    modify the maximum gravitational distance by changing the value of `c_MaxGravityDistSQ`
    that we defined in `game.hpp`. The following lines are used to turn our scalar
    force value into a vector force value that is pointing from our ship to our star:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have converted `dist_vec` into a force vector that points in the
    direction of our star, we can add that force vector to our ship''s velocity to
    create the gravitational effect on our ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The final change we need to make is to the `Move` function. We will need to
    add two calls to the `ShipGravity` function; one call to create the gravitational
    effect on the player, and a second call to create the gravitational effect on
    the enemy spaceship. Here is the new version of the `Move` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines are new. Make sure you add these two lines to the `Move`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Changing the main.cpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After updating our `star.cpp` file, we need to change the `main.cpp` file to
    incorporate our elastic collisions. We need to make all of these changes to the
    `collisions()` function. Here is the new version of `collisions` in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first part of this function, we loop over the projectiles and check
    to see whether they hit an asteroid or a ship. If the projectile hits an asteroid
    or a ship when that ship has its shields up, we want to create an elastic collision
    with the projectile. The projectile will still be destroyed, but the ship or asteroid
    will have a modified velocity based on the collision. Here is the code for the
    `projectile` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first series of checks this loop performs is against every asteroid. It
    looks for an active asteroid with which it currently collides. If those conditions
    are true, the first thing it does is call the `ElasticCollision` function on the
    asteroid, passing in the projectile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is the same as the earlier version, but with the addition of this
    call to `ElasticCollision`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in our loop through each active projectile, we will add a call to the
    `ElasticCollision` function if a projectile strikes your player''s spaceship while
    its shields are up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will do the same for an enemy spaceship struck by a projectile while its
    shields are up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After looping over all of the active projectiles, the `collisions` function
    loops over all of the asteroids looking for a collision between an asteroid and
    one of the ships. If the ship does not have its shields activated, the ship is
    destroyed. We do not make any modifications to this part of the code. In previous
    versions of our code, if the ship did have its shields up, we destroyed the asteroid.
    Now, we will have an elastic collision, which will cause the spaceship and the
    asteroid to bounce off one another. This is what this `asteroid` loop looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are now two calls to `ElasticCollision`. One of the calls occurs when
    the player ship collides with an asteroid and the player ship has its shields
    up. The other occurs when the enemy ship collides with an asteroid, and the enemy
    ship has its shields up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change we must make to our `collisions()` function is the addition
    of a new double `asteroid` loop that will loop through all our asteroids looking
    for collisions between two of them. That creates a fun effect where asteroids
    bounce off one another like billiard balls. If there is a collision detected between
    two of the asteroids, we call `ElasticCollision`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Changes to asteroid.cpp and projectile.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to make a small addition to both `asteroid.cpp` and `projectile.cpp`.
    We have added a new attribute called `m_Mass` to the `Collider` class, so all
    classes derived from `Collider` inherit this attribute. The `m_Mass` attribute
    is used by our `ElasticCollision` function to determine how these objects will
    move after an elastic collision. The ratio between the mass of a spaceship and
    the mass of a projectile will be used to calculate the amount of recoil that occurs
    when the spaceship shoots a projectile. The first modification is to the `Projectile`
    class constructor. Here is the new version of that constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The only modification is the final line, where we set `m_Mass` to `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next constructor that needs to be modified is in the `asteroid.cpp` file.
    We need to modify the `Asteroid` class constructor. Here is the new version of
    the `Asteroid` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the only line we will add is the final line where we set `m_Mass`
    to `100.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Changes to the ship.cpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first change to the `ship.cpp` file will be to the `Ship` constructor.
    This is a simple change that we need to make to the end of the constructor function,
    where we will be setting the mass of the ship to `50.0`. Here is the new version
    of the `Ship` class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The only line that was changed was the very last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to change the `Shoot` function to add a recoil. A few lines
    will be added to modify the velocity of the ship by adding a vector that is in
    the opposite direction to where the ship is facing, and has a magnitude based
    on the velocity and relative mass of the projectile fired. Here is the new `Shoot`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the two lines that we are adding to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the physics.html file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have added physics, it is time to compile our code. We can build
    the `physics.html` file with the following `em++` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot may look similar to earlier versions, but when you
    fire your projectiles, the ship will accelerate backward. If you collide with
    an asteroid when your shields are on, you will bounce off them like a billiard
    ball. Get too close to the sun, and the gravity will begin to attract your ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10269f25-3eed-46f3-9771-a8ed315e3005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: physics.html screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the history of physics in computer games, and
    how that history dates back to the very first computer game, *SpaceWar!*. We talked
    about the physics that we already have in our game, which includes the conservation
    of momentum. We briefly discussed Newton's third law and how it applies to games,
    and we then added more Newtonian physics to our game by using the third law. We
    added a gravitational field to our star and had it attract the spaceships in our
    game with a force that decreases with the square of the distance between the two
    objects. Finally, we added elastic collisions between our spaceships, projectiles,
    and asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add a **user interface** (**UI**) to our game.
    We will also break the game up into multiple screens and add a mouse interface.
  prefs: []
  type: TYPE_NORMAL
