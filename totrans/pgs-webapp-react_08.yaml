- en: Using a Service Worker to Send Push Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will complete our application's process for sending push
    notifications. The implementation is a little complicated; it requires many moving
    pieces to get things working (in my experience, this is true of any push notifications
    implementation, on mobile or web). The exciting part is that we get to interact
    with a lot of new areas of knowledge, such as **Device tokens** and **Cloud functions**.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, let's take a minute to outline the process for setting up push
    notifications. As of now, we have our messaging service worker up and running.
    This service worker will sit there and wait to be called with a new notification.
    Once that happens, it'll handle everything to do with displaying that notification,
    so we don't have to worry about that (at least).
  prefs: []
  type: TYPE_NORMAL
- en: What is up to us is sending that message to the service worker. Let's say that
    we have 1,000 users for our application, each with one unique device. Each device
    has a unique token, which identifies it to Firebase. We need to keep track of
    all of those tokens, because when we want to send a notification, we need to tell
    Firebase exactly what devices to send it to.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's step one--set up and maintain a database table of all tokens for
    devices using our app. As we'll see, that also necessarily involves asking the
    user whether they want notifications in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our tokens saved, we can then tell Firebase to listen for a new
    message in the database, and then send a notification to all devices (based on
    the tokens) with the message details. As a small additional complication, we have
    to ensure that we don't send the notification to the user who created the message.
  prefs: []
  type: TYPE_NORMAL
- en: This stage (telling Firebase to send a notification) actually takes place outside
    of our application. It takes place in the mythical "Cloud", where we'll host a
    function to take care of this process; more on that later.
  prefs: []
  type: TYPE_NORMAL
- en: Our approach to this rather involved piece of engineering will be to approach
    it slowly, one piece at a time. Ensure that you follow the code examples carefully;
    the nature of notifications means we won’t be able to fully test our implementation
    until it is complete, so do your best to avoid small errors along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permission to show notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking and saving user tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cloud Functions to send notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright, let’s do it!
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the preceding introduction explains, we have a lot of functionality to create
    in this chapter. In order to keep it all in one place, without cluttering up our
    `App.js`, we will create a separate JavaScript class to manage everything to do
    with notifications. This is a pattern I really like with React, to extract functionality
    not attached to any one component. In our `src/` folder, next to our `components`
    folder, let's create a folder called `resources`, and within that, a file called
    `NotificationResource.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic outline of our class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create a JavaScript class and export it.
  prefs: []
  type: TYPE_NORMAL
- en: For those unfamiliar with JavaScript classes (especially for those familiar
    with classes in other languages), I encourage you to read the MDN article explaining
    the basics, at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import it in our `App.js` before we forget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When our app starts up, we want to ask the user for permission to send them
    notifications. Note that Firebase remembers whether the user has already accepted
    or denied our request, so we won't be bothering them with a popup every time,
    only if they haven't been asked before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''ll approach this process:'
  prefs: []
  type: TYPE_NORMAL
- en: When our app mounts, we'll create a new instance of the `NotificationResource`
    class, passing it the Firebase messaging library (we pass this in to save us from
    having to import it into the `NotificationResource.js` file, since we already
    have access to it in `App.js`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `NotificationResource` class is first instantiated, we'll immediately
    ask the user for permission, using the Firebase messaging library passed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If these steps are clear to you, I encourage you to try implementing them on
    your own first. If you're totally confused about how we will do this, don't worry,
    we'll go through it all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s start with our App''s `componentDidMount`. This is where we want
    to create the instance of our `NotificationResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We're setting the `NotificationResource` instance to be a property of `App`;
    this will allow us to access it elsewhere within `App.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said earlier, we also want to pass in the Firebase messaging library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every JavaScript class automatically has a `constructor` method that is called
    when an instance is created. That is what we're called when we say new `NotificationResource()`.
    Whatever we put inside those brackets is passed as an argument to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s jump back over to `NotificationResource.js` and set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you start up your app, you should see `"Instantiated!"` in the console as
    soon as `App` mounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to use our `messaging` library to access the user for permission
    to send them notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We do the same thing we did with the `NotificationResource` in `App` with the
    `messaging` library, that is, save it as a property of our resource so that we
    can use it elsewhere. Then, we tap into the `requestPermission` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to our app, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Allow, and you should see Permission granted in the console.
  prefs: []
  type: TYPE_NORMAL
- en: If you've previously built a personal project using `localhost:8080` and allowed
    notifications, you won't see this popup. You can forget your previous preference
    by clicking on the icon to the left of the URL in the preceding screenshot, and
    resetting notifications to Ask.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have permission to start bugging our users, we will start keeping
    track of all their devices, via tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **token** is a unique identifier for your user's device. It helps Firebase
    figure out where to send push notifications. In order for our notifications to
    be sent properly, we need to keep a record of all current device tokens in our
    database, and ensure that it's up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the token of our user''s device via the Firebase `messaging`
    library. Two methods in particular will be useful: `onTokenRefresh` and `getToken`.
    Both have fairly self-explanatory names, so we’ll dive right into the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You'll see a very long string of numbers and letters when your app refreshes.
    This is your device's identity. We need to save this to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the token changes `firebase.messaging().onTokenRefresh` is called.
    The token can be deleted by our application, or when the user clears browser data,
    in which case a new one will be generated. When that happens, we'll need to overwrite
    the old token in our database. The key part is overwriting; if we don't delete
    the old token, we'll end up wasting Firebase’s time by sending to devices that
    don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have four steps to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: When the token changes, get the new token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for an existing token in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an old one exists, replace it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, add the new token to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a bunch of intermediary tasks we'll have to complete in order to finish
    this checklist, but let's just dive in with this rough plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add four functions to our `NotificationResource`: `setupTokenRefresh`,
    `saveTokenToServer`, `findExistingToken`, and `registerToken`. You can see how
    the last two accord with the last two steps in our checklist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `setupTokenRefresh`. We will call this from our constructor,
    because it will be in charge of registering the listener for token changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This pattern should be familiar after all the "on" listeners we've configured
    with Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create `saveTokenToServer`, and call it from `setupTokenRefresh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now we can move through those comments one by one. We already know how
    to get the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the next step, look for the existing token; we don't currently have access
    to the previous tokens saved in our database (okay, there aren’t any yet, but
    there will be).
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to create a table in our database to save our tokens. We’ll call
    it `fcmTokens` for ease. It doesn't exist yet, but it will as soon as we send
    some data to it. That's the beauty of the Firebase data--you can send data to
    a non-existent table, and it will be created and populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did for messages in `App.js`, let''s add a listener for values from
    the `/fcmTokens` table inside the constructor of `NotificationResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll note that we now expect a database instance to be passed into the constructor.
    Let''s hop back over to `App.js` to set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Okay, this is perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you `console.log` out `snapshot.val()` inside of the database listener,
    it''ll be null, since there are no values in our `/fcmTokens` table. Let''s work
    on registering one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the tokens are loaded, we can check for an existing one. If the tokens are
    not loaded, do nothing. This may seem odd, but we want to ensure that we don't
    create duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we find an existing token? Well, in our constructor, we saved the result
    of loading the token values in the database to `this.allTokens`. We will simply
    loop through them and see whether any of them match the `res` variable generated
    from `getToken`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The important part of this method is that `tokenToSave` will be a string (the
    random assortment of numbers and letters seen earlier), and `this.allTokens` will
    be a collection of token objects loaded from the database and hence the `this.allTokens[tokenObject].token`
    business.
  prefs: []
  type: TYPE_NORMAL
- en: '`findExistingToken` will thus either return the key of the token object that
    matches, or false. From there, we can either update that existing token object,
    or create a new one. We’ll see why it''s important to return the key (rather than
    the object itself) when we try to update the token.'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching a user to the token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on to covering the two cases though, let’s take a step back and
    think about how our push notifications will work, because there’s an important
    caveat we need to cover.
  prefs: []
  type: TYPE_NORMAL
- en: When a user sends a message, we want to notify every user, except the user who
    created the message (that will be infuriating), so we need some way to send a
    notification to every token in our database, except for the ones that belong to
    the user who sent the message.
  prefs: []
  type: TYPE_NORMAL
- en: How will we be able to prevent that? How can we match a user's message with
    a user's token?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we have access to the user ID in the message object (that is, we always
    save the ID along with the message content). What if we did something similar
    with the token, and saved the user ID along with it, so we can be sure to identify
    which user belongs to which device?
  prefs: []
  type: TYPE_NORMAL
- en: This seems like a pretty simple solution, but that means we need access to the
    current user’s ID inside `NotificationResource`. Let's do that right away, and
    then get back to writing and updating tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the user inside NotificationResource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have a method to handle user changes inside `App.js`--our old friend,
    `onAuthStateChanged`. Let''s hook in to that, and use that to call a method inside
    `NotificationResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside `NotificationResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Incidentally, this helps us solve another problem with tokens. As noted earlier,
    `onTokenRefresh` is called when a new token is generated, either because the user
    deleted browser data or because the web app deleted the previous token. However,
    if we''re saving the user ID along with the token, we need to ensure that we update
    that ID when the user changes, so we''ll have to call our `saveTokenToServer`
    method every time the user changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now we can go back to our `if`-`else` statement inside `saveTokenToServer`,
    and start saving some tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with covering the latter case, creating a new token. We''ll make
    a new method called `registerToken`, passing in the result of the `getToken` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We save the token, along with the user ID. Perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an existing token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll do something similar with updating a token, but this time we need to access
    the existing token in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `console.log` here for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, try logging in and out of the app with different users. You should see
    the same `existingToken` key each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use this to grab the existing entry from the `fcmToken` table in our
    database, and update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that was a lot. Let's double-check that this is working correctly. Go
    to `console.firebase.com` and check the Database tab. Try logging in and out of
    the app again with two different users. You should see the matching token entry
    update its user ID each time. Then, try logging in on a different device (after
    doing another firebase deploy) and see another token appear. Magic!
  prefs: []
  type: TYPE_NORMAL
- en: We now have a table of tokens for every device that uses our app, along with
    the ID of the user last associated with that device. We're now ready to move to
    the best part of push notifications--actually sending them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final `NotificationResource.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Sending push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Way back at the beginning of this book, when we initialized Firebase, we checked
    an option for Functions. This created a folder in our root directory called `functions`,
    which we have ignored as of yet (if you don't have this folder, you can run `firebase
    init` again, and ensure that you check off both Functions and Hosting for the
    first question. Reference the chapter on Firebase for more).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `functions` folder allows us to use Firebase Cloud Functions. Here''s how
    Google defines them:'
  prefs: []
  type: TYPE_NORMAL
- en: “Cloud Functions gives developers access to Firebase and Google Cloud events,
    along with scalable computing power to run code in response to those events.”
  prefs: []
  type: TYPE_NORMAL
- en: That's the simplest definition--code that runs in response to events, outside
    of our application. We extract a bit of functionality that doesn't belong to any
    particular instance of our app (because it concerns all instances of our app)
    to the Cloud, and have it run automatically by Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open up `functions /index.js` and get to work.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our Cloud function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we can initialize our app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Cloud functions = code run in response to events, so what's our event?
  prefs: []
  type: TYPE_NORMAL
- en: We want to notify the user when a new message is created. So, the event is a
    new message, or, more specifically, when a new entry is created in the messages
    table of our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define the export of our `index.js` to be a function called `sendNotifications`,
    which defines a listener for the `onWrite` event of `/messages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Everything else in this section will take place in the event listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we grab the snapshot from the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, we don’t support editing messages; but one day we might. We don''t
    want a push notification in that event, so we''ll return early if `onWrite` is
    triggered by an update (the snapshot has a previous value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll construct our notification. We define an object with a nested
    notification object, with a `title`, `body`, `icon`, and `click_action`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `title` comes from the user email associated with the message. The `body`
    is the message itself. Both of those are wrapped in template strings to ensure
    that they come out as strings. It's just a safety thing!
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use our app icon as the icon for the notification. Note the path--the
    icon doesn’t actually exist in our `functions` folder, but since it will be deployed
    to the root of our app (it's in the `build` folder), we can reference it.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, our `click_action` should take our user to the app. We grab the domain
    URL via our config.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to send payload to the relevant devices. Buckle up, this will
    be a good chunk of code.
  prefs: []
  type: TYPE_NORMAL
- en: Sending to the tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write out the steps we need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of all tokens in our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter that list for only the tokens that don't belong to the user who sent
    the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the notification to the devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any devices fail to receive the notification due to an invalid or unregistered
    token, remove their tokens from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step is to keep things clean by periodically removing invalid tokens
    from our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, sounds like fun. Remember that this is all within the event listener
    of `onWrite`. Here''s the first step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This uses the database `.once` method to grab a one-time look at the token table.
    From there, we can proceed if we actually have some tokens saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter our results, we''ll do a loop very similar to our `findExistingToken`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We loop through all tokens, and if the `user_id` does not match the `user_id`
    of the message, we push it into our array of valid tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for the third step; send the notification to every device, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward. We pass `sendToDevice` an array of tokens, and
    our payload object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s do the cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code should be simple to look through, except perhaps returning the `Promise.all`.
    The reason for that is that called `remove()` on each token entry returns a promise,
    and we simply return the resolution of all such promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Testing our push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run `**yarn deploy**`, and then we can test out our push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to test it is to simply open up a tab of our deployed app,
    and then another version in an Incognito tab (using Chrome). Log in to each tab
    with different users, and when you send a message, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you must not have both tabs in focus; you need to open both tabs,
    but switch away from one, otherwise the notification won't display.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you encounter any problems, you can try the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Cloud Functions logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you log in to `console.firebase.com`, under the Functions tab, there's
    a log tab that shows the execution of each function. Any errors will show up here
    and also, any of the old token deletions we configured. Check to ensure that A)
    the function is actually running when you send a message and B) there are no errors
    that interfere with the sending.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Service Worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said earlier, the Service Worker should update given any byte-difference
    in its size as well as after every reload if Update on reload is checked in Chrome
    DevTools | Application. However, even with those steps, I found that the service
    worker often did not actually update on redeployment. If you’re having problems,
    click on Unregister beside each instance under the Application | Service Workers
    tab of DevTools. Then, click on the name of each service worker file to ensure
    that the code matches what's in your `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that the tokens are saving and updating correctly in the database. There
    should be no duplicates with different user IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Push notifications are tricky. In this chapter, we had to write a lot of code
    with very few benchmarks to check in along the way. If you're running into problems,
    ensure that all your code matches the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Once your notifications are working, though, we'll have bridged a major gap
    between web apps and native applications. Now, it's time to take another step
    into the world of native apps, by making our apps installable by the user.
  prefs: []
  type: TYPE_NORMAL
