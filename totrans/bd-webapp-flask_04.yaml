- en: Chapter 4. Please Fill in This Form, Madam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever imagined what happens when you fill in a form on a website and
    click on that fancy **Send** button at the end of it? Well, all the data you wrote—comment,
    name, checkbox, or whatever—is encoded and sent through a protocol to the server,
    which then routes that information to the Web application. The Web application
    will validate the data origin, read the form, validate the data syntactically
    then semantically, and then decide what to do with it. Do you see that long chain
    of events where every link might be the cause of a problem? That's forms for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, there is nothing to fear! Flask can help you in those steps but
    there are also tools specifically designed for this purpose. In this chapter,
    we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to write and handle forms with Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to validate form data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use WTForms to validate forms with Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement cross-site request forgery protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will actually be a fairly smooth chapter, with lots of new info but nothing
    complex. Hope you enjoy it!
  prefs: []
  type: TYPE_NORMAL
- en: HTML forms for the faint of heart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML is, pretty much, the language in which the Web is written. With the help
    of special markups called **tags**, it's possible to add meaning and context to
    plain text, turning it into HTML. For us, HTML is a means to an end. So, if you
    want to learn more about it, please open [http://www.w3schools.com/html/](http://www.w3schools.com/html/)
    in your preferred browser. We are not covering HTML syntax fully, nor all the
    beautiful magic involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we will not cover HTML extensively, we will cover HTML specifically;
    by this, I refer to the `<form>` tag. Here is the deal: every time you open a
    webpage and there are a few blank fields for you to fill in, you''re most likely
    filling in an HTML form. That''s the plainest way to transfer data from your browser
    to a server. How does that work? Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have a full login form. Its beginning is defined
    by the `<form>` tag, which has two non-required attributes: `method` and `action`.
    The `method` attribute defines how you want your form data to be sent to the server
    when it is sent. Its value could be either `get` or `post`. You should use `get`,
    which is the default, only when the form data is small (a few hundred characters),
    not sensitive (it doesn''t matter if someone else sees it) and there are no files
    in the form. These requirements exist because when using `get`, all the form data
    will be appended to the current URL as encoded parameters before being sent. In
    our example, the chosen method is `post` because one of our input fields is a
    password and we don''t want other people looking into our password. A good use
    case for using the `get` method would be with search forms. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In `example 2`, we have a simple search form. If we fill the `name` input with
    the search term `SearchItem` and hit *Enter*, the URL will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mydomain.com/?search=SearchItem](http://mydomain.com/?search=SearchItem)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding URL would then be saved into the browser history and anyone with
    access to it would be able to see what the previous user was searching for. In
    the case of sensitive data, that's bad.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, back to *example 1*. The second attribute, `action`, is useful for telling
    the browser which URL should receive and respond to the form data. We used `'.'`
    as its value because we want the form data to be sent to the current URL.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines are our input fields. Input fields are used to collect user
    data and, contrary to what the name may suggest, an input field may be an `input`,
    `textarea`, or `select` element. When using input fields, always remember to name
    them with the attribute `name` as it facilitates handling them in the Web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line we have a special input field, which does not necessarily
    have any data to be sent, the Submit input button. By default, a form will be
    sent if you press *Enter* while an `input` element has focus or when a Submit
    button is pressed. Our *example 1* is the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Wow! Finally, our form is written and explained. For an extensive list of possible
    types for an input field, take a look at [http://www.w3schools.com/tags/tag_input.asp](http://www.w3schools.com/tags/tag_input.asp).
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s see how to integrate our form from *example 1* with an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define a view called `login_view` that accepts
    `get` or `post` requests; when the request is `post` (we ignore the form if it
    was sent by a `get` request), we fetch the values for `username` and `passwd`;
    then we run a very simple validation and change the value of `msg` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Beware: a view, in Flask, is not the same as a view in MVC. In Flask, a view
    is the component that receives a request and returns a response, which may be
    a function or a class.'
  prefs: []
  type: TYPE_NORMAL
- en: Did you see the `request` variable we are handling in our example? That's a
    proxy to the current active `request` context. That's why `request.form` points
    to the sent form data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if you're receiving a parameter encoded in the URL? How will you get
    it, given that the request URL is `http://localhost:5000/?page=10`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is pretty common when paginating. Just as before, `request.args`
    is related to the current user request only. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have handled form validation pretty poorly with inline validation.
    No more! Let's try something fancier from now on.
  prefs: []
  type: TYPE_NORMAL
- en: WTForms and you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WTForms ([https://github.com/wtforms/wtforms](https://github.com/wtforms/wtforms))
    is a standalone robust form handling library that allows you to generate HTML
    forms from form-like classes, implement fields and form validation, *and* include
    cross-source forgery protection (a nasty vulnerability that crackers may try to
    exploit in your Web applications). We certainly don't want that!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to install WTForms library, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s write some forms. A WTForms form is a class that extends the `Form`
    class. As plain as that! Let''s create a login form that could be used with our
    previous login example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have a form with two fields, `username` and `passwd`,
    with no validation. It is just enough to build a form in a template, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code, you can iterate over the fields of a WTForms
    form and each field has a few useful attributes you can use to make your HTML
    look good, such as `label` and `errors`. `{{ field }}` will render a plain HTML
    input element for you. There are cases where you may want to set special attributes
    for the input element—for example, `required`, which tells your browser that the
    given field should not be submitted if empty. Call `field` as a function in order
    to achieve that, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You could pass any desired argument, as `placeholder` or `alt`, in line with
    the example. Flask-Empty ([https://github.com/italomaia/flask-empty](https://github.com/italomaia/flask-empty))
    has a nice example within its macros.
  prefs: []
  type: TYPE_NORMAL
- en: WTForms uses a flag system in order to allow you to check when some validations
    are applied to a field. If a field has a "required" validation rule, a `required`
    flag would be set to true in the `fields.flags` attribute. But how does WTForms
    validation work?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Flask, a validator is a callable you add to your `validators` field, or
    a class method in the format `validate_<field>(form, field)`. It allows you to
    validate that the field data is as required or it raises a `ValidationError` explaining
    what went wrong. Let''s see how our nice login form example would look with some
    validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a full form example, with validation, using classes,
    methods and functions as validators and a simple test. The first argument for
    each of our fields is the field label. The second argument is a list of validators
    you want run when the `form.validate` method is called (that's pretty much what
    `form.validate` does). Each field validator is run sequentially, raising a `ValidationError`
    (and stopping the validation chain call) if an error is found.
  prefs: []
  type: TYPE_NORMAL
- en: Each validator receives the form and field as arguments and must do the validating
    *thing* with them. As seen with `validate_password`, which is called for the field
    `password` because of the naming convention. `field.data` holds the field input,
    so you can just validate that most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand each validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Length`: This validates that the input value length is within a given range
    (min, max).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputRequired`: This validates that the field received a value, any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_proper_username`: This validates that the field value matches a given regex.
    (There is also a built-in validator to match a regex to a given value, called
    **Regexp**. You should try it.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate_password`: This validates that the field value matches a given group
    of regex rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example test, you may have noticed the use of a special dictionary-like
    class called `MultiDict` from the `werkzeug` library. It is used because the `formdata`
    parameter, which may receive your `request.form` or `request.args`, must be a
    `multidict-type`. It pretty much means you can't use a plain dictionary here.
  prefs: []
  type: TYPE_NORMAL
- en: When `form.validate` is called, all the validators are called. First the field
    validators, then the `class` method field validators; `form.errors` is a dictionary
    populated with all the field errors found after validate is called. You can then
    iterate over it to show what you found in your templates, console, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-WTF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask uses extensions in order to integrate transparently with third party
    libraries. WTForms with Flask-WTF is a good example of that as we will soon see.
    And, by the way, a Flask extension is a piece of code that integrates its configuration,
    context, and usage with Flask in a predictable way. That means extension usage
    is pretty similar. Now make sure Flask-WTF is installed in your virtual environment
    before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From [http://flask-wtf.readthedocs.org/](http://flask-wtf.readthedocs.org/),
    the project website, we have the following list of features offered by Flask-WTF:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with WTForms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure form with a CSRF token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File upload that works with Flask-Uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global CSRF protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recaptcha support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see the first two features in this chapter while the third will be discussed
    in [Chapter 10](ch10.html "Chapter 10. What Now?"), *What Now?*. The last three
    features will not be covered in this book. We advise you to explore them as homework.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with WTForms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask-WTF uses a little trick regarding `request` in order to integrate. As
    `request` implements a proxy to your current request and request data, and it
    is available whenever you're inside a `request` context, the extension `Form`
    will just grab the `request.form` data by default, saving you some typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `login_view` example could be rewritten taking into account what was discussed
    so far, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We could go even further, as we are, obviously, perfectionists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template, exchange `{{ message }}` by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`get_flashed_messages` is available in the template context by default and
    gives you all the flashed messages for the current user that have not yet been
    shown. We then cache it with `with`, check whether it is not empty, then iterate
    over it.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flashed messages are especially useful when redirecting, because they are not
    bound to the response context.
  prefs: []
  type: TYPE_NORMAL
- en: Securing forms with a CSRF token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cross Site Request Forgery** (**CSRF**) happens when a site tries to exploit
    the trust another site has on your browser (given you''re the user). Basically,
    a site you''re visiting will try to get, or alter information of, a site you have
    already visited and authenticated. Imagine you''re visiting a website and that
    website has an image that loads a URL from another website you''ve already authenticated
    with; imagine that the given URL requests an action of the former website and
    that action changes something from your account—for example, its status is amended
    to inactive. Well, that''s a simple case of a CSRF attack. Another common case
    is when a JSONP request is sent. If the attacked site, the one you''re not visiting,
    accepts JSONP form substitution (JSONP is used for cross-domain requests) and
    does not have CRSF protection, well, then you''ll have an even nastier attack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'WTForms come with its own CSRF protection; Flask-WTF just glues the whole thing
    together with Flask, making your life easier. In order to have CSRF protection
    while using the extension, you need to have `secret_key` set, and that''s it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, whenever you write a form that should have CSRF protection, just make
    sure to add the CSRF token to it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the form is received, the CSRF token is checked against what is registered
    in the user session. If they match, the form's source is good. This is a safe
    approach because a website cannot read a cookie set by another website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases when you don''t want CSRF protection in a form, do not add the token.
    You will have to turn off the CSRF protection for the form if you wish to unprotect
    it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You *may* need to unprotect a form in the case of search fields that use the
    `get` method but are also validated with a Form.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a Web application that receives a name and then answers: `"Hello <NAME>"`.
    If the form is sent empty, an error message should be displayed. If the name given
    is "Chuck Norris", the answer should be "Roundhouse KICK!".'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Web application that shows an image and asks the user what he sees.
    The application should then validate if the answer is correct. If it is not, show
    the user an error message. Otherwise, congratulate the user and show a new image.
    Use Flask-WTF.
  prefs: []
  type: TYPE_NORMAL
- en: Create a calculator with the four operations. It should have all the numbers
    and operators for the user to click on. Make sure it looks like a calculator (because
    we are perfectionists!) and complains if the user tries something evil, such as
    dividing 0 by 0.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So much learned... What can I say! No harm trying, right? Well, we have seen
    how to write HTML forms; read forms with Flask; write WTForms forms; validate
    form data with plain Python and form validators; and write custom validators.
    We also saw how to use Flask-WTF to write and validate our forms and how to protect
    our applications against CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to store our Web application data in
    relational and non-relational databases using great, easy-to-use libraries and
    how to integrate them with Flask. A brief overview on databases will also take
    place to make for smoother knowledge absorption.
  prefs: []
  type: TYPE_NORMAL
