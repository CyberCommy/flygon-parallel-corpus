- en: Routing with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If our app has multiple pages, we need to manage the navigation between the
    different pages. React Router is a great library that helps us do just this!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to build a web shop where we can purchase a few
    tools for React. Our simple shop will have multiple pages that we''ll manage using
    React Router. The shop will look like the following screenshot when we are finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f7ddbc37-471d-4a5d-bec6-962275e687c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we''ll learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Router with routing types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling not found routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing page redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animated transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter).
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Router with routing types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**React Router** and its Types are in `npm`, so we can install them from there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before installing React Router, we need to create our React shop project. Let''s
    get ready to do that by choosing an empty folder of our choice and opening Visual
    Studio Code. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now open a Terminal and enter the following command to create a new
    React and TypeScript project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json` is
    less that `16.7.0-alpha.0`, then we can install this version using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the project is created, let''s add TSLint as a development dependency
    to our project along with some rules that work well with React and Prettier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add a `tslint.json` file containing some rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s enter the following command to install React Router into our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also install the TypeScript types for React Router and save them as
    a development dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going on to the next section, we''re going to remove some of the files `create-react-app`
    created that we don''t need:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's remove the `App` component. So, let's delete the `App.css`, `App.test.tsx`,
    and `App.tsx` files. Let's also remove the import reference `"./App"` in `index.tsx`**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's also remove the service worker by deleting the `serviceWorker.ts` file
    and removing the references to it in `index.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `index.tsx`, let''s change the root component from `<App/>` to `<div/>`.
    Our `index.tsx` file should have the following content in it now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Declaring routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We declare the pages in our app using the `BrowserRouter` and `Route` components. `BrowserRouter` is
    the top-level component and this looks for `Route` components beneath it to determine
    all the different page paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to declare some pages in our app using `BrowserRouter` and `Route`
    later in this section, but before that we need to create our first two pages. This
    first page is going to contain the list of our React tools that we are going to
    sell in our shop. We use the following steps to create our pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start by creating the data for our list of tools by creating a `ProductsData.ts`filewith
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another file called `ProductsPage.tsx` containing the following
    to import React as well as our data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to reference the data in our component state, so let''s create
    an interface for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to create our class component called `ProductsPage`, initializing
    the state to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement the `componentDidMount` life cycle method and set the
    data to the `products` array from `ProductData.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to implementing the `render` method, let''s welcome our users and
    set out the products in a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `map` function in the `products` array to iterate through the
    elements and produce a list item tag, `li`, for each product. We need to give
    each `li` a unique `key` attribute to help React manage any changes to the list
    items, which in our case is the `id` product.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve referenced some CSS classes, so let''s add these to `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement our second page now, which is going to be an admin panel.
    So, let''s create a file called `AdminPage.tsx` with the following function component
    inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have two pages in our shop, we can declare our two routes to them.
    Let''s create a file called `Routes.tsx` with the following content to import
    `React`, the `BrowserRouter` and `Route` components from React Router, and our
    two pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have renamed `BrowserRouter` to `Router` in the import statement to save
    a few keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go on to implement a function component containing our two routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: During rendering, if the `path` in a `Route` component matches the current path,
    the component will be rendered, and if not, `null` will be rendered. In our example,
    `ProductPage` will be rendered if the path is `"/products"` and `AdminPage` will
    be rendered if the path is `"/admin"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the final step to render our `Routes` as the root component
    in `index.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to run our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The app will probably start on the root page, which will be blank because that
    path doesn't point to anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the path to `"/products"`, our product list should render the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/925bbb49-69b4-4177-992b-c25699f815d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we change the path to `"/admin"`, our admin panel should render the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0b262240-7972-4581-8568-e6e1bcb6c572.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have successfully created a couple of routes, we really need a navigation
    component to make our pages a little more discoverable. We will do just that in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router comes with some nice components for providing navigation. We are
    going to use these to implement navigation options in the app header.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Link component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the `Link` component from React Router to create our navigation
    options by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new file called `Header.tsx` with the following
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create two links using the `Link` component in a `Header` function component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Link` component allows us to define the path where the link navigates to
    as well as the text to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve referenced some CSS classes, so, let''s add these to `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our `Header` component is in place, let''s `import` into `Routes.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it in the JSX as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we examine the running app, it should look like the following screenshot
    with a nice header and two navigation options to go to our Products and Admin
    pages rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e0077307-1579-4601-9c40-0921d07bbd20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Try clicking the navigation options — they work! If we inspect the Products
    and Admin elements using the browser Developer tools, we see that React Router
    has rendered them as anchor tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/13e4d12e-4743-4191-b589-920510489478.png)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the Network tab in Developer tools while clicking the navigation
    options, we'll see no network request is being made to serve the pages. This shows
    that React Router is handling the navigation for us in our React app.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NavLink component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Router providers another component for linking to pages, called `NavLink`.
    This is actually even more suitable for our requirements. The following steps
    explain how we can refactor our `Header` component to use `NavLink`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s replace `Link` with `NavLink` in our `Header` component and make
    some improvements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our app looks and behaves exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavLink` exposes an `activeClassName` attribute that we can use to style the
    active link. So, let''s use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the CSS for `header-link-active` into our `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we switch to the running app now, the active link will be underlined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3400106f-fffa-4040-9a59-fd6563524f78.png)'
  prefs: []
  type: TYPE_IMG
- en: So, `NavLink` is great for the main app navigation where we want to highlight
    the active link and `Link` is great for all the other links in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Route parameter is a variable part of the path that can used in the destination
    component to conditionally render something.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add another page to our shop to show the description and price of
    each product, along with an option to add it to the basket. We want to be able
    to navigate to this page using the `"/products/{id}"` path, where `id` is the
    ID of the product. For example, the path to React Redux would be `"products/2"`.
    So, the `id` part of the path is a route parameter. We can do all this by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this route to `Routes.tsx` in between the two existing routes. The
    `id` part of the route is going to be a route parameter, which we define with
    a colon in front of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the `ProductPage` component doesn''t exist yet, so, let''s create
    that by first creating a new file called `ProductPage.tsx` with the following
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The key part here is that we are going to use the `RouteComponentProps` type
    to access the `id` parameter in the path. Let''s define the props type alias for
    our `ProductPage` component using the `RouteComponentProps` generic type and passing
    in a type with an `id` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if you don't understand the angle brackets in the `type` expression.
    This denotes a generic type, which we will explore in [Chapter 5](5359acd1-bd43-48ef-b141-aea4d5fa356c.xhtml),
    *Advanced Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we'd have specified the `id` property as a number to match the type
    in the product data. However, `RouteComponentProps`only allows us to have Route
    parameters of type string or undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductPage` component is going to have state to hold the product that
    is being rendered and whether it has been added to the basket, so let''s define
    an interface for our state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The product is initially going to be `undefined`, which is why it is defined
    as optional. Let''s create our `ProductPage` class and initialize the state so
    that the product is not in the basket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component is loaded into the DOM, we need to find our product from
    the product data with the `id` property from the `Route` parameter. `RouteComponentProps`
    gives us a `match` object, containing a `params` object, containing our `id` route
    parameter. So, let''s implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `id` route parameter is a string, which is why we cast it
    to a number using `parseInt` before comparing it with the product data in the `filter` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our product in our component state, let''s move on to the
    `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few interesting bits in this JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line inside the function, we set a `product` variable to the product
    state to save a few keystrokes because we reference the product a lot in the JSX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ternary inside `div` renders the product if there is one. Otherwise, it
    informs the user that the product cannot be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `React.Fragment` in the true part of the ternary because each part of
    a ternary can only have a single parent and `React.Fragment` is a mechanism for achieving
    this, without rendering something like a `div` tag that is not really needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `Intl.NumberFormat` to format the product price as currency with a currency
    symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are also calling the `handleAddClick` method when the Add to basket button
    is clicked. We haven''t implemented this yet, so, let''s do that now and set the
    `added` state to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve implemented the `ProductPage` component, let''s go back to
    `Routes.tsx` and import it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go to our running app and type in `"/products/2"` as the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0b6b05ab-b747-4c2a-82e9-3f753290bb97.png)'
  prefs: []
  type: TYPE_IMG
- en: Not quite what we want! Both `ProductsPage` and `ProductPage` have rendered
    because `"/products/2"` matches both `"/products"` and `"/products/:id"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we can tell the `"/products"` route to only render when there
    is an exact match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After we make this change and save `Routes.tsx`, our product page looks much
    better:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/59bbace4-1854-40b6-9504-65f9c7b1a1df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We aren''t going to make our users type in the specific paths to visit the
    products! So, we are going to change `ProductsPage` to link to `ProductPage` for
    each product using the `Link` component. First, let''s import `Link` into `ProductsPage`
    from React Router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of rendering the product name in each list item, we are going
    to render a `Link` component that goes to our product page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we take a look a the running app, let''s add the following CSS class
    in our `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we go to the products list in our app and click on a list item, it takes
    us to the relevant product page.
  prefs: []
  type: TYPE_NORMAL
- en: Handling not found routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if a user enters a path that doesn''t exist in our app? For example, if
    we try to navigate to `"/tools"` we get nothing appearing beneath our header.
    This makes sense, because React Router didn''t find any matching routes, so nothing
    is rendered. However, if the user does navigate to an invalid path, we want to
    inform them that the path doesn''t exist. The following steps make this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a new file called `NotFoundPage.tsx` with the following component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import this into our routes in `Routes.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s then add a `Route` component to this with the other routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is going to render for every path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3842b2b9-6751-45b7-9d7b-9f605e22cece.png)'
  prefs: []
  type: TYPE_IMG
- en: How can we just render `NotFoundPage` when it hasn't found another route? The
    answer is to wrap the Routes in the `Switch` component in React Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first import `Switch` into `Routes.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now wrap the `Route` components in a `Switch` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Switch` component renders only the first matching `Route` component. If
    we look at the running app we see that our problem is resolved. If we enter a
    path that doesn''t exist, we get our nice not found message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21ea4cb5-68fb-41c3-abe3-ae2b50f7e5ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing page redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router has a component called `Redirect` that we can use to redirect to
    pages. We use this component in a couple of cases to improve our shop in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Simple redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we visit the `/` route path, we'll notice that we get the Sorry, this page
    cannot be found message. Let's change this to redirect to `"/products"` when the
    path is `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `Redirect` component from React Router into `Routes.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `Redirect` component to redirect to `"/products"` when the
    path is `/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `exact` attribute on `Redirect` so that it only matches `/` and
    not `"/products/1"` and `"/admin"`. If we give this a try and enter `/` as the
    path in our running app, it will immediately redirect to `"/products"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `Redirect` component to protect pages from unauthorized users.
    In our shop, we can use this to ensure only logged in users can access our Admin
    page. We do this through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a route to a `LoginPage` in `Routes.tsx` after the route
    to the Admin page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, `LoginPage` doesn''t exist at the moment, so, let''s create a file
    called `LoginPage.tsx` and enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then go back to `Routes.tsx` and import `LoginPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go to the running app and navigate to `"/login"`, we will see our Login
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cc65b5cd-91ed-4172-acdd-646e9462f43d.png)'
  prefs: []
  type: TYPE_IMG
- en: We are not going to fully implement our Login page; the page that we have implemented
    is enough to demonstrate a conditional redirect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the conditional redirect on the `"admin"` path, we need
    to add a piece of state for whether a user is logged in or not in `Routes.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: So, we have used a `useState` hook to add a state variable called `loggedIn`
    and a function to set it called `setLoggedIn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to add the following inside the `Route` component with the `"/admin"`
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We conditionally render `AdminPage` if the user is logged in, otherwise, we
    redirect to the `"/login"` path. If we now click the `admin` link in our running
    app, we get redirected to the Login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the `loggedIn` state to be true when we initialize it, we are
    able to access our Admin page again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A query parameter is part of the URL that allows additional parameters to be
    passed into a path. For example, `"/products?search=redux"` has a query parameter
    called `search` with a `redux` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this example and allow the users of the shop to search for
    a product:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a variable in the state in `ProductsPage.tsx` called
    `search`, which is going to hold the search criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we need to access the URL, we need to use `RouteComponentProps`
    as the props type in `ProductsPage`. Let''s first import this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this as the `props` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can initialize the `search` state to an empty string in `constructor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to set the `search` state in `componentDidMount` to the search
    query parameter. React Router gives us access to all the query parameters in `location.search`
    within the `props` argument that it passes into the component. We then need to
    parse that string to get our search query string parameter. We can use the `URLSearchParams`JavaScript
    function to do this. We are going to use the static `getDerivedStateFromProps`
    life cycle method to do this, which is called when the component loads and when
    its `props` parameters change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, `URLSearchParams`hasn''t been implemented yet in all browsers,
    so we can use a polyfill called `url-search-params-polyfill`. Let''s install this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import this into `ProductPages.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We then can use the `search` state in the `render` method by wrapping an `if`
    statement around the returned list item to only return something when the value
    of `search` is contained within the product name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enter `"/products?search=redux"` as the path in our running app, we will
    see our products list containing only React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/96ffab51-0017-401b-b155-bb32ee090203.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to finish implementing this feature by adding a search input in
    our app header that sets the search query parameter. Let''s start this by creating
    some state in the `Header` component for the search value in `Header.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to need to access the query string via React Router and `URLSearchParams`,
    so let''s import `RouteComponentProps`, `withRouter`,andthe `URLSearchParams`
    polyfill:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a `props` parameter to our `Header` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now get the search value from the path query string and set the `search`
    state to this when the component first renders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add a `search` input in the `render` method for the user to enter
    their search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `search-container` CSS class that we just referenced to `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in `Header.tsx`, let''s add the `handleSearchChange` method, which is
    referenced in the `render` method and will keep our `search` state up to date
    with the value being entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now implement the `handleSearchKeydown` method, which is referenced
    in the `render` method. This needs to add the `search` state value to the path
    query string when the `Enter` key is pressed. We can leverage the `push` method
    in the `history` prop that `RouteComponentProps` gives us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to export the `Header` component wrapped with the `withRouter` higher
    order component in order for the reference to `this.props.history` to work. So,
    let''s do this and adjust our `export` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give this a try in the running app. If we enter `redux` in the search
    input and press the *Enter* key, the app should navigate to the Products page
    and filter the products to React Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/57a03ba9-e655-4f2e-be06-f7ac98dbad03.png)'
  prefs: []
  type: TYPE_IMG
- en: Route prompts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we might want to ask the user to confirm that they want to navigate
    away from a page. This is useful if the user is in the middle of data entry on
    a page and presses a navigation link to go to a different page before they have
    saved the data. The `Prompt` component in React Router allows us to do this, as
    set out in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, we are going to prompt users to confirm that they want to navigate
    away from the Product page if they haven''t added the product to their basket.
    First, in `ProductPage.tsx`, let''s import the `Prompt` component from React Router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Prompt`component invokes a confirmation dialog during navigation when
    a certain condition is met. We can use the `Prompt` component in our JSX as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `when` attribute allows us to specify an expression for when the dialog
    should appear. In our case, this is when the product hasn't been added to the
    basket.
  prefs: []
  type: TYPE_NORMAL
- en: The `message`attribute allows us to specify a function that returns the message
    to display in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we call a `navAwayMessage` method, which we''ll implement next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give this a try by navigating to the React Router product and then navigating
    away without clicking the Add to basket button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cf59716c-37f2-4965-a041-d7c064953d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: We are asked to confirm whether we want to navigate away.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A nested route is when a URL is more than one level deep and it renders multiple
    components. We are going to implement some nested routes in this section in our
    Admin page. Our completed Admin page will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aea627e7-0812-4851-b2c2-3619c51533ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The URL in the preceding screenshot is 3 levels deep which renders the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The top-level menu containing links for Users and Products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A menu containing all the users. This is just Fred, Bob, and Jane is our example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about the selected user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by opening `AdminPage.tsx` and add `import` statements for the
    following from `react-router-dom`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the `NavLink` component to render the menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Route` component will be used to render the nested routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RouteComponentProps` type will be used to get the `id` of a user from the
    URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to replace the `p` tag with an unordered list containing menu
    options Users and Products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We use the `NavLink` component to navigate to the nested route for the two options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the CSS classes we have just referenced in `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving back to `AdminPage.tsx`, let''s add two `Route` components beneath the
    menu we have just added. These will handle the `/admin/users` and `/admin/products` paths
    we referenced in our menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just referenced `AdminUsers` and `AdminProducts` components that don''t
    exist yet. Let''s implement the `AdminProducts` component first by entering the
    following beneath the `AdminPage` component in `AdminPage.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: So, this component just renders a bit of text on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the `AdminUsers` component now which is more complex. We''ll
    start by defining an interface for a user along with some user data beneath the `AdminProducts` component
    in `AdminPage.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: So, we have 3 users in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start to implement the `AdminUsers` component then in `AdminPage.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The component renders a link containing each user's name. The link is to a nested
    path which will eventually show details about the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to define another route that will call a component to render details
    about a user. We can do this by using another `Route` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The path we have just defined routes to an `AdminUser` component we haven''t
    defined yet. So, let''s make a start on this beneath the `AdminUsers` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We use `RouteComponentProps` to get the `id` from the URL path and make this
    available in the props.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the `id` from the path to get the user from our `adminUsersData`
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the `user` object, we can render the information within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go to the running app, go to the Admin page and click on the Products
    menu item, it will look like below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/41b9577d-4622-4b94-8fbc-8fff41c2939e.png)'
  prefs: []
  type: TYPE_IMG
- en: If we click on the Users menu item, we'll see the 3 users that we can click
    on to get more information about a user. This will look like the first screenshot
    in this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in order to implement nested routes, we create the necessary links using
    `NavLink` or `Link` components and route those links to the component to render
    the content using a `Route` component. We already knew about these components
    before this section, so, we just needed to learn how to use these in the context
    of nested routes.
  prefs: []
  type: TYPE_NORMAL
- en: Animated transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a bit of animation when users navigate
    to different pages. We do this using the `TransitionGroup` and `CSSTransition`
    components from the `react-transition-group npm` package, as shown in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s first install this package with its TypeScript types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`TransitionGroup` keeps track of all its children inside its local state and
    calculates when children are entering or exiting.  `CSSTransition` takes whether
    children are leaving or exiting from `TransitionGroup` and applies CSS classes
    to the children based on that status. So, `TransitionGroup` and `CSSTransition` can
    wrap our routes and invoke CSS classes that we can create to animate pages in
    and out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s import these components into `Routes.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import `RouteComponentProps` from React Router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `RouteComponentProps` as the `Route` component props type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `CSSTransition` and `TransitionGroup` components to the JSX
    around the `Switch` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`TransitionGroup` requires children to have a unique key for it to determine
    what is exiting and entering. So, we have specified a `key` attribute on `CSSTransition`
    to be the `location.key` property from `RouteComponentProps`. We have specified
    that the transition is going to run for up to half a second via the `timeout`
    attribute. We have also specified the CSS classes that are going to be invoked
    with an `animate` prefix via the `classNames`attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add these CSS classes in `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`CSSTransition` is going to invoke these CSS classes when its key changes.
    The CSS classes initially hide the element being transitioned and gradually ease
    the element''s opacity so that it shows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go to `index.tsx`, we get a compilation error where we reference the
    `Routes` component because it is expecting us to pass props such as `history`
    from the router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d2f019b7-3abf-401b-873b-968d0076d9f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, we can't use the `withRouter` higher order component because
    this would be outside the `Router` component. To resolve this, we can add a new
    component called `RoutesWrap`, which doesn't take in any props and wraps our existing
    `Routes` component. The `Router` will move up to `RoutesWrap` and will contain
    a `Route` component that always renders our `Routes` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add this `RoutesWrap` component to `Routes.tsx` and export `RoutesWrap`
    instead of `Routes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The compilation error goes away, which is great.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now remove `Router` from our `Routes` component, leaving the `div` tag
    as its root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If we go to the running app and navigate to the different pages, you'll see
    a nice fade animation as the page comes into view.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, all the JavaScript for our app is loaded when the app first
    loads. This includes the Admin page that users don''t use that often. It would
    be great if the `AdminPage` component wasn''t loaded when the app loads and instead
    loaded on demand. This is exactly what we are going to do in this section. This
    is called "lazy loading" components. The following steps allows us to load things
    on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to import the `Suspense` component from React, which we
    are going to use a little later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to import the `AdminPage` component differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We use a React function called `lazy` which takes in a function that returns
    a dynamic import, which in turn is assigned to our `AdminPage` component variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have done this, we may get a linting error: A dynamic import call
    in ES5/ES3 requires the ''Promise'' constructor. Make sure you have a declaration
    for the ''Promise'' constructor or include ''ES2015'' in your `--lib` option.
    So, in `tsconfig.json`, let''s add the `lib` compiler option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is to wrap the `Suspense` component around the `AdminPage` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `Suspense` component shows a `div` tag containing Loading... whilst `AdminPage`
    is being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this in the running app. Let''s open the browser developer tools
    and go to the Network tab. In our app, let''s go to the Products page and refresh
    the browser. Let''s then clear the content in the Network tab in the developer
    tools. If we then go to the Admin page in our app and look at the content in the
    Network tab, we''ll see the *chunk* of JavaScript for the `AdminPage` component
    dynamically loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3c17f194-4bda-4257-9bcb-b5469bc15d8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `AdminPage` component loads really fast, so we never really see the Loading
    ... `div` tag. So, let''s slow the connection down in the browser developer tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c83f1d4f-ebb1-4d97-9c9b-62be48138d46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we then refresh the browser, and go to the Admin page again, we''ll see
    Loading ...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0432f462-c81f-4d13-81f5-06e001a1f974.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the `AdminPage` component isn't that big so this approach doesn't
    really positively impact performance. However, loading larger components on demand
    can really help performance, particularly on slow connections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router gives us a comprehensive set of components for managing the navigation
    between pages in our app. We learned that the top-level component is `Router`,
    which looks for `Route` components beneath it where we define what components
    should be rendered for certain paths.
  prefs: []
  type: TYPE_NORMAL
- en: The `Link` component allows us to link to different pages with an app. We learned
    that the `NavLink` component is like `Link`, but it includes the ability to style
    it depending on whether it is the active path or not. So, `NavLink` is perfect
    for the main navigation element in an app and `Link` is great for other links
    that appear on pages.
  prefs: []
  type: TYPE_NORMAL
- en: '`RouteComponentProps` is a type that gives us access to route parameters and
    query parameters. We discovered that React Router doesn''t parse query parameters
    for us, but can use the native JavaScript `URLSearchParams` interface to do this
    for us.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Redirect` component redirects to a path under certain conditions. We found
    that this is perfect for protecting pages that only privileged users can access.
  prefs: []
  type: TYPE_NORMAL
- en: The `Prompt` component allows us to ask the user to confirm they want to leave
    a page under a certain condition. We used this on the Product page to double-check
    whether users wanted to buy the product. Another common use case for this component
    is confirming navigation away from a data entry page when the inputted data hasn't
    been saved.
  prefs: []
  type: TYPE_NORMAL
- en: We learnt about how nested routes can provide users with deep links into very
    specific parts of our app. We simply define the relevant links using `Link` or
    `NavLink` and `Route` components to handle those links.
  prefs: []
  type: TYPE_NORMAL
- en: We improved our app experience with page transitions using the `TransitionGroup`
    and `CSSTransition` components from the `react-transition-group npm` package.
    We wrapped these components around our `Route` components that define the app
    paths and added CSS classes to do the animation we want when pages exit and enter
    into view.
  prefs: []
  type: TYPE_NORMAL
- en: We learnt that the React `lazy` function along with its `Suspense` component
    can be used on large components that are rarely used by users to load them on
    demand. This helps performance for the startup time of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our knowledge on React Router with the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following `Route` component that shows a list of customers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Will the `CustomersPage` component render when the page is `"/customers"`?
  prefs: []
  type: TYPE_NORMAL
- en: Will the `CustomersPage` component render when the page is `"/customers/24322"`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only want the `CustomersPage` component to render when the path is `"/customers"`.
    How can we change the attributes on `Route` to achieve this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be the `Route` component that could handle the `"/customers/24322"` path be? It
    should put `"24322"` in a route parameter called `customerId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we catch paths that don't exist so that we can inform the user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we implement a `search` query parameter in `CustomersPage`? So, `"/customers/?search=Cool
    Company"` would show customers with the name `"Cool Company"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a while, we decide to change the `"customer"` paths to `"clients"`. How
    can we implement this so that users can still use the existing `"customer"` paths
    but have the paths automatically redirect to the new `"client"` paths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The React Router documentation at the following link is worth going through:
    [https://reacttraining.com/react-router](https://reacttraining.com/react-router)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `react-transition-group` documentation is also worth looking at to gain
    further knowledge on transitioning components: [https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
