- en: Filesystems and File I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far we have traversed across the elemental resources of the kernel, such
    as address spaces, processor time, and physical memory. We have built an empirical
    understanding of *process management*, *CPU scheduling,* and *memory management*
    and the crucial abstractions they provide. We shall continue to build our understanding
    in this chapter by looking at another key abstraction provided by the kernel,
    the *file I/O architecture.* We will look in detail at aspects such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VFS data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing systems exist for the sole purpose of processing data. Most algorithms
    are designed and programmed to extract desired information from acquired data.
    Data which fuels this process must be stored persistently for continuous access,
    mandating storage systems to be engineered to contain information safely for longer
    periods of time. For users however it's the operating system which fetches data
    from these storage devices and makes it available for processing. The kernel's
    filesystem is the component that serves this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem - high-level view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Filesystems** abstract the physical view of storage devices from users, and
    virtualize storage area on a disk for each valid user of the system through abstract
    containers called **files and directories**. **Files** serve as containers for
    user data and **directories** act as containers to a group of user files. In simple
    words, operating systems virtualize a view of a storage device for each user as
    a set of directories and files. Filesystem services implement routines to create,
    organize, store, and retrieve files, and these operations are invoked by user
    applications through appropriate system call interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: We will begin this discussion by looking at the layout of a simple filesystem,
    designed to manage a standard magnetic storage disk. This discussion will help
    us comprehend key terms and concepts related to disk management in general. A
    typical filesystem implementation however involves appropriate data structures
    which describe the organization of file data on disk, and operations which enable
    applications to execute file I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A storage disk typically is composed of physical blocks of identical size called
    **sectors**; size of a sector is usually 512 bytes or in multiples, depending
    on type and capacity of storage. A sector is the minimal unit of I/O on the disk.
    When a disk is presented to the filesystem for management, it perceives storage
    area as an array of **blocks** of fixed size, where each block is identical to
    a sector or multiples of sector size. Typical default block size is 1024 bytes
    and can vary as per disk capacity and filesystem type. Block size is considered
    the minimal unit of I/O by a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inode (index node)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filesystem needs to maintain metadata to identify and track various attributes
    for each file and directory created by user. There are several elements of metadata
    that describe a file such as filename, type of file, last access timestamp, owner,
    access privileges, last modification timestamp, creation time, size of file data,
    and references to disk blocks containing file data. Conventionally, filesystems
    define a structure called inode to contain all metadata of a file. The size and
    type of information contained in inode is filesystem specific and may largely
    vary based on the functionalities it supports. Each inode is identified by a unique
    number referred to as an **index**, which is considered a low-level name of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Filesystems reserve a few disk blocks for storing inode instances and the rest
    for storing corresponding file data. The number of blocks reserved for storing
    inodes depend on the storage capacity of the disk. The on-disk list of nodes held
    in inode blocks is referred to as the **inode table**. Filesystems would need
    to track the status of the inode and data blocks to identify free blocks. This
    is generally achieved through **bitmaps**, a bitmap for tracking free inodes and
    another to track free data blocks*.* The following diagram shows the typical layout
    with bitmap, inode, and data blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Data block map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, each inode should record the locations of data blocks
    in which corresponding file data is stored. Depending on the length of file data,
    each file might occupy *n* number of data blocks. There are various methods used
    to track data block details in an inode; the simplest being **direct references**,
    which involves the inode containing **direct pointers** to data blocks of the
    file. The number of such **direct pointers** would depend on filesystem design,
    and most implementations choose to engage fewer bytes for such pointers. This
    method is productive for small files which span across a few data blocks (usually
    < 16k), but lacks support for large files spread across numerous data blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To support large files, filesystems engage an alternate method called **multi-level
    indexing** which involves indirect pointers. The simplest implementation would
    have an indirect pointer along with a few direct pointers in an inode structure.
    An **indirect pointer** refers to a block containing **direct pointers** to data
    blocks of the file. When a file grows too large to be referred through direct
    pointers of the inode, a free data block is engaged with direct pointers and the
    indirect pointer of the inode is referred to it. The data block referred to by
    an indirect pointer is called **indirect block**. The number of direct pointers
    in an indirect block can be determined by block size divided by the size of block
    addresses; for instance, on a 32-bit filesystem with 4-byte (32 bits) wide block
    addresses and 1024 block size, each indirect block can contain up to 256 entries,
    whereas in a 64-bit filesystem with 8-byte (64 bits) wide block addresses, each
    indirect block can contain up to 128 direct pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This technique can be furthered to support even larger files by engaging a **double-indirect
    pointer,** which refers to a block containing indirect pointers with each entry
    referring to a block containing direct pointers**.** Assuming a 64-bit filesystem
    with 1024 block size, with each block accommodating 128 entries, there would be
    128 indirect pointers each pointing to a block holding 128 direct pointers; thus
    with this technique a filesystem can support a file that can span up to 16,384
    (128 x 128) data blocks, which is 16 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Further, this technique can be extended with a **triple-indirection pointer,**
    resulting in even more metadata to be managed by filesystems. However, despite
    of multi-level indexing**,** increasing filesystem block size with reduction in
    block address size is the most recommended and efficient solution to support larger
    files. Users will need to choose the appropriate block size while initializing
    a disk with a filesystem, to ensure proper support for larger files.
  prefs: []
  type: TYPE_NORMAL
- en: Some filesystems use a different approach called extents to store data block
    information in an inode. An **extent** is a pointer that refers to the start data
    block (similar to that of a direct pointer) with added length bits that specify
    the count of contiguous blocks where file data is stored. Depending on file size
    and disk fragmentation levels, a single extent might not be sufficient to refer
    to all data blocks of the file, and to handle such eventualities, filesystems
    build **extent lists** with each extent referring to the start address and length
    of one region of contiguous data blocks on disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extents approach reduces metadata that filesystems need to manage to store
    data block maps by a significant volume, but this is realized at the cost of flexibility
    in filesystem operations. For instance, consider a read operation to be performed
    at a specific file position of a large file: to locate a data block of specified
    file offset position, the filesystem must begin with the first extent and scan
    through the list until it finds the extent that covers the required file offset.'
  prefs: []
  type: TYPE_NORMAL
- en: Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filesystems consider a directory as a special file. They represent a directory
    or a folder with an on-disk inode. They are differentiated from normal file inodes
    through the **type** field, which is marked as **directory**. Each directory is
    assigned data blocks where it holds information about files and subdirectories
    it contains. A directory maintains records of files, and each record includes
    the filename, which is a name string not exceeding a specific length as defined
    by the filesystem''s naming policy, and the inode number associated with the file.
    For efficient management, filesystem implementations define the layout of file
    records contained in a directory through appropriate data structures such as binary
    trees, lists, radix trees, and hash tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Superblock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from storing inodes that captures metadata of individual files, filesystems
    also need to maintain metadata pertaining to disk volume as a whole, such as size
    of the volume, total block count, current state of filesystem, count of inode
    blocks, count of inodes, count of data blocks, start inode block number, and filesystem
    signature (magic number) for identity. These details are captured in a data structure
    called **superblock**. During initialization of filesystem on disk volume, the
    superblock is organized at start of disk storage. The following diagram illustrates
    the complete layout of disk storage with superblocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While **data structures** make up elementary constituents of a filesystem design,
    the operations possible on those data structures to render file access and manipulation
    operations makes the core feature set. The number of operations and type of functionalities
    supported are filesystem implementation specific. Following is a generic description
    of a few common operations that most filesystems provide.
  prefs: []
  type: TYPE_NORMAL
- en: Mount and unmount operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mount** is an operation of enumerating an on-disk superblock and metadata
    into memory for the filesystem''s use. This process creates in-memory data structures
    that describe file metadata and present the host operating system with a view
    of the directory and file layout in the volume. The mount operation is implemented
    to check consistency of disk volume. As discussed earlier, the **superblock**
    contains the state of the filesystem; it indicates whether the volume is *consistent*
    or *dirty*. If the volume is clean or consistent, a mount operation would succeed,
    and if the volume is marked as dirty or inconsistent, it returns with the appropriate
    failure status.'
  prefs: []
  type: TYPE_NORMAL
- en: An abrupt shutdown causes filesystem state to be dirty*,* and requires consistency
    check before it can be marked for use again*.* Mechanisms adopted for consistency
    checks are complex and time consuming; such operations are filesystem implementation
    specific, and most simple ones provide specific tools for consistency and checks,
    and other modern implementations use journaling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unmount** is an operation of flushing the in-memory state of filesystem data
    structures back to disk. This operation causes all metadata and file caches to
    be synchronized with disk blocks. Unmount marks the filesystem state in the superblock
    as consistent, indicating graceful shutdown. In other words, the on-disk superblock
    state remains dirty until unmount is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: File creation and deletion operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Creation** of a file is an operation that requires instantiation of a new
    inode with appropriate attributes. User programs invoke the file creation routine
    with chosen attributes such as filename, directory under which file is to be created,
    access permissions for various users, and file modes. This routine also initializes
    other specific fields of inode such as creation timestamp and file ownership information.
    This operation writes a new file record into the directory block, describing the
    filename and inode number.'
  prefs: []
  type: TYPE_NORMAL
- en: When a user application initiates a `delete` operation on a valid file, the
    filesystem removes the corresponding file record from the directory and checks
    the file's reference count to determine the number of processes currently using
    the file. Deletion of a file record from a directory prevents other processes
    from opening the file that is marked for deletion. When all current references
    to a file are closed, all resources assigned to the file are released by returning
    its data blocks to the list of free data blocks, and inode to list of free inodes.
  prefs: []
  type: TYPE_NORMAL
- en: File open and close operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user process attempts to open a file, it invokes the `open` operation
    of the filesystem with appropriate arguments, which include path and name of the
    file. The filesystem traverses through directories specified in the path until
    it reaches the immediate parent directory that contains the requested file's record.
    Lookup into the file record produces the inode number of the specified file. However,
    specific logic and efficiency of lookup operation depends on the data structure
    chosen by the particular filesystem implementation for organizing file records
    in a directory block.
  prefs: []
  type: TYPE_NORMAL
- en: Once the filesystem retrieves the related inode number of the file, it initiates
    appropriate sanity checks to enforce access control validation on the calling
    context. If the caller process is cleared for file access, the filesystem then
    instantiates an in-memory structure called **file descriptor** to maintain file
    access state and attributes. Upon successful completion, the open operation returns
    the reference of the file descriptor structure to the caller process, which serves
    as a handle to the file for the caller process to initiate other file operations
    such as `read`, `write`, and `close`.
  prefs: []
  type: TYPE_NORMAL
- en: Upon initiating a `close` operation, the file descriptor structure is destroyed
    and the file's reference count is decremented. The caller process will no longer
    be able to initiate any other file operation until it can open the file all over
    again.
  prefs: []
  type: TYPE_NORMAL
- en: File read and write operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When user applications initiate *read* on a file with appropriate arguments,
    the underlying filesystem's `read` routine is invoked. Operations begin with a
    lookup into the file's data block map to locate the appropriate data disk sector
    to be read; it then allocates a page from the page cache and schedules disk I/O.
    On completion of I/O transfer, the filesystem moves requested data into the application's
    buffer and updates the file offset position in the caller's file descriptor structure.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `write` operation of the filesystem retrieves data passed from
    user buffer and writes it into the appropriate offset of file buffer in the page
    cache, and marks the page with the `PG*_*dirty` flag. However, when the `write`
    operation is invoked to append data at the end of the file, new data blocks might
    be required for the file to grow. The filesystem looks for free data blocks on
    disk, and allocates them for this file, before proceeding with *write*. Allocating
    new data blocks would need changes to the inode structure's data block map and
    allocation of new page(s) from page cache mapped to the new data blocks allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Additional features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the fundamental components of a filesystem remain similar, the way data
    is organized and the heuristics to access data is implementation dependent. Designers
    consider factors such as **reliability**, **security**, **type** and **capacity
    of storage volume**, and **I/O efficiency** to identify and support features that
    enhance capabilities of a filesystem. Following are few extended features that
    are supported by modern filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Extended file attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: General file attributes tracked by a filesystem implementation are maintained
    in an inode and interpreted by appropriate operations. Extended file attributes
    are a feature that enables users to define custom metadata for a file, which is
    not interpreted by the filesystem. Such attributes are often used to store various
    types of information which depend on the type of data the file contains. For instance,
    document files can define the author name and contact details, web files can specify
    URL of the file and other security-related attributes such as digital certificates
    and crypto hash keys. Similar to normal attributes, each extended attribute is
    identified by a **name** and a **value**. Ideally*,* most filesystems do not impose
    restrictions on the number of such extended attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Some filesystems also provide a facility of **indexing** the attributes, which
    aids in quick lookup for required type of data without having to navigate file
    hierarchy. For instance, assume that files are assigned with an extended attribute
    called **Keywords***,* which records keyword values that describe file data. With
    indexing, the user could issue queries to find the list of files matching specific
    keywords through appropriate scripts, regardless of the file's location. Thus,
    indexing offers a powerful alternative interface to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem consistency and crash recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Consistency** of an on-disk image is critical for reliable functioning of
    a filesystem. While the filesystem is in the process of updating its on-disk structures,
    there is every possibility for a catastrophic error to occur (power down, OS crash,
    and so on), causing interruption of a partially committed critical update. This
    results in corruption of on-disk structures and leaves the filesystem in an inconsistent
    state. Dealing with such eventualities, by engaging an effective strategy for
    crash recovery, is one of the major challenges faced by most filesystem designers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some filesystems handle crash recovery through a specially designed filesystem
    consistency check tool like **fsck** (a widely used Unix tool). It is run at system
    boot before mount and scans through on-disk filesystem structures looking for
    inconsistencies, and fixes them when found. Once finished, the on-disk filesystem
    state is reverted to a consistent state and the system proceeds with the `mount`
    operation, thus making the disk accessible to users. The tool executes its operations
    in a number of phases, closely checking for consistency of each on-disk structure
    such as superblock, inode block, free blocks, checking individual inodes for valid
    state, directory checks, and bad block check in each phase. Though it provides
    much-needed crash recovery, it has its downsides: such phased operations can consume
    a lot of time to complete on a large disk volume, which directly impacts the system''s
    boot time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Journaling** is another technique engaged by most modern filesystem implementations
    for quick and reliable crash recovery. This method is enforced by programming
    appropriate filesystem operations for crash recovery. The idea is to prepare a
    **log** (note) listing out changes to be committed to the on-disk image of the
    filesystem, and writing the log to a special disk block called a **journal block**,
    before beginning the actual update operation*.* This ensures that on a crash during
    actual update, the filesystem can easily detect inconsistencies and fix them by
    looking through information recorded in the log*.* Thus, an implementation of
    journaling filesystem eliminates the need for the tedious and expensive task of
    disk scan, by marginally extending work done during an update.'
  prefs: []
  type: TYPE_NORMAL
- en: Access control lists (ACLs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default file and directory access permissions that specify access rights
    for the owner, the group to which owner belongs, and others users does not offer
    fine-grained control required in some situations. ACLs are a feature that enable
    an extended mechanism to specify file access permissions for various processes
    and users. This feature considers all files and directories as objects, and allows
    system administrators to define a list of access permissions for each. ACLs include
    operations valid on an object with access privileges, and restrictions for each
    user and system process on a specified object.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems in the Linux kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with fundamental concepts related to filesystem implementations,
    we will explore filesystem services supported by Linux systems. The kernel''s
    filesystem branch has implementations of numerous filesystem services, which support
    diverse file types. Based on the type of files they manage, the kernel''s filesystems
    can be broadly categorized into:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage filesystems
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Special filesystems
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Distributed filesystems or network filesystems
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We shall discuss special filesystems in a later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage filesystems**: Kernel supports various persistent storage filesystems,
    which can be broadly categorized into various groups based on the type of storage
    device they are designed to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disk filesystems**: This category includes various standard storage disk
    filesystems supported by the kernel, which includes the Linux native ext family
    of disk filesystems, such as Ext2, Ext3, Ext4, ReiserFS, and Btrfs; Unix variants
    such as the sysv filesystem, UFS, and MINIX filesystem; Microsoft filesystems
    such as MS-DOS, VFAT, and NTFS; other proprietary filesystems such as IBM''s OS/2
    (HPFS), Qnx based filesystems such as qnx4 and qnx6, Apple''s Macintosh HFS and
    HFS2, Amiga''s Fast Filesystem (AFFS), and Acorn Disk Filing System (ADFS); and
    journaling filesystems like IBM''s JFS and SGI''s XFS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removable media filesystems**: This category includes filesystems designed
    for CD, DVD, and other movable storage media devices, such as the ISO9660 CD-ROM
    filesystem and Universal Disk Format (UDF) DVD filesystem, and squashfs used in
    live CD images for Linux distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semiconductor storage filesystems**: This category includes filesystems designed
    and implemented for raw flash and other semiconductor storage devices that require
    support of wear-leveling and erase operations. The current set of filesystems
    supported include UBIFS, JFFS2, CRAMFS, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall discuss in brief a few native disk filesystems in the kernel, which
    are used across various distributions of Linux as default.
  prefs: []
  type: TYPE_NORMAL
- en: Ext family filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial release of the Linux kernel used MINIX as the default native filesystem,
    which was designed for use in the Minix kernel for educational purposes and hence
    had many usage limitations. As the kernel matured, kernel developers built a new
    native filesystem for disk management called the **extended filesystem***.* The
    design of *ext* was heavily influenced by the standard Unix filesystem UFS. Due
    to various implementation limitations and lack of efficiency, the original ext
    was short lived and was soon replaced by an improved, stable, and efficient version
    named **second extended filesystem** (**Ext2**)*.* The Ext2 filesystem continued
    to be the default native filesystem for quite a long period of time (until 2001,
    with the 2.4.15 release of the Linux kernel).
  prefs: []
  type: TYPE_NORMAL
- en: Later, rapid evolution in disk storage technologies led to a massive increase
    in storage capacity and efficiency of storage hardware. To exploit features provided
    by storage hardware, the kernel community evolved forks of *ext2* with appropriate
    design improvements and added features that are best suitable for a specific class
    of storage. Current versions of the Linux kernel contain three versions of extended
    filesystems, called Ext2, Ext3, and Ext4.
  prefs: []
  type: TYPE_NORMAL
- en: Ext2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ext2 filesystem was first introduced in kernel version 0.99.7 (1993). It
    retains the core design of classic UFS (Unix filesystem) with write-back caching,
    which enables short turnaround time and improved performance. Although it was
    implemented to support disk volumes in the range of 2 TB to 32 TB and file sizes
    in the range of 16 GB to 2 TB, its usage was restricted for up to 4 TB disk volumes
    and 2 GB max file sizes due to block device and application imposed restrictions
    in 2.4 kernels. It also includes support for ACLs, file memory maps, and crash
    recovery through the consistency checker tool fsck. Ext2 divides physical disk
    sectors into fixed-size block groups. A filesystem layout is constructed for each
    block group, with each having a complete superblock, free block bitmap, inode
    bitmap, inode, and data blocks. Thus, each block group appears as a miniature
    filesystem. This design assists *fsck* with faster consistency checks on a large
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: Ext3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also called **third extended filesystem**, it extends the functionality of Ext2
    with journaling. It retains the entire structure of Ext2 with block groups, which
    enables seamless conversion of an Ext2 partition into an Ext3 type. As discussed
    earlier, journaling causes the filesystem to log details of an update operation
    into specific regions of disk called journal blocks; these logs help expedite
    crash recovery and ensure consistency and reliability of the filesystem. However,
    on journaling filesystems, disk update operations can turn expensive due to slower
    or variable-time write operations (due to journal log) which would directly impact
    performance of regular file I/O. As a solution, Ext3 provides journal configuration
    options through which system administrators or users can select specific types
    of information to be logged to a journal. These configuration options are referred
    to as **journaling modes**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Journal mode**: This mode causes the filesystem to record both file data
    and metadata changes into the journal. This results in maximized filesystem consistency
    with increased disk access, causing slower updates. This mode causes the journal
    to consume additional disk blocks and is the slowest Ext3 journaling mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ordered mode**: This mode records only filesystem metadata into the journal,
    but it guarantees that related file data is written to disk before associated
    metadata is committed to the journal block. This ensures that file data is valid;
    if a crash occurs while executing write to a file, the journal will indicate that
    the appended data has not been committed, resulting in a purge operation on such
    data by the cleanup process. This is the default journaling mode of Ext3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writeback mode**: This is similar to ordered mode with only metadata journaling,
    but with an exception that the related file contents might be written to disk
    before or after the metadata is committed to journal. This can result in corruption
    of filedata. For example, consider a file being appended to may be marked in the
    journal as *committed* before actual file write: if a crash occurs during the
    file append operation, then the journal suggests the file being larger than it
    actually is. This mode is fastest but minimizes file data reliability. Many other
    journaling filesystems such as JFS uses this mode of journaling, but ensure that
    any *garbage* due to unwritten data is zeroed out on reboot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these modes have a similar effect with respect to the consistency of
    metadata, but differ in consistency of file and directory data, with journal mode
    ensuring maximum safety with minimal chance of file data corruption, and writeback
    mode offering minimal safety with high risk of corruption. Administrators or users
    can tune the appropriate mode during mount operation on an Ext3 volume.
  prefs: []
  type: TYPE_NORMAL
- en: Ext4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implemented as a replacement to Ext3 with enhanced features, Ext4 first appeared
    in kernel 2.6.28 (2008). It is fully backward compatible with Ext2 and Ext3, and
    a volume of either type can be mounted as Ext4\. This is the default ext filesystem
    on most current Linux distributions. It extends journaling capabilities of Ext3
    with **journal checksums** which increases its reliability. It also adds checksums
    for filesystem metadata and supports transparent encryption, resulting in enhanced
    filesystem integrity and security. Other features include support for extents*,*
    which help reduce fragmentation, persistent preallocation of disk blocks, which
    enables allocation of contiguous blocks for media files, and support for disk
    volumes with storage capacities up to 1 exbibyte (EiB[)](https://en.wikipedia.org/wiki/Exbibyte)
    and files with sizes up to 16 tebibytes (TiB).
  prefs: []
  type: TYPE_NORMAL
- en: Common filesystem interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presence of diverse filesystems and storage partitions results in each filesystem
    maintaining its tree of files and data structures that are distinct from others.
    Upon mount, each filesystem will require to manage its in-memory file trees in
    isolation from others, resulting in an inconsistent view of the file tree for
    system users and applications. This complicates kernel support for various file
    operations such as open, read, write, copy, and move. As a solution, the Linux
    kernel (like many other Unix systems) engages an abstraction layer called **virtual
    file system (VFS)** that hides all filesystem implementations with a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: The VFS layer builds a common file tree called **rootfs**, under which all filesystems
    can enumerate their directories and files. This enables all filesystem-specific
    subtrees with distinct on-disk representations to be unified and presented as
    a single filesystem. System users and applications have a consistent, homogeneous
    view of the file tree, resulting in flexibility for the kernel to define a simplified
    set of common system calls that applications can engage for file I/O, regardless
    of underlying filesystems and their representations. This model ensures simplicity
    in application design due to limited and flexible APIs and enables seamless copy
    or movement of files from one disk partition or filesystem tree to another, irrespective
    of underlying dissimilarities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the virtual filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'VFS defines two sets of functions: first, a set of generic filesystem-independent
    routines that serve as common entry functions for all file access and manipulation
    operations, and second, a set of abstract operation interfaces that are filesystem
    specific. Each filesystem defines its operations (as per its notion of files and
    directories) and maps them to an abstract interface provided, and with the virtual
    filesystem, this enables VFS to handle file I/O requests by dynamically switching
    into underlying filesystem-specific functions.'
  prefs: []
  type: TYPE_NORMAL
- en: VFS structures and operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deciphering the key objects and data structures of VFS lets us gain clarity
    on how the VFS internally works with filesystems and enables the all-important
    abstraction. Following are four elemental data structures around which the entire
    web of abstraction is weaved:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct super_block`--which contains information on specific filesystems that
    have been mounted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct inode`--which represents a specific file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct dentry`--representing a directory entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct file`--representing the file which has been opened and linked to a
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these data structures are bound to appropriate abstract operation interfaces
    that are defined by filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: struct superblock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VFS defines a generic layout for the superblock through this structure. Each
    filesystem would need to instantiate an object of this structure to fill in its
    superblock details during mount. In other words, this structure abstracts the
    filesystem-specific superblock from the rest of the kernel, and helps VFS track
    all mounted filesystems through a list of `struct super_block`. Pseudo filesystems,
    which do not have persistent superblock structure, will dynamically generate superblocks.
    The superblock structure (`struct super_block`) is defined in `<linux/fs.h>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The superblock structure contains other structures which define and extend
    the information and functionalities of the superblock. Following are some of the
    elements of `super_block`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s_list` is of type `struct list_head` and contains pointers to the list of
    mounted superblocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_dev` is the device identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_maxbytes` contains the maximum file size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_type` is a pointer of type `struct file_system_type`, which describes the
    filesystem type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_op` is a pointer of type `struct super_operations`, containing operations
    on the superblock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_export_op` is of type `struct export_operations` and helps the filesystem
    be exportable for remote systems to access, using network filesystems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_root` is a pointer of type `struct dentry` and points to the dentry object
    of the filesystem''s root directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each enumerated superblock instance contains a pointer to an abstract structure
    of function pointers that define the interface for superblock operations. Filesystems
    will need to implement their superblock operations and assign them to appropriate
    function pointers. This helps each filesystem implement superblock operations
    as per its layout of on-disk superblock and hide that logic under a common interface.
    `Struct super_operations` is defined in `<linux/fs.h>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'All elements in this structure point to functions that operate on the superblock
    object. All these operations are only called from a process context and without
    any locks being held, unless specified. Let''s look at few important ones here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alloc_inode`: This method is used to create and allocate space for the new
    inode object and initialize it under the superblock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy_inode`: This destroys the given inode object and frees resources allocated
    for the inode. This is only used if `alloc_inode` was defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dirty_inode`: This is called by the VFS to mark a dirty inode (when inode
    is modified).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_inode`: VFS invokes this method when it needs to write an inode on to
    the disk. The second argument points to `struct writeback_control`, a structure
    that tells the writeback code what to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put_super`: This is invoked when VFS needs to free the superblock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync_fs`: This is invoked to synchronize filesystem data with that of the
    underlying block device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statfs`: Invoked to get filesystem statistics for the VFS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remount_fs`: Invoked when the filesystem needs to be remounted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`umount_begin`: Invoked when the VFS is unmounting a filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show_options`: Invoked by VFS to show mount options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quota_read`: Invoked by VFS to read from the filesystem quota file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: struct inode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each instance of `struct inode` represents a file in `rootfs`. VFS defines
    this structure as an abstraction for filesystem-specific inodes. Irrespective
    of the type of inode structure and its representation on disk, each filesystem
    needs to enumerate its files as `struct inode` into `rootfs` for a common file
    view. This structure is defined in `<linux/fs.h>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all fields are not mandatory and applicable to all filesystems; they
    are free to initialize appropriate fields that are relevant as per their definition
    of an inode. Each inode is bound to two important groups of operations defined
    by the underlying filesystem: first, a set of operations to manage inode data.
    These are represented through an instance of type `struct inode_operations` that
    is referred to by the `i_op` pointer of the inode. Second is a group of operations
    for accessing and manipulating underlying file data that the inode represents;
    these operations are encapsulated in an instance of type `struct file_operations`
    and bound to the `i_fop` pointer of inode instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, each inode is bound to metadata operations represented by an
    instance of type struct `inode_operations`, and file data operations represented
    by an instance of type `struct file_operations`. However, user-mode applications
    access file data operations from a valid `file` object created to represent an
    open file for the caller process (we will discuss more on file object in next
    section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is a brief description of few important operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lookup`: Used to locate inode instance of the file specified; this operation
    returns a dentry instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`: This routine is invoked by VFS to construct an inode object for dentry
    specified as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link`: Used to support hard links. Called by the `link(2)` system call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlink`: Used to support deleting inodes. Called by the `unlink(2)` system
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir`: Used to support creation of subdirectories. Called by the `mkdir(2)`
    system call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mknod`: Invoked by the `mknod(2)` system call to create a device, named pipe,
    inode, or socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listxattr`: Invoked by the VFS to list all extended attributes of a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_time`: Invoked by the VFS to update a specific time or the `i_version`
    of the inode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is VFS-defined `struct file_operations`, which encapsulates filesystem-defined
    operations on the underlying file data. Since this is declared to serve as a common
    interface for all filesystems, it contains function pointer interfaces suitable
    to support operations on various types of filesystems with distinct definitions
    of file data. Underlying filesystems are free to choose appropriate interfaces
    and leave the rest, depending on their notion of file and file data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is a brief description of a few important operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`llseek`: Invoked when the VFS needs to move the file position index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read`: Invoked by `read(2)` and other related system calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write`: Invoked by the `write(2)` and other related system calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterate`: Invoked when VFS needs to read directory contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll`: This is invoked by the VFS when a process needs to check for activity
    on the file. Called by `select(2)` and `poll(2)` system calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlocked_ioctl`: The operation assigned to this pointer is invoked when the
    user-mode process calls the `ioctl(2)` system call on the file descriptor. This
    function is used to support special operations. Device drivers use this interface
    to support configuration operations on the target device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compat_ioctl`: Similar to ioctl with an exception that it is used to convert
    arguments passed from a 32-bit process to be used with a 64-bit kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmap`: The routine assigned to this pointer is invoked when the user-mode
    process calls the `mmap(2)` system call. Functionality supported by this function
    is underlying filesystem dependent. For regular persistent files, this function
    is implemented to map the caller-specified data region of the file into the virtual
    address space of the caller process. For device files that support `mmap`, this
    routine maps underlying device address space into the caller''s virtual address
    space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: The function assigned to this interface is invoked by VFS when the
    user-mode process initiates the `open(2)` system call to create a file descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flush`: Invoked by the `close(2)` system call to flush a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release`: A function assigned to this interface is invoked by VFS when a user-mode
    process executes the close(2) system call to destroy a file descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fasync`: Invoked by the `fcntl(2)` system call when asynchronous mode is enabled
    for a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splice_write`: Invoked by the VFS to splice data from a pipe to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setlease`: Invoked by the VFS to set or release a file lock lease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fallocate`: Invoked by the VFS to pre-allocate a block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct dentry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our earlier discussion, we gained an understanding on how a typical disk
    filesystem represents each directory through an `inode` structure, and how a directory
    block on disk represents information of files under that directory. When user-mode
    applications initiate file access operations such as `open()` with a complete
    path such as `/root/test/abc` *,* the VFS will need to perform directory lookup
    operations to decode and validate each component specified in the path.
  prefs: []
  type: TYPE_NORMAL
- en: For efficient lookup and translation of components in a file path, VFS enumerates
    a special data structure, called `dentry`. A dentry object contains a string `name`
    of the file or directory, a pointer to its `inode`, and a pointer to the parent
    `dentry`. An instance of dentry is generated for each component in the file lookup
    path; for instance, in the case of `/root/test/abc`, a dentry is enumerated for
    `root`, another for `test`*,* and finally for file `abc`*.*
  prefs: []
  type: TYPE_NORMAL
- en: '`struct dentry` is defined in kernel header `</linux/dcache.h>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`d_parent` is pointer to the parent dentry instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_name` holds the name of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_inode` is a pointer to the inode instance of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_flags` contains several flags defined in `<include/linux/dcache.h>.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_op` points to the structure containing function pointers to various operations
    for the dentry object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now look at `struct dentry_operations`, which describes how a filesystem
    can overload the standard dentry operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is a brief description of a few important dentry operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d_revalidate`: Invoked when VFS needs to revalidate a dentry. Whenever a name
    lookup returns a dentry in the dcache, this is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_weak_revalidate`: Invoked when VFS needs to revalidate a jumped dentry.
    This is invoked if a path-walk ends at a dentry that wasn''t found on a lookup
    on the parent directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_hash`: Invoked when VFS adds a dentry to the hash table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_compare`: Invoked to compare the filenames of two dentry instances. It compares
    a dentry name with a given name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_delete`: Invoked when the last reference to a dentry is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_init`: Invoked when a dentry is allocated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_release`: Invoked when a dentry is deallocated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_iput`: Invoked when an inode is released from the dentry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d_dname`: Invoked when the pathname of the dentry must be generated. Handy
    for special filesystems to delay pathname generation (whenever the path is needed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: struct file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An instance of `struct fil*e*` represents an open file. This structure is created
    when a user process successfully opens a file, and contains the caller application's
    file access attributes such as offset into file data, access mode, and special
    flags, among others. This object is mapped to the caller's file descriptor table,
    and serves as the caller application's handle to the file. This structure is local
    to the process and is retained by a process until the relevant file is closed.
    A `close` operation on the file descriptor destroys the `file` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `f_inode` pointer refers to the inode instance of the file. When a file
    object is constructed by VFS, the `f_op` pointer is initialized with the address
    of `struct file_operations` associated with the file's inode, as we discussed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Special filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike regular filesystems, which are designed to manage persistent file data
    backed on to a storage device, the kernel implements various special filesystems
    that manage a specific class of kernel in-core data structures. Since these filesystems
    do not deal with persistent data, they do not consume disk blocks, and the entire
    filesystem structure is maintained in-core. Presence of such filesystems enables
    simplified application development, debugging, and easier error detection. There
    are many filesystems in this category, each deliberately designed and implemented
    for a specific purpose. Following is brief description of a few important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Procfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Procfs** is a special filesystem that enumerates kernel data structures as
    files. This filesystem serves as a debugging resource for kernel programmers,
    since it allows users to view the state of data structures through the virtual
    file interface. Procfs is mounted to the `/proc` directory (mount point) of rootfs.'
  prefs: []
  type: TYPE_NORMAL
- en: Data in procfs files is not persistent, and is always constructed on the run;
    each file is an interface through which users can trigger associated operations.
    For instance, a read operation on a proc file invokes the associated read callback
    function bound to the file entry, and that function is implemented to populate
    the user buffer with appropriate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of files enumerated depends on the configuration and architecture
    for which the kernel was built. Following is a list of a few important files with
    useful data enumerated under `/proc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/cpuinfo` | Provides low-level cpu details such as vendor, model, clock
    speed, cache size, number of siblings, cores, CPU flags, and bogomips. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/meminfo` | Provides a summarized view of physical memory state. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/ioports` | Provides details on current usage of port I/O address space
    supported by the x86 class of machines. This file is not present on other architectures.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/iomem` | Shows a detailed layout describing current usage of memory
    address space. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/interrupts` | Shows a view of the IRQ descriptor table that contains
    details of IRQ lines and interrupt handlers bound to each. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/slabinfo` | Shows a detailed listing of slab caches and their current
    state. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/buddyinfo` | Shows the current state of buddy lists managed by the
    buddy system. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/vmstat` | Shows virtual memory management statistics. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/zoneinfo` | Shows per-node memory zone statistics. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/cmdline` | Shows boot arguments passed to the kernel. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/timer_list` | Shows a list of active pending timers, with details
    of clock source. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/timer_stats` | Provides detailed statistics on active timers, used
    for tracking timer usage and debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/filesystems` | Presents a list of filesystem services currently active.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/mounts` | Shows currently mounted devices with their mountpoints.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/partitions` | Presents details of current storage partitions detected
    with associated /dev file enumerations. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/swaps` | Lists out active swap partitions with status details. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/modules` | Lists out names and status of kernel modules currently
    deployed. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/uptime` | Shows length of time kernel has been running since boot
    and spent in idle mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/kmsg` | Shows contents of kernel''s message log buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/kallsyms` | Presents kernel symbol table. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/devices` | Presents a list of registered block and character devices
    with their major numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/misc` | Presents a list of devices registered through the misc interface
    with their misc identifiers. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/stat` | Presents system statistics. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/net` | Directory that contains various network stack-related pseudo
    files. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/sysvipc` | Subdirectory containing pseudo files that show the status
    of System V IPC objects, message queues, semaphores, and shared memory. |'
  prefs: []
  type: TYPE_TB
- en: '`/proc` also lists out a number of subdirectories that provide a detailed view
    of elements in process PCB or task structure. These folders are named by the PID
    of the process that they represent. Following is a list of important files that
    present process-related information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/cmdline` | Command-line name of the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/exe` | A symbolic link to the executable file. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/environ` | Lists out environmental variables accessible to the
    process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/cwd` | A symbolic link to the current working directory of the
    process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/mem` | A binary image that shows the virtual memory of the process.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/maps` | Lists out virtual memory mappings for the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/fdinfo` | A directory that lists out open file descriptors'' current
    status and flags. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/fd` | Directory that contains symlink to open file descriptors.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/status` | Lists out current status of the process, including its
    memory usage. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/sched` | Lists out scheduling statistics. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/cpuset` | Lists out the cpu affinity mask for this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/cgroup` | Shows cgroup details for the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/stack` | Shows backtrace of the process-owned kernel stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/smaps` | Shows memory consumed for each mapping into its address
    space. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/pagemap` | Shows the physical mapping status for each virtual
    page of the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/syscall` | Exposes the system call number and arguments for the
    system call currently being executed by the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc/pid/task` | Directory containing child process/thread details. |'
  prefs: []
  type: TYPE_TB
- en: These listings were drawn up to familiarize you with proc files and their use.
    You are advised to visit the manual page of procfs for a detailed description
    of each of these files.
  prefs: []
  type: TYPE_NORMAL
- en: All of the files we listed so far are read-only; procfs also contains a branch
    `/proc/sys` that holds read-write files, which are referred to as kernel parameters.
    Files under `/proc/sys` are further classified as per the subsystems to which
    they apply. Listing out all those files is out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Sysfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sysfs** is another pseudo filesystem that is introduced to export unified
    hardware and driver information to user mode. It enumerates information about
    devices and associated device drivers from the kernel''s device model perspective
    to user space through virtual files. Sysfs is mounted to the /sys directory (mount
    point) of the `rootfs`. Similar to procfs, underlying drivers and kernel subsystems
    can be configured for power management and other functionalities through virtual
    file interfaces of sysfs. Sysfs also enables hotplug event management by Linux
    distros through appropriate daemons such as **udev**, which is configured to listen
    and respond to hotplug events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a brief description of important subdirectories of sysfs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Devices**: One of the objectives behind the introduction of sysfs is to present
    a unified list of devices currently enumerated and managed by respective driver
    subsystems. The devices directory contains the global device hierarchy, which
    contains information for each physical and virtual device that has been discovered
    by the driver subsystems and registered with the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BUS**: This directory contains a listing of subdirectories, each representing
    the physical bus type that has support registered in the kernel. Each bus type
    directory contains two subdirectories: `devices` and `drivers`. The `devices`
    directory contains a listing of devices currently discovered or bound to that
    bus type. Each file in the listing is a symbolic link to the device file in device''s
    directory in the global device tree. The `drivers` directory contains directories
    describing each device driver registered with the bus manager. Each of the driver
    directories lists out attributes that show the current configuration of driver
    parameters, which can be modified, and symbolic links that point to the physical
    device directory that the driver is bound to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: The `class` directory contains representations of device classes
    that are currently registered with the kernel. A device class describes a functional
    type of device. Each device class directory contains subdirectories representing
    devices currently allocated and registered under this class. For most of the class
    device objects, their directories contain symbolic links to the device and driver
    directories in the global device hierarchy and the bus hierarchy that are associated
    with that class object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firmware**: The `firmware` directory contains interfaces for viewing and
    manipulating platform-specific firmware that is run during power on/reset, such
    as BIOS or UEFI on x86 and OpenFirmware for PPC platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**: This directory contains subdirectories that represent each kernel
    module currently deployed. Each directory is enumerated with the name of the module
    it is representing. Each module directory contains information about a module
    such as refcount, modparams, and its core size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike procfs and sysfs, which are implemented to present specific information
    through the virtual file interface, *debugfs* is a generic memory filesystem that
    allows kernel developers to export any arbitrary information that is deemed useful
    for debugging. Debugfs provides function interfaces used to enumerate virtual
    files and is generally mounted to the `/sys/debug` directory. Debugfs is used
    by tracing mechanisms such as ftrace to present function and interrupt traces.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other special filesystems such as pipefs, mqueue, and sockfs;
    we shall touch upon a few of them in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, we have gained a generic understanding of a typical filesystem,
    its fabric and design, and what makes it an elemental part of an operating system.
    This chapter also emphasizes the importance and elegance of abstraction, using
    the common, layered architecture design which the kernel comprehensively imbibes.
    We have also stretched our understanding of the VFS and its common file interface
    that facilitates the common file API and its internal structures. In the next
    chapter, we will shall explore another facet of memory management called a virtual
    memory manager that deals with process virtual address spaces and page tables.
  prefs: []
  type: TYPE_NORMAL
