- en: Chapter 2. Revisiting Linux Network Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you have a lot of knowledge of Linux networking or you are just getting
    started, we will round off the basics of Linux networking in this chapter. While
    the TCP/IP stack in Linux is implemented with the same features as in other platforms,
    specific tools are used to manage such networks. Here, we'll discuss how Linux
    handles IP addressing, network device naming, as well as bringing interfaces up
    and down. In addition, we'll discuss the graphical and nongraphical tools used
    to manage our interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the TCP/IP protocol suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming the network device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Linux hostname resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the iproute2 and net-tools suites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing network interfaces manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing connections with Network Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the TCP/IP protocol suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP is the most popular networking protocol in existence. Not only is it
    the primary protocol suite of the Internet, it's something that you can find on
    just about any device that supports network connectivity in one form or another.
    Your computer understands this suite very well, but nowadays your phone, TV, and
    perhaps even a kitchen appliance or two supports this technology. It really is
    everywhere. Although TCP/IP is often referred to as a protocol, it's actually
    a **protocol suite** made up of several individual protocols. From the name, I'm
    sure you can gather that two of them are the TCP and IP protocols. In addition,
    there is also a third, UDP, which is part of this protocol suite as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP** is an acronym for **Transmission Control Protocol**. It''s responsible
    for breaking down network transmissions into sequences (also known as packets
    or segments), which are then sent to the target node and reassembled back into
    the original message by TCP on the other end. In addition to managing packets,
    TCP also ensures that they were properly received (to the best of its ability).
    It does this via **error correction**. If a packet is not received by the target,
    TCP will resend it. It knows to do this because of the **retransmission time**r.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss error correction and retransmission, let's first take a look
    at the actual process that TCP uses to send data. When setting up a connection,
    TCP performs a **three-way handshake**, which consists of three special packets
    that are sent between the communicating nodes. The first packet, **SYN** (**synchronize**),
    is sent to the receiver by the sender. Essentially, it's how the node announces
    that it wants to start a communication. On the receiving end, once (and if) the
    packet is received, a **SYN/ACK** (**synchronize acknowledgment**) packet is sent
    back to the sender. Finally, an **ACK** (**acknowledge**) packet is sent to the
    receiver from the sender, which is an overall verification that the transfer is
    all set to proceed. From that point forward, the connection is established and
    the two nodes are able to send information to each other. Further packets are
    then sent, which make up the remainder of the communication.
  prefs: []
  type: TYPE_NORMAL
- en: If we lived in a perfect world, this would be all that is needed. Packets would
    never get lost in transmission, bandwidth would be unlimited, and packets would
    never get corrupted during transmission. Unfortunately, we don't live in a perfect
    world and packets are lost and/or corrupted all the time. TCP has built-in features
    to deal with these types of things. Error correction helps ensure that the packet
    which was received is the same as the one that was sent. TCP packets contain a
    checksum, and an algorithm is used to verify it. If the verification fails, the
    packet is deemed incorrect and is then discarded. This verification isn't perfect,
    so it's still possible that the file you just downloaded may still have an error
    or two, but it's better than nothing. Most of the time, it works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The flow control feature of TCP handles the speed at which data is transferred.
    While most of us geeks have a very nice set of networking hardware that is able
    to handle a ton of bandwidth, the Internet is not a consistent place. Your uber
    high-end switch may be able to handle whatever you throw at it, but that really
    doesn't matter if there is a weak link somewhere upstream within the connection.
    A network transmission is only as fast as its slowest point. While you're sending
    a transmission to another node, you're only able to send as much data as its buffer
    is able to hold. At some point, its buffer will fill up and then be unable to
    receive any additional packets until it deals with the ones it already has. Any
    additional packets sent to the receiver at this time are dropped. The sender sees
    that it is no longer receiving ACK replies, and then backs off and slows down
    its rate of transfer. This is the method that TCP uses in order to adjust the
    transfer speed according to what receiving nodes are able to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control works by utilizing what is known as a **sliding window**. The receiving
    node specifies what is known as a **receive window**, which tells the sender how
    much data it's able to receive before it becomes overwhelmed. Once this receive
    window runs dry, the sender waits for the receiver to clarify that it's ready
    to receive data again. Of course, if the receiving end sends an update to the
    sender that it is ready to receive data and the sender never gets the memo, we
    could run into a real problem if the sender waited forever for an all-clear message
    that was lost in transmission. Thankfully, we have a **persist timer** in place
    to help deal with this. Essentially, the persist timer represents how long the
    sender is willing to wait before it needs to verify that the connection is still
    active. Once the persist timer elapses, the sender transmits another packet to
    the receiver, to see whether it is able to deal with it. If a reply is sent, the
    reply packet will contain another receive window, which identifies that it is
    indeed ready to continue the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: The **IP** (short for **Internet Protocol**) handles the actual sending and
    receiving of the packets that TCP wants to send or receive. Within each packet,
    there is a destination known as an **IP address** (which we'll discuss further
    in this chapter). Each connected network interface will have its own IP address,
    which the IP protocol will use to figure out where a packet needs to go, or which
    device it is from. Together, TCP and IP make up a powerful team. TCP splits up
    a communication into packets, and IP handles routing them to their destination.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there's also **UDP** (short for **User Datagram Protocol**), which
    is part of the suite as well. It's very similar to TCP in that it breaks up a
    transmission into packets. The main difference, however, is that UDP is **connectionless**.
    This means that UDP does not verify anything. It sends the packets, but does not
    guarantee delivery. If a packet isn't received by the target, it will not be resent.
  prefs: []
  type: TYPE_NORMAL
- en: Those learning about UDP for the first time may question why such an untrustworthy
    protocol would even be considered. The fact is, in some cases, a connection-oriented
    protocol such as TCP may add unwanted overhead to certain types of transmissions.
    One example of this is contacting a colleague via Skype, which offers audio calls
    over the Internet as well as video calls. If a packet was lost by either end during
    a communication, it wouldn't make much sense to resend it. You would just hear
    a bit of static for a second or so, and retransmitting a packet certainly wouldn't
    change the fact that you had difficulty hearing a word or two. Adding error correction
    to such a transmission would be pointless and add overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing TCP/IP in its entirety would be a book in and of itself. In Linux,
    this protocol is handled in much the same way as other platforms, the real difference
    is in regards to how the protocol is managed. Throughout this book, we'll talk
    about ways we can manage this protocol and tweak our network.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the network device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nowadays, it''s not uncommon for a computer to have multiple network interfaces.
    For example, if you''re using a laptop (other than an Ultrabook), it''s likely
    that you have a wired, as well as a wireless, network interface. Each network
    interface will have its own IP address and they operate independently of each
    other. In fact, you can even route traffic between multiple interfaces, though
    this is typically disabled by default in most Linux distributions. Just like each
    interface has its own IP address, each will also be identified by the system by
    its own device name. Before we discuss this further, go ahead and take a look
    at the device names on your system. Open up a terminal and type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Naming the network device](img/B03919_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of the ip command, showing network interfaces and address assignments
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we see three network interfaces listed. The first, `lo`, is
    the local loopback adapter. The second listing, `eth0`, is the wired interface.
    Finally, `wlan0` represents the wireless interface. Given this output, you can
    deduce that there is a network cable plugged in (`eth0` has an IP address) and
    it is not currently utilizing its wireless interface (there is no IP address listed
    for `wlan0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shown previously was taken from a system running Debian. Now, let''s
    take a look at the output of the same command when run on a CentOS system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Naming the network device](img/B03919_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of the ip command, this time run from a CentOS system
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you see the difference? If you look at the wired connection, you can tell
    that it''s named quite differently than the wired connection from the Debian example.
    With Debian, it was named `eth0`. But on CentOS, it was named `enp0s3`. This brings
    us to the point of this section: network devices are named differently in CentOS
    and Debian.'
  prefs: []
  type: TYPE_NORMAL
- en: In the past, wired ethernet devices were named beginning with the prefix of
    `eth`, and wireless devices were prefixed with `wlan`. For example, the first
    wired ethernet adapter would be labeled `eth0`; the second would be `eth1`, and
    so on. Wireless devices were handled similarly as well, with the first device
    being `wlan0`, the second would be `wlan1`, and so on. With Debian, this is still
    the case (even in newer releases). However, some distributions that utilize **systemd**
    feature a different naming scheme for network devices. In fact, Debian 9 will
    change its naming scheme for interfaces once it's released.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this change is because the previous naming scheme was at times
    unpredictable. It was possible to have network device names cross when a machine
    was rebooted, causing confusion as to which interface is which. The various distributions
    deal with this problem in their own way, but systemd has a built in naming scheme
    that is based on the position of the card in the system's bus, rather than just
    using the names `eth0`, `eth1`, and so on as the devices are probed. As mentioned
    before, Debian still utilizes the older naming scheme, despite the fact that Debian
    8 also utilizes systemd. Throughout this book, we will practice systemd commands;
    however, systemd will be explained more thoroughly in [Chapter 5](ch05.html "Chapter 5. Monitoring
    System Resources"), *Monitoring System Resources*, so don't worry too much if
    you aren't aware of how it works just yet.
  prefs: []
  type: TYPE_NORMAL
- en: For the CentOS machine used in the second example, the wired network card was
    given the designation of `enp0s3`. So, what exactly does this mean? First of all,
    we know that `en` represents ethernet, and this part of the designation is given
    to wired network cards. The rest of the given name represents the position of
    the network card on the bus of the system. Since each wired card, if you had more
    than one, would reside in its own physical position, the name given to the device
    would be predictable. If you were to write startup scripts for a specific network
    interface, you can be reasonably certain that you'd be writing the script to reference
    the appropriate device.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux hostname resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a network, it''s much more convenient to look up other resources by name,
    rather than remembering the IP address of every resource we connect to. By default,
    looking up hosts by name may not function without a little configuration. For
    example, you can try the `ping` command against the name of one of your Linux
    machines, and you may or may not get a response. This is because a DNS entry for
    the resource you''re connecting to might not exist. If it doesn''t, you''ll see
    an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you ping the device by its IP, it would more than likely respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Press *Ctrl* + *C* on your keyboard to break out of your `ping` command, as
    it will ping forever if it finds a connection.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is in order for a network host to be able to contact another,
    it needs to know its IP address. If you type in a name instead of an IP address,
    the machine will attempt hostname resolution, and if there is a valid entry in
    **Domain Name System** (**DNS**) for the machine you're attempting to contact,
    you'll be able to receive a reply. In Microsoft networks with Windows-based **Dynamic
    Host Configuration Protocol** (**DHCP**) and DNS servers, it's very typical for
    the server to register a **dynamic DNS** entry whenever it assigns an IP address
    to a host. Linux-based DHCP and DNS servers are capable of dynamic DNS as well,
    but it's not configured by default and it's rarely enabled by the administrator.
    In an all Linux network or any network that doesn't assign DNS dynamically, this
    ping would most likely fail. We discuss DNS in more detail in chapter [Chapter
    6](ch06.html "Chapter 6. Configuring Network Services"), *Configuring Network
    Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, DNS is not the first place that a Linux host will look in order
    to resolve hostnames. There is also a file saved locally on the system (`/etc/hosts`)
    that your machine will check first. If an entry for the host you''re contacting
    isn''t included there, your machine will then contact its configured primary DNS
    server in order to find an IP address for the name that you entered. Here''s an
    example of a `host` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `hosts` file presented, we can see an entry for `localhost` and an entry
    for `trinity-debian`. Both of these entries, which begin with a `127.0.x.x` IP
    address, represent the machine itself. To test this, try pinging `localhost` as
    well as the name of your machine (in this case, `trinity-debian`). Either way,
    you''ll get a reply. This is because the machine is aware of its hostname, and
    `localhost` uses the loopback adapter to reach itself. If you desired to do so,
    you could create additional name to IP address matches within this file. For example,
    if you had a computer named `potato` at IP address `10.10.96.10`, you could add
    it to the end of the `hosts` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: From now on, you'd be able to reach IP address `10.10.96.10` by typing in `potato`.
    You could ping it, or even enter it into the address bar of your browser (providing
    the machine was serving web content). In fact, the host entry doesn't even need
    to be a local resource in your network. You could even enter an IP address for
    an external website, and reach it by a different name. However, this only works
    in theory—a well-designed website may not operate under such circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `/etc/hosts` is checked first, your Linux installation includes a file,
    `/etc/nsswitch.conf` that it uses to make the ultimate determination on the order
    in which host resolution occurs. The line in question begins with `hosts`, and
    you can easily check the host resolution order on your machine with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the system is set up to check `files` first, which represents
    local files, which includes `/etc/hosts`. If the search is for a local domain
    and it is not found, the `NOTFOUND=return` entry causes the remainder of the search
    to abort. If you're searching for anything else, the next resource that will be
    used is DNS, as shown with `dns` being the last entry. Unless you changed this
    file, chances are that your distribution will also be set up to look within local
    hosts files first, and then DNS if the resource is not found locally.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the net-tools and iproute2 suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For quite some time, **net-tools** has been the suite of tools used to manage
    network connections on Linux systems. The net-tools suite includes commands such
    as `ifconfig`, `route`, `netstat`, and others (which we''ll discuss shortly).
    The problem with net-tools is that it hasn''t been updated by its developers in
    well over a decade, making many distributions opt to abandon it in favor of the
    **iproute2** suite, which offers the same functionality (but with different commands
    to achieve the same goals). Even though net-tools are being deprecated, quite
    a few distributions still include it. For example, Debian includes both iproute2
    and net-tools, so you can use commands from either suite. In CentOS, iproute2
    is present though net-tools is not installed by default. If you would like to
    utilize the older net-tools, you can install it in CentOS with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, why would you want to install `net-tools` if it's being abandoned? Many
    systems still have scripts that use commands from the net-tools suite, so it's
    not something that will disappear from the Linux community any time soon. Learning
    net-tools, as well as the newer iproute2, will enable you to easily adapt to any
    environment. This is especially the case for older data centers that are using
    older distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see these suites in action. First, to report basic information about
    your network connections, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the net-tools and iproute2 suites](img/B03919_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of the ifconfig command
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see statistics from both the internal wired connection (`eth0`)
    as well as the loopback adapter (`lo`). We see `HWaddr`, which is the **MAC address**
    of the network card. We also have `inet addr`, which is the IP address that the
    card was provided by the **DHCP server**. In addition, we can see the subnet mask,
    `Mask`, which is `255.255.252.0` in this case. While troubleshooting networking
    issues, we would use this tool to check these basic things, such as ensuring we
    have an IP address and we are on the appropriate subnet. In addition, we can also
    see the number of packets sent and received on the interface, as well as the number
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the iproute2 suite, we can find most of the same information with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output from a reference machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the net-tools and iproute2 suites](img/B03919_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output from the ip addr show command
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the information reported is mostly the same, though the layout
    is a bit different. For example, one difference is that you don''t see the number
    of packets sent and received, nor an error count (by default). In the past, the
    following command would show the IP addresses in use as well as sent and received
    packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Understanding the net-tools and iproute2 suites](img/B03919_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output of the ip addr show command with the -s flag added
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, recent versions of the iproute2 suite don't seem to show this
    information anymore (despite adding the `-s` switch), but we'll look at additional
    tools later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of `addr` in the previous commands, you can also type out the entire
    string (address) such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output will be the same. The commands shown in these examples were condensed,
    which save typing time.
  prefs: []
  type: TYPE_NORMAL
- en: The iproute2 suite features many more commands than just these, and we'll discuss
    them as the book continues. For now, it's important to understand the difference
    between the two command suites and to note that net-tools won't be available forever.
    In the time period in which this book was written, both are common. However, iproute2
    is the name of the game going forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before closing out this section, there''s a really easy command in the iproute2
    suite that might prove useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This simple command just prints the hostname of the machine on which your shell
    is attached. If you're using your default bash prompt, chances are you are already
    aware of your machine's hostname. However, the hostname command can at least help
    you verify that your device is reporting the hostname you think it should be;
    this can be useful when you're dealing with name resolution issues.
  prefs: []
  type: TYPE_NORMAL
- en: Manually managing network interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, after you install your desired distribution of Linux, it receives
    an IP address via DHCP and away it goes. Whether you're using a graphical desktop
    environment or a shell environment with no GUI, the magic mostly happens in the
    background. While there are GUI tools to manage your network connections, anything
    you can do via a graphical tool, you can do via the shell. In the case of servers,
    there may not be a graphical environment at all, so learning how to manage your
    network connection via the shell is very important. In this section, we'll discuss
    the method for manually configuring an interface in Debian, and then discuss how
    to do the same thing with CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, two methods were discussed for finding your current
    IP address. Depending on whether your distribution ships net-tools or iproute2,
    you can use one method or the other (or both). Of course, that''s the first step.
    Do you have a connection? Checking to see whether or not you have an IP address
    is a logical place to start. You can also utilize a simple ping test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you do get a response, chances are that you have a network connection. However,
    if you don't get a response, it doesn't necessarily mean that there's something
    wrong with your network. Some sites are configured to not respond to ping tests.
    Whenever possible, ping against local resources instead (such as your local DNS
    or DHCP server).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, ping works a bit differently than in Windows. For starters, the `ping`
    command in Linux will run virtually forever by default. To break out of it, press
    *Ctrl* + *C* on your keyboard. If you prefer to have `ping` stop after a certain
    number of tries, add the `-c` flag accompanied by the number of times you''d like
    it to attempt. In this case, our `ping` command will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `ping` will attempt four times, stop, and then report some basic
    statistics to you.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to check whether or not you're connected is one thing, but what
    do you do when you're not? Or what if your network connection is active, but reports
    invalid information and you need to reconfigure it?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s explore how to check our current configuration. In Debian, the
    file that controls the network devices by default is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Depending on several variables, which include how you configured your Debian
    installation, this file may be created differently. First, you may see several
    interfaces listed, such as your loopback adapter, wired Ethernet, and wireless.
    If you have more than one wired interface, you'll see any additional adapters
    here as well. This file is, simply put, a **configuration file**. It's a text
    file that contains information that the underlying Linux system understands, and
    causes a device to be configured as designated in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To edit files such as these, there are many Linux text editors available, both
    GUI and terminal based. My personal favorite is **vim**, though many administrators
    typically start off with **nano**. The nano text editor is fairly easy to use,
    though very light on features. Alternatively, vim has many more features than
    nano but is a bit harder to get used to. Take your pick. To open a file in nano,
    all you need to do is type `nano` along with the name of a text file you would
    like to edit. If the file doesn''t exist, the command will create it if you save
    the file. In the case of our `/etc/network/interfaces` file, the command will
    be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using nano is simply a matter of opening a file, using the arrow keys on your
    keyboard to move the insertion point to where you want to type, pressing *Ctrl*
    + *O* to save the file, and pressing *Ctrl* + *X* to exit. There are more features,
    but for the purposes of editing our configuration files, that's all we need for
    now. A tutorial for vim is beyond the scope of this book, but feel free to play
    around with it if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Now, back to the subject of our `/etc/network/interfaces` file. It's important
    to note that this file is not required for the purposes of ethernet and wireless
    adapters. If you see nothing in this file at all (other than the loopback device)
    it means that the network connections are being managed by **Network Manager**.
    Network Manager is a graphical tool for managing client-side network connections
    (which we'll discuss later in this chapter). For our purposes in this section,
    Network Manager is typically installed when you decide to include a graphical
    desktop environment when setting up Debian for the first time. If you did opt
    for a graphical environment (such as GNOME, Xfce, and so on), then Network Manager
    was more than likely set up for you and is handling the job of configuring your
    interfaces. If your `interfaces` file is blank other than the entry for the loopback
    adapter, then that means Network Manager is handling this task.
  prefs: []
  type: TYPE_NORMAL
- en: With Debian, it's extremely common to see installations in the wild with no
    graphical environment installed at all. A GUI is usually not necessary for the
    server to fulfill its purpose. A typical Linux administrator will configure a
    server with the minimum required packages for it to do its job, which often will
    not include a desktop environment. In this case, Network Manager may not be installed
    at all. If it's not, the `/etc/network/interfaces` file will then be responsible
    for setting up the connection. In other cases, perhaps Network Manager is installed,
    but was disabled by the administrator whom configured the network connections
    in this file instead.
  prefs: []
  type: TYPE_NORMAL
- en: So, when should you use Network Manager, and when should you just configure
    your connections in the `interfaces` file? In the case of end-user workstations
    (desktops and laptops), Network Manager is almost always preferred. In the case
    of servers, setting up the configuration in `/etc/network/interfaces` is preferred,
    especially when setting up a static IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve discussed what the `interfaces` file is, and when you''d want to use
    it. Now, let''s take a look at `some` various types of configurations you can
    expect to see. First, let''s gander at the `interfaces` file when only the local
    loopback adapter is listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comments are declared with the first character `#`, which is ignored when the
    configuration file is parsed. In the previous example, the first line is ignored
    and it just serves as information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the machine most likely has Network Manager in use, as neither
    the wired (typically `eth0`) or wireless (typically `wlan0`) interfaces are shown.
    To verify this, we can check to see if Network Manager is running via the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If Network Manager is running, you might see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That mystery is solved; the machine uses Network Manager, so there is no configuration
    for `eth0` or `wlan0` stored in `/etc/network/interfaces`. Now, let''s take a
    look at an example from a machine where Network Manager is not being used. To
    configure `eth0` in such an installation, the `interfaces` file would look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we still have the loopback entry as we did before, but at the
    end of the file, configuration details were included for `eth0`. Just as in our
    loopback entry, we declare `auto` and then an interface name `eth0`, which means
    that we would like interface `eth0` to automatically come up. In the next line,
    we clarify that we'd like to utilize `dhcp` for interface `eth0` so that it will
    obtain an IP address automatically from a DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, there's no good reason to abandon Network Manager in favor
    of manually configuring the connection when all we're going to do is use DHCP.
    However, this example was included here because it's actually fairly common in
    situations where a server receives a **static lease** from a DHCP server, rather
    than a dynamic one. With a static lease, the DHCP server will provide the same
    IP address for a particular MAC address each time. So in such a scenario, a server
    could have a designated IP address for it, but the IP address is still provided
    by a DHCP server. This is also known as a **DHCP reservation**.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's also possible (and perhaps more common) to simply declare a
    static IP in the interfaces file. We'll even explore that method next. But a static
    lease is worth pointing out because it does carry with it an additional benefit.
    With a static lease, the node's IP configuration is not tied to its configuration
    with its installed distribution. If it's booted from live media, or even if the
    distribution is reinstalled, the node will still receive the same IP address each
    time its interface comes up. An additional benefit of a static lease is that you
    can configure the static IPs of all your nodes in one central place (on the DHCP
    server), rather than keep track of individual configuration files from machine
    to machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that seeing `dhcp` listed in the `interfaces` file for
    an interface does not always mean that a static lease is in use. For Debian, it's
    common for an administrator to simply not install Network Manager, and then manually
    type the `interfaces` file when bringing up a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at an example `interfaces` file where a static IP has been
    manually configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice the change in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we declare `static` instead of `dhcp`. If we had forgotten to change
    this, all the remaining lines of the configuration file would then be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we declare the statistics for interface `eth0`. We set the IP address
    to `10.10.10.12`, the subnet mask to `255.255.248.0`, the network we're joining
    to `10.10.10.0`, the broadcast ID as `10.10.10.255`, and the gateway as `10.10.10.1`.
    We'll discuss what each of these values actually mean later on in this book, but
    for now the important thing to note is the syntax for this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now you may be wondering how we make these changes take effect, now that
    we went through the trouble of configuring our interface. To do so, you would
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With CentOS, the process of manually configuring network interfaces is a bit
    different to Debian systems. First, we''ll need to know which interfaces are installed
    on our machine. Running the following command will list them, along with any IP
    addresses that are currently assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, I''ll use `enp0s3`, which is the default on the test machine
    used for this book. If yours differs, change these example commands accordingly.
    Anyway, now that we know what interface we''re working with, let''s configure
    it. Next, navigate to the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you list the storage for the files within that directory (the `ls` command),
    you should see a configuration file with a name that matches the name of your
    interface. In our example of `enp0s3`, you should see a file named `ifcfg-enp0s3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this file with your chosen text editor and you''ll see the configuration
    looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this default file is using `dhcp`, which is listed on the third
    line. To configure this connection to utilize a static address, we''ll need to
    change the file accordingly. Changes to the file are marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we made just four changes to the file. First, we changed `BOOTPROTO`
    to `static`. Then, we added the following brand new lines just underneath it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure you can gather what the first two lines are responsible for. The fourth
    line we added may be obvious too, but just in case it isn't, we're basically telling
    our system that we would rather not manage our connection via Network Manager,
    and would like to take care of that ourselves with this configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we need to restart networking in order for these changes to take
    effect. Since CentOS uses systemd (just like Debian 8), the command is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And, there you have it. We took care of manually setting up our network interfaces
    in both Debian and CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: Managing connections with Network Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we just went through the trouble of manually configuring our network interfaces,
    it's not always the case that this is desirable. End user workstations, for example,
    would benefit from Network Manager handling this job for us. For laptops and their
    wireless interfaces, Network Manager does the job better than most of us would.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network Manager is usually installed by default in most distributions of Linux.
    For Debian, it is typically installed whenever you opt for a graphical desktop
    environment. If you opted for a shell-only install (you unchecked the options
    for a desktop environment during installation), you probably don''t have it installed.
    To be sure, execute the following command (works on both Debian and CentOS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see that Network Manager is running, then it is installed. But to be
    double-sure, you can execute this command in Debian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If Network Manager is installed, you''ll see it listed as follows (there will
    be an `i` designation to the left of it):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In CentOS, you can check whether Network Manager is installed or not using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re running a desktop environment, you may have an implementation of
    Network Manager running within your system tray. If so, feel free to manage your
    connection via the available GUI tools. Depending on which desktop environment
    you''re using, the instructions for doing so will be different. In this section,
    we discuss a more universal approach to utilizing Network Manager to configure
    connections. This method is to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `nmtui` command allows you to configure Network Manager within a shell environment,
    but with GUI-like controls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing connections with Network Manager](img/B03919_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a system's network connection via nmtui
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on **Edit a connection**, we will see a list of interfaces available
    on our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing connections with Network Manager](img/B03919_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: nmtui interface selection
  prefs: []
  type: TYPE_NORMAL
- en: When we select an interface, we'll first see some basic information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing connections with Network Manager](img/B03919_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First screen of editing a connection in nmtui
  prefs: []
  type: TYPE_NORMAL
- en: To edit the IP address for this interface, press the down arrow key to select
    **<AUTOMATIC>** on the left-hand side of **IPv4 CONFIGURATION** and press *Enter*.
    Then, press the right arrow key to select the **<Show>** option and expand the
    remaining fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing connections with Network Manager](img/B03919_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Editing a connection with nmtui
  prefs: []
  type: TYPE_NORMAL
- en: To edit an item, press the down arrow key to the **<Add...>** option next to
    the field. It will expand a textbox to allow you to edit the item.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing connections with Network Manager](img/B03919_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Editing a connection with nmtui
  prefs: []
  type: TYPE_NORMAL
- en: When finished, scroll all the way down and press *Enter* on **<OK>** to save
    your changes. There you have it; you should be able to manage your connections
    via Network Manager, should you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of TCP/IP networking in Linux and even
    configured our interfaces manually. We explored how to edit the configuration
    files associated with Debian and CentOS, as well as how to restart networking
    on both platforms. We briefly talked about the systemd method, though we'll explore
    systemd in more depth in [Chapter 5](ch05.html "Chapter 5. Monitoring System Resources"),
    *Monitoring System Resources*. We finished the chapter by utilizing the `nmtui`
    tool to configure Network Manager for our system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at how to use **Secure Shell** (**SSH**)
    to remotely manage our systems.
  prefs: []
  type: TYPE_NORMAL
