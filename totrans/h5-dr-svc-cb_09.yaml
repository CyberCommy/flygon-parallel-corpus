- en: Chapter 9. Client-side Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering objects using Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering objects using EJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering objects using Jade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering arrays using Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering arrays using EJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering arrays using Jade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying templates with helpers in Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing templates with partials in Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing templates with partials in EJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using filters in Jade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins in Jade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using layouts and blocks in Jade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern service apps are often built for multiple platforms, where only one of
    those platforms is the Web. Other platforms may include iOS, Android, and other
    websites that need to use the service through an API. Some of those platforms
    might not support HTML. They might also need to show different HTML for the same
    data or do preprocessing before displaying the data.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, there has been a shift in web apps from using server-side HTML
    rendering to client-side HTML rendering. The service serves the serialized raw
    data (most often as JSON, sometimes XML) and the client decides how to display
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''re going to take a look at several popular client-side
    template languages, each with a different approach to templating:'
  prefs: []
  type: TYPE_NORMAL
- en: EJS, which combines HTML with the full power of JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlebars, which combines HTML with a succinct but more restricted block structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jade, which replaces HTML syntax with a cleaner-looking version that has support
    for dynamic facilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're going to learn how to do some common tasks in each, such as displaying
    basic objects, displaying lists (or looping), and using partial templates.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering objects using Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handlebars is a template language that adds minimal syntax to HTML. Its goal
    is to minimize the amount of logic present in the template and force the passed
    model object to correspond to what should be rendered in the view.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate some of the advantages and shortcomings
    of Handlebars using a simple example. We're going to render a user greeting based
    on the time of the day.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html` containing a `name` input, a `greeting` placeholder, and
    the Handlebars template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to bind the template to the data and the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We usually embed Handlebars templates inside an HTML page by adding them to
    a `script` element with a `type` attribute set to `text/x-handlebars-template`.
    The browser ignores scripts with unknown types, so we can be sure that the content
    is left intact.
  prefs: []
  type: TYPE_NORMAL
- en: Using the template is done in two phases. In the first phase, we need to compile
    the template text. This process results with a compiled template in the form of
    a JavaScript function being returned. In the second phase, we pass a model object
    as a parameter to that function (the compiled template) and get the HTML output.
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars is a very opinionated and minimal templating language. The use of
    program logic, such as comparison operators inside the template is strictly forbidden.
    This is by design, and it is a good idea, if the business logic changes we don't
    need to update the template. For example, if we start considering the period from
    midnight to 2 a.m. as evening, we don't need to change the template – we only
    need to add the condition when creating the model, which we pass to Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can see that Handlebars sometimes goes a bit too far with
    its restrictions. For example, it doesn't support a case structure, enumerations
    or constructs such as `'else if'`. As a result, we must either resort to Boolean
    expressions for every possible state or keep the actual text or value inside the
    model. In some of those cases the model may interfere with information that belongs
    to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering objects using EJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EJS is a template language that allows users to mix HTML and JavaScript inside
    the template. Similar to PHP and ERB, it works by adding extra tags to HTML which
    allow the user to "escape" from HTML to the programming language and use the full
    facilities of that language.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to demonstrate EJS using a simple example. We're
    going to render a user greeting based on the time of the day.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download EJS from [http://embeddedjs.com/](http://embeddedjs.com/)
    and extract `ejs_production.js` in our `recipe` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html` containing a `name` input, a `greeting` placeholder, and
    an EJS `template`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to bind the template to the data and the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The common way to embed EJS templates inside the page is to add them inside
    a `script` element with a `type` attribute set to `text/ejs`. The browser ignores
    scripts with unknown types, so we can be sure that the content is left intact.
  prefs: []
  type: TYPE_NORMAL
- en: In-between the EJS opening and closing tags, `<% %>`, we can write any arbitrary
    JavaScript, which will be executed when rendering the template. The rest of the
    template is plain HTML. This makes EJS very easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to print the value of a JavaScript expression, we use a different
    opening tag, `<%=`, which prints the expression value as plain text, escaping
    any HTML contained.
  prefs: []
  type: TYPE_NORMAL
- en: To use the template, we create a new EJS object. This calls the EJS compiler,
    which compiles the template into a more efficient form. Then we can call the `render`
    method of this object, passing it the variables (data model) to use when rendering
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To print the value of an HTML expression without escaping we can use the `<%-`
    tag instead of the `<%=` tag. This enables us to insert the HTML code as DOM nodes
    (as against treating them as plain text).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering objects using Jade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jade is a clean, terse template language. It uses significant whitespace to
    denote block and element hierarchy. It supports many advanced features, for example,
    mixins, which are subtemplates and blocks, which are template sections replaceable
    by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to render a simple greeting using Jade. Later on
    in this chapter, we're going to look at some of the more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download `jade.min.js` in our `recipe` folder, available at [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`, it will contain a small form asking the user for his or
    her name, a placeholder to render the greeting, and the greeting template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to compile the template and bind it to the data and the
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jade templates are very similar to the resulting HTML structure. Our template
    produces a single `span` element containing the greeting text, and another `b`
    (bold) element containing the name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Jade supports conditionals. Their syntax looks exactly similar to the element
    syntax, except that they're not rendered. The condition doesn't need to be wrapped
    in parenthesis, but otherwise the Boolean expression is evaluated as the JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the "Good Morning" greeting, we can use the vertical pipe character
    to split the text into multiple lines
  prefs: []
  type: TYPE_NORMAL
- en: To display the contents of a variable (escaping HTML markup), we use the "`=`"
    (equals) character. If we don't want the content to be filtered we can use the
    character "`-`" (minus).
  prefs: []
  type: TYPE_NORMAL
- en: To use a Jade template, we compile it using `jade.compile`. This results with
    a `template` function. If we pass an object to this function, we're going to get
    a rendered HTML as the result. We display the HTML inside the `#greeting` element.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering arrays using Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying a list of objects is the most common reason we need a separate template
    language, otherwise we could easily get by with direct DOM manipulation. Handlebars
    has an easy, clean, and straightforward syntax for array iteration—the `each`
    construct, which works very similarly to the `for each` loops in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to render a list of message objects. Each message
    object will have an author, arrival time, body, and read status. We're going to
    use a different style to distinguish between read and unread messages.
  prefs: []
  type: TYPE_NORMAL
- en: As usual in this chapter, the template will be included in the HTML file inside
    a `script` tag. However, the compilation can be called on any string that we choose;
    it is therefore possible to download the template data by sending a request to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`, it will contain a header, the Handlebars template, the
    placeholder to render the message list, and some styles for the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to display an example array in the placeholder element
    using the `template` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handlebars have the `{{#each}}` helper, which iterates through the array passed
    as its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the block, every member variable of the array element comes into the
    current scope and is directly accessible by name. This feature greatly simplifies
    this template because it avoids the repetition of the variable name inside the
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: From this example we can see that we're not limited to using the variables inside
    the elements, we can also use them in the middle of attributes or anywhere else
    in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering arrays using EJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common tasks when using a template language is to render a list
    of items. Since EJS is based on escaping to JavaScript, rendering lists can be
    done using the loop constructs in the language.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to render a list of message objects. Each message
    object will have an author, arrival time, body, and read status. We're going to
    use a different style to distinguish between read and unread messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download EJS from [http://embeddedjs.com/](http://embeddedjs.com/)
    and extract `ejs_production.js` in our `recipe` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`, it will contain a header, the EJS template, the placeholder
    to render the message list, and some styles for the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `render` function from `example.js` with some text data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `render` function we pass a model object containing an array of messages
    to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: To render the array we use a standard JavaScript `for` loop. We can add any
    valid JavaScript code between the opening and closing tags. In our example we
    assign a variable inside the body of the loop, and then use it throughout the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: From the example it's clear that EJS allows you to escape to JavaScript at any
    point in the template text. Even escaping in HTML attributes is allowed (we are
    adding a class to our message that corresponds to the message status, read or
    unread) by escaping inside the `class` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example shows that EJS is almost as powerful as JavaScript itself. However,
    it's not recommended to write any business logic code inside the template. Instead,
    prepare your model object in a way that makes the template code straightforward
    to write.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering arrays using Jade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jade also supports rendering lists of items as other template languages. We
    can use the `each` construct to iterate through the elements in the array and
    output some HTML elements for each.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to render a list of message objects. Each message
    object will have an author, arrival time, body, and read status. We're going to
    use a different style to distinguish between read and unread messages.
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to use different backgrounds for odd and even rows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download `jade.min.js` in to our `recipe` folder available at [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html` containing the CSS style, placeholder, and the template
    `script` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to wrap the element and the template with some model data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides allowing us to access the array element, the `each` construct in Jade
    can also provide the index of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this index we demonstrate that Jade can support arbitrary expressions.
    We add an odd class to oddly-numbered messages, and an even class to evenly-numbered
    ones. Of course, it''s better to use CSS pseudo-selectors to do this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Jade allows us to omit the name of the element and only use a class and/or an
    ID attribute. In these cases the element is assumed to be a `div`.
  prefs: []
  type: TYPE_NORMAL
- en: We can append CSS style classes and an ID after the element tag. Jade will add
    the corresponding attributes to the element.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of concatenating the style classes, we can also pass a variable which
    contains an array of classes to add to the element.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying templates with helpers in Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing templates we often have the task of displaying common visual elements,
    such as alerts, dialogs, and lists. These elements may have a complex internal
    structure, and writing a template every time to map the model to this structure
    can be an error-prone and repetitive process.
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars allows us to simplify the writing of templates containing common
    elements by replacing the template for the common element with a call to helpers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to write Handlebars helpers to render links, images,
    and unordered lists. We're going to display a list of people with their name,
    photo, and link to their profile.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`, which will contain the list style, list placeholder, and
    list template. The template will utilize our new helpers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the helpers, and render the template in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside our template, we're using two new helpers, `ul` to display lists and
    the `img` tag to display images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handlebars has two different types of helpers: regular and block. Block helpers
    are invoked in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When Handlebars encounters a block, it invokes its block function, which takes
    one or two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If specified, the first argument is passed to the `helper` function. If the
    first argument is not available, the `options` argument becomes first.
  prefs: []
  type: TYPE_NORMAL
- en: The named parameters are also optional, and are available inside the `options`
    argument in the `hash` property that is, `options.hash`.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the mandatory block argument, available inside the `helper` function
    as `options.fn`. The block argument is a function that takes a context and returns
    the result of rendering the block with that context
  prefs: []
  type: TYPE_NORMAL
- en: The `else` block is also a block function (`options.inverse`). It is optional
    and can be omitted. If omitted, a default empty block function is passed as `options.inverse`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: In our example we pass the list contents to our `ul` helper. This helper uses
    the regular block on each item if there are items in the list; otherwise it uses
    the alternative block to display the empty list message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other type of helper is a regular helper and can be invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Normal helpers work similarly, to the block helpers, except that they don't
    receive the block parameters. In our example, we pass the `alt` text to the rendered
    image as a named parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Both types of helpers should return the rendered HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `example.js` file, we register our two new helpers by calling `Handlebars.registerHelper`.
    This makes them available to all subsequent templates that we need to render.
    Afterwards, we can call `render` on the template with our data, which in turn
    invokes the helpers to generate the resulting HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Reusing templates with partials in Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handlebars partials are templates which can be invoked from other templates
    with a certain context.
  prefs: []
  type: TYPE_NORMAL
- en: One example use of a partial template is a user login box. Such a box would
    display the username, the number of unread notifications, and a logout link if
    the user is logged in; otherwise it would display regular login options which
    are available while using Facebook and Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Partial templates can be used instead of helpers when there are no parameters
    to be passed to the helper or when no complex logic is necessary. They're particularly
    useful when the amount of dynamically generated content is small and the amount
    of HTML is large. This is because inside partial templates, HTML can be written
    directly without the need to convert it to strings.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to use partial templates to render a threaded conversation
    model. This example also demonstrates that partial templates can be re-used recursively
    from within themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to download Handlebars from [https://github.com/wycats/handlebars.js](https://github.com/wycats/handlebars.js).
    The browser version is in the `dist` directory. Create a directory for the example
    and copy `handlebars.js` to this directory, or download directly (on Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html` which will contain the conversation placeholder, the main
    conversation template, and the recursive partial thread template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To style the displayed messages, create `style.css` and add the following CSS
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendering will be done from `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data structure of the message in this recipe is recursive. It contains
    the message details: the username and user photo, message text, and message date.
    But it also contains the replies to that message, which are messages themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: To render this structure we write a partial template for a single thread of
    conversation, specifying how to display the message details but also iterating
    through all the replies and invoking itself for every reply.
  prefs: []
  type: TYPE_NORMAL
- en: This partial template is then called once from the main template, resulting
    with a full conversation tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handlebars partial templates are called with the variables from the current
    context. Partials work just the same as we do directly to replace the call to
    the partial with the contents of the partial template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial templates can be used for headers, footers, menus, or even recursively.
    It's a recommended practice to split large reusable sections of a website into
    partial templates to avoid copying and to making these sections easier to change
    and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing templates with partials in EJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial templates are larger sections of HTML which need to be included multiple
    times from multiple pages. Common uses for partial templates include headers,
    footers, site menus, login boxes, alerts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of EJS doesn't natively support partial templates; they have
    been removed. However, there is another way to use other templates from within
    a template, by including the compiled template itself in the data model.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to render a conversation thread using a recursive
    partial template written in EJS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download EJS from [http://embeddedjs.com/](http://embeddedjs.com/)
    and extract `ejs_production.js` in our `recipe` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`, which will contain the conversation placeholder, the main
    conversation template, and the recursive partial thread template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the styles necessary to render the template in `style.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the rendering code in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message thread is a recursive data structure. It contains the message details
    (such as date, user, and text) and also the replies which are themselves message
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: To make the partial template object available inside the template, we include
    it in the passed model. Then we can call it from the template, passing it further
    inside the model of the recursive partial thread template.
  prefs: []
  type: TYPE_NORMAL
- en: This partial template displays the message details, and then proceeds to call
    itself to render every reply if such replies are available. In each call we pass
    the partial template object to make it available within the next call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process ends when there are no more threads to be rendered, resulting with
    a complete message tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though EJS doesn't natively support partials anymore, this recipe shows
    how we can still reuse EJS templates inside each other. We can easily extend this
    to full partial support by passing a table of all registered partials along with
    every model.
  prefs: []
  type: TYPE_NORMAL
- en: Using filters in Jade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jade filters are powerful features which enable the users to use different markups
    inside Jade templates. Their primary use is to make templates even more succinct
    by enabling the user to use the appropriate tool for a particular section of the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to use Jade filters to embed markdown inside our
    template and explain how filters work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client-side version of Jade [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade)
    is found in the `jade.js` file and does not support markdown filters out of the
    box. To add support for markdown we need edit this file and find the line that
    starts defining the `markdown` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And then replace it with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will inform Jade to use the globally defined markdown object, which we're
    going to provide by including an external markdown script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html` which will contain the placeholder for our template and
    the template itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the simple `example.js` file to bind the template to the element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Jade encounters the `:markdown` block, it passes the text found inside
    it to the markdown `filter` function which we previously created. This `filter`
    function calls the markdown-js to the HTML method that processes the markdown
    and generates HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using mixins in Jade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to partial templates in other template languages, Jade mixins are smaller
    template pieces that can accept parameters. Mixins are useful when generating
    common HTML chunks such as alert boxes, dialogs, and menus.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we're going to compare Jade's mixins with the partial templates
    found in the other template languages by reimplementing the threaded conversation
    template. This is a recursive template that renders a threaded conversation tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download `jade.min.js` in our `recipe` folder, available at [https://github.com/visionmedia/jade](https://github.com/visionmedia/jade).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html` which will contain the conversation placeholder, the main
    conversation template, and the recursive partial thread template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to pass the data to the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `style.css` to style the conversation thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message thread is a recursive data structure. It contains the message details
    (such as date, user, and text) and also the replies which are themselves message
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: To render this structure we wrote a Jade mixin. The mixin takes the thread as
    an argument and displays its attributes as well as the text in the top node of
    the thread.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if there are replies inside the thread object, it iterates through
    all of those replies and recursively calls itself with each reply as an argument.
    Calling a mixin is done by prefixing the mixin name with the character "+".
  prefs: []
  type: TYPE_NORMAL
- en: The main template displays the topic of the top level message in a heading.
    Afterwards it invokes the mixin with the top level thread which results in the
    rendering of the complete thread tree.
  prefs: []
  type: TYPE_NORMAL
- en: Using layouts and blocks in Jade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow us to easily create different templates, Jade supports template inheritance.
    Jade's template inheritance allows us to define a master layout template, and
    then replace parts of this template by extending the master layout.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we're going to use template inheritance to simulate a complete
    website, containing a header, a menu, some content, and a footer. The content
    will be split into two pages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client-side version of Jade does not support layouts and blocks. Specifying
    the template to extend requires access to the filesystem which is not available
    inside the browser. However, we can precompile the templates using browserify.
    To do this we're going to write a browserify plugin that registers a handler for
    the Jade files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the prerequisites first. We''re going to need `nodejs`, which
    can be downloaded from [http://nodejs.org/](http://nodejs.org/). After installing
    node from a command prompt, we''re going to install browserify Version 1 (Version
    2 has no support for plugins as of now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall create a new directory for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In that directory we will install Jade (and markdown to add markdown support
    to Jade):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the browserify plugin, `browserify.jade.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create `index.html`, which in this case is a simple placeholder for the
    content which will be filled by the templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create `example.js`, which will load the two templates and make
    the menu clicks render a different template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the content of `layout.jade` (which also renders the menu):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this to `example.jade`, which extends `layout.jade` by appending an item
    to the `menu` block and replacing the `content` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add `style.css` to give it a nice look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally let''s wrap it all into `example.min.js` by typing the following command
    in the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with `browserify-jade.js`.
  prefs: []
  type: TYPE_NORMAL
- en: This plugin works by registering the new file extension '`jade`' with browserify
    and telling it to invoke our transformation function with the contents of every
    jade file it encounters being required in our code. This means it will intercept
    both `require('layout.jade')` and `require('example.jade')`.
  prefs: []
  type: TYPE_NORMAL
- en: Our plugin function compiles the received template content using Jade, and then
    writes the code of the resulting JavaScript function. However to make sure that
    Jade helper functions are available for the generated template, it also includes
    `runtime.js` via require. This file contains the basic Jade library that all compiled
    templates need to work (adding it this way will cause browserify to include it
    in the final bundle).
  prefs: []
  type: TYPE_NORMAL
- en: 'How blocks and inheritance work:'
  prefs: []
  type: TYPE_NORMAL
- en: To make a template an inheritable layout, all we need to do is place named blocks
    inside it. In our example we have two named blocks in `layout.jade` – one for
    the menu and one for the content.
  prefs: []
  type: TYPE_NORMAL
- en: Named blocks allow us extend the template and then replace parts of the content
    with our own. We do this in the `example.jade` file. This file inherits from layout,
    appends a new menu item to the menu block using "`block append`", and completely
    replaces the content block with its own written in markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's also possible to prepend content to a block by simply using "`block prepend`".
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the `browserify` command, it combines the templates and `example.js`
    into a single file called `example.min.js`, which we include in our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result is a simple page with a heading, menu, content, and a footer block.
    When a link from the menu is clicked, the appropriate template is loaded and rendered
    on this page.
  prefs: []
  type: TYPE_NORMAL
