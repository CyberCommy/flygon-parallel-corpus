- en: Redux Bindings with connected-react-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we looked at how the component's state can be used to
    store model data and how React updates the view when the model is updated as a
    result of a user action. In large applications, this state information should
    be made available not only to the current component and its children but also
    to other components in the application tree. There are various state management
    libraries available that aid in keeping the user interface components in sync
    with the application state. Redux is one such library that uses a central data
    store to manage the state of the application. The store serves as a source of
    truth and the components in the application can rely on the state maintained in
    the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the `connected-react-router` library,
    which provides Redux bindings for React Router. The following topics are discussed
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: State management with Redux—An introduction to Redux concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with `connected-react-router`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the react-router state from the Redux store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to different routes by dispatching actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management with Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, Redux uses a single store to manage the state of the application.
    Apart from `Store`, there are two other building blocks: `Actions` and `Reducers`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how these building blocks help maintain `state` and update
    the view when `state` in `Store` changes.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actions let you define the operations that the user can perform to update the
    state of the application. An Action is a JavaScript object of the `{ type, payload
    }` shape, where `type` is a string mentioning the user action and `payload` is
    the data with which the state should be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `addTodo` action accepts a TODO text and indicates that the Action
    is used to add a TODO to a list of TODOs. `payload` here is an object containing
    the TODO `text`, a TODO `ID`, and a Boolean flag, `isCompleted` (set to false).
    It''s also possible to have actions that don''t require the `payload` property
    to be included. For example, consider the following action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `action` type `INCREMENT` indicates that the value of an entity has
    to be incremented by one. The preceding `action` does not need a `payload` property
    and based on the action type, the state of the entity can be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Reducer in Redux alters the state of an entity based on the action dispatched
    to the store. A Reducer is a pure function that accepts two parameters: `state`
    and `action`. The Reducer then returns an updated state based on the value store
    in `action.type`. For example, consider the following reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The initial state of `todoReducer` is set to an empty array (state parameter's
    default value) and a TODO is added to the list when the action type is `ADD_TODO`.
    One of the core tenets of Redux is not to mutate the state tree, but rather return
    a new state tree as a result of an action dispatched by the component. This helps
    to keep the reducer function pure (that is, with no side effects), and helps in
    recognizing the new state change when the React component re-renders the view
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there could be multiple actions that update the TODO state (such
    as `MARK_COMPLETED` and `DELETE`), and the reducer can alter the state of the
    TODO list based on the action type dispatched to the store.
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store is a central data object from which the application state can be derived.
    The components in the application subscribe to the changes in the store's state
    and update the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the data flows in Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cb8a8480-c8bd-4a97-af97-49da8821c08d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The user performs an operation, such as submitting a form or clicking a button,
    thus dispatching an action to the store. The application defines various actions
    that the user can perform and reducer is coded so that it can handle these actions
    and update the state of the entity. The state of various entities in the application
    is maintained in one central location: the store. For example, the application
    could have various entities, such as Todo and the User profile, and the store
    would maintain the state information for these entities. Whenever the reducer
    updates the state value of a particular entity in the store, the user interface
    component receives an update from the store, updating the component''s state information
    and re-rendering the view with the updated state.'
  prefs: []
  type: TYPE_NORMAL
- en: Redux in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating a project using the `create-react-app` CLI, include the dependencies
    `redux` and `react-redux` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `redux` library includes the `createStore`, `combineReducers`, `bindActionCreators`,
    `applyMiddleware`, and `compose` helper functions; whereas the `react-redux` library
    includes Redux bindings that help your React components communicate with the Redux
    store.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to define actions that the user can initiate from the user
    interface. In our example, we will create a `Counter` component that can `increment`
    and `decrement` the counter value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `actions/counter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining actions for our counter entity, the `reducer` that updates the
    state of the `counter` needs to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `reducers/counter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `reducer` defined here updates the `state` value based on the type of `action` triggered
    by the user. Similarly, you can have various reducers and actions in the application
    that update the entity's state when a certain action is triggered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `combineReducers` utility from `redux` allows you to combine all the reducers
    into one single reducer, which can then be used in `initializing` the store for
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `reducers/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A `rootReducer` is created using the `combineReducers` function, which accepts
    an object with a key-value mapping of an entity and a reducer. Here `counterReducer`
    is assigned to the `count` entity and `todoReducer` is assigned to an entity with
    the `todo` key.
  prefs: []
  type: TYPE_NORMAL
- en: '`rootReducer` is then used in the `createStore` function to create a store.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The store is made available to the components in the application using the
    `<Provider>` component defined in the `react-redux` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The components in the application can now subscribe to the state changes in
    the entities (`count` and `todo`) in the store using the `connect` higher-order
    function. A `Counter` component is created, which will display the current state
    value of `count` and will dispatch the `increment` and `decrement` actions that
    we defined in `actions/counter.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `components/counter.component.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `count`, `increment`, and `decrement` props are made available from the
    `store` using the following `connect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `connect` higher-order function from `react-redux` helps you to inject the
    Redux state into your React components. The `connect` HOC accepts two arguments: `mapStateToProps` 
    and `mapDispathToProps`. As observed, the Redux state `count` property is assigned
    to the component's state `count` property in `mapStateToProps`, and similarly,
    the component can dispatch actions to the store using the `increment` and `decrement`
    actions specified in `mapDispatchToProps`. Here, to read the state values from
    the Redux store, `mapStateToProps` is used, and `connect` provides the entire
    state tree to the component so that the component can read from various objects
    in the state tree. To alter the state of the tree, `mapDispatchToProps` helps
    in dispatching actions registered with the store. The `connect` HOC provides the
    `dispatch` method so that the component can invoke actions on the store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with connected-react-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `connected-react-router` library provides Redux bindings for React Router;
    for example, the application's history can be read from a Redux store and you
    can navigate to different routes in the application by dispatching actions to
    the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first install `connected-react-router` and other libraries using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will update the store settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createStore` function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It accepts three parameters: the first parameter is the `reducer` function,
    which returns the next state tree given the current state tree and the action
    to handle; the second parameter specifies the initial `state` of the application
    and should be an object with the same shape as the one used in `combineReducers`;
    the third parameter specifies the store `enhancer`, which adds more capabilities
    to the store, such as time travel, persistence, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the first parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`connectRouter` from `connected-react-router` wraps `rootReducer` and returns
    a new root reducer with the `router` state in it. The `connectRouter` reducer
    responds to actions with type `@@router/LOCATION_CHANGE` to update the router
    state. Notice that `connectRouter` accepts the `history` object as its parameter; `connectRouter`
    then uses the history object to initialize the router state with the `location`
    and `action` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter to `createStore` is enhancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we're specifying `enhancer` as the second parameter. The `createStore`
    method marks the second parameter as `enhancer` if it is a function and when the
    third parameter to `createStore` is not specified. The `compose` utility in `redux`
    returns a function obtained by composing given functions from right to left. In
    the previous case, we are checking whether the `Redux Devtools Extension` is available
    in the browser, which enables you to view the state of various entities in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '`routerMiddleware` defined in `connected-react-router` is a middleware function
    used to redirect the user using the provided `history` object. If an action of
    the `''CALL_HISTORY_METHOD''` type is dispatched, the middleware function will
    navigate the user to the requested route by calling one of the methods on the
    `history` object. It also prevents the action (`CALL_HISTORY_METHOD`) from reaching
    other reducers defined in the application and the middleware components that are
    defined after `routerMiddleware`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `applyMiddleware` utility in Redux is used to create a store enhancer, which
    applies middleware to the dispatch method of the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to make the store (created with `createStore`) available to
    the components in the application using the `<Provider>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have wrapped the application root component inside the `<ConnectedRouter>`
    component, which, in turn, is wrapped inside the `<Provider>` component. This
    is required since `ConnectedRouter` subscribes to the changes in the `router`
    state to see whether the `location` property has changed and then calls the `history.push` method
    to navigate the user to the requested route.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes, the components in our application can now read the state
    information from the store and also dispatch actions to navigate to various routes
    defined in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Reading state information from the Redux store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the preceding setup, let''s first create a `<Link>` component in our
    navbar and a corresponding `<Route>` with the same path name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `<Link>` component specifies the `to` object with the `pathname`,
    `search`, `hash`, and `state` properties. We will read this information from the
    Redux store in our rendered component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: From this code snippet, the `pathname`, `search`, `location`, and `hash` properties
    are read from `state.router.location`. As mentioned earlier, the `connectRouter`
    function creates the `router` state and it updates the value when an action of
    type `LOCATION_CHANGE` has been dispatched. The `<ConnectRouter>` component listens
    to the changes in the history object and then dispatches the `LOCATION_CHANGE` action
    whenever you try to navigate using the `<Link>` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Redux Dev Tools installed in Chrome (available in the Chrome Web
    Store), you can observe the action dispatched when you try to navigate from one
    route to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0e48d393-6727-4d43-8fb2-cc9ef8fb8b28.png)'
  prefs: []
  type: TYPE_IMG
- en: In this Dev Tools window, the `@@router/LOCATION_CHANGE` action is dispatched
    when you try to navigate, and the action in the following section shows the payload
    provided when dispatching the action.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating by dispatching actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `connected-react-router` library provides actions that you can dispatch
    from your components to navigate to the routes defined in the application. These
    include `push`, `replace`, `go`, `goBack`, and `goForward`. These methods call
    the corresponding methods on the history object to navigate to the specified path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DashboardComponent` in the previous example can now be updated to use
    `mapDispatchToProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding component now dispatches `push` and `replace` actions when you
    click on the HOME and the COUNTER buttons respectively. The `mapDispatchToProps` function
    enables you to dispatch actions to the store and, in our example, the `push` and
    `replace` functions accept a `pathname` to dispatch actions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how the Redux library can be used to create a
    store to manage various state entities in the application. The store receives
    actions and the reducers alter the state of the application when an action is
    dispatched. The `connected-react-router` library provides Redux bindings for React
    Router and it includes a higher-order function, `connectRouter`, which wraps `rootReducer`
    and creates a `router` state. The `connectRouter` function is then used in the
    `createStore` function to make the `router` state available to the components
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `<ConnectedRouter>` component in `connected-react-router` listens to the
    changes in the `history` location and dispatches the `LOCATION_CHANGE` action
    to update the `router` state property. This `router` state property can then be
    read by the rendered route component by reading the state information from the
    store.
  prefs: []
  type: TYPE_NORMAL
- en: The library also includes the `push`, `replace`, `go`, `goBack`, and `goForward` actions, which
    the component can dispatch to navigate to the routes defined in the application.
  prefs: []
  type: TYPE_NORMAL
