- en: State Management with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at State Management Patterns with `Vuex`.
    `Vuex` may not be needed for every application created, but it is extremely important
    that you have an understanding of what it is when it becomes appropriate to use
    it, and how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understood what `Vuex` is and why you should use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created your first Vuex store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated actions, mutations, getters, and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used the Vue devtools to step through `Vuex` mutations as they happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Vuex?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management is an important part of modern-day web applications, and managing
    this state as the application grows is a problem every project faces. `Vuex` looks
    to help us achieve better state management by enforcing a centralized store, essentially
    a single source of truth within our application. It follows design principles
    similar to that of Flux and Redux and also integrates with the official Vue devtools
    for a great development experience.
  prefs: []
  type: TYPE_NORMAL
- en: So far, I've spoken about *state* and *managing state*, but you may still be
    confused as to what this really means for your application. Let's define these
    terms in a little more depth.
  prefs: []
  type: TYPE_NORMAL
- en: State Management Pattern (SMP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define a state as the current value(s) of a variable/object within our
    component or application. If we think about our functions as simple `INPUT ->
    OUTPUT` machines, the values stored outside of these functions make up the current
    condition (state) of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note how I've made a distinction between **component level** and **application
    level** state. The component level state can be defined as state confined to one
    component (that is, the data function within our component). Application level
    state is similar but is often used across multiple components or services.
  prefs: []
  type: TYPE_NORMAL
- en: As our application continues to grow, passing state across multiple components
    gets more difficult. We saw earlier in the book that we can use an Event bus (that
    is, a global Vue instance) to pass data around, and while this works, it's much
    better to define our state as part of a singular centralized store. This allows
    us to reason about the data in our application much easier, as we can start defining
    **actions** and **mutations** that always generate a new version of state, and
    managing state become much more systemized.
  prefs: []
  type: TYPE_NORMAL
- en: Event bus is a simple approach to state management relying on a singular view
    instance and may be beneficial in small Vuex projects, but in the majority of
    cases, Vuex should be used. As our application becomes larger, clearly defining
    our actions and intended side effects with Vuex allows us to better manage and
    scale the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example of how all this fits together can be seen in the following
    screenshot ([https://vuex.vuejs.org/en/intro.html](https://vuex.vuejs.org/en/intro.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cda49897-a62e-4bc1-8d9d-a3ae96d0005d.png)Vuex state flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down this example into a step-by-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial **State** is rendered inside of a Vue component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Vue component dispatches an **Action** to get some data from a **Backend API**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This then fires a **Commit** event that is handled by a **Mutation**. This **Mutation**
    returns a new version of the state containing the data from the **Backend API**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process can then be seen in the Vue **Devtools**, and you have the ability
    to "time travel" between different versions of the previous state that takes place
    within the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new **State** is then rendered inside of the **Vue Components**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main component of our Vuex application(s) is, therefore, the store, our
    single source of truth across all component(s). The store can be read but not
    directly altered; it must have mutation functions to carry out any changes. Although
    this pattern may seem strange at first, if you've never used a state container
    before, this design allows us to add new features to our application in a consistent
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: As Vuex is natively designed to work with Vue, the store is reactive by default.
    This means any changes that happen from within the store can be seen in real time
    without the need for any hacks.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a thought exercise, let's start off by defining the goals for our application
    as well as any state, actions, and potential mutations. You don't have to add
    the following code to your application just yet, so feel free to read on, and
    we'll bring it all together at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by considering the state as a collection of key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For our counter application, we just need one element of stateâ€”the current count.
    This will likely have a default value of `0` and will be of type number. As this
    is likely the only state inside of our application, you can consider this state
    to be application level at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's think about any action types that the user may want to take our
    counter application.
  prefs: []
  type: TYPE_NORMAL
- en: 'These three action types can then be dispatched to the store and thus we can
    perform the following mutations, returning a new version of state each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increment**: Add one to the current count (0 -> 1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decrement**: Remove one from the current count (1 -> 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reset**: Set the current count back to zero (n -> 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can imagine that at this point, our user interface will be updated with the
    correct bound version of our count. Let's implement this and make it a reality.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've had a detailed look at what makes up an application driven by
    `Vuex`, let's make a playground project to take advantage of these features!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start off by creating a file named `index.js` inside `src/store`. This
    is the file we'll use to create our new store and bring together the various components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by importing both `Vue` and `Vuex` as well as telling Vue that
    we''d like to use the `Vuex` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then export a new `Vuex.Store` with a state object that contains all
    of our application states. We''re exporting this so that we can import the state
    in other components when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining action types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can then create a file inside `src/store` named `mutation-types.js`, which
    contains the various actions that the user may take within our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although we don't have to explicitly define our actions like this, it's a good
    idea to use constants where possible. This allows us to take better advantage
    of tooling and linting techniques, as well as allowing us to infer the actions
    within our entire application at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use these action types to commit a new action to be subsequently handled
    by our mutations. Create a file inside `src/store` named `actions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside each method, we''re destructuring the returned `store` object to only
    take the `commit` function. If we didn''t do this, we''d have to call the `commit`
    function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we revisit our state diagram, we can see that after committing an action,
    the action is picked up by the mutator.
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A mutation is the only method in which the state of the store can be changed;
    this is done by committing/dispatching an action, as seen earlier. Let''s create
    a new file inside `src/store` named `mutations.js` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You'll note that once again, we're using our action types to define the method
    names; this is possible with a new feature from ES2015+ named computed property
    names. Now, any time that an action is committed/dispatched, the mutator will
    know how to handle this and return a new state.
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now commit actions and have these actions return a new version of the
    state. The next step is to create getters so that we can return sliced parts of
    our state across our application. Let''s create a new file inside `src/store`
    named `getters.js` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have a minuscule example, the use of a getter for this property isn''t
    entirely necessary, but as we scale our application(s), we''ll need to use getters
    to filter state. Think of these as computed properties for values in the state,
    so if we wanted to return a modified version of this property for the view-layer,
    we could as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Combining elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to pull this all together, we have to revisit our `store/index.js`
    file and add the appropriate `state`, `actions`, `getters`, and `mutations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `App.vue`, we can create a `template` that will give us the current
    count as well as some buttons to `increment`, `decrement`, and `reset` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the user clicks on a button, an action is dispatched from within one
    of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we''re using constants to make for a better development experience.
    Next, in order to take advantage of the getter we created earlier, let''s define
    a `computed` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have an application that displays the current count and can be incremented,
    decremented, or reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89a16d62-66d5-4e32-90f7-7d8d8e0c604b.png)'
  prefs: []
  type: TYPE_IMG
- en: Payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we wanted to let the user decide how much they wanted to increment the
    count? Let's say we had a textbox that we could add a number and increment the
    count by that much. If the textbox was set to `0` or was empty, we'd increment
    the count by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our template would, therefore, look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d place the amount value on our local component state, as this doesn''t
    necessarily need to be part of the main Vuex Store. This is an important realization
    to make, as it means we can still have local data/computed values if necessary.
    We can also update our methods to pass the amount through to our actions/mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have to update `actions.js` as this now receives both the `state` object
    and our `amount` as an argument. When we use `commit`, let''s also pass the `amount`
    through to the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, our mutations look similar to before, but this time we increment/decrement
    based on the amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Ta-da! We can now increment the count based on a text value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4061a26c-2e6b-4d07-bbd9-2a3648259a74.png)'
  prefs: []
  type: TYPE_IMG
- en: Vuex and Vue devtools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a consistent way of interacting with our store via actions,
    we can take advantage of the Vue devtools to see our state over time. If you haven't
    installed the Vue devtools already, visit [Chapter 2](238a1f48-501e-4512-8331-1dbe6d7bc0fa.xhtml),
    *Proper Creation of Vue Projects*, to find more information regarding this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the counter application as an example, to ensure that you have
    this project running, and right click on Inspect Element from within Chrome (or
    your browser''s equivalent). If we head over to the Vue tab and select Vuex, we
    can see that the counter has been loaded with the initial application state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca392021-f7a8-4315-aa1b-cf5cf83597a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, you can see the count state member as well as
    the value of any getters. Let''s click on the increment button a few times and
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/156c812f-8a82-40c6-92c6-4f76d75b84d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome! We can see the INCREMENT action as well as a subsequent change to
    the state and getters, and more information about the mutation itself. Let''s
    see how we can time travel throughout our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6af553b2-d7ed-4625-bfa0-e254c368672a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, I''ve selected the time travel button on the first
    action. You can then see that our state is reverted to count: 1, and this is reflected
    in the rest of the metadata. The application is then updated to reflect this change
    in state, so we can literally step through each action and see the results on
    screen. Not only does this help with debugging, but any new state that we add
    to our application will follow the same process and be visible in this manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s hit the commit button on an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e644b281-6abc-4363-bd02-da43536bdea9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this merges all of our actions up to when we hit commit to then
    be part of our Base State. As a result, the count property is then equal to the
    action you committed to Base State.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, we have everything in root state. As our application gets larger,
    it would be a good idea to take advantage of modules so that we can appropriately
    split our container into different chunks. Let's turn our counter state into its
    own module by creating a new folder inside `store` named `modules/count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then move the `actions.js`, `getters.js`, `mutations.js`, and `mutation-types.js`
    files into the count module folder. After doing so, we can create an `index.js`
    file inside the folder that exports the `state`, `actions`, `getters`, and `mutations`
    for this module only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve also elected to export the mutation types from the `index.js` file, so
    we can use these within our components on a per-module basis by importing from
    `store/modules/count` only. As we''re importing more than one thing within this
    file, I gave the store the name of `countStore`. Let''s define the new module
    inside `store/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `App.vue` then changes slightly; instead of referencing the types object,
    we reference the types specifically from this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can then add more modules to our application by having the same files/structure
    as our count example. This allows us to scale as our application continues to
    grow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took advantage of the `Vuex` library for consistent state
    management within Vue. We defined what state is as well as component state and
    application-level state. We learned how to appropriately split our actions, getters,
    mutations, and store between different files for scalability as well as how to
    call these items within our components.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at using the Vue devtools with `Vuex` to step through mutations
    as they happened within our application. This gives us the ability to better debug/reason
    about the decisions we make when developing applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at testing our Vue applications and how to let
    our tests drive our component design.
  prefs: []
  type: TYPE_NORMAL
