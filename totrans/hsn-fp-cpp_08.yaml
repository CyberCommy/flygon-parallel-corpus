- en: Thinking in Functions - from Data in to Data out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my journey toward understanding functional programming, I hit a difficult
    hurdle—my mind was trained in a completely different style of programming. Let's
    call it imperative object-oriented programming. So, how could I shift my thought
    patterns from thinking in objects to thinking in functions? And how could I mix
    these two in a good way?
  prefs: []
  type: TYPE_NORMAL
- en: I first looked into functional programming resources. Unfortunately, most of
    them are focused on the mathematics and the inner beauty of the concepts—which
    is great for anyone who can already think in these terms. But what if you're just
    trying to learn them? Is going through mathematical theories the only way to learn?
    While I like math, I'm rusty at it, and I'd rather find more practical ways.
  prefs: []
  type: TYPE_NORMAL
- en: I've then been exposed to various ways of writing code through events such as
    Coderetreats, Coding Dojos, or pair programming with programmers from around Europe.
    And I realized, little by little, that there's a simple approach to fixing this
    problem—just focus on inputs and outputs instead of focusing on the model between
    them. That's a much more concrete and practical way to learn to think in functions,
    and this is what we'll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of a functional mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relearning how to identify data in and data out for features and taking advantage
    of type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining data transformations as pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use typical data transformations such as a map, reduce, filter, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the functional mindset to solve a problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing error management for code designed around functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp),
    in the `Chapter06` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https://github.com/onqtam/doctest](https://github.com/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: From data in to data out through functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My computer programming education, and my focus as a programmer, was mostly
    on writing code rather than deeply understanding input and output data. This focus
    changed when I learned **test-driven development** (**TDD**), since this practice
    forces the programmer to start from inputs and outputs. Through applying an extreme
    form called **TDD As If You Meant It**, I gained a new appreciation for the core
    definition of a program—something that takes input data and returns output data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It wasn''t easy, though. My training was pushing me back to thinking of the
    things that form the program. But then, I realized that those things can just
    be pure functions. After all, any program can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of pure functions, as previously defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of functions that interact with **input/output** (**I/O**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we reduce the program to the minimum and separate everything that is I/O,
    figure out the I/O for the rest of the program, and write pure functions for everything
    we can, we've just made our first steps for thinking in functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next question is—what should those functions be? In this chapter, we will
    look into the simplest way of designing with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from data in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the data out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a series of transformations (pure functions) that turn the data in into
    the data out step by step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see a few examples contrasting the two approaches of writing the program.
  prefs: []
  type: TYPE_NORMAL
- en: A worked example of imperative versus functional style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show the differences between approaches, we will need to use a problem. I
    like practicing new programming techniques using problems derived from games.
    On the one hand, it's a fun domain that I don't work with very often. On the other
    hand, games provide a lot of challenges that common business applications don't,
    thereby allowing us to explore new ideas.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will look at one problem that allows people to
    learn how to start thinking in functions—**the tic-tac-toe result ****problem**.
  prefs: []
  type: TYPE_NORMAL
- en: Tic-tac-toe result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tic-tac-toe result problem has the following requirements—given a tic-tac-toe
    board that's either empty or already has moves, print out the result of the game,
    if the game has ended, or print out the game that is still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: It looks as if the problem is fairly simple, yet it will show us a fundamental
    difference between the functional and imperative **object-oriented** (**OO**)
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: If we approach the problem from an OO perspective, we're already considering
    some objects to define—a game, a player, a board, maybe some representation for
    `X` and `O` (which I call tokens), and so on. We might then be looking at how
    to connect these objects—a game has two players and a board, and the board has
    tokens or empty fields on it and so on. As you can see, there's a lot of representation
    involved. Then, we need to implement a `computeResult` method somewhere that returns `GameState`,
    either `XWon`, `OWon`, `draw`, or `InProgress`. At first glance, it looks as if
    `computeResult` fits into the `Game` class. That method will probably need to
    loop inside `Board`, use some conditional statements, and return the corresponding
    `GameState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the OO approach, we''ll use a few strict steps to help us
    think differently about the code structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly define the input; give examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clearly define the output; give examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify a chain of functional transformations that you can apply to the input
    data to turn it into the output data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we move on, please be aware that this mindset change requires a bit of
    knowledge and practice. We will look into the most common transformations to provide
    you with a good start, but you will need to try this method for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs and outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lesson we learned as programmers is that any program has an input
    and an output. We then proceed to focus the rest of our careers on what happens
    between the input and the output, in the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output deserve more attention from programmers, though, because they
    define the requirements of our software. And we know that the biggest waste in
    software is to implement something that works perfectly but doesn't do what it
    was supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: I've noticed that it's very difficult for programmers to go back to thinking
    in terms of input and output. The seemingly simple question of what the input
    and what the output for a given feature should be often leaves them baffled and
    confused. So, let's look in detail at the input and output data for our problem.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we will do something unexpected. I've learned a neat trick from
    business analysts—it's best to start from the output when analyzing a feature
    because the output tends to be smaller and clearer than the input data. So, let's
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: What is the output data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What do we expect as outputs? Given that the board can have anything on it,
    or nothing at all, we are looking at the following possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Game not started*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Game in progress*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` won'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O` won'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See, the output is simple! Now, we can see how the input data relates with these
    possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: What is the input data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, the input data is in the problem statement—our input is a board
    with moves on it. But let''s look at some examples. The simplest example is an
    empty board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For clarity, we use `_` to represent an empty space on the board.
  prefs: []
  type: TYPE_NORMAL
- en: The empty board corresponds, of course, to the *game not started* output.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s simple enough. Now, let''s see one with a few moves on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `X` and `O` have made their moves, but the game is still in progress.
    There are many examples we can provide of *game in progress*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few examples that could never happen in a tic-tac-toe game, such
    as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `X` has made four moves, while `O` has made only one, which is
    something the tic-tac-toe rules wouldn't allow. We will ignore this situation
    for now and just return a *game in progress*. You can, however, implement your
    own algorithm for this once we finish the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a game won by `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`X` wins because the first line is filled. Are there other ways in which `X`
    can win? Yes, on a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It could also win on the main diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a win for `X` on the secondary diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we have examples where `O` wins by filling a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a win by filling a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a win by the main diagonal for `O`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a win via the secondary diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'How about a game that ends in a draw? That''s easy—all the squares are filled
    but there''s no winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've looked at examples for all possible outputs. Now, it's time to look at
    data transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Data transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we transform the input into the output? To do this, we'll have to pick
    one of the possible outputs to tackle first. The easiest one for now is the case
    when `X` wins. So, how can `X` win?
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the rules of the game, `X` wins if either a line, a column, or
    a diagonal in the board is filled with `X`. Let''s write down all the possible
    cases. `X` wins if any of the following happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Any line is filled with `X` OR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any column is filled with `X` OR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main diagonal is filled with `X` OR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The secondary diagonal is filled with `X`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement this, we need a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the lines from the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the columns from the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the main and the secondary diagonal from the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of them are filled with `X`, `X` won!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can write this in another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What does `filledWithX` mean? Let''s take an example; we are looking for lines
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are not looking for lines such as `X O X` or `X _ X`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It sounds like we are checking whether all the tokens on the line, column,
    or diagonal are `''X''`. Let''s visualize this check as a transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our set of transformations becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One question remains—how can we get the lines, the columns, and the diagonals?
    We can look at this problem separately, in the same way we looked at the big problem.
    Our input is definitely the board. Our output is a list formed of first line,
    second line, and third line, first column, second column, and third column, main
    diagonal, and the secondary diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is, what defines a line? Well, we know how to get the first
    line—we use the `[0, 0]`, `[0, 1]`, and `[0, 2]` coordinates. The second line
    has the `[1, 0]`, `[1, 1]`, and `[1, 2]` coordinates. What about a column? Well,
    the first column has the `[1, 0]`, `[1, 1]`, and `[2, 1]` coordinates. And, as
    we'll see, the diagonals are also defined by specific coordinate sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what did we learn? We learned that to get the lines, columns, and diagonals,
    we need the following transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our analysis. It's time to move on to implementation. All the
    previous transformations can be expressed in code by using functional constructs.
    In fact, some of the transformations are so common that they're already implemented
    in the standard library. Let's see how we can use them!
  prefs: []
  type: TYPE_NORMAL
- en: Using all_of for filledWithX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first transformation we''ll look at is `all_of`. Given a collection and
    a function that returns a Boolean (also called a **logical predicate**), `all_of`
    applies the predicate to every element of the collection and returns the logical
    AND between the results. Let''s see a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `all_of` function takes two iterators defining the beginning and end of
    a range and a predicate as parameters. The iterators are useful when you want
    to apply the transformation to a subset of a collection. Since I usually use it
    on full collections, I find it annoying to write `collection.begin()` and `collection.end()`
    repeatedly. Thus, I implement my own simplified `all_of_collection` version that
    takes the whole collection and takes care of the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing this transformation, it''s easy to write our `lineFilledWithX` function—we
    turn the collection of tokens into a collection of Booleans specifying whether
    the token is `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We can ascertain whether our line is filled with `X`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s make a few simple adjustments. First, let''s make
    the code clearer by naming our `vector<char>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s check that the code works fine for the negative scenarios as well.
    If `Line` is not filled with the `X` token, `lineFilledWithX` should return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, an astute reader will notice that we will need the same function for
    the `O` wins condition. We now know how to do that—remember the power of argument
    binding. We just need to extract a `lineFilledWith` function and obtain the `lineFilledWithX`
    and `lineFilledWithO` functions by binding the `tokenToCheck` parameter to the `X` and
    `O` token values, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's recap—we have a `Line` data structure, and we have a function that can
    check whether the line is filled with `X` or `O`. We used the `all_of` function
    to do the heavy lifting for us; we just had to define the logic of our tic-tac-toe
    line.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to move forward. We need to turn our board into a collection of lines,
    formed out of the three lines, the three columns, and the two diagonals. To do
    so, we need to visit another functional transformation, `map`, which is implemented
    in **Standard Template Library** (**STL**) as the `transform` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using map/transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to write a function that turns the board into a list of lines,
    columns, and diagonals; therefore, we could use a transformation that takes a
    collection and turns it into another collection. This transformation is called
    `map` in general functional programming, and is implemented as `transform` in
    STL. To understand it, we will use a simple example; given a vector of characters,
    let''s replace each character with `''a''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While it works, the previous code sample is naive because it initializes the
    `aaa` vector with values that are overwritten afterward. We can avoid this issue
    by first reserving `3` elements in the `aaa` vector, and then use `back_inserter`
    so that `transform` automatically calls `push_back` on the `aaa` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `transform` is based on iterators in the same way `all_of` works.
    By now, you will have noticed that I like to keep things simple and focused on
    what we are trying to accomplish. There is no need to write this all the time;
    instead, we can implement our own simplified version that works on a full collection
    and takes care of all the rituals surrounding this function.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to implement the `transform_all` function in the simplest way possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we hit a snag when we try to implement it in this way—we need
    a type for the destination collection. The natural way of doing this is to use
    C++ templates and pass in the `Destination` type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine for any collection that has a `push_back` function. A nice
    side effect is that we can use it to concatenate the resulting characters in `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `transform_all` with `string` allows us to do things such as turning
    lowercase characters into uppercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'But that''s not all—the output type doesn''t necessarily have to be the same
    as the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `transform` function is therefore very useful whenever we need to transform
    a collection into another, be it the same type or different types. With the support
    of `back_inserter`, it can also be used for `string` outputs, thereby enabling
    the implementation of string representations for any type of collection.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to use transform. So, let's go back to our problem.
  prefs: []
  type: TYPE_NORMAL
- en: Our coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our transformation starts by computing coordinates. So, let''s define them
    first. The STL `pair` type is a simple representation for coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Getting a line from board and coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming we built the list of coordinates for a line, column, or diagonal,
    we need to transform the collection of tokens into the `Line` parameter. That''s
    easily done with our `transformAll` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `projectCoordinates` lambda takes the board and a list of coordinates, and
    returns the list of elements from the board that corresponds to those coordinates.
    We use `transformAll` on the coordinates list, and a transformation that takes
    two parameters—the `board` parameter and a `coordinate` parameter. However, `transformAll`
    requires a lambda with a single parameter, a `Coordinate` value. Therefore, we
    have to either capture the value of the board or use partial application.
  prefs: []
  type: TYPE_NORMAL
- en: We now just have to build our list of coordinates for lines, columns, and diagonals!
  prefs: []
  type: TYPE_NORMAL
- en: Getting a line from the board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily get a line from the board by using the previous function, `projectCoordinates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `line` lambda takes `board` and `lineIndex`, builds the line coordinates
    list, and uses `projectCoordinates` to return the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we build the line coordinates? Well, since we have `lineIndex` and `Coordinate` as
    a pair, we need to call `make_pair` on `(lineIndex, 0)`, on `(lineIndex, 1)`,
    and on `(lineIndex, 2)`. This looks like a `transform` call as well; the input
    is a `{0, 1, 2}` collection, and the transformation is `make_pair(lineIndex, index)`.
    Let''s write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But what is `{0, 1, 2}`? In other programming languages, we could use the concept
    of ranges; for example, in Groovy, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges are very useful, and they were adopted in the C++ 20 standard. We will
    discuss them in [Chapter 14](1edd5963-94e4-48dc-830f-8f201b3a39c7.xhtml), *Lazy
    Evaluation Using the Ranges Library*. Until then, we will write our own function, `toRange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`toRange` takes a collection as input and creates `range` from `0` to `collection.size()`.
    So, let''s use it in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have all the elements in place, so it's time to look at the columns.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for getting a column is very similar to the one for a line, except
    that we keep `columnIndex` instead of `lineIndex`. We just need to pass it as
    a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Isn't this cool? With a few functions, and the help of standard functional transformations,
    we can build complex behavior in our code. The diagonals are a breeze now.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the diagonals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main diagonal is defined by equal line and column coordinates. It''s pretty
    easy to use the same mechanic as before to read it; we build the pairs of equal
    indices and pass them to the `projectCoordinates` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the secondary diagonal? Well, the sum of coordinates is always equal
    to the size of the `board` parameter. In C++, we also need to take into account
    the 0-based index, so we need a well-placed adjustment by `1` when building the
    list of coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Getting all lines, all columns, and all diagonals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this being said, we can now build a collection of all lines, columns, and
    diagonals. There are multiple ways to do that; since I''m going for a general
    solution written in functional style, I will use `transform` again. We need to
    transform the `(0..board.size())` range into the list of lines and the list of
    columns respectively. Then, we need to return a collection containing the main
    and secondary diagonals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need one more thing—a way to concatenate the three collections. Since
    the vector doesn''t have this implemented, the recommended solution is to use
    `insert` and `move_iterator`, thus moving the items from the second collection
    at the end of the first collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just combine the three collections into two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now get the full list of lines, columns, and diagonals from the board,
    as you can see in the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's only one more step left in finding out whether `X` has won. We have
    the list of all lines, columns, and diagonals. We know how to check that a line
    is filled with `X`. We just need to check whether any of the lines from the list
    are filled with `X`.
  prefs: []
  type: TYPE_NORMAL
- en: Using any_of to check whether X has won
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `all_of`, another functional construct helps us to express an OR
    condition between predicates applied on a collection. In STL, this construct is
    implemented in the `any_of` function. Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the other higher-level functions we saw in this chapter, it uses iterators
    for the beginning and the end of the collection. As usual, I like to keep things
    simple; since I typically use `any_of` on full collections, I like to implement
    my helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to use it on our list to check whether `X` is the winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our solution for the winning condition for `X`. Before we move
    on, it would be nice to be able to display the board on the console. It's now
    time to use the close cousin of `map`/`transform`—`reduce`, or, as it's known
    in STL, `accumulate`.
  prefs: []
  type: TYPE_NORMAL
- en: Using reduce/accumulate to display the board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to display the board on the console. Normally, we would use a
    mutable function such as `cout` to do that; however, remember how we discussed
    that while we need to keep parts of our program mutable, such as those calling
    `cout`, we should limit them to a minimum. So, what would the alternative be?
    Well, we need to think about inputs and outputs once again—we want to write a
    function that takes `board` as input and returns a `string` representation that
    we can display by using a mutable function such as `cout`. Let''s write what we
    want in the form of a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain this result, we first need to transform each line from `board` into
    its `string` representation. Our line is `vector<char>` and we need to turn it
    into `string`; while there are many ways of doing this, please allow me to use
    the `transformAll` function with a `string` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this function written, we can easily turn a board into `vector<string>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to combine these strings with `\n` between them. We often
    need to combine elements of a collection in various ways; that's where `reduce`
    comes into play. In functional programming, `reduce` is an operation that takes
    a collection, an initial value (for example, empty `strings`), and an accumulation
    function. The function takes two parameters, performs an operation on them, and
    returns a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a few examples. First, there''s the classic example of adding a
    vector of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows us what to do if we need to add the vector with an initial
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can concatenate `strings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can add a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, I prefer a simplified implementation that works on a full collection
    and uses a default value as an initial value. With a bit of `decltype` magic,
    it''s easy to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This just leaves us with one task—writing an implementation of concatenate
    that combines the `string` lines using a newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can now use `cout << boardToString` to display our board. Once again, we
    used a few functional transformations and very little custom code to put everything
    together. That's quite nice.
  prefs: []
  type: TYPE_NORMAL
- en: The `map`/`reduce` combination, or, as it's known in STL, `transform`/`accumulate`,
    is very powerful and very common in functional programming. We often need to start
    from a collection, transform it into another collection multiple times, and then
    combine the elements of the collection. It's such a powerful concept that it's
    at the heart of big data analysis, using tools such as Apache Hadoop, albeit scaled
    at the level of machines. This shows that by mastering these transformations,
    you might end up applying them in unexpected situations, making you an indispensable
    problem solver. Cool, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Using find_if to display specific win details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are happy now that we have solved the tic-tac-toe result problem for `X`.
    However, as always, requirements change; we need now to not only say whether `X`
    won, but also how—on which line, or column, or diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we already have most of the elements in place. Since they are
    very small functions, we just need to recombine them in a way that helps us. Let''s
    think again in terms of data—our input data is now a collection of lines, columns,
    and diagonals; our result should be something such as `X` won *on first line*.
    We just need to enhance our data structure to contain information about each line;
    let''s use `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We know how to find out where `X` won—through our `lineFilledWithX` predicate
    function. Now, we just need to search in the map for the line that fits the `lineFilledWithX`
    predicate and return the corresponding message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, this is a common operation in functional programming. In STL, it''s
    implemented with the `find_if` function. Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`find_if` looks in a collection based on a predicate and returns a pointer
    to the result, or a pointer to the `end()` iterator if nothing is found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, let''s do our wrapper implementation that allows a search in a whole
    collection. We need to represent the `not found` value in a way; fortunately,
    we can use the optional type from STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can easily implement the new requirement. We can find the line that
    is filled with `X` by using our newly implemented `findInCollection` function
    and return the corresponding description. We can therefore tell the user how `X`
    won—on a line, on a column, or on a diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We should, of course, generate the map from the board instead of hardcoding
    it. I will leave this exercise to the reader; just use our favorite `transform`
    function again.
  prefs: []
  type: TYPE_NORMAL
- en: Completing our solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have implemented the solution for `X` wins, we now need to look into
    the other possible outputs. Let's take the easiest one first—`O` wins.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether O has won
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Checking whether `O` has won is easy—we just need a small change in our functions.
    We need a new function, `oWins`, that checks whether any line, column, or diagonal
    is filled with the `O` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We use the same implementation as for `xWins`, with just a slight change in
    the lambda that is passed as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for draw using none_of
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What about `draw`? Well, a draw happens when the `board` parameter is full
    and neither `X` nor `O` has won:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'What does a full board mean? It means that every line is full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And how do we know whether the line is full? Well, we know that if none of
    the tokens from the line are the empty (`'' ''`) token, the line is full. As you
    probably expect by now, there is a function in STL called `none_of` that can check
    this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Checking for game in progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final case is when the game is still in progress. The simplest way is just
    to check that the game was not won and the board is not full yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, we've done it! We've implemented the tic-tac-toe result problem
    using a number of functional transformations; a few lambdas of our own. But, more
    importantly, we've learned how to start thinking as a functional programmer—clearly
    defining the input data, clearly defining the output data, and figuring out the
    transformations that can turn the input data into the required output data.
  prefs: []
  type: TYPE_NORMAL
- en: Error management using optional types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have a small program written in functional style. But what about
    the error cases? How do we deal with them?
  prefs: []
  type: TYPE_NORMAL
- en: It's obvious that we can still use the C++ mechanisms—return values or exceptions.
    But functional programming also looks at another way—treating errors as data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw an example of this technique when we implemented our `find_if`
    wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Instead of throwing an exception or returning `collection.end()`, which is a
    local value, we used the `optional` type. As stated in its name, the optional
    type represents a variable that may, or may not, have a value. An optional value
    can be initialized, either with a value supported by the underlying type, or with
    `nullopt`—a default non-value, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: 'When encountering an optional value in our code, we need to take it into account,
    as we did in the function checking how `X` won:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the *not found* condition is not an error; instead, it''s a normal
    part of our code and of our data. Indeed, another way of dealing with this condition
    is to enhance `findInCollection` to return a specified value when nothing is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `findInCollectionWithDefault` to obtain an `X did not win` message when
    we call `howDidXWin` on a board where `X` did not win:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: My best advice is this—use exceptions for all exceptional situations, and make
    everything else part of your data structures. Use optional types, or transformations
    with default values. You'll be surprised by how easy and natural error management
    becomes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of ground in this chapter! We went through a journey of
    discovery—we started by listing the outputs and corresponding inputs for our problem,
    decomposed them, and figured out how to transform the inputs in the requisite
    outputs. We saw how small functions and the functional operations give us agility
    when new features are requested. We saw how to use `any`, `all`, `none`, `find_if`,
    `map`/`transform`, and `reduce`/`accumulate`, and how to use optional types or
    default values to support all possible cases in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of how to write code in functional style, it's time
    to see how this approach fits with OO programming in the next chapter.
  prefs: []
  type: TYPE_NORMAL
