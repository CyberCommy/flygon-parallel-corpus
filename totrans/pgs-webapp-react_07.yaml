- en: Adding a Service Worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to our first big step into the world of Progressive Web Applications.
    This chapter will be devoted to creating our first service worker which, in turn,
    will unlock much of the functionality that makes PWAs so special.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve talked previously about PWAs bridging web apps and native applications.
    The way they do this is through service workers. Service workers make things such
    as push notifications and offline access possible. They're an exciting new technology
    with many applications (more and more emerging each year); if one piece of tech
    will transform web development in the next five years, it's service workers.
  prefs: []
  type: TYPE_NORMAL
- en: However, enough hype; let's dive in to what exactly a service worker is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a service worker?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service worker life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to register a service worker on our page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a service worker?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **service worker** is a bit of JavaScript that sits between our application
    and the network.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a script that runs outside the context of our application,
    but with which we can communicate from within the bounds of our code. It's a piece
    of our application, but separate from the rest.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest example is in the context of caching files (which we’ll explore
    in the upcoming chapters). Let’s say that our application, when the user navigates
    to [https://chatastrophe.com](https://chatastrophe.com), goes and fetches our
    `icon.png` file.
  prefs: []
  type: TYPE_NORMAL
- en: A service worker, if we configure it, will sit between our app and the network.
    When our app requests the icon file, the service worker intercepts that request
    and checks the local cache for the file. If found, it returns it; no network request
    is made. Only if it doesn't find the file in the cache does it let the network
    request go through; after the download is complete, it puts the file in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: You can see where the term "worker" comes from--our service worker is a busy
    little bee.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example; push notifications (sneak preview of [Chapter
    9](part0144.html#49AH00-7dd7c66301294003b85168009fe95fa4), *Making Our App Installable
    with a Manifest*). Most push notifications work this way--when a certain event
    happens (a user sends a new chat message), a messaging service is alerted (in
    our case, the message service is managed by Firebase). The messaging service sends
    an alert to the relevant registered users (who are registered via their devices),
    and then their devices create the notification (ding!).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this flow, in a web app context, is that our application stops
    running when the user is not on the page, so we won't be able to notify them unless
    their app is already open, which completely defeats the point of push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers solve this problem by always being "on" and listening for messages.
    Now, the messaging service can alert our service worker, which displays a message
    to the user. Our application code is never actually involved, so it doesn't matter
    whether it’s running or not.
  prefs: []
  type: TYPE_NORMAL
- en: This is exciting stuff, but with any new technology, there's a few rough edges,
    and some things to watch out for.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The life of your service worker begins when a user first visits your page. The
    service worker is downloaded and begins running. It may go idle for a time when
    not needed, but can then restart when required.
  prefs: []
  type: TYPE_NORMAL
- en: This **always on** functionality is what makes the service workers useful for
    push notifications. It also makes service workers a bit unintuitive to work with
    (more on that to come). However, let's take a deep look at the life and death
    of a service worker on a typical page.
  prefs: []
  type: TYPE_NORMAL
- en: First, the service worker is installed, if possible. All service worker installations
    will start with a check to see whether the technology is supported by the user's
    browser. As of now, Firefox, Chrome, and Opera have full support, and other browsers
    do not. Apple, for one, views service workers as **experimental technology**,
    indicating that they're still on the fence about the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: If the user's browser is modern enough, the installation begins. The script
    (for example, `sw.js`) is installed (or rather, registered) within a certain scope.
    **Scope**, in this case, refers to what paths of the website it is concerned with.
    A global scope will take `'/'`, for example, all paths on the site, but you can
    also limit your service worker to `'/users'`; for example, to only cache certain
    parts of the application. We'll discuss more about scope in the caching chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Once registered, the service worker is activated. The activation event also
    occurs whenever the service worker is required, for example, when a push notification
    comes in. The activation and deactivation of service workers means that you cannot
    persist state within a service worker; it’s just a bit of code ran in reaction
    to events, rather than a full-blown application of its own. That’s an important
    distinction to remember, lest we ask too much of our workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service worker will be idle until an event occurs. As of now, there are
    two events that service workers react to: a `fetch` event (also known as a network
    request from the application) and a `message` (also known as an interaction from
    either the application code or a messaging service). We can register listeners
    for these events within the service worker, and then react as appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The service worker code will update under two conditions: 24 hours has elapsed
    (in which case it stops and redownloads a method to prevent broken code from causing
    too much annoyance), or the user visits the page and the `sw.js` file has changed.
    Every time the user visits the app, the service worker compares its current code
    with the `sw.js` served by the site, and if there is even a byte of difference,
    the new `sw.js` is downloaded and registered.'
  prefs: []
  type: TYPE_NORMAL
- en: That's the basic technical overview of service workers and how they work. It
    may seem complicated, but the good news is that using service workers is relatively
    straightforward; you can get a simple one up and running in a matter of minutes,
    which is exactly what we'll do next!
  prefs: []
  type: TYPE_NORMAL
- en: Registering our first service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the distinction about service workers--they are a piece of our site,
    but run outside our application code. With that in mind, our service worker will
    live inside `public/ folder`, and not in `src/ folder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a file called `sw.js` in your `public/ folder`. We''ll keep it
    simple for now; just add a single `console.log` inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The real work (registering the service worker) will be done inside our `index.html`.
    For this process, we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the browser supports service workers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the page to load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the service worker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s move through the steps one by one. First, let''s create an empty `script`
    tag below our Firebase initialization, inside `public/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Checking for browser support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Checking whether the user''s browser can handle service workers is very easy.
    In our script tag, we''ll add a simple `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check the `window.navigator` object for any service worker support.
    The navigator can also be used (via its `userAgent` property) to check what browser
    the user has, though we won't need that here.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for the page load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We don''t want to register our service worker until the page has finished loading;
    there''s no point, and it can lead to complications, so we''ll add an event listener
    to the window for the `''load''` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Registering the service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted earlier, the `window.navigator` has a `serviceWorker` property,
    the existence of which confirms browser support for service workers. We can also
    use that same object to register our service worker, via its `register` function.
    I know, it's shocking stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `navigator.serviceWorker.register`, and pass in the path to our service
    worker file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Logging out the result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, let''s add some `console.logs` so that we know the result of the registration.
    Luckily, `navigator.serviceWorker.register` returns a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let''s test this all out! Reload the page, and if all is good, you should
    see the following in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also check it by navigating to the Application tab in DevTools, and
    then to the Service Workers tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I would recommend taking the opportunity to check the Update on reload button
    at this time. This ensures that your service worker is refreshed every time you
    refresh the page (remember the normal service worker life cycle we discussed earlier).
    Why take this precaution? We're stepping into the world of cached code, where
    the browser may think your service worker hasn't changed, when it actually has.
    This checkbox just ensures that you're always dealing with the freshest build
    of `sw.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we've registered a worker! Fantastic. Let's take a moment to go through
    the service worker life cycle from within our `sw.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Experiencing the service worker life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first event that a service worker experiences is the `'install'` event.
    This is when a user first starts up a PWA. The standard user will only experience
    this once.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tap into this event, all we have to do is add an event listener to our service
    worker itself. To do that from within `sw.js`, we use the `self` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you reload the page, you should see `'Install!'` appear in the console.
    In fact, you should see it every time you reload the page, unless you uncheck
    the Update on reload option under Application | Service Workers. Then, you will
    only see it the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `activate` event. This event is triggered when the service worker
    first registers, before the registration completes. In other words, it should
    occur under the same situations as install, only later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last event we want to cover is the `''fetch''` event. This event is called
    whenever the application makes a network request. It''s called with an event object
    that has a request URL, which we can log out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding this in, we should see a very cluttered console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can delete all the `console.logs` in the service worker for now, but we
    will use each of these event listeners in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at hooking into the Firebase messaging service, to lay the
    groundwork for push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Firebase to our service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal for the rest of the chapter is to integrate Firebase into our service
    worker so that it is ready to receive push notifications and display them.
  prefs: []
  type: TYPE_NORMAL
- en: This is a big project. We won't be able to actually display push notifications
    until the end of the next chapter. However, here we'll see how to integrate third-party
    services into service workers, and dive a little more into the theory behind service
    workers.
  prefs: []
  type: TYPE_NORMAL
- en: Naming our service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service we will use to send push notifications to user devices is called
    **Firebase Cloud Messaging**, or **FCM**. FCM works on the web by looking for
    a service worker and then sending it a message (containing the notification details).
    The service worker then displays the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, FCM looks for a service worker named `firebase-messaging-sw.js`.
    You can change that using `firebase.messaging().useServiceWorker` and passing
    a service worker registration object. For our purposes, however, it will be more
    straightforward to simply rename our service worker. Let''s do so; change the
    filename in `public/` and in the registration in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once that's done, we can start initializing Firebase inside our service worker.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say it again; a service worker is not linked to your application code.
    This means that it does not have access to our current Firebase initialization.
    We can reinitialize Firebase inside our service worker, though, and only keep
    what's relevant--the `messagingSenderId`. You can get your `messagingSenderId`
    from the Firebase console or your `secrets.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you're concerned about security, ensure that you add `public/firebase-messaging-sw.js`
    to your `.gitignore`, though keeping your `messagingSenderId` private is not as
    important as keeping your API key secret.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import the parts of Firebase we need at the top of the file,
    which include the `app` library and the `messaging` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s done, we should be able to `console.log` out `firebase.messaging();`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](../images/00054.jpeg)*'
  prefs: []
  type: TYPE_NORMAL
- en: This means our Firebase is up and running inside our service worker!
  prefs: []
  type: TYPE_NORMAL
- en: If you're still seeing the logs from our old `sw.js`, go to the **Application
    | Service Workers** tab of DevTools and **Unregister** it. This is a good example
    of how service workers will persist even if they're not being reregistered.
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, a service worker is an always-running piece of code (though
    not perfectly accurate--think of the life cycle of such workers--which is a good
    way to think of them). This means it will always be waiting for FCM to tell it
    that there's a message coming in.
  prefs: []
  type: TYPE_NORMAL
- en: However, right now, we don't have any messages coming. The next step is to start
    configuring when push notifications get sent, and how to display them!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of service workers, and got one up and
    running. Our next step is to start using it. Specifically, we want to use it to
    listen for notifications, and then display them to the user. Let's take another
    big step towards making our PWA feel like a native app by setting up push notifications.
  prefs: []
  type: TYPE_NORMAL
