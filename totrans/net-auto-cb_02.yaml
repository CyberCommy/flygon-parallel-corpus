- en: Managing Cisco IOS Devices Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline how to automate Cisco IOS-based devices using
    Ansible. We will explore the different modules available in Ansible to automate
    configuration and collect network information from Cisco IOS devices. This chapter
    will be based on the following sample network diagram, and we will walk through
    how we can implement this network design using Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/06d3ef76-2fe9-43da-98c7-ea99b04fb0c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table outlines the management IP addresses on the Cisco nodes,
    which Ansible will use to connect to the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Role** | **Vendor** | **MGMT Port** | **MGMT IP** |'
  prefs: []
  type: TYPE_TB
- en: '| `access01` | Access switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.18`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `access02` | Access switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.19`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `core01` | Core switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.20` |'
  prefs: []
  type: TYPE_TB
- en: '| `core02` | Core switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.21` |'
  prefs: []
  type: TYPE_TB
- en: '| `wan01` | WAN router | Cisco IOS–XE 16.6.1 | `GigabitEthernet1` | `172.20.1.22`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wan02` | WAN router | Cisco IOS–XE 16.6.1 | `GigabitEthernet1` | `172.20.1.23`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The main recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible network inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Cisco IOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring basic system information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring interfaces on IOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring L2 VLANS on IOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring trunk and access interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring interface IP addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring OSPF on IOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting IOS device facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating network reachability on IOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving operational data from IOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating network states with pyATS and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch2_ios](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch2_ios)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The software releases that this chapter is based on are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cisco IOS 15.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco IOS–XE 16.6.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/34F8xPW](https://bit.ly/34F8xPW)'
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible network inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build and structure the Ansible inventory
    to describe the network setup outlined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that Ansible is already installed on the control machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new directory with the following name: `ch2_ios`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this new folder, create the `hosts` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Ansible.cfg` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built the Ansible inventory using the `hosts` file, and we defined multiple
    groups in order to group the different devices in our topology in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: We created the `access` group, which has both access switches (`access01` and
    `access02`) in our topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `core` group, which groups all core switches that will act as
    the L3 termination for all the VLANs on the access switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `wan` group, which groups all our Cisco IOS–XE routes, which
    will act as our wan routers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created another group called `lan,` which groups both access and core groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `network` group, which groups both `lan` and `wan` groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we created the `Ansible.cfg` file and configured it to point to our
    `hosts` file to be used as an Ansible inventory file. We disabled the setup module,
    which is not required when running Ansible against network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Cisco IOS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to connect to Cisco IOS devices from Ansible
    via SSH in order to start managing devices from Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability between the Ansible
    control machine and all the devices in the network must be configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `ch2_ios` directory, create the `groups_vars` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `group_vars` folder, create the `network.yml` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On all IOS devices, ensure that the following is configured to set up SSH access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate SSH keys on the Cisco IOS devices from the config mode, as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `Ansible.cfg` file with the following highlighted parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our sample network, we will use SSH to set up the connection between Ansible
    and our Cisco devices. In this setup, Ansible will use SSH in order to establish
    the connection to our Cisco devices with a view to start managing it. We will
    use username/password authentication in order to authenticate our Ansible control
    node with our Cisco devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Cisco devices, we must ensure that SSH keys are present in order to
    have a functional SSH server on the Cisco devices. The following code snippet
    outlines the status of the SSH server on the Cisco device prior to generating
    the SSH keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once we create the SSH keys, the SSH server on the Cisco device is operational,
    and is ready to accept an SSH connection from the Ansible control node.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Ansible machine, we include all the variables required to establish
    the SSH connection to the managed devices in the `network.yml` file. As per our
    inventory file, the network group includes all the devices within our topology,
    and so all the attributes that we configure in this file will apply to all the
    devices in our inventory. The following is a breakdown of the attributes that
    we included in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ansible_connection`: This establishes how Ansible connects to the device.
    In this scenario, we set it to `network_cli` to indicate that we will use SSH
    to connect to a network device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ansible_network_os`: When using `network_cli` as the connection plugin to
    connect to the network device, we must indicate which network OS Ansible will
    be connecting to, so as to use the correct SSH parameters with the devices. In
    this scenario, we will set it to `ios`, since all the devices in our topology
    are IOS-based devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ansible_user`: This parameter specifies the username that Ansible will use
    to establish the SSH session with the network device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ansible_password`: This parameter specifies the password that Ansible will
    use to establish the SSH session with the network device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ansible_become`: This instructs Ansible to use the `enable` command to enter
    privileged mode when configuring or executing `show` commands on the managed device.
    We set this to `yes` in our context, since we will require privileged mode to
    configure the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ansible_become_password`: This specifies the `enable` password to use in order
    to enter privileged mode on the managed IOS device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ansible_become_method`: This option specifies the method to use in order to
    enter privileged mode. In our scenario, this is the `enable` command on IOS devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, I have defined the SSH password and the `enable` passwords as
    plain text just for simplicity; however, this is highly discouraged. We should
    use `Ansible-vault` to secure the passwords, as outlined in the *Ansible Vault*
    recipe in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On the Cisco devices, we set up the required username and password so that Ansible
    can open an SSH connection to the managed Cisco IOS devices. We also configure
    an `enable` password to be able to enter privileged mode, and to make configuration
    changes. Once we apply all of these configurations to the devices, we are ready
    to set up Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any SSH connection, when an SSH client (Ansible control node in our case)
    connects to an SSH server (Cisco devices in our case), the server sends a copy
    of its public key to the client before the client logs in. This is used to establish the
    secure channel between the client and the server, and to authenticate the server
    to the client in order to prevent any man-in-the-middle attacks. So, at the start
    of a new SSH session involving a new device, we see the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the SSH client initiates the SSH connection to the client, the SSH server
    sends its public key to the client in order to authenticate itself to the client.
    The client searches for the public key in its local known `hosts` files (in the `~/.SSH/known_hosts`
    or `/etc/SSH/SSH_known_hosts` files). In the event that it does not find the public
    key for this machine in its local known `hosts` file, it will prompt the user
    to add this new key to its local database, and this is the prompt that we see
    when we initiate the SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: In order to simplify the SSH connection setup between the Ansible control node
    and its remotely managed `hosts`, we can disable this host checking. We can do
    this by telling Ansible to ignore host keys and not to add them to the known `hosts`
    files by setting `host_key_checking` to `False` in the `Ansible.cfg` configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling host key checking is not a best practice, and we are only showing
    it as it is a lab setup. In the next section, we will outline an alternative method
    to establish the SSH connection between Ansible and its remote managed devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to verify the identity of the SSH `hosts` that we will connect to,
    and thereby enable `host_key_checking`, we can automate the addition of the SSH
    public key of the remote managed `hosts` to the `~/.SSH/known_hosts` file using
    Ansible. We create a new Ansible playbook that will run on the Ansible control
    machine to connect to the remote devices using the `ssk-keyscan` command. We then
    collect the SSH public keys for the remote machines and add them to the `~/.SSH/known_hosts`
    file. The method is outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `playbook pb_gather_SSH_keys.yml` file and add the following play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook and add another play within the same playbook to save and
    store the SSH public keys for the remote managed nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our new playbook, we have a play that targets all our managed devices by
    setting the `hosts` parameter to `all`. In this play, we have a single task, which
    we run on the Ansible control node (using the `delegate_to` localhost) to issue
    the `SSH-keyscan` command, which returns the SSH public key for the remote device,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this task, we are using `delegate_to` as being equal to `localhost,` as Ansible
    will try to connect to the remote devices and issue the command on the remote
    device by default. In our case, this is not what we need; we need to issue this
    command from the Ansible control node. So, we use `delegate_to` as being equal
    to `localhost` in order to enforce this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We run the second play on the Ansible control host by setting `hosts` to `localhost,`
    and we execute tasks to create the known hosts file (if not already present) and
    to populate this file with the data that we captured in the first play using the
    `SSH_keys` variable. We run this playbook on the Ansible control machine to store
    the SSH keys from the remotely managed nodes prior to running any of our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring basic system information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will outline how we can configure basic system parameters
    on Cisco IOS devices, such as setting the hostname, DNS server, and NTP servers.
    Following the network setup that we outlined at the start of this chapter, we
    will configure the following information on all the Cisco IOS devices:'
  prefs: []
  type: TYPE_NORMAL
- en: DNS servers 172.20.1.250 and 172.20.1.251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NTP server 172.20.1.17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ansible inventory file must be present, as well as the configuration for
    Ansible to connect to the Cisco IOS devices via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To the `group_vars/network.yml` file, add the following system parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_build_network.yml` with the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `network.yml` file, we define the `name_servers` variable as a list of
    DNS servers, and we also define the `ntp_servers` variable, which defines the
    NTP servers that we want to configure on the IOS devices. Defining these parameters
    in the `network.yml` file applies these variables to all the devices within the
    network group.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a playbook and the first play targets all the `hosts` in the `lan`
    group (this includes both access and core devices) and, within this play, we reference
    two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ios_system`: This sets the hostname and the DNS servers on the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_ntp`: This configures the NTP on the IOS devices and enables logging for
    NTP events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these modules are declarative Ansible modules in which we just identify
    the state pertaining to our infrastructure. Ansible converts this declaration
    into the necessary IOS commands. The modules retrieve the configuration of the
    devices and compare the current state with our intended state (to have DNS and
    NTP configured on them) and then, if the current state does not correspond to
    the intended state defined by these modules, Ansible will apply the needed configuration
    to the devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run these tasks on all the LAN devices, the following configuration
    is pushed to the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the `ios_system` and `ios_ntp` modules, as well
    as the different parameters supported by these modules, please consult the following
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_system_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_system_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_ntp_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_ntp_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring interfaces on IOS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure the basic interface properties
    on Cisco IOS-based devices, such as setting the interface description, the interface
    **maximum transmission unit** (**MTU**), and enabling `interfaces`. We will configure
    all the links within our topology as having a link MTU of 1,500 and to be fully
    duplex.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, as is IP reachability between the Ansible control node with the Cisco
    devices in place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `group_vars/network.yml` file, add the following content to define the
    generic interface parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file, `lan.yml`, under the `group_vars` folder, with the following
    data to define the `interfaces` on our Cisco devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_build_network.yml` playbook file with the following task to
    set up the `interfaces`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we outline how to configure the physical interfaces on IOS devices.
    We first declare the generic parameters (interface duplex and MTU) that apply
    to all the interfaces. These parameters are defined under the `network.yml` file.
    Next, we define all the interface-specific parameters for all our LAN devices
    under the `lan.yml` file to be applied to all devices. All these parameters are
    declared in the `interfaces` dictionary data structure.
  prefs: []
  type: TYPE_NORMAL
- en: We update our playbook with a new task to configure the physical parameters
    for all of our LAN devices in our network. We use the `ios_interface` module to
    provision all the `interface` parameters, and we loop over all the `interfaces`
    in each node using the `interfaces` data structure. We set the state to `up` in
    order to indicate that the `interface` should be present and operational.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `ios_interface` module, and the different
    parameters supported by these modules, please consult the following URL: [https://docs.Ansible.com/Ansible/latest/modules/ios_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_interface_module.html)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring L2 VLANs on IOS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure L2 VLANs on Cisco IOS devices,
    as per the network topology discussed in the introduction to this chapter. We
    will outline how to declare VLANs as Ansible variables, and how to use suitable
    Ansible modules to provision these VLANs on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be building on the previous recipes discussed in this chapter to continue
    to configure the L2 VLANs on all the LAN devices within our sample topology.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/lan.yml` file with the VLAN definition, as outlined
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_build.yml` playbook with the following task to provision the
    VLANs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `group_vars/lan.yml` file, we define a `vlans` list data structure that
    holds the VLAN definition that we need to apply to all our core and access switches.
    This variable will be available for all the core and access switches, and Ansible
    will use this variable in order to provision the required VLANs on the remote
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: We use another declarative module, `ios_vlan`, which takes the VLAN definition
    (its name and the VLAN ID) and configures these VLANs on the remote managed device.
    It pulls the existing configuration from the device and compares it with the list
    of devices that need to be present, while only pushing the delta.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `loop` construct to go through all the items in the `vlans` list,
    and configure all the respective VLANs on all the devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this task on the devices, the following is the output from one
    of the access switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Configuring trunk and access interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to configure access and trunk interfaces on
    Cisco IOS-based devices, and how to map interfaces to an access VLAN, as well
    as how to allow specific VLANs on the trunks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following our sample topology, we will configure the interfaces on the devices.
    As shown in this table, we are only showing the VLANs for `access01` and `core01`—
    the other devices are exact replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Interface** | **Mode** | **VLANs** |'
  prefs: []
  type: TYPE_TB
- en: '| Core01 | Ethernet0/1 | Trunk | 10,20,100 |'
  prefs: []
  type: TYPE_TB
- en: '| Core01 | Ethernet0/2 | Trunk | 10,20,100 |'
  prefs: []
  type: TYPE_TB
- en: '| Core01 | Ethernet0/3 | Trunk | 10,20,100,200 |'
  prefs: []
  type: TYPE_TB
- en: '| Access01 | Ethernet0/1 | Trunk | 10,20,100 |'
  prefs: []
  type: TYPE_TB
- en: '| Access01 | Ethernet0/2 | Trunk | 10,20,100 |'
  prefs: []
  type: TYPE_TB
- en: '| Access01 | Ethernet0/3 | Access | 10 |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `core.yml` file under `group_vars` and include the following `core_vlans`
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_build_network.yml` playbook with the following tasks to configure
    all trunk ports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to configure all access ports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using the same data structure in the `lan.yml` file that defines all
    the interfaces within the LAN network and describes their type (access/trunk).
    In the case of access ports, we define which access interface is part of which
    VLAN. We will reference this list data structure to configure the access and trunk
    ports on all the devices within the `lan` group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfaces within our `layer2` network are one of the following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access**:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `ios_l2_interface` with the `access_vlan` parameter to configure the
    correct access VLAN on the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We select only the access interfaces for each device using the `selectattr jinja2`
    filter, and we match only one interface with a mode equal to `access`, and we
    loop over this list for each device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trunk**:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `ios_l2_interface` with the `trunk_allowed_vlans` parameter to add all
    the VLANs to the trunk ports, on both access and core switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create the permitted VLAN list using the Jinja2 `map` and `join` filters
    and we apply this filter to the `vlans` list data structure. This outputs a string
    similar to the following: `10,20,100`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We select only the trunk ports using the `selectattr` Jinja2 filter from the
    interface's data structure per node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to configure these trunks as `dot1q` ports; however, this attribute
    is still not enabled on `ios_l2_interface`. Hence, we use another module, `ios_config`,
    to send the required Cisco IOS command to set up the `dot1q` trunks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following output outlines the configuration applied to the `access01` device
    as an example for both access and trunk ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding `ios_l2_interface` and the different parameters
    supported by these modules, please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_l2_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_l2_interface_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interface IP addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore how to configure the interface IP address on
    Cisco IOS devices. We will use the sample topology to configure the VLAN interfaces
    on both the core switches. We will outline how to configure VRRP between the core
    switches for all the VLAN interfaces. We will configure the following IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** | **Prefix** | **VRRP IP address** |'
  prefs: []
  type: TYPE_TB
- en: '| VLAN10 | `10.1.10.0/24` | `10.1.10.254` |'
  prefs: []
  type: TYPE_TB
- en: '| VLAN20 | `10.1.20.0/24` | `10.1.20.254` |'
  prefs: []
  type: TYPE_TB
- en: '| VLAN100 | `10.1.100.0/24` | `10.1.100.254` |'
  prefs: []
  type: TYPE_TB
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that the interface and VLANs are configured as per the previous
    recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/core.yml` file with following data to define the SVI
    interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `core01.yml` and `core02.yml` files under the `host_vars` folder and
    add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_build_network.yml` playbook with the following tasks to create
    and enable the L3 SVI interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to set up VRRP configuration on
    the SVI interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are configuring the IP addresses for the L3 VLAN interfaces
    on the core switches, as well as configuring VRRP on all the L3 VLAN interfaces
    to provide L3 redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a new list data structure called `svi_interfaces,` which describes
    all the SVI interfaces with L3 IP addresses, and also some added parameters to
    control both the VRRP and OSPF configured on these interfaces. We also set up
    two new variables on each core router, `hst_svi_id` and `hst_vrrp_priority`, which
    we will use in the playbook to control the IP address on each core switch, as
    well as the VRPP priority.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `ios_l3_interface` Ansible module to set the IPv4 addresses on the
    VLAN interfaces. On each core switch, we loop over the `svi_interfaces` data structure,
    and for each VLAN we configure the IPv4 address on the corresponding VLAN interface.
    We determine which IP address is configured on each router using the Ansible `ipaddr`
    filter, along with the `hst_svi_id` parameter `{{item.ipv4 | ipv4(hst_svi_id)}}`
    . So, for example, for VLAN10, we will assign `10.1.10.1/24` for `core01` and
    `10.1.10.2/24` for `core02`.
  prefs: []
  type: TYPE_NORMAL
- en: When first creating the VLAN interface on Cisco IOS devices, they are in a state
    of shutdown, so we need to enable them. We use the `ios_interface` module to enable
    the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For the VRRP part, we return to using the `ios_config` module to set up the
    VRRP configuration on all the VLAN interfaces, and we use `hst_vrrp_priority`
    to correctly set up `core01` as the master VRRP for all VLANs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample of the configuration that is pushed on the devices
    after running the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding `ios_l3_interface` and the different parameters
    supported by these modules, please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_l3_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_l3_interface_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OSPF on IOS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure OSPF on Cisco IOS devices with
    Ansible. Using our sample network topology, we will set up OSPF between core switches
    and WAN routers, as well as advertising the SVI interface via OSPF.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that all the interfaces are already configured with the
    correct IP addresses and are following the same procedures outlined in previous
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/core.yml` file with the following data to define core
    links between core switches and WAN routers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_build_network.yml` playbook with the following tasks to set
    up OSPF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created another dictionary data structure in the `core.yml` file that describes
    the L3 links between the core switches and the WAN routers. We specified whether
    they will run OSPF and what the OSPF metric is on these links.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Ansible doesn't provide a declarative module to manage OSPF configuration
    on IOS-based devices. Therefore, we need to push the required configuration using
    the `ios_config` module. We created two separate tasks using `ios_config` in order
    to push the OSPF-related configuration on each device. In the first task, we configured
    the interface-related parameters under each interface, and we looped over both
    the `svi_interface` and `core_l3_interfaces` data structures to enable OSPF on
    all the OSPF-enabled interfaces. We used the Jinja2 `selectattr` filter to select
    all the interfaces that have the OSPF attribute set to `yes`/`true`.
  prefs: []
  type: TYPE_NORMAL
- en: In the last task, we applied the passive interface configuration to all the
    interfaces that have the passive flag enabled on them. We used the Jinja2 `selectattr`
    filter to select only those interfaces with the passive parameter set to `yes`/`true`.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting IOS device facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to collect device facts from Cisco devices
    with Ansible. This information includes the serial number, IOS version, and all
    the interfaces on the devices. Ansible executes several commands on managed IOS
    devices in order to collect this information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible controller must have IP connectivity with the managed network devices,
    and SSH must be enabled on the IOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_collect_facts.yml` in the same `ch2_ios` folder with
    the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We run this new playbook against all nodes within the `core` and `wan` group,
    and we use the `ios_facts` module to collect the information from the managed
    IOS devices. In this recipe, we use the debug module to print out the information
    that was collected from the `ios_facts` module. The following is a subset of the
    information that was discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can see some of the main facts that the `ios_facts`
    module has captured from the devices, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`net_all_ipv4_addresses`: This list data structure contains all the IPv4 addresses
    that are configured on all the `interfaces` on the IOS device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net_interfaces`: This dictionary data structure captures the status of all
    of the `interfaces` on this device and their operational state, as well as other
    important information, such as a description and their operational state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net_serialnum`: This captures the serial number of the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net_version`: This captures the IOS version running on this device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the information that is collected from the `ios_facts` module, we can
    generate structured reports for the current state of the network and use these
    reports in further tasks. In this section, we will outline how to modify our playbook
    to build this report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new task to the `pb_collect_facts.yml` playbook, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `blockinfile` module to build a YAML file called `facts.yml.` We
    use Jinja2 expressions within the `blockinfile` module to customize and select
    the information we want to capture from the Ansible facts that were captured from
    the `ios_facts` task. When we run the `pb_collect_facts.yml` playbook, we generate
    the `facts.yml` file, which has the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding `ios_facts` and the different parameters supported
    by these modules, please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_facts_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_facts_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Validating network reachability on IOS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to validate network reachability via `ping`
    using Ansible. ICMP allows us to validate proper forwarding across our network.
    Using Ansible to perform this task provides us with a robust tool to validate
    proper traffic forwarding, since we can perform this task from each node simultaneously
    and collect all the results for further inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is built based on the network setup that was outlined in the chapter
    introduction, and I am assuming that the network has already been built in accordance
    with all the previous recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_net_validate.yml` and add the following task
    to store all SVI IP addresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_net_validate.yml` playbook with the following task to ping all
    the SVI `interfaces`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this playbook, we are using the `ios_ping` module, which logs into each
    node defined in our Ansible inventory, and pings the destination specified by
    the `dest` attribute. In this sample playbook, we would like to validate network
    reachability to a single host within the data, voice, and web VLANs, and we choose
    the tenth host in all these VLANs (just as an example). In order to build all
    the VLAN prefixes we set in the first task, we add a new variable called `all_svi_prefixes`
    and use multiple `jinja2` filters to collect only those prefixes that are running
    VRRP (so as to remove any core VLANs). We get only the IPv4 attributes for these
    SVI `interfaces`. The following are the contents of this new variable after running
    the first task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We supply this new list data structure to the `ios_ping` module and we specify
    that we need to ping the tenth host within each subnet. As long as the ping succeeds,
    the task will succeed. However, if there is a connectivity problem from the router/switch
    to this host, the task will fail. We are using the `ignore_errors` parameter in
    order to ignore any failure that might occur owing to the fact that the host is
    unreachable/down, and to run any subsequent tasks. The following code snippet
    outlines the successful run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving operational data from IOS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to execute operational commands on IOS devices
    and store these outputs to text files for further processing. This allows us to
    capture any operational commands from IOS devices during pre- or post-validation
    after we perform any deployment so that we can compare the results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file should
    be in place and the network should already be set up as per the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_op_cmds.yml` and populate it with the following
    tasks to create the directory structure to save the output from the devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_op_cmds.yml` playbook and populate it with the following tasks
    to retrieve the running configuration from the devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook and populate it with the following tasks to retrieve the
    operational commands from the devices and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are using the `ios_command` module in order to execute operational
    commands on the IOS devices, and saving them to text files. In order to achieve
    this goal, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create the folders that we will store the output to, and we create a folder
    called `configs` to store the running config of all the devices. We also create
    an `op_data` file to store the output of the operational commands that we will
    get from the devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then execute the `show running` command on all the IOS devices in our inventory
    and we register the output in a new variable called `show_run`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the copy module to save the output from the previous task to a file for
    each device. The output from the command run is saved in the `stdout` variable.
    As we executed a single command, the `stdout` variable only has a single item
    (`stdout[0]`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we execute this task, we can see that the `configs` folder is populated
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For the next part, we create a folder for each node to store the output from
    the multiple `show` commands that we will execute on the IOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `ios_command` module to execute the `show` commands on the devices,
    and save all the output in a new variable called `op_output.` We use the copy
    execute command, `show ip route`, and we create a file for the output of this
    command with the name `show_ip_route.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this task, we can see that this is the current structure of the
    `op_data` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the content of one of the files to confirm that all the data has
    been stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Validating network states with pyATS and Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to use Ansible and the Cisco pyATS Python
    library to execute and parse operational commands on Cisco devices. Using these
    parsed commands, we can validate various aspects of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that the network has already been built and configured as
    outlined in all the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the Python libraries needed for pyATS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `roles` directory and then create the `requirements.yml` file with
    the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `Ansible-pyats` role as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create a new playbook called `pb_validate_pyats.yml` and populate it with the
    following task to collect the `ospf neighbor` from the `wan` devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following tasks to extract the data for OSPF peer
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following tasks to validate OSPF peers and the
    OSPF peer state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are exploring how to use the `pyATS` framework to perform
    network validation. `pyATS` is an open source Python library developed by Cisco
    as a testing framework for network testing. `Genie` is another Python library
    that provides parsing capabilities for transforming CLI-based output to Python
    data structures that we can consume in our automation scripts. Cisco released
    an Ansible role that uses the pyATS and Genie libraries. Within this role, there
    are multiple modules that we can use in order to build more robust Ansible validation
    playbooks to validate the network state. In order to start working with this role,
    we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `pyats` and `enie` Python packages using `python-pip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Ansible-pyats` role using Ansible-galaxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this recipe, we are using one of the modules within the `Ansible-pyats`
    role, which is `pyats_parse_command`. This module executes an operational command
    on the remote managed device and returns both the CLI output for this command
    and the parsed structured output for this command. The following code snippet
    outlines the structured data returned by this module for `ip ospf neigbor` on
    the `wan01` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We save the data returned by this module to the `ospf_output` variable and we
    use the `set_fact` module to capture the structured data returned by this module,
    before saving it to a new variable – `pyats_ospf_data.` Then, we use the `set_fact`
    module to filter the links defined in `wan_l3_interfaces` to just the ports that
    are enabled for OSPF.
  prefs: []
  type: TYPE_NORMAL
- en: Using the structured data returned by `pyats_parse_command`, we can validate
    this data and compare it with our OSPF peer definition using the `assert` module
    so as to validate the correct number of OSPF peers and their states.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the OSPF peer state, we use the `json_query` filter to filter the
    returned data and provide just the OSPF state for each neighbor.
  prefs: []
  type: TYPE_NORMAL
- en: We are setting `Ansible_connection` to `local` on the play level, and setting
    it to `network_cli` on the `pyats_parse_command` task level, since we only need
    to connect to the device in this task. All the other tasks can run locally on
    the Ansible machine.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the PyATS and Genie libraries and how to use
    them for network testing, please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.cisco.com/docs/pyats/#!introduction/pyats-genie](https://developer.cisco.com/docs/pyats/#!introduction/pyats-genie)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information regarding `json_query` and its syntax, please consult
    the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/user_guide/playbooks_filters.html#json-query-filter](https://docs.Ansible.com/Ansible/latest/user_guide/playbooks_filters.html#json-query-filter)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jmespath.org/tutorial.html](http://jmespath.org/tutorial.html)'
  prefs: []
  type: TYPE_NORMAL
