- en: Chapter 6. Design Patterns for Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the singleton design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the abstract factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the command design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an advanced game using design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us consider that we are faced with a certain problem. After some time, we
    find a solution to that problem. Now, if the problem reoccurs, or a similar pattern
    to the problem reoccurs, we will know how to solve the problem by applying the
    same principle that solved the previous problem. Design patterns are similar to
    this. There are already 23 such solutions documented, which provide subtle solutions
    for dealing with problems that have a similar pattern to the ones that are documented.
    They are described by the authors more commonly referred to as the *Gang of Four*.
    They are not complete solutions, but rather templates or frameworks that can be
    applied to similar situations. One of the biggest drawbacks of design patterns,
    however, is that if they are not applied correctly, they can prove to be disastrous.
    Design patterns can be classified as structural, behavioral, or creational. We
    will be looking at only a few of them, which are used often in games development.
  prefs: []
  type: TYPE_NORMAL
- en: Using the singleton design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton design pattern is the most commonly used design pattern for games.
    Unfortunately, it is also the most overused and most incorrectly applied design
    pattern for games. There are a few advantages of the singleton design pattern,
    which we will discuss. However, it has a lot of serious consequences as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to create a singleton design pattern.
    We will also see the common pitfalls of this design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason why developers want to use a singleton class is when they want
    to restrict to just one instance of the class. In our example, we have taken the
    `PhysicsManager` class. We make the constructor private and then assign a static
    function to get the handle to the instance of the class and hence its methods.
    We also use a Boolean to check if an instance is already created. If it is, we
    do not assign a new instance. If it is not, we assign a new instance and call
    the corresponding methods.
  prefs: []
  type: TYPE_NORMAL
- en: As intelligent as it may seem, this design pattern has many flaws and hence
    should be avoided as much as possible in game design. First, it's a global variable.
    This in itself is bad. A global variable is saved on the global pool and can be
    accessed from everywhere. Second, this encourages bad coupling, which may appear
    in the code. Third, it is not concurrent friendly. Imagine there are multiple
    threads, and each thread can access this global variable. This is a recipe for
    disaster, as deadlock will happen. Finally, one of the most common mistakes made
    by new programmers is to create managers for everything, and then make the manager
    a singleton. The fact is that we can get away without creating a manager by using
    OOPS and references in an effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows a lazy value of initializing a singleton and hence
    can be improved. However, all the fundamental problems described in this recipe
    will still remain.
  prefs: []
  type: TYPE_NORMAL
- en: Using the factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A factory is essentially a warehouse for creating objects of other types. In
    a factory method design pattern, the creation of a new type of object, such as
    an enemy or a building, happens from an interface and the subclass decides which
    class it needs to instantiate. This is also a commonly used pattern in games and
    can be quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to write a factory method design
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we have created a `Building` interface, which has a pure virtual
    function for `TotalHealth`. This means all the derived classes must override this
    function. Therefore, we can guarantee that all our buildings will have this property.
    We can keep adding to this structure by having more properties, such as hit points,
    total storage capacity, rate of production of villagers, and so on, based on the
    nature and design of the game. The derived classes have their own implementation
    of `TotalHealth`. They are also named to reflect the type of building they are.
    The biggest advantage of this design pattern is that all we need on the client
    side is a reference to the base interface. After that, we can create the type
    of building we need at runtime. We store these building types in a vector list
    and finally use a loop to display the contents. Since we have the reference `IBuilding*`,
    we can assign any new derived class we want at runtime. There is no need to create
    references for all derived classes, such as `Temple*` and so on. The following
    screenshot shows the output we are likely to get for a user-defined village:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the abstract factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract factory is a part of the creational design pattern. It is one of
    the best ways to create an object and is a commonly repeated design pattern in
    games. It is like a factory of factories. It uses an interface to create a factory.
    The factory is responsible for creating objects without specifying their class
    type. The factory generates these objects based on the factory method design pattern.
    However, some argue that the abstract factory method can also be implemented using
    the prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to implement the abstract factory
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created two interfaces, namely `IFast` and `ISlow`.
    After that we have created several enemies and decided whether they are fast or
    slow. Finally, we created an abstract class with two virtual functions to get
    the fast enemy and the slow enemy. This means all the derived classes must override
    and have their own implementation of these functions. So in effect we have created
    a factory of factories. The land, air, and water enemy factories that we have
    created from the abstract class have references to two interfaces for slow and
    fast. Hence the land, water, and air serve as factories themselves too.
  prefs: []
  type: TYPE_NORMAL
- en: 'So from the client side, we can request a fast land enemy or a slow water enemy
    and we can get the appropriate enemy displayed to us. As the following screenshot
    shows, we can get the output as displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer design pattern is one which is not commonly used in games, but
    it should be used more often by game developers as it is a very smart way to handle
    notifications. In the observer design pattern, a component maintains a one-to-many
    relationship with other components. This means when the main component changes,
    all the dependent components also update. Imagine a physics system. We want `enemy1`
    and `enemy2` to update as soon as the physics system updates, so we should use
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to implement the observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 Windows application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created a physics system that continuously updates
    its value. Other components that are dependent on the physics system must attach
    themselves to it, so that they are notified as soon as the physics system is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The physics system that we have created holds a vector list of all the components
    that are being observing from it. In addition to this, it contains methods to
    get the current value or set a values for it. It also contains a method to notify
    all the dependent components once a value has been changed in the physics system.
    The `Observer` class contains a reference to the physics system, as well as a
    pure virtual function for updates, which the derived class must override. The
    `PlayerObserver` and `AIObserver` classes can derive from this class and have
    their own implementation of impulse based on the changes in the physics system.
    Both the AI and player systems will continuously receive updates from the physics
    system unless they detach themselves from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very useful pattern and has loads of implementation in games. The
    following screenshot shows what a typical output would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flyweight design pattern is mostly used when we want to reduce the amount
    of memory that is used to create the objects. This pattern is often used when
    we want to create something hundreds or thousands of times. Games with a forest
    structure often use this design pattern. This design pattern falls under the structural
    design category. In this pattern, the object, let's say the tree object, is divided
    into two parts, one that is dependent on the state of the object and one that
    is independent. The independent part is stored in the flyweight object, whereas
    the dependent part is handled by the client and sent to the flyweight object as
    and when invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to implement the flyweight
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created a forest. The basic principle of the flyweight
    pattern is applied, whereby part of the structure is shared across all trees and
    part is dictated by the client. In this example, apart from the size (this could
    be anything, size is just chosen to be an example), every other attribute is chosen
    to be shared. We create a tree-type interface which contains all the attributes.
    We then have derived classes that have their attributes overridden and a method
    to set the `size` attribute. We can have multiple such trees. Generally, the greater
    the variety of trees, the more detailed the forest will look. Let us say that
    we have 10 different types of tree, so we need to have 10 different classes that
    derive from the interface and have a method to assign the `size` attribute from
    the client size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the tree factory, which assigns each tree at runtime. We create
    a reference to the interface as we do with any factory pattern. However, instead
    of directly instantiating a new object, we first check the map to see whether
    the tree''s attributes are already present. If they are not, we assign a new object
    and push the attributes to the map. So the next time a request comes for a similar
    tree structure to one that has already been assigned, we can share the attributes
    from the map. Finally, from the client, we create a forest-type document which
    we feed to the factory, and it generates the forest for us using the trees listed
    in the document. As the majority of the attributes are shared, the memory footprint
    is very low. The following screenshot shows us how the forest is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy design pattern is a very smart way of designing code. In games,
    this is mostly used for the AI component. In this pattern, we define a large number
    of algorithms and have all of them from a common interface signature. Then at
    runtime, we can change the clients of the algorithms. So in effect, the algorithms
    are independent of the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to implement the strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a Win32 console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Source.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created different interfaces for different properties
    that the enemy may have. So, since we know that special power is a property every
    enemy type will have, we have created an interface called `SpecialPower` and then
    derived two classes from it called `Fire` and `Invisibility`. We can add as many
    special powers as we want, we just need to create a new class and derive from
    the special power interface. Similarly, all the enemy types should have a property
    for flying. Either they fly, or don't fly, or fly with the help of jetpacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have created a `FlyBehaviour` interface and have the different flying-type
    classes derive from it. After that, we have created an abstract class for the
    enemy type which contains both the interfaces as references. Hence any derived
    class can decide what flying type and what special power it needs. This also gives
    us the flexibility to change special powers and flying ability at runtime. The
    screenshot below shows a brief example of this design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the command design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command design pattern generally involves encapsulating a command as an
    object. This is highly used in networking for games, in which player movements
    are sent across as objects that are run as commands. The four main points to remember
    in a command design pattern are the client, invoker, receiver, and command. The
    command object has knowledge of the receiver object. The receiver does the work
    after it receives a command. The invoker performs the command, without having
    any knowledge of who has sent the command. The client controls the invoker and
    decides which commands are to be performed at which stage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to implement the command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see in this example, we have set up an interface to send information
    via the network protocol command. From that interface, we can derive multiple
    child instances to be used on the client side. We then need to create a server
    receiver, which will receive commands sent from the client. We also need to create
    a client invoker, which will invoke the command. A reference to the network protocol
    command should also be present in this class. Finally, from the client side, we
    need to create an instance of the server and attach the instance to the object
    of the network protocol command''s child that we created. We then use the client
    invoker to invoke the command and send it via the network protocol command to
    the receiver. This ensures that an abstraction is maintained and the entire message
    is send via packets. The following screenshot shows a part of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an advanced game using design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After understanding the basic design patterns, it's important to combine them
    to create a good game. It takes years of practice to finally understand what architecture
    will suit the game structure. More often than not, we have to use a few design
    patterns in conjunction to come up with clean code that can be applied to the
    game. The factory pattern will probably be your most used design pattern, but
    that is purely an anecdotal reference from my experience.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we will find out how easy it is to combine design patterns to
    create a game:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous code is just a small section of the code. Let us assume that we
    need to make a game where there are different classes of enemies and there are
    different types of powers, as well as some special boosts or power-ups. One approach
    to this is to think of all the powers and special boosts as individual classes
    that derive from an interface. So we need to create an interface for speed, which
    can be derived from the `HighSpeed` class and so on. Similarly, we can create
    a `SpecialPower` interface, which can be derived by the `Fire` class and so on.
    We need to create interfaces for all the groups of properties that our characters
    can have. Finally, we need to create an interface for the characters (`IEnemy`)
    that is derived by the `Soldier`, `Archer`, and `Grenadier` class, and so on.
    The `IEnemy` interface should also hold a reference to all the other interfaces,
    such as `ISpecialPower` and `ISpeed`. In this way, the child classes of `IEnemy`
    can decide what power and speed they want to have. This is similar to the strategy
    design pattern. We can further improve this structure if we want to group the
    enemies into types, let's say land enemies and air enemies. In that case, either
    we create an interface for `IType` and have `Land` and `Air` classes derive from
    it, or we could create a factory that creates enemy types for us depending on
    the type the client requests. Each enemy type created will also be a derived class
    from `IEnemy`, so that it will also have the references to the previous interfaces.
    As the complexity of the game increases, we can add more design patterns to aid
    us.
  prefs: []
  type: TYPE_NORMAL
