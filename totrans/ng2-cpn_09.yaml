- en: Chapter 9. Angular 2 Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we learned how to craft Angular 2 components. Before we
    end our journey, it's important to understand that Angular 2 didn't kill the concept
    of directives. As a matter of fact, a component *is* a directive. In this chapter,
    we will introduce Angular 2 directives and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between components and directives in Angular 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 directive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a simple attribute directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a simple structural directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components and directives in Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have built components. But components do not replace the directives
    that we are familiar with from Angular 1\. If you are not familiar with Angular
    1 directives, don't worry, we will explain the difference in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining what a directive is in Angular terminology: a directive
    is a custom attribute or an element that extends HTML tags by adding custom behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Angular 2, we have three types of directive: component directive, attribute
    directive, and structural directive. We are already familiar with components,
    so let''s define the other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute directive**: This changes the appearance or behavior of an element.
    One example for this can be the NgStyle directive from Angular core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural directive**: This manipulates the DOM, just like NgFor and NgSwitch
    from the Angular core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives as opposed to components, do not require a template, and usually
    define a selector as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like for previous chapters, let''s create a new project as explained in [Chapter
    2](part0020.xhtml#aid-J2B81 "Chapter 2. Setting Up an Angular 2 Development Environment
    with angular-cli"), *Setting Up an Angular 2 Development Environment with angular-cli*.
    You can also remove all the existing folders and remove all the unnecessary code
    from `app.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The basic attribute directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new file for our directive named `text-marker.ts`.
    Inside it, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To create a directive, we need to import the `Directive` decorator function
    from Angular core. We will also need two more classes named `ElementRef` and `Renderer`
    to manipulate the element. They are injected to our directive class from its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: This directive will add styling to the element and decorate the text with an
    underline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this directive by applying it on our `app component` template.
    Open `index.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add the `TextMarker` class to the `declarations` attribute
    of the root module. This operation will be required for all custom components
    and directives implemented in this chapter. Open the `app.module.ts` file and
    update it as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the browser and inspect the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic attribute directive](../Images/image00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ElementRef and Renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attribute directives intend to add behavior to an element. For this, we need
    to gain access to the element itself. In Angular 2, direct access to a DOM element
    is considered to be bad practice. Angular keeps the code separated from the view
    layer by introducing an abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: To reference the element, we use `ElementRef`, which is the class that represents
    the type of element of the platform we are running on. In our case, it's the browser
    DOM. The `ElementRef` class has the ability to reveal the native element that
    it wraps, but we won't need it. Instead, we will use another class named `Renderer`
    and pass the `ElementRef` instance to it. `Renderer` is a class that exposes methods
    for manipulating the element, without specifying which type of element it is.
    This mechanism keeps our code decoupled from the element's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to events from the host element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An attribute directive applies on an element. If we want to react to the events
    that this element fires, we can use the `HostListener` decorator on some methods
    of the `Directive` class. In the following example, our directive will listen
    to mouse events from the element and change the style in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, the style will be applied and removed each time the mouse enters and leaves
    the element that *host* the attribute directive.
  prefs: []
  type: TYPE_NORMAL
- en: Passing properties to the directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also pass configuration into the directive by using properties. Just
    like components, directives can declare inputs. Let's refactor our `Directive`
    class to fetch and apply a text color from a property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `Input` decorator, we can accept the value of the property (in
    our case, it is `text-marker`) and use it inside our directive class. Now we can
    pass the color that we want to use. Open `app.component.ts` and try the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each time the mouse enters the `h1` element, the text should be colored
    in red and decorated with an underline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing properties to the directive](../Images/image00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The basic structural directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, the third type of directive
    is called structural directives, and as the name suggests, those directives are
    meant to manipulate the element that they applied on. Angular core includes several
    directives that manipulate the DOM, such as `ngIf`, `ngFor`, and `ngSwitch`.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will implement our own `ngIf` directive that behaves just
    like the original one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new file named `only-if.ts` and let''s define the basic structure
    for our directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The structural directives begin their lives just like an attribute directive.
    We import the `@Directive` decorator from the Angular core and declare the selector
    as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to access the template, and we will need some kinds of container
    so we can attach or remove views. For this, we will need to inject `TemplateRef`
    and `ViewContainerRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our directive, just like the Angular `ngIf`, needs to receive a Boolean from
    its caller that represents the condition on which the content will be shown or
    removed. For this, we will declare an input for this condition and make use of
    `ViewContainerRef` and `TemplateRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make use of this directive. Open `app.component.ts` and paste the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add the `OnlyIf` class to the `declarations` attribute of the
    root module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore what''s going on: when we use the asterisk (`*`) to call our
    directive, Angular creates a `<template>` tag behind the scenes. Inside our directive,
    we can get a reference for this template through the `TemplateRef` class. Then,
    we can use the `ViewContainerRef` class, which represents a `container` so that
    we can embed a view into it, to create or clear a view from the content of the
    template.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Angular 2, there are three types of directive: component directive, attribute
    directive, and structural directive. Throughout this chapter, we got a quick introduction
    to them and learned how to build simple directives. Directives can do much more,
    but that''s beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
