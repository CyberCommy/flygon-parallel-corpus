- en: Chapter 4. Game Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actors and entities are integral parts of the game, but game rules are what
    tie them together. The game rules system manages all initial player events, such
    as OnConnect, OnDisconnect, and OnEnteredGame.
  prefs: []
  type: TYPE_NORMAL
- en: Using the game rules system, we can create custom game flow to control and tie
    our gameplay mechanics together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the basic concept of a game mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our `IGameRules` implementation in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write game rules scripts in Lua and C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to game rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When thinking of a game, we typically direct our thoughts to game mechanics
    such as the handling of deaths and end game conditions. Based on what we've learned
    in the previous chapters, we can't really accomplish this due to every entity
    and actor not affecting a grander scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Game rules do exactly what the name implies; control the rules of the game.
    A rule can be simple, like a rule for what happens when one actor shoots the other,
    or more complex, for example, start and end rounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CryENGINE game rules implementation revolves around two very similar sounding
    types that are still quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game rules**: This implementation is done via the `IGameRules` interface
    in C++, and it handles callbacks such as `OnClientConnect` and `OnClientDisconnect`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game mode**: This is reliant on the game rules implementation, but extends
    it with game conditions such as actor spawning and kill conditions. For example,
    we could have two game modes; SinglePlayer and DeathMatch, both which rely on
    the default behavior provided by the `IGameRules` implementation, but each adding
    additional functionality, such as support for multiple players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IGameRules interface – game rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the end of [Chapter 3](ch03.html "Chapter 3. Creating and Utilizing Custom
    Entities"), *Creating and Utilizing Custom Entities*, we learned about game object
    extensions. We'll be using that knowledge in this chapter to implement `IGameRules`,
    a game object extension used to initialize the game context and tie gameplay mechanics
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always keep in mind that the currently active game mode is an entity. This can
    sometimes be abused by requesting entity events. For example, a common hack in
    the Crytek game, Crysis, revolved around sending a bullet or kill event on the
    game mode. This essentially "killed" the game rules entity and resulted in a hard
    server crash.
  prefs: []
  type: TYPE_NORMAL
- en: The `IGameRules` implementation is commonly responsible for the most basic behavior
    of your game modes, and forwards everything else to its C# or Lua script.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting – game modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After registering our `IGameRules` implementation, we'll need to register a
    game mode that utilizes it. This is done using the `IGameRulesSystem::RegisterGameRules`
    function (commonly done inside `IGame::Init`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After having processed the previous snippet, the game rules system will be aware
    of our game mode. When the `sv_gamerules` console variable is changed to `MyGameMode`,
    the system will create a new entity and activate its game object extension called
    `GameRules` (registered in the previous section).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The console variable `sv_gamerules` is set to the value of `sv_gamerulesdefault`
    on CryENGINE startup, unless running on a dedicated server.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the game will automatically search for a Lua script named after
    your game mode in `Scripts/GameRules/`. For the previous snippet, it would find
    and load `Scripts/GameRules/MyGameMode.lua`.
  prefs: []
  type: TYPE_NORMAL
- en: By using scripts, the game rules implementation can forward game events (such
    as new player connections) to Lua or C#, allowing each game mode to specialize
    behavior depending on its internal logic.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a level is loaded using the map console command, the game framework searches
    for the level inside `Game/Levels`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `IGameRulesSystem::AddGameRulesLevelLocation`, we can add subdirectories
    within `Game/Levels` which will be searched when looking for a new level. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When loading a level with `sv_gamerules` set to `MyGameMode`, the game framework
    will now search in the `Levels/MGM_Levels/` directory for the level directory.
  prefs: []
  type: TYPE_NORMAL
- en: This allows game mode specific levels to be moved to subdirectories within the
    `Game/Levels` directory, making it much easier to sort levels by game mode.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game rules interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the basic workings of the game rules system, we can give creating
    a custom `IGameRules` implementation a shot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start, consider whether you actually need a custom `IGameRules` implementation
    for your game. The default GameDLL that ships with `CGameRules`, is an `IGameRules`
    implementation specialized for **First-Person Shooters** (**FPS**). If your game
    premise is similar to a FPS, or if you can reuse existing functionality that might
    be preferrable to writing an implementation from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we'll need to create two new files; `GameRules.cpp` and `GameRules.h`.When
    you're done, open `GameRules.h` and create a new class. We'll be naming ours as
    `CGameRules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the class is in place, we have to derive from `IGameRules`. As we mentioned
    before, game rules are handled as game object extensions. We''ll therefore have
    to use the `CGameObjectExtensionHelper` template class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The third and optional `CGameObjectExtensionHelper` parameter defines how many
    RMIs this game object support. We'll cover it further in [Chapter 8](ch08.html
    "Chapter 8. Multiplayer and Networking"), *Multiplayer and Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the class present, we can start implementing all the pure virtual methods
    defined in the `IGameRules` and `IGameObjectExtension` structs. As with entities,
    we can implement dummies that return either nothing, nullptr, zero, false or an
    empty string. The methods that need to be handled separately are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IGameObjectExtension::Init` | Called to initialize the game object extension.
    Should call `IGameRulesSystem::SetCurrentGameRules(this)` |'
  prefs: []
  type: TYPE_TB
- en: '| `IGameRules::OnClientConnect` | Called on the server when a new client connects,
    has to create a new actor using `IActorSystem::CreateActor` |'
  prefs: []
  type: TYPE_TB
- en: '| `IGameRules::OnClientDisconnect` | Called on the server when a client disconnects,
    has to contain a call to `IActorSystem::RemoveActor` |'
  prefs: []
  type: TYPE_TB
- en: '| `IGameObjectExtension::Release / Destructor` | The `Release` function should
    delete the extension instance and call `IGameRulesSystem::SetCurrentGameRules(nullptr)`
    via its the destructor |'
  prefs: []
  type: TYPE_TB
- en: Registering the game object extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you're done, register the game rules implementation by using the `REGISTER_FACTORY`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Game object extensions have to be registered early in the game initialization
    process, and therefore most commonly done in the `IGame::Init` function (via `GameFactory.cpp`
    in the default GameDLL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom game modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we'll need to register our first game mode.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the difference between the `IGameRules` implementation, and the game mode
    itself. The game mode is dependent on the `IGameRules` implementation, and is
    registered separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register custom game modes, CryENGINE exposes the `IGameRulesSystem::RegisterGameRules`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will create a game mode called `MyGameMode`, which depends
    on the `GameRules` game object extension we registered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: When a map is loaded with `sv_gamerules` set to `MyGameMode`, the game rules
    entity will be created and assigned the name `MyGameMode`. After spawning, the
    `IGameRules` extension we created earlier will be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are simply creating a copy or subclass of an existing game mode, for
    example, the default `DeathMatch.lua` script that derives from `SinglePlayer.lua`,
    you'll need to register the `DeathMatch` game mode separately.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game modes are typically heavily scripting-oriented, with game flow such as
    spawning, killing, and reviving being delegated to a secondary language such as
    Lua or C#.
  prefs: []
  type: TYPE_NORMAL
- en: Lua scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Lua scripts are integrated into the CryENGINE, we don''t need to do any
    additional loading for it to work. To access your script table (based on the Lua
    file named the same as your game mode in `Game/Scripts/GameRules`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Invoking methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To invoke methods on your script table, see the `IScriptSystem BeginCall` and
    `EndCall` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the previous code, we''ll be able to execute Lua code in a function
    named `MyMethod` contained inside our game mode''s script table. An example of
    the table can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Invoking methods with parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To provide your Lua method with parameters, use `IScriptSystem::PushFuncParam`
    between the beginning and end of your script call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`IScriptSystem::PushFuncParam` is a template function that attempts to create
    a `ScriptAnyValue` object with the provided value. If the default `ScriptAnyValue`
    constructors don''t support your type, a compiler error will appear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations, you have now called a Lua function with a string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Getting values returned from Lua
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also get return values from Lua functions by passing an additional parameter
    to `IScriptSystem::EndCall`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Getting table values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes it might be necessary to get values directly from Lua tables, this
    can be done using `IScriptTable::GetValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will search for a variable called `bMyBool` in the script,
    and if successful, set its value to the native `bValue` variable.
  prefs: []
  type: TYPE_NORMAL
- en: CryMono scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an instance of a CryMono script in your `IGameObjectExtension::Init`
    implementation, see `IMonoScriptSystem::InstantiateScript`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code will find a CryMono class with the current game mode's name, and return
    a new instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no need to use both Lua and CryMono game rules scripts simultaneously.
    Decide which is best for your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have your class instance, you can invoke one of its functions
    using the `IMonoObject::CallMethod` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will search for a method named `OnClientConnect` with matching arguments,
    and invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`IMonoObject::CallMethod` returns a `mono::object` type by default, which represents
    a boxed managed object. To get the native value, we''ll have to unbox it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get the value of a property in your managed object, have a look at `IMonoObject::GetPropertyValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to set property values directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to get and set the values of fields in the same way you
    would with properties, but using the `IMonoObject` methods, `GetFieldValue` and
    `SetFieldValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic game mode in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the basic knowledge required to create a mini-game, why not
    do so? To start off, we'll aim towards creating a very basic system for spawning
    actors and entities.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our intention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, let''s clarify exactly what we want to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn our actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign our actor to one of the two possible teams.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check when an actor enters the opposite team's `Headquarters` entity, and end
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is spawn our actor, which can''t be done before
    we have one. To do this, we''ll need to create a `MyActor.cs` file somewhere in
    the `Game/Scripts` directory and then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet is the bare minimum required for an actor to be registered.
  prefs: []
  type: TYPE_NORMAL
- en: We should also update our actor's view, to make sure the player sees something
    when entering the game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will simply set the camera to use the player entities' position
    and rotation, with a field of view of 60.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about creating actors and views, refer to [Chapter 5](ch05.html
    "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our actor, we can move on to creating the game mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As with all CryMono types found in the `Game/Scripts/` directory, our game mode
    will be automatically registered on CryENGINE startup, shortly after the call
    to `IGameFramework::Init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to creating game-specific logic, we''ll have to make sure
    our actor is created when the actor connects. To do so, we implement an `OnClientConnect`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as script functions aren''t automated, we''ll need to modify our `IGameRules`
    implementation''s `OnClientConnect` method to make sure we receive this callback
    in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, when a new player connects to the server, our `IGameRules` implementation
    will call `ReachTheHeadquarters.OnClientConnect`, which in turn creates a new
    actor of type `MyActor`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the game mode's `OnClientConnect` is called very early, right
    at the point when a new client is connecting to the server. If an actor has not
    been created for the specified `channelId` after `OnClientConnect` exits, the
    game will throw a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The actor will now be created when the client connects, but what about actually
    repositioning the actor to a **SpawnPoint** ? To start, create a new `SpawnPoint.cs`
    file somewhere in the `Scripts` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This entity should now appear in **RollupBar** after you restart the Editor.
    We'll be calling the `spawnPoint.Spawn` function to spawn our actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll need to open our `ReachTheHeadquarters` class and add a new
    `OnClientEnteredGame` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function will be called when the client enters the game. In Launcher mode
    this typically happens when the player has finished loading, whereas in Editor
    it is called when the player switches into **pure game mode** following *Ctrl*
    + *G*.
  prefs: []
  type: TYPE_NORMAL
- en: At its current state, we'll first get the `MyActor` instance of our player,
    and then spawn at a randomly selected `SpawnPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to call your script's `OnClientEnteredGame` function from your
    `IGameRules` implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Handling disconnections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll also have to make sure the actor is removed when the player disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to call the `OnClientConnect` function from your `IGameRules` implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Failure to remove the player after disconnection will result in the actor persisting
    in the game world, and more severe issues can appear due to the associated player
    no longer having a connection to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the player to a team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that players can connect and spawn, let's implement a basic teams system
    to keep track of which team each player belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, let''s add a new `Teams` property to our game mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code simply determines which teams our game mode allows for, in our case
    `Red` and `Blue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s also add a new property to our `MyActor` class, to determine which
    team the actor belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Great! However, we'll also need to add the same snippet to the `SpawnPoint`
    entity to avoid spawning players of the same team next to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done this, open the `ReachTheHeadquarters` game mode class and
    navigate to the `OnClientEnteredGame` function we created earlier. What we want
    to do is expand the `SpawnPoint` selection to only use ones belonging to the player's
    team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace this snippet with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically remove all SpawnPoints in which the `Team` property
    is not equal to that of the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait, we also have to assign the player to a team! To do so, add the following
    before getting the SpawnPoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When a player enters the game, we'll select a random team to assign them to.
    If you want, why not expand this to make sure teams are always balanced? For example,
    don't allow a new player to join team Red if it already has two more players than
    Blue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving on, feel free to play around with the current setup. You should
    be able to spawn in game!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Headquarters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let's move on to creating our end game condition; Headquarters. In
    simple terms, each team will have one `Headquarters` entity, and when a player
    enters the headquarters of the opposite team, that player's team wins the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the end game event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before creating the `Headquarters` entity, let''s add a new `EndGame` function
    to our `ReachTheHeadquarters` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We'll call this from the `Headquarters` entity, in order to notify the game
    mode that the game should be ended.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Headquarters entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to create our `Headquarters` entity (see the following code snippet).
    The entity will be placed in each level via Sandbox, once per team. We''ll expose
    three Editor properties; `Team`, `Minimum`, and `Maximum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Team`: This determines which team the `Headquarters` instance belongs to,
    in our case either Blue or Red'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minimum`: This specifies the minimum size of the trigger area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Maximum`: This specifies the maximum size of the trigger area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we just have to expand the `OnEnterArea` method to notify our game
    mode when the game should end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Headquarters` entity will now notify the game mode when an entity of the
    opposite team enters it.
  prefs: []
  type: TYPE_NORMAL
- en: Detour – trigger bounds and entity areas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Entities can receive area callbacks by registering an area. This can be done
    by linking the entity to a shape entity or by creating a trigger proxy manually.
    In C# you can create a proxy manually by setting the `EntityBase.TriggerBounds`
    property as we have done in the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: When an entity is positioned inside or close to the area, it will start receiving
    events on that entity. This allows specific entities to be created that can track
    when and where players enter specific areas, to trigger specialized gameplay logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following table for a list of available area callbacks, receivable
    via entity events in C++ and virtual functions in the C# `Entity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Callback name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `OnEnterArea` | Called when an entity has entered the area linked to this
    entity |'
  prefs: []
  type: TYPE_TB
- en: '| `OnLeaveArea` | Triggered when an entity present inside the area linked to
    this entity has left |'
  prefs: []
  type: TYPE_TB
- en: '| `OnEnterNearArea` | Triggers when an entity moves near the area linked to
    this entity |'
  prefs: []
  type: TYPE_TB
- en: '| `OnMoveNearArea` | Called when an entity moves near the area linked to this
    entity |'
  prefs: []
  type: TYPE_TB
- en: '| `OnLeaveNearArea` | Called when an entity leaves the area near to the area
    linked to this entity |'
  prefs: []
  type: TYPE_TB
- en: '| `OnMoveInsideArea` | Triggered when an entity is repositioned inside the
    area linked to this entity |'
  prefs: []
  type: TYPE_TB
- en: Populating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic sample is now complete, but requires some tweaks to get it working!
    First, we'll need to create a new level and place `Headquarters` for each team.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, open the Sandbox Editor and create a new level by navigating to **File**
    | **New**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating the level](img/5909_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This brings up the **New Level** dialog, in which we can set the level name
    and terrain settings.
  prefs: []
  type: TYPE_NORMAL
- en: After clicking on **OK**, your level will be created and then loaded. Once done,
    it's time to start adding the necessary gameplay elements to our level!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, open **RollupBar** and spawn the **Headquarters** entity by dragging
    it into the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating the level](img/5909_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once spawned, we have to set the Editor properties we created in the **Headquarters**
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Set **Team** to **Red** and **Maximum** to **10,10,10**. This informs the class
    of which team `Headquarters` belongs to, and the maximum size of the area which
    we'll be querying to detect whether another player has entered it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating the level](img/5909_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have done this, spawn another **Headquarters** entity (or copy the
    existing one) and follow the same process, except this time set the **Team** property
    to **Blue**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just have to spawn one SpawnPoint entity per team and we''re ready
    to go! Open **RollupBar** again and go to **Others** | **SpawnPoint** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating the level](img/5909_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, drag the entity onto the viewport to spawn it in the same way you did
    to spawn **Headquarters**. Once spawned, set the **Team** property to **Red**
    and then repeat the process for the Blue team:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating the level](img/5909_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Done! You should now be able to enter the game using *Ctrl* + *G* or by navigating
    to **Game** | **Switch to Game**. However, as we haven't added any type of player
    movement, the players won't be able to navigate towards the enemy headquarters
    to end the game.
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to handle player input and movement, refer to the next chapter,
    [Chapter 5](ch05.html "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the basic behavior of the game rules system,
    and created our own `IGameRules` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: After having registered your own game mode, and created the `Headquarters` sample
    in C#, you should have a good understanding of the game rules system.
  prefs: []
  type: TYPE_NORMAL
- en: We've created our first game mode, and can now move onto the next chapter. Keep
    in mind the purpose of game rules in future chapters, so you can tie together
    all the game mechanics that need to be created in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Not satisfied with game rules yet? Why not try and create a basic rule-set for
    your game in a scripting language of your choice, or perhaps extend the sample
    we created previously. In the next chapter, we will see how to create custom actors.
  prefs: []
  type: TYPE_NORMAL
