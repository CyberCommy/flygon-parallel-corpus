- en: Coding for User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine several often overlooked, but valuable, aspects
    of programming, chiefly testing, user experience, and dependency graphs. While
    these topics might not feel like they have anything to do with; **Dependency Injection**
    (**DI**), they have been included to give you a solid but pragmatic foundation
    from which you can evaluate the techniques in the second part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for humans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A security blanket named *unit tests*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-induced damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing your package dependencies with Godepgraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering a good user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good user experience does not need to be divined. It does not need to be handed
    down from some experienced guru either. In fact, the problem with experience is
    that what is easy, simple, and obvious to you today is vastly different from what
    it was last month, last year, or when you were starting out.
  prefs: []
  type: TYPE_NORMAL
- en: A good UX can be discovered through logic, persistence, and practice. To find
    out what a good UX looks like for your user, you can apply my UX discovery survey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ask yourself the following four questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Who is the user?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are your users capable of?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do users want to use your code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do your users expect to use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need a basic understanding of Go.
  prefs: []
  type: TYPE_NORMAL
- en: All code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch03](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch03).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for humans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, we have seen the rise of the term UX, which stands for user
    experience. At its core, UX is about usability—understanding the user and crafting
    interactions and interfaces to be more intuitive or more natural for them to use.
  prefs: []
  type: TYPE_NORMAL
- en: UX typically refers to customers, which makes sense—that is, after all, where
    the money is. However, we programmers are missing out on something rather significant.
    Let me ask you, who are the users of the code you write? Not the customers that
    use the software itself. The users of the code are your colleagues and the future
    version of you. Would you like to make their life easier? Put in a different way,
    would you rather spend your future trying to figure out the purpose of a piece
    of code or extending the system? That is where the money is. As programmers, we
    get paid to deliver features rather than beautiful code, and code with good UX
    enables the faster delivery of features, and with less risk.
  prefs: []
  type: TYPE_NORMAL
- en: What does user experience mean for Go code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does UX mean for Go code? The short version is, *we should write code whose
    general intent is understood after a quick first read by any competent programmer*.
  prefs: []
  type: TYPE_NORMAL
- en: Did that sound a bit like hand waving? Yeah, it might be hand waving. It's a
    standard problem with solving problems in any creative endeavor; you know it when
    you see it, and you feel it when it doesn't exist. Perhaps the main reason it
    is so hard to define is that the definition of *competence *varies significantly
    based on the members of the team and the environment. Similarly, the reason it
    is often hard to achieve is due to the fact that code inherently makes more sense
    to the author than anyone else.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's look at some simple principles to start off in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Start with simple – get complicated only when you must
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As programmers, we should always strive to keep things simple, and resort to
    complexity when there is no other way. Let''s see this principle in action. Try
    to determine what this next example does in three seconds or less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'How about this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Applying the approach embodied in the first code to an entire system will almost
    certainly make it run faster, but not only did it likely take longer to code,
    but it's also harder to read and therefore maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: There will be times when you need to extract extreme performance from your code,
    but it's far better to wait until it cannot be avoided before burdening yourself
    with the extra complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Apply just enough abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Excessive abstraction leads to an excessive mental burden and excessive typing.
    While some may argue that any code fragment that could be swapped out or extended
    later deserves an abstraction, I would argue for a more pragmatic approach. Implement
    enough to deliver the business value we are tasked with and then refactor as needed.
    Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the previous code to the following usage of the commonly understood
    concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Follow industry, team, and language conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concepts, variables, and function names all *just make sense *when they follow
    conventions. Ask yourself, if you are working on a system about cars, what would
    you expect a variable called `flower` to be?
  prefs: []
  type: TYPE_NORMAL
- en: Coding style is arguably something that Go got right. For many years, I was
    part of the *bracket placement *and the *tab versus spaces *wars, but when switching
    to Go, all of that changed. There is a fixed, documented, and easily reproducible
    style—run `gofmt`, problem solved. There are still some places where you can hurt
    yourself. Coming from a language with unchecked exceptions, you might be tempted
    to use Go's `panic()` phrase; while possible, it is one of several conventions
    explicitly discouraged in the official Code Review Comments wiki ([https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)).
  prefs: []
  type: TYPE_NORMAL
- en: Team conventions are a little bit harder to define, and perhaps sometimes to
    follow. Should a variable of the `channel` type be called `result`, `resultCh`,
    or `resultChan`? I have seen, and probably written, all three.
  prefs: []
  type: TYPE_NORMAL
- en: How about error logging? Some teams like to log errors at the point at which
    they are triggered, and others prefer to do so at the top of the call stack. I
    have a preference, as I am sure you do, but I have yet to see an overwhelmingly
    compelling argument for either.
  prefs: []
  type: TYPE_NORMAL
- en: Export only what you must
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are careful and stingy about your exported API, many good things happen.
    Chiefly, it becomes easier for others to understand; when a method has fewer parameters,
    it is naturally easier to understand. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What does `true` mean? It''s hard to tell without opening the function or the
    documentation. However, what if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the purpose is clear, mistakes are unlikely and, as a bonus, encapsulation
    is improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, interfaces and structs with fewer methods and packages with objects
    are all easier to understand, and are more likely to have a more definite purpose.
    Let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the preceding code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Yes, in both of these cases, the result was more code. More straightforward
    code, but more code nonetheless. Providing a better UX for users will frequently
    incur a little bit more cost, but the productivity gains for the users are multiplicative.
    Considering the fact that, in many cases, one of the users of the code that you
    write is future you, you could say that a bit of extra work now saves you lots
    of work in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing along the line of looking out for *future me*, the second advantage
    this approach offers is it makes it easier to change your mind. Once a function
    or type is exported, it can be used; once used, it has to be maintained and takes
    much more effort to change. This approach makes such changes easier.
  prefs: []
  type: TYPE_NORMAL
- en: Aggressively apply the single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, applying the **single responsibility principle** (**SRP**)
    encourages objects to be more concise and more coherent and therefore easier to
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: Who is the user?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the time, the answer will be *future me *and my colleagues. Your *future
    me *will be a better, smarter, and more handsome version of who you are now. Your
    colleagues, on the other hand, are harder to predict. If it helps, we can avoid
    considering the smart, fantastic ones; hopefully, whatever we do, they will understand.
    An intern, on the other hand, will be harder to predict. Chances are that if we
    can make our code make sense to them, then it will be just fine for everyone else.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever have the chance to write software libraries for company-wide or
    general use, then this answer becomes a whole lot harder. In general, you want
    to aim low and only depart from a standard and straightforward format when there
    is no other choice.
  prefs: []
  type: TYPE_NORMAL
- en: What are your users capable of?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are clear on who the users are, we can develop a better understanding
    of their worldview. There is likely a massive disparity between the skills, experience,
    and domain knowledge between you and your users, and even between you and future
    you. This where most technical tools and software libraries fail. Think back to
    when you just started with Go. What did your code look like? Were there any language
    features in Go that you weren''t using yet? Personally, I come from a Java background
    and, because of this, I entered the field with some preconceived ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: I thought that threads were expensive (and that goroutines were threads)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I thought that everything had to be in a struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being used to explicit interfaces meant that I was not as enthusiastic about
    using the **interface segregation principle** (**ISP**) or the **dependency inversion
    principle** (**DSP**) as I am now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I didn't understand the power of channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing lambdas around blew my mind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Over time, I have seen these sorts of things pop up over and over, particularly
    in code-review comments. There is quite an effective way of answering the question: *What
    are the users capable of? *Write an example and ask your colleagues the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What does this do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you have done it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do you expect this function to do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't have any users that you can quiz, another option is to ask yourself,
    *What else exists that is similar?* I am not suggesting that you follow other
    people's mistakes. The basic theory here is that if something else exists, and
    your users are comfortable with it then, if yours is similar, they will not have
    to learn to use it. This was perhaps best illustrated to me when using lambdas.
    Colleagues from a functional background were happy with it, but those from an
    object-oriented background found it either somewhat confounding or just not intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Why do users want to use your code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer to the question of why your users would want to use your code could
    be long and varied. If it is, you might want to go back and re-read the *SRP*
    section. Beyond being able to split the code into smaller, more concise chunks,
    we need to make a list. We will apply the 80/20 rule to this list. Typically,
    80% of usage comes from 20% of the use cases. Let me put this into perspective
    with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an **automated teller machine** (**ATM**). A list of its use cases
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Withdraw money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deposit money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change PIN code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deposit check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I reckon that on at least 80% of the occasions that a person uses an ATM, their
    purpose is to withdraw money. So what can we do with this information? We can
    optimize the interface to make the most common use cases as convenient as possible.
    In the case of the ATM, it could be as simple as putting the withdraw function
    on the first screen at the top so that users don't have to search for it. Now
    that we understand what our users are trying to achieve, we can build on this
    and consider how they expect to use it.
  prefs: []
  type: TYPE_NORMAL
- en: How do they expect to use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the ATM example was clear, it was a system, and so you may be wondering
    how that could possibly apply to low-level concepts, such as functions. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That probably looks OK, right? The problem is that most of the usage looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most of the time we don't need all of those return values, and
    many of the inputs are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to addressing this sort of situation is to look at the under-used
    parts of the code and ask yourself, do we really need them? If they exist only
    for testing, then it means they are *test-induced damage*, which we will look
    at later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If they exist for some infrequently used but compelling use case, then we can
    address it another way. The first option would be to split the function into multiple
    parts; this would allow users to adopt only the complexity they need. The second
    option is to merge the configuration into an object, allowing users to ignore
    the parts they don't use.
  prefs: []
  type: TYPE_NORMAL
- en: In both approaches, we are providing *reasonable defaults*, reducing the mental
    burden of the function by allowing users to only worry about what they need.
  prefs: []
  type: TYPE_NORMAL
- en: When to compromise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a great user experience is a desirable goal, but is not a necessity.
    There are always going to be situations where the UX needs to be compromised.
    The first and perhaps most common situation is team evolution.
  prefs: []
  type: TYPE_NORMAL
- en: As the team evolves and becomes more experienced with Go, it will inevitably
    find that some early software patterns no longer seem as effective. These might
    include things such as the use of global, panic, and loading configurations from
    environment variables, or even when to use functions rather than objects. As the
    team evolves, so does their definition of both good software and what is standard
    or intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: The second, and in many cases, an overused excuse for poor UX, is performance.
    As we saw in an early example in this chapter, it's often possible to write faster
    code, but the faster code is often harder to understand. The best option here
    is to optimize it for humans first and then, only when the system has proven to
    not be quick enough, optimize it for speed. Even then, these optimizations should
    be selectively applied to those parts of the system that are shown, by measurement,
    to be worth the effort to refactor and the long-term cost of less-than-ideal UX.
  prefs: []
  type: TYPE_NORMAL
- en: The last situation is visibility; sometimes, you just can't see what a good
    UX might be. In these cases, the more effective option is to implement and then
    iteratively refactor based on usage and any inconveniences that arise.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts on coding for user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programmer time, your time, is expensive; you should conserve it in preference
    of CPU time. The user experience for developers is challenging because of our
    inherent need to solve problems and deliver useful software. However, it is possible
    to conserve programmer time. Try to remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making something more configurable doesn't make it more usable—it makes it more
    confusing to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing for all use cases makes the code inconvenient for everyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User competence and expectations play a prominent role in how your code is perceived,
    and in its adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps most pertinent—it is always better and easier to change the UX to match
    the user than the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: A security blanket named unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many folks will tell you, *you must write unit tests for your code; they make
    sure you have no bugs*. They really don't do that at all. Nor do I write unit
    tests because someone tells me I must. I write unit tests for what they do for
    me. Unit tests are empowering. They actually reduce the amount of work I have
    to do. Perhaps these are not justifications you have heard before. Let's explore
    them in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests give you the freedom and confidence to refactor**: I love to refactor,
    perhaps a little too much, but that''s a different topic. Refactoring allows me
    to experiment with varying styles of code, implementations, and UX. By having
    unit tests in place, I can be adventurous and confident that I don''t unintentionally
    break anything along the way. They can also give you the courage to try new technologies,
    libraries, or coding techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Existing unit tests make adding new features easier**: As we have mentioned
    before, adding new features does incur some risk—risk that we might break something.
    Having the tests in place provides a safety net that allows us to be less mindful
    of what already exists and focus more on adding the new feature. It might seem
    counterintuitive, but unit tests actually make you move faster. As the system
    expands, having a safety blanket of unit tests allows you to proceed with confidence
    and not to have to worry about the things you might break.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests prevent repeated regression**: There is no way around it—regression
    sucks. It makes you look bad and it causes you extra work, but it''s going to
    happen. The best we can hope for is to not repeatedly fix the same bug. While
    tests do prevent some regression, they cannot stop it all. By writing a test that
    fails because of the bug and then fixing the bug, we achieve two things. First,
    we know when the bug is fixed because the test passes. Second, the bug does not
    happen again.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests document your intent**: While I am not trying to suggest that
    tests can replace documentation, they are explicit, executable expressions of
    what you intended when you wrote the code. This is an exceptionally desirable
    quality when working in a team. It allows you to work on any part of the system
    without worrying about breaking code written by others or even perhaps fully understanding
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests document your requirements from a dependency**: In the second
    section of this book, we will work through some examples of applying DI to an
    existing code base. A significant part of this process will include grouping and
    extracting functionality into abstractions. These abstractions naturally become
    *units of work*. Each unit is then tested individually and in isolation. These
    tests are consequently more focused, and are easier to write and maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the tests on code that uses DI will often focus on how that function
    uses and reacts to the dependency. These tests effectively define the requirements
    contract for the dependency and help to prevent regression. Let''s look at an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code expects the dependency to behave in a certain way.
    While the tests do not enforce this behavior from the dependency, they do serve
    to define this code's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests can help restore confidence and increase understanding**: Do you
    have code in your system that you don''t dare to change because if you do, something
    will break? How about code where you are really not sure what it does? Unit tests
    are fantastic for both of these situations. Writing tests against this code is
    an unobtrusive way to both learn what it does and validate that it does what you
    think it does. These tests have the added bonus that they can also be used as
    regression prevention for any future changes and to teach others what this code
    does.'
  prefs: []
  type: TYPE_NORMAL
- en: So why do I write unit tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For me, the most compelling reason to write unit tests is that it makes me feels
    good. It feels great to go home at the end of the day or week and know that everything
    is working as intended and that the tests are making sure of it.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that there are no bugs, but there are definitely fewer. Once
    fixed, bugs don't come back, saving me from embarrassment and saving me time.
    And, perhaps most importantly, fixing bugs means fewer support calls at nights
    and weekends because something is broken.
  prefs: []
  type: TYPE_NORMAL
- en: What should I test?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wish I had a clear, quantifiable metric to give you as to what you should
    and should not test, but it''s just not that clear. The first rule is definitely
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t test co**de that is too simple break.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes language features, such as those shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This also includes simple functions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After that, be pragmatic. We get paid to write code that works; tests are only
    a tool to ensure that it does and continues to do so. It is entirely possible
    to test too much. Excessive tests will not only lead to a lot of extra work, but
    will also cause tests to become brittle and frequently break during refactoring
    or extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, I recommend testing from a slightly higher and more *black-box *level.
    Take a look at the struct in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we were to write tests for each method of this struct, then we will be discouraged
    from refactoring these methods or even extracting them from `Save() `in the first
    place, as we would have to refactor the corresponding tests as well. However,
    if we test the `Save()` method only, which is the only method that is used by
    others, then we can refactor the rest with far less hassle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of tests are also important. Typically, we should test the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path**: This is when everything goes as expected. These tests also
    tend to document how to use the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input errors**: Incorrect and unexpected inputs can often cause the code
    to behave in strange ways. These tests ensure that our code handles these issues
    in a predictable way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency issues**: The other common cause of failure is when a dependency
    fails to perform as we need it to, either through coder error (such as regression)
    or environmental issues (such as a missing file or a failed call to a database).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, by now you are sold on unit tests and are excited by what they can
    do for you. Another often neglected aspect of tests is their quality. By this,
    I'm not talking about use case coverage or code coverage percentage, but the raw
    code quality. It's sadly commonplace to write tests in a manner that we wouldn't
    allow ourselves to write for production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Duplication, poor readability, and lack of structure are all frequent mistakes.
    Thankfully, these issues can be easily addressed. The first step is just being
    mindful of the problem and applying the same level of effort and skill as we do
    with production code. The second requires breaking out some test-specific techniques;
    there are many but, in this chapter, I will introduce only three. These are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Table-driven tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-driven tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, while writing tests, you will find that multiple tests for the same
    method result in a lot of duplication. Take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing surprising, nor wrong with the intent here. Table-driven tests
    acknowledge the need for duplication and extract the variations into a *table*.
    It is this table that then drives a single copy of the code that would otherwise
    have been duplicated. Let''s convert our tests in to table-driven tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our tests are now guaranteed to be consistent across all of the scenarios for
    this method, which in turn makes them more effective. If we had to change the
    function signature or call pattern, we have only one place in which to do so,
    resulting in less maintenance cost. Finally, reducing the inputs and outputs to
    a table makes it cheap to add new test scenarios, and helps to identify test scenarios
    by encouraging us to focus on the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes referred to as *test doubles*, stubs are fake implementations of a
    dependency (that is, an interface) that provides a predictable, usually fixed
    result. Stubs are also used to help exercise code paths, such as errors, that
    otherwise might be very difficult or impossible to trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s imagine that the production implementation of the fetcher interface
    actually calls an upstream REST service. Using our previous *types of tests *list,
    we want to test for the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path**: The fetcher returns data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input error: **The fetcher fails to find the `Person` we requested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System error**: The upstream service is down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more possible tests that we could implement, but this is enough for
    our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about how we would have to test without using a stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path**: The upstream service has to be up and working correctly, and
    we would have to make sure we had a valid ID to request at all times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input error**: The upstream service has to be up and working correctly, but
    in this case, we would have to have an ID that was guaranteed to be invalid; otherwise,
    this test would be flaky.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System error**: The service would have to be down? If we assume that the
    upstream service belongs to another team or has users other than us, I don''t
    think they would appreciate us shutting down the service every time we needed
    to test. We could configure an incorrect URL for the service, but then we would
    be running different configurations for our different test scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a lot of nonprogramming issues with the preceding scenarios. Let''s
    see if a little code can solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding stub implementation, we can now create one stub instance
    per scenario with a table-driven test, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our tests now cannot fail because of the dependency; they no
    longer require anything external to the project itself, and they probably even
    run faster. If you find writing stubs burdensome, I would recommend two things.
    Firstly, check the previous [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go,* on the ISP and see if you can break the interface into
    something smaller. Secondly, check out one of the many fantastic tools in the
    Go community; you are sure to find one that suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Excessive test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another problem that could arise is excessive test coverage. Yes, you read
    that right. Writing too many tests is possible. Programmers, being the technically
    minded folks that we are, love metrics. Unit-test coverage is one such metric.
    While it is possible to achieve 100% test coverage, realizing this goal is a huge
    time sink, and the resulting code can be rather terrible. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve 100% coverage, we would have to write a test where the `destination.Close()`
    call fails. We can totally do this, but what would it achieve? What would we be
    testing? It would give us another test to write and maintain. If this line of
    code doesn''t work, would you even notice? How about this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can totally test for that. But would we really be testing? In this
    case, we'd be testing that the JSON package in the Go standard library works as
    it's supposed to. External SDKs and packages should have their own tests so that
    we can just trust that they do what they claim. If this is not the case, we can
    always write tests for them and send them back to the project. That way, the entire
    community benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocks are very much like stubs, but they have one fundamental difference. Mocks
    have expectations. When we used stubs, our tests did nothing to validate our usage
    of the dependency; with mocks, they will. Which you use depends very much on the
    type of test and the dependency itself. For example, you might want to use a stub
    for a logging dependency, unless you are writing a test that ensures the code
    logs in a specific situation. However, you will often need a mock for a database
    dependency. Let''s change our previous tests from stubs to mocks to ensure that
    we make those calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are validating that the appropriate calls are made
    and that the inputs are as we expect. Given that mock-based tests are more explicit,
    they are often more brittle and verbose than their stub-based equivalents. The
    best advice I can give you about this is to choose the option that best fits the
    test you are trying to write and, if the amount of setup seems excessive, consider
    what this implies about the code you are testing. You could have issues with feature
    envy or an inefficient abstraction. Refactoring for the DIP or SRP might help.
  prefs: []
  type: TYPE_NORMAL
- en: Just as there are with stubs, there are many great tools in the community for
    generating mocks. I have personally used mockery ([https://github.com/vektra/mockery](https://github.com/vektra/mockery))
    by Vektra.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install mockery with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we can generate a mock for our test interface using mockery
    from the command line, or by using the `go generate`tool provided with the Go
    SDK by merely adding a comment to our source code, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The resulting mocks can then be used as we did in the previous example. We will
    be using mockery and the mocks it generates a great deal in the second section
    of this book. If you wish to download mockery, you will find a link to their GitHub
    project at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Test-induced damage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a 2014 blog post, *David Heinemeier Hansson* expressed that changes to a
    system for the sole purpose of making tests easier or faster resulted in test-induced
    damage. While I agree with David's intent, I am not sure we agree on the details.
    He coined this term in response to what he felt was excessive application DI and
    **test-driven development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I take a pragmatic approach to both. They are tools. Please try
    them out. If they work for you, fantastic. If not, that's fine too. I have never
    been able to get TDD to be as productive for me as other methods. Generally, I
    will write my function, at least the happy path, and then apply my tests. Then
    I refactor and clean.
  prefs: []
  type: TYPE_NORMAL
- en: Warning signs of test-induced damage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are many ways in which testing could cause damage to your software
    design, the following are some of the more common kinds of damage.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters, config options, or outputs that only exist because of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While an individual instance of this might not feel like it has a huge impact,
    the cost does eventually add up. Remember that each parameter, option, and output
    is something that a user has to understand. Similarly, each parameter, option,
    and output has to be tested, documented, and otherwise maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters that cause or are caused by leaky abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common to see a database connection string or URL passed into the business-logic
    layer for the sole purpose of passing it down to the data layer (the database
    or HTTP client). Typically, the motivation is to pass the config through the layers
    so that we can swap out the live config for something friendlier for testing.
    This sounds good, but it breaks the encapsulation of the data layer. Perhaps more
    concerning is that if we were to change the data-layer implementation to something
    else, we would likely have extensive shotgun surgery on our hands. The actual
    problem here is not the testing, but how we have chosen to *swap out *the data
    layer. Using the DIP, we could define our requirements as an interface in the
    business-logic layer and then mock or stub it. This would completely decouple
    the business-logic layer from the data layer and remove the need to pass the test
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing mocks in production code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocks and stubs are tools for testing; as such, they should only ever exist
    in test code. In Go, this means an `_test.go` file. I have seen many well-meaning
    folks publish interfaces and their mocks in production code. The first problem
    with this is that it introduces a possibility, however remote, of this code ending
    up in production. Depending on where in the system this mistake was located, the
    results could be disastrous.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is a little more subtle. When publishing the interface and
    mock, the intent is to reduce duplication, which is fantastic. However, this also
    increases dependence and resistance to change. Once this code is published and
    adopted by others, modifying it will require changing all usage of it.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing your package dependencies with Godepgraph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a book about DI, you can expect us to spend a lot of time talking about
    dependencies. Dependencies at the lowest level, functions, structs, and interfaces
    are easy to visualize; we can just read the code or, if we want a pretty picture,
    we can make a class diagram like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/782bf8ac-65ed-4f92-b38d-9cc09cc1c450.png)'
  prefs: []
  type: TYPE_IMG
- en: If we zoom out to the package level and try to map the dependencies between
    packages, then life gets a lot more difficult. This is where we rely again on
    the open source community's wealth of open-source tools. This time, we will need
    two tools called **godepgraph** and **Graphviz** ([http://www.graphviz.org/](http://www.graphviz.org/)).
    Godepgraph is a program for generating a dependency graph of Go packages, and
    Graphviz is a source graph-visualization software.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple `go get` will install `godepgraph`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How you install Graphviz depends on your operating system. You can use Windows
    binaries, Linux packages, and both MacPorts and HomeBrew for OSX.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a dependency graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once everything is installed, the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Will produce the following pretty picture for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dd06d05-ed7a-4466-8d2b-72813417f6ff.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the dependency graph for `godepgraph` is nice and flat, and
    only relies on packages from the standard library (the green circles).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something a little more complicated: let''s generate the dependency
    graph for the code we are going to use in the second part of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This gives us an incredibly complicated graph that will never fit on the page.
    Please take a look at `ch03/04_visualizing_dependencies/acme-graph-v1.png` if
    you want to see just how complicated it is. Don't worry too much about trying
    to make out the details; it's not in a super useful form right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we can do to fix this is remove the standard library imports
    (which have the `-s` flag), as shown in the following code. We can assume that
    using the standard library is acceptable, and is not something we need to turn
    into an abstraction or use DI on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use this graph, but it''s still too complicated for me. Assuming we
    don''t recklessly adopt external dependencies, we can treat them like the standard
    library and hide them from the graph (with the `-o` flag), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb1d7fc1-69ba-4873-a931-80a20e0ae5a4.png)'
  prefs: []
  type: TYPE_IMG
- en: With all of the external packages removed, we can see how our packages relate
    and depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using OSX or Linux, I have included a Bash script called `depgraph.sh`
    that I use to generate these graphs in the source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the dependency graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like a lot of things in the programming world, what a dependency graph says
    is very much open to interpretation. I use the graph to discover potential problems
    that I can then go searching for in the code.
  prefs: []
  type: TYPE_NORMAL
- en: So, what would a *perfect *graph look like? If there were one, it would be very
    flat, with pretty much everything hanging from the main package. In such a system,
    all of the packages would be completely decoupled from each other and would have
    no dependencies beyond their external dependencies and the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: This is really not feasible. As you will see with the various DI methods in
    the second part of this book, the goal is frequently to decouple the layers so
    that dependencies flow only in one direction—from the top down.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an abstract perspective, this looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0d5132d-0e6a-431d-a581-2ffccc2079ee.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in mind, what potential issues do we see with our graph?
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to consider when looking at any package is how many arrows are
    pointing into or out of it. This is a fundamental measure of coupling. Every arrow
    pointing into a package indicates a user of this package. Therefore, every arrow
    pointing inward means that the package may have to change if we make changes to
    the current package. The same can be said in reverse—the more packages the current
    package depends on, the more likely it will be to have to change as a result of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the DIP, while adopting an interface from another package is the
    quick and easy thing to do, defining our own interface allows us to depend on
    ourselves, and reducing the likelihood of change.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that jumps out is the config package. Just about every package
    depends on it. As we have seen, with this amount of responsibility, making changes
    to that package is potentially tricky. Not far behind in terms of trickiness is
    the logging package. Perhaps what is most concerning is that the config package
    depends on the logging package. This means that we are one bad import away from
    circular dependency problems. These are both issues that we will need to leverage
    DI to deal with in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the graph is pretty good; it flows out like a pyramid from the main
    package, and almost all of the dependencies are in one direction. The next time
    you are looking for ways to improve your code base or are experiencing a circular
    dependency problem, why don't you fire up `godepgraph` and see what it says about
    your system. The dependency graph will not tell you exactly where there is a problem
    or where there isn't a problem, but it will give you hints as to where to start
    looking.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We made it to the end of the first section! Hopefully, at this
    point, you've discovered a few new things, or perhaps have been reminded of some
    software design concepts that you had forgotten.
  prefs: []
  type: TYPE_NORMAL
- en: Programming, like any professional endeavor, deserves constant discussion, learning,
    and a healthy dose of skepticism.
  prefs: []
  type: TYPE_NORMAL
- en: In the second section, you will find several very different techniques for DI,
    some that you might like, some that you might not. Armed with everything we have
    examined so far, you will have no trouble in determining how and when each technique
    could work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is the usability of code important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who benefits the most from code with great UX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you construct a good UX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can unit testing do for you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of test scenarios should you consider?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do table-driven tests help?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can testing damage your software design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
