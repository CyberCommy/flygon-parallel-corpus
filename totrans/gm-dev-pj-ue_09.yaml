- en: 10\. Creating a SuperSideScroller Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will set up the project for a new `SuperSideScroller` game.
    You will be introduced to the different aspects of a side-scroller game, including
    power-ups, collectibles, and enemy AI, all of which we will be using in our project.
    You will also learn about the Character animation pipeline in game development
    and see how to manipulate the movement of our game's Character.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create a side-scroller project,
    manipulate the default mannequin skeleton for our Character, import Characters
    and animations, and create Character and Animation Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned a lot about the Unreal Engine, C++ programming, and
    general game development techniques and strategies. In previous chapters, we covered
    topics such as collisions, tracing, how to use C++ with Unreal Engine 4, and even
    the Blueprint Visual Scripting system. On top of that, we gained crucial knowledge
    of Skeletons, animations, and Animation Blueprints that we will utilize in the
    upcoming project.
  prefs: []
  type: TYPE_NORMAL
- en: For our newest project, `SuperSideScroller`, we will use many of the same concepts
    and tools that we have used in previous chapters to develop our game features
    and systems. Concepts such as collision, input, and the HUD will be at the forefront
    of our project; however, we will also be diving into new concepts involving animation
    to recreate the mechanics of popular side-scrolling games. The final project will
    be a culmination of everything we have learned thus far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless examples of side-scroller games out there that can be used
    as references for this project. Most recently, some popular side-scrolling games
    have included titles such as *Celeste*, *Hollow Knight*, and *Shovel Knight*,
    but there is also a deep, rich history behind the side-scroller/platformer genre,
    which we will discuss in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Project Breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the example of the famous *Super Mario Bros*, released on the
    **Nintendo Entertainment System** (**NES**) console in 1985\. This game was created
    by Nintendo and designed by Shigeru Miyamoto. For those who are unfamiliar with
    the franchise, the general idea is this: the player takes control of Mario, who
    must traverse the many hazardous obstacles and creatures of the Mushroom Kingdom
    in the hope of rescuing Princess Peach from the sinister King Koopa, Bowser.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To have an even better understanding of how the game works, feel free to play
    it online for free at [https://supermariobros.io/](https://supermariobros.io/).
    A more in-depth wiki of the entire *Super Mario Brothers* franchise can be found
    here: [https://www.mariowiki.com/Super_Mario_Bros](https://www.mariowiki.com/Super_Mario_Bros).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the core features and mechanics of games in this genre:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SuperSideScroller` game will be in 3D and not pure 2D, the movement of our
    Character will work identically to that of Mario, only supporting vertical and
    horizontal movement:![Figure 10.1: A comparison of 2D and 3D coordinate vectors'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: A comparison of 2D and 3D coordinate vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '`SuperSideScroller` game will be no different. There are many different games,
    such as *Celeste*, *Hollow Knight*, and *Super Meat Boy*, as mentioned before,
    that use the jumping feature – all of which are in 2D.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Character Power-Ups**: Without Character power-ups, many side-scrolling games
    lose their sense of chaos and replayability. For instance, in the game *Ori and
    the Blind Forest*, the developers introduce different Character abilities that
    change how the game is played. Abilities such as the triple-jump or the air dash
    open a variety of possibilities to navigate the level and allow level designers
    to create interesting layouts based on the movement abilities of the player.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enemy AI**: Enemies with various abilities and behaviors are introduced to
    add a layer of challenge for the player, on top of the challenge of navigating
    the level solely through the use of the available movement mechanics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'What are some ways that AI in games can interact with the player? For example,
    in *The Elder Scrolls V: Skyrim*, there are AI characters in various towns and
    villages that can have conversations with the player to exposit world-building
    elements such as history, sell items to the player, and even give quests to the
    player.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SuperSideScroller` game will allow players to collect coins.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have evaluated the game mechanics that we want to support, we can
    break down the functionality of each mechanic as it relates to our `SuperSideScroller`
    and what we need to do to implement these features.
  prefs: []
  type: TYPE_NORMAL
- en: The Player Character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all of the functionality that we want for our Character is given to us
    by default when using the `Side Scroller` game project template in Unreal Engine
    4\.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, we are using Unreal Engine version 4.24.2; using another
    version of the engine could result in some differences in the editor, the tools,
    and how your logic will work later on, so please keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's begin creating our project in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Creating the Side-Scroller Project and Using the Character
    Movement Component'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will be setting up Unreal Engine 4 with the `Side Scroller`
    template. This exercise will help you get started with our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Epic Games Launcher, navigate to the `Unreal Engine` tab at
    the bottom of the options on the left-hand side, and select the `Library` option
    at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be prompted with a window asking you to either open an existing
    project or create a new project of a certain category. Among these options is
    the `Games` category; select this option for our project. With your project category
    selected, you are now prompted to select the template for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the `Side Scroller` option because we want our game to use 3D
    Skeletal Meshes and animations, and not just 2D textures, flipbooks, and other
    features of the Paper2D toolset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to select the correct `Side Scroller` option, because Unreal Engine
    4 has two types of Side Scroller projects: `Side Scroller` and `2D Side Scroller`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the main differences between these two project templates shortly
    after this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to set up our project settings.
  prefs: []
  type: TYPE_NORMAL
- en: Choose to base the project on `C++`, not `Blueprints`, to include `Starter Content`,
    and to use `Desktop/Console` as our platform. The remaining project settings can
    be left as their defaults. Select the location and name the project `SuperSideScroller`
    and save the project in an appropriate directory of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After these settings are applied, select `Create Project`. When it''s done
    compiling the engine, both the Unreal Editor and Visual Studio will open, and
    we can get started.![Figure 10.2: The Unreal Engine editor should now be open'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: The Unreal Engine editor should now be open'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we continue to manipulate the Character movement component that exists
    inside the default `SideScroller` Character and see how this affects the Character.
    The `Character Movement` component can only be implemented in `Character` classes
    and allows bipedal avatars to move by means of *walking*, *jumping*, *flying*,
    and *swimming*. This component also has a built-in network replication functionality
    that is necessary for multiplayer games.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Content Browser`, navigate to the `/SideScrollerCPP/Blueprints/` directory
    and find the `SideScrollerCharacter` Blueprint:![Figure 10.3: The default SideScrollerCharacter
    Blueprint selected inside Content Browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: The default SideScrollerCharacter Blueprint selected inside Content
    Browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double *left-click* the `Blueprint` asset to open the `Blueprint`. Sometimes,
    if the `Blueprint` does not have any graph logic, you will see what is shown in
    *Figure 10.4*. If you see this, just *left-click* on `Open Full Blueprint Editor`:![Figure
    10.4: When a Blueprint has no graph logic'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: When a Blueprint has no graph logic'
  prefs: []
  type: TYPE_NORMAL
- en: With the Character `Blueprint` opened, we can *left-click* the `CharacterMovement(Inherited)`
    component in the `Components` tab to view the parameters for this component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, under the `Details` panel, we have access to dozens of parameters that
    affect Character movement. In the `Character Movement: Walking` category, we have
    the `Max Walk Speed` parameter. Change this value from `600.0f` to `2000.0f`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, compile and save our Character `Blueprint`. Now, if we play in the
    editor, we can observe how fast our player Character is moving:![Figure 10.5:
    If we play in the editor, we can see that our Character moves much faster'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: If we play in the editor, we can see that our Character moves
    much faster'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have completed the exercise, you have experienced first-hand the
    control you have over how the player Character moves! Try changing the value of
    `Max Walk Speed` and observe in-game how such changes affect the Character.
  prefs: []
  type: TYPE_NORMAL
- en: Side Scroller versus 2D Side Scroller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a brief moment here to learn about the main differences between the
    `2D Side Scroller` project template and the `Side Scroller` template. The `2D
    Side Scroller` template uses the Paper2D system built with Unreal Engine 4, which
    takes advantage of texture-based animation via textures, sprites, and paper flipbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about Paper2D, please refer to the following documentation:
    [https://docs.unrealengine.com/en-US/Engine/Paper2D/index.html](https://docs.unrealengine.com/en-US/Engine/Paper2D/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: There is enough material about Paper2D to warrant its own textbook, so we will
    not cover much more of that topic. The `Side Scroller` template, however, is almost
    identical to the 2D version, except we are using 3D animated skeletons instead
    of 2D animation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and look at performing our first activity to manipulate the
    player Character's jump movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Making Our Character Jump Higher'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will be manipulating a new parameter (`jump`) that exists
    within the `CharacterMovement` component of the default `Side Scroller` Character
    Blueprint to observe how these properties affect how our Character moves.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing what we learned from *Exercise 10.01*, *Creating the
    Side-Scroller Project and Using the Character Movement Component*, and applying
    that to how to create our Character power-ups and the general movement feel of
    our Character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to `SideScrollerCharacter` Blueprint and find the `Jump Z Velocity` parameter
    in the `CharacterMovement` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change this parameter from the default `1000.0`f to a value of `2000.0`f.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and save the `SideScrollerCharacter` Blueprint and play in the editor.
    Observe how high our Character can jump using the space bar on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop playing in the editor, return to the `SideScrollerCharacter` Blueprint,
    and update `Jump Z Velocity` from a value of `2000.0`f to `200.0`f.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and save the Blueprint again, play in the editor, and watch the Character jump.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Expected output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: The expected output with the jumping Character'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: The expected output with the jumping Character'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed this activity, we have a better understanding of
    how a few changes to the `CharacterMovement` component parameters can affect our
    player Character. We can use this later on when we need to give our Character
    basic movement behaviors such as `Walking Speed` and `Jump Z Velocity` to achieve
    the Character feel we want. Before moving on, return the Jump Z Velocity parameter
    back to its default value 1000.0f.
  prefs: []
  type: TYPE_NORMAL
- en: We will also keep these parameters in mind when we develop our player Character
    power-ups later on in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Features of Our Side-Scroller Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now take some time to lay out the specifics of the game we'll be designing.
    Many of these features will be implemented in later chapters, but now is a good
    time to lay out the vision for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing you should have noticed while playing the `SuperSideScroller` project
    is that there is no enemy AI provided to you by default. So, let's discuss the
    type of enemies we will want to support and how they will work. Our `SuperSideScroller`
    project will support one enemy type.
  prefs: []
  type: TYPE_NORMAL
- en: The enemy will have a basic back-and-forth movement pattern and will not support
    any attacks; only by colliding with the player Character will they be able to
    inflict any damage. However, we need to set the two locations to move between
    for the enemy AI, and next, we will need to decide whether the AI should change
    locations. Should they constantly move between locations, or should there be a
    pause before selecting a new location to move to?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we decide whether our AI should be aware of where the player is at
    all times. If the player comes within a certain range of our enemy, should the
    enemy know about this and aggressively move toward the player's last known location?
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 13,* *Enemy Artificial Intelligence*, we will use the tools available
    in Unreal Engine 4 to develop this AI logic.
  prefs: []
  type: TYPE_NORMAL
- en: Power-Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SuperSideScroller` game project will support one type of power-up, in the
    form of a potion that the player can pick up from the environment. This potion
    power-up will increase the movement speed of the player and the maximum height
    to which the player can jump. These effects will only last a short duration before
    they are removed.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind what you implemented in *Exercise 10.01*, *Creating the Side-Scroller
    Project and Using the Character Movement Component*, and *Activity 10.01*, *Making
    Our Character Jump Higher*, about the `CharacterMovement` component, you could
    develop a power-up that changes the effect of gravity on the Character, which
    would allow interesting new ways to navigate the level and combat enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Collectible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collectibles in video games serve different purposes. In some cases, collectibles
    are used as a form of currency to purchase upgrades, items, and other goods. In
    others, collectibles serve to improve your score or reward you when enough collectibles
    have been collected. For the `SuperSideScroller` game project, the coins will
    serve a single purpose: to give the player the goal of collecting as many coins
    as they can without being destroyed by the enemy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the main aspects of our collectible:'
  prefs: []
  type: TYPE_NORMAL
- en: The collectible needs to interact with our player; this means that we need to
    use collision detection for the player to collect it and for us to add information
    to our UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collectible needs a visual static mesh representation so that the player
    can identify it in the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final element of our `SuperSideScroller` project is the brick block. The
    brick block will serve the following purposes for the `SuperSideScroller` game:'
  prefs: []
  type: TYPE_NORMAL
- en: Bricks are used as an element of the level's design. Bricks can be used to access
    otherwise unreachable areas; enemies can be placed on different elevated sections
    of bricks to provide variation in gameplay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bricks can contain collectible coins. This gives the player an incentive to
    try and see which blocks contain collectibles and which do not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HUD (Heads-Up Display)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HUD UI can be used to display to the player important and relevant information,
    based on the type of game and the mechanics that you support. For the `SuperSideScroller`
    project, there will be one HUD element, which will display to the player how many
    coins they have collected. This UI will be updated each time the player collects
    a coin, and it will reset back to `0` when the player is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have laid out some of the specifics that we will be working toward
    as part of this project, we will move on to the animation pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Steps in Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be clear, this book is not going to cover animation. We will not discuss
    and learn how to make animations using 3D software tools such as 3D Studio Max,
    Maya, or Blender. However, we will learn how to import these assets into Unreal
    Engine, use animation assets inside the engine, and use the animation toolsets
    available to bring our Characters to life.
  prefs: []
  type: TYPE_NORMAL
- en: Character Animation Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purposes of this book, we will only be concerned with 3D animation and
    how animations work inside Unreal Engine 4; however, it's important to briefly
    discuss the pipeline used in many industries to create a Character and its animations.
  prefs: []
  type: TYPE_NORMAL
- en: The Concept Stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first stage is developing a concept of the Character that we want to create
    and later animate. This is almost always done in 2D, either by hand or through
    the use of a computer using programs such as Photoshop. It makes the job easier
    for the 3D modeler to have several references for how a Character looks, and the
    relative size of the Character, before starting the process of modeling. Below,
    we see a basic example of a stick figure Character in different poses. Notice
    how the Character is posed in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: A very simple example of a 2D Character concept'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: A very simple example of a 2D Character concept'
  prefs: []
  type: TYPE_NORMAL
- en: The 3D Modeling Stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the Character concepts are complete, the pipeline can then move to the
    next stage: making a 3D model of the Character. Models are typically made in programs
    such as 3D Studio Max or Maya, but this software is relatively expensive, unless
    you have a student license, and is more often used in professional environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Without going into significant detail regarding the complexity of 3D modeling,
    all we need to know is that 3D artists use computer software to manipulate points
    in 3D space known as vertices to create objects. These objects are then sculpted
    into the shapes of our Characters or environment pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The Rigging Stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the final Character model is complete, it is ready to begin the rigging
    process. The software that was used to model the Character will usually be what
    is used to rig the Character. Rigging means building a series of bones that form
    the frame of a Character's skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of humanoid Characters, we would typically see bones for the head,
    along the spine, the hips, the legs, and so on; but a skeleton can vary depending
    on the type of Character you are making. An elephant would have a completely different
    skeletal rig than a human. It is also possible for the same rig to be applied
    to different Characters.
  prefs: []
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have our Character rigged and a hierarchy of bones, it is time for the
    animator to take this mesh and bring it to life with animation.
  prefs: []
  type: TYPE_NORMAL
- en: 3D animation, in its most basic form, is the manipulation of skeletal bones
    over time. The process of recording the changes to bone position, rotation, and
    scale over time is what results in an animation. With the animation complete,
    we can export the asset from the 3D software and import it into the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Asset Export and Import
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have our 3D Character mesh, its skeletal rig, and its animation, it's
    time to export these assets from the 3D software and import them into Unreal Engine
    4\. It is important to note that the artists working on the Character, the rig,
    and the animations will constantly be exporting work-in-progress assets into the
    engine to get a better idea of the final result as seen in-game. We will be implementing
    this later on in this chapter in *Activity 10.03*, *Importing More Custom Animations
    to Preview the Character Running*, and its accompanying exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Exploring the Persona Editor and Manipulating the Default Mannequin
    Skeleton Weights'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the animation pipeline, let's go
    ahead and take a deeper look into the default mannequin skeletal mesh that is
    given to us in the `Side Scroller` template project.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal here is to learn more about the default skeletal mesh and the tools
    that are given to us in the Persona Editor so that we have a better understanding
    of how bones, bone weighting, and skeletons work inside Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Unreal Engine Editor and navigate to `Content Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `/Mannequin/Character/Mesh/` folder and open the `UE4_Mannequin_Skeleton`
    asset:![Figure 10.8: The UE4_Mannequin_Skeleton asset is highlighted and visible
    here'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: The UE4_Mannequin_Skeleton asset is highlighted and visible here'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon opening the Skeleton asset, we are shown the `Persona Editor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: The Persona Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: The Persona Editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly break down the Skeleton Editor of Persona:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side (*marked with a 1*), we see the hierarchy of bones that
    exist in the Skeleton. This is the Skeleton that was made during the rigging process
    of this Character. The `root` bone, as the name suggests, is the root of the skeletal
    hierarchy. This means that transformative changes to this bone will affect all
    of the bones in the hierarchy. From here, we can select a bone or a section of
    bones and see where they are on the Character mesh.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we see the Skeletal Mesh preview window (*marked with a 2*). It shows
    us our Character mesh, and there are several additional options that we can toggle
    on that will give us a preview of our Skeleton and weight painting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the right-hand side (*marked with a 3*), we have basic transformation options
    where we can modify individual bones or groups of bones. There are also additional
    settings available that we will take advantage of in the next exercise. Now that
    we know more about what it is and what we are looking at, let's see what the actual
    Skeleton looks like on our mannequin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigate to `Character`, as shown in *Figure 10.10*:![Figure 10.10: The Character
    options menu gives you the ability to display the Skeleton of the mannequin over
    the mesh itself'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.10: The Character options menu gives you the ability to display the
    Skeleton of the mannequin over the mesh itself'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the drop-down menu, select the `Bones` option. Then, make sure the option
    for `All Hierarchy` is selected. With this option selected, you will see the outlining
    Skeleton rendering above the mannequin mesh:![Figure 10.11: The Skeleton overlayed
    on top of the mannequin Skeletal Mesh'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: The Skeleton overlayed on top of the mannequin Skeletal Mesh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, hide the mesh and simply preview the skeletal hierarchy, for which we
    can disable the `Mesh` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `Character` and, from the drop-down menu, select the `Mesh` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deselect the option for `Mesh` and the result should be what we see below:![Figure
    10.12: The skeletal hierarchy of the default Character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: The skeletal hierarchy of the default Character'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this exercise, let's toggle `Mesh` visibility back on so
    that we see both the mesh and the Skeleton hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, take a look together at the weight scaling for our default Character.
  prefs: []
  type: TYPE_NORMAL
- en: 'To preview this, navigate to `Character` and, from the drop-down menu, select
    the `Mesh` option. Then, select the option for `Selected Bone Weight` toward the
    bottom in the section labeled `Mesh Overlay Drawing`:![Figure 10.13: Drop-down
    option to show the selected bone weight'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: of a bone for the mannequin
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: Drop-down option to show the selected bone weight of a bone for
    the mannequin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we select a bone or a group of bones from our hierarchy, we can see
    how each bone affects a certain area of our mesh:![Figure 10.14: This is the weight
    scaling for the spine_03 bone'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.14: This is the weight scaling for the spine_03 bone'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that when we are previewing the weight scaling for a particular
    bone, there is a spectrum of colors across different sections of the Skeletal
    Mesh. This is the weight scaling shown visually instead of numerically. Colors
    such as `red`, `orange`, and `yellow` indicate larger weighting for a bone, meaning
    that the highlighted area of the mesh in these colors will be more affected. In
    areas that are `blue`, `green`, and `cyan`, they will still be affected, but not
    as significantly. Lastly, areas that have no overlay highlight will not be affected
    at all by the manipulation of the selected bone. Keep in mind the hierarchy of
    the Skeleton because even though the left arm does not have an overlay color,
    it will still be affected when you are rotating, scaling, and moving the `spine_03`
    bone, since the arms are children of the `spine_03` bone. Please refer to the
    image below to see how the arms are connected to the spine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: The clavicle_l and clavicle_r bones are children of the spine_03
    bone'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.15: The clavicle_l and clavicle_r bones are children of the spine_03
    bone'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by manipulating one of the bones on the mannequin Skeletal Mesh
    and see how these changes affect its animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Persona Editor, *left-click* the `thigh_l` bone in the skeletal hierarchy:![Figure
    10.16: Here, the thigh_l bone is selected'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.16: Here, the thigh_l bone is selected'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `thigh_l` bone selected, we have a clear indication of how the weight
    scaling will affect other parts of the mesh. Also, because of how the Skeleton
    is structured, any modifications to this bone will not impact the upper body of
    the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: You can see that on the skeletal bone hierarchy, the thigh_l
    bone'
  prefs: []
  type: TYPE_NORMAL
- en: is a child of the pelvis bone
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.17: You can see that on the skeletal bone hierarchy, the thigh_l
    bone is a child of the pelvis bone'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the knowledge from earlier chapters, change the Local Location, Local
    Rotation, and Scale values to offset the transform of the `thigh_l` bone. The
    image below shows an example of values to use.![Figure 10.18: The thigh_l values
    updated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.18: The thigh_l values updated'
  prefs: []
  type: TYPE_NORMAL
- en: 'After making the changes to the bone transform, you will see that the mannequin''s
    left leg is completely changed and looks ridiculous:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19: The left leg of the Mannequin Character is completely changed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.19: The left leg of the Mannequin Character is completely changed'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `Details` panel, head to the tab labeled `Preview Scene Settings`.
    *Left-click* this tab and you will see new options, displaying some default parameters
    and an `Animation` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Animation` section to preview animations and how they are affected
    by the changes made to the Skeleton. For the `Preview Controller` parameter, change
    that to the `Use Specific Animation` option. By doing this, a new option labeled
    `Animation` will appear. The `Animation` parameter allows us to choose an animation
    associated with the Character Skeleton to preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, *left-click* on the drop-down menu and select the `ThirdPersonWalk` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, now you can see the mannequin Character playing the walking animation,
    but their left leg is completely misplaced and mis-scaled:![Figure 10.20: Preview
    of the updated animation for the mannequin Character'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.20: Preview of the updated animation for the mannequin Character'
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, make sure to return the `thigh_l` bone back to its original
    Local Location, Local Rotation, and Scale; otherwise, animations moving forward
    will not look correct.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have completed this final part of our second exercise, you have
    experienced first-hand how skeletal bones affect Characters and animations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and perform our second activity to manipulate a different
    bone on the mannequin Character and observe the results of applying different animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.02: Skeletal Bone Manipulation and Animations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this activity, we will put into practice the knowledge we have gained about
    manipulating bones on the default mannequin to affect how the animations are played
    out on the Skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the bone that will affect the entire Skeleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the scale of this bone so that the Character is half its original size.
    Use these values to change `Scale` to (`X=0.500000, Y=0.500000, Z=0.500000`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apply the running animation to this Skeletal Mesh from the `Preview Scene Settings`
    tab and observe the animation for the half-size Character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21: Character that is halved in size performing the running animation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.21: Character that is halved in size performing the running animation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you now have practical knowledge of how bone manipulation
    of Skeletons and Skeletal Meshes affects how animations are applied. You have
    also seen first-hand the effects of weight scaling for the bones of a Skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Animations in Unreal Engine 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s break down the main aspects of animations as they function inside Unreal
    Engine. More in-depth information about the topics in this section can be found
    in the documentation that is available directly from Epic Games: [https://docs.unrealengine.com/en-US/Engine/Animation](https://docs.unrealengine.com/en-US/Engine/Animation).'
  prefs: []
  type: TYPE_NORMAL
- en: Skeletons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Skeletons are Unreal Engine's representation of the Character rig that was made
    in external 3D software; we saw this in *Activity 10.02*, *Skeletal Bone Manipulation
    and Animations*. There isn't much more to skeletons that we haven't discussed
    already, but the main takeaway is that once the Skeleton is in the engine, we
    can view the skeleton hierarchy, manipulate each individual bone, and add objects
    known as sockets. What sockets allow us to do is attach objects to the bones of
    our Character, and we can use these sockets to attach objects such as meshes and
    manipulate the transformation of the sockets without disrupting the bones' transformation.
    In first-person shooters, typically a weapon socket is made and attached to the
    appropriate hand.
  prefs: []
  type: TYPE_NORMAL
- en: Skeletal Meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Skeletal Mesh is a specific kind of mesh that combines the 3D Character model
    and the hierarchy of bones that make up its skeleton. The main difference between
    a Static Mesh and a Skeletal Mesh is that Skeletal Meshes are required for objects
    that use animations, while Static Meshes cannot use animations due to their lack
    of skeleton. We will look more into our main Character Skeletal Mesh in the next
    chapter, but we will be importing our main Character Skeletal Mesh in *Activity
    10.03*, *Importing More Custom Animations to Preview the Character Running*, later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, an animation sequence is an individual animation that can be played
    on a specific Skeletal Mesh; the mesh it applies to is determined by the Skeleton
    selected while importing the animation into the engine. We will look at importing
    our own Character Skeletal Mesh and a single animation asset together in *Activity
    10.03*, *Importing More Custom Animations to Preview the Character Running*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Included in our animation sequence is a timeline that allows us to preview
    the animation frame by frame, with additional controls to pause, loop, rewind,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22: The animation sequence timeline and preview window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.22: The animation sequence timeline and preview window'
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will import a custom Character and an animation.
    The custom Character will include a Skeletal Mesh and a Skeleton, and the animation
    will be imported as an animation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: Importing and Setting Up the Character and Animation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our final exercise, we will import our custom Character and a single animation
    that we will use for the `SuperSideScroller` game's main Character, as well as
    creating the necessary Character Blueprint and Animation Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Included with this chapter is a set of files in a folder labeled `Assets`,
    and it is these files that we will import into the engine. These assets come from
    Mixamo: [https://www.mixamo.com/](https://www.mixamo.com/); feel free to create
    an account and view the free 3D Character and animation content available there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Assets` content is available on our GitHub: [https://packt.live/2IcXIOo](https://packt.live/2IcXIOo).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the Unreal Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Content Browser`, create a new folder named `MainCharacter`. Within this
    folder, create two new folders called `Animation` and `Mesh`. Our `Content Browser`
    tab should now look like the image below:![Figure 10.23: Folders added in the
    MainCharacter directory in Content Browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.23: Folders added in the MainCharacter directory in Content Browser'
  prefs: []
  type: TYPE_NORMAL
- en: Next, import our Character mesh. Inside the `Mesh` folder we created, *right-click*
    and select the `Import` option, which will open the File Explorer menu. Navigate
    to the directory where you saved the `Assets` folder that accompanies this chapter
    and find the `MainCharacter.fbx` asset inside the `Character Mesh` folder – for
    example, `\Assets\Character Mesh\MainCharacter.fbx` – and open that file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When selecting this asset, the FBX import options window will appear. Make sure
    that the options for `Skeletal Mesh` and `Import Mesh` are set to `check` in their
    respective checkboxes and leave every other option set to its default setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we can select the `Import` option so that our FBX asset will be imported
    into the engine. This will include the necessary materials created within the
    FBX; a Physics Asset, which will automatically be created for us and assigned
    to the `Skeletal Mesh`; and the `Skeleton Asset`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Ignore any warnings that may appear when importing the `FBX` file; they are
    unimportant and will not affect our project moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Character, let's import an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our `Animation` folder in the `MainCharacter` folder directory, again
    *right-click* and select the option to `Import`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory where you saved the `Assets` folder that accompanies
    this chapter and locate the `Idle.fbx` asset inside the `Animations/Idle` folder
    – for example, `\Assets\Animations\Idle\Idle.fbx` – and open that file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When selecting this asset, an almost identical window will appear as when we
    imported our Character Skeletal Mesh. Since this asset is only an animation and
    not a Skeletal Mesh/Skeleton, we don''t have the same options as before, but there
    is one crucial parameter that we need to set correctly: `Skeleton`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Skeleton` parameter under the `Mesh` category of our `FBX` import options
    tells the animation to which Skeleton the animation applies. Without this parameter
    set, we cannot import our animation, and applying the animation to the wrong Skeleton
    can have disastrous results or cause the animation to not import altogether. Luckily
    for us, our project is simple and we have already imported our Character Skeletal
    Mesh and Skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `MainCharacter_Skeleton` and choose the option at the bottom, `Import`;
    leave all other parameters set to their defaults.![Figure 10.24: The settings
    when importing the Idle.fbx animation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.24: The settings when importing the Idle.fbx animation'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know to import both a custom Character mesh and an animation. Understanding
    the importing process for both types of assets is crucial, and in the next activity,
    you will be challenged to import the remaining animations. Let's continue this
    exercise by creating both the Character Blueprint and the Animation Blueprint
    for the `SuperSideScroller` game's main Character.
  prefs: []
  type: TYPE_NORMAL
- en: Now, although the Side Scroller template project does include a Blueprint for
    our Character and other assets such as an Animation Blueprint, we will want to
    create our own versions of these assets for the sake of organization and good
    practice as game developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder under our `MainCharacter` directory in `Content Browser`
    and name this folder `Blueprints`. In this directory, create a new Blueprint based
    on the `SideScrollerCharacter` class under `All Classes`. Name this new Blueprint
    `BP_SuperSideScroller_MainCharacter`:![Figure 10.25: The SideScrollerCharacter
    class to be used'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: as the parent class for our Character Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.25: The SideScrollerCharacter class to be used as the parent class
    for our Character Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Blueprints` directory, *right-click* in an empty area of `Content Browser`,
    hover over the `Animation` option, and select `Animation Blueprint`:![Figure 10.26:
    The Animation Blueprint option under the Animation category'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.26: The Animation Blueprint option under the Animation category'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we select this option, a new window will appear. This new window requires
    us to apply a parent class and a Skeleton to our Animation Blueprint. In our case,
    use `MainCharacter_Skeleton`, select OK and name the Animation Blueprint asset
    `AnimBP_SuperSideScroller_MainCharacter`:![Figure 10.27: The settings we need
    when creating our Animation Blueprint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.27: The settings we need when creating our Animation Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open our Character Blueprint, `BP_SuperSideScroller_MainCharacter`,
    and select the `Mesh` component, we will find a handful of parameters that we
    can change:![Figure 10.28: The SuperSideScroller Character Blueprint using the
    mannequin Skeletal Mesh'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.28: The SuperSideScroller Character Blueprint using the mannequin
    Skeletal Mesh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `Mesh` category, we have the option to update the `Skeletal Mesh`
    used. Find our `MainCharacter` Skeletal Mesh and assign it to this parameter:![Figure
    10.29: The settings we need for our Mesh component to properly'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: use our new Skeletal Mesh and our Animation Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.29: The settings we need for our Mesh component to properly use our
    new Skeletal Mesh and our Animation Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: While still in our Character Blueprint and with the `Mesh` component selected,
    we can find the `Animation` category just above the `Mesh` category. Luckily,
    by default, the `Animation Mode` parameter is already set to `Use Animation Blueprint`,
    which is the setting we need.
  prefs: []
  type: TYPE_NORMAL
- en: Now assign the `Anim` class parameter to our new Animation Blueprint, `AnimBP_SuperSideScroller_MainCharacter`.
    Finally, head back to our default `SideScrollerExampleMap` level and replace the
    default Character with our new Character Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, make sure that we have `BP_SuperSideScroller_MainCharacter` selected
    in our `Content Browser` and then *right-click* on the default Character in our
    map and choose to replace it with our new Character:![Figure 10.30: With the Character
    Blueprint selected in Content Browser, we can simply right-click on the default
    Character in the level and replace it with our new Character'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.30: With the Character Blueprint selected in Content Browser, we
    can simply right-click on the default Character in the level and replace it with
    our new Character'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new Character in the level, we can now play in the editor and move
    around the level. The result should look something like the image below; our Character
    in the default T-pose is moving around the level environment:![Figure 10.31: You
    now have the custom Character running around the level'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_10_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.31: You now have the custom Character running around the level'
  prefs: []
  type: TYPE_NORMAL
- en: With our final exercise complete, you now have a full understanding of how to
    import custom Skeletal Meshes and animations. Additionally, you learned how to
    create a Character Blueprint and an Animation Blueprint from scratch and how to
    use those assets to create the base of the `SuperSideScroller` Character.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the final activity of this chapter, where you will be challenged
    to import the remaining animations for the Character and to preview the running
    animation inside Persona Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.03: Importing More Custom Animations to Preview the Character Running'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity aims to import the remaining animations, such as running for the
    player Character, and to preview the running animation on the Character Skeleton
    to ensure that it looks correct.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the activity, all of the player Character animations will be imported
    into the project and you will be ready to use these animations to bring the player
    Character to life in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, all of the animation assets we need to import exist in the `\Assets\Animations`
    directory, wherever you may have saved the original `zip` folder. Import all of
    the remaining animations in the `MainCharacter/Animation` folder. Importing the
    remaining animation assets will work the same way as in *Exercise 10.03*, *Importing
    and Setting Up the Character and Animation*, when you imported the `Idle` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `MainCharacter` skeleton and apply the `Running` animation you
    imported in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with the `Running` animation applied, preview the Character animation
    in the Persona Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32: The expected output of the Character with additional custom
    imported assets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_10_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.32: The expected output of the Character with additional custom imported
    assets'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this final activity completed, you have now experienced first-hand the
    process of importing custom skeletal and animation assets into Unreal Engine 4\.
    The import process, regardless of the type of asset you are importing, is commonplace
    in the games industry and it's vital that you are comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the player Character Skeleton, Skeletal Mesh, and animations imported into
    the engine, we can move on to the next chapter, where you will prepare the Character
    movement and UpdateAnimation Blueprint so that the Character can animate while
    moving around the level.
  prefs: []
  type: TYPE_NORMAL
- en: From the exercises and activities of this chapter, you learned about how the
    Skeleton and bones are used to animate and manipulate the Character. With first-hand
    experience of importing and applying animations into Unreal Engine 4, you now
    have a strong understanding of the animation pipeline, from the Character concept
    to the final assets being imported for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you have learned about topics that we will use in the next chapter,
    such as blend spaces for Character movement animation blending. With the `SuperSideScroller`
    project template created and the player Character ready, in the next chapter,
    let's move on to animating the Character with an Animation Blueprint.
  prefs: []
  type: TYPE_NORMAL
