- en: Building an Obstacle-Avoiding Robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can move the robot in multiple directions for specified periods
    of time, let's think about how to read values from an ultrasonic sensor in order
    to create a robot that can avoid obstacles. We will also use an LCD display and
    use it to print distance values.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using an ultrasonic sensor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an LCD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an obstacle-avoiding robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main hardware requirements for this chapter are the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: An HC-SR04 ultrasonic sensor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 16x2 LCD or a 16x2 LCD with an I2C LCD module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 1 KΩ resistor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 2 KΩ resistor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12-13 connecting wires
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Using an ultrasonic sensor
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An ultrasonic sensor is used to measure the distance between an obstacle or
    an object. An ultrasonic sensor consists of a transmitting transducer and a receiving
    transducer. The transmitting transducer (the trigger) emits **ultrasonic pulses**
    (also referred to as **ultrasonic sound**), which collide with nearby obstacles
    and are received by the receiving transducer (the echo). The sensor determines
    the distance between a target by measuring the time difference between the sending
    and the receiving of ultrasonic waves. The following diagram illustrates this
    process:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f46574f-956b-4437-8c0e-980e47cc5d17.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'The ultrasonic sensor we will use for this project is called an **HC-SR04 ultrasonic
    sensor**, which is one of the most widely-used ultrasonic sensors. It can measure
    distances in the range of 0–180 cm, with a resolution of about 0.3 cm. It has
    a frequency of around 40 KHz. The HC-SR04 sensor consists of the following four
    pins:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: VCC pins
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ground pin
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigger pin
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An echo pin
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A trigger pin is connected to the transmitting transducer, which transmits
    pulses, and an echo pin is connected to the receiving transducer, which receives
    the pulses, as shown in the photo of an HC-SR04 ultrasonic sensor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73133637-f38b-49e7-879f-c72f0e9be28f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: How an ultrasonic sensor measures distances
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve understood the basic workings of an ultrasonic sensor, let''s
    think about exactly how the ultrasonic sensor measures distance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/609372a0-6067-4556-84bd-da0cd9761349.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: In order to measure distance, the ultrasonic sensor generates an ultrasonic
    pulse. To generate this ultrasonic pulse, the trigger pin is set in a **high**
    state for **10 microseconds**. This produces an *eight-cycle sonic burst* that
    travels at the *speed of sound*, which is received by the echo pin after colliding
    with an object. When this *eight-cycle sonic burst* is received, the echo will
    become high and it will remain high for a time duration that is proportional to
    the time taken for the ultrasonic pulse to reach the echo pin. If it took 20 microseconds
    for the ultrasonic pulse to reach the echo pin, the echo pin would remain high
    for 20 microseconds.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The arithmetic equation for determining the time taken
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s firstly look at the arithmetic equation for calculating distance, which
    is shown in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed84f223-6087-425e-8553-a3016e6073f4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: As indicated in the preceding diagram, let's imagine that the distance between
    the sensor and the object is 30 cm. The ultrasonic sensor travels at a speed of
    sound, which is 340 m/s, or 0.034 cm/μs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the time taken, we will use the following equation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc7241ea-190d-418e-b0a0-cf8d89d70a93.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'If we move time to the left-hand side, and speed to the right-hand side, we
    get the following equation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ddea5b8-fca7-44ee-937c-afe3c1aea1c7.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'If we input the preceding numbers, we get the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f5d9451-5fda-467f-8e7e-b60216141bd1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: The result of this equation is that the time taken is 882.35 μs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the time value is 882.35 μs, the time duration for which the echo
    pin remains high will actually be double 882.35 μs, which is 1764.70 μs. This
    is because the ultrasonic sound first travels toward the object, and is received
    by the echo after bouncing back from the object. It travels the same distance
    twice: first from the sensor to the object, and then from the object to the sensor.
    If the time value is doubled, the distance value will also be doubled. We can
    modify the preceding equation to find the distance as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9724eb93-b665-47db-8dd0-3e94527ccd68.png)![](img/c226d115-3dd0-4781-8a83-ba2a81032fd6.png)![](img/69e3b3b7-117e-46e2-a910-00d48243a1b2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Make note of this equation, as we will use it later on to find the distance,
    once we get the time duration value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the ultrasonic sensor to the Raspberry Pi
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HC-SRO4 sensor consists of four pins: **VCC**, **GND**, **trigger** (**Trig**),
    and **echo**, so the wiring connections of the RPi and the ultrasonic sensor should
    be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **VCC** pin of the sensor to pin number 4.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect the **GND** pin of the sensor to pin number 9.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect the **Trig** pin of the sensor to wiringPi pin number 12.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **echo** pin of the sensor is connected to wiringPi pin number 13 via a
    voltage divider. The two resistors used in the voltage divider circuit have a
    resistance value of 1 KΩ (**R1**) and 2KΩ (**R2**), respectively. The voltage
    divider circuit is used to reduce the incoming 5V signal from the echo pin (to
    the RPi) to 3.3V. The wiring connection of RPi and HC-SR04 is shown in the following
    figure:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4ac40083-049a-41fd-9ec6-39e8fa313c5f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'The formula used to convert the incoming voltage to 3.3V is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00e0025c-7d65-4bcc-90d3-77a0bbbe6d7b.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: '**Vin** is the incoming voltage from the echo pin, **R1** is the first resistor,
    and **R2** is the second resistor. **Vin** is 5V, **R1** is 1 KΩ, and **R2** is
    2 KΩ:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/357686da-8029-432c-8e80-b638b0fc8561.png)![](img/8c54b198-1b8e-47e7-be56-a0fdbe0eba7b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: The HC-SR04 sensor program
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After wiring up the HC-SR04 sensor to the Raspberry Pi, let's write a program
    for measuring the distance between an object from an ultrasonic sensor. The distance
    measurement program is called `DistanceMeasurement.cpp` and you can download it
    from the `Chapter04` folder of the GitHub repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for measuring the distance is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we declared the `wiringPi`, `stdio`, and `iostream`
    libraries. After that, we declared the `std` namespace:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: After this, with the lines `#define trigger 12` and `#define echo 13`, we declare
    wiringPi pin number 12 as the trigger pin and wiringPi pin number 13 as the echo
    pin.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we declare two variables called `startTime` and `stopTime`, which are
    of the datatype `Long`.The `startTime` variable will record the time when the
    ultrasonic pulse is sent by the trigger pin and the `stopTime` variable will record
    the time when the ultrasonic pulse is received by the echo pin.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the main function, the trigger pin is set up as `OUTPUT`, as it will
    generate the ultrasonic pulse. The echo pin is set up as `INPUT`, as it will receive
    the ultrasonic pulse.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside a `for` loop, we set the trigger pin to `LOW` for 500 milliseconds, or
    0.5 seconds.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate the ultrasonic pulse, the trigger pin is set to `HIGH` (`digitalWrite(trigger,HIGH)`)
    for 10 microseconds (`delayMicroseconds(10)`). After generating the pulse for
    10 μs, we set the trigger pin to `LOW` again.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have two `while` loops, inside of which, there are two `micros()` functions.
    The `micros()` will return the current time value in milliseconds. The first while
    loop (`digitalRead(echo) == LOW`) will record the time at the beginning of the
    pulse, and the time duration in which the echo pin is `LOW` will be stored in
    the `startTime` variable.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the pulse is received by the echo pin, the second `while` loop (`digitalRead(echo)
    == HIGH`*)* will execute. The `micros()` function inside this while loop will
    return the time value for the time taken for the ultrasonic pulse to reach the
    echo pin. This time value will be stored in the `stopTime` variable.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, to find the total time, we subtract the `startTime` from the `stopTime`
    and store this time value in the `totalTime` variable.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After finding out the `totalTime`, we use the following formula to calculate
    the distance:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*float distance = (totalTime x 0.034)/2*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To display the distance value, we will use the `cout` statement. The `delay(2000);`
    command is called so that the distance value is printed after every two seconds.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completing the code, you can compile and build it to check the final output.
    You can place an object in front of the sensor and the object's distance from
    the sensor will be displayed inside the console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: On my robot's chassis, there is an additional part on which I have fixed the
    ultrasonic sensor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Using an LCD
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **liquid crystal display** (**LCD**) is an electronic display unit that is
    generally used in computers, TVs, smartphones, and cameras. A 16x2 LCD is a basic
    LCD module that is generally used in electronics or DIY projects. As the name
    suggests, a 16x2 LCD consists of 16 columns and 2 rows. This means that it has
    two lines, on each of which we can display a maximum of 16 characters. A 16x2
    LCD consists of 16 pins labeled from **VSS** to **K**, as shown in the following
    photo:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2131f109-6a0f-44de-85f9-b39236de6b2f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Each pin on the LCD can be described as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pin number** | **Name** | **How it works** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| 1  | VSS (GND) | Ground pin. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| 2 | VCC | The VCC pin requires 5V of power in order to turn on the LCD module.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| 3 | Vo | Using this pin, we can adjust the contrast of LCD. We can connect
    it to GND for maximum contrast. If you want to vary the contrast, connect it to
    the data pin of a potentiometer. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| 4 | RS (RegisterSelect) | The LCD consist of two registers: the command register
    and the data register. The RS pin is used to switch between the command and the
    data register. It is set to HIGH (1) for the command register and LOW (0) for
    the data register. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| 5 | R/W (Read Write) | Set this pin to LOW to write to the register, or set
    it to HIGH to read from the register.  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| 6 | E (Enable) | This pin enables the clock of the LCD, so that the LCD can
    execute instructions.  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| 7 | D0 | Even though the LCD has eight data pins, we can either use it in
    eight-bit mode or four-bit mode. In eight-bit mode, all the eight data pins (D0-D7)
    are connected to the RPi pins. In four-bit mode, only four pins (D4-D7) are connected
    to the RPi. We will use the LCD in four-bit mode in this case, so that fewer wiringPi
    pins are occupied.   |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| 8 | D1 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 9 | D2 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 10 | D3 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 11 | D4 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| 12 | D5 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| 13 | D6 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| 14 | D7 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| 15 | A (Anode) | +5V pin for LCD backlight. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| 16 | K (Cathode) | GND pin for LCD backlight. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: Since a 16x2 LCD has a total of 16 pins, connecting all the pins correctly to
    the Raspberry Pi can sometimes be an issue. If you make a mistake and a pin that
    needs to be connected to D0 gets connected to D1, for example, you might get incorrect
    output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this potential confusion, you can choose to purchase an **I2C LCD adapter
    module** for a 16x2 LCD. This module takes the 16 pins of LCD as an input, and
    provides only 4 pins as an output (VCC, GND, SDA, SCL). This means that you only
    need to connect 4 pins to the Raspberry Pi, instead of 16 pins.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The 16x2 LCDs with I2C LCD adapters soldered to them are also available, which
    can save you some time. The 16x2 LCD that I''m using for this project already
    has an I2C LCD adapter soldered to it, as shown in the following picture:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8ddc43e-28b8-4c72-983d-55bc3a128e5e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we'll understand the wiring connections and how to
    program both a normal LCD and an LCD with an I2C LCD adapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: I will refer to the **16x2 LCD with the I2C LCD adapter** as **I2C LCD** to
    avoid complication.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the 16x2 LCD to the Raspberry Pi
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect the 16x2 LCD to the Raspberry Pi, you will need a mini breadboard,
    as there are a couple of pins that need to be connected to the VCC and the GND.
    The wiring connections of RPi and the 16x2 LCD are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc131ce7-56ca-450b-8f64-8a9b22acb8cb.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'First, connect pin number 2 or pin number 4 from the Raspberry Pi to one horizontal
    pin of the breadboard, so that we can use that row as a VCC row. Similarly, connect
    one ground pin from the Raspberry Pi to a horizontal pin of the breadboard, so
    that we can use that row as the ground row. Next, follow these instructions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Connect the VSS (GND) pin to the ground row of breadboard
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the VCC pin to the VCC row of the breadboard
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the V0 pin to the ground row of breadboard
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **register select** (**RS**) pin to wiringPi pin number 22 of the
    RPi
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the R/W pin to the ground row of the breadboard, as we will write off
    the LCD's register
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the enable pin to wiringPi pin number 26 of the RPi
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use the LCD in four-bit mode, so pins D0 to D3 will remain unconnected
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin D4 should be connected to wiringPi pin number 24 of the RPi
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin D5 should be connected to wiringPi pin number 25 of the RPi
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin D6 should be connected to wiringPi pin number 27 of the RPi
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin D7 should be connected to wiringPi pin number 28 of the RPi
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode pin to the VCC row of the breadboard
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the cathode pin to the ground row of the breadboard
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For testing the LCD program, add `-lwiringPiDev` command inside Compile and
    Build option by opening Build | Set Build Commands as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b116e0b7-8c82-44f2-9b5e-e8c153012deb.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: After connecting the 16X2 LCD to the RPi, let's program the LCD.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Programming the LCD
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write two programs using the normal 16x2 LCD. In the first program,
    we will print a value on the 16x2 LCD. In the second program, we will print the
    ultrasonic sensor value on the LCD screen. The first program is called `LCDdisplay.cpp`
    and you can download it from the GitHub repository of `Chapter04`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The LCD program
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After connecting the LCD to the Raspberry Pi, let''s examine the program for
    printing the value on the LCD, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the details of the preceding program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: First, we call the `LCD.h` library. The `LCD.h` library consists of all the
    important functions that we can use to print, position, and move text, as well
    as clear the LCD screen.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we define pin numbers RS, E, D4, D5, D6, and D7.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, inside the `lcdInit` function, the first number, which is `2`, represents
    the number of rows in the LCD, while the number `16` represents the number of
    columns. The number `4` means that we are using the LCD in four-bit mode. Next,
    we have the RS and E pins, and finally, we have the four data pins. Since we haven't
    connected the D0, D1, D2, and D3 data pins to the RPi, we have four zeros at the
    end.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `lcdPuts` is used to print data on the LCD. It takes two parameters as
    input: the `fd` variable and the text value that needs to be displayed.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completing this code, you can compile and build the code to test the final
    output.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the output, you will notice that the text output will start from column one,
    instead of column zero.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To position the text on the extreme left side, or column `0`, row `0`, we need
    to use the `lcdPosition()` function. The `lcdPosition(fd, column position, row
    position)` function consists of three parameters, and it should be written before
    the `lcdPuts` function as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the text is not positioned at column 0 and row 0, restart your RPi and test
    the code once again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The LCD and the ultrasonic sensor program
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After printing a simple text value on the LCD, let''s take a look at how to
    view the ultrasonic distance value on the LCD screen. The wiring connection of
    the HC-SR04 ultrasonic sensor, the 16x2 LCD, and the RPi are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50d44944-2bea-4121-b45f-bb6aeec24483.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'The LCD connections to the RPi remain the same. The ultrasonic trigger pin
    is connected to wiringPi pin number 12 and the echo pin is connected to wiringPi
    pin number 13\. Let''s now take a look at the program. This program is called
    `LCDdm.cpp` (**dm** is short for **distance measurement**) and you can download
    it from the GitHub repository of `Chapter04`. The `LCDdm.cpp` program is a combination
    of the `LCDdisplay.cpp` and `DistanceMeasurement.cpp` programs:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, after finding out the distance value, we position the
    cursor in row zero, column zero, using the `lcdPosition(fd, 0, 0);` command. Next,
    with the `lcdPuts(fd, "Distance: ")` code, we are displaying the distance text.
    After this, we position the cursor in column zero and row one. Finally, to print
    the distance value, we use the `lcdPrintf(fd, distance);` command. Since we have
    set the delay to two seconds, the distance value will be printed every two seconds.
    It will then be cleared (`clear()`) and replaced with a new value.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: What is the I2C protocol?
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The I2C protocol is used in many electronic devices. We use it to connect one
    master device to multiple slave devices, or multiple master devices to multiple
    slave devices. The main advantage of the I2C protocol is that the master needs
    only two pins to communicate with multiple slave devices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'In an I2C bus, all devices are connected in parallel to the same two-wire bus.
    We can connect a total of 128 devices using 7-bit addressing, and a total of 
    1,024 devices using 10-bit addressing, as shown in the following diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb12dc27-aadc-4936-a5a2-5e1816b59d8f.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Each device connected using the I2C protocol has a unique ID, which makes it
    possible to communicate with multiple devices. The two main pins in the I2C protocol
    are the **Serial Data** (**SDA**) pin and the **Serial Clock** (**SCA**) pin:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**SDA**: The SDA line is used for transferring data.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCL**: The SCL is generated by the master device. It is a clock signal that
    synchronizes the data transfer between the devices connected in the I2C.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've understood the basics of the I2C protocol, let's look at how
    to connect the I2C LCD and the Raspberry Pi.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the I2C LCD and the Raspberry Pi
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Raspberry Pi, physical pin number 3 is the SDA pin, while physical pin
    number 5 is the SCA pin, as shown in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a26ae87-880f-47ed-bd0d-4202a77002d3.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'The following is the details of connecting LCD with the RPi:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Connect pin number 3 of the Raspberry Pi to the SDA pin of the LCD
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin number 5 of the Raspberry Pi to the SCA pin of the LCD
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND pin of the LCD to the GND pin of the RPi
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the VCC pin of the LCD to pin number 2 or pin number 4 of the Raspberry
    Pi
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programming the LCD with the I2C LCD module
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before writing the program, we first need to enable the I2C protocol from the
    Raspberry Pi configuration. To do this, open the command window and type in the
    following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside configurations, open Interfacing Options, shown as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f02ab85-9905-400a-a784-589eb3e4ec2c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Next, open the I2C option, as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d20a283-291f-4fef-b936-bedda3ee1613.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Select the Yes option and press *Enter* to enable I2C, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b31f95ca-9171-4eae-9d40-2e3cfca6d1a7.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'After enabling I2C, select the Ok option and exit the configuration, shown
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d1c032c-dd09-46ef-b8b1-3299651b5b8c.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: After enabling the I2C protocol inside your Raspberry Pi, let's write the program
    to print values to the LCD. The program is called `I2CLCD.cpp` and you can download
    it from the GitHub repository of `Chapter04`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this LCD has an I2C module attached to it, the `LCD.h` library that we
    used in the previous LCD program will not work in this program. Instead, I have
    created five main functions that will initialize the LCD, print messages, and
    clear the LCD screen, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`init_lcd()`: This function will initialize (set up) the LCD'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printmessage()`: This function is used to print a string on the LCD'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printInt()`: This function is used to display integer values'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printfloat()`: This function is used to display float values'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This function will clear the LCD screen'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We start the program by declaring the `wiringPiI2C.h` library. Next, we have
    the `wiringPi` library and two other libraries, which are standard C libraries.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, with the `#define I2C_DEVICE_ADDRESS 0x27` command, we define the
    I2C device address, which is `0x27`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `0x80` command represents the first row: row zero, column zero. With the  `#define
    firstrow 0x80` command, we initialize the first line of the LCD.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, `0xC0` represents the second row of LCD: row one, column zero. With
    the `#define secondrow 0xC0` command, we initialize the second line of the LCD.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, inside the `lcdaddr` variable, we will store the I2C LCD''s address,
    as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the `main()` function, we store the device address inside the `lcdaddr`
    variable.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we initialize, or set up the LCD with the `init_lcd();` command.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the `for` loop, we move the cursor to the first row with the `moveCursor(firstrow);`command.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, since the cursor is in the first row, the `LCD OUTPUT` text inside the
    `printmessage("LCD OUTPUT"`code will be printed on the first row.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cursor is then moved to the second row with the `moveCursor(secondrow)` command.
    The `USING I2C` text is printed on that row.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The text on the first and second rows will be visible for two seconds, after
    which time the LCD screen will be cleared with the `clear()` command.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, with the next four lines, an integer, `314`, will be printed on
    the first row. The `printInt(iNumber)` function is used to display the integer
    value.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the `printFloat(iFloat)` function is used to display the float value.
    In the next four lines, `float 3.14` will be printed on the second row.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we again clear the LCD.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how we can display string, numeric, and float values inside our I2C LCD.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The I2C LCD and the ultrasonic sensor program
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read the ultrasonic sensor value inside an I2C LCD, connect the ultrasonic
    sensor and I2C LCD to the RPi. From the GitHub repository of `Chapter04`, you
    can download the complete program called `I2CLCDdm.cpp` program. The wiring connections
    of I2C LCD, ultrasonic sensor, and the RPi is shown in the following figure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/870f16ba-4b07-4833-824d-4930cd0e0704.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'This `I2CLCDdm.cpp`program is basically a combination of the `DistanceMeasurement.cpp`
    and the `I2CLCD.cpp` programs. In this program, after declaring all the necessary
    libraries and variables related to the ultrasonic sensor and the I2C LCD below
    the `cout << "Distance: "<<distance << "cm" << endl` line, we need to add the
    following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the first row, the text `DISTANCE` will be printed using the `printmessage("DISTANCE")` command.
    After that, on the second row, the distance value will be printed using the `printFloat(distance)` command,
    since the code is still on the second line. With the `printmessage(" cm")` command,
    the `cm` text will be printed beside the distance value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The distance value inside the console and the I2C LCD will be visible for two
    seconds. Next, with the `clear()` function, the old distance value will be cleared
    and replaced with a new value. In the console, however, the new value will be
    displayed on the next line.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Building an obstacle-avoiding robot
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, our robot will move freely in a given space, but as soon as it
    comes near to an object or an obstacle, it will turn or move backward, thus avoiding
    the obstacle. In this kind of project, we generally use an ultrasonic sensor.
    As the robot moves, the ultrasonic sensor keeps measuring the distance it is away
    from objects. When the sensor detects that the distance value is very low, and
    the robot may collide with the nearby object, it will command the robot to change
    direction, thus avoiding the obstacle.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an obstacle-avoiding robot, you first need to mount the ultrasonic
    sensor on the robot. Inside my robotic kit, there is already an attachment that
    allows me to mount the ultrasonic sensor on the robot. This attachment looks as
    follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb5a56d9-8248-406f-b183-c67105b56321.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: 'After attaching the ultrasonic sensor on the robot, the final assembly looks
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3314bcae-f4eb-4046-b225-99fc138a42a4.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Wiring connections
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultrasonic sensor''s trigger pin is connected to wiringPi pin number 12,
    while the echo pin is connected to wiringPi pin number 13 via the voltage divider
    circuit. The VCC pin of the ultrasonic sensor is connected to physical pin 2 (5V)
    of RPi, and the ground pin of the ultrasonic sensor is connected to physical pin
    6 of RPi. The remaining connections are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**WiringPi pin 0** is connected to the **IN1 pin** of the L298N motor driver.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WiringPi pin 2** is connected to the **IN2 pin** of the L298N motor driver.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WiringPi pin 3** is connected to the **IN3 pin** of the L298N motor driver.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WiringPi pin 4** is connected to the **IN4 pin** of the L298N motor driver.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **motor driver's ground pin** is connected to the **physical pin 3** of
    RPi.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm using an I2C LCD, so the **SDA pin** of the I2C LCD is connected to the
    **physical pin 3 of the RPi**, and the **SCL pin** is connected to the **physical
    pin 5**. The **ground pin of I2C LCD** is connected to **physical pin 9**, and
    the **VCC pin of I2C LCD** is connected to **physical pin 4** of RPi.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the LCD display to the robot is totally up to you. If you have sufficient
    space on the robot where the LCD can be placed, go ahead and add it. If not, this
    is not a necessity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Programming the obstacle-avoiding robot
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this program, we will first find out the distance of a nearby object using
    the ultrasonic sensor. Next, we will create an `if` condition that monitors the
    distance value. If the distance goes below a certain value, we will command the
    robot to take a turn. Otherwise, the robot will keep moving forward. You can download
    the complete code called `ObstacleAvoiderRobot.cpp` from `Chapter04` in the GitHub repository:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code, if the **distance** is **greater** than **7 cm**, the robot will
    keep moving forward. Now, as long as the obstacle is not present, the LCD will
    display the message `No Obstacle` on the second row. If an obstacle is detected,
    the robot will first make a radial left turn for 0.5 seconds and the I2C LCD will
    display the `Obstacle detected` text on the second row. You can increase or decrease
    the delay value depending on the speed of your motors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how an ultrasonic sensor works, and we wrote
    a program to measure the distance values. Next, we programmed the 16x2 LCD, and
    read the ultrasonic distance value using it. We also looked at the I2C LCD, which
    takes the 16 LCD pin as an input, and provides four pins as an output, thus simplifying
    the wiring connections. Finally, we fitted the ultrasonic sensor on our robot
    to create our obstacle-avoiding robot. This robot moved freely when there was
    no obstacle near it, and if it approached an obstacle, it would avoid it by taking
    a turn.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to create two different types of PC-controlled
    robot. In the first PC-controlled robot, we will use a library called **ncurses**
    and use the keyboard as an input. In the second PC-controlled robot, we will create
    UI buttons using QT, and then use them to move the robot.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建两种不同类型的PC控制机器人。在第一个PC控制机器人中，我们将使用一个叫做**ncurses**的库，并使用键盘作为输入。在第二个PC控制机器人中，我们将使用QT创建UI按钮，然后使用它们来移动机器人。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What type of pulse does an ultrasonic sensor send?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超声波传感器发送什么类型的脉冲？
- en: What does LCD stand for?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LCD代表什么？
- en: Up to what distance can an HC-SR04 ultrasonic sensor measure?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HC-SR04超声波传感器可以测量到多远的距离？
- en: Which row and column would the `lcdPosition(fd, 4,1)` command start printing
    the text?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lcdPosition(fd, 4,1)`命令会从哪一行和哪一列开始打印文本？'
- en: What are the functions of the anode pin (pin 15) and the cathode pin (pin 16)
    pin on an LCD?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LCD的阳极引脚（引脚15）和阴极引脚（引脚16）在LCD上有什么功能？
