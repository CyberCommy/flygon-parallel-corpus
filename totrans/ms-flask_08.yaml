- en: Chapter 8. Building RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Representational State Transfer, or **REST**, is a method of transferring information
    between a client and a server. On the Web, REST is used on top of HTTP and allows
    browsers and servers to easily communicate by leveraging basic HTTP commands.
    By using HTTP commands, REST is platform and programming language agnostic, and
    decouples the client and the server for easier development. This is typically
    used in JavaScript applications that need to pull or update user information on
    the server. REST is also used to provide outside developers with a common interface
    to user data. For example, Facebook and Twitter use REST in their application
    program interface (**API**), to allow developers to get information without having
    to parse the website's HTML.
  prefs: []
  type: TYPE_NORMAL
- en: What is REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into the details of REST, let''s look at an example. With a
    client, in this case, a web browser, and a server, the client sends a request
    to the server over HTTP for some models as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is REST](img/B03929_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The server will then respond with a document containing all the models.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is REST](img/B03929_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The client can then modify the data on the server through a `PUT` HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is REST](img/B03929_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then the server will respond that it has modified the data. This is a very simplified
    example, but it will serve as a backdrop to how REST is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a strict standard, REST lays out a set of constraints on communications
    to define a methodology that can be implemented in many ways. These constraints
    are born out of years of trial and error with other communication protocols, such
    as **Remote Procedure Call** (**RPC**) or **Simple Object Access Protocol** (**SOAP**).
    These protocols fell by the wayside due to their strictness, verboseness, and
    the difficulty in creating APIs with them. The issues with these systems were
    identified, and REST's constraints were created to keep these issues from happening
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The first constraint requires that the client and the server must have a separation
    of concerns. The client cannot handle permanent data storage, and the server cannot
    handle anything with the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The second constraint is that the server must be stateless. What this means
    is that any information that is necessary to handle requests is stored in the
    request itself or by the client. An example of the server being stateless is the
    session object in Flask. The session object does not store its information on
    the server, but stores it on the client in a cookie. The cookie is sent along
    with every request for the server to parse and determine if the necessary data
    for the requested resource is stored inside it rather than the server storing
    session information for every user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third constraint is that all resources provided must have a uniform interface.
    There are many different parts to this constraint, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface is based around resources, which are models in our case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data sent by the server is not the actual data in the server, but a representation.
    For example, the actual database is not sent with each request, but a JSON abstraction
    of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data sent by the server is enough to allow the client to modify the data
    on the server. In the preceding example, the IDs passed to the client filled this
    role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every resource provided by the API must be represented and accessed in the same
    manner. For example, one resource cannot be represented in XML and one in JSON,
    one over raw TCP and one over HTTP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final constraint is that the system must allow for layers. Load balancers,
    proxies, caches, and other servers and services can act between the client and
    the server as long as the final result is the same as if they were not there.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a system adheres to all these constraints, it is considered to be a RESTful
    system. The most common forms of RESTful systems are built of HTTP and JSON. Each
    resource is located on its own URL path and modified with different HTTP request
    types. Generally, it takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP method | URL | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://host/resource` | Get all the resource representations |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://host/resource/1` | Get the resource with an ID of one |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `http://host/resource` | Create a new resource from the form data
    in the `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `http://host/resource/1` | Modify the existing data of the resource
    with the ID of one |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `http://host/resource/1` | Delete the resource with the ID of
    one |'
  prefs: []
  type: TYPE_TB
- en: 'As an example, a response to the second `GET` request would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In REST APIs, it is also very important to return the correct HTTP status code
    with the response data, to notify the clients of what actually happened on the
    server without the client resorting to parsing the returned message. Here is the
    list of the main HTTP codes used in REST APIs and their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP code | Name | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 200 | OK | The default code of HTTP. The request was successful, and the
    data was returned. |'
  prefs: []
  type: TYPE_TB
- en: '| 201 | Created | The request was successful, and a new resource was created
    on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| 204 | No content | The request was successful, but the response returned
    no content. |'
  prefs: []
  type: TYPE_TB
- en: '| 400 | Bad request | The request was denied because of some perceived client
    error—either a malformed request or missing required data. |'
  prefs: []
  type: TYPE_TB
- en: '| 401 | Unauthorized | The request was denied because the client is not authenticated
    and should authenticate before requesting this resource again. |'
  prefs: []
  type: TYPE_TB
- en: '| 403 | Forbidden | The request was denied because the client does not have
    permission to access this resource. This is in contrast to the 401 code, which
    assumes that the user is not authenticated. The 403 code says the resource is
    not accessible regardless of authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| 404 | Not found | The requested resource does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| 405 | Method not allowed | The request was denied because the HTTP method
    is not available for the URL. |'
  prefs: []
  type: TYPE_TB
- en: Setting up a RESTful Flask API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our app, we will create a RESTful interface to the blog post data in our
    database. The representations of the data will be sent as JSON. The data will
    be retrieved and modified using the general form in the preceding table, but the
    URI will be `/api/posts`.
  prefs: []
  type: TYPE_NORMAL
- en: We could just use the standard Flask views to create the API, but the Flask
    extension **Flask Restful** makes the task much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Flask Restful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `extensions.py` file, initialize the `Api` object that will handle all
    the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The control logic and views for our Post API should be stored in a new folder
    named `rest` in the `controllers` folder. In this folder, we will need an empty
    `__init__.py` and a file named `post.py`. Inside `post.py`, let''s create a simple*Hello
    World* example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Flask Restful, every REST resource is defined as a class that inherits from
    the `Resource` object. Much like the `MethodView` object shown in [Chapter 4](ch04.html
    "Chapter 4. Creating Controllers with Blueprints"), *Creating Controllers with
    Blueprints*, any class that inherits from the `Resource` object defines its logic
    with methods named after the HTTP methods. For example, when the `GET` HTTP method
    hits the `PostApi` class, the `get` method will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the other Flask extensions we used, the `Api` object will need to
    be initialized on the app object in the `__init__.py` file, which holds the `create_app`
    function. The `PostApi` class will also have its route defined with the `add_resource()`
    method of the `Api` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you open the `/api/post` URI in the browser, the *Hello World* JSON
    will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: GET requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some of our `GET`, `PUT`, and `DELETE` requests, our API will need the
    ID of the Post to modify. The `add_resource` method can take multiple routes,
    so let''s add the second route that captures the passed ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `get` method will need to accept `post_id` as a keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The data to be sent to the client must be a representation of the Post objects
    in JSON, so how will our Post objects be translated? Flask Restful provides a
    way of translating any object to JSON through the `fields` object and the `marshal_with`
    function decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Output formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output format is defined by creating a dictionary of `field` objects that
    represent basic types. The key of the field defines what attribute the field will
    try to translate. By passing the dictionary to the `marshal_with` decorator, any
    object the `get` method attempts to return will be first translated with the dictionary.
    This also works for lists of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While reloading the API in the browser, every Post object will be shown in
    JSON format. However, the problem is that the API should not return the HTML from
    the WYSIWYG editor in the post creation form. As stated earlier, the server should
    not be concerned with UI, and HTML is purely for output specification. To solve
    this, we will need a custom field object that strips HTML from strings. In a new
    file in the `rest` folder named `fields.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `post_fields` dictionary should be updated to work with the new field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the standard library `HTMLParser` module, we now have a `strip_tags` function
    that will return any string cleaned of HTML tags. A new field type `HTMLfield`
    is defined by inheriting from the `fields.Raw` class and sending values through
    the `strip_tags` function. If the page is reloaded once again, all the HTML is
    gone and just the text remains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask Restful provides many default fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.String`: This converts the value using `str()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.FormattedString`: This passes formatted string in Python with the variable
    name in brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Url`: This provides the same functionality as the Flask `url_for` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.DateTime`: This converts a Python `date` or `datetime` object to a
    string. The format keyword argument specifies if the string should be an `ISO8601`
    date or an `RFC822` date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Float`: This converts the value to a string representation of a float.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Integer`: This converts the value to a string representation of an
    integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Nested`: This allows nested objects to be represented by another dictionary
    of field objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.List`: Much like the MongoEngine API, this field takes another field
    type as an argument and tries to convert a list of values into a JSON list of
    the field types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Boolean`: This converts the value to a string representation of a boolean
    argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two more fields that should be added to the returned data: the author
    and the tags. The comments will be left out because they should be contained under
    their own resource.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `author` field uses the attribute keyword argument of the `field` class.
    This allows any attribute of the object to be represented rather than just base-level
    properties. Because the many-to-many relationship of the tags returns a list of
    objects, the same solution cannot be used with the tags. Using the `NestedField`
    type inside a `ListField` and another dictionary of fields, a list of tag dictionaries
    can now be returned. This has the added benefit for the end users of the API of
    giving them a tag ID to easily query as if there was a tag API.
  prefs: []
  type: TYPE_NORMAL
- en: Request arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While sending a `GET` request to the base of the resource, our API currently
    sends all the Post objects in the database. This is acceptable if the number of
    objects is low or the number of people using the API is low. However, if either
    increases, the API will put a large amount of stress on the database. Much like
    the Web interface, the API should be paginated as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, our API will need to accept a `GET` query string
    parameter `page` that specifies which page to load. Flask Restful provides a method
    to grab request data and parse it. If the required arguments aren''t there, or
    the types don''t match, Flask Restful will autocreate a JSON error message. In
    a new file in the `rest` folder named `parsers.py`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `PostApi` class will need to be updated to work with our parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `RequestParser` looks for the `page` variable
    in either the query string or the request header and returns the page of Post
    objects from that page.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a parser object is created with `RequestParser`, arguments can be added
    using the `add_argument` method. The first argument of `add_argument` is the key
    of the argument to parse, but `add_argument` also takes a lot of keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`: This is what the parser does with the value after it has been successfully
    parsed. The two available options are `store` and `append`. `store` adds the parsed
    value to the returned dictionary. `append` adds the parsed value to the end of
    a list in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case_sensitive`: This is a `boolean` argument to allow or disallow the keys
    to be case insensitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`choices`: This is like MongoEngine, a list of the allowed values for the argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This is the value produced if the argument is absent from the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dest`: This is the key to add the parsed value in the return data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help`: This is a message to return to the user if validation fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignore`: This is a `boolean` argument to allow or disallow failures of the
    type conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`: this indicates where to look for the data. The locations available
    are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args` to look in the `GET` query string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers` to look in the HTTP request headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form` to look in the HTTP `POST` data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookies` to look in the HTTP cookies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json` to look in any sent JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files` to look in the `POST` file data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'required: this is a `boolean` argument to determine if the argument is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'store_missing: this is a `boolean` argument to determine if the default value
    should be stored if the argument is not in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'type: this is the Python type to convert the passed value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the Flask Restful parser, it is very easy to add new parameters to the
    API. For example, let''s add a user argument that allows us to search for all
    posts by a user. First, in the `parsers.py` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `post.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the Flask `abort` function is called from a `Resource`, Flask Restful will
    automatically create an error message to be returned with the status code.
  prefs: []
  type: TYPE_NORMAL
- en: POST requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using our new knowledge of the Flask Restful parser, the `POST` endpoint can
    be added. First, we will need a parser that will take a title, the body text,
    and a list of tags. In the `parser.py` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `PostApi` class will need a `post` method to handle incoming requests.
    The `post` method will use the given values for the title and body text. Also,
    if the tags key exists, then add the tags to the post, which creates new tags
    if the passed ones do not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At the `return` statement, if a tuple is returned, the second argument is treated
    as the status code. There is also a third value that acts as extra header values
    by passing a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test this code, a different tool than the web browser has to be
    used, as creating custom POST requests without a browser plugin is very difficult
    in a browser. A tool named curl will be used instead. **Curl** is a command-line
    tool included in Bash that allows for creation and manipulation of HTTP requests.
    To perform a `GET` request with curl, just pass the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass `POST` variables, the `d` flag is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The id of the newly created post should be returned. However, if you now load
    the post you created in the browser, an error should appear. This is because our
    `Post` object had no user associated with it. In order to have Post objects assigned
    to users and for only authenticated users of the website to have permission to
    `POST` posts, we need to create an authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve our authentication problems, Flask-Login could be used and the cookie
    data from the login could be checked. However, this would require developers who
    wish to use our API to have their program login through the web interface. We
    could also have developers send their login data with every request, but it's
    a good design practice to only send sensitive information when absolutely necessary.
    Instead, our API will provide an `auth` endpoint that allows them to send login
    credentials and get an access token back.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `access` token will be created by the Python library *it''s dangerous*,
    which Flask uses to encode the session data on a cookie, so it should already
    be installed. The token will be a Python dictionary cryptographically signed by
    the app''s secret key containing the id of the user. This token has an expiration
    date encoded inside it that will not allow it to be used after it expires. This
    means that even if the token is stolen by a malicious user, it will only be useful
    for a limited amount of time before the client has to reauthenticate. First, a
    new parser is needed to handle parsing the username and password data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new file named `auth.py` inside the `rest` folder, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not allow users to send their login credentials across an unsecured connection!
    HTTPS is required if you wish to protect your user's data. The best solution would
    be to require HTTPS for your entire app to avoid the possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users of our API will have to pass the token received from this resource to
    any method that requires user credentials. However, first we need a function that
    verifies the token. In the `models.py` file, the `verify_auth_token` will be a
    `staticmethod` on the `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `POST` parser needs a token argument to accept the `auth` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `post` method can properly add new posts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using curl, our `auth` and `post` APIs can now be tested. For the sake of brevity,
    the token is omitted here as it is very long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: PUT requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As listed in the table at the beginning of this chapter, `PUT` requests are
    for changing the values of existing resources. Like the `post` method, the first
    thing to be done is to create a new parser in `parsers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic for the `put` method is very similar to the `post` method. The main
    difference is that each change is optional and any request that does not provide
    a `post_id` is denied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this method, curl can also create `PUT` requests with the `-X` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: DELETE requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we have the `DELETE` request, which is the simplest of the four supported
    methods. The main difference with the `delete` method is that it returns no content,
    which is the accepted standard with `DELETE` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If everything is successfully deleted, you should receive a 204 status code
    and nothing should show up.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on from REST completely, there is one final challenge to the
    reader to test your understanding of Flask Restful. Try to create a comments API
    that is not only modifiable from `http://localhost:5000/api/comments`, but also
    allow developers to modify only those comments on a specific post by using the
    URL `http://localhost:5000/api/post/<int:post_id>/comments`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Post API is now a complete feature. If a developer wants, they can create
    a desktop or mobile application using this API, all without using HTML scraping,
    which is a very tedious and long process. Giving the developers who wish to use
    your website as a platform the ability to do so will increase your site's popularity,
    as they will essentially give you free advertising with their app or website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the popular program Celery to run programs
    and tasks asynchronously with our application.
  prefs: []
  type: TYPE_NORMAL
