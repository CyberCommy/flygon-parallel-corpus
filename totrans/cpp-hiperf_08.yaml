- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compile-Time Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has the ability to evaluate expressions at compile time, meaning that values
    are already calculated when the program executes. Even though metaprogramming
    has been possible since C++98, it was initially very complicated due to its complex
    template-based syntax. With the introduction of `constexpr`, `if constexpr`, and
    recently, C++ *concepts*, metaprogramming has become much more similar to writing
    regular code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you a brief introduction to compile-time expression evaluations
    in C++ and how they can be used for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming using C++ templates and how to write abbreviated function templates
    in C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting and manipulating types at compile time using type traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant expressions that are evaluated by the compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++20 concepts and how to use them to add constraints to our template parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-world examples of metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin with an introduction to template metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to template metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing regular C++ code, it is eventually transformed into machine code.
    **Metaprogramming**, on the other hand, allows us to write code that transforms
    itself into regular C++ code. In a more general sense, metaprogramming is a technique
    where we write code that transforms or generates some other code. By using metaprogramming,
    we can avoid duplicating code that only differs slightly based on the data types
    we use, or we can minimize runtime costs by precomputing values that can be known
    before the final program executes. There is nothing that stops us from generating
    C++ code by using other languages. We could, for example, do metaprogramming by
    using preprocessor macros extensively or writing a Python script that generates
    or modifies C++ files for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: A metaprogram generates regular C++ code that will later be compiled
    into machine code'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we could use any language to produce regular code, with C++, we
    have the privilege of writing metaprograms within the language itself using **templates**
    and **constant expressions**. The C++ compiler can execute our metaprogram and
    generate regular C++ code that the compiler will further transform into machine
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many advantages to doing metaprogramming directly within C++ using
    templates and constant expressions rather than using some other technique:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to parse the C++ code (the compiler does that for us).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is excellent support for analyzing and manipulating C++ types when using
    C++ template metaprogramming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code of the metaprogram and the regular non-generic code is mixed in the
    C++ source. Sometimes, this can make it hard to understand what parts are executed
    at runtime and compile time, respectively. However, in general, this is a very
    important aspect of making C++ metaprogramming effective to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In its simplest and most common form, template metaprogramming in C++ is used
    to generate functions, values, and classes that accept different types. A template
    is said to be **instantiated** when the compiler uses that template to generate
    a class or a function. Constant expressions are **evaluated** by the compiler
    to generate constant values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Compile-time programming in C++. The metaprogram that will generate
    regular C++ code is written in C++ itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a somewhat simplified view; there is nothing that says that the C++
    compiler is required to perform the transformations in this way. However, it''s
    useful to think about C++ metaprogramming being carried out in these two distinct
    phases:'
  prefs: []
  type: TYPE_NORMAL
- en: An initial phase, where templates and constant expressions produce regular C++
    code of functions, classes, and constant values. This phase is usually called
    **constant evaluation**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second phase, where the compiler eventually compiles the regular C++ code
    into machine code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this chapter, I will refer to C++ code generated from metaprogramming
    as *regular C++ code*.
  prefs: []
  type: TYPE_NORMAL
- en: When using metaprogramming, it is important to remember that its main use case
    is to make great libraries and, thereby, hide complex constructs/optimizations
    from the user code. Please note that however complex the interior of the code
    for the metaprogram may be, it's important to hide it behind a good interface
    so that the user codebase is easy to read and use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and create our first templates for generating function and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at a simple `pow()` function and a `Rectangle` class. By using
    a **type template parameter**, the `pow()` function and the `Rectangle` class
    can be used with any integer or floating-point type. Without templates, we would
    have to create a separate function/class for every base type.
  prefs: []
  type: TYPE_NORMAL
- en: Writing metaprogramming code can be very complex; something that can make it
    easier is to imagine how the expected regular C++ code is intended to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a simple function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function will generate a function whose return type is dependent
    on the template parameter type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The explicit template argument types (`float` and `int` in this case) can (preferably)
    be omitted, and instead the compiler can figure this out on its own. This mechanism
    is called **template argument deduction** because the compiler *deduces* the template
    arguments. The following example will result in the same template instantiation
    as the one shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Correspondingly, a simple class template can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When a class template is utilized, we can explicitly specify the types that
    the template should generate the code for, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But it''s also possible to benefit from **class template argument deduction**
    (**CTAD**), and have the compiler deduce the argument type for us. The following
    code will instantiate a `Rectangle<int>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A function template can then accept a `Rectangle` object where the rectangle
    dimensions are defined using an arbitrary type `T`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Type template parameters are the most common template parameters. Next, you
    will see how to use numeric parameters instead of type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Using integers as template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond general types, a template can also be of other types, such as integral
    types and floating-point types. In the following example, we will use an `int`
    in the template, which means that the compiler will generate a new function for
    every unique integer passed as a template argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will oblige the compiler to instantiate two distinct functions:
    one squares the value and one cubes the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note the difference between the template parameter `N` and the function parameter
    `v`. For every value of `N`, the compiler generates a new function. However, `v`
    is passed as a regular parameter and, as such, does not result in a new function.
  prefs: []
  type: TYPE_NORMAL
- en: Providing specializations of a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the compiler will generate regular C++ code whenever we use a template
    with new parameters. But it''s also possible to provide a custom implementation
    for certain values of the template parameters. Say, for example, that we want
    to provide the regular C++ code of our `const_pow_n()` function when it''s used
    with integers and the value of `N` is `2`. We could write a **template specialization**
    for this case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For function templates, we need to fix *all* template parameters when writing
    a specialization. For example, it's not possible to only specify the value of
    `N` and let the type argument `T` be unspecified. However, for class templates,
    it is possible to specify only a subset of the template parameters. This is called
    **partial template specialization**. The compiler will choose the most specific
    template first.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we cannot apply partial template specialization to functions is that
    functions can be overloaded (and classes cannot). If we were allowed to mix overloads
    and partial specialization, it would be very hard to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: How the compiler handles a template function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the compiler handles a template function, it constructs a regular function
    with the template parameters expanded. The following code will make the compiler
    generate regular functions since it utilizes templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, when compiled, as distinguished from regular functions, the compiler
    will generate new functions for every unique set of *template parameters*. This
    means that it is the equivalent of manually creating four different functions
    that look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is important for understanding how metaprogramming works. The template
    code generates non-templated C++ code, which is then executed as regular code.
    If the generated C++ code does not compile, the error will be caught at compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Abbreviated function templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++20 introduced a new abbreviated syntax for writing function templates by
    adopting the same style used by generic lambdas. By using `auto` for function
    parameter types, we are actually creating a function template rather than a regular
    function. Recall our initial `pow_n()` template, which was declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the abbreviated function template syntax, we can instead declare it by
    using `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between these two versions is that the abbreviated version doesn''t
    have an explicit placeholder for the type of the variable `v`. And since we were
    using the placeholder `T` in our implementation, this code will unfortunately
    fail to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To fix this, we can use the `decltype` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving the type of a variable with decltype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `decltype` specifier is used to retrieve the type of a variable and is used
    when an explicit type name is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need an explicit placeholder for a type but none are available,
    only the variable name is. This happened to us in our implementation of the `pow_n()`
    function previously, when using the abbreviated function template syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using `decltype` by fixing our implementation
    of `pow_n()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code compiles and works, we are a bit lucky since the type of
    `v` is actually a `const` reference and not the type we want for the variable
    `product`. We can get around this by using the left-to-right declaration style.
    But trying to rewrite the line where the product is defined to something that
    would appear to be identical reveals a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are getting a compilation error since `product` is a `const` reference
    and may not be assigned to a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really want is to get rid of the `const` reference from the type of
    `v` when defining the variable `product`. We could use a handy template called
    `std::remove_cvref` for this purpose. Our definition of `product` would then look
    like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Phew! In this particular case, it would probably have been easier to stick with
    our initial `template <typename T>` syntax. But now, you have learned how to use
    `std::remove_cvref` together with `decltype`, which is a common pattern when writing
    generic C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C++20, it was common to see `decltype` in the body of generic lambdas.
    However, it is now possible to avoid the rather inconvenient `decltype` by adding
    explicit template parameters to generic lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the definition of the lambda, we are writing `<class T>` in order to get
    an identifier for the type of the argument that can be used inside the body of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: It might take some time to get accustomed to using `decltype` and utilities
    for manipulating types. Maybe `std::remove_cvref` looks a bit mysterious at first.
    It's a template from the `<type_traits>` header, which we will look further into
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing template metaprogramming, you may often find yourself in situations
    where you need information about the types you are dealing with at compile time.
    When writing regular (non-generic) C++ code, we work with concrete types that
    we have complete knowledge about, but this is not the case when writing a template;
    the concrete types are not determined until a template is being instantiated by
    the compiler. Type traits let us extract information about the types our templates
    are dealing with in order to generate efficient and correct C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to extract information about template types, the standard library provides
    a type traits library, which is available in the `<type_traits>` header. All type
    traits are evaluated at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Type trait categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two categories of type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: Type traits that return information about a type as a boolean or an integer
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type traits that return a new type. These type traits are also called metafunctions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first category returns `true` or `false`, depending on the input, and ends
    with `_v` (short for value).
  prefs: []
  type: TYPE_NORMAL
- en: The `_v` postfix was added in C++17\. If your library implementation does not
    provide `_v` postfixes for type traits, then you can use the older version, `std::is_floating_point<float>::value`.
    In other words, remove the `_v` extension and add `::value` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of compile-time type checking using type traits for
    fundamental types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Type traits can also be used on user-defined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second category of type traits returns a new type and ends with `_t` (short
    for type). These type trait transformations (or metafunctions) come in handy when
    dealing with pointers and references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The type trait `std::remove_cvref` that we used earlier is also part of this
    category. It removes the reference part (if any) and the `const` and `volatile`
    qualifiers from a type. `std::remove_cvref` was introduced in C++20\. Before that,
    it was conventional to use `std::decay` for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Using type traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As already mentioned, all type traits are evaluated at compile time. For example,
    this function, which returns `1` if the value is greater than or equal to zero
    and `-1` otherwise, can immediately return `1` for unsigned integers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since type traits are evaluated at compile time, the compiler will generate
    the code shown in the following table when invoked with an unsigned and signed
    integer, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Used with an unsigned integer... | ...generated function: |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Used with a signed integer... | ...generated function: |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.1: Based on the type we pass to sign_func() (in the left column), different
    functions is generated by the compiler (in the right column).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about constant expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with constant expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An expression prefixed with the `constexpr` keyword tells the compiler that
    the expression should be evaluated at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `constexpr` keyword can also be used with functions. In that case, it tells
    the compiler that a certain function is intended to be evaluated at compile time
    if all the conditions allowing for compile-time evaluation are fulfilled. Otherwise,
    it will execute at runtime, like a regular function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `constexpr` function has a few restrictions; it is not allowed to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle local static variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle `thread_local` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call any function, which, in itself, is not a `constexpr` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `constexpr` keyword, writing a compile-time evaluated function is as
    easy as writing a regular function since its parameters are regular parameters
    instead of template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `constexpr` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the result of `sum()` is used in a constant expression and all its parameters
    can be determined at compile time, the compiler will generate the following regular
    C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is then compiled into machine code, as usual. In other words, the compiler
    evaluates a `constexpr` function and generates regular C++ code where the result
    is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we called `sum()` instead and stored the result in a variable that is *not*
    marked with `constexpr`, the compiler *might* (most likely) evaluate `sum()` at
    compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In summary, if a `constexpr` function is invoked from a constant expression
    and all its arguments are constant expressions, it is guaranteed to be evaluated
    at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Constexpr functions in a runtime context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, the summed values (`3`, `4`, `5`) were known to the
    compiler at compile time, but how do `constexpr` functions handle variables whose
    values are not known until runtime? As mentioned in the previous section, `constexpr`
    is an indicator to the compiler that a function, under certain conditions, can
    be evaluated at compile time. If variables with values are unknown until the runtime
    is invoked, they will be evaluated just like regular functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the values of `x`, `y`, and `z` are provided from
    the user at runtime, and therefore, it would be impossible for the compiler to
    calculate the sum at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we didn't intend to use `sum()` during runtime at all, we could prohibit
    such usage by making it an immediate function.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring immediate functions using consteval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `constexpr` function can be called at runtime or compile time. If we want
    to limit the uses of a function so that it''s only invoked at compile time, we
    can do that by using the keyword `consteval` instead of `constexpr`. Let''s assume
    that we want to prohibit all uses of `sum()` at runtime. With C++20, we can do
    that with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A function that is declared using `consteval` is called an **immediate function**
    and can only produce constants. If we want to call `sum()`, we need to call it
    from within a constant expression, or the compilation will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will also complain if we try to use `sum()` with parameters that
    are not known at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the `if` `constexpr` statement next.
  prefs: []
  type: TYPE_NORMAL
- en: The if constexpr statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if constexpr` statement allows template functions to evaluate different
    scopes in the same function at compile time (also called compile-time polymorphism).
    Take a look at the following example, where a function template called `speak()`
    tries to differentiate member functions, depending on the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we compile the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will then generate a `speak()` function, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the compiler will keep the call to the member function, `quack()`,
    which will then fail to compile since `Bear` does not contain a `quack()` member
    function. This happens even though the `quack()` member function will never be
    executed due to the `else if (false)` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the `speak()` function compile, regardless of the type, we
    need to inform the compiler that we'd like to completely ignore the scope if the
    `if` statement is `false`. Conveniently, this is exactly what `if constexpr` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can write the `speak()` function with the ability to handle
    both `Bear` and `Duck`, even though they do not share a common interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When `speak()` is invoked with `Animal == Bear`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler generates the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When `speak()` is invoked with `Animal == Duck`,as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler generates the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If `speak()` is invoked with any other primitive type, such as `Animal == int`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler generates an empty function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike a regular `if` statement, the compiler is now able to generate multiple
    different functions: one using `Bear`, another one using `Duck`, and a last one
    if the type is neither `Bear` nor `Duck`. If we want to make this third case a
    compilation error, we can do that by adding an `else` case with a `static_assert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We will talk more about the usefulness of `static_assert` later.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the way `constexpr` is being used here can be referred
    to as compile-time polymorphism. So, how does it relate to runtime polymorphism?
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with runtime polymorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a side note, if we were to implement the previous example with traditional
    runtime polymorphism, using inheritance and virtual functions to achieve the same
    functionality, the implementation would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The objects have to be accessed using pointers or references, and the type
    is inferred at *runtime*, which results in a performance loss compared with the
    compile-time version, where everything is available when the application executes.
    The following image shows the difference between the two types of polymorphism
    in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Runtime polymorphism is supported by virtual functions whereas
    compile time polymorphism is supported by function/operator overloading and if
    constexpr.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will continue to see how we can use `if constexpr` for something more
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Example of the generic modulus function using if constexpr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example will show you how to use `if constexpr` to distinguish between
    operators and global functions. In C++, the `%` operator is used to get the modulus
    of integers, while `std::fmod()` is used for floating-point types. Say we'd like
    to generalize our codebase and create a generic modulus function called `generic_mod()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to implement `generic_mod()` with a regular `if` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'it would fail if invoked with `T == float` as the compiler would generate the
    following function, which would fail to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Even though the application cannot reach it, the compiler will generate the
    line `return v % n;`, which isn't compliant with `float`. The compiler doesn't
    care that the application cannot reach it—since it cannot generate an assembly
    for it, it will fail to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we will change the `if` statement to an `if constexpr`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the function is invoked with a floating-point type, it will generate
    the following function, where the `v % n` operation is eradicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The runtime `assert()` tells us that we cannot call this function if the second
    argument is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Checking programming errors at compile time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assert statements are a simple but very powerful tool for validating invariants
    and contracts between callers and callees in a codebase, (see *Chapter 2*, *Essential
    C++ Techniques*.) It's possible to check programming errors while executing the
    program using `assert()`. But we should always strive to detect errors as early
    as possible, and if we have a constant expression, we can catch programming errors
    when compiling the program using `static_assert()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using assert to trigger errors at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Review the templated version of `pow_n()`. Let''s say we want to prevent it
    from being called with negative exponents (the `n` value). To prevent this in
    the runtime version, where `n` is a regular argument, we can add a runtime assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the function is called with a negative value for `n`, the program will break
    and inform us where we should start looking for the bug. This is good, but it
    would be even better if we could track this error at compile time rather than
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using static_assert to trigger errors at compile time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we do the same to the template version, we can utilize `static_assert()`.
    The `static_assert()` declaration, unlike a regular assert, will refuse to compile
    if the condition isn''t fulfilled. So, it''s better to break the build than have
    a program break at runtime. In the following example, if the template parameter
    `N` is a negative number, `static_assert()` will prevent the function from compiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In other words, with regular variables, the compiler is only aware of the type
    and has no idea what it contains. With compile-time values, the compiler knows
    both the type and the value. This allows the compiler to calculate other compile-time
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an `int` and assert that it's non-negative, we could (should)
    have used an `unsigned int` instead. We are only using a signed `int` in this
    example to demonstrate the use of `assert()` and `static_assert()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using compile-time asserts is one way to check constraints at compile time.
    It is a simple but very useful tool. The support for compile-time programming
    has seen some very exciting progress over the last few years in C++. Now, we will
    move on to one of the biggest features from C++20 that takes constraints checking
    to a new level.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered quite a few important techniques for writing C++ metaprograms.
    You have seen how templates can generate concrete classes and functions for us
    with excellent support from the type traits library. Furthermore, you have seen
    how the use of `constexpr`, `consteval`, and `if constexpr` can help us move computations
    from runtime to compile time. In that way, we can detect programming errors at
    compile time and write programs with lower runtime costs. This is great, but there
    is still plenty of room for improvement when it comes to writing and consuming
    generic code in C++. Some of the issues that we haven''t addressed yet include:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are too generic. When using a template with some arbitrary type,
    it's hard to know what the requirements of that type are. This makes the templates
    hard to use if we only inspect the template interface. Instead, we have to rely
    on documentation or dig deep into the implementation of a template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type errors are caught late by the compiler. The compiler will eventually check
    the types when compiling the regular C++ code, but the error messages are usually
    hard to interpret. Instead, we would like type errors to be caught in the instantiation
    phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unconstrained template parameters make metaprogramming hard. The code we have
    written so far in this chapter has used unconstrained template parameters, with
    the exception of a few static asserts. This is manageable for small examples,
    but it would be much easier to write and reason about our metaprograms if we could
    have access to more meaningful types, in the same way the type system helps us
    write correct non-generic C++ code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional code generation (compile-time polymorphism) can be performed using
    `if constexpr`, but it quickly becomes hard to read and write at a larger scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you will see in this section, C++ concepts address these issues in an elegant
    and effective way by introducing two new keywords: `concept` and `requires`. Before
    exploring constraints and concepts, we will spend some time considering the shortcomings
    of template metaprogramming without concepts. Then, we will use constraints and
    concepts to strengthen our code.'
  prefs: []
  type: TYPE_NORMAL
- en: An unconstrained version of a Point2D template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we are writing a program that deals with a two-dimensional coordinate
    system. We have a class template that represents a point with `x` and `y` coordinates,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that we need to find the Euclidean distance between two points,
    **p1** and **p2**, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Finding the Euclidean between p1 and p2'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the distance, we implement a free function that takes two points
    and uses the Pythagorean theorem (the actual math is of less importance here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A small test program verifies that we can instantiate the `Point2D` template
    with integers and compute the distance between the two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This code compiles and runs fine and outputs `5` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Generic interfaces and bad error messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before moving on, let''s take a short detour and reflect for a while on the
    function template `dist()`. Let''s imagine that we didn''t have easy access to
    the implementation of `dist()` and only could read the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What can we say about the return type and the types of `p1` and `p2`? Practically
    nothing—because `p1` and `p2` are completely *unconstrained*, the interface of
    `dist()` does not reveal anything for us. This doesn't mean that we can pass anything
    to `dist()`, though, because in the end, the generated regular C++ code has to
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we try to instantiate our `dist()` template with two integers
    instead of `Point2D` objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler will gladly generate a regular C++ function, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The error will be caught later on when the regular C++ code is checked by the
    compiler. Clang generates the following error message when trying to instantiate
    `dist()` with two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This error message refers to the *implementation* of `dist()`, something that
    the caller of the function `dist()` shouldn't need to know about. This is a trivial
    example, but trying to interpret error messages caused by providing wrong types
    to templates from sophisticated template libraries can be a real challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even worse, if we are really unlucky, we get through the entire compilation
    by providing types that don''t make sense at all. In this case, we are instantiating
    a `Point2D` with `const char*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It compiles and runs, but the output is probably not what we would expect.
    We want to catch these sorts of errors earlier on in the process, something we
    can achieve by using constraints and concepts as shown in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Type errors can be caught at instantiation phase using constraints
    and concepts'
  prefs: []
  type: TYPE_NORMAL
- en: Later on, you will see how this code can be made more expressive so that it
    is easier to use correctly and harder to misuse. We will do this by adding concepts
    and constraints to our code. But first, I will provide a quick overview of how
    to define and use concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A syntactic overview of constraints and concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is a short introduction to constraints and concepts. We will not
    cover them completely in this book but I will provide you with enough material
    to be productive.
  prefs: []
  type: TYPE_NORMAL
- en: Defining new concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defining new concepts is straightforward with some help from the type traits
    that you are already familiar with. The following example defines the concept
    `FloatingPoint` using the keyword `concept`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The right-hand side of the assignment expression is where we can specify the
    constraints of the type `T`. It''s also possible to combine multiple constraints
    using `||` (logical OR) and `&&` (logical AND). The following example uses `||`
    to combine floats and integrals into a `Number` concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You will note that, it's possible to build concepts using already defined concepts
    on the right-hand side as well. The standard library contains a `<concepts>` header,
    which defines many useful concepts, such as `std::floating_point` (which we should
    use rather than defining our own).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can use the `requires` keyword to add a set of statements that
    should be added to our concept definition. For example, this is the definition
    of the concept `std::range` from the Ranges library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In short, this concept states that a range is something that we can pass to
    `std::ranges::begin()` and `std::ranges::end()`.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to write more sophisticated `requires` clauses than this, and
    you will see more on that later on.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining types with concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add constraints to template parameter types by using the `requires`
    keyword. The following template can only be instantiated with the parameters of
    integral types by using the concept `std::integral`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the same technique when defining class templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative syntax allows us to write this in a more compact way by replacing
    the `typename` directly with the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This form can also be used with class templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use the abbreviated function template form when defining a function
    template, we can add the concept in front of the `auto` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type can also be constrained by using concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are many ways to specify the same thing. The abbreviated
    form combined with concepts has really made it easy to both read and write constrained
    function templates. Another powerful feature of C++ concepts is the ability to
    overload functions in a clear and expressive way.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall the `generic_mod()` function we implemented earlier using `if constexpr`.
    It looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'By using concepts, we can overload a function template similar to how we would
    have done if we''d written a regular C++ function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: With your new knowledge of constraints and concepts, it's time to go back to
    our example with the `Point2D` template and see how it can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: A constrained version of the Point2D template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to define and use concepts, let's put them to use by writing
    a better version of our templates, `Point2D` and `dist()`. Remember that what
    we're aiming for is a more expressive interface and to have errors caused by irrelevant
    parameter types appear at template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a concept for arithmetic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a concept called `Point` that defines that a point should
    have the member functions `x()` and `y()` return the same type, and that this
    type should support arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This concept can now make the interface of `dist()` much better with explicit
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is starting to look really promising, so let''s just add a constraint
    to our return type as well. Although `Point2D` might be instantiated with an integral
    type, we know that the distance can be a floating-point number. The concept `std::floating_point`
    from the standard library is well suited for this. Here is the final version of
    `dist()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Our interface is now more descriptive, and when we try to instantiate it with
    wrong parameter types, we will get errors during the instantiation phase rather
    than the final compilation phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now do the same to our `Point2D` template to avoid someone accidentally
    instantiating it with types that it wasn''t intended to handle. For example, we
    would like to prevent someone from instantiating a `Point2D` class with `const
    char*`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already created the `Arithmetic` concept, which we can use here to
    put constraints in the template parameter of `Point2D`. Here is how we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we needed to change was to specify that the type `T` should support
    the operations specified by the concept `Arithmetic`. Trying to instantiate a
    template using `const char*` will now generate a direct error message while the
    compiler tries to instantiate a `Point2D<const char*>` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints to your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The usefulness of concepts reaches far beyond template metaprogramming. It's
    a fundamental feature of C++20 that changes how we write and reason about code
    using concepts other than concrete types or completely unconstrained variables
    declared with `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: A concept is very similar to a type (such as `int`, `float`, or `Plot2D<int>`).
    Both types and concepts specify a set of supported operations on an object. By
    inspecting a type or a concept, we can determine how certain objects can be constructed,
    moved, compared, and accessed by member functions and so on. A big difference,
    though, is that a concept does not say anything about how an object is stored
    in memory, whereas a type provides this information in addition to its set of
    supported operations. For example, we can use the `sizeof` operator on a type
    but not on a concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'With concepts and `auto`, we can declare variables without the need for spelling
    out the exact type, but still express the intent with our code very clearly. Have
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, when we stumble upon code like this, we are interested in
    knowing what operations we can perform on `v` rather than knowing the exact type.
    Adding a concept in front of `auto` makes the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to use concepts in almost all contexts where we can use the
    keyword `auto`: local variables, return values, function arguments, and so forth.
    Using concepts in our code makes it easier to read. At the time of writing this
    book (mid 2020), there is currently no additional support for concepts in the
    established C++ IDEs. However, it is just a matter of time before code completion,
    as well as other useful editor features based on concepts, will be available and
    make C++ coding both more fun and safer.'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in the standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++20 also included a new `<concepts>` header with predefined concepts. You
    have already seen some of them in action. Many concepts are based on the traits
    from the type traits library. However, there are a few fundamental concepts that
    have not been expressed with traits previously. Among the most important ones
    are the comparison concepts such as `std::equality_comparable` and `std::totally_ordered`,
    as well as the object concepts such as `std::movable`, `std::copyable`, `std::regular`,
    and `std::semiregular`. We will not spend any more time on the concepts from the
    standard library but remember to keep them in mind before starting to define your
    own. Defining concepts on the correct level of generality is not trivial and it's
    usually wise to define new concepts based on the already existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Let's end this chapter by having a look at some real-world examples of metaprogramming
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples of metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced metaprogramming can appear to be very academic, so in order to demonstrate
    its usefulness, let's look at some examples that not only demonstrate the syntax
    of metaprogramming, but how it can be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: creating a generic safe cast function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When casting between data types in C++, there is a multitude of different ways
    things can go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: You might lose a value if casting to an integer type of a lower bit length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might lose a value if casting a negative value to an unsigned integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If casting from a pointer to any other integer than `uintptr_t`, the correct
    address might become incorrect. This is because C++ only guarantees that `uintptr_t`
    is the only integer type that can withhold an address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If casting from `double` to `float`, the result might be `int` if the `double`
    value is too large for `float` to withhold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If casting between pointers with a `static_cast()`, we might get undefined behavior
    if the types aren't sharing a common base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to make our code more robust, we can create a generic checked cast
    function that verifies our casts in debug mode and performs our casts as fast
    as possible if in release mode.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the types that are being cast, different checks are performed.
    If we try to cast between types that are not verified, it won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the cases `safe_cast()` is intended to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Same type**: Obviously, if we''re casting the same type, we just return the
    input value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointer to pointer**: If casting between pointers, `safe_cast()` performs
    a dynamic cast in debug mode to verify it is castable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double to floating point**: `safe_cast()` accepts precision loss when casting
    from `double` to `float` with one exception – if casting from a `double` to a
    `float`, there is a chance the double is too large for the float to handle the
    result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arithmetic to arithmetic**: If casting between arithmetic types, the value
    is cast back to its original type to verify no precision has been lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointer to non-pointer**: If casting from a pointer to a non-pointer type,
    `safe_cast()` verifies that the destination type is an `uintptr_t` or `intptr_t`,
    the only integer types that are guaranteed to hold an address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any other case, the `safe_cast()` function fails to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can implement this. We start by fetching information about
    our cast operation in `constexpr` booleans. The reason they are `constexpr` booleans
    and not `const` booleans is that we will utilize them later in `if constexpr`
    expressions, which require `constexpr` conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have all the necessary information about the cast as `constexpr`
    booleans, we assert at compile time that we can perform the cast. As mentioned
    previously, a `static_assert()` will fail to compile if the condition is not satisfied
    (unlike a regular assert, which verifies conditions at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: Note the usage of `static_assert()` and `make_false<T>` at the end of the `if`/`else`
    chain. We cannot just type `static_assert(false)` as that would prevent `safe_cast()`
    from compiling at all; instead, we utilize the template function `make_false<T>()`
    to delay the generation until required.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the actual `static_cast()` is performed, we cast back to the original
    type and verify that the result is equal to the uncasted argument using a regular
    runtime `assert()` This way, we can make sure the `static_cast()` has not lost
    any data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we use the `if constexpr` in order for the function to conditionally
    compile. If we use a regular `if` statement, the function will fail to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the compiler will try to compile the following line and `dynamic_cast`
    only accepts pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'However, thanks to the `if constexpr` and `safe_cast<int>(42.0f)` constructs,
    the following function compiles properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, except for the `is_number_to_number` clause, everything in-between
    the `if constexpr` statements has been completely eradicated, allowing the function
    to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: hash strings at compile time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have a resource system consisting of an unordered map of strings
    that identifies bitmaps. If a bitmap is already loaded, the system returns the
    loaded bitmap; otherwise, it loads the bitmap and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The bitmap cache is then utilized wherever a bitmap resource is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: If it's not loaded yet, the `get_bitmap_resource()` function will load and return
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's already been loaded somewhere else, the `get_bitmap_resource()` will
    simply return the loaded function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, independent of which of these draw functions is executed first, the second
    one will not have to load the bitmap from disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using an unordered map, we need to compute a hash value whenever
    we check for a bitmap resource. You will now see how we can optimize the runtime
    code by moving computations to compile time.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of the compile-time hash sum calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem that we will try to solve is that every time the line `get_bitmap_resource("my_bitmap.png")`
    is executed, the application will compute the hash sum of the string `"my_bitmap.png"`
    at runtime. What we would like to do is perform this calculation at compile time
    so that when the application executes, the hash sum has already been calculated.
    In other words, just as you have learned to use metaprogramming to generate functions
    and classes at compile time, we will now have it generate the hash sum at compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have already come to the conclusion that this is a so-called *micro-optimization*:
    calculating the hash sum of a small string won''t affect the application''s performance
    at all as it is such a tiny operation. That is probably completely true; this
    is just an example of how to move a calculation from runtime to compile time,
    and there might be other instances where this can make a significant performance
    impact.'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, when writing software for weak hardware, string hashing is a
    pure luxury, but hashing strings at compile time gives us this luxury on any platform
    since everything is computed at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and verifying a compile-time hash function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to enable the compiler to calculate the hash sum at compile time,
    we rewrite `hash_function()` so that it takes a raw null-terminated `char` string
    as a parameter of an advanced class like `std::string`, which cannot be evaluated
    at compile time. Now, we can mark `hash_function()` as `constexpr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s invoke this with a raw literal string known at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will generate the following piece of code, which is the sum of
    the ASCII values corresponding to `a`, `b`, and `c` (`97`, `98`, and `99`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Just accumulating the individual values is a very bad hash function; do not
    do this in a real-world application. It's only here because it's easy to grasp.
    A better hash function would be to combine all the individual characters with
    `boost::hash_combine()`, as explained in *Chapter 4*, *Data Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: '`hash_function()` will only evaluate at compile time if the compiler knows
    the string at compile time; if not, the compiler will execute `constexpr` at runtime,
    just like any other expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the hash function in place, it's time to create a string class
    that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a PrehashedString class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now ready to implement a class for pre-hashed strings that will use
    the hash function we created. This class consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor that takes a raw string as a parameter and calculates the hash
    at construction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `get_hash()` member function, which returns the hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overload of `std::hash()`, which simply returns the hash value. This overload
    is used by `std::unordered_map`, `std::unordered_set`, or any other class from
    the standard library that uses hash values. To put it simply, this makes the container
    aware that a hash function exists for the `PrehashedString`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a basic implementation of a `PrehashedString` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the template trick in the constructor. This forces the `PrehashedString`
    to only accept compile-time string literals. The reason for this is that the `PrehashedString`
    class does not own the `const char* ptr` and therefore we may only use it with
    string literals created at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have everything in place, let's see how the compiler handles
    `PrehashedString`.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating PrehashedString
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a simple test function that returns the hash value for the string `"abc"`
    (used for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our hash function simply sums the values, and the letters in `"abc"`
    have ASCII values of *a* = 97, *b* = 98, and *c* = 99, the assembler (generated
    by Clang) should output the sum 97 + 98 + 99 = 294 somewhere. Inspecting the assembler,
    we can see that the `test_prehashed_string()` function compiles to exactly one
    `return` statement, which returns `294`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This means that the whole `test_prehashed_string()` function has been executed
    at compile time; when the application executes, the hash sum has already been
    calculated!
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating get_bitmap_resource() with PrehashedString
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s return to our original `get_bitmap_resource()` function, the `std::string`,
    which was originally used and exchanged for a `PrehashedString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a function to test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: What we would like to know is whether this function precalculated the hash sum.
    Since `get_bitmap_resource()` does quite a lot (constructing a static `std::unordered_map`,
    inspecting the map, and so on), the resulting assembly is about 500 lines. Nevertheless,
    if our magic hash sum is found in the assembler, this means that we have succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'When inspecting the assembler generated by Clang, we will find a line that
    corresponds to our hash sum, `294`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: To confirm this, we will change the string from `"abc"` to `"aaa"`, which should
    change this line in the assembler to 97 * 3 = 291, but everything else should
    be exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: We're doing this to make sure this wasn't just some other magic number that
    popped up, totally unrelated to the hash sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the resulting assembler, we will find the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Everything, except this line, is the same, so we can safely assume that the
    hash is calculated at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: The examples we have looked at demonstrate that we can use compile-time programming
    for very different things. Adding safety checks that can be verified at compile
    time allows us to find bugs without running the program and searching for errors
    with coverage tests. And moving expensive runtime operations to compile time makes
    our final program faster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to use metaprogramming to generate functions
    and values at compile time instead of runtime. You also discovered how to do this
    in a modern C++ way by using templates, the `constexpr`, `static_assert()`, and
    `if constexpr`, type traits, and concepts. Moreover, with constant string hashing,
    you saw how to use compile-time evaluation in a practical context.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to further expand your C++ toolbox so
    that you can create libraries by constructing hidden proxy objects.
  prefs: []
  type: TYPE_NORMAL
