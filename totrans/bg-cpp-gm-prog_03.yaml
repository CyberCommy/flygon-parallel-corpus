- en: Chapter 3. C++ Strings, SFML Time, Player Input, and HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will spend around half the time learning how to manipulate
    text and display it on the screen, and the other half looking at timing and how
    a visual time bar can create a sense of urgency in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and restarting the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFML Text and SFML font classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a HUD to Timber!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a time bar to Timber!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing and restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress with this game over the next three chapters, the code will obviously
    get longer and longer. So, now it seems like a good time to think ahead and add
    a little bit more structure into our code. We will add this structure to give
    us the ability to pause and restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: We will add code so that when the game is first run, it will be paused. The
    player will be able to press the ***Enter*** key to get the game started. Then
    the game will run until either the player gets squished or runs out of time. At
    this point the game will pause and wait for the player to press ***Enter*** key,
    to restart again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s step through setting this up a bit at a time. First, declare a new `bool`
    variable called `paused`, outside the main game loop, and initialize it to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the game is run we have a variable, `paused`, that will be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add another `if` statement where the expression will check to
    see whether the ***Enter*** key is currently being pressed. If it is being pressed
    it sets `paused` to `false`. Add the highlighted code just after our other keyboard-handling
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `bool` called `paused`, which starts off `true` but changes to
    `false` when the player presses the ***Enter*** key. At this point, we have to
    make our game loop respond appropriately, based on whatever the current value
    of `paused` might be.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we will proceed. We will wrap the entire, update part of the code,
    including the code we wrote in the last chapter to move the bee and clouds, in
    an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, in the next code, the `if` block will only execute when `paused`
    is not equal to `true`. Or to put it another way, the game won't move/update when
    it is paused.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what we want. Look carefully at the exact place to add the new
    `if` statement and its corresponding opening and closing curly braces `{...}`.
    If they are put in the wrong place, things will not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code to wrap the update part of the code, paying close
    attention to the context shown next. I have added `...` on a few lines to represent
    hidden code. Obviously the `...` is not real code and should not be added to the
    game. You can identify where to place the new code (highlighted), at the start
    and the end, by the un-highlighted code surrounding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, when you place the closing curly brace of the new `if` block, Visual
    Studio neatly adjusts all the indenting, to keep the code tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can run the game and everything will be static until you press the ***Enter***
    key. It is now possible to go about adding features to our game and we just need
    to remember when the player dies or runs out of time, we need to set `paused`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter we had a first glimpse of C++ strings. We need to learn
    a bit more about them so we can implement the player's HUD.
  prefs: []
  type: TYPE_NORMAL
- en: C++ strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we briefly mentioned strings and we learned that a string
    can hold alphanumeric data in anything from a single character to a whole book.
    We didn't look at declaring, initializing, or manipulating strings. So let's do
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declaring a string variable is simple. We state the type, followed by the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once we have declared a string we can assign a value to it.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a value to strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To assign a value to a string, as with regular variables, we simply put the
    name, followed by the assignment operator, then the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the values need to be enclosed in quotation marks. As with regular
    variables we can also declare and assign values in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can change our string variables.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `#include <sstream>` directive to give us some extra power with
    our strings. The `sstream` class enables us to add some strings together. When
    we do so it is called **concatenation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to using `sstream` objects, a string variable can even be concatenated
    with a variable of a different type. This next code starts to reveal how strings
    might be quite useful to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `<<` operator is a bitwise operator. C++ however, allows you to write your
    own classes and override what a specific operator does, within the context of
    your class. The `sstream` class has done this to make the `<<` operator work the
    way it does. The complexity is hidden in the class. We can use its functionality
    without worrying about how it works. If you are feeling adventurous you can read
    about operator overloading at: [http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm).
    You don''t need any more information in order to continue with the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know the basics of C++ strings, and how we can use `sstream`, we can
    see how to use some SFML classes to display them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: SFML Text and Font
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's briefly discuss the `Text` and `Font` classes with some hypothetical code,
    before we actually go ahead and add code to our game.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to drawing text on the screen is to have a font. In the first
    chapter we added a font file to the project folder. Now we can load the font,
    ready for use, into an SFML `Font` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to do so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code we first declare the `Font` object and then load an actual
    font file. Note that `myfont.ttf` is a hypothetical font and we could use any
    font that is in the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have loaded a font we need an SFML `Text` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can configure our `Text` object. This includes the size, the color,
    the position on screen, the string that holds the message, and, of course, associating
    it with our `font` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a HUD to Timber!!!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a score and a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know enough about strings, SFML `Text`, and SFML `Font` to go about implementing
    the HUD.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to do is to add another `#include` directive to the top
    of the code file. As we have learned, the `sstream` class adds some really useful
    functionality for combining strings, and other variable types, together into a
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next we will set up our SFML `Text` objects. One will hold a message that we
    will vary to suit the state of the game, and the other will hold the score and
    needs to be regularly updated.
  prefs: []
  type: TYPE_NORMAL
- en: The next code that declares the `Text` and `Font` objects loads the font, assigns
    the font to the `Text` objects, and then adds the string messages, color, and
    size. This should look familiar from our discussion in the previous section. In
    addition, we add a new `int` variable called `score` which we can manipulate to
    hold the player's score.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that if you chose a different font from `KOMIKAP_.ttf`, back in [Chapter
    1](ch01.html "Chapter 1. C++, SFML, Visual Studio, and Starting the First Game"):
    C*++, SFML, Visual Studio, and Starting the First Game*, you will need to change
    that part of the code to match the `.ttf` file that you have in the `Visual Studio
    Stuff/Projects/Timber/Timber/fonts` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code and we will be ready to move on to updating the HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code might look a little convoluted, even complex. It is, however,
    really straightforward when you break it down a bit. Examine and add the new code,
    then we will go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have two objects of the type `Text` that we will display on the screen. We
    want to position `scoreText` on the top left with a little bit of padding. This
    is not a challenge; we simply use `scoreText.setPosition(20, 20)` and that positions
    it in the top left with 20 pixels of horizontal and vertical padding.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning `messageText`, however, was not so easy. We want to position it
    in the exact center of the screen. Initially this might not seem like a problem,
    but then we remember that the origin of everything we draw is the top left-hand
    corner. So, if we simply divide the screen width and height by two and use the
    results in `mesageText.setPosition...`, then the top left of the text will be
    in the center of the screen and it will spread out untidily to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a way to be able to set the center of `messageText` to the
    center of the screen. The rather nasty looking bit of code that you just added
    repositions the origin of `messageText` to the center of itself. Here is the code
    under current discussion again for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, in this code, we declare a new object of type `FloatRect`, called `textRect`.
    A `FloatRect` object, as the name suggests, holds a rectangle with floating point
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The code then uses the `messageText.getLocalBounds` function to initialize `textRect`
    with the coordinates of the rectangle that wraps `messageText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line of code, spread over four lines as it is quite long, uses the
    `messageText.setOrigin` function to change the origin (the point at which we draw)
    to the center of `textRect`. Of course, `textRect` holds a rectangle, which exactly
    matches the coordinates that wrap `messageText`. Then, this next line of code
    executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, `messageText` will be neatly positioned in the exact center of the screen.
    We will use this exact same code each time we change the text of `messageText`,
    because changing the message changes the size of `messageText`, so its origin
    will need recalculating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we declare an object of type `stringstream` called `ss`. Note that we
    use the full name including the namespace `std::stringstream`. We could avoid
    this syntax by adding `using namespace std` to the top of our code file. We don''t,
    however, because we use it infrequently. Take a look at the code and add it to
    the game, then we can go through it in more detail. As we only want this code
    to execute when the game is not paused, be sure to add it with the other code,
    inside the `if(!paused)` block, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use `ss` and the special functionality provided by the `<<` operator, which
    concatenates variables into a `stringstream`. So the code, `ss << "Score = " <<
    score`, has the effect of creating a string with `"Score = "` and whatever the
    value of `score` is, it is concatenated together. For example, when the game first
    starts, `score` is equal to zero, so `ss` will hold the value `"Score = 0"`. If
    `score` ever changes, `ss` will adapt each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code simply displays/sets the string contained in `ss` to `scoreText`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is now ready to be drawn onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This next code draws both `Text` objects (`scoreText` and `messageText`), but
    notice that the code that draws `messageText` is wrapped in an `if` statement.
    This `if` statement causes `messageText` only to be drawn when the game is paused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now run the game and see our HUD drawn on the screen. You will see the
    **SCORE = 0** and PRESS ENTER TO START! messages. The latter will disappear when
    you press ***Enter*** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a score and a message](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to see the score updating, add a temporary line of code, `score
    ++;` anywhere in the `while(window.isOpen)` loop. If you add this temporary line
    you will see the score go up fast, very fast!
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a score and a message](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you added the temporary code `score ++;`, be sure to delete it before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a time bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As time is a crucial mechanic in the game, it is necessary to keep the player
    aware of it. He needs to know if his allotted six seconds are about to run out.
    It will give him a sense of urgency as the end of the game draws near, and a sense
    of accomplishment if he performs well enough to maintain or increase his remaining
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the number of seconds remaining on the screen is not easy to read (when
    concentrating on the branches) or a particularly interesting way to achieve the
    objective.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a time bar. Our time bar will be a simple red rectangle, prominently
    displayed on the screen. It will start off nice and wide, but rapidly shrink as
    time runs out. When the player's remaining time reaches zero, the time bar will
    be gone completely.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time as adding the time bar, we will add the necessary code to keep
    track of the player's remaining time, as well as to respond when he runs out.
    Let's go through it a step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `Clock clock;` declaration from earlier and add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First we declare an object of the type `RectangleShape` and call it `timeBar`.
    `RectangleShape` is an SFML class that is perfect for drawing simple rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Next we add a few `float` variables, `timeBarStartWidth` and `timeBarHeight`.
    We initialize them to `400` and `80` respectively. These variables will help us
    keep track of the size we need to draw the `timeBar` each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set the size of the `timeBar` using the `timeBar.setSize` function.
    We don't just pass in our two new `float` variables. First we create a new object
    of type `Vector2f`. What is different here, however, is that we don't give the
    new object a name. We simply initialize it with our two float variables and it
    is passed straight in to the `setSize` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Vector2f` is a class which holds two `float` variables. It also has some other
    functionality that will be introduced throughout the book.'
  prefs: []
  type: TYPE_NORMAL
- en: After that we color the `timeBar` red by using the `setFillColor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we do to the `timeBar,` in the previous code, is to set its
    position. The y coordinate is completely straightforward, but the way we set the
    x coordinate is slightly convoluted. Here is the calculation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code first divides `1920` by `2`. Then it divides `timeBarStartWidth` by
    `2`. Finally it subtracts the latter from the former.
  prefs: []
  type: TYPE_NORMAL
- en: The result makes the `timeBar` sit nice and horizontally centered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The final three lines of code that we are talking about declare a new `Time`
    object called `gameTimeTotal`, a new `float` called `timeRemaining` that is initialized
    to `6`, and a curious-sounding `float` named `timeBarWidthPerSecond` which we
    will discuss further.
  prefs: []
  type: TYPE_NORMAL
- en: The `timeBarWidthPerSecond` variable is initialized with `timeBarStartWidth`
    divided by `timeRemaining`. The result is exactly the amount of pixels that the
    `timeBar` needs to shrink by, each second of the game. This will be useful when
    we resize the `timeBar` in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously we need to reset the time remaining each time the player starts a
    new game. The logical place to do this is the ***Enter*** key press. We can also
    set the `score` back to zero at the same time. Let''s do that now by adding this
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each frame we must reduce the amount of time remaining and resize the
    `timeBar` accordingly. Add the following highlighted code in the update section
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'First we subtracted the amount of time the player has left by however long
    the previous frame took to execute with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we adjusted the size of the `timeBar` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The x value of the `Vector2F` is initialized with `timebarWidthPerSecond` multiplied
    by `timeRemaining`. This produces exactly the correct width, relative to how long
    the player has left. The height remains the same and `timeBarHeight` is used without
    any manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, we must detect when time has run out. For now, we will simply
    detect that time has run out, pause the game, and change the text of the `messageText`.
    Later we will do more work here. Add the highlighted code right after the previous
    code we added, and we will look at it in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Stepping through the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: First we test whether time has run out with `if(timeRemaining <= 0.0f)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we set `paused` to `true` so this will be the last time the update part
    of our code is executed (until the player presses ***Enter*** again).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we change the message of `messageText`, calculate its new center to set
    it as its origin, and position it in the center of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, for this part of the code, we need to draw the `timeBar`. There is
    nothing new in this code that we haven''t seen many times before. Just note that
    we draw the `timeBar` after the tree, so it is visible. Add the highlighted code
    to draw the time bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run the game. Press ***Enter*** to start, and watch the time bar
    smoothly disappear down to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a time bar](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The game then pauses and the **OUT OF TIME!!** message will appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a time bar](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can, of course, press ***Enter*** again to start the whole thing running
    from the start.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I can foresee that positioning sprites by their top left corner could sometimes
    be inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: A) Fortunately, you can choose what point of a sprite is used as the positioning/origin
    pixel, just as we did with `messageText`, using the `setOrigin` function.
  prefs: []
  type: TYPE_NORMAL
- en: Q) The code is getting rather long and I am struggling to keep track of where
    everything is.
  prefs: []
  type: TYPE_NORMAL
- en: A) Yes, I agree. In the next chapter we will look at the first of a few ways
    we can organize our code and make it more readable. We will see this when we learn
    about writing C++ functions. In addition, we will learn a new way for handling
    multiple objects/variables of the same type (such as the clouds), when we learn
    about C++ arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learnt about strings, SFML `Text`, and SFML `Font`. Between
    them they enabled us to draw text to the screen, which provided the player with
    a HUD. We also used `sstream,` which allows us to concatenate strings and other
    variables to display the score.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the SFML `RectangleShape` class, which does exactly what its name
    suggests. We used an object of the type `RectangleShape,` and some carefully planned
    variables, to draw a time bar that visually displays how much time a player has
    left. Once we have implemented chopping, and moving branches that can squash the
    player, the time bar will create tension and urgency.
  prefs: []
  type: TYPE_NORMAL
- en: Next we are going to learn about a whole range of new C++ features, including
    loops, arrays, switching, enumerations, and functions. This will enable us to
    move the tree branches, keep track of their locations, and squash the player.
  prefs: []
  type: TYPE_NORMAL
