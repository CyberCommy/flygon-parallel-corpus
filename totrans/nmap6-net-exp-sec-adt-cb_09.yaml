- en: Chapter 9. Writing Your Own NSE Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter shows you how to do some things that in many situations might be
    illegal, unethical, a violation of the terms of service, or just not a good idea.
    It is provided here to give you information that may be of use to protect yourself
    against threats and make your own system more secure. Before following these instructions,
    be sure you are on the right side of the legal and ethical line... use your powers
    for good!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to identify vulnerable Trendnet webcams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending UDP payloads by using NSE sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting a path traversal vulnerability with NSE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a brute force script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the web crawling library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting vulnerabilities correctly in NSE scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own NSE library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with NSE threads, condition variables, and mutexes in NSE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine was introduced in 2007 in Version 4.5, in order to
    extend Nmap's functionality to a whole new level by using the information gathered
    during a port or a network scan and performing additional tasks powered by the
    powerful scripting language **Lua**. This feature has become a whole arsenal by
    itself with almost 300 scripts already officially included. The amount of tasks
    you can accomplish with this feature is impressive, as you have learned throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Lua is a scripting language currently used in other important projects, such
    as World of Warcraft, Wireshark, and Snort, for very good reasons. Lua is very
    lightweight and extensible. As an NSE developer, my experience with Lua has been
    very positive. The language is very powerful and flexible, yet with a clear and
    easy-to-learn syntax. Because Lua is a whole topic by itself, I will not be able
    to focus on all of its great features, but I recommend that you read the official
    reference manual at [http://www.lua.org/manual/5.2/](http://www.lua.org/manual/5.2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each NSE script receives two arguments: a host and a port table. They contain
    the information collected during the discovery or port scan. Some information
    fields are populated only if certain flags are set. Some of the fields in the
    host table are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host.os`: Table with array of OS matches (needs flag `-O`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host.ip`: Target IP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host.name`: Returns the reverse DNS entry if available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the complete list of fields, visit [http://nmap.org/book/nse-api.html#nse-api-arguments](http://nmap.org/book/nse-api.html#nse-api-arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the port table contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`port.number`: Port number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port.protocol`: Port protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port.service`: Service name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port.version`: Service version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port.state`: Port state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of flexibility and information provided by the Nmap Scripting
    Engine allows penetration testers and system administrators to save a lot of development
    time when writing scripts to automate tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The community behind Nmap is amazing and very collaborative. I can say they
    are some of the most passionate people in the open source community. New scripts
    and libraries are added every week, and this has become the very same reason why
    penetration testers need to keep the latest development snapshot under their arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: In honor of David Fifield and Fyodor's talk introducing the Nmap Scripting Engine
    in Defcon 2010 where they wrote a script to detect vulnerable httpd webcams, we
    will start by writing our own NSE script to detect Trendnet cameras.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you will also learn how to write NSE scripts that perform brute
    force password auditing, and will use the new HTTP crawler library to automate
    security checks. We will talk about scripts that handle NSE sockets and raw packets
    to exploit vulnerabilities. We will cover some of the NSE libraries that allow
    us to make HTTP requests, manage found credentials, and report vulnerabilities
    to the users.
  prefs: []
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine evolves fast and grows even faster. Due to limited
    space it is impossible to cover all of the great NSE scripts and libraries that
    this project already has, but I invite you to visit the official book website
    [http://nmap-cookbook.com](http://nmap-cookbook.com) for additional recipes and
    script examples that I will be posting in the future.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that after reading the recipes I have picked for you, you will learn
    all of the necessary tools to take on more challenging tasks. Make debugging mode
    your friend (`-d[1-9]`) and of course, don't forget to contribute to this amazing
    project by sending your scripts or patches to `<[nmap-dev@insecure.org](mailto:nmap-dev@insecure.org)>`.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time that you are writing a script for NSE, I recommend
    that you download and study the overall structure and necessary fields of a script.
    I uploaded the template that I have used to [https://github.com/cldrn/nmap-nse-scripts/blob/master/nse-script-template.nse](https://github.com/cldrn/nmap-nse-scripts/blob/master/nse-script-template.nse).
  prefs: []
  type: TYPE_NORMAL
- en: Ron Bowes also wrote a very detailed template for NSE scripts at [http://nmap.org/svn/docs/sample-script.nse](http://nmap.org/svn/docs/sample-script.nse).
  prefs: []
  type: TYPE_NORMAL
- en: The complete documentation for the NSE script format can be found online at
    [http://nmap.org/book/nse-script-format.html](http://nmap.org/book/nse-script-format.html).
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to identify vulnerable Trendnet webcams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine offers a library to handle requests and other common
    functions of an HTTP client. With this library, NSE developers can accomplish
    many tasks, from information gathering to vulnerability exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to use the HTTP library to send an HTTP request
    to identify vulnerable Trendnet TV-IP110W webcams.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Trendnet TV-IP110W webcams allow unauthenticated access to their video feed
    by simply requesting the URI `/anony/mjpg.cgi`. Let''s write an NSE script to
    detect these devices. For now, let''s ignore the documentation tags:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `http-trendnet-tvip110w.nse` and start by filling up the NSE
    script basic information fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We load the libraries that we are going to need. Note that this format corresponds
    to Nmap 6.x:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We define our execution rule. We use the alias `shortport.http` to tell Nmap
    to execute the script when a web server is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main function will identify the type of 404 responses and determine if
    the webcam is vulnerable to unauthorized access by sending the HTTP request to
    `/anony/mjpg.cgi` and checking for status code 200:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now just run the NSE script against your target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find a vulnerable webcam you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The complete script with documentation tags can be downloaded from [https://github.com/cldrn/nmap-nse-scripts/blob/master/scripts/6.x/http-trendnet-tvip110w.nse](https://github.com/cldrn/nmap-nse-scripts/blob/master/scripts/6.x/http-trendnet-tvip110w.nse).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the script `http-trendnet-tvip110w.nse`, we defined the execution rule with
    the alias `http` from the `shortport` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The alias `shortport.http` is defined in the file `/nselib/shortport.lua` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `http` library has methods such as `http.head()`, `http.get()`, and `http.post()`
    corresponding to the common HTTP methods `HEAD`, `GET`, and `POST` respectively,
    but it also has a generic method named `http.generic_request()` to allow more
    flexibility to developers who may want to try more obscure HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script `http-trendnet-tvip110w`, we used the function `http.head()`
    to retrieve the URI `/anony/mjpg.cgi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `http.head()` returns a table containing the following response
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status-line`: Contains the returned status line. For example, `HTTP/1.1 404
    Not Found`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: Contains the status code returned by the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: Contains the response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookies`: Table of cookies set by the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header`: Associative table where the returned headers are stored. The name
    of the header is used as an index. For example, `header["server"]` contains the
    Server field returned by the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rawheader`: Numbered array of headers in the same order as they were sent
    by the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The library `stdnse` is also used in the script `http-trendnet-tvip110w.nse`.
    This library is a collection of miscellaneous functions that come in handy when
    writing NSE scripts. The script used the function `stdnse.print_debug()`, a function
    to print debugging messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete documentation for these libraries can be found at [http://nmap.org/nsedoc/lib/http.html](http://nmap.org/nsedoc/lib/http.html)
    and [http://nmap.org/nsedoc/lib/stdnse.html](http://nmap.org/nsedoc/lib/stdnse.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some web servers do not return regular status 404 code responses when a page
    does not exist, and instead return status code 200 all the time. This is an aspect
    that is often overlooked and even I have made the mistake before of assuming that
    a status of 200 meant that the URI exists. We need to be careful with this to
    avoid false positives in our scripts. The functions `http.identify_404()` and
    `http.page_exists()` were created to identify if a server returns regular 404
    responses and if a given page exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function `http.identify_404(host, port)` was successful, we can use
    `http.page_exists()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Debugging Nmap scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Setting the user agent pragmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some packet filtering products that block requests using Nmap''s
    default HTTP user agent. You can use a different user agent value by setting the
    argument `http.useragent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the user agent in your NSE script, you can pass the header field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: HTTP pipelining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some web server's configuration supports encapsulation of more than one HTTP
    request in a single packet. This may speed up the execution of an NSE HTTP script
    and it is recommended that you use it if the web server supports it. The `http`
    library, by default, tries to pipeline 40 requests and automatically adjusts that
    number according to the network conditions and the `Keep-Alive` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users will need to set the script argument `http.pipeline` to adjust this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement HTTP pipelining in your NSE scripts, use the functions `http.pipeline_add()`
    and `http.pipeline()`. First, initiate a variable that will hold the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add requests to the pipeline with `http.pipeline_add()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are done adding requests, execute the pipe with `http.pipeline()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable results will contain the number of response objects added to the
    HTTP request queue. To access them, you can simply iterate through the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing your own NSE library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Listing supported HTTP methods* recipe in [Chapter 4](ch04.html "Chapter 4. Auditing
    Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Checking if an HTTP proxy is open* recipe in [Chapter 4](ch04.html "Chapter 4. Auditing
    Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Detecting web application firewalls* recipe in [Chapter 4](ch04.html "Chapter 4. Auditing
    Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Detecting possible XST vulnerabilities* recipe in [Chapter 4](ch04.html
    "Chapter 4. Auditing Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending UDP payloads by using NSE sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine offers a robust library for handling networking I/O
    operations by providing an interface to **Nsock**. Nsock is Nmap's optimized parallel
    sockets library, and its flexibility allows developers to handle raw packets and
    decide whether to use blocking or non-blocking network I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will go through the process of writing an NSE script that reads
    a payload from a file and sends a UDP packet to exploit a vulnerability in Huawei
    HG5xx routers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Huawei HG5xx routers reveal sensitive information when they receive a special
    packet to UDP port 43690\. This vulnerability caught my attention because this
    is a very popular device, works remotely, and obtains interesting information
    such as the PPPoE credentials, MAC address, and exact software/firmware version.
    Let''s write a script to exploit these devices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, create the file `huawei-hg5xx-udpinfo.nse` and define the information
    tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the required libraries (Nmap 6.x format):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the execution rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function to load the UDP payload from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that creates an NSE socket and sends the special UDP packet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the main method, which will load and send the UDP payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You may run the final script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A vulnerable device will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our script `huawei-hg5xx-udpinfo` defined the execution rule with the alias
    `shortport.portnumber(ports, protos, states)`. Our script will run if UDP port
    43690 is either `open`, `open|filtered` or `filtered`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read NSE arguments in a few different ways, but the recommended function
    is `stdnse.get_script_args()`. This allows multiple assignments and supports shorthand
    assignment (you don''t have to type the script name before the argument name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'NSE sockets are managed by the `nmap` library. To create an NSE socket, use
    the function `nmap.new_socket()` and to connect to this socket, use `connect()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We send our UDP payload as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the response from the NSE socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we need to close the sockets when we are done by using the function
    `close()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can process the received data. In this case I will replace the null
    characters for an output that is easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can download the complete script from [https://github.com/cldrn/nmap-nse-scripts/blob/master/scripts/6.x/huawei5xx-udp-info.nse](https://github.com/cldrn/nmap-nse-scripts/blob/master/scripts/6.x/huawei5xx-udp-info.nse).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script `huawei-hg5xx-udpinfo` uses a standard connect-style in which a socket
    is created, the connection is established, data is sent and/or received, and the
    connection is closed.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more control, the `nmap` library also supports reading and writing
    raw packets. The scripting engine uses a `libpcap` wrapper through Nsock to read
    raw packets, and can send them at either the Ethernet or IP layer.
  prefs: []
  type: TYPE_NORMAL
- en: When reading raw packets you will need to open the capture device and register
    a listener that will process the packets as they arrive. The functions `pcap_open()`,
    `pcap_receive()`, and `pcap_close()` correspond to opening a capture device, receiving
    packets, and closing the listener. I recommend that you look at the scripts `sniffer-detect`
    ([http://nmap.org/nsedoc/scripts/sniffer-detect.html](http://nmap.org/nsedoc/scripts/sniffer-detect.html)),
    `firewalk` ([http://nmap.org/svn/scripts/firewalk.nse](http://nmap.org/svn/scripts/firewalk.nse)),
    and `ipidseq` ([http://nmap.org/svn/scripts/ipidseq.nse](http://nmap.org/svn/scripts/ipidseq.nse)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to send raw packets, create a `dnet` object with `nmap.new_dnet()`
    and, depending on the layer, (IP or Ethernet), use the methods `ip_open()` or
    `ethernet_open()` to open a connection. To actually send the raw packets, use
    the functions `ip_send()` or `ethernet_send()` as appropriate. The following snippets
    from the script `ipidseq.nse` illustrate the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to read the entire documentation of these libraries at [http://nmap.org/nsedoc/lib/nmap.html](http://nmap.org/nsedoc/lib/nmap.html).
    If you are working with raw packets, the library `packet` will help you a lot
    too ([http://nmap.org/nsedoc/lib/packet.html)](http://nmap.org/nsedoc/lib/packet.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library `nmap` provides an exception handling mechanism for NSE scripts
    that is designed to help with networking I/O tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling mechanism from the `nmap` library works as expected.
    We wrap the code that we want to monitor for exceptions inside a `nmap.try()`
    call. The first value returned by the function indicates the completion status.
    If it returns `false` or `nil`, the second returned value must be an error string.
    The rest of the return values in a successful execution can be set and used as
    you wish. The catch function defined by `nmap.new_try()` will execute when an
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code is a snippet of the script `mysql-vuln-cve2012-2122.nse`
    ([http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html](http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html)).
    In this script, a catch function performs some simple garbage collection if a
    socket is left open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation of the NSE library `nmap` can be found at [http://nmap.org/nsedoc/lib/nmap.html](http://nmap.org/nsedoc/lib/nmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Nmap scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing your own NSE library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with NSE threads, condition variables, and mutexes in NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting a path traversal vulnerability with NSE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Path traversal vulnerabilities exists in many web applications. Nmap NSE gives
    penetration testers the ability to quickly write scripts to exploit them. Lua
    also supports string captures, which help a lot when extracting information using
    patterns with a simpler syntax than regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will teach you how to write an NSE script to exploit a path traversal
    vulnerability existing in some models of TP-Link routers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write an NSE script that exploits a path traversal vulnerability in
    several TP-Link routers. We will take advantage of a few NSE libraries and Lua''s
    string library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `http-tplink-dir-traversal.nse` and complete the NSE information
    tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the required libraries (Nmap 6.x format):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the execution rule with some help of the `shortport` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a function to send the path traversal request and determine if the web
    application is vulnerable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Read and parse the file out of the response with some help of a Lua capture
    (`.*`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A vulnerable device will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script `http-tplink-dir-traversal.nse` performs the following tasks to
    exploit the discussed path traversal vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it sends a path traversal request to determine if an installation is
    vulnerable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the installation is vulnerable, extract the requested file out of the response
    sent by the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Report the vulnerability to the user and provide the proof of concept.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, the library `http` was required to send the HTTP request containing
    the path traversal payload. To determine if the device is vulnerable, we request
    the file `/etc/shadow`, because we know this file exists in all of the devices,
    and a root account must exist in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The response should contain the requested file inside its body, after the closing
    script tag `</SCRIPT>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7485_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To confirm exploitability we only need to match the response body to the string
    "root:":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Lua captures allow developers to extract strings matching the given patterns.
    They are very helpful and I highly recommend that you play around with them ([http://www.lua.org/pil/20.3.html](http://www.lua.org/pil/20.3.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we confirm the vulnerability, it is recommended to report it using the
    library `vulns`. This library was created to unify the output format used by the
    various NSE scripts. It supports several fields to provide all of the vulnerability
    details in an organized manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following states are defined in the `vulns` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To return the vulnerability report, use `make_output(vuln)`. This function
    will return a vulnerability report if the state was set to anything except `vulns.STATE.NOT_VULN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the script output from the previous example to see what a vulnerability
    report looks like when using the NSE library `vulns`. Visit the official documentation
    of the library to learn more about the possible report fields and their usage:
    [http://nmap.org/nsedoc/lib/vulns.html](http://nmap.org/nsedoc/lib/vulns.html).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing NSE scripts to exploit path traversal vulnerabilities, remember
    that IPS/IDS vendors will create patches to identify your detection probes. If
    possible, I recommend you use the stealthiest encoding scheme supported. In the
    previous example, no other encoding was read correctly in the application and
    we had no choice but to use the well known pattern `"../"` which will be detected
    by any decent WAF/IPS/IDS.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend the tool Dotdotpwn ([http://dotdotpwn.blogspot.com/](http://dotdotpwn.blogspot.com/))
    and its module `payload` to locate obscure encodings when exploiting path traversal
    vulnerabilities. Ideally, you could also write a small function that randomly
    uses a different path traversal pattern with each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Debugging NSE scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Setting the user agent pragmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some packet filtering products that block requests using Nmap''s
    default HTTP user agent. You can use a different user agent value by setting the
    argument `http.useragent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the user agent in your NSE script you can pass the header field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: HTTP pipelining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some web server configurations support encapsulation of more than one HTTP request
    in a single packet. This may speed up the execution of an NSE HTTP script and
    it is recommended that you use it if the web server supports it. The `http` library,
    by default, tries to pipeline 40 requests and automatically adjusts that number
    according to the network conditions and the `Keep-Alive` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users will need to set the script argument `http.pipeline` to adjust this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement HTTP pipelining in your NSE scripts, use the functions `http.pipeline_add()`
    and `http.pipeline()`. First, initiate a variable that will hold the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Add requests to the pipeline with `http.pipeline_add()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have finished adding requests, execute the pipe with `http.pipeline()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable results will contain the number of response objects added to the
    HTTP request queue. To access them, you can simply iterate through the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Detecting web application firewalls* recipe [Chapter 4](ch04.html "Chapter 4. Auditing
    Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Detecting possible XST vulnerabilities* recipe [Chapter 4](ch04.html "Chapter 4. Auditing
    Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a brute force script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brute force password auditing has become a major strength of the Nmap Scripting
    Engine. The library `brute` allows developers to quickly write scripts to perform
    their custom brute force attacks. Nmap offers libraries such as `unpwd`, which
    give access to a flexible username and password database to further customize
    the attacks, and the library `creds`, which provides an interface to manage the
    valid credentials found.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will guide you through the process of writing your own brute force
    script by using the NSE libraries `brute`, `unpwdb`, and `creds` to perform brute
    force password auditing against Wordpress installations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write an NSE script to brute force Wordpress accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file `http-wordpress-brute.nse` and complete the information tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the required libraries (Nmap 6.x format):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'NSE scripts that use the brute engine need to implement its `Driver` class
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the corresponding functions relevant to our script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `constructor` function takes care of reading the script arguments and setting
    any other options the script might need:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `connect` function can be left empty because in this case there is no need
    to connect to a socket; we are performing a brute force password auditing attack
    against an HTTP service (the library `http` takes care of opening and closing
    the necessary sockets when used inside our next login function):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `disconnect` function also can be left empty for this script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `check` function is used as a sanity check before we begin our brute force
    password attack. Note that this function was marked as deprecated recently, and
    these checks will need to be moved to the main section in future versions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally the `login` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We left the main sectionof the code to initialize, configure, and start the
    brute engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The library `brute` provides developers with an organized interface for writing
    NSE scripts that perform brute force password auditing. The number of brute scripts
    have grown a lot and currently NSE can perform brute force attacks against many
    applications, services, and protocols: Apache Jserv, BackOrifice, Joomla, Citrix
    PN Web Agent XML, CVS, DNS, Domino Console, Dpap, IBM DB2, Wordpress, FTP, HTTP,
    Asterisk IAX2, IMAP, Informix Dynamic Server, IRC, iSCSI, LDAP, Couchbase Membase,
    RPA Tech Mobile Mouse, Metasploit msgrpc, Metasploit XMLRPC, MongoDB, MSSQL, MySQL,
    Nessus daemon, Netbus, Nexpose, Nping Echo, OpenVAS, Oracle, PCAnywhere, PostgreSQL,
    POP3, redis, rlogin, rsync, rpcap, rtsp, SIP, Samba, SMTP, SNMP, SOCKS, SVN, Telnet,
    VMWare Auth daemon, and XMPP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this library, we needed to create a `Driver` class and pass it to the
    brute engine as an argument. Each login attempt will create a new instance of
    this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the script `http-wordpress-brute`, the functions `connect()` and `disconnect()`
    returned `true` all the time because a connection did not need to be established
    beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `login` function should return a Boolean to indicate its status. If the
    login attempt was successful it should also return an `Account` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this script we are also storing the credentials by using the library `creds`.
    This allows other NSE scripts to access them, and users can even generate additional
    reports based on the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NSE libraries `unpwdb` and `brute` have several script arguments that users
    can tune for their brute force password auditing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use different username and password lists, set the arguments `userdb` and
    `passdb` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To quit after finding one valid account, use the argument `brute.firstOnly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To set a different timeout limit, use the argument `unpwd.timelimit`. To run
    it indefinitely, set it to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The official documentation for these libraries can be found at the following
    sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://nmap.org/nsedoc/lib/brute.html](http://nmap.org/nsedoc/lib/brute.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nmap.org/nsedoc/lib/creds.html](http://nmap.org/nsedoc/lib/creds.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nmap.org/nsedoc/lib/unpwdb.html](http://nmap.org/nsedoc/lib/unpwdb.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging NSE scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library `nmap` provides an exception handling mechanism for NSE scripts,
    which is designed to help with networking I/O tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling mechanism from the `nmap` library works as expected.
    We wrap the code that we want to monitor for exceptions inside a `nmap.try()`
    call. The first value returned by the function indicates the completion status.
    If it returns `false` or `nil`, the second returned value must be an error string.
    The rest of the return values in a successful execution can be set and used as
    you wish. The `catch` function defined by `nmap.new_try()` will execute when an
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a code snippet of the script `mysql-vuln-cve2012-2122.nse`
    ([http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html](http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html)).
    In this script a `catch` function performs some simple garbage collection if a
    socket is left open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation of the NSE library `nmap` can be found at [http://nmap.org/nsedoc/lib/nmap.html](http://nmap.org/nsedoc/lib/nmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: Brute modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `brute` library supports different modes that alter the combinations used
    in the attack. The available modes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: For each user listed in `userdb`, every password in `passdb` will be
    tried'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`pass`: For each password listed in `passdb`, every user in `userdb` will be
    tried'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`creds`: This requires the additional argument `brute.credfile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Brute forcing HTTP authentication* recipe in [Chapter 4](ch04.html "Chapter 4. Auditing
    Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Brute-force password auditing Wordpress installations* recipe in [Chapter
    4](ch04.html "Chapter 4. Auditing Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Brute-force password auditing Joomla installations* recipe in [Chapter
    4](ch04.html "Chapter 4. Auditing Web Servers"), *Auditing Web Servers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing your own NSE library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the web crawling library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When pentesting web applications, there are certain checks that need to be done
    to every file in a web server. Tasks such as looking for forgotten backup files
    may reveal the application source code or database passwords. The Nmap Scripting
    Engine supports web crawling to help us with tasks that require a list of existing
    files on a web server.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to write an NSE script that will crawl a web server
    looking for files with a `.php` extension and perform an injection test via the
    variable `$_SERVER["PHP_SELF"]` to find reflected Cross Site Scripting vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common task that some major security scanners miss is to locate reflected
    cross-site scripting vulnerabilities in PHP files via the variable `$_SERVER["PHP_SELF"]`.
    The web crawler library `httpspider` comes handy when automating this task as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the script file `http-phpself-xss.nse` and complete the information
    tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the required libraries (Nmap 6.x format):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Define that the script should run every time it encounters an HTTP server with
    the alias `shortport.http`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the function that will receive a URI from the crawler and send an injection
    probe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the function that will check the response body to determine if a PHP file
    is vulnerable or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main section of the script, we will add the code that reads the script
    arguments, initializes the `http` crawler, sets the vulnerability information,
    and iterates through the pages to launch a probe if a PHP file is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the script, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If a PHP file is vulnerable to Cross Site Scripting via `$_SERVER["PHP_SELF"]`
    injection, the output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script `http-phpself-xss` depends on the library `httpspider`. This library
    provides an interface to a web crawler that returns an iterator to the discovered
    URIs. This library is extremely useful when conducting web penetration tests as
    it speeds up several tests that otherwise will have to be done manually or with
    a third-party tool.
  prefs: []
  type: TYPE_NORMAL
- en: PHP offers developers a variable named `$_SERVER["PHP_SELF"]` to retrieve the
    file name of the executing PHP script. Unfortunately, it is a value that can be
    tampered with user-supplied data, and many developers use it unsafely in their
    scripts, causing reflected **Cross Site Scripting** (**XSS**) vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize a web crawler. We set the starting path and the timeout
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of the web crawler can be modified with the following library
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url`: Base URL at which to start spidering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxpagecount`: The maximum number of pages to visit before quitting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useheadfornonwebfiles`: Save bandwidth by using `HEAD` when a binary file
    is found. The list of files not treated as binaries is defined in the `file /nselib/data/http-web-file-extensions.lst`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noblacklist`: Don''t load the blacklist rules. This option is not recommended
    as it will download all files, including binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withinhost`: Filters out URIs outside the same host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withindomain`: Filters out URIs outside the same domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We iterate through the URIs to find files with the extension `.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Each URI with the extension `.php` is processed and an injection probe is sent
    for each one of them, by using the function `http.get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `check_probe_response()` function simply looks for the injected text in
    the response with some help from `string.find()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, we check the table where we stored the vulnerable URIs, and
    report them as extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is recommended you include a message to notify users about the settings
    used by the web crawler as it may have quit before completing a test. The function
    `crawler:getLimitations()` will return a string that displays the crawler settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation for the library `httpspider` can be found at [http://nmap.org/nsedoc/lib/httpspider.html](http://nmap.org/nsedoc/lib/httpspider.html).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging NSE scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Setting the user agent pragmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some packet filtering products that block requests using Nmap''s
    default HTTP user agent. You can use a different user agent value by setting the
    argument `http.useragent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the user agent in your NSE script you can pass the `header` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: HTTP pipelining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some web server configurations support encapsulation of more than one HTTP request
    in a single packet. This may speed up the execution of an NSE HTTP script and
    it is recommended if the web server supports it. The `http` library, by default,
    tries to pipeline 40 requests and automatically adjusts that number according
    to the network conditions and the `Keep-Alive` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users will need to set the script argument `http.pipeline` to adjust this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement HTTP pipelining in your NSE scripts, use the functions `http.pipeline_add()`
    and `http.pipeline()`. First, initiate a variable that will hold the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Add requests to the pipeline with `http.pipeline_add()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have finished adding requests, execute the pipe with `http.pipeline()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable results will contain the number of response objects added to the
    HTTP request queue. To access them you can simply iterate through the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library `nmap` provides an exception handling mechanism for NSE scripts
    designed to help with networking I/O tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling mechanism from the `nmap` library works as expected.
    We wrap the code that we want to monitor for exceptions inside a `nmap.try()`
    call. The first value returned by the function indicates the completion status.
    If it returns `false` or `nil`, the second returned value must be an error string.
    The rest of the return values in a successful execution can be set and used as
    you wish. The `catch` function defined by `nmap.new_try()` will execute when an
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a code snippet of the script `mysql-vuln-cve2012-2122.nse`
    ([http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html](http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html)).
    In this script a `catch` function performs some simple garbage collection if a
    socket is left opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation of the NSE library `nmap` can be found at [http://nmap.org/nsedoc/lib/nmap.html](http://nmap.org/nsedoc/lib/nmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing your own NSE library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting vulnerabilities correctly in NSE scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine is perfect for detecting vulnerabilities, and for
    this reason there are already several exploitation scripts included with Nmap.
    Not too long ago, each developer used his own criteria of what output to include
    when reporting these vulnerabilities. To address this issue and unify the output
    format and the amount of information provided, the library `vulns` was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will teach you how to report vulnerabilities correctly in your NSE
    scripts by using the library `vulns`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The correct way to report vulnerabilities in NSE is through the library `vulns`.
    Let''s review the process of reporting a vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the library `vulns` (Nmap 6.x format):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `vuln` object table. Pay special attention to the `state` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a report object and report the vulnerability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If the state is set to indicate if a host is vulnerable, Nmap will include
    a similar vulnerability report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library `vulns` was introduced by Djalal Harouni and Henri Doreau to unify
    the output returned by NSE scripts that performed vulnerability checks. This library
    also manages and keeps track of the security checks done, a useful feature for
    users who would like to list the security checks even if the target was not vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerability table can contain the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: String indicating the title of the vulnerability. This field is mandatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: This field indicates different possible states of the vulnerability
    check. This field is mandatory. See the table `vulns.STATE` for all possible values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDS`: Field that stores CVE and BID IDs. It is used to automatically generate
    advisory URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`risk_factor`: String that indicates the risk factor: `High`/`Medium`/`Low`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scores`: Field that stores CVSS and CVSSv2 scores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: Description of the vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dates`: Field of dates relevant to this vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_results`: String or list of strings used to store returned results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exploit_results`: String or list of strings used to store the exploitation
    results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_info`: String or list of strings used to store additional information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`references`: List of URIs to be included as references. The library will automatically
    generate URIs for CVE and BID links if the table IDS was set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you saw previously, the procedure to report vulnerabilities within NSE is
    pretty straightforward. First, we create a table containing all of the vulnerability
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'To report back to the users, we need a report object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The last function that you should use in NSE scripts that include this library
    is `make_output()`. This will generate and display the report if the target was
    found to be vulnerable, or will return `nil` if it wasn't.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to study more NSE scripts that use this library, visit [http://nmap.org/nsedoc/categories/vuln.html](http://nmap.org/nsedoc/categories/vuln.html).
    Note that not all the scripts use it yet as this library was introduced fairly
    recently.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can tell Nmap to report on all vulnerability checks performed by NSE by
    using the library argument `vulns.showall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of all vulnerability checks will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This library can also be combined with prerule and postrule actions if you need
    more flexibility. The online documentation of the NSE library `vulns` can be found
    at [http://nmap.org/nsedoc/lib/vulns.html](http://nmap.org/nsedoc/lib/vulns.html).
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability states of the library vulns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library `vulns` can mark hosts with an exploitability status which is used
    to indicate to the Nmap Scripting Engine if certain vulnerabilities exist in a
    host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a snippet from the `vulns` library that shows the supported
    states and the corresponding string message used in the reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing your own NSE library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own NSE library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you will realize that the code you are writing could be
    put into a library to be re-used by other NSE scripts. The process of writing
    an NSE library is straightforward, and there are only certain things that we need
    to consider, such as not accessing global variables used by other scripts. Although
    Lua modules are preferred, the Nmap Scripting Engine also supports C modules via
    the Lua C API, for those looking for that extra performance.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will teach you how to create your own Lua NSE library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a library has a similar process to writing scripts. Just keep in mind
    the scope of the variables that you are working with. Let''s create a simple library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file `mylibrary.lua`, and start by typing the required libraries
    you may need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, simply add the functions to your library. We will create a function that
    returns the classic `"Hello World!"` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Place your library file inside the directory `/nselib/`. Create a new NSE script
    and add the `require()` call inside of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute your method from inside your script. If the method can''t be accessed,
    you probably set an incorrect scope assignment for the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The LUA NSE libraries are stored inside the directory `/nselib/` in your configured
    data directory. To create our own libraries we just need to create the `.lua`
    file and place it in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'NSE scripts can now import your NSE library and call the available functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: It is important to document your library well before submitting it to `<[nmap-dev@insecure.org](mailto:nmap-dev@insecure.org)>`
    in order to help other developers quickly understand the purpose and functionality
    of your new library.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To avoid overriding global variables used in other scripts by mistake, include
    the module `strict.lua`. This module will alert you every time you access or modify
    undeclared global variables at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging NSE scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library `nmap` provides an exception handling mechanism for NSE scripts,
    which is designed to help with networking I/O tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling mechanism from the nmap library works as expected. We
    wrap the code that we want to monitor for exceptions inside a `nmap.try()` call.
    The first value returned by the function indicates the completion status. If it
    returns `false` or `nil`, the second returned value must be an error string. The
    rest of the return values in a successful execution can be set and used as you
    wish. The `catch` function defined by `nmap.new_try()` will execute when an exception
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a code snippet of the script `mysql-vuln-cve2012-2122.nse`
    ([http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html](http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html)).
    In this script a `catch` function performs some simple garbage collection if a
    socket is left open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation of the NSE library `nmap` can be found at [http://nmap.org/nsedoc/lib/nmap.html](http://nmap.org/nsedoc/lib/nmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules in C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some modules included with the Nmap Scripting Engine are written in C++ or C.
    These languages provide enhanced performance and are recommended when that is
    a critical aspect of the required task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use compiled C modules with the Lua C API in our scripts by following
    the protocols described extensively at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.lua.org/manual/5.2/manual.html#4](http://www.lua.org/manual/5.2/manual.html#4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nmap.org/book/nse-library.html](http://nmap.org/book/nse-library.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with NSE threads, condition variables, and mutexes in NSE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine offers finer control over script parallelism by implementing
    threads, condition variables, and mutexes. Each NSE script is normally executed
    inside a Lua coroutine or thread but it may yield additional worker threads if
    the programmer decides to do so.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will teach you how to deal with parallelism in NSE.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NSE threads are recommended for scripts that need to perform network operations
    in parallel. Let''s see how to deal with parallelism in our scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new NSE thread, use the function `new_thread()` from the library
    `stdnse`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'To synchronize access to a network resource, create a mutex on an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the function returned by `nmap.mutex(object)` can be locked as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'After you are done working with it, you should release it with the function
    `"done"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'NSE supports condition variables to help you synchronize the execution of threads.
    To create a condition variable, use the function `nmap.condvar(object)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'After that you may wait on, signal, or broadcast the condition variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NSE scripts transparently yield when a network operation occurs. Script writers
    may want to perform parallel networking tasks, like the script `http-slowloris`
    which opens several sockets and keeps them open concurrently. NSE threads solve
    this problem by allowing script writers to yield parallel network operations.
  prefs: []
  type: TYPE_NORMAL
- en: The function `stdnse.new_thread` receives as the first argument the new worker's
    main function. This function will be executed after the new thread is created.
    Script writers may pass any additional arguments as optional parameters in `stdnse.new_thread()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The worker's return values are ignored by NSE and they can't report script output.
    The official documentation recommends using `upvalues`, function parameters, or
    environments to report results back to the base thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'After execution, it returns the base coroutine and a status query function.
    This status query function returns up to two values: the results of `coroutine.status`
    using the base `coroutine` and, if an error occurs, an error object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutexes or mutual exclusive objects were implemented to protect resources such
    as NSE sockets. The following operations can be performed on a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lock`: Locks the mutex. If the mutex is taken, the worker thread will yield
    and wait until it is released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trylock`: Attempts to lock the mutex in a non-blocking way. If the mutex is
    taken, it will return false. (It will not yield as in the function `lock`.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`done`: Releases the mutex. Other threads can lock it after this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`running`: This function should not be used at all other than for debugging,
    because it affects the thread collection of finished threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Condition variables were implemented to help developers coordinate the communication
    between threads. The following operations can be performed on a conditional variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`broadcast`: Resumes all threads in the condition variable queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait`: Adds the current thread to the waiting queue on the condition variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal`: Signals a thread from the waiting queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read implementations of script parallelism, I recommend that you read the
    source code of the NSE scripts `broadcast-ping`, `ssl-enum-ciphers`, `firewall-bypass`,
    `http-slowloris`, or `broadcast-dhcp-discover`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lua provides an interesting feature called coroutines. Each coroutine has its
    own execution stack. The most important part is that we can suspend and resume
    the execution via `coroutine.resume()` and `coroutine.yield()`. The function `stdnse.base()`
    was introduced to help identify if the main script thread is still running. It
    returns the base coroutine of the running script.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about coroutines from Lua''s official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lua-users.org/wiki/CoroutinesTutorial](http://lua-users.org/wiki/CoroutinesTutorial)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.lua.org/pil/9.1.html](http://www.lua.org/pil/9.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging NSE scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something unexpected happens, turn on debugging to get additional information.
    Nmap uses the flag `-d` for debugging and you can set any integer between 0 and
    9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library `nmap` provides an exception handling mechanism for NSE scripts
    that is designed to help with networking I/O tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling mechanism from the `nmap` library works as expected.
    We wrap the code that we want to monitor for exceptions inside a `nmap.try()`
    call. The first value returned by the function indicates the completion status.
    If it returns `false` or `nil`, the second returned value must be an error string.
    The rest of the return values in a successful execution can be set and used as
    you wish. The `catch` function defined by `nmap.new_try()` will execute when an
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a code snippet of the script `mysql-vuln-cve2012-2122.nse`
    ([http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html](http://nmap.org/nsedoc/scripts/mysql-vuln-cve2012-2122.html)).
    In this script a `catch` function performs some simple garbage collection if a
    socket is left open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation of the NSE library `nmap` can be found at [http://nmap.org/nsedoc/lib/nmap.html](http://nmap.org/nsedoc/lib/nmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making HTTP requests to identify vulnerable Trendnet webcams* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending UDP payloads by using NSE sockets* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploiting a path traversal vulnerability with NSE* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing a brute force script* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with the web crawling library* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reporting vulnerabilities correctly in NSE scripts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
