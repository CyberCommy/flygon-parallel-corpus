- en: Prepare Yourself - Interviews and the Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an unusual chapter in an **Object-oriented programming** (**OOP**) book.
    Job interviews are an important part of a software developer’s career. An interview
    is like a test of your knowledge. It gives you an idea of how much you know and
    what you should learn more about. It’s also a way to learn from experienced developers in
    other companies.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of this chapter is to give you a glimpse into the types of question
    that are asked in a job interview and how you can prepare yourself for them. Bear
    in mind that job interview questions depend on the position you have applied for,
    the company, the interviewer’s knowledge, and the technology stacks the company
    is using. While not all of these questions will be asked, there is a high possibility
    that some might be, as these determine your basic OOP and C# knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the topics we will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Interview questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interview and career tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things to learn next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interview questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss some of the most common interview questions
    for a beginner to mid-level developer. As this book is about C#, we will also
    have questions that directly relate to the C# programming language.
  prefs: []
  type: TYPE_NORMAL
- en: What are the fundamental principles of object-oriented programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object-oriented programming has four fundamental principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is inheritance?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance** means that a class can inherit the attributes and methods of
    another class. For example, `Dog` is a class, but it is also a subclass of `Animal`.
    An `Animal` class is a more general class that has the basic attributes and methods
    that all animals have. As a dog is also an animal, a `Dog` class can inherit the `Animal`
    class, so that all the attributes and methods of the `Animal` class also become
    available in the `Dog` class.'
  prefs: []
  type: TYPE_NORMAL
- en: What is encapsulation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Encapsulation** means hiding the data of a class. Access modifiers in C#
    are mainly used for the purpose of encapsulation. If we make a method or field
    private, that method or field is not accessible outside the class. This means
    we are hiding that data from the outside world. The main reason for having encapsulation
    is that we want to hide more complicated implementations and only show simple
    interfaces to the outside world for easy usage.'
  prefs: []
  type: TYPE_NORMAL
- en: What is abstraction?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Abstraction** is an idea, something that is not real. **Abstraction** means
    providing the idea of a certain object to the outside world but not it''s implementation.
    Interfaces and abstract classes are examples of abstraction. When we create an
    interface, we don''t implement the methods in it, but when a class implements
    the interface, it has to implement the method as well. This means the interface
    is actually giving an abstract impression of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: What is polymorphism?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** means many forms. In OOP, we should have the option of creating
    one thing in many forms. For example, you can have an `addition` method that might
    have different implementations, depending on the input it receives. An `addition`
    method that receives two integers and returns the sum of those integers could
    be one implementation. There could be another form of `addition` method, which
    might take two double values and return the sum of those double values.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an interface?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **interface** is an entity or feature of the C# programming language that
    is used to apply abstraction in a program. It’s like a contract between a class
    and the interface itself. The contract is that the class that will inherit the
    interface must implement the method signatures that the interface has within itself.
    An interface can’t be instantiated, it can only be implemented by a class or struct.
  prefs: []
  type: TYPE_NORMAL
- en: What is an abstract class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **abstract class** is a special kind of class that can’t be initialized.
    No object can be created from an abstract class. Abstract classes can have concrete
    methods as well as non-concrete methods. If a class implements an abstract class,
    the class must implement the abstract methods. It can override non-abstract methods
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What is a sealed class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **sealed class** is a class that can’t be inherited. It is mainly used to
    stop the inheritance feature in C#.
  prefs: []
  type: TYPE_NORMAL
- en: What is a partial class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **partial class** is a class that has its source in separate files. Normally,
    one class has all its fields and methods in the same file. In a partial class,
    you can separate the class code in different files. When compiled, all the code
    from the separate files is treated as a single class.
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between interfaces and abstract classes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the major differences between an interface and an abstract
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: A class can implement any number of interfaces but can only implement one abstract
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class can have abstract methods as well as non-abstract methods,
    whereas an interface can’t have non-abstract methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an abstract class, data members are private by default, whereas, in an interface,
    all data members are public and this can't be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an abstract class, we need to use the `abstract` keyword to make a method
    abstract, whereas this is not needed in an interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between method-overloading and method-overriding?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Method-overloading** is when a method with the same name has different input
    parameters. For example, let''s say we have a method called `Sum` that takes two
    integer type input and returns an integer type output. An overloaded method of
    `Sum` could take two double type input and return a double output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method-overriding** is when a method with the same name, the same parameters,
    and the same return type is implemented in a subclass for a different kind of
    implementation. For example, imagine we have a method called `Discount` in a class
    called `Sales`, where the discount is calculated as 2% of the total purchase.
    If we have another subclass of `Sales` called `NewYearSales`, in which the discount
    is calculated as 5%, using method-overriding, the `NewYearSales` class can easily
    apply the new implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: What are access modifiers?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Access modifiers** are used to set the security levels of different entities
    in a programming language. By setting access modifiers, we can hide data for classes
    of different levels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, there are six types of access modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected Internal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private Protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is boxing and unboxing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Boxing** is the process of converting a value type to an object. **Unboxing**
    is when the value type is extracted from an object. Boxing may be done implicitly,
    but unboxing has to be explicit in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between a struct and a class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structs and classes are very similar concepts with some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Structs are of the value type and classes are of the reference type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs are usually used for small amounts of data, whereas classes are used
    for large amounts of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs can’t be inherited by other types, whereas classes can be inherited
    by other classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct can’t be abstract, whereas a class can be abstract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an extension method in C# and how do we use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **extension method** is a method that is added to an existing type without
    creating a new derived type or compiling or changing the existing type. It works
    like an extension. For example, by default, we get the string type from .NET frameworks.
    If we want to add another method to this string type, either we have to create
    a derived type that will extend this string type and place the method there, or
    we add the code in the .NET framework and compile and rebuild the library. However,
    with extension methods, we can easily extend a method in the existing type. To
    do that, we have to create a static class and then create an extension method
    that is static as well. This method should take the type as a parameter, but the
    `this` keyword should be placed before the string. Now this method will work as
    an extension method for that type.
  prefs: []
  type: TYPE_NORMAL
- en: What is managed and unmanaged code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code that is developed in the .NET framework is called managed code. **Common
    Language Runtime** (**CLR**) can directly execute this code. Unmanaged code is
    not developed in the .NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: What is a virtual method in C#?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **virtual method** is a method that is implemented in a base class, but that
    also can be overridden in child classes. Virtual methods cannot be abstract, static,
    private, or overridden.
  prefs: []
  type: TYPE_NORMAL
- en: What do you understand by value types and reference types in C#.NET?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, there are two types of data. One is called value type and another is
    called reference type. **Value types** are types that hold the value directly
    in the memory location. If the value is copied, a new memory location holds the
    same value, and both are independent of each other. A **reference type** is when
    the value is not directly placed in the memory location but a reference to the
    value is set instead. Another major difference between value types and reference
    types is that value types are located in stacks and reference types are located
    in heaps. An example of a value type is `int`, whereas an example of a reference
    type is `string`.
  prefs: []
  type: TYPE_NORMAL
- en: What are design principles?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five design principles that make up the acronym **SOLID**:'
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Open/Closed Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the single responsibility principle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <q>*"A class should have one, only one reason to change."*</q>
  prefs: []
  type: TYPE_NORMAL
- en: – *Robert C. Martin*
  prefs: []
  type: TYPE_NORMAL
- en: This means that one class should have only one responsibility. If a class is
    doing multiple things, this is a violation of the **Single Responsibility Principle**
    (**SRP**). For example, if we have a class named `Student`, it should only be
    responsible for student-related data. If the `Student` class needs to be modified
    when changing anything in the `Teacher` class, the `Student` class is violating
    the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Open/Closed principle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software components should be open for extensions but closed for modifications.
    This means that a component should be designed in such a way that, if you need
    to add a new rule or functionality, you shouldn’t have to modify the existing
    code. If you have to modify the existing code to add new functionality, this means
    the component is violating the **Open/Closed principle**.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Liskov substitution principle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Derived types must be completely substitutable for their base types. This means
    that if you have an instance of a base class used somewhere, you should be able
    to replace the base class instances with the child class instances of that base
    class. For example, if you have a base class called `Animal` and a child class
    called `Dog`, you should be able to replace your `Animal` class instances with
    `Dog` class instances without breaking any functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What is the interface segregation principle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clients should not be forced to depend upon interfaces that they don’t use.
    Sometimes, interfaces contain a lot of information that might not be used by the
    classes that implement them. The **interface segregation principle **suggests
    that you keep the interfaces small. Instead of classes implementing one big interface,
    they should implement multiple small interfaces, where all the methods in the
    class are needed.
  prefs: []
  type: TYPE_NORMAL
- en: What is the dependency inversion principle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules; both should depend
    on abstraction. This means that, when you develop modular software code, high-level
    modules should not directly depend on low-level modules, but should depend on
    an interface or abstract class that the low-level module has implemented. By doing
    this, the modules in the system are independent and, in the future, if you replace
    your low-level module with another module, the high-level module isn't affected.
  prefs: []
  type: TYPE_NORMAL
- en: There is another part of this principle, which is *abstraction should not depend
    on details, details should depend on abstractions*. This means that interfaces
    or abstract classes should not depend on classes, but the classes that implement
    interfaces and abstract classes should depend on the interface or abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: Interview and career tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered some of the most common questions that you can be asked
    in an interview, I also have a couple of tips to help you to perform better in
    the interview and in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Improving your communication skills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is commonly believed that software developers are unsociable and not good
    at communication. The reality, however, is very different. All successful developers
    *have* to be good at communication.
  prefs: []
  type: TYPE_NORMAL
- en: As a software developer, there will be times when you have to explain technical
    ideas or situations to non-technical people. To be able to do so, you have to
    communicate in such a way that makes the information accessible and understandable
    to everyone. This may include both verbal (meetings or discussions) and written
    communication (documentation or emails).
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of your career, you might not necessarily understand the importance
    of communication as you will simply be given tasks to complete. However, as you
    gain experience and get ahead in your career, you will appreciate the importance
    of communicating effectively.
  prefs: []
  type: TYPE_NORMAL
- en: As a senior developer, you might have to communicate with your junior developers
    to explain problems or solutions, or with the business team to ensure that you
    fully understand the business requirements. You might also have to conduct technical
    sessions for knowledge-sharing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, ensure that you keep interacting with people and read up on resources
    that will help you to communicate effectively and teach you how to address your
    audience. Good communication skills will not only help you to ace that interview
    but will also be valuable to you throughout your career.
  prefs: []
  type: TYPE_NORMAL
- en: Keep practicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While no software developer is perfect, by practicing regularly, you can become
    a knowledgeable and experienced software developer.
  prefs: []
  type: TYPE_NORMAL
- en: Computer programming is an art. By making mistakes, you will develop a sense
    of what is wrong and what is right. The more you code, the more you will experience
    different situations. These situations will help you gain experience as you will
    likely encounter them again in future projects.
  prefs: []
  type: TYPE_NORMAL
- en: And the best way to learn or master programming is to *practice it*.
  prefs: []
  type: TYPE_NORMAL
- en: Try to apply the concepts you have learned in this book in your real-life projects.
    If this is not possible in your current projects, create demonstration projects
    and apply them there. Technical concepts are very practical; if you're doing practical
    implementations, the concepts will become crystal clear to you.
  prefs: []
  type: TYPE_NORMAL
- en: Things to learn next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading this book, you should have a better understanding of OOP and
    the C# programming language. However, this isn''t enough. You must push yourself
    to learn more about software development. You should learn the other language
    features of C# and how to use them to get your job done. You should also learn
    data structures and algorithms for your professional work. In the following list,
    I have suggested a number of topics and technologies to look into next:'
  prefs: []
  type: TYPE_NORMAL
- en: C# programming language features such as operators, control statements, arrays,
    lists, operator overloading, Lambda expressions, LINQ, string formatting, and
    threading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures and algorithms such as linked lists, binary trees, sorting,
    and searching algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web/desktop frameworks such as ASP.NET MVC, ASP.NET Web API, WPF, and WCF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend technologies such as HTML, CSS, and JavaScript, as well as Javascript
    frameworks such as reactjs/angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database technologies such as MS SQL Server, Oracle, and MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns and their implications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software architecture and design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean code, code refactoring, and code optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other things to learn, but I have covered the topics I believe
    every software developer should know. This list is quite long and the topics are
    quite technical, so plan your learning carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Building the habit of reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My last tip is to become an avid reader. Reading is super important for software
    developers. Information is normally distributed to people by text or speech. While
    video tutorials are a good way to learn, reading gives you time to think and provides
    you with access to millions of resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few of my must-read books:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Pragmatic Programmer: From Journeyman to Master* by Andrew Hunt and David
    Thomas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Code* by Robert Cecil Martin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code Complete 2* by Steve McConnell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring* by Martin Fowler and Kent Beck'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms* by Charles E. Leiserson, Clifford Stein, Ronald
    Rivest, and Thomas H. Cormen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by the Gang
    of Four'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C# 7.0 in a Nutshell: The Definitive Reference* by Joseph Albahari'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C# in Depth* by Jon Skeet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development is a very interesting field. You can develop amazing applications
    that can change the world. Apps such as Facebook and Maps, and the myriad products
    of digital giants, such as Google and Windows, have had a significant impact on
    our lives. Programs can make people's lives easier by increasing productivity.
  prefs: []
  type: TYPE_NORMAL
- en: My request to you as a software developer is to write good code and develop
    amazing apps. If you have the right intentions, a passion for software development,
    and a strong work ethic, you will surely become successful in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make this world a great place by creating amazing software that can aid
    the progress of human civilization.
  prefs: []
  type: TYPE_NORMAL
