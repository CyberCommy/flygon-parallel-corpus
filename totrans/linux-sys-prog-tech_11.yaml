- en: '*Chapter 11*: Using Threads in Your Programs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn what threads are and how to use them in Linux.
    We will write several programs using **POSIX threads**, otherwise known as **pthreads**.
    We will also learn what race conditions are and how to prevent them by using mutexes.
    Then, we'll learn how to make a mutex program more efficient. Lastly, we'll learn
    what condition variables are.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to write threaded programs will make them faster and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first threaded program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading return values from threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causing a race condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding race conditions with mutexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the mutex program more efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using condition variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile. If you haven't installed these tools yet, please refer to [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*, for installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need a program called `htop` to view the CPU load. You install it
    with your distribution's package manager. The program is called `htop` on all
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the code samples for this chapter can be downloaded from GitHub at the
    following URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch11](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch11).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2O4dnlN](https://bit.ly/2O4dnlN)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first threaded program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first recipe, we'll write a small program that checks whether two numbers
    are prime numbers—in parallel. While those two numbers are checked, each in their
    own **thread**, another thread will write dots in the terminal to indicate that
    the program is still running. A total of three threads will run in this program.
    Each thread will print its own result, so there's no need to save and return the
    values in this program.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the basics of threading will give the foundation to move along to more
    advanced programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the `htop` program so you can see the **CPU** load
    go up for two CPU cores. Of course, other similar programs work as well, such
    as KSysGuard for **K Desktop Environment** (**KDE**). It's also best if your computer
    has more than one CPU **core**. Most computers today have more than one core,
    even Raspberry Pis and similar small computers, so this shouldn't be a problem.
    The program still works, even if you only have a single-core CPU, but it's harder
    to visualize the threads.
  prefs: []
  type: TYPE_NORMAL
- en: You also require the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to use `Makefile`. Notice the added `-lpthread`,
    something we didn''t have in the generic Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on and write the program. The code is a bit long, so it''s
    broken up into several steps. All the code goes into a single file, though. Save
    the code as `first-threaded.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the header files, some function prototypes, the `main()`
    function, and some necessary variables. Notice the new header file, `pthread.h`.
    We have a new type here also, called `pthread_t`. This type is used for thread
    IDs. There''s also a `pthread_attr_t` type, which is used for the attributes of
    the threads. We also perform a check to see whether the user entered two arguments
    (the numbers that will be checked to establish whether they are prime numbers).
    Then, we''ll convert the first and second arguments to `long long` integers with
    `atoll()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll initialize the threads attribute structure, `threadattr`, with some
    default settings using `pthread_attr_init()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will create the three threads using `pthread_create()`. The `pthread_create()`
    function takes four arguments. The first argument is the thread ID variable; the
    second argument is the attributes for the thread; the third argument is the function
    that will execute in the thread; the fourth argument is the argument for that
    function. We will also mark the thread for the "progress bar" as detached using
    `pthread_detach()`. This makes the thread''s resources release automatically when
    it terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the program wait for all the threads to finish, we must use `pthread_join()`
    for each thread. Notice that we don''t wait for the progress thread, but we did
    mark it as detached. Here, we will cancel the progress thread before we exit the
    program using `pthread_cancel()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to write the body for the function that will calculate whether
    the given number is a prime number. Notice that the return type of the function
    is a void pointer. The argument is also a void pointer. This is the requirement
    in order for `pthread_create()` to work. Since the argument is a void pointer,
    and we want it as a `long long int`, we must first convert it. We do this by casting
    the void pointer to a `long long int` and save what it''s pointing to in a new
    variable (refer to the *See also* section for a more verbose option). Notice that
    we return `NULL` in this function. This is because we have to return *something*,
    so `NULL` will do just fine here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we write the function for the progress meter. It isn''t really a progress
    meter; it just prints a dot every second to show the user that the program is
    still running. We must use `fflush()` after the call to `printf()` since we aren''t
    printing any newline characters (remember that stdout is line-buffered):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to compile the program using our new Makefile. Note that we
    receive a warning regarding an unused variable here. This is the `arg` variable
    for the progress function. We can safely ignore this warning since we know we
    aren''t using it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, before we run the program, start a new terminal and start `htop` in it.
    Place it somewhere where you can see it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we run the program in the first terminal. Choose two numbers that aren''t
    so small that the program will finish immediately but not so large that it will
    run forever. For me, the following numbers are sufficiently large to make the
    program run for about a minute and a half. This will vary depending on the CPU.
    While you run the program, check the `htop` program. You''ll notice that two cores
    will use 100% until the first number is computed, and then it will only use one
    core at 100%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two numbers are checked individually, each in their own thread. This speeds
    up the process when compared to a non-threaded program. A non-threaded program
    would check each number after the other. That is, the second number would have
    to wait until the first number was completed. But with a threaded program, like
    the one we made here, check both numbers simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: The `isprime()` function is where the calculations are performed. The same function
    is used for both threads. We also use the same default attributes for both threads.
  prefs: []
  type: TYPE_NORMAL
- en: We execute the functions in threads by calling `pthread_create()` for each number.
    Notice that we don't put any parentheses after the `isprime()` function in the
    `pthread_create()` argument. Putting parentheses after the function name executes
    the function. However, we want the `pthread_create()` function to execute the
    function instead.
  prefs: []
  type: TYPE_NORMAL
- en: Since we won't be `pthread_cancel()` is called—we mark it as detached so that
    its resources will be released when the thread terminates. We mark it as detached
    with `pthread_detach()`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a thread has its `sleep()` is one such function; therefore, the
    progress thread will cancel once it executes `sleep()`. The *cancelability type*
    can be changed to asynchronous, meaning it can cancel at any time.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `main()` function, we called `pthread_join()` on both of the
    thread IDs (that are executing `isprime()`). This is necessary to make the process
    wait until the threads are finished; otherwise, it would end right away. The first
    argument for `pthread_join()` is the thread ID. The second argument is a variable
    wherein the thread's return value can be saved. But since we aren't interested
    in the return value here—it just returns `NULL`—we set it to `NULL`, which ignores
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To change the *cancelability state* of a thread, you use `pthread_setcancelstate()`.
    See `man 3 pthread_setcancelstate` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: To change the *cancelability type* of a thread, you use `pthread_setcanceltype()`.
    See `man 3 pthread_setcanceltype` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: To see a list of which functions are `man 7 pthreads` and search for *cancelation
    points* in that manual page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion from a void pointer to a `long long int` can seem a bit cryptic.
    Instead of doing it all in one line, as we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have written it in two steps, which is a bit more verbose, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of useful information in the manual pages for `pthread_create()`
    and `pthread_join()`. You can read them with `man 3 pthread_create` and `man 3
    pthread_join`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding `pthread_detach()`, see `man 3 pthread_detach`.
  prefs: []
  type: TYPE_NORMAL
- en: For information regarding `pthread_cancel()`, see `man 3 pthread_cancel`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading return values from threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll continue from the previous recipe. Here, we'll fetch the
    answers as **return values** from the threads instead of letting them print the
    result themselves. This is like the return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to fetch the return values from threads enables you to do much more
    complicated things with threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for this recipe to make sense, it's advised that you complete the previous
    recipe first.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the Makefile that we wrote in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This program is similar to that of the previous recipe, but instead of each
    thread printing its own result, they return it to `main()`. This is similar to
    how functions return a value to `main()`, only here we need to do some **casting**
    back and forth. The downside of this approach is that we won''t see the result
    until both threads are finished unless we intentionally give the first thread
    the smallest number. If the first thread has the largest number, we won''t get
    the result of the second thread until the second thread is finished, even if it
    has been completed. However, even if we don''t see the results printed right away,
    they are still being processed in two separate threads, just as before:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is long, so it''s split up into several steps. Write the code in a
    single file called `second-threaded.c`. As usual, we start with the headers file,
    the function prototypes, and the beginning of the `main()` function. Notice that
    we have an extra header file here, called `stdint.h`. This is for the `uintptr_t`
    type, which we''ll cast the returned value to. This is safer than casting to an
    `int`, since this is guaranteed to be of the same size as the pointer we''re casting
    from. We also create two void pointers (`prime1Return` and `prime2Return`) that
    we''ll save the return values in. Apart from these changes, the rest of the code
    is the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next part, we add the void pointers we created earlier as the second
    argument to `pthread_join()`, or actually the address of those variables. This
    will save the thread''s return value in these variables. Then, we check those
    return values to see whether the numbers were a prime number. But since the variable
    is a void pointer, we must first cast it to a `unitptr_t` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the functions as before. But this time, we return 0 or 1 cast
    to a void pointer (since that is what the function is declared to do, we cannot
    violate that):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the program. We still get the same warning regarding an
    unused variable, but this is safe to ignore. We know we aren''t using it for anything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now try the program, first with the bigger number as the first argument,
    and then with the smaller number as the first argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The overall basics of this program are the same as in the previous recipe. The
    difference here is that we return the result of the calculations from the threads
    to `main()`, just like a function. But since the return value of our `isprime()`
    function is a void pointer, we must also return this type. To save the return
    values, we pass the address of a variable as the second argument to `pthread_join()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since each call to `pthread_join()` will *block* until its thread has finished,
    we won't get the result until both threads are completed (unless we give it the
    smallest number first).
  prefs: []
  type: TYPE_NORMAL
- en: The new type we used in this recipe, `uintptr_t`, is a special type that matches
    the size of an unsigned integer pointer. Using a regular `int` will probably work
    as well, but it's not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Causing a race condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **race condition** is when more than one thread (or process) tries to write
    to the same variable simultaneously. Since we don't know which thread will access
    the variable first, we can't safely predict what will happen. Both threads will
    try to access it first; they will *race* to access the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what's causing a race condition will help you avoid them, making your
    programs safer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need the Makefile we wrote in the first recipe
    of this chapter, along with the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program that causes a race condition. If the
    program were to work properly, it should add 1 to the `i` variable on every run,
    ending up at 5,000,000,000\. There are five threads, and each thread adds 1 up
    to 1,000,000,000\. But since all the threads access the `i` variable simultaneously—more
    or less—it never reaches 5,000,000,000\. Each time a thread accesses it, it takes
    the current value and adds 1\. But during that time, another thread might also
    read the current value and add 1, which then overwrites the added 1 from the other
    thread. In other words, the threads are overwriting each other''s work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is broken up into several steps. Note that all code goes into a single
    file. Name the file `race.c`. We''ll start with the header files, a `i` of the
    type `long long int`. Then we write the `main()` function, which is pretty self-explanatory.
    It creates five threads with `pthread_create()` and then waits for them to finish
    with `pthread_join()`. Finally, it prints the resulting `i` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we write the `add()` function that will run inside the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program. Once again, it''s safe to ignore the warning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try out the program. We''ll run it several times. Notice that each
    time we run it, we get a different value. That''s because the timing of the threads
    can''t be predicted. But most likely, it will never reach 5,000,000,000, which
    should be the correct value. Note that the program will take several seconds to
    complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This program is rather inefficient at the moment. We''ll time the program before
    we move on using the `time` command. The time it takes to complete will be different
    on different computers. In a later recipe, *Making the mutex program more efficient*,
    we''ll make the program much more efficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all the threads read and write to the same variable at the same time,
    they all undo each other's work. If they all ran in succession, like a non-threaded
    program, the result would be 5,000,000,000, which is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand what's happening here, let's take it step by step. Note
    that this is just a rough estimation; the exact values and thread differ from
    one time to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thread reads the value of `i`; let''s say it''s 1\. The second thread
    also reads `i`, which is still 1, since the first thread hasn''t incremented the
    value yet. Now the first thread increments the value to 2 and saves it to `i`.
    The second thread does the same; it also increments the value to 2 (1+1=2). Now,
    the third thread starts and reads the variable `i` as 2 and increments it to 3
    (2+1=3). The result is now 3, instead of 4\. This continues throughout the program''s
    execution, and there''s no telling what the result will be. Each time the program
    runs, the **timing** of the threads will be slightly different. The following
    diagram contains a simplified example of the problems that can arise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Example of a race condition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B13043_11_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Example of a race condition
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding race conditions with mutexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **mutex** is a **locking mechanism** that prevents access to a **shared variable**
    so that no more than one thread can access it simultaneously. This prevents race
    conditions. With a mutex, we only lock the critical part of the code, for example,
    the updating of a shared variable. This will make sure that all other parts of
    the program run in parallel (if this is possible with the locking mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: However, if we are not careful when we write our programs, a mutex can slow
    down the program a lot, which we'll see in this recipe. In the next recipe, we'll
    fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use mutexes will help you overcome many of the problems associated
    with race conditions, making your programs safer and better.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for this recipe to make sense, it's advised that you complete the previous
    recipe first. You'll also need the Makefile that we wrote in the first recipe
    of this chapter, the GCC compiler, and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This program builds upon the previous recipe, but the complete code is shown
    here. The code is broken up into several steps. However, remember that all the
    code goes into the same file. Name the file `locking.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start at the top as usual. The added code is highlighted. First, we
    create a new variable called `mutex` of the `pthread_mutex_t` type. This is the
    variable that is used for locking. We place this variable in the global area so
    that it can be reached from both `main()` and `add()`. The second added bit is
    the initialization of the mutex variable, using `pthread_mutex_init()`. `NULL`
    as the second argument means that we want the default attributes for the mutex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After we are done with the calculations, we destroy the `mutex` variable with
    `pthread_mutex_destroy()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we use the locking and unlocking mechanisms in the `add()` function.
    We lock the part where the `i` variable is updated and unlock it once the update
    is complete. That way, the variable is locked while the update is in progress
    so that no other threads can access it until the update is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the program. As usual, we can ignore the warning regarding
    an unused variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to run the program. Just as in the previous recipe, we''ll time
    the execution using the `time` command. This time, the calculation will be correct;
    it will end up at 5,000,000,000\. However, the program will take a long time to
    finish. On my computer, it takes well over 5 minutes to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare this result to a simple, non-threaded program that accomplishes
    the same result with the same basic algorithm. Let''s name this program `non-threaded.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile this program and time it. Note how much faster this program
    executes while, at the same time, attaining the same result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Threaded programs aren't automatically going to be faster than non-threaded
    programs. The non-threaded program that we ran in *step 7* was even faster than
    the threaded program from the previous recipe, even though that program didn't
    even use any mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: So why is this, then?
  prefs: []
  type: TYPE_NORMAL
- en: The threaded program we've written has several inefficiencies. We'll start by
    discussing the issues with the `race.c` program from the previous recipe. The
    reason why that program is slower than the non-threaded version is because of
    numerous small things. For example, it takes some time to start each thread (a
    small amount of time, but still). Then there's the inefficiency of updating the
    global `i` variable by only one step each time. All the threads are also accessing
    the same global variable at the same time. We have five threads, and each thread
    increments its local `j` variable by one. And each time that happens, the thread
    updates the global `i` variable. And since all of this happens 5,000,000,000 times,
    it takes a bit longer than it would have taken to run it sequentially in a single
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `locking.c` program in this recipe, we added a mutex to lock the
    `i = i + 1` part. Since this ensures that only one thread can access the `i` variable
    simultaneously, it makes the entire program sequential again. Instead of all the
    threads running side by side, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock the `i = i + 1` part.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `i = i + 1` to update `i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlock `i = i + 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the next thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock the `i = i + 1` part.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `i = i + 1` to update `i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlock `i = i + 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps will repeat over and over again 5,000,000,000 times in a row. Each
    time a thread starts takes time. Then it takes additional time to lock and unlock
    the mutex, and it also takes time to increment the `i` variable. It also takes
    time to switch to another thread and start the whole locking/unlocking process
    all over again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we'll address these issues and make the program run much
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about mutexes, see the manual pages `man 3 pthread_mutex_init`,
    `man 3 phtread_mutex_lock`, `man 3 phthread_mutex_unlock`, and `man 3 pthread_mutex_destroy`.
  prefs: []
  type: TYPE_NORMAL
- en: Making the mutex program more efficient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw that a threaded program isn't necessarily any
    faster than a non-threaded program. We also saw that when we introduced mutexes,
    the program got horribly slow. Much of this slowness is due to switching back
    and forth and locking and unlocking billions of times.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to all of this locking and unlocking and switching back and forth
    is to lock and unlock as few times as possible. And also, to update the `i` variable
    as few times as possible and do as much work as possible in each thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll make our threaded program much faster and much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to write efficient threaded programs will help you stay away from
    many of the pitfalls when it comes to threading.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for this recipe to make sense, it's advised that you complete the two
    previous recipes in this chapter. Other than that, the same requirements apply
    here; we need the Makefile, the GCC compiler, and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This program builds on the previous `locking.c` program from the previous recipe.
    The only difference is the `add()` function. Therefore, only the `add()` function
    is shown here; the rest is the same as `locking.c`. The complete program can be
    downloaded from this chapter''s GitHub directory. The name of the file is `efficient.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of `locking.c` and name the new file `efficient.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rewrite the `add()` function so that it looks like this code instead. Notice
    that we have removed the `for` loop. Instead, we increment a local `j` variable
    in a `while` loop until it reaches 1,000,000,000\. Then, we add the local `j`
    variable to the global `i` variable. This reduces the number of times we have
    to lock and unlock the mutex (from 5,000,000,000 times to only 5 times):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the program and time it using the `time` command. Notice how
    much faster this program is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program is much faster than both the non-threaded version and the first
    locking version. As a reminder of the execution times, the non-threaded version
    took around 10 seconds to complete; the first threaded version (`race.c`) took
    around 20 seconds to complete; the first mutex version (`locking.c`) took well
    over 5 minutes to complete. The final version (`efficient.c`) took just under
    2 seconds to complete—a huge improvement.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main reasons why this program is so much faster. First, this program
    only locks and unlocks the mutex 5 times (compared to 5,000,000,000 times in the
    previous recipe). Secondly, each thread can now complete its work (the `while`
    loop) fully before writing anything to the global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, each thread can now do its work without any interruptions, making
    it truly threaded. Only when the threads have completed their work will they write
    their result to the global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using condition variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `main()` using a condition variable that it has finished and then joins
    with that thread.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use condition variables will help you make your threaded programs
    more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for this recipe to make sense, it's advised that you have completed
    the *Reading return values from threads* recipe first. You'll also need the GCC
    compiler, the Makefile we wrote in the *Writing your first threaded program* recipe,
    and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll rewrite the prime number program from the *Reading return
    values from threads* recipe to use condition variables. The complete program will
    be shown here, but we will only discuss the added parts for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the code is long, it has been broken up into several steps. Save the
    code in a file called `cond-var.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start at the top as usual. Here we have added three new variables, a
    mutex that we name `lock`, a condition variable that we name `ready`, and a thread
    ID for the prime thread, which we name `primeid`. The `primeid` variable will
    be used to send the thread ID from the thread that has finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we must initialize both the **mutex** and the **condition variable**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we check the number of arguments, just as before. If the argument
    count is correct, we start the threads with `pthread_create()`, also as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the interesting stuff. We''ll start by locking the mutex so that
    the `primeid` variable is protected. Then, we wait for the signal from the condition
    variable using `pthread_cond_wait()`. This will release the mutex so that the
    threads can write to `primeid`. Note that we also loop the `pthread_cond_wait()`
    call in a `while` loop. We do this because we only want to wait for the signal
    if `primeid` is still 0\. Since `pthread_cond_wait()` will block, it won''t use
    any CPU cycles. When we get the signal, we move down to the `if` statement. This
    checks which thread it was that finished and joins it. Then we go back and start
    again using the `for` loop. Each time an `if` or `else` statement has completed—when
    a thread has joined—the `primeid` variable is reset to 0\. This will make the
    next iteration wait again with `pthread_cond_wait()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we have the `isprime()` function. Here we have some new lines. Once
    the function is done calculating the number, we lock the mutex to protect the
    `primeid` variable. Then we set the `primeid` variable to the thread''s ID. Then,
    we signal the condition variable (`ready`) and release the mutex lock. This will
    wake up the `main()` function since it''s now waiting with `pthread_cond_wait()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we have the `progress()` function. Nothing has changed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now try out the program. We''ll test it with both the smaller number
    as the first argument and then as the second argument. Either way, the fastest
    number to compute will be displayed instantly, without having to wait for the
    other thread to join:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we waited in the `while` loop with `pthread_cond_wait()`, we called it
    with both the condition variable (`ready`) and the mutex (`lock`). That way, it
    knows which mutex to release and which signal to wait for. It's when we wait that
    the mutex is released.
  prefs: []
  type: TYPE_NORMAL
- en: During the waiting, the other threads can write to the `primeid` variable. The
    other threads will first lock the variable with the mutex before writing to it.
    Once they have written to the variable, they signal the condition variable and
    release the mutex. This wakes up the `main()` function, which is currently waiting
    with `pthread_cond_wait()`. The `main()` function then checks which thread it
    was that finished and joins it with `pthread_join()`. Then, the `main()` function
    will reset the `primeid` variable to 0 and go back to waiting with `pthread_cond_wait()`
    until the next thread signals that it's finished. There are two threads we are
    waiting for, so the `for` loop in `main()` will run the loop two times.
  prefs: []
  type: TYPE_NORMAL
- en: Each thread gets its own thread ID using `pthread_self()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following manual pages for more information regarding condition
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 3 pthread_cond_init()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 3 pthread_cond_wait()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 3 pthread_cond_signal()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
