- en: Chapter 3. Using RNG with C++ Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. An Introduction to Procedural Generation"),
    *An Introduction to Procedural Generation*, we learned the fact that pseudorandom
    number generation is at the heart of random procedural generation. Remember, a
    procedural system is not random by nature, we need to induce randomness. To start
    our journey, we're going to look at a range of different C++ data types, and use
    Random Number Generator (RNG) to give them random values at runtime. This ability
    to use core C++ data types in a random, yet still controlled, way will be the
    basis for all our future systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the game seed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Boolean values randomly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing random elements in an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random number distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the game seed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we do anything we're going to need to set the game seed. Without it we'll
    get the same results each time our game is run. As we've learned, this simply
    requires us to make a call to the `std::srand()` function passing a random parameter
    to be used as the seed. We'll use the current system time as our seed, it's random
    enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Where we make the call to the `std::srand()` function is arbitrary so long as
    it's called before any call to the `std::rand()` function. The file `main.cpp`
    contains the function `main()`, the entry point of the application. It's here
    that our game object is created and the main game loop entered, so we'll make
    our call to the `std::srand()` function here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our updated `main()` function should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each time we run the game now we will have a random seed set, so our calls to
    the `std::rand()` yield unique results.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your game to be consistent between runs you can use a hard-coded
    value as the seed. Just don't forget to change it back or you'll wonder why things
    aren't random later down the line!
  prefs: []
  type: TYPE_NORMAL
- en: Setting Boolean values randomly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps the simplest of all data types is the humble bool. With only two states,
    true and false, it shouldn''t be too hard to set randomly! When represented as
    integers, the two states have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: False = 0 or lower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: True = 1 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given this, to randomly assign a bool we simply need to generate either the
    number 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a number between 0 and 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. An Introduction to Procedural Generation"),
    *An Introduction to Procedural Generation*, we covered the generation of random
    numbers within a specific range. Well we''re now going to put that to use. Using
    the `std::rand()` function we will generate a number between 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, `std::rand()` generates a number between `0` and `RAND_MAX` function.
    We then calculate the remainder of that result divided by 2\. This leaves just
    the range 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `bool` does not have to be set with the `true` or `false` keyword. You can
    assign an integer to a `bool` and its state will be determined by the integer''s
    value using the rule stated previously. Any number less than 1 is false, and any
    number above 0 is true. That means we can feed our result straight into a bool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Putting this together, we can create a simple console application that outputs
    either true or false randomly each time the user presses *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code for this program from the Packt Publishing website.
    It will be in the `Examples` folder, and the project name is `random_boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a number between 0 and 1](img/B04920_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each time we hit *Enter* we get a random Boolean value. Even this simple case
    of random generation can enable us to start building our procedural roguelike
    game. Let's apply it straight away to the creation of items when the room is created.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, nowhere in this small example application do we set the seed randomly.
    As a result, this program will generate the same sequence of values each time
    it is run.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing if an item spawns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, when we start the game a gem and gold item are always spawned. Let's
    use this random bool assignment to decide whether or not the two objects are created.
    To accomplish this we'll encapsulate their spawn code inside an `if` statement,
    the parameter to which will be the result of our random Boolean assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Game::PopulateLevel` method is where out items are spawned. We''ll replace
    the current code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, each time we run the game, it's random whether or not the gem and gold
    are spawned.
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing if an item spawns](img/B04920_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple change, but the first step in creating a procedurally generated game.
    There is no single algorithm or function that makes a game procedural. It's a
    collection of small techniques such as this that make systems non-predictable
    and determined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Random number distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build upon what we know about random number generation to distribute numbers
    randomly. We'll achieve this by first generating `n` numbers between 0 and 100\.
    If we add these together we get a random total where each of our individual numbers
    represents a percentage of that. We can then take that percentage of our goal
    number to get a random portion. The following code demonstrates this and will
    make it clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code for this program from the Packt website. It will
    be in the `Examples` folder, and the project name is `random_distribution`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method ensures that each segment of the number is completely random. There
    is a slight rounding error to be taken into account, but that's not a problem
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Random number distribution](img/B04920_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's waste no time and apply this new skill to the game!
  prefs: []
  type: TYPE_NORMAL
- en: Giving the player random stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classic way in which this random distribution of numbers can be used is to
    give a player random stats. Traditionally, a character in a game is given `n`
    stat points, and it's up to the player to distribute them. Since we're making
    a procedural game, we'll instead distribute them randomly to create procedurally
    generated character stats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this we need to hook up the previous code with the assignment of our
    player''s stat variables. Our player stats are currently fixed, and assigned in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's replace that with the following to randomly distribute the stats. We'll
    also add a variable to the player so we can change how many `stat` points the
    player has to distribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, add the following variable to the player, and don''t forget to add
    it to our initializer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use this to give our player random stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each time we now load the game our player has their stat points allocated randomly.
    This approach of randomly distributing of a set amount could be used in many other
    ways, such as sharing loot between players and allocating damage between multiple
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving the player random stats](img/B04920_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing random elements of a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have collections of similar objects, they are often stored in structures
    such as arrays and vectors. Usually when working with these structures we access
    specific elements, and it's their uniformness and order that make them useful.
  prefs: []
  type: TYPE_NORMAL
- en: To access a specific element we simply supply its index in the collection. Therefore,
    to access a random element of the array we just supply a random index, which is
    a simple case of generating a random number.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an example of this. In the following example we create
    a vector of strings which we populate with animal names. Each time we press enter
    we access a random element of the vector by generating a number between 0 and
    the vectors size.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code for this program from the Packt website. It will
    be in the `Examples` folder, and the project name is `random_element`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing random elements of a collection](img/B04920_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing random elements of a collection is a great tool for creating procedural
    systems. Anywhere in your game where there is a single object, you can create
    an array or vector of alternates, and choose one at random at runtime. With this
    alone you could create a highly randomized game where each run is unique.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a random item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, when we load our game, set items are spawned. We need to add an element
    of randomness to do this, and something as simple as a `switch` statement is all
    that's needed. Where we can, we always want to add options to create random and
    procedurally generated content.
  prefs: []
  type: TYPE_NORMAL
- en: To randomly spawn our items, we need to generate a random number between `0`
    and the number of items we have, and then use that in a `switch` statement. As
    stated previously, there isn't one approach to procedural generation, so there
    will be other methods to doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add in the number generation and `switch` statements to choose which
    item to spawn. The updated `Game::PopulateLevel` function should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see that when we run the game, if an object can be spawned it will
    be either the gold item or the gem. We have a bunch of items in the game, and
    in the next chapter we''ll be extending this system to include them all, populating
    our entire level from a single function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawning a random item](img/B04920_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating random characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we've covered generating random strings from a set wordlist, let's look
    at generating random characters. The `char` data type is a single, one byte character.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `string` is actually just a null-terminated sequence of characters, so the
    following lines of code produce the exact same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the following code is semantically correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a `char` is one byte, it has the possible integer representations of
    0 to 255\. Each of these decimal values represents a different character. A lookup
    table can found in the ASCII table. For example, the character *a* has the decimal
    value `97`. We can use these integers when assigning a `char`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C++ the maximum decimal value of a `char` is 255\. If you go over this it
    will overflow and loop back through the table. For example, setting a char value
    equal to 353 will result in the character *a*. An ASCII table can be found at
    [http://www.asciitable.com/](http://www.asciitable.com/).
  prefs: []
  type: TYPE_NORMAL
- en: To generate a random char we therefore need to generate a number between 0 and
    255, something we're very familiar with now.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code for this program from the Packt website. It will
    be in the `Examples` folder, and the project name is `random_character`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this code we're generating a random character from the entire ASCII table.
    To generate characters within a more specific range, we simply need to cap the
    number range we generate with.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, looking at the ASCII table shows us that the lowercase alphabet
    starts at 97 and runs until 122\. Let''s adjust the random number generator to
    generate values within this range only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see that the outputs are letters from the lowercase alphabet only,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating random characters](img/B04920_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Repeating loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another use of generating random numbers is to loop over certain code an undetermined
    number of times. For example, when we spawn our items we make individual calls
    to the spawn code. This is fine if we just want to spawn one item every time,
    but what about when we want to spawn a random number of items.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make a random amount of calls to our code, which we'll later wrap
    in its own function, and this can be achieved using `for` loops. In a `for` loop
    we specify how many times we want the loop to iterate, so instead of using a fixed
    value as we normally would, we can generate a random number to use instead. Each
    time the code is run, a new random number will be generated, and the loop will
    be a different size each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code for this program from [http://www.packtpub.com/support](http://www.packtpub.com/support).
    It will be in folder `Chapter 3`, and is called `random_loops.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Repeating loops](img/B04920_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spawning a random number of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our items being spawned in our `Game::PopulateLevel` function, and the
    ability to call a function a random number of times, let's update the code so
    we spawn a random number of items when we start the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, all we need to do is create the same loop as in the previous
    exercise, and encapsulate our spawn code within it. Let''s update `Game::PopulateLevel`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now when we run the code, we have a bunch of items that are spawned. They are
    currently spawning on-top of one-another, but don't worry, we're fixing that in
    the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawning a random number of items](img/B04920_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enable you to test your knowledge of this chapter's content, here are a few
    exercises that you should work through. They are not imperative to the rest of
    the book, but working through them will help you assess your strengths and weaknesses
    on the material covered.
  prefs: []
  type: TYPE_NORMAL
- en: Add more options to the random string generator. Try to create a generator that
    uses two random words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amend the random character generation program so we generate the characters
    A-Z uppercase, and a-z lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player is currently spawned at a fixed location in the level. Create a set
    of possible spawn coordinates, and choose randomly between them at run-time so
    the spawn location varies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've taken a look at a range of C++ data types, and incorporated
    RNG with their use. The ability to use these data types in a random, but controlled
    way, is key in implementing random procedural systems. Remember, procedural generation
    is just the creation of content as the result of a calculation. This is not random
    by nature, we have to induce randomness as we have in this chapter. The additions
    we have made to the game are small, but are the first steps in creating a procedurally
    generated game. Already when we run our game it will be a little different each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we're going to develop our level further by spawning our
    items and enemies in random locations around the map. Procedurally generated environments
    are a staple in procedurally generated games, and spawning our game objects in
    random locations is a big step towards achieving this.
  prefs: []
  type: TYPE_NORMAL
