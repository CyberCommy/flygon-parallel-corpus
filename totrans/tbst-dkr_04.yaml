- en: Chapter 4. Devising Microservices and N-Tier Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。设计微服务和N层应用程序
- en: 'Let''s expand on what we saw and learned in the last chapter about the more
    advanced development and deployment of microservices and N-tier applications.
    This chapter will address the underlying architectures for these design approaches
    as well as resolve typical issues faced while building these types of applications.
    We will cover the following topics in the chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展上一章中所看到和学到的关于微服务和N层应用程序更高级的开发和部署。本章将讨论这些设计方法的基础架构，以及在构建这些类型的应用程序时遇到的典型问题。本章将涵盖以下主题：
- en: Monolithic architectural pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片架构模式
- en: N-tier application architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: N层应用程序架构
- en: Building, testing, and automating N-tier applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、测试和自动化N层应用程序
- en: Microservices architectural pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: Building, testing, and automating microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、测试和自动化微服务
- en: Decoupling multi-tier applications into multiple images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多层应用程序解耦为多个图像
- en: Making different tiers of applications work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使不同层的应用程序运行
- en: Nowadays, modern software built as services are giving rise to a shift in how
    applications are designed. Instead of using web frameworks to invoke services
    and produce web pages, applications today are built by consuming and producing
    APIs. Much has changed in the development and deployment of business applications,
    some of it dramatically and some of it either by revision or extension from the
    past design approaches, depending upon your viewpoint. Several architectural design
    approaches exist, and they are distinguishable by applications built for enterprise
    versus web versus Cloud.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，作为服务构建的现代软件正在引发应用程序设计方式的转变。如今，应用程序不再使用Web框架来调用服务和生成网页，而是通过消费和生成API来构建。在业务应用程序的开发和部署方面发生了许多变化，其中一些变化是戏剧性的，另一些变化是根据过去的设计方法进行修订或扩展的，这取决于您的观点。存在几种架构设计方法，它们可以通过为企业构建的应用程序与为Web构建的应用程序与云构建的应用程序进行区分。
- en: Development trends, over the last few years in particular, are awash with terms
    such as **microservices architecture** (**MSA**), applicable to a particular way
    of application design and development as suites of independently deployable services.
    The meteoric rise of the microservices architectural style is clearly an irrefutable
    force in today's development for deployment; there has been a considerable shift
    away from monolithic architecture and toward N-tier applications and microservices,
    but just how much of this is hype and how much of this can be honed?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年的发展趋势中，充斥着诸如**微服务架构**（MSA）之类的术语，这些术语适用于一种特定的应用程序设计和开发方式，即独立部署的服务套件。微服务架构风格的迅猛崛起显然是当今开发部署中不可否认的力量；从单片架构到N层应用程序和微服务的转变是相当大的，但这究竟有多少是炒作，有多少可以被磨练？
- en: Hype or hubris
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 炒作还是自负
- en: Before we begin diving deeply into troubleshooting, we ought to provide a basic contextual
    overview of modern applications and both the N-tier and microservices architectural
    styles. Knowing both the advantages and limitations of these architectural styles
    will help us plan for potential troubleshooting areas, and how we can avoid them.
    Containers are ideally suited for both of these architectural approaches, and
    we will discuss each one separately to give their proper due.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入研究故障排除之前，我们应该对现代应用程序以及N层和微服务架构风格进行基本的上下文概述。了解这些架构风格的优势和局限将有助于我们规划潜在的故障排除领域，以及我们如何避免它们。容器非常适合这两种架构方法，我们将分别讨论每种方法，以便给予它们适当的重视。
- en: Within all the noise, we sometimes forget that to deploy systems across these
    domains, one still has to create services and compose multiple services in working
    distributed applications. Here, it is important to understand the modern meaning
    of the term application. Applications are now primarily constructed as asynchronous
    message flows or synchronous request calls (if not both) that serve in forming
    collections of components or services allied by these connections. Participating
    services are highly distributive across variant machines and diverse Clouds (private,
    public, and hybrid).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的噪音中，我们有时会忘记，要在这些领域部署系统，仍然需要创建服务，并在工作的分布式应用程序中组合多个服务。在这里，重要的是要理解术语“应用程序”的现代含义。应用程序现在主要是构建为异步消息流或同步请求调用（如果不是两者兼而有之），这些消息流或请求调用用于形成由这些连接联合的组件或服务的集合。参与的服务高度分布在不同的机器和不同的云（私有、公共和混合）之间。
- en: As for architectural styles, we shan't bother ourselves with too much comparison
    or engage in overly detailed discussions on what microservices actually are and
    whether they are any different from **Service-Oriented Architecture** (**SOA**)-there
    is certainly plenty of forum and related debate elsewhere for your choosing. With
    design principles rooted at least as far back as Unix, we will proffer no authoritative
    viewpoints in this book that the current microservices trend is either conceptually
    singular or entirely ingenious. Instead, we will put forward the major considerations
    for implementing this architectural approach and the benefits to be gained for
    modern applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于建筑风格，我们不会过多比较或进行过于详细的讨论，关于微服务到底是什么，以及它们是否与面向服务的架构（SOA）有任何不同-在其他地方肯定有很多论坛和相关的辩论可供选择。以Unix至少根植的设计原则为基础，我们在本书中不会提出任何权威观点，即当前的微服务趋势是概念上独特的或完全巧妙的。相反，我们将提出实施这种架构方法的主要考虑因素以及现代应用程序可以获得的好处。
- en: 'Use case still drives and dictates architectural approaches (or, in my opinion,
    should), and as such there is value in making some degree of comparative analysis
    among all predominant architectural styles: **monolithic**, **N-tier**, and **microservices**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用例仍然驱动和决定架构方法（或者，在我看来，应该如此），因此在所有主要的架构风格之间进行一定程度的比较分析是有价值的：单体、N层和微服务。
- en: Monolithic architecture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: Monoliths are essentially one deployment unit housing all services and dependencies,
    making them easy to develop, easy to test, relatively easy to deploy and, initially,
    easy to scale. However, this style does not meet the requisite needs for most
    modern enterprise applications (N-tier) and web development at scale, and certainly
    not (microservices) applications being deployed to the Cloud. Change cycles are
    tightly coupled-any changes made, even to the smallest parts of an application,
    require wholesale rebuilds and redeployments for the entire monolith. As the monolith
    matures, any attempts at scaling require scaling of the entire application rather
    than the individual parts, which specifically require greater resources, becoming
    altogether nightmarish, if not improbable. At this point, a monolithic application
    has become overly complex, weighted with vast lines of code that is ever-increasingly
    difficult to decipher, such that business-critical items like bug fixes or implementing
    new features become too much of a time drain to ever attempt. As the code base
    becomes unintelligible, it is only reasonable to expect any changes made likely
    to be done incorrectly. The burgeoning size of the application not only slows
    development, it impedes continuous development altogether; to update any part
    of a monolith, the entire app must be redeployed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Monolithic architecture](graphics/Untitled.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Monolithic architectural pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Other problems with monoliths abound, resources cannot be catered to better
    meet needs, for example, CPU or memory requirements. Since all modules are running
    the same processes, any bug can potentially bring the entire process to a halt.
    Lastly, it becomes much more difficult to adopt newer frameworks or languages,
    creating a huge barrier to adopt new technologies-you are likely stuck with whatever
    technology choices you made at the beginning of the project. Needless to say,
    your needs may have changed rather dramatically since the beginning. Using obsolete,
    unproductive technology makes keeping and bringing in new talent more difficult.
    The application has now become very difficult to scale and is unreliable, making
    agile development and delivery of applications impossible. The initial ease and
    simplicity of a monolith quickly become its own Achilles heel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: As these monolithic architectures are basically one deployment unit that does
    everything–N-tier and microservices architectures have arisen to address the specialized
    service needs of modernized applications, primarily Cloud and mobile-based.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: N-tier application architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand N-tier applications and their potential for decoupling
    into microservices, we will hold its comparison against the monolithic style since
    both the development of N-tier applications and proliferation of microservices
    exist to address many of the problems found in the outdated conditions we've found
    resulting from the approach of monolithic architectures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The N-tier application architecture, also referred to as **distributed applications**
    or **multi-tier**, proffers a model in which developers can create flexible and
    reusable applications. As the application is segregated into tiers, developers
    are empowered by the option of modifying or adding a specific tier or layer instead
    of requiring a rework of the entire application as would be necessary under monolithic.
    A multi-tier application is any application developed and distributed among more
    than one layer. It logically separates the different application-specific and
    operational layers. The number of layers varies by business and application requirements,
    but three-tier is the most commonly used architecture. Multi-tier applications
    are used to divide enterprise applications into two or more components that may
    be separately developed, tested, and deployed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: N-tier applications are essentially SOA that attempt to address some of the
    issues with antiquated monolothic design architecture. As we have seen in the previous chapters,
    Docker containers are a perfect match for N-tier application development.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![N-tier application architecture](graphics/Untitled-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: N-tier application architecture
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'A common N-tier application consists of three layers: a **PRESENTATION TIER**
    (providing basic user interface and application services access), a **DOMAIN LOGIC
    TIER** (providing the mechanism used to access and process data), and a **DATA
    STORAGE TIER** (which holds and manages data that is at rest).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the concepts of layer and tier are often used interchangeably, a fairly
    common point of view is that there is actually a difference. This view holds that
    a *layer* is a logical structuring mechanism for the elements that make up the
    software solution, while a *tier* is a physical structuring mechanism for the
    system infrastructure. Unless otherwise specifically noted in our book, we will
    use tier and layer interchangeably.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to separate the various tiers in an N-tier application is to
    create discrete projects for each tier that you want to include in your application.
    For example, the presentation tier might be a Windows forms application, whereas
    the data access logic might be a class library located in the middle tier. Additionally,
    the presentation layer might communicate with the data access logic in the middle
    tier through a service. Separating application components into separate tiers
    increases the maintainability and scalability of the application. It does this
    by enabling easier adoption of new technologies that can be applied to a single
    tier without the requirement to redesign the whole solution. In addition, N-tier
    applications typically store sensitive information in the middle tier, which maintains
    isolation from the presentation tier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most common example of N-tier app development is websites; an example
    of this can be seen in the `cloudconsulted/joomla` image we used in the last chapter,
    where Joomla, Apache, MySQL, and PHP were all *layered* as tiers into a single
    container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: It will be easy enough for us to simply recursively use our `cloudconsulted/joomla`
    image (from earlier) here, but let's build a classic three-tiered web application
    to expose ourselves to some other application potential as well as introduce another
    unit test tool for our development teams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Building a three-tier web application
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s develop and deploy a real-world three-tier web application with the
    help of the following containers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'NGINX > Ruby on Rails > PostgreSQL:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The NGINX Docker container (Dockerfile), as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Ruby on Rails Docker container (Dockerfile), as shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The PostgreSQL Docker container, as illustrated:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding Dockerfiles can be used to deploy a three-tier web application
    and help us get started with microservices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin explaining the microservice architectural style, it will prove beneficial
    to again compare to the monolithic, as we did with N-tier. As you may recall,
    a monolithic application is constructed as a single unit. Also, recall that monolithic
    enterprise applications are often built around three primary tiers: a client-side
    user interface (comprising of HTML pages and JavaScript running in a browser on
    the user''s machine), a database (comprising of many tables inserted into a common,
    and usually relational, database management system), and a server-side application
    (which handles HTTP requests, executes domain logic, retrieves and updates data
    from the database, and selects and populates HTML views to be sent to the browser).
    This classic version of a monolithic enterprise application is a single, logical
    executable. Any changes to the system involve building and deploying a new version
    of the server-side application, and changes in the underlying technology are likely
    not prudent.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始解释微服务架构风格，将有利于再次与单片进行比较，就像我们在N层中所做的那样。您可能还记得，单片应用是作为一个单一单位构建的。还要记住，单片企业应用通常围绕三个主要层构建：客户端用户界面（包括在用户机器上的浏览器中运行的HTML页面和JavaScript）、数据库（包括插入到一个常见且通常是关系型数据库管理系统中的许多表）和服务器端应用程序（处理HTTP请求，执行领域逻辑，从数据库中检索和更新数据，并选择和填充要发送到浏览器的HTML视图）。这种经典版本的单片企业应用是一个单一的逻辑可执行文件。对系统的任何更改都涉及构建和部署服务器端应用程序的新版本，并且更改底层技术可能是不明智的。
- en: The path to modernity
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通往现代化的道路
- en: 'Microservices represent the convergence of the modern Cloud and modern application
    development, structured around the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务代表了现代云和现代应用开发的融合，围绕以下结构：
- en: Componentized services
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件化服务
- en: Organization around business capabilities
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕业务能力的组织
- en: Products, not projects
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品，而不是项目
- en: Smart endpoints and dumb pipes
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能端点和愚蠢的管道
- en: Decentralized governance and data management
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散式治理和数据管理
- en: Infrastructure automation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施自动化
- en: 'Here, monolithic typically focuses on **enterprise service bus** (**ESB**) used
    to integrate monolithic applications, modern application design is API driven.
    These modern applications embrace APIs on all sides: on the frontend for connecting
    to rich clients, the backend for integrating with internal systems, and on the
    sides to allow other applications access to their internal data and processes.
    Rather than leveraging the more complicated traditional enterprise mechanisms,
    many developers are finding that the same lightweight API services that have proven
    to be resilient, scalable, and agile for frontend, backend, and application-to-application
    scenarios can also be leveraged for application assembly. What is also compelling
    is that containers, and especially so within a microservices architectural approach,
    alleviate the perennial issue of developers being blocked out of architectural
    decisions while still realizing the benefits of repeatability. The use of preapproved
    container configurations.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单片通常侧重于用于集成单片应用的企业服务总线（ESB），现代应用设计是API驱动的。这些现代应用在各个方面都采用API：在前端用于连接富客户端，在后端用于与内部系统集成，并在侧面允许其他应用访问其内部数据和流程。许多开发人员发现，与更复杂的传统企业机制相比，那些已被证明对前端、后端和应用程序之间的场景具有弹性、可扩展性和敏捷性的轻量级API服务也可以用于应用程序组装。同样引人注目的是，容器，尤其是在微服务架构方法中，缓解了开发人员被阻止参与架构决策的永恒问题，同时仍然实现了可重复性的好处。使用经过预先批准的容器配置。
- en: Microservices architectural pattern
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: 'Here, we illustrate that instead of a single, monstrous monolithic application,
    we have split the application into smaller, interconnected services (that is,
    microservices) that implement each functional area of the application. This allows
    us to deploy directly to address the needs of specialized use cases or specific
    devices or users /or/ the microservices approach, in a nutshell, dictates that
    instead of having one giant code base that all developers touch, which often becomes
    perilous to manage, there are numerous smaller code bases managed by small and
    agile teams. The only dependency these code bases have on one another is their
    APIs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices architectural pattern](graphics/Untitled-2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Microservices architectural pattern
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common discussion around microservices is debate over whether this is just
    SOA. Some validity exists on this point as the microservice style does share some
    of the advocacies of SOA. In reality, SOA means a host of many different things.
    As such, we submit and will attempt to show that while shared similarities do
    exist, SOA remains significantly different from the microservices architectural
    style as presented herein.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Common characteristics of microservices
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we will not attempt a formal definition of the microservices architectural
    style, there are some common characteristics we can certainly use to identify
    it. Microservices are generally designed around business capabilities and priorities
    and include multiple component services that can be automated for deployment independently
    without compromising the application, intelligence endpoints, and decentralized
    control of languages and data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide some basis then, if not common ground, to follow is an outline that
    can be seen as the common characteristics for architectures that fit the *microservices*
    label. It should be understood that not all microservice architectures will exhibit
    all characteristics at all times. Since we do, however, have expectations that
    most microservice architectures will exhibit most of these characteristics, let''s
    list them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Independent
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interchangeable
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of microservices
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The common characteristics of microservices we just listed also serve to itemize
    their advantages. Without meaning to belabor the issue over too much redundancy,
    let''s at least canvass the main advantage points:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices enforce a level of modularity**: This is extremely difficult
    to accomplish in practice with a monolithic architecture. The microservices advantage
    is that individual services are much faster to develop, much easier to understand,
    and much easier to maintain.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务强制实施一定程度的模块化：这在单片架构中实际上非常难以实现。微服务的优势在于单个服务开发速度更快，更容易理解，更容易维护。
- en: '**Microservices enable each service to be developed independently**: This is
    done by teams specifically focused on that service. The microservices advantage
    is empowering developers with the freedom to choose whatever technology is best
    suited or makes better sense, so long as that service honors the API contract.
    By default, this also means that developers are no longer trapped with potentially
    obsolete technologies from a project''s beginning, or when starting a new project.
    Not only does an option exist to employ the current technology, but with a relatively
    small service size it is also now feasible to rewrite older services using a more
    relevant and reliable technology.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使每个服务能够独立开发：这是由专门专注于该服务的团队完成的。微服务的优势在于赋予开发人员选择最适合或更合理的技术的自由，只要该服务遵守API合同。这也意味着开发人员不再被困在项目开始时或开始新项目时可能过时的技术中。不仅存在使用当前技术的选项，而且由于服务规模相对较小，现在还可以使用更相关和可靠的技术重写旧服务。
- en: '**Microservices enable each service to be deployed continuously**: Developers
    needn''t coordinate the deployment of changes that are localized to their service.
    The microservices advantage is in continuous deployment-deployment takes place
    as soon as changes are successfully tested.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使每个服务能够持续部署：开发人员无需协调局部更改的部署。微服务的优势在于持续部署-只要更改成功测试，部署就会立即进行。
- en: '**Microservices enable each service to be scaled independently**: You need
    to deploy only the instances of each service necessary to satisfy the capacity
    and availability constraints. Additionally, we can also succinctly match the hardware
    to fulfill a service''s resource requirements (for example, compute or memory
    optimized hardware for CPU and memory-intensive services). The microservices advantage
    is in not only matching capacity and availability, but leveraging user-specific
    hardware optimized for a service.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使每个服务能够独立扩展：您只需部署每个服务实例以满足容量和可用性约束。此外，我们还可以简洁地匹配硬件以满足服务的资源需求（例如，为CPU和内存密集型服务优化的计算或内存优化硬件）。微服务的优势在于不仅匹配容量和可用性，而且利用为服务优化的用户特定硬件。
- en: All of these advantages are extremely advantageous, but for the next bit let's
    elaborate on the point of scalability. As we've seen with monolithic architectures,
    while easy to initialize scaling, it is certainly deficient in executing it over
    time; bottlenecks abound and, eventually, it's approach to scaling is vastly untenable.
    Fortunately, microservices as an architectural style supremely excels at scaling.
    A quintessential book, *THE ART OF SCALABILITY* ([http://theartofscalability.com/](http://theartofscalability.com/)) illustrates
    a highly useful, three-dimensional model of scalability in a *scale cube* ([http://microservices.io/articles/scalecube.html](http://theartofscalability.com/)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些优势都非常有利，但接下来让我们详细阐述可伸缩性的观点。正如我们在单片架构中所看到的，虽然易于初始化扩展，但在随着时间的推移执行扩展时显然存在不足；瓶颈随处可见，最终，其扩展方法是极不可行的。幸运的是，作为一种架构风格，微服务在扩展方面表现出色。一本典型的书，《可伸缩性的艺术》（[http://theartofscalability.com/](http://theartofscalability.com/)）展示了一个非常有用的三维可伸缩性模型，即*可伸缩性立方体*（[http://microservices.io/articles/scalecube.html](http://theartofscalability.com/)）。
- en: Microservices at scalability
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可伸缩的微服务
- en: In the provided model, along the X-axis scaling (that is, Monolothic) we can
    see the common horizontal duplication approach, scaling an application by running
    multiple, cloned copies of that application behind a load balancer. This results
    in improved application capacity and availability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices at scalability](graphics/image_04_004.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Microservices at scalability
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Moving along the Z-axis for scaling (that is N-tier/SOA), each server runs identical
    copies of code (similar to X-axis). The difference here comes in that each server
    is responsible solely for a strict subset of the data (that is, data partitioning
    or scaling by splitting into similar things). A given component of the system
    therefore has responsibility for routing a given request to an appropriate server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sharding** is a commonly used routing criteria where an attribute of the
    request is used to route the request to a particular server (for example, the
    primary key of a row or identity of a customer).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Just as with X-axis scaling, Z-axis scaling serves to improve application capacity
    and availability. However, as we learned in this chapter, neither the monolithic
    or N-tier approach (X- and Y-axis scaling) will resolve the inherent problems
    of our ever-increasing development and application complexities. To effectively
    deal with these issues, we need to apply Y-axis scaling (that is, microservices).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: This third dimension to scaling (Y-axis) involves functional decomposition,
    or scaling by splitting into different things. Occurring at the application tier,
    Y-axis scaling will split a monolithic application into separate sets of services
    wherein each service implements a set of allied functionalities (for example,
    customer management, order management, and so on). Later in this chapter, we will
    look directly into the decomposition of services.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: What we can typically see are applications that utilize all the three axes of
    the scaling cube together. Y-axis scaling decomposes the application into microservices;
    at runtime, X-axis scaling executes multiple instances of each service behind
    a load balancer for enhanced output and availability, and some applications may
    additionally use Z-axis scaling for partition of services.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of microservices
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s do our full due diligence here by also understanding some of the disadvantages
    of microservices:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying a microservices-based application is much more complex**: In contrast
    to monolithic applications, a microservice application typically consists of a
    large number of services. Defacto, we have greater complexity in deploying them.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management and orchestration of microservices is much more complex**: Each
    service, within a large number of services, will have multiple runtime instances.
    An exponential increase occurs across many more moving parts that require configuration,
    deployment, scaling, and monitoring. Any successful microservices deployment,
    therefore, requires more granular control of deployment methods by developers
    combined with a high level of automation.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing a microservices application is much more complex**: Writing test
    classes for a microservices application does not only require that service to
    be started, but also its dependency services.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once understood, we can strategize and design to mitigate these drawbacks and
    better plan for troubleshooting areas.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for devising microservices
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have reviewed the transgression from single delivery to multi-tier to containerized
    microservices, and understand that each has its own functional place for application.
    Each architecture carries its own degree of validity; appropriate design strategy
    and application of these architectures is necessary for your deployment successes.
    Having learned the basic tenets for monolithic, N-tier, and microservices, we
    are better equipped toward strategically implementing the best-suited architectures
    on a per use case basis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Considerations for devising microservices](graphics/Untitled-3.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: From mono to micro
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architectural pattern is a better choice for complex, evolving
    applications despite the drawbacks and implementation challenges. To utilize microservices
    for modern Cloud and web application design and deployment, how best do we leverage
    the advantages of microservices while mitigating the potential drawbacks?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether developing a new application or reinvigorating an old one, these considerations
    must be taken into account for microservices:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Building and maintaining highly available distributed systems is complex
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More moving parts means more components to keep track of
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled services means that steps need to be taken to keep data consistent
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed asynchronous processes create network latency and more API traffic
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and monitoring individual services is challenging
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigating the disadvantages
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is likely the most simplistic instruction provided in the entire book;
    however, time and again we witness the obvious either completely ignored, overlooked,
    or underpursued. Our submission here is that, in spite of the relatively few but
    known disadvantages, there exist both current and evolving mechanisms to resolve
    almost all of these issues; expectation is strong that the container market will
    evolve a plethora of working solutions to the current issues.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, let''s just start with the most basic elements here as the foundation
    of successful microservices applications that require less troubleshooting:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**Take total ownership**: Without taking full ownership and knowing that ultimate
    success is directly up to you and your team, your projects and their resulting
    applications will suffer. Commitment, dedication, and persistence pay handsome
    results.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Develop a complete understanding**: Fully comprehend what the business goals
    are and what technologies can be best applied to address them, not to mention
    the *how* and *why* for which you are using them. Always be learning!'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pursue exhaustive, coordinated planning**: Plan strategically, plan along with
    other application stakeholders, plan for failure, and then plan some more; Measure
    your results and revise the plan, re-evaluating the plan on a continuum. Always
    be measuring, and always be planning!'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize the current technology**: It is imperative in today''s technology
    climate to make good use of the most stable and functional tools and applications;
    so, seek them out.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evolve with the application**: You must be as agile and adaptable as the
    container technologies you are using; change must be an accepted part of your
    exhaustive, coordinated planning!'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great! We know that we must not only acknowledge, but actively participate in
    the most basic elements of our application project process. We also know and understand
    the advantages and disadvantages of a microservices architectural approach, and
    that those advantages have the potential to far outweigh any negatives. Outside
    of the preceding five powerful items, how do we mitigate these drawbacks to use
    the positives afforded to us with microservices to our benefit?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Managing microservices
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you may be asking yourself "so, where does Docker fit into this
    conversation?" Our first tongue in cheek answer is that it fits in perfectly,
    indeed!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is excellent for microservices as it isolates containers to one process
    or service. This intentional containerization of single services or processes
    makes it very simple to manage and update these services. Therefore, it''s not
    surprising that the next wave on top of Docker has led to the emergence of frameworks
    for the sole purpose of managing more complex scenarios, including as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: How to manage single services in a cluster?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage multiple instances in a service across hosts?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to coordinate between multiple services on a deployment and management level?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As expected within a maturing container market, we are seeing additional complementary
    tools emerge to go along with open source projects, such as Kubernetes, MaestroNG,
    and Mesos to only name but a few-all arising to address the management, orchestration,
    and automation needs for containerized applications with Docker. Kubernetes, as
    an example, is a project built especially for microservices and works extremely
    well with Docker. The key features of Kubernetes cater directly to the exact traits
    so imperative within the microservices architecture-easy deployment of new services
    via Docker, independent scaling of services, end-client transparency to failures,
    and simple, ad-hoc name-based discovery of service endpoints. Further, Docker's
    own native projects-Machine, Swarm, Compose, and Orca, while currently still in
    beta at the time of this writing, look highly promising-will likely soon be added
    to the Docker core kernel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Since we will later dedicate examples and discussion to Kubernetes, other third-party
    applications and an entire chapter to Docker Machine, Swarm, and Compose, let's
    look at an example here utilizing services we used earlier (NGINX, Node.js) along
    with Redis and Docker Compose.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Real-world example
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NGINX > Node.js > Redis > Docker Compose
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will delve more thoroughly into Docker Compose in [Chapter 10](ch10.html
    "Chapter 10. Docker Deployment in a Public Cloud - AWS and Azure"), *Docker Machine,
    Compose and Swarm*. Additionally, we will also need to implement a service discovery
    mechanism (discussed in a later chapter) that enables a service to discover the
    locations (hosts and ports) of any other services it needs to communicate with.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests and deployments
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want as much confidence as possible that our applications are working; that
    starts with automated testing to facilitate our automated deployments. Needless
    to say, our automated tests are mission-critical. Promotion of working software
    *up* the pipeline means we automate deployment to each new environment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The testing of microservices right now is still relatively complex; as we've
    discussed, test classes for a service will require a launch of that service in
    addition to any services it depends upon. We at least need to configure stubs
    for those services. All this can be done, but let's look into mitigating its complexity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strategically, we need to map out our design flow to include testing to validate
    our applications for deployment into production. Here''s an example workflow of
    what we want to accomplish with our automated testing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated testing](graphics/image_04_006.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram represents a DevOps pipeline starting with code compilation
    and moving to integration test, performance test and, finally, the app getting
    deployed in a production environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Designing for failure
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to succeed, we must accept failures as a very real possibility. In
    fact, we really ought to be purposefully inserting failures into our application
    design flow to test how we can successfully deal with them when they occur. This
    kind of automated testing in production initially requires nerves of steel; however,
    we can derive automation that is self-healing through repetition and familiarity.
    Failures are a certainty; therefore, we must plan and test our automation for
    mitigating the damages of such a certainty.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Successful application design involves built-in fault tolerances; this is particularly
    true of microservices as a consequence of using services as components. Since
    services can fail at any time, it's important to be able to detect the failures
    quickly and, if possible, automatically restore service. Real-time monitoring
    of our application is of critical emphasis across microservice applications, providing
    an early warning system of either issues actually occurring or those showing potential
    for error or problems. This affords an earlier response among development teams
    to follow up and investigate; because there is such choreography and event collaboration
    in a microservices architecture, our ability to track emergent behaviors becomes
    rather vital.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservice teams should, therefore, design to include some minimums for monitoring
    and logging setups for each individual service: dashboards with up/down status,
    metadata on circuit breaker status, current throughput, and latency and a variety
    of operational and business relevant metrics.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: At the end of our application builds, should our components not compose cleanly,
    we have accomplished little more than shifting complexity from inside a component
    to the connections between them. This puts things into areas harder to define
    and more difficult to control. Ultimately, we should design for the inevitability
    of failures to be successful.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Dockunit for unit tests
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To enhance our unit testing capabilities, we will also install and use **Dockunit**
    to deliver our unit testing. There are plenty of options available to us for our
    unit tests. In mixing and matching different tools to accomplish unit testing
    in the past, I have found that by deploying Dockunit as a *stock and standard*
    application in my development toolkit, I can meet almost any unit test needs with
    this utility. So as not to be too repetitive, let's go ahead and set up for automated
    testing using Dockunit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Dockunit requirements are Node.js, npm, and Docker.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'If not already installed, install npm(we will assume installation of both Docker
    and Node.js):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can use Dockunit to easily test our Node.js applications. This is done
    simply via a `Dockunit.json` file; to follow is a sample that tests an application
    in Node.js 0.10.x and 0.12.0 using `mocha`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code snippet shows how easily an application can be unit tested
    inside the docker container.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Automated deployments
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One approach to automation is to use an off-the-shelf PaaS (for example, Cloud
    Foundry or Tutum, and so on). A PaaS provides developers with an easy way to deploy
    and manage their microservices. It insulates them from concerns such as procuring
    and configuring IT resources. At the same time, the systems and network professionals
    who configure the PaaS can ensure compliance with best practices and company policies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Another way to automate the deployment of microservices is to develop what is
    essentially your own PaaS. One typical starting point is to use a clustering solution,
    such as Mesos or Kubernetes, in conjunction with a technology, such as Docker.
    Later in this book, we will review how software-based application delivery approaches
    like NGINX, which easily handles caching, access control, API metering, and monitoring
    at the microservice level can help solve this problem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling N-tier applications into multiple images
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decomposing applications improves deployability and scalability and simplifies
    the adoption of new technologies. To achieve this level of abstraction, the application
    must be fully decoupled from the infrastructure. Application containers, such
    as Docker, provide a way to decouple application components from the infrastructure.
    At this level, each application service must be elastic (that is, it can scale
    up and down independently of other services) and resilient (that is, it has multiple
    instances and can survive instance failures). The application should also be designed
    so that failures in one service do not cascade to other services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve done entirely too much talking, and not enough doing. Let''s get at
    what we really need to know-how to build it! We can easily use our `cloudconsulted/wordpress`
    image here to show an example of our decoupling into separate containers: one
    for WordPress, PHP, and MySQL. Instead, let''s explore other applications to continue
    to show the range of capabilities and potential for application deployments that
    we can make with Docker; for this example, a simple LEMP stack'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Building an N-tier web application
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LEMP stack (NGINX > MySQL > PHP)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplification, we will split this LEMP stack across two containers: one
    for MySQL and the other for NGINX and PHP, each utilizing an Ubuntu base:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A second container will install and house NGINX and PHP:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Making different tiers of applications work
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From our real-world production examples, we have already seen several different
    ways in which we can make different application tiers work together. Since discussion
    on making interoperable tiers workable within the application all depend upon
    the application tiers being deployed, we can continue on *ad-infinitum* as to
    how to do this; one example leading to another, and so on. Instead, we will delve
    into this area more thoroughly in [Chapter 06](ch06.html "Chapter 6. Making Containers
    Work"), *Making Containers Work*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are the vehicle for modern microservices architectures; the use of
    containers provides not some wild and imaginative advantages when coupled with
    microservices and N-tier architectural styles, but workable production-ready solutions.
    In many ways, the use of containers to implement a microservices architecture
    is an evolution not unlike those observed over the past 20 years in web development.
    Much of this evolution has been driven by the need to make better use of compute
    resources and the need to maintain increasingly complex web-based applications.
    For modern application development, Docker is a veritable and forceful weapon.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, the use of a microservices architecture with Docker containers addresses
    both these needs. We explored example environments designed seamlessly from development
    to test, eliminating the need for manual and error-prone resource provisioning
    and configuration. In doing so, we touched briefly on how a microservice application
    can be tested, automated, deployed, and managed, but the use of containers in
    distributed systems goes far beyond microservices. Increasingly, containers are
    becoming "first class citizens" in all distributed systems and, in the upcoming
    chapters, we'll discuss how tools such as Docker Compose and Kubernetes are essential
    for managing container-based computing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
