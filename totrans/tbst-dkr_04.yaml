- en: Chapter 4. Devising Microservices and N-Tier Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s expand on what we saw and learned in the last chapter about the more
    advanced development and deployment of microservices and N-tier applications.
    This chapter will address the underlying architectures for these design approaches
    as well as resolve typical issues faced while building these types of applications.
    We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architectural pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: N-tier application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and automating N-tier applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices architectural pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and automating microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling multi-tier applications into multiple images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making different tiers of applications work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, modern software built as services are giving rise to a shift in how
    applications are designed. Instead of using web frameworks to invoke services
    and produce web pages, applications today are built by consuming and producing
    APIs. Much has changed in the development and deployment of business applications,
    some of it dramatically and some of it either by revision or extension from the
    past design approaches, depending upon your viewpoint. Several architectural design
    approaches exist, and they are distinguishable by applications built for enterprise
    versus web versus Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Development trends, over the last few years in particular, are awash with terms
    such as **microservices architecture** (**MSA**), applicable to a particular way
    of application design and development as suites of independently deployable services.
    The meteoric rise of the microservices architectural style is clearly an irrefutable
    force in today's development for deployment; there has been a considerable shift
    away from monolithic architecture and toward N-tier applications and microservices,
    but just how much of this is hype and how much of this can be honed?
  prefs: []
  type: TYPE_NORMAL
- en: Hype or hubris
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin diving deeply into troubleshooting, we ought to provide a basic contextual
    overview of modern applications and both the N-tier and microservices architectural
    styles. Knowing both the advantages and limitations of these architectural styles
    will help us plan for potential troubleshooting areas, and how we can avoid them.
    Containers are ideally suited for both of these architectural approaches, and
    we will discuss each one separately to give their proper due.
  prefs: []
  type: TYPE_NORMAL
- en: Within all the noise, we sometimes forget that to deploy systems across these
    domains, one still has to create services and compose multiple services in working
    distributed applications. Here, it is important to understand the modern meaning
    of the term application. Applications are now primarily constructed as asynchronous
    message flows or synchronous request calls (if not both) that serve in forming
    collections of components or services allied by these connections. Participating
    services are highly distributive across variant machines and diverse Clouds (private,
    public, and hybrid).
  prefs: []
  type: TYPE_NORMAL
- en: As for architectural styles, we shan't bother ourselves with too much comparison
    or engage in overly detailed discussions on what microservices actually are and
    whether they are any different from **Service-Oriented Architecture** (**SOA**)-there
    is certainly plenty of forum and related debate elsewhere for your choosing. With
    design principles rooted at least as far back as Unix, we will proffer no authoritative
    viewpoints in this book that the current microservices trend is either conceptually
    singular or entirely ingenious. Instead, we will put forward the major considerations
    for implementing this architectural approach and the benefits to be gained for
    modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use case still drives and dictates architectural approaches (or, in my opinion,
    should), and as such there is value in making some degree of comparative analysis
    among all predominant architectural styles: **monolithic**, **N-tier**, and **microservices**.'
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monoliths are essentially one deployment unit housing all services and dependencies,
    making them easy to develop, easy to test, relatively easy to deploy and, initially,
    easy to scale. However, this style does not meet the requisite needs for most
    modern enterprise applications (N-tier) and web development at scale, and certainly
    not (microservices) applications being deployed to the Cloud. Change cycles are
    tightly coupled-any changes made, even to the smallest parts of an application,
    require wholesale rebuilds and redeployments for the entire monolith. As the monolith
    matures, any attempts at scaling require scaling of the entire application rather
    than the individual parts, which specifically require greater resources, becoming
    altogether nightmarish, if not improbable. At this point, a monolithic application
    has become overly complex, weighted with vast lines of code that is ever-increasingly
    difficult to decipher, such that business-critical items like bug fixes or implementing
    new features become too much of a time drain to ever attempt. As the code base
    becomes unintelligible, it is only reasonable to expect any changes made likely
    to be done incorrectly. The burgeoning size of the application not only slows
    development, it impedes continuous development altogether; to update any part
    of a monolith, the entire app must be redeployed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Monolithic architecture](graphics/Untitled.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monolithic architectural pattern
  prefs: []
  type: TYPE_NORMAL
- en: Other problems with monoliths abound, resources cannot be catered to better
    meet needs, for example, CPU or memory requirements. Since all modules are running
    the same processes, any bug can potentially bring the entire process to a halt.
    Lastly, it becomes much more difficult to adopt newer frameworks or languages,
    creating a huge barrier to adopt new technologies-you are likely stuck with whatever
    technology choices you made at the beginning of the project. Needless to say,
    your needs may have changed rather dramatically since the beginning. Using obsolete,
    unproductive technology makes keeping and bringing in new talent more difficult.
    The application has now become very difficult to scale and is unreliable, making
    agile development and delivery of applications impossible. The initial ease and
    simplicity of a monolith quickly become its own Achilles heel.
  prefs: []
  type: TYPE_NORMAL
- en: As these monolithic architectures are basically one deployment unit that does
    everything–N-tier and microservices architectures have arisen to address the specialized
    service needs of modernized applications, primarily Cloud and mobile-based.
  prefs: []
  type: TYPE_NORMAL
- en: N-tier application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand N-tier applications and their potential for decoupling
    into microservices, we will hold its comparison against the monolithic style since
    both the development of N-tier applications and proliferation of microservices
    exist to address many of the problems found in the outdated conditions we've found
    resulting from the approach of monolithic architectures.
  prefs: []
  type: TYPE_NORMAL
- en: The N-tier application architecture, also referred to as **distributed applications**
    or **multi-tier**, proffers a model in which developers can create flexible and
    reusable applications. As the application is segregated into tiers, developers
    are empowered by the option of modifying or adding a specific tier or layer instead
    of requiring a rework of the entire application as would be necessary under monolithic.
    A multi-tier application is any application developed and distributed among more
    than one layer. It logically separates the different application-specific and
    operational layers. The number of layers varies by business and application requirements,
    but three-tier is the most commonly used architecture. Multi-tier applications
    are used to divide enterprise applications into two or more components that may
    be separately developed, tested, and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: N-tier applications are essentially SOA that attempt to address some of the
    issues with antiquated monolothic design architecture. As we have seen in the previous chapters,
    Docker containers are a perfect match for N-tier application development.
  prefs: []
  type: TYPE_NORMAL
- en: '![N-tier application architecture](graphics/Untitled-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: N-tier application architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'A common N-tier application consists of three layers: a **PRESENTATION TIER**
    (providing basic user interface and application services access), a **DOMAIN LOGIC
    TIER** (providing the mechanism used to access and process data), and a **DATA
    STORAGE TIER** (which holds and manages data that is at rest).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the concepts of layer and tier are often used interchangeably, a fairly
    common point of view is that there is actually a difference. This view holds that
    a *layer* is a logical structuring mechanism for the elements that make up the
    software solution, while a *tier* is a physical structuring mechanism for the
    system infrastructure. Unless otherwise specifically noted in our book, we will
    use tier and layer interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to separate the various tiers in an N-tier application is to
    create discrete projects for each tier that you want to include in your application.
    For example, the presentation tier might be a Windows forms application, whereas
    the data access logic might be a class library located in the middle tier. Additionally,
    the presentation layer might communicate with the data access logic in the middle
    tier through a service. Separating application components into separate tiers
    increases the maintainability and scalability of the application. It does this
    by enabling easier adoption of new technologies that can be applied to a single
    tier without the requirement to redesign the whole solution. In addition, N-tier
    applications typically store sensitive information in the middle tier, which maintains
    isolation from the presentation tier.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most common example of N-tier app development is websites; an example
    of this can be seen in the `cloudconsulted/joomla` image we used in the last chapter,
    where Joomla, Apache, MySQL, and PHP were all *layered* as tiers into a single
    container.
  prefs: []
  type: TYPE_NORMAL
- en: It will be easy enough for us to simply recursively use our `cloudconsulted/joomla`
    image (from earlier) here, but let's build a classic three-tiered web application
    to expose ourselves to some other application potential as well as introduce another
    unit test tool for our development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Building a three-tier web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s develop and deploy a real-world three-tier web application with the
    help of the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NGINX > Ruby on Rails > PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NGINX Docker container (Dockerfile), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ruby on Rails Docker container (Dockerfile), as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The PostgreSQL Docker container, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Dockerfiles can be used to deploy a three-tier web application
    and help us get started with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin explaining the microservice architectural style, it will prove beneficial
    to again compare to the monolithic, as we did with N-tier. As you may recall,
    a monolithic application is constructed as a single unit. Also, recall that monolithic
    enterprise applications are often built around three primary tiers: a client-side
    user interface (comprising of HTML pages and JavaScript running in a browser on
    the user''s machine), a database (comprising of many tables inserted into a common,
    and usually relational, database management system), and a server-side application
    (which handles HTTP requests, executes domain logic, retrieves and updates data
    from the database, and selects and populates HTML views to be sent to the browser).
    This classic version of a monolithic enterprise application is a single, logical
    executable. Any changes to the system involve building and deploying a new version
    of the server-side application, and changes in the underlying technology are likely
    not prudent.'
  prefs: []
  type: TYPE_NORMAL
- en: The path to modernity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microservices represent the convergence of the modern Cloud and modern application
    development, structured around the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Componentized services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organization around business capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products, not projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart endpoints and dumb pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized governance and data management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, monolithic typically focuses on **enterprise service bus** (**ESB**) used
    to integrate monolithic applications, modern application design is API driven.
    These modern applications embrace APIs on all sides: on the frontend for connecting
    to rich clients, the backend for integrating with internal systems, and on the
    sides to allow other applications access to their internal data and processes.
    Rather than leveraging the more complicated traditional enterprise mechanisms,
    many developers are finding that the same lightweight API services that have proven
    to be resilient, scalable, and agile for frontend, backend, and application-to-application
    scenarios can also be leveraged for application assembly. What is also compelling
    is that containers, and especially so within a microservices architectural approach,
    alleviate the perennial issue of developers being blocked out of architectural
    decisions while still realizing the benefits of repeatability. The use of preapproved
    container configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architectural pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we illustrate that instead of a single, monstrous monolithic application,
    we have split the application into smaller, interconnected services (that is,
    microservices) that implement each functional area of the application. This allows
    us to deploy directly to address the needs of specialized use cases or specific
    devices or users /or/ the microservices approach, in a nutshell, dictates that
    instead of having one giant code base that all developers touch, which often becomes
    perilous to manage, there are numerous smaller code bases managed by small and
    agile teams. The only dependency these code bases have on one another is their
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices architectural pattern](graphics/Untitled-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservices architectural pattern
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common discussion around microservices is debate over whether this is just
    SOA. Some validity exists on this point as the microservice style does share some
    of the advocacies of SOA. In reality, SOA means a host of many different things.
    As such, we submit and will attempt to show that while shared similarities do
    exist, SOA remains significantly different from the microservices architectural
    style as presented herein.
  prefs: []
  type: TYPE_NORMAL
- en: Common characteristics of microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we will not attempt a formal definition of the microservices architectural
    style, there are some common characteristics we can certainly use to identify
    it. Microservices are generally designed around business capabilities and priorities
    and include multiple component services that can be automated for deployment independently
    without compromising the application, intelligence endpoints, and decentralized
    control of languages and data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide some basis then, if not common ground, to follow is an outline that
    can be seen as the common characteristics for architectures that fit the *microservices*
    label. It should be understood that not all microservice architectures will exhibit
    all characteristics at all times. Since we do, however, have expectations that
    most microservice architectures will exhibit most of these characteristics, let''s
    list them:'
  prefs: []
  type: TYPE_NORMAL
- en: Independent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interchangeable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The common characteristics of microservices we just listed also serve to itemize
    their advantages. Without meaning to belabor the issue over too much redundancy,
    let''s at least canvass the main advantage points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices enforce a level of modularity**: This is extremely difficult
    to accomplish in practice with a monolithic architecture. The microservices advantage
    is that individual services are much faster to develop, much easier to understand,
    and much easier to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices enable each service to be developed independently**: This is
    done by teams specifically focused on that service. The microservices advantage
    is empowering developers with the freedom to choose whatever technology is best
    suited or makes better sense, so long as that service honors the API contract.
    By default, this also means that developers are no longer trapped with potentially
    obsolete technologies from a project''s beginning, or when starting a new project.
    Not only does an option exist to employ the current technology, but with a relatively
    small service size it is also now feasible to rewrite older services using a more
    relevant and reliable technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices enable each service to be deployed continuously**: Developers
    needn''t coordinate the deployment of changes that are localized to their service.
    The microservices advantage is in continuous deployment-deployment takes place
    as soon as changes are successfully tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices enable each service to be scaled independently**: You need
    to deploy only the instances of each service necessary to satisfy the capacity
    and availability constraints. Additionally, we can also succinctly match the hardware
    to fulfill a service''s resource requirements (for example, compute or memory
    optimized hardware for CPU and memory-intensive services). The microservices advantage
    is in not only matching capacity and availability, but leveraging user-specific
    hardware optimized for a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these advantages are extremely advantageous, but for the next bit let's
    elaborate on the point of scalability. As we've seen with monolithic architectures,
    while easy to initialize scaling, it is certainly deficient in executing it over
    time; bottlenecks abound and, eventually, it's approach to scaling is vastly untenable.
    Fortunately, microservices as an architectural style supremely excels at scaling.
    A quintessential book, *THE ART OF SCALABILITY* ([http://theartofscalability.com/](http://theartofscalability.com/)) illustrates
    a highly useful, three-dimensional model of scalability in a *scale cube* ([http://microservices.io/articles/scalecube.html](http://theartofscalability.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Microservices at scalability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the provided model, along the X-axis scaling (that is, Monolothic) we can
    see the common horizontal duplication approach, scaling an application by running
    multiple, cloned copies of that application behind a load balancer. This results
    in improved application capacity and availability.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices at scalability](graphics/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservices at scalability
  prefs: []
  type: TYPE_NORMAL
- en: Moving along the Z-axis for scaling (that is N-tier/SOA), each server runs identical
    copies of code (similar to X-axis). The difference here comes in that each server
    is responsible solely for a strict subset of the data (that is, data partitioning
    or scaling by splitting into similar things). A given component of the system
    therefore has responsibility for routing a given request to an appropriate server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sharding** is a commonly used routing criteria where an attribute of the
    request is used to route the request to a particular server (for example, the
    primary key of a row or identity of a customer).'
  prefs: []
  type: TYPE_NORMAL
- en: Just as with X-axis scaling, Z-axis scaling serves to improve application capacity
    and availability. However, as we learned in this chapter, neither the monolithic
    or N-tier approach (X- and Y-axis scaling) will resolve the inherent problems
    of our ever-increasing development and application complexities. To effectively
    deal with these issues, we need to apply Y-axis scaling (that is, microservices).
  prefs: []
  type: TYPE_NORMAL
- en: This third dimension to scaling (Y-axis) involves functional decomposition,
    or scaling by splitting into different things. Occurring at the application tier,
    Y-axis scaling will split a monolithic application into separate sets of services
    wherein each service implements a set of allied functionalities (for example,
    customer management, order management, and so on). Later in this chapter, we will
    look directly into the decomposition of services.
  prefs: []
  type: TYPE_NORMAL
- en: What we can typically see are applications that utilize all the three axes of
    the scaling cube together. Y-axis scaling decomposes the application into microservices;
    at runtime, X-axis scaling executes multiple instances of each service behind
    a load balancer for enhanced output and availability, and some applications may
    additionally use Z-axis scaling for partition of services.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s do our full due diligence here by also understanding some of the disadvantages
    of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying a microservices-based application is much more complex**: In contrast
    to monolithic applications, a microservice application typically consists of a
    large number of services. Defacto, we have greater complexity in deploying them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management and orchestration of microservices is much more complex**: Each
    service, within a large number of services, will have multiple runtime instances.
    An exponential increase occurs across many more moving parts that require configuration,
    deployment, scaling, and monitoring. Any successful microservices deployment,
    therefore, requires more granular control of deployment methods by developers
    combined with a high level of automation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing a microservices application is much more complex**: Writing test
    classes for a microservices application does not only require that service to
    be started, but also its dependency services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once understood, we can strategize and design to mitigate these drawbacks and
    better plan for troubleshooting areas.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for devising microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have reviewed the transgression from single delivery to multi-tier to containerized
    microservices, and understand that each has its own functional place for application.
    Each architecture carries its own degree of validity; appropriate design strategy
    and application of these architectures is necessary for your deployment successes.
    Having learned the basic tenets for monolithic, N-tier, and microservices, we
    are better equipped toward strategically implementing the best-suited architectures
    on a per use case basis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Considerations for devising microservices](graphics/Untitled-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From mono to micro
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architectural pattern is a better choice for complex, evolving
    applications despite the drawbacks and implementation challenges. To utilize microservices
    for modern Cloud and web application design and deployment, how best do we leverage
    the advantages of microservices while mitigating the potential drawbacks?
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether developing a new application or reinvigorating an old one, these considerations
    must be taken into account for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and maintaining highly available distributed systems is complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More moving parts means more components to keep track of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled services means that steps need to be taken to keep data consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed asynchronous processes create network latency and more API traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and monitoring individual services is challenging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigating the disadvantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is likely the most simplistic instruction provided in the entire book;
    however, time and again we witness the obvious either completely ignored, overlooked,
    or underpursued. Our submission here is that, in spite of the relatively few but
    known disadvantages, there exist both current and evolving mechanisms to resolve
    almost all of these issues; expectation is strong that the container market will
    evolve a plethora of working solutions to the current issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, let''s just start with the most basic elements here as the foundation
    of successful microservices applications that require less troubleshooting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Take total ownership**: Without taking full ownership and knowing that ultimate
    success is directly up to you and your team, your projects and their resulting
    applications will suffer. Commitment, dedication, and persistence pay handsome
    results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Develop a complete understanding**: Fully comprehend what the business goals
    are and what technologies can be best applied to address them, not to mention
    the *how* and *why* for which you are using them. Always be learning!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pursue exhaustive, coordinated planning**: Plan strategically, plan along with
    other application stakeholders, plan for failure, and then plan some more; Measure
    your results and revise the plan, re-evaluating the plan on a continuum. Always
    be measuring, and always be planning!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize the current technology**: It is imperative in today''s technology
    climate to make good use of the most stable and functional tools and applications;
    so, seek them out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evolve with the application**: You must be as agile and adaptable as the
    container technologies you are using; change must be an accepted part of your
    exhaustive, coordinated planning!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great! We know that we must not only acknowledge, but actively participate in
    the most basic elements of our application project process. We also know and understand
    the advantages and disadvantages of a microservices architectural approach, and
    that those advantages have the potential to far outweigh any negatives. Outside
    of the preceding five powerful items, how do we mitigate these drawbacks to use
    the positives afforded to us with microservices to our benefit?
  prefs: []
  type: TYPE_NORMAL
- en: Managing microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you may be asking yourself "so, where does Docker fit into this
    conversation?" Our first tongue in cheek answer is that it fits in perfectly,
    indeed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is excellent for microservices as it isolates containers to one process
    or service. This intentional containerization of single services or processes
    makes it very simple to manage and update these services. Therefore, it''s not
    surprising that the next wave on top of Docker has led to the emergence of frameworks
    for the sole purpose of managing more complex scenarios, including as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to manage single services in a cluster?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage multiple instances in a service across hosts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to coordinate between multiple services on a deployment and management level?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As expected within a maturing container market, we are seeing additional complementary
    tools emerge to go along with open source projects, such as Kubernetes, MaestroNG,
    and Mesos to only name but a few-all arising to address the management, orchestration,
    and automation needs for containerized applications with Docker. Kubernetes, as
    an example, is a project built especially for microservices and works extremely
    well with Docker. The key features of Kubernetes cater directly to the exact traits
    so imperative within the microservices architecture-easy deployment of new services
    via Docker, independent scaling of services, end-client transparency to failures,
    and simple, ad-hoc name-based discovery of service endpoints. Further, Docker's
    own native projects-Machine, Swarm, Compose, and Orca, while currently still in
    beta at the time of this writing, look highly promising-will likely soon be added
    to the Docker core kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will later dedicate examples and discussion to Kubernetes, other third-party
    applications and an entire chapter to Docker Machine, Swarm, and Compose, let's
    look at an example here utilizing services we used earlier (NGINX, Node.js) along
    with Redis and Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NGINX > Node.js > Redis > Docker Compose
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will delve more thoroughly into Docker Compose in [Chapter 10](ch10.html
    "Chapter 10. Docker Deployment in a Public Cloud - AWS and Azure"), *Docker Machine,
    Compose and Swarm*. Additionally, we will also need to implement a service discovery
    mechanism (discussed in a later chapter) that enables a service to discover the
    locations (hosts and ports) of any other services it needs to communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests and deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want as much confidence as possible that our applications are working; that
    starts with automated testing to facilitate our automated deployments. Needless
    to say, our automated tests are mission-critical. Promotion of working software
    *up* the pipeline means we automate deployment to each new environment.
  prefs: []
  type: TYPE_NORMAL
- en: The testing of microservices right now is still relatively complex; as we've
    discussed, test classes for a service will require a launch of that service in
    addition to any services it depends upon. We at least need to configure stubs
    for those services. All this can be done, but let's look into mitigating its complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strategically, we need to map out our design flow to include testing to validate
    our applications for deployment into production. Here''s an example workflow of
    what we want to accomplish with our automated testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated testing](graphics/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram represents a DevOps pipeline starting with code compilation
    and moving to integration test, performance test and, finally, the app getting
    deployed in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for failure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to succeed, we must accept failures as a very real possibility. In
    fact, we really ought to be purposefully inserting failures into our application
    design flow to test how we can successfully deal with them when they occur. This
    kind of automated testing in production initially requires nerves of steel; however,
    we can derive automation that is self-healing through repetition and familiarity.
    Failures are a certainty; therefore, we must plan and test our automation for
    mitigating the damages of such a certainty.
  prefs: []
  type: TYPE_NORMAL
- en: Successful application design involves built-in fault tolerances; this is particularly
    true of microservices as a consequence of using services as components. Since
    services can fail at any time, it's important to be able to detect the failures
    quickly and, if possible, automatically restore service. Real-time monitoring
    of our application is of critical emphasis across microservice applications, providing
    an early warning system of either issues actually occurring or those showing potential
    for error or problems. This affords an earlier response among development teams
    to follow up and investigate; because there is such choreography and event collaboration
    in a microservices architecture, our ability to track emergent behaviors becomes
    rather vital.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservice teams should, therefore, design to include some minimums for monitoring
    and logging setups for each individual service: dashboards with up/down status,
    metadata on circuit breaker status, current throughput, and latency and a variety
    of operational and business relevant metrics.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of our application builds, should our components not compose cleanly,
    we have accomplished little more than shifting complexity from inside a component
    to the connections between them. This puts things into areas harder to define
    and more difficult to control. Ultimately, we should design for the inevitability
    of failures to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Dockunit for unit tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To enhance our unit testing capabilities, we will also install and use **Dockunit**
    to deliver our unit testing. There are plenty of options available to us for our
    unit tests. In mixing and matching different tools to accomplish unit testing
    in the past, I have found that by deploying Dockunit as a *stock and standard*
    application in my development toolkit, I can meet almost any unit test needs with
    this utility. So as not to be too repetitive, let's go ahead and set up for automated
    testing using Dockunit.
  prefs: []
  type: TYPE_NORMAL
- en: Dockunit requirements are Node.js, npm, and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not already installed, install npm(we will assume installation of both Docker
    and Node.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use Dockunit to easily test our Node.js applications. This is done
    simply via a `Dockunit.json` file; to follow is a sample that tests an application
    in Node.js 0.10.x and 0.12.0 using `mocha`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows how easily an application can be unit tested
    inside the docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Automated deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One approach to automation is to use an off-the-shelf PaaS (for example, Cloud
    Foundry or Tutum, and so on). A PaaS provides developers with an easy way to deploy
    and manage their microservices. It insulates them from concerns such as procuring
    and configuring IT resources. At the same time, the systems and network professionals
    who configure the PaaS can ensure compliance with best practices and company policies.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to automate the deployment of microservices is to develop what is
    essentially your own PaaS. One typical starting point is to use a clustering solution,
    such as Mesos or Kubernetes, in conjunction with a technology, such as Docker.
    Later in this book, we will review how software-based application delivery approaches
    like NGINX, which easily handles caching, access control, API metering, and monitoring
    at the microservice level can help solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling N-tier applications into multiple images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decomposing applications improves deployability and scalability and simplifies
    the adoption of new technologies. To achieve this level of abstraction, the application
    must be fully decoupled from the infrastructure. Application containers, such
    as Docker, provide a way to decouple application components from the infrastructure.
    At this level, each application service must be elastic (that is, it can scale
    up and down independently of other services) and resilient (that is, it has multiple
    instances and can survive instance failures). The application should also be designed
    so that failures in one service do not cascade to other services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve done entirely too much talking, and not enough doing. Let''s get at
    what we really need to know-how to build it! We can easily use our `cloudconsulted/wordpress`
    image here to show an example of our decoupling into separate containers: one
    for WordPress, PHP, and MySQL. Instead, let''s explore other applications to continue
    to show the range of capabilities and potential for application deployments that
    we can make with Docker; for this example, a simple LEMP stack'
  prefs: []
  type: TYPE_NORMAL
- en: Building an N-tier web application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LEMP stack (NGINX > MySQL > PHP)
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplification, we will split this LEMP stack across two containers: one
    for MySQL and the other for NGINX and PHP, each utilizing an Ubuntu base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A second container will install and house NGINX and PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Making different tiers of applications work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From our real-world production examples, we have already seen several different
    ways in which we can make different application tiers work together. Since discussion
    on making interoperable tiers workable within the application all depend upon
    the application tiers being deployed, we can continue on *ad-infinitum* as to
    how to do this; one example leading to another, and so on. Instead, we will delve
    into this area more thoroughly in [Chapter 06](ch06.html "Chapter 6. Making Containers
    Work"), *Making Containers Work*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are the vehicle for modern microservices architectures; the use of
    containers provides not some wild and imaginative advantages when coupled with
    microservices and N-tier architectural styles, but workable production-ready solutions.
    In many ways, the use of containers to implement a microservices architecture
    is an evolution not unlike those observed over the past 20 years in web development.
    Much of this evolution has been driven by the need to make better use of compute
    resources and the need to maintain increasingly complex web-based applications.
    For modern application development, Docker is a veritable and forceful weapon.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, the use of a microservices architecture with Docker containers addresses
    both these needs. We explored example environments designed seamlessly from development
    to test, eliminating the need for manual and error-prone resource provisioning
    and configuration. In doing so, we touched briefly on how a microservice application
    can be tested, automated, deployed, and managed, but the use of containers in
    distributed systems goes far beyond microservices. Increasingly, containers are
    becoming "first class citizens" in all distributed systems and, in the upcoming
    chapters, we'll discuss how tools such as Docker Compose and Kubernetes are essential
    for managing container-based computing.
  prefs: []
  type: TYPE_NORMAL
