- en: Chapter 7. Best Practices in PHP Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we discussed performance-related topics. Now, in this chapter, we will
    study best practices in PHP applications' development and deployment. This is
    a vast topic, but we will cover it briefly. PHP provides all levels of programmers
    with the ability to write quality code easily and quickly. However, when the application
    advances to a more complex nature, we forget to follow the best practices. To
    produce a high performance PHP application, it is necessary to keep in mind the
    performance at every line of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service-oriented architecture (SOA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development (TDD) and PHPUnit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control systems and Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are too many coding styles out there, such as PSR-0, PSR-1, PSR-2, PSR-3,
    and so on. Programmers can use different standards as they want, but it is necessary
    to follow a standard that is already used in the libraries or a framework in use
    to make the code more readable. For example, Laravel uses the PSR-1 and PSR-4
    coding standards, so if we are developing in Laravel, we should follow these coding
    standards. Some PHP frameworks, such as Yii 2 and **Zend Framework 2**, follow
    the PSR-2 coding standards. However, none of these frameworks stick to a single
    standard; most of them follow a mixed standard according to their requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The important point is to follow the standard that is used in the libraries
    used in the application. An organization can also use its own coding standards
    for internal purposes. It is not a requirement for coding; it is a requirement
    for readability and producing quality code that others can understand.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP Framework Interop Group** (**PHP-FIG**) is a group whose members defined
    coding standards for PHP. Full details about PSR standards can be found on their
    website at [http://www.php-fig.org/](http://www.php-fig.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of discussing a specific coding standard, let''s discuss best practices
    in coding styles for PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first letter of each word in the class name must be capital. The opening
    brace should be on the line after the class declaration, and the closing brace
    should be on the line after the class end line. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Class methods and function names should follow the camel case naming convention.
    The starting braces should be on the next line of the class declaration, and the
    end brace should be on the line at the end of the function definition. There should
    be no spaces between the method name and the parenthesis. Also, there should be
    no space between the first argument, the opening parenthesis, the last argument,
    and the closing parenthesis. Also, there should be no space between an argument
    and the comma at the end of this argument, but there should be a space between
    a comma and the next argument. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a namespace declaration, there must be a single empty line after
    its declaration. If there are use declarations, all of them must go after that
    namespace''s declarations. There must be one use declaration per line, and there
    must be a space after the use block. Also, the `extends` and `implements` keywords
    must be on the same line as the class declaration. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Visibility must be declared for all properties, and the properties must be
    in camel case. Also, properties must not be prepended with an underscore for private
    or protected visibilities. Take a look at the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is an `abstract` keyword, it must come before the `class` keyword
    for classes, and the `final` keyword must come before the method''s visibility
    in the case of methods. On the other hand, the `static` keyword must come after
    the method visibility. Take a look at this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All PHP keywords must be used in lowercase, including the `true` and `false`
    keywords. Constants must be declared and used in capital case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all control structures, there must be a space after the control structure
    keyword. If there is an expression for this control structure, there must be no
    space between the parenthesis holding this expression and the block of code that
    follows. There must be a space after the parenthesis and the starting brace. The
    starting brace must be on the same line as the control structure. The closing
    brace must be on the line after the end of the body. Refer to the following code
    for a better understanding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of loops, the spaces must be as in the following examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of this book, I did not follow the rule of the opening brace
    being on the same line as the control structure declaration and always used it
    on the next line of the declaration. I did not find it clearer; it is a personal
    choice, and anybody can follow the standards mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: Standards are good to follow as they make the code more readable and professional.
    However, never try to invent your own new standards; always follow those that
    are already invented and followed by the community.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development (TDD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-driven development is the process of testing every aspect of the application
    during development. Either the tests are defined before development and then development
    is made to pass these tests, or the classes and libraries are built and then tested.
    Testing the application is very important, and launching an application without
    tests is like jumping from a 30-floor-high building without a parachute.
  prefs: []
  type: TYPE_NORMAL
- en: PHP does not provide any built-in features to test, but there are other test
    frameworks that can be used for this purpose. One of most widely used frameworks
    or libraries is PHPUnit. It is a very powerful tool and provides lots of features.
    Now, let's have a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: The installation of PHPUnit is easy. Just download it and place it in your project
    root so that it can be accessed from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHPUnit installation and basic details, including features and examples, can
    be found at [https://phpunit.de/](https://phpunit.de/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a simple example. We have a `Book` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of a simple class that initializes the `title` property when
    the class is instantiated. When the `getBook` method is called, it returns the
    title of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to make a test in which we will check whether the `getBook` method
    returns `PHP 7` as a title. So, perform the following steps to create the test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `tests` directory at your project's root. Create a `BookTest.php` file
    in the `tests` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, place the following code in the `BookTest.php` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have written our first test. Note that we named our class `BookTest`,
    which extends the `PHPUnit_Framework_TestCase` class. We can name our test class
    whatever we want. However, the name should be easily recognizable so that we know
    this is written for the class that needs to be tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we added a method named `testBookClass`. We are also free to select whatever
    name we want to give to this method, but it should start with the word `test`.
    If not, PHPUnit will not execute the method and will issue a warning—in our case,
    for the preceding test class—that no tests were found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `testBookClass` method, we created an object of the `Book` class and
    passed `PHP 7` as our title. Then, we fetched the title using the `getBook` method
    of the `Book` class. The important part is the last line of the `testBookClass`
    method, which performs the assertion and checks whether the data returned from
    `getBook` is the desired data or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to run our first test. Open the command line or terminal
    in the root of the project and issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the command is executed, we will have an output similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test-driven development (TDD)](graphics/B05225_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our test is executed successfully as it met the criteria defined in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change our class a little bit and pass `PHP` to the `Book` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are looking for PHP 7, and our `Book` class returns `PHP`, so it does
    not pass our test. After executing this test, we will have a failure, as shown
    in the following screenshot:![Test-driven development (TDD)](graphics/B05225_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As seen in the preceding screenshot, we expected `PHP 7`, and we got an actual
    result of `PHP 7`. The `–` sign shows the expected value, and the `+` sign shows
    the actual value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous topic, we discussed how we can perform tests on our libraries.
    We only discussed a simple basic test. PHPUnit is not limited to these simple
    tests, but covering PHPUnit completely is out of the scope of this book. A very
    nice book on PHPUnit is *PHPUnit Essentials*, published by Packt Publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A design pattern solves a specific problem. It is not a tool; it is just a description
    or template that describes how to solve a specific problem. Design patterns are
    important, and they play a good role in writing clean and clear code.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely used design patterns in the PHP community is the **Model
    View Controller** (**MVC**) pattern. Most PHP frameworks are built upon this pattern.
    MVC advises you to keep the business logic and data operations (that is, the model)
    separate from the presentation (the view). Controllers just play the role of a
    middleman between models and views and make the communication between them possible.
    There is no direct communication between models and views. If a view needs any
    kind of data, it sends a request to the controller. The controller knows how to
    operate on this request and, if needed, make a call to the model to perform any
    operation on the data (fetch, insert, validate, delete, and so on). Then at last,
    the controller sends a response to the view.
  prefs: []
  type: TYPE_NORMAL
- en: In best practices, fat models and skinny controllers are used. This means that
    controllers are only used to take a specific action on a request and nothing else.
    Even in some modern frameworks, the validation is moved out of the controllers
    and is performed at the model level. These models perform all the operations on
    the data. In modern frameworks, models are considered as a layer, which can have
    multiple parts, such as the business logic, **Create Read Update Delete** (**CRUD**)
    database operations, data mapper pattern and services, and so on. So, a full load
    of models and controllers is just sitting there and enjoying the lazy work load.
  prefs: []
  type: TYPE_NORMAL
- en: Another widely used design pattern is the factory design pattern. This pattern
    simply creates objects that are needed to be used. Another good pattern is the
    observer pattern, in which an object calls different observers on a specific event
    or task on it. This is mainly used for event handling. Yet another widely used
    pattern is the **singleton pattern**, which is used when there is a requirement
    that only a single object of a class be used throughout the application's execution.
    *A singleton object can't be serialized and cloned*.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture (SOA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In service-oriented architecture, the application's components provide services
    to each other on a defined protocol. Each component is loosely coupled with each
    other, and the only way of communication between them is through the services
    they provide.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, Symfony provides the best way to have SOA as it is mainly an HTTP-centric
    framework. Symfony is the most mature, well-tested collection of libraries that
    are widely used by other PHP frameworks, such as Zend Framework, Yii, Laravel,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a scenario where we have a backend and a frontend for a website
    and a mobile application. Normally, in most applications, the backend and frontend
    run on the same code base and on a single access point, and an API or web service
    is built for mobile applications to communicate with this backend. It is good,
    but we need great. So, for high performance and scalable applications, the separate
    components run independently of each other. If they need to communicate with each
    other, they communicate through the web services.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are the central communication point between the frontend and backend
    and between the backend and mobile applications. The backend is the main hub of
    data and any other business logic. It can be standalone and built using any programming
    language, such as PHP. The frontend can be built using normal HTML/CSS, AngularJS,
    Node.js, jQuery, or any other technology for the frontend. Similarly, mobile apps
    can be native or built on cross-platform technologies. The backend doesn't care
    what the frontend and mobile apps are built on.
  prefs: []
  type: TYPE_NORMAL
- en: Being object-oriented and reusable always
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This may seem difficult for a small, single-page application in which only a
    few things are happening, but this is not the case. The classes are easy to handle,
    and the code is always clear. Also, the classes separate the application logic
    from the views. This make things more logical. In the earlier days when structure
    code was used and a bunch of functions had to be created either in the view files
    or in a separate file, this would have been too easy. However, when applications
    got more complex, it got more difficult to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Always try to create loosely coupled classes to make them more reusable in other
    applications. Also, always perform a single task in each method of the class.
  prefs: []
  type: TYPE_NORMAL
- en: PHP frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know about frameworks, and they are not essential to a programmer's life.
    There are lots of frameworks, and each framework has its own superiority over
    other frameworks in some features. All frameworks are good, but what make a framework
    not suitable for an application are the application's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to build an enterprise-level CRM application, which framework
    will suit us best? This is the most important, confusing, and time-wasting question.
    First, we need to know the complete requirements for the CRM application, usage
    capacity, features, data security, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Version control system (VCS) and Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version controller system provides the flexibility to properly maintain code,
    changes, and versions of the application. Using VCS, a complete team can work
    together on an application, and they can pull other team members' changes and
    their own changes to the system without any big troubles. In case of a disaster,
    VCS provides the ability to fall back to an old, more stable version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Oh wait! Are we talking about VCS? Did we mention Git? Nope! So, let's start
    with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Git is a powerful tool. It monitors changes in each file in a branch, and when
    pushed to a remote branch, only the changed files are uploaded. Git keeps a history
    of the file changes and provides you with the ability to compare the changed files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very informative and good book on Git is *Git Essentials* published by Packt
    Publishing. Also, an official and free book about Git can be found at [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2).
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and Continuous Integration (CI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP is obsolete. It is not feasible for today, it makes things slow, and a normal
    FTP connection is insecure. It is hard for a team to deploy their changes using
    FTP because it creates huge conflicts in their code and this may cause problems,
    while uploading changes and can override each other's changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Git versioning system, such as GitHub, GitLab, and Bitbucket, we can
    make our deployment automatic. Different developers use different setups for automatic
    deployments, and it all depends on their own choice and ease. The general rules
    of using automatic deployments are to make them easy for a team and to not use
    FTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a general flowchart for a deployment setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment and Continuous Integration (CI)](graphics/B05225_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding flowchart, we have two servers: the staging or testing
    the server and production server. On the staging server, we have an exact copy
    of the website to test new features and others, and the production server has
    our live website.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a repository that has two main branches: the master branch and
    the production branch. The master branch is used for development and testing purposes,
    and the production branch is used for final production features. Note that the
    production branch should only accept merging, and it should not accept commits
    so that the production environment is completely safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say that we want to add a customer registration feature to our
    application. We will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first and most important thing to do is to create a new branch from the
    production branch head. Let's name this branch `customer-registration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add all the new features to this `customer-registration` branch and while
    verifying on the local development server, merge this branch to the local master
    branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After merging the new branch to the local master branch, push the master branch
    to remote master branch. A successful push will cause the new features to be moved
    to the staging server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, test all the new features on the staging server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When everything works fine, merge the remote master branch with the remote production
    branch. This will cause all the changes to be moved to the production branch,
    and this merge will cause all the new changes to be moved to the production server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An ideal setup similar to the preceding one makes deployment very easy, and
    a complete team can work on the application regardless of the geographical location.
    In case any issue occurs during the deployment, one can be easily fall back to
    the old version of the production branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is a technique in which all the members
    of a team have to integrate their code into a shared repository, and then each
    check by the team member is verified by automatic builds to catch errors and problems
    in the early stages.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools that are used for CI for PHP; some of these are PHPCI,
    Jenkins, Travis CI, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed a few best practices, including coding standards
    and styles, PHP frameworks, design patterns, Git, and deployment. Also, we discussed
    the PHPUnit framework to test classes and libraries against tests. Also, we discussed
    Service-oriented design, which plays a major role in creating APIs for applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we studied setting up development environments, including Linux
    servers, specifically Debian and Ubuntu, and we also discussed Vagrant. The new
    features of PHP are also listed with sample codes. You read in detail about the
    tools that we can use to improve the performance of an application and a database.
    Also, we discussed debugging and stress or load testing our applications and some
    best practices of writing quality code.
  prefs: []
  type: TYPE_NORMAL
- en: We mostly summarized the tools and techniques with simple examples to introduce
    the reader to these tools and techniques. There is a good chance that each tool
    and technique has its own book written for a more advanced usage. We recommend
    you follow up on these tools and techniques and conduct more research for their
    advance usage. Good luck Php-ing!
  prefs: []
  type: TYPE_NORMAL
