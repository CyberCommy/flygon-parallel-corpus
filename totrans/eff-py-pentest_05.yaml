- en: Chapter 5. Fuzzing and Brute-Forcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most helpful tools that a security tester can have is a fuzzing tool
    to test a parameter of an application. Fuzzing has been very effective at finding
    security vulnerabilities, as it can be used for finding weaknesses by scanning
    an application attack surface. Fuzzers can test an application for directory traversal,
    command execution, SQL injection, and cross site scripting vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The best fuzzers are highly customizable, so in this chapter, we'll learn how
    to build our own fuzzers that can be used for a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing and brute-forcing passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH brute-forcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMTP brute-forcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute-forcing directories and file locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute-force cracking password-protected zip files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sulley fuzzing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, the fuzzing process consists of the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying the target**: For fuzzing an application, we have to identify
    the target application. For instance, a FTP server with a specific IP and running
    on port 21.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying inputs**: As we know, the vulnerability exists because the target
    application accepts a malformed input and processes it without sanitizing. So,
    we have to identify those inputs that the application accepts. For instance, the
    user name and password are input in the FTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating fuzz data**: After getting all the input parameters, we have to
    create invalid input data to send to the target application. Fuzzing data is often
    known as payloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzzing**: After creating the fuzz data, we have to send it to the target
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring the exceptions and logging**: Now we have to watch the target
    application for interesting responses and crashes and save this data for manual
    analysis. Monitoring web application fuzzing is a bit different, as the fuzzing
    may not crash the target application. We have to depend on the error messages
    and responses; making sure to note down any such unexpected responses for manual
    analysis. Sometimes the application may reveal internal building blocks in the
    error messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determining exploitability**: After fuzzing, we have to check the interesting
    responses or the input that caused a crash. This may help to exploit the target
    application. It is not necessarily the case that all crashes may lead to an exploitable
    vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classification of fuzzers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many classifications exist for fuzzing based on target, attack vectors used,
    and fuzzing method. Fuzzing targets include file formats, network protocols, command-line
    arguments, environment variables, web applications, and many others. Fuzzing can
    be broadly categorized based on the way test cases are generated. They are mutation
    fuzzing (dump) and generation fuzzing (intelligent).
  prefs: []
  type: TYPE_NORMAL
- en: Mutation (dump) fuzzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fuzzer that creates completely random input is known as a mutation or dump
    fuzzer. This type of fuzzer mutates the existing input value blindly. But it lacks
    an understandable format or structure of the data. For example, it can be replacing
    or appending a random slice of data to the desired input.
  prefs: []
  type: TYPE_NORMAL
- en: Generation (intelligent) fuzzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generation fuzzers create inputs from scratch rather than mutating existing
    input. So, it requires some level of intelligence in order to generate input that
    makes at least some sense to the target application.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to mutation fuzzers, this type will have an understanding of the
    file format, protocol, and so on. Also, this type of fuzzers are  difficult to
    create but are more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing and brute-forcing passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passwords can be cracked by guessing or by trying to login with every possible
    combination of words and letters. If the password is complicated, with a combination
    of numbers, characters, and special characters, this may take hours, to weeks,
    or months.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests with all possible passwords begin with words that have a higher possibility
    of being used as passwords, such as names and places. This method is the same
    as we did for injections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the password from a dictionary file and try it in the application
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we read the `dictionary` file and try each password in our script. When
    a specific password works it will print it in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the whole list of fuzz database here: [https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb).
  prefs: []
  type: TYPE_NORMAL
- en: SSH brute-forcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Python script to automate the brute-force attack to break the SSH
    login. Here we try multiple usernames and passwords to bypass SSH authentication
    with automated Python script. For brute-forcing SSH, we have to use a module named
    **paramiko**, which lets us connect to SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we initialize the static variables like password size, target IP, target
    port, and user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check with each password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make this script multi-threaded with the threading module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use threading to make the fuzzing run in parallel, for speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: SMTP brute-forcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple Mail Transfer Protocol** (**SMTP**) is a standard for e-mail transmission
    across networks. E-mail servers and other mail transfer agents use SMTP to send
    and receive e-mail messages. E-mail client applications regularly use SMTP only
    for sending e-mails. To perform brute-force password auditing against SMTP, we
    can use the `smtplib` module, which helps us to connect to SMTP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, import the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `IP` and `USER`. You can also get these values as input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the SMTP with each and every password in the password list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Brute-forcing directories and file locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could write a custom spider script to crawl the target website to discover
    sufficient information about the web application. However, there are often lots
    of configuration files, leftover development files, backup files, debugging scripts,
    and many other files that can provide sensitive information about the web application
    or expose some functionality that the developer of the application did not intend
    to expose.
  prefs: []
  type: TYPE_NORMAL
- en: The method to discover this type of content is to use brute-forcing to trace
    common filenames and directories. It is always far superior to have our own custom
    scripts, which will help us to customize the target files and to filter the results
    according to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as usual we import the required modules. Here we use threading to run
    multiple requests in parallel. But make sure to keep the threads low; a large
    number of threads may cause denial of service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define a function to read the word list file and to form an array of
    words to brute-force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define the function to brute-force the URL with the possible
    extensions of the words in the wordlist, which check the words for the file extensions,
    and if it''s not a file, we append an extra slash (`/`) and create a list of attempts
    for each word with the possible extensions and directory slash. After creating
    the attempt list, check for each entry in the attempts list appended to the URL
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we initiate the brute-force in threaded mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Brute-force cracking password protected ZIP files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed, the same method can be used to crack the password in a protected
    ZIP file. For that, we use the `zipfile` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sulley fuzzing framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using fuzzing frameworks, we can create fuzzers in less time. A fuzzing framework
    provides a flexible and reusable development environment that helps to build fuzzers
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Sulley is a Python fuzz testing framework that consists of multiple extensible
    components that can be used to fuzz file formats, network protocols, command line
    arguments, and many more. Sulley can monitor the network and  maintain records
    systematically. It can also monitor the health of the target.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sulley depends on PaiMei and pcapy. PaiMei is a reverse engineering framework
    to debug the fuzzed application and `pcap` to capture packets.
  prefs: []
  type: TYPE_NORMAL
- en: PaiMei has a lot of dependencies, like the MySQL database server that provides
    the Python database API, wxPython, GraphViz, Oreas GDE, uDraw, pydot, and ctypes.
    So, we have to install those dependencies first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Debian Linux we can install pydot, ctypes, wxPython, and GraphViz from the
    `apt-get` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then we can download PaiMei from [http://www.openrce.org/downloads/details/208](http://www.openrce.org/downloads/details/208).
  prefs: []
  type: TYPE_NORMAL
- en: 'After extracting the zip file, run the `_install_requirements.py` file to install
    its requirements. After that, install the MySql server, if it''s not installed
    in the host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, configure the MySQL server with the `__setup_mysql.py` file. For that,
    run the following Python script with your MySQL server credentials as the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install PaiMei by running the setup script as we do for other Python modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to install the `pcapy` library. To install the `pcapy` library,
    we can depend on the `apt-get` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have installed all the prerequisites. So, we can clone the `sulley`
    library and utilize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get in to the `sulley` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the installation, run the `process_monitor.py` script and `network_monitor.py`
    with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To install in Windows, as on Linux, install the prerequisites first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install PaiMei, download it from the link as we do for Linux and run the
    `__install_requirements.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will install the dependencies of PaiMei (ctypes, pydot, wxPython, MySQLdb,
    Graphviz, Oreas GDE, and uDraw).
  prefs: []
  type: TYPE_NORMAL
- en: Then, run the MySQL setup `script.python __setup_mysql.py` hostname username
    password.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, install the PaiMei library by running the build and install commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then we have to download and install `libdasm`. Download it from [http://libdasm.googlecode.com/files/libdasm-beta.zip](http://libdasm.googlecode.com/files/libdasm-beta.zip)
    and run the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, install `pcapy` from `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, clone the `sulley` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can check the installation by running the `process_monitor_unix.py` and `network_monitor.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any issues with the installation? Here is the detailed install instruction for
    Windows: [https://github.com/OpenRCE/sulley/wiki/Windows-Installation](https://github.com/OpenRCE/sulley/wiki/Windows-Installation).
  prefs: []
  type: TYPE_NORMAL
- en: Scripting with sulley
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start writing fuzzing scripts with sulley, we need to have a basic
    understanding of the grammar that will be used in sulley. When we write a Python
    script that uses sulley to fuzz a specific target, we need to define all the required
    objects. All sulley commands begin with an `s_` prefix. The following are several
    sections that will be used to build the scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data model**: Defines the properties of the protocol that we are about to
    fuzz.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State model**: Defines possible interactions between different states of
    the fuzzed network protocol. For example, authenticated and unauthenticated states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: Defines the target to fuzz. For instance, the IP and port of the
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agents**: Programs that monitor the fuzzed process for crashes, intercepting
    the relevant network packets, restarting the crashed process, and so on. This
    runs on the target computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring interface**: Helps to see the result of the fuzzing process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a static un-mutating value, we can use `s_static()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a four-byte word, we can use `s_int()`. For instance, to create a
    mutating integer that starts with `555` and is formatted in ASCII:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Blocks and groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Primitives can be nested within blocks. Such blocks can be started with `s_block_start()`
    and end with `s_block_end()`. A group is a collection of primitives; we can start
    a group with `s_group()`. An example for a static group primitive listing the
    various HTTP methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Grouping allows us to attach a block to a group primitive to specify that the
    block should cycle through all possible ways. We can iterate through these static
    HTTP methods with a block as follows. This defines a new block named `"body"`
    and associates it with the preceding group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can tie a number of requests together to form a session. Sulley is capable
    of fuzzing *deep* within a protocol by linking requests together in a graph. Sulley
    goes through the graph structure, starting with the root node and fuzzing each
    component along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write a script to fuzz the SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the modules `sulley` and `paramiko`. Make sure the script resides
    in the root of the sulley program that we downloaded from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set the username and password to string primitive. Sulley provides the
    `s_string()` primitive for representing these fields to denote that the data contained
    is a fuzzable string. Strings can be anything, like e-mail addresses, hostnames,
    usernames, passwords, and many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize the paramiko SSH client to try connecting to SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we can start fuzzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will try mutating the username and password and try to connect to the server
    with paramiko.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can fuzz FTP protocol. Here, we import FTP from requests and
    sulley:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we instruct sulley to wait for the banner before starting fuzzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we intialize the session, which keeps track of our fuzzing. This allows
    us to stop and restart fuzzing where we had previously left off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define our target with the IP and port number of the target FTP
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can instruct the network sniffer to set itself up on the same host
    and listening on `26300`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the target and grab the FTP banner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Try authenticating the FTP connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After authenticating we can use the commands, which require authentication,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, instruct sulley to start `fuzz`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about sulley and its usage here: [http://www.fuzzing.org/wp-content/SulleyManual.pdf](http://www.fuzzing.org/wp-content/SulleyManual.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through the basic methods of fuzzing and password brute-forcing.
    Now we can extend the scripts to meet our own needs. There are many fuzzing and
    brute-force tools available, but a custom script will always be better to get
    our specific results. We will discuss more on debugging and reverse engineering
    with Python libraries in the next chapter.
  prefs: []
  type: TYPE_NORMAL
