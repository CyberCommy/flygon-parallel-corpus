- en: Chapter 5. Extension Points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce and explore the theory and design concepts
    used while developing Jenkins plugins. We will cover the high-level concepts here
    with some generic examples as a preparation for the next two chapters where we
    will see how to implement these ideas for real.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singletons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, we will review several important design concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Design by contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief history of Jenkins plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are thousands of plugins available for Jenkins, and they cover a vast
    range of tasks and provide a wealth of valuable resources for the community that
    uses and works with Jenkins. Many of the existing plugins started out by providing
    simple functions and offering limited functionalities, but the majority of them
    have grown and developed into very mature software that offers large degrees of
    functionality. Many plugins have also been incorporated into Jenkins core functionality—turning
    them from an additional and optional add-on component to code that is shipped
    within Jenkins by default.
  prefs: []
  type: TYPE_NORMAL
- en: A major part of the reason for the success of Jenkins and its range of plugins
    is the design philosophy that was used to develop and extend Jenkins from the
    beginning. This approach to software development has encouraged people to work
    together, enabled projects to benefit from each other, and created a highly productive
    and collaborative community of developers and contributors to this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first look at developing your own plugin for Jenkins, there are several
    questions you should first address—the following link gives a detailed description
    of the steps you should take before embarking on developing your own new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.jenkins-ci.org/display/JENKINS/Before+starting+a+new+plugin](https://wiki.jenkins-ci.org/display/JENKINS/Before+starting+a+new+plugin)'
  prefs: []
  type: TYPE_NORMAL
- en: The intention behind this is to improve the quality of the plugins and to avoid
    duplication. This approach seeks to encourage developers of both existing and
    future or proposed plugins to work together and build upon the existing functionality
    rather than have a plethora of very similar plugins, all doing something slightly
    different.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for some additional functionality that is not available in
    the current list of plugins, it is possible that someone might be working on providing
    this feature right now. If you publicize your requirements and intentions within
    the development community, this might save you a lot of time and trouble. Instead
    of rolling your own, you could instead offer to collaborate on the development
    of this new plugin. The end result of this collaboration is more likely to produce
    a popular and high-quality product than two developers creating a similar functionality.
    It's also possible that you will find a vast majority of the functionality that
    you are seeking already available within a related plugin, and with a little information
    and collaboration, you may be able to leverage this to add a new feature by reusing
    much of the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: All of this collaboration, code reuse, and enhancement are achieved largely
    through the use of **Extension Points**, which represent some aspect of the functionality
    of either a plugin or of Jenkins. These are interfaces and abstract classes that
    enable interaction and reuse between different plugins and the Jenkins core functionality
    through declared and publicized entry points that provide and perform services
    to a documented contract.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a quick look at the theory behind these ideas so that when
    we write our own plugin, we will understand what is going on behind the scenes
    and why we are doing things with this reuse and extension in mind from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces in Java are the mechanisms used to provide and declare a **contract**
    that defines how to interact with and reuse an existing software. The main idea
    behind this approach is that it removes the requirement of knowing how things
    are done internally; you only need to know what the required input parameters
    should be and what to expect by calling an interface. Exactly what the internal
    workings of the code are and how the processing is done are not really important,
    and as long as you adhere to the declared contract, everything should be ok.
  prefs: []
  type: TYPE_NORMAL
- en: Another major benefit of this "design by contract" approach is that it reduces
    the impact of code and process updates on external users. For example, if you
    call an `add` interface on a class called `calculator` that takes two numbers
    and returns the result, you (as a consumer of this service) do not need to know
    or care how the addition is done—internally, the class could be simply adding
    the two Java integers together, or perhaps the input variables are being passed
    over to a web service in the cloud somewhere, which returns the answer back to
    the `calculator`. The code and the approach used could be completely redesigned
    and rewritten in any way the developers of the `calculator` desire, but as long
    as everyone sticks to the agreed contract and interface, external consumers should
    not be affected.
  prefs: []
  type: TYPE_NORMAL
- en: This clearly-defined interface also makes it easier to write automated regression
    tests. When you know there is a clearly-defined and stable interface, it is usually
    simple to write tests against it that will not require much maintenance, as the
    interface is not normally likely to be changed. These tests can be automatically
    rerun as part of the CI build whenever there is a related code change, and any
    discrepancy should be easily identified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an interface in Java, we use the **interface** keyword in the class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For an external class to use this interface, we use the **implements** keyword
    in the class declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As the `Motorbike` class has declared that it implements `Vehicle`, it will
    need to implement each of the methods that are declared in `Vehicle`. The Java
    compiler will ensure that this is done at compile time. For our `Vehicle` example,
    the methods would probably include logical functions, such as start, stop, turn
    left, turn right, brake, and accelerate. The `Motorbike` class-specific methods
    could include specifics, such as "pop a wheelie", extending the kickstand, falling
    over, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract classes in Java provide a high-level functionality that can be used
    by other classes as well. You can't create an abstract class directly, but you
    can implement another class that derives from the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest explanation is that an abstract class is a type of a thing, but
    is not a thing—by this, I mean that you can have an abstract class like our `Vehicle`
    example that declares all of the methods that we mentioned, but you can't ever
    create just a vehicle—you have to have something specific, such as a car, motorbike,
    hovercraft, helicopter, and so on; you can't have just a generic vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: All of our vehicles are slightly different, but share the same base functionality—they
    can go, they can stop, and they can turn. This common set of functionalities could,
    therefore, be modeled as base methods of an abstract (`Vehicle`) class, and whenever
    you create a new type of vehicle, you will have all of them available to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an abstract class in Java, you have to use the `abstract` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Typically, an abstract class will define the methods (go, stop, turn) only,
    and the subclasses will provide their actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Motorbike` class would then extend this abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The subclasses that extend the abstract classes are known as **concrete classes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract classes](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike the conceptual and logical grouping of abstract classes, these represent
    real, tangible objects.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extension points make use of both abstraction and interfaces to permit and encourage
    reuse of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the following diagram, **Deposit Money** declares an extension point called
    **Transfer to savings**. If we consider this to be an existing piece of code,
    and for the sake of this example, if we want to create a new **Savings Account**
    object, we can extend the functionality already provided by Deposit Money and
    use this to implement a new feature called Savings Account, which extends Deposit
    Money. This means that it will use most of the Deposit Money functionality, and
    it will also offer additional functionality of its own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstraction and interfaces](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In another example, we are extending the existing `Open Account` code to `Add
    Joint Account Holder`. This uses many of the `Open Account` methods, but also
    declares some methods that are specific to a second applicant. The following diagram
    shows the relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstraction and interfaces](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In cases where we have more than one application, we can extend Open Account
    to create a new **Add Joint Account Holder** object. This new object will contain
    and reuse a lot of the Open Account code, but it will do so slightly differently
    to cater to a secondary account holder.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types are a key concept in Java programming and in object-orientated
    design, in general. They are sometimes referred to as **existential** types, which
    help to reinforce what they are—*types of a thing* but without the required implementation
    or properties to actually be *a thing*.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on from the high-level and design theory topic and take a look
    at implementing extensions in Jenkins, there is one more Java design pattern that
    we still need to cover—the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons are used when you want to ensure that there will only be either zero
    or one instance of a given class.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, this pattern occurs when you need to control concurrent actions—by
    ensuring that there is only a maximum of one instance possible, we can be sure
    that we will not face any concurrency or race conditions, as this class (and its
    code) will *definitely* be the only possible instance at any given time. Usually,
    a Singleton will be used by many different functions, and its purpose is to handle
    and manage this demand safely.
  prefs: []
  type: TYPE_NORMAL
- en: A common Singleton example is a logging utility. For example, a class that takes
    a message from several different areas of a system at any point in time. It then
    opens a log file and appends the message to the file. We wouldn't want two classes
    writing to the same log file at the same time—that would cause chaos and end horribly—so
    control and access is managed by and restricted to a maximum of one instance of
    the class. This instance will be guaranteed to have ownership and free rein to
    write to the log files, and it will be safe in the knowledge that there is no
    other instance of the same class doing the same thing at the same time—it manages
    the "write this information to the log file" function safely.
  prefs: []
  type: TYPE_NORMAL
- en: Each section of code that wishes to use the "write to log file" method will
    attempt to initialize the Singleton object. If an instance of this object already
    exists, we will reuse this, and if currently there is no instance, one will be
    created. It will then remain available for other users until the program exists,
    or it is cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Singleton instantiation is managed via a private constructor so that only
    the code inside the Singleton can create it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is known as Eager instantiation, as we will create a new Singleton object
    every time prior to invoking the `getInstance()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative approach to this—and which one you use depends on your preferences
    and requirements—is to use Lazy instantiation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used a static Singleton instance and synchronized the `getInstance()`
    method. Comparing the two approaches should help you to decide the best approach
    for your needs. In UML, a Singleton can be documented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Singletons](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Declaring an extension in Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, creating an interface or an abstract class is simple
    once we understand the logic behind them. It's easier to declare an interface
    or an abstract class, and then implement the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Singleton is also straightforward once you understand when to use
    each design pattern and which approach suits your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If we keep this model in mind when creating or adding components to a Jenkins
    plugin, we should be able to identify appropriate opportunities where it would
    be helpful to expose an interface and create an extension point for others to
    use. For example, if you are working on a plugin that for some reason transforms
    the history of a Jenkins job in to a CSV file so that it can be exported and analyzed
    in a spreadsheet, you will be writing functions to turn some data in to CSV values—this
    could be declared as an extension point, and as long as the data passed is of
    the specified type, others can reuse your code to convert their data to CSV too,
    rather than everyone implementing the same functions, which would cause needless
    duplication.
  prefs: []
  type: TYPE_NORMAL
- en: To define or create an extension in Jenkins, we use the `@Extension` annotation
    type.
  prefs: []
  type: TYPE_NORMAL
- en: This annotation is picked up by Jenkins, and the new extension will be added
    to an `ExtensionList` object, where the extension can then be found via `ExtensionFinder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'More details on the extension annotation can be found here: [http://javadoc.jenkins-ci.org/?hudson/Extension.html](http://javadoc.jenkins-ci.org/?hudson/Extension.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the declaration for an `Animal` extension point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This illustrates an abstract class that implements `ExtensionPoint`: [https://wiki.jenkins-ci.org/display/JENKINS/Defining+a+new+extension+point](https://wiki.jenkins-ci.org/display/JENKINS/Defining+a+new+extension+point).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the concepts behind several major design patterns
    and saw when you would use each approach and why you would do so.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an experienced Java programmer, these concepts should be very familiar,
    and if not, then hopefully this will serve as a foundation that will help you
    to understand not only what we are doing in the subsequent chapters, but also
    why we are doing it.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning of this chapter, we touched upon the philosophy behind plugin
    development—that people should seek to collaborate, reuse, and extend existing
    code to provide new functionality whenever possible. If everyone went off and
    created their own plugins for their own particular needs, rather than collaborating
    and contributing to existing efforts, there would be massive duplication and replication,
    and the quality would be far poorer as a result.
  prefs: []
  type: TYPE_NORMAL
- en: This ethos and the preceding design approach has created a community of plugin
    developers who produce high quality software by providing a vast array of functionality
    that enables Jenkins users to adapt and extend Jenkins to perform an incredibly
    diverse number of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build upon this knowledge and see the concepts
    that we have covered here being used for real when we develop our first Jenkins
    plugin.
  prefs: []
  type: TYPE_NORMAL
