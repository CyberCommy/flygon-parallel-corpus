- en: Chapter 4. Socializer – the Testable Timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will build our next application with the codename: Socializer.
    This application will provide you with a very typical *timeline* feed, whose variations
    grace many well-known modern web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: This application will allow authenticated users to follow others, and be followed
    by other users, and display content posted from the followed users in a time-ordered
    fashion. Along with building the basic features required of a timeline-based application,
    we will implement additional behaviors using the excellent `Blinker` library for
    in-process publish/subscribe signals that will allow us to decouple the application
    into more compassable, reusable parts.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Socializer will be built with unit and functional testing in mind,
    allowing us to vigorously test the various models and views to ensure that it
    functions according to our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Starting off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did in the previous chapter, let''s create a completely new directory
    for this application, in addition to creating a virtual environment and installing
    a few basic packages that we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application layout will, for the moment, be very similar to the one that
    we used in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Application factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major benefits of unit and functional testing is the ability to ensure,
    under a variety of different conditions and configurations, that your application
    behaves in a known and predictable manner. To this end, it will be a great advantage
    to have the ability to construct all the Flask application objects in our test
    suite. We can then easily provide different configurations to each of these objects
    and ensure that they exhibit the behavior that we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, this is entirely achievable using the application factory pattern,
    which is well supported by Flask. Let''s add a `create_app` method to our `application/__init__.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What this method does is relatively simple: given an optional `config` argument,
    construct a Flask application object, optionally apply this custom configuration,
    and finally return the newly created Flask application object to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we would simply instantiate a Flask object in the module itself,
    which meant that on import of this package or module the application object would
    be immediately available. However, this also meant that there was no simple way
    of doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Delaying the construction of the application object to some time after the module
    was imported to the local namespace. This may seem frivolous at first but is incredibly
    useful and powerful for large applications that can benefit from this type of
    lazy instantiation. As we mentioned previously, side-effect generating package
    imports should be avoided as much as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substituting different application configuration values, such as those that
    may be needed while running tests. We might like to avoid, for example, sending
    out e-mail notifications to real world users while running our test suite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple Flask applications in the same process. While we do not explicitly
    address the concept in this book, this can be useful in a variety of situations,
    such as having separate application instances that serve different versions of
    a public API or separate application objects that serve different content types
    (JSON, XML, and so on). More information on this topic can be gleaned from the
    *Application dispatching* section in the official Flask online documentation [http://flask.pocoo.org/docs/0.10/patterns/appdispatch/](http://flask.pocoo.org/docs/0.10/patterns/appdispatch/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the application factory, we now have more flexibility in when and how our
    main application object is constructed. The downside (or upside, if you're intent
    on running several applications in the same process!), of course, is that we no
    longer have access to a quasi-global `app` object that we can import to our modules
    in order to do things such as register route handlers or access the `app` object's
    logger.
  prefs: []
  type: TYPE_NORMAL
- en: The application context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the principal design goals of Flask is to ensure that you can run multiple
    applications in the same Python process. How, then, should an application be certain
    that the `app` object being imported to a module is the correct one and not the
    object for one of the other applications running in the same process?
  prefs: []
  type: TYPE_NORMAL
- en: 'In other frameworks that support the single-process/multi-app paradigm, this
    is sometimes accomplished by enforcing explicit dependency injection: a code that
    requires an `app` object to be present should explicitly require that the app
    object be passed to the function or method that needs it. From an architectural
    design perspective this sounds great, but this can quickly become cumbersome if
    third-party libraries or extensions do not follow the same design principles.
    At best, you will end up needing to write a lot of boilerplate wrapper functions,
    and at worst you will end up resorting to monkey-patching modules and classes
    in a never-ending downward spiral of brittleness and unnecessary complexity that
    will ultimately cause you more trouble than you originally bargained for.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is, of course, nothing inherently wrong with explicit dependency injection
    boilerplate wrapper functions. Flask has simply chosen a different approach, which
    it has been criticized for in the past, but has shown to be both flexible, testable,
    and resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Flask, for better or worse, has been built around an alternative method that
    is based on proxy objects. These proxy objects are, in essence, container objects
    that are shared among all the threads and know how to dispatch to the *real* objects
    that are bound to a particular thread behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common misconception is that in a threaded application, each request will
    be assigned its own new thread under the WSGI specification: this is simply not
    the case. New requests may reuse existing but currently unused threads, and this
    old thread may have locally scoped variables still lurking around that may interfere
    with your new request handling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these proxy objects, `current_app`, is created and bound to the current
    request This means that instead of importing an already-constructed Flask application
    object (or worse, creating additional application objects in the same request),
    we replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aliasing of the imported `current_app` object is, of course, completely
    optional. It is sometimes preferable to leave it named `current_app` so as to
    remind yourself that it is not the real application object, but a proxy to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using this proxy object, we can sidestep the issue of not having an instantiated
    Flask application object available to us at import time when we implement the
    application factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating an app object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, at some point, we need to actually create an application object so
    that the proxies have something to, well, proxy to. Generally, we want to create
    the object once and then we want to make sure that the `run` method is invoked
    in order to launch the Werkzeug development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, we can modify the `run.py` script that we had in the previous
    chapter to instantiate the app object from our factory and invoke the `run` method
    on the newly created instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to run this extremely barebones application as we have
    previously done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also possible to invoke the Python interpreter such that a module, package,
    or script is imported to the environment for you and executed immediately. This
    is accomplished with the `–m` flag and our preceding invocation of `run.py` can
    be modified to the more concise version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unit and functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary benefits of implementing an application factory to hand out
    the Flask application instances is that we have the abilities to test the application
    more effectively. We can construct different application instances for different
    test cases and can be sure that they are as isolated from each other as possible
    (or as much as Flask/Werkzeug will allow).
  prefs: []
  type: TYPE_NORMAL
- en: 'The mainstay of the testing libraries in the Python ecosystem is unittest,
    which is included in the standard library and includes much of the functionalities
    that are expected of an xUnit framework. While a complete exposition on unittest
    is largely out of the scope of this book, a typical class-based test case will
    follow this basic skeleton, assuming that we are still using the factory pattern
    to separate our application configuration from instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the advantages of using the unittest test format/style:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not require external dependencies; unittest is part of the Python standard
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started is relatively easy. Most xUnit testing frameworks follow similar
    naming conventions to declare the test classes and test methods, and include several
    helpers for typical assertions such as `assertTrue` or `assertEqual`, among several
    others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is, however, not the only player in town; we will be using `pytest` and the
    associated Flask extension that wraps the convenient functionality, `pytest-flask`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being a slightly more modern and concise testing framework,
    the other major advantage that `pytest` provides over many other testing tools
    is the ability to define fixtures for the tests, which are described quite succinctly
    from their own documentation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures have explicit names and are activated by declaring their use from test
    functions, modules, classes, or whole projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixtures are implemented in a modular manner as each fixture name triggers a
    fixture function that itself can use other fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixture management scales from a simple unit to complex functional testing,
    allowing you to parameterize fixtures and tests according to the configuration
    and component options or to reuse fixtures across class, module, or whole test
    session scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of testing a Flask application, this means that we can define
    objects (such as our application object) in a `fixture` and then have this object
    automatically injected into a test function via the use of an argument that has
    the same name as the defined fixture function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that last paragraph was a bit too much to handle, then a simple example
    should be enough to clear things up. Let''s create the following `conftest.py`
    file, which will contain any test suite-wide fixtures and helpers that our other
    tests might use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create our first test module in `tests/test_application.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `tests_*` prefix to the test file names is important—it allows
    `pytest` to automatically discover which files contain test functions and assertions
    that need to be run. If a filename in your tests/folder does not have the aforementioned
    prefix, then the test runner will abstain from loading it and treating it as a
    file that contains functions with test assertions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `app` argument in the `test_app` function signature matches the
    name of the `app` fixture function that is defined in `conftest.py`, and the value
    that is passed to `test_app` is the return value of the `app` fixture function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the test suite using the `py.test` executable that was installed
    to our virtual environment (when we added the `pytest-flask` and `pytest` libraries)
    in the directory that contains `conftest.py` and our tests/folder, and the output
    will indicate that our test module was discovered and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We've written and run our very first, albeit uninteresting, test
    for our application. Don't fret if you don't quite understand what's going on
    just yet; quite a bit of concrete testing is coming up in this chapter and many
    more examples will follow.
  prefs: []
  type: TYPE_NORMAL
- en: Social features – friends and followers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modern web applications allow users to *friend* or *follow* other users
    and be friended or followed themselves. While this concept may be simple to explain
    in words, there are numerous implementations and variations, all of which are
    optimized for their particular use-cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, where we want to implement a newsfeed-like service that
    displays information from a selected pool of users in an aggregated timeline that
    is unique for each authenticated user, the following are the three categories
    of approaches that may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fan-out on Write**: Each newsfeed for a user is stored in a separate logical
    container with the intention of making reads exceedingly simple, fast, and straightforward,
    at the expense of denormalization and lower write throughput. The logical container
    may be a database table for each user (although this is highly inefficient for
    a large amount of users), columns in a column-oriented database such as Cassandra,
    or more specialized storage solutions such as Redis lists that may have elements
    added to them in an atomic fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fan-out on Read**: When newsfeeds require additional customization or processing
    to determine things such as visibility or relevance, a fan-out on read approach
    is usually best. This allows more fine-grained control over which items will end
    up in the feed and in which order (assuming that something more elaborate than
    chronological is required) at the cost of increased computational time to load
    the user-specific feed. Such a costly approach may be mitigated by keeping the
    recent items in RAM (which is the basic approach behind the Facebook™ newsfeed
    and the reason why Facebook also has the largest deployment of Memcache in the
    world), but this introduces several layers of complexity and indirection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naïve Normalization**: This is the least scalable of the approaches, but
    the simplest to implement. For many small-scale applications, this is the best
    place to start: a post''s table that contains all the items created by users (with
    a foreign key constraint to the user who created that particular item) and a follower''s
    table that tracks which users are following whom. Various caching solutions may
    be used to speed up parts of the request at the cost of additional complexity
    and may be introduced when they are necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of our Socializer application, the third approach, the so-called
    naïve normalization, will be the one we implement. The other approaches are valid,
    and you may choose to go down either path depending on your goals, but for the
    sake of simplicity and exposition we shall choose the one that requires the least
    amount of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s begin by implementing the basic SQLAlchemy models
    and relationships that are required. First, let''s use our newly minted application
    factory to initialize and configure the Flask-SQLAlchemy extension along with
    Flask-Bcrypt to hash our user passwords, using the same hybrid property approach
    that we explored in the previous chapter. Our `application/__init__.py` is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Due to the use of the application factory, we separated the instantiation of
    the extensions (`db` and `flask_bcrypt`) from their configurations. The former
    happens at the time of import and the latter needs to occur when the Flask application
    object is constructed. Luckily, most modern Flask extensions allow this exact
    separation to occur, as we have demonstrated in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create our user''s package by creating `application/users/__init__.py`,
    then we will create `application/users/models.py` with our standard bits for the
    Flask-Login extension (which we will use later) as we did in the previous chapter.
    In addition, we will add an explicit SQLAlchemy mapping for our follower''s table
    and the following associated relationship on the User model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `followed` attribute of the User model is a SQLAlchemy relationship that
    maps the user''s table to itself via the intermediate follower''s table. The intermediate
    table is necessary due to the implicit many-to-many relationship that a social
    connection requires. Take a close look at the `followed` attribute, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the declaration is somewhat complex in comparison to the regular
    column definitions that we used in this chapter and in previous ones. However,
    each argument to the `relationship` function has a very definite purpose, as shown
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`User`: This is the string-based name of the target relationship class. This
    can also be the mapped class itself, but then you might end up in a quagmire of
    circular import problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`primaryjoin`: The value of this argument will be evaluated and then used as
    the `join` condition for the primary table (`user`) to the association table (`follower`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secondaryjoin`: The value of this argument, similar to the `primaryjoin`,
    is evaluated and then used in the `join` condition of the association table (`follower`)
    to the child table (`user`). As our primary and child tables are one and the same
    (users follow other users), this condition is almost identical to the one produced
    in the `primaryjoin` argument, differing only in the key that is mapped in the
    association table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backref`: This is the name of the property that will be inserted on an instance
    that will handle the reverse direction of the relationship. This means that once
    we have a user instance, we can access `user.followers` to get the list of people
    that are following the given user instance, as opposed to the `user.followed`
    attribute in which we explicitly define the list of users that the current user
    is following.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lazy`: This is the most often misused attribute for any relationship-based
    property. There are various values available, ranging from `select`, `immediate`,
    `joined`, `subquery`, `noload`, and `dynamic`. These determine how or when the
    related data is loaded. For our application, we''ve chosen to use the value of
    dynamic, which, instead of returning an iterable collection, returns a `Query`
    object that can then be further refined and acted on. For example, we can do something
    such as `user.followed.filter(User.username == ''example'')`. While this is not
    very useful in this particular instance, it provides a huge amount of flexibility,
    sometimes at the cost of generating less efficient SQL queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The various attributes that we will set are to ensure that the generated queries
    use the correct columns to create the self-referential many-to-many join and the
    query to obtain the list of followers is only executed when we need it. More information
    about these particular patterns can be found in the official SQLAlchemy documentation:
    [http://docs.sqlalchemy.org/en/latest/](http://docs.sqlalchemy.org/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add a few methods to our User model that will facilitate the following/unfollowing
    of other users. Thanks to some under-the-hood cleverness from SQLAlchemy, adding
    and removing followers for a user can be expressed as if you were acting on a
    native Python list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, you are not acting on a native Python list, but rather a data structure
    that SQLAlchemy knows how to track the removals and additions from and then synchronize
    these to the database via the Unit of Work pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create the `Post` model and we'll do so in the blueprint module
    of `application/posts/models.py`. As usual, don't forget to create the `application/posts/__init__.py`
    file in order to declare the folder as a valid Python package, otherwise some
    very confusing import errors will occur when you attempt to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, this particular model will be a paragon of simplicity. Here''s the
    current implementation of the User model for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our `Post` model defined, we can now add a method to the User
    model that will allow us to fetch the newsfeed for the user that is linked by
    the current instance. We name that method `newsfeed`, and it''s implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we must import the `Post` model to the `application/users/models.py`
    module in order to implement the preceding method as described. While this particular
    scenario will function without issue, one must always be wary of the potential
    circular import problems that may be somewhat difficult to diagnose.
  prefs: []
  type: TYPE_NORMAL
- en: Functional and integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most of the treatments of unit, functional, and integration testing, it is
    often recommended that you write the tests before the corresponding code itself
    is written. While this is generally considered to be a good practice for a variety
    of reasons (primarily allowing you to ensure that the code being written solves
    the problem that has been defined), for the sake of simplicity, we have waited
    until now to touch on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new `test_settings.py` file that is sibling to our existing
    `settings.py`. This new file will contain the application configuration constants
    that we want to use while running our test suite. Most importantly, it will contain
    the URI to a database that is not our application database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding `SQLALCHEMY_DATABASE_URI` string points to `/tmp/test_app.db`
    as the location for the test database. You may of course choose a different path
    than the system-wide `tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also make a few additions to the `conftest.py` file in order to add
    additional fixtures for initializing a test database and ensuring that we have
    a SQLAlchemy database session object available for any test functions that may
    require it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The session fixture can be augmented with explicit transactions, ensuring that
    a transaction is begun and then committed in the teardown. The (simple) implementation
    of this is left as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `scope` argument indicates the lifetime of the given fixture object once
    it has been created. In the preceding example, we indicated `function` for the
    session fixture, which means that a new fixture object will be created for each
    test function that is invoked as an argument. If we used `module` as our scope
    value, we would have a new fixture created for each `module` that the fixture
    is included in: a single fixture would be used for all the tests in our module.
    This should not be confused with the `session` scope value, which indicates that
    a single fixture object is to be created for the entire duration of our test suite
    run. The session scope can be useful in situations where, for example, creating
    a database connection is an extremely expensive operation. If we only had to create
    the database connection once, the total runtime of our test suite might be significantly
    reduced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional information on the `scope` argument for the `py.test` fixture
    decorator and the use of the built-in `request` object to add the teardown finalizer
    callback functions, the online documentation is a fantastic starting point: [https://pytest.org/latest/contents.html](https://pytest.org/latest/contents.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a simple test to create a new user from our declarative User model
    in `tests/test_user_model.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After running the test suite with `py.test`, we should see our newly created
    test file appear in the listed output and our tests should run without error.
    We will assert that our newly created user should have an ID (assigned by the
    database) and should not be following any other users. Consequently, the newsfeed
    for the user that we created should also have no elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some more tests for the nontrivial parts of our user data model,
    which will ensure that our follow/following relationships work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Publish/subscribe events with Blinker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the many difficulties in the lifecycle of any nontrivial application
    is ensuring that the right level of modularity is present in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: There exist various methodologies to create interfaces, objects, and services
    and implementing design patterns that help us manage the ever-increasing complexity
    that is inevitably created for a real-world application. One methodology that
    is often left unexplored for web applications is the in-process `publish-subscribe`
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, `publish-subscribe`, or more colloquially known as pub/sub, is a
    messaging pattern where two classes of participants exist: **publishers** and
    **subscribers**. Publishers send messages and subscribers subscribe to a subset
    of the messages that are produced via the topic (a named channel) or via the content
    of the message itself.'
  prefs: []
  type: TYPE_NORMAL
- en: In large distributed systems, pub/sub is usually mediated by a message bus or
    broker that communicates with all the various publishers and subscribers and ensures
    that the published messages are routed to the subscribers that are interested
    in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purpose, however, we can use something a little simpler: an in-process
    pub/sub system using the wonderfully simple `Blinker` package, which is supported
    by Flask if it is installed.'
  prefs: []
  type: TYPE_NORMAL
- en: Signals from Flask and extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `Blinker` package is present, Flask allows you to subscribe to various
    signals (topics) that are published. In addition, Flask extensions may implement
    their own custom signals. You can subscribe to any number of signals in your application,
    but the order in which the signal subscribers will receive the messages is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the more interesting signals that Flask publishes are described in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request_started`: This is sent immediately after the request context was created
    but before any request processing occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request_finished`: This is sent after the response has been constructed but
    immediately before it is sent back to the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Flask-SQLAlchemy extension publishes the following two signals itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models_committed`: This is sent after any modified model instances are committed
    to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before_models_committed`: This is sent just before the model instances are
    committed to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flask-Login publishes half a dozen signals, many of which can be utilized for
    modularizing the authentication concerns. A few useful ones are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user_logged_in`: This is sent when a user logs in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_logged_out`: This is sent when a user logs out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_unauthorized`: This is sent when an unauthenticated user attempts to
    access a resource that requires authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to subscribing to the signal topics that are published by Flask
    and various Flask extensions, it's also possible (and sometimes very useful!)
    to create your own custom signals that may then be consumed in your own application.
    While this may seem like a roundabout approach where a simple function or method
    call would suffice, the ability to separate out orthogonal concerns from the various
    parts of your application is an attractive proposal.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you have a User model that has an `update_password` method,
    which allows the password for the given user instance to be changed to a new given
    value. When the password is changed, we would like to send an e-mail to the user,
    informing them that this action has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the straightforward implementation of this would be to simply have the
    mail sent in the `update_password` method itself, which is inherently not a bad
    idea. Imagine, however, that we have yet another dozen instances where incurred
    actions require that an e-mail be sent out to the user: when they are followed
    by a new user, when they are unfollowed by a user, when they reach a certain threshold
    of followers, and the list goes on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem then becomes apparent: we have mixed logic and functionality to
    send an e-mail to a user in various parts of our application, which makes it increasingly
    difficult to reason about, debug, and refactor.'
  prefs: []
  type: TYPE_NORMAL
- en: While several methods to manage this complexity exist, the explicit separation
    of concerns that is possible becomes readily apparent when a publish/subscribe
    pattern is implemented. With custom signals in our Flask application, we can create
    a follower-added signal where an event is published after the action takes place
    and any number of subscribers can listen for that particular event. Moreover,
    we can organize our application in such a way that the signal subscribers for
    similar events (for example, sending out an e-mail notification) reside in the
    same location in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a signal that will publish an event whenever a user follows another
    user. First, we will need to create our `Namespace` signal container object so
    that we can then declare our signal topics. Let''s do this in `application/__init__.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is in place, emitting the `user-followed` event in our `User.follow()`
    method is simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to add the [PRE23]
  prefs: []
  type: TYPE_NORMAL
- en: __all__ = ['user_followed_email']
  prefs: []
  type: TYPE_NORMAL
- en: import logging
  prefs: []
  type: TYPE_NORMAL
- en: logging.basicConfig(level=logging.DEBUG)
  prefs: []
  type: TYPE_NORMAL
- en: logger = logging.getLogger(__name__)
  prefs: []
  type: TYPE_NORMAL
- en: 'def user_followed_email(user, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: logger.debug(
  prefs: []
  type: TYPE_NORMAL
- en: '"Send an email to {user}".format(user=user.username))'
  prefs: []
  type: TYPE_NORMAL
- en: from application import user_followed
  prefs: []
  type: TYPE_NORMAL
- en: 'def connect_handlers():'
  prefs: []
  type: TYPE_NORMAL
- en: user_followed.connect(user_followed_email)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: from flask import Flask
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.sqlalchemy import SQLAlchemy
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.bcrypt import Bcrypt
  prefs: []
  type: TYPE_NORMAL
- en: from blinker import Namespace
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the db extension, but without configuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: it with an application instance.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: db = SQLAlchemy()
  prefs: []
  type: TYPE_NORMAL
- en: flask_bcrypt = Bcrypt()
  prefs: []
  type: TYPE_NORMAL
- en: socializer_signals = Namespace()
  prefs: []
  type: TYPE_NORMAL
- en: user_followed = socializer_signals.signal('user-followed')
  prefs: []
  type: TYPE_NORMAL
- en: from signal_handlers import connect_handlers
  prefs: []
  type: TYPE_NORMAL
- en: connect_handlers()
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: from flask import Blueprint, render_template, url_for, redirect, flash, g
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.login import login_user, logout_user
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.wtf import Form
  prefs: []
  type: TYPE_NORMAL
- en: from wtforms import StringField, PasswordField
  prefs: []
  type: TYPE_NORMAL
- en: from wtforms.validators import DataRequired, Length
  prefs: []
  type: TYPE_NORMAL
- en: from models import User
  prefs: []
  type: TYPE_NORMAL
- en: from application import db, flask_bcrypt
  prefs: []
  type: TYPE_NORMAL
- en: users = Blueprint('users', __name__, template_folder='templates')
  prefs: []
  type: TYPE_NORMAL
- en: "class Login\tForm(Form):"
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Represents the basic Login form elements & validators.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: username = StringField('username',
  prefs: []
  type: TYPE_NORMAL
- en: validators=[DataRequired()])
  prefs: []
  type: TYPE_NORMAL
- en: password = PasswordField('password',
  prefs: []
  type: TYPE_NORMAL
- en: validators=[DataRequired(),Length(min=6)])
  prefs: []
  type: TYPE_NORMAL
- en: 'class CreateUserForm(Form):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulate the necessary information required for creating a new user.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: username = StringField('username', validators=[DataRequired(), Length(min=3,
    max=40)])
  prefs: []
  type: TYPE_NORMAL
- en: email = StringField('email', validators=[DataRequired(), Length(max=255)])
  prefs: []
  type: TYPE_NORMAL
- en: password = PasswordField('password', validators=[DataRequired(),
  prefs: []
  type: TYPE_NORMAL
- en: Length(min=8)])
  prefs: []
  type: TYPE_NORMAL
- en: '@users.route(''/signup'', methods=[''GET'', ''POST''])'
  prefs: []
  type: TYPE_NORMAL
- en: 'def signup():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Basic user creation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: form = CreateUserForm()
  prefs: []
  type: TYPE_NORMAL
- en: 'if form.validate_on_submit():'
  prefs: []
  type: TYPE_NORMAL
- en: user = User( username=form.username.data,
  prefs: []
  type: TYPE_NORMAL
- en: email=form.email.data,
  prefs: []
  type: TYPE_NORMAL
- en: password=form.password.data)
  prefs: []
  type: TYPE_NORMAL
- en: add the user to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: db.session.add(user)
  prefs: []
  type: TYPE_NORMAL
- en: db.session.commit()
  prefs: []
  type: TYPE_NORMAL
- en: Once we have persisted the user to the database successfully,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: authenticate that user for the current session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: login_user(user, remember=True)
  prefs: []
  type: TYPE_NORMAL
- en: return redirect(url_for('users.index'))
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/signup.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: '@users.route(''/'', methods=[''GET''])'
  prefs: []
  type: TYPE_NORMAL
- en: 'def index():'
  prefs: []
  type: TYPE_NORMAL
- en: return "User index page!", 200
  prefs: []
  type: TYPE_NORMAL
- en: '@users.route(''/login'', methods=[''GET'', ''POST''])'
  prefs: []
  type: TYPE_NORMAL
- en: 'def login():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Basic user login functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if hasattr(g, ''user'') and g.user.is_authenticated():'
  prefs: []
  type: TYPE_NORMAL
- en: return redirect(url_for('users.index'))
  prefs: []
  type: TYPE_NORMAL
- en: form = LoginForm()
  prefs: []
  type: TYPE_NORMAL
- en: 'if form.validate_on_submit():'
  prefs: []
  type: TYPE_NORMAL
- en: We use one() here instead of first()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: user = User.query.filter_by(username=form.username.data).one()
  prefs: []
  type: TYPE_NORMAL
- en: 'if not user or not flask_bcrypt.check_password_hash(user.password, form.password.data):'
  prefs: []
  type: TYPE_NORMAL
- en: flash("No such user exists.")
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/login.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: login_user(user, remember=True)
  prefs: []
  type: TYPE_NORMAL
- en: return redirect(url_for('users.index'))
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/login.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: '@users.route(''/logout'', methods=[''GET''])'
  prefs: []
  type: TYPE_NORMAL
- en: 'def logout():'
  prefs: []
  type: TYPE_NORMAL
- en: logout_user()
  prefs: []
  type: TYPE_NORMAL
- en: return redirect(url_for('users.login'))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '{% extends "layout.html" %}'
  prefs: []
  type: TYPE_NORMAL
- en: '{% block content %}'
  prefs: []
  type: TYPE_NORMAL
- en: <form action="{{ url_for('users.signup')}}" method="post">
  prefs: []
  type: TYPE_NORMAL
- en: '{{ form.hidden_tag() }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ form.id }}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>{{ form.username.label }}: {{ form.username }}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{% if form.username.errors %}'
  prefs: []
  type: TYPE_NORMAL
- en: <ul class="errors">{% for error in form.username.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endif %}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>{{ form.email.label }}: {{ form.email }}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{% if form.email.errors %}'
  prefs: []
  type: TYPE_NORMAL
- en: <ul class="errors">{% for error in form.email.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endif %}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>{{ form.password.label }}: {{ form.password }}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{% if form.password.errors %}'
  prefs: []
  type: TYPE_NORMAL
- en: <ul class="errors">{% for error in form.password.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endif %}'
  prefs: []
  type: TYPE_NORMAL
- en: <div><input type="submit" value="Sign up!"></div>
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endblock %}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: from flask import Flask
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.sqlalchemy import SQLAlchemy
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.bcrypt import Bcrypt
  prefs: []
  type: TYPE_NORMAL
- en: from blinker import Namespace
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.login import LoginManager
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the db extension, but without configuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: it with an application instance.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: db = SQLAlchemy()
  prefs: []
  type: TYPE_NORMAL
- en: flask_bcrypt = Bcrypt()
  prefs: []
  type: TYPE_NORMAL
- en: login_manager = LoginManager()
  prefs: []
  type: TYPE_NORMAL
- en: socializer_signals = Namespace()
  prefs: []
  type: TYPE_NORMAL
- en: user_followed = socializer_signals.signal('user-followed')
  prefs: []
  type: TYPE_NORMAL
- en: from signal_handlers import *
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_app(config=None):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__)
  prefs: []
  type: TYPE_NORMAL
- en: 'if config is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: app.config.from_object(config)
  prefs: []
  type: TYPE_NORMAL
- en: Initialize any extensions and bind blueprints to the
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: application instance here.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: db.init_app(app)
  prefs: []
  type: TYPE_NORMAL
- en: flask_bcrypt.init_app(app)
  prefs: []
  type: TYPE_NORMAL
- en: login_manager.init_app(app)
  prefs: []
  type: TYPE_NORMAL
- en: from application.users.views import users
  prefs: []
  type: TYPE_NORMAL
- en: app.register_blueprint(users, url_prefix='/users')
  prefs: []
  type: TYPE_NORMAL
- en: from application.users import models as user_models
  prefs: []
  type: TYPE_NORMAL
- en: '@login_manager.user_loader'
  prefs: []
  type: TYPE_NORMAL
- en: 'de fload_user(user_id):'
  prefs: []
  type: TYPE_NORMAL
- en: return user_models.User.query.get(int(user_id))
  prefs: []
  type: TYPE_NORMAL
- en: return app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: SQLALCHEMY_DATABASE_URI = 'sqlite:///socializer.db'
  prefs: []
  type: TYPE_NORMAL
- en: SECRET_KEY = 'BpRvzXZ800[-t:=z1eZtx9t/,P*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: place with other imports…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from sqlalchemy import exc
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: db.session.add(user)
  prefs: []
  type: TYPE_NORMAL
- en: db.session.commit()
  prefs: []
  type: TYPE_NORMAL
- en: 'except exc.IntegrityError as e:'
  prefs: []
  type: TYPE_NORMAL
- en: A unique column constraint was violated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: current_app.exception("User unique constraint violated.")
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/signup.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: 'except exc.SQLAlchemyError:'
  prefs: []
  type: TYPE_NORMAL
- en: current_app.exception("Could not save new user!")
  prefs: []
  type: TYPE_NORMAL
- en: flash("Something went wrong while creating this user!")
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/signup.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: We use one() here instead of first()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: user = User.query.filter_by(
  prefs: []
  type: TYPE_NORMAL
- en: username=form.username.data).one()s
  prefs: []
  type: TYPE_NORMAL
- en: 'except NoResultFound:'
  prefs: []
  type: TYPE_NORMAL
- en: flash("User {username} does not exist.".format(
  prefs: []
  type: TYPE_NORMAL
- en: username=form.username.data))
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/login.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_get_user_signup_page(client):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Ensure signup page is available."""'
  prefs: []
  type: TYPE_NORMAL
- en: response = client.get('/users/signup')
  prefs: []
  type: TYPE_NORMAL
- en: assert response.status_code == 200
  prefs: []
  type: TYPE_NORMAL
- en: assert 'Sign up!' in response.data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: from flask import session, get_flashed_messages
  prefs: []
  type: TYPE_NORMAL
- en: from application.users.models import User
  prefs: []
  type: TYPE_NORMAL
- en: from application import flask_bcrypt
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_signup_new_user(client):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Successfully sign up a new user."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'data = {''username'': ''test_username'', ''email'': ''test@example.com'','
  prefs: []
  type: TYPE_NORMAL
- en: '''password'': ''my test password''}'
  prefs: []
  type: TYPE_NORMAL
- en: response = client.post('/users/signup', data=data)
  prefs: []
  type: TYPE_NORMAL
- en: On successful creation we redirect.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert response.status_code == 302
  prefs: []
  type: TYPE_NORMAL
- en: Assert that a session was created due to successful login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert '_id' in session
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that we have no stored flash messages indicating an error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: occurred.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert get_flashed_messages() == []
  prefs: []
  type: TYPE_NORMAL
- en: user = User.query.filter_by(username=data['username']).one()
  prefs: []
  type: TYPE_NORMAL
- en: assert user.email == data['email']
  prefs: []
  type: TYPE_NORMAL
- en: assert user.password
  prefs: []
  type: TYPE_NORMAL
- en: assert flask_bcrypt.check_password_hash(
  prefs: []
  type: TYPE_NORMAL
- en: user.password, data['password'])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: import sqlalchemy
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_signup_invalid_user(client):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Try to sign up with invalid data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'data = {''username'': ''x'', ''email'': ''short@example.com'','
  prefs: []
  type: TYPE_NORMAL
- en: '''password'': ''a great password''}'
  prefs: []
  type: TYPE_NORMAL
- en: response = client.post('/users/signup', data=data)
  prefs: []
  type: TYPE_NORMAL
- en: With a form error, we still return a 200 to the client since
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: browsers are not always the best at handling proper 4xx response codes.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: assert response.status_code == 200
  prefs: []
  type: TYPE_NORMAL
- en: assert 'must be between 3 and 40 characters long.' in response.data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_signup_invalid_user_missing_fields(client):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Try to sign up with missing email."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'data = {''username'': ''no_email'', ''password'': ''a great password''}'
  prefs: []
  type: TYPE_NORMAL
- en: response = client.post('/users/signup', data=data)
  prefs: []
  type: TYPE_NORMAL
- en: assert response.status_code == 200
  prefs: []
  type: TYPE_NORMAL
- en: assert 'This field is required' in response.data
  prefs: []
  type: TYPE_NORMAL
- en: 'with pytest.raises(sqlalchemy.orm.exc.NoResultFound):'
  prefs: []
  type: TYPE_NORMAL
- en: User.query.filter_by(username=data['username']).one()
  prefs: []
  type: TYPE_NORMAL
- en: 'data = {''username'': ''no_password'', ''email'': ''test@example.com''}'
  prefs: []
  type: TYPE_NORMAL
- en: response = client.post('/users/signup', data=data)
  prefs: []
  type: TYPE_NORMAL
- en: assert response.status_code == 200
  prefs: []
  type: TYPE_NORMAL
- en: assert 'This field is required' in response.data
  prefs: []
  type: TYPE_NORMAL
- en: 'with pytest.raises(sqlalchemy.orm.exc.NoResultFound):'
  prefs: []
  type: TYPE_NORMAL
- en: User.query.filter_by(username=data['username']).one()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'class Post(db.Model):'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: user = db.relationship('User',
  prefs: []
  type: TYPE_NORMAL
- en: backref=db.backref('posts', lazy='dynamic'))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '@users.route(''/feed'', methods=[''GET''])'
  prefs: []
  type: TYPE_NORMAL
- en: '@login_required'
  prefs: []
  type: TYPE_NORMAL
- en: 'def feed():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: List all posts for the authenticated user; most recent first.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: posts = current_user.newsfeed()
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('users/feed.html', posts=posts)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '{% extends "layout.html" %}'
  prefs: []
  type: TYPE_NORMAL
- en: '{% block content %}'
  prefs: []
  type: TYPE_NORMAL
- en: <div class="new-post">
  prefs: []
  type: TYPE_NORMAL
- en: <p><a href="{{url_for('posts.add')}}">New Post</a></p>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '{% for post in posts %}'
  prefs: []
  type: TYPE_NORMAL
- en: <div class="post">
  prefs: []
  type: TYPE_NORMAL
- en: <span class="author">{{post.user.username}}</span>, published on <span class="date">{{post.created_on}}</span>
  prefs: []
  type: TYPE_NORMAL
- en: <pre><code>{{post.content}}</code></pre>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endfor %}'
  prefs: []
  type: TYPE_NORMAL
- en: '{% endblock %}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: from flask import Blueprint, render_template, url_for, redirect, flash, current_app
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.login import login_required, current_user
  prefs: []
  type: TYPE_NORMAL
- en: from flask.ext.wtf import Form
  prefs: []
  type: TYPE_NORMAL
- en: from wtforms import StringField
  prefs: []
  type: TYPE_NORMAL
- en: from wtforms.widgets import TextArea
  prefs: []
  type: TYPE_NORMAL
- en: from wtforms.validators import DataRequired
  prefs: []
  type: TYPE_NORMAL
- en: from sqlalchemy import exc
  prefs: []
  type: TYPE_NORMAL
- en: from models import Post
  prefs: []
  type: TYPE_NORMAL
- en: from application import db
  prefs: []
  type: TYPE_NORMAL
- en: posts = Blueprint('posts', __name__, template_folder='templates')
  prefs: []
  type: TYPE_NORMAL
- en: 'class CreatePostForm(Form):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Form for creating new posts."""'
  prefs: []
  type: TYPE_NORMAL
- en: content = StringField('content', widget=TextArea(),
  prefs: []
  type: TYPE_NORMAL
- en: validators=[DataRequired()])
  prefs: []
  type: TYPE_NORMAL
- en: '@posts.route(''/add'', methods=[''GET'', ''POST''])'
  prefs: []
  type: TYPE_NORMAL
- en: '@login_required'
  prefs: []
  type: TYPE_NORMAL
- en: 'def add():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add a new post."""'
  prefs: []
  type: TYPE_NORMAL
- en: form = CreatePostForm()
  prefs: []
  type: TYPE_NORMAL
- en: 'if form.validate_on_submit():'
  prefs: []
  type: TYPE_NORMAL
- en: user_id = current_user.id
  prefs: []
  type: TYPE_NORMAL
- en: post = Post(user_id=user_id, content=form.content.data)
  prefs: []
  type: TYPE_NORMAL
- en: db.session.add(post)
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: db.session.commit()
  prefs: []
  type: TYPE_NORMAL
- en: 'except exc.SQLAlchemyError:'
  prefs: []
  type: TYPE_NORMAL
- en: current_app.exception("Could not save new post!")
  prefs: []
  type: TYPE_NORMAL
- en: flash("Something went wrong while creating your post!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return render_template('posts/add.html', form=form)
  prefs: []
  type: TYPE_NORMAL
- en: return redirect(url_for('users.feed'))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '{% extends "layout.html" %}'
  prefs: []
  type: TYPE_NORMAL
- en: '{% block content %}'
  prefs: []
  type: TYPE_NORMAL
- en: <form action="{{ url_for('posts.add')}}" method="post">
  prefs: []
  type: TYPE_NORMAL
- en: '{{ form.hidden_tag() }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ form.id }}'
  prefs: []
  type: TYPE_NORMAL
- en: <div class="row">
  prefs: []
  type: TYPE_NORMAL
- en: '<div>{{ form.content.label }}: {{ form.content }}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{% if form.content.errors %}'
  prefs: []
  type: TYPE_NORMAL
- en: <ul class="errors">{% for error in form.content.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endif %}'
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div><input type="submit" value="Post"></div>
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endblock %}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'def create_app(config=None):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__)
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from application.users.views import users
  prefs: []
  type: TYPE_NORMAL
- en: app.register_blueprint(users, url_prefix='/users')
  prefs: []
  type: TYPE_NORMAL
- en: from application.posts.views import posts
  prefs: []
  type: TYPE_NORMAL
- en: app.register_blueprint(posts, url_prefix='/posts')
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Once the preceding code is in place, we can generate a few test users and posts
    for these users by creating user accounts via the web interface at the `/users/signup`
    endpoint and then creating posts for the users at `/posts/add`. Otherwise, we
    could create a small CLI script to do this for us, which we will learn how to
    implement in the next chapter. We could also write a few test cases to ensure
    that the newsfeed works as expected. Actually, we could do all three!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by first introducing the concept of an application factory
    and described some of the benefits and trade-offs of this approach. Next, we used
    our newly created application factory to set up our first test suite using `py.test`,
    which required some modification as to how our application object was created
    in order to ensure that we obtained a suitable instance that was configured to
    test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we dove headfirst into implementing the basic data models behind a typical
    web application that contained *social* features with the ability to follow other
    users and be followed ourselves. We briefly touched on several main implementation
    patterns for so-called newsfeed applications and used the simplest version for
    our own data models.
  prefs: []
  type: TYPE_NORMAL
- en: This then led us to discuss and explore the concept of the publish/subscribe
    design pattern, of which an in-process implementation can be found in the `Blinker`
    package that Flask and various Flask extensions integrate. Using this new knowledge,
    we created our own publishers and subscribers, allowing us to address some common
    cross-cutting concerns that exist in many modern web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our next project, we will switch gears from creating the HTML-based forms
    and views that we have used for the past few chapters and focus on another very
    important part of modern web applications: providing a useful JSON API to interact
    with.'
  prefs: []
  type: TYPE_NORMAL
