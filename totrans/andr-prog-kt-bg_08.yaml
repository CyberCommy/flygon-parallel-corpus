- en: Chapter 8. Kotlin Decisions and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned about variables and we now understand how to change the
    values that they hold with expressions, but how can we take a course of action
    that is dependent upon the value of a variable?
  prefs: []
  type: TYPE_NORMAL
- en: We can certainly add the number of new messages to the number of previously
    unread messages, but how can we, for example, trigger an action within our app
    when the user has read all their messages?
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that we need a way to test the value of a variable, and
    then respond when the value falls within a range of values or is equal to a specific
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that is common in programming is that we need sections of our
    code to be executed a certain number of times (more than once or sometimes not
    at all) depending on the values of variables.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the first problem, we will look at making decisions in Kotlin with
    `if`, `else`, and `when`. To solve the latter, we will look at loops in Kotlin
    with `while`, `do` – `while`, `for`, `continue`, and `break`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we will learn that, in Kotlin, decisions are also expressions
    that produce a value. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions with `if`, `else`, `else` – `if`, and `switch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `when` demo app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin `while` loops and `do` - `while` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's learn more about Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Kotlin code will constantly be making decisions. For example, we might need
    to know whether the user has new messages, or whether they have a certain number
    of friends. We need to be able to test our variables to see whether they meet
    certain conditions, and then execute a specific section of code depending upon
    whether they did or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, as our code gets more in-depth, it helps to present the code
    in a way that makes it more readable. Let's take a look at code indenting to make
    our discussion about making decisions easier.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting code for clarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have probably noticed that the Kotlin code in our project is indented.
    For example, the first line of code inside the `MainActivity` class is indented
    by one tab. Additionally, the first line of code is indented inside each function
    by another tab; here is an annotated diagram to make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indenting code for clarity](img/B12806_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that when the indented block has ended, often with a closing curly brace
    (`}`), it is indented to the same extent as the line of code that began the block.
  prefs: []
  type: TYPE_NORMAL
- en: We do this to make the code more readable. It is not part of the Kotlin syntax,
    however, and the code will still compile if we don't bother to do this.
  prefs: []
  type: TYPE_NORMAL
- en: As our code gets more complicated, indenting, along with comments, helps to
    keep the meaning and structure of our code clear. I mention this now because when
    we start to learn the syntax for making decisions in Kotlin, indenting becomes
    especially useful and it is recommended that you indent your code the same way.
    Most of this indenting is done for us by Android Studio, but not all of it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to present our code more clearly, we can learn about more
    operators, and then we can get to work by making decisions with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: More Kotlin operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can already add (`+`), take away (`-`), multiply (`*`), divide (`/`), assign
    (`=`), increment (`++`), and decrement (`--`) with operators. Now we will explore
    some more useful operators, and then we will go straight onto learning about how
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry about memorizing each of the following operators. Glance over them
    and their explanations, and then move on to the next section. There, we will put
    a few operators to use and they will become much clearer as we see the examples
    of what they allow us to do. They are presented here in a list just to make the
    variety and scope of operators clear from the start. The list will also be more
    convenient to refer to later when not intermingled with the discussion about implementation
    that follows it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use operators to create an expression that is either true or false. We wrap
    that expression in parentheses or brackets like this: `(expression goes here)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the comparison operator. It tests for equality and is either true or
    false; it is of the `Boolean` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An expression such as `(10 == 9)`, for example, is false. 10 is obviously not
    equal to 9\. However, an expression such as `(2 + 2 == 4)` is obviously true.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That is, except in *1984*, when 2 + 2 == 5 ([https://en.wikipedia.org/wiki/Nineteen_Eighty-Four](https://en.wikipedia.org/wiki/Nineteen_Eighty-Four)).
  prefs: []
  type: TYPE_NORMAL
- en: The logical NOT operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the logical NOT operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is used to test the negation of an expression. If the expression is false,
    then the NOT operator causes the expression to be true.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the expression `(!(2+2 == 5))` evaluates to true because 2 + 2
    *is not* 5\. But, a further example of `(!(2 + 2 = 4))` is false. This is because
    2 + 2 *is* obviously 4.
  prefs: []
  type: TYPE_NORMAL
- en: The NOT equal operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the NOT equal operator and it is another comparison operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The NOT equal operator tests whether something is NOT equal; for example, the`(10
    != 9)` expression is true because 10 is not equal to 9\. On the other hand, `(10
    != 10)` is false because 10 is equal to 10.
  prefs: []
  type: TYPE_NORMAL
- en: The greater-than operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another comparison operator (and there are a few more as well) is the greater-than
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This operator tests whether something is greater than something else. The expression
    `(10 > 9)` is true, but the expression `(9 > 10)` is false.
  prefs: []
  type: TYPE_NORMAL
- en: The less-than operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can probably guess that this operator tests for values that are less than
    others; here is what the operator looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The expression `(10 < 9)` is false because 10 is not less than 9, while the
    expression `(9 < 10)` is true.
  prefs: []
  type: TYPE_NORMAL
- en: The greater-than-or-equal-to operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator tests whether one value is greater than or equal to the other,
    and if either is true, the result is true. This is what the operator looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As an example, the expression `(10 >= 9)`is true, the expression `(10 >= 10)`
    is also true, but the expression `(10 >= 11)` is false because 10 is neither greater
    than nor equal to 11.
  prefs: []
  type: TYPE_NORMAL
- en: The less-than-or-equal-to operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like the previous operator, this one tests for two conditions, but this time,
    **less** than or equal to; take a look at the following operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The expression `(10 <= 9)` is false, the expression `(10 <= 10)` is true, and
    the expression `(10 <= 11)` is also true.
  prefs: []
  type: TYPE_NORMAL
- en: The logical AND operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is known as logical AND. It tests two or more separate parts
    of an expression, and both or all parts must be true for the entire expression
    to be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression `((10 > 9) && (10 < 11))` is true because both
    parts are true. On the other hand, the expression `((10 > 9) && (10 < 9))` is
    false because only one part of the expression is true – `(10 > 9)`, while the
    other is false – `(10 < 9)`.
  prefs: []
  type: TYPE_NORMAL
- en: The logical OR operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is called logical OR and it is just like logical AND, except
    that only one of two or more parts of an expression needs to be true for the expression
    to be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Take another look at the previous example that we used for logical AND, but
    instead, replace `&&` with `||`. The expression `((10 > 9) || (10 < 9))` is now
    true because only one or more parts of the expression needs to be true.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing these operators in a more practical context, in this chapter and throughout
    the rest of the book, will help to clarify their different uses. Now we know how
    to form expressions with operators, variables, and values. Next, we can look at
    a way of structuring and combining expressions to make several deep decisions.
  prefs: []
  type: TYPE_NORMAL
- en: How to use all these operators to test variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All these operators are virtually useless without a way of properly using them
    to make real decisions that affect real variables and code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the information we need, we can look at a hypothetical
    situation, and then actually examine some code for decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Using the if expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you have seen, operators serve very little purpose on their own, but it is
    useful to see just part of the wide and varied range that is available to us.
    Now when we look at putting the most common operator, `==`, to use, we can start
    to see the powerful, yet fine, control that they offer us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the previous examples less abstract. Meet the **if** expression
    by examining the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code starts by declaring and initializing an `Int` type called
    `time` to the value of `9`. The next line of code is quite interesting as it does
    two things. The `if(time < 12)` expression is a test; we know that time is less
    than `12` because we just initialized it to `9`. As the condition is true, the
    `if` expression returns the `"am"` value and the first part of the line of code
    before the `if` expression declares and initializes a new `String` type called
    `amOrPm` with that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Had we initialized the `time` variable to any value that was not less than
    12 (that is, 12 or higher) then the value returned would have been `"pm"` from
    the `else` block. If you copy and paste the preceding code into a project, such
    as the `onCreate` function, the output in logcat will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `if` expression is evaluated and, if the condition is true, then the code
    in the first set of curly braces (`{…}`) is executed; if the condition is false,
    then the code in the `else {…}` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that `if` does not have to return a value, rather it could
    simply execute some code based on the result of the test; take a look at the following
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there is no returned value; we only care that the correct
    bit of code gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically, there is still a value returned (in this case, true or false),
    but we chose not to do anything with it.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our `if` expression can handle more than two outcomes, as we will
    see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `if` in a String template. We saw in the previous chapter that
    we can insert an expression into a `String` type by inserting the expression between
    curly brackets following the `$` symbol. Here is a reminder of the code from the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part in the preceding code will cause the value of `yearOfBirth`
    that is subtracted from `currentYear` being printed amongst the rest of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample shows how we can insert an entire `if` expression
    into a `String` template in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses `if` to test whether the `weight` variable was initialized
    to a value that was greater than or equal to 25\. Depending upon whether the expression
    is true, it will add the word `hold` or the word `cabin` into the `String` initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute the preceding code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you change the initialization of `weight` to any value under 25 and execute
    the code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at a more complicated example.
  prefs: []
  type: TYPE_NORMAL
- en: If they come over the bridge, shoot them!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next example, we will use `if`, a few conditional operators, and a short
    story to demonstrate their use.
  prefs: []
  type: TYPE_NORMAL
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Kotlin program (what else?) to convey his last
    orders after he has died. The troops must hold one side of a bridge while awaiting
    reinforcements, but with a few rules that determine their actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command the captain wants to make sure his troops understand is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**If they come over the bridge, shoot them.**'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we simulate this situation in Kotlin? We need a `Boolean` variable
    –`isComingOverBridge`. The next bit of code assumes that the `isComingOverBridge`
    variable has been declared and initialized to either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use `if` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the `isComingOverBridge` Boolean is true, the code inside the opening and
    closing curly braces will execute. If `isComingOverBridge` is false, the program
    continues after the `if` block and without running the code within it.
  prefs: []
  type: TYPE_NORMAL
- en: Else do this instead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The captain also wants to tell his troops what to do if the enemy is not coming
    over the bridge. In this situation, he wants them to stay where they are and wait.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we can use `else`. When we want to explicitly do something when the
    `if` expression does not evaluate to true, we use `else`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The captain then realizes that the problem isn't as simple as he first thought.
    What if the enemy comes over the bridge, but has too many troops? His squad will
    be overrun and slaughtered.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, he comes up with the following code (this time, we''ll use some variables
    as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has three possible paths of execution. The first is for
    if the enemy is coming over the bridge and the friendly troops are greater in
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is for if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The third and final possible outcome that will execute if neither of the other
    two paths are true is captured by the final `else` statement without an `if` condition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Reader challenge**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly
    and will, therefore, be handled by the final `else` statement, which is meant
    for when there are no enemy troops. Any self-respecting captain would expect his
    troops to fight in this situation, and he could have changed the first `if` statement
    to accommodate this possibility, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if(isComingOverBridge && friendlyTroops >= enemyTroops)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the captain''s last concern is that if the enemy comes over the bridge
    waving the white flag of surrender and are promptly slaughtered, then his men
    will end up as war criminals. The code required here is obvious; using the `wavingWhiteFlag`
    Boolean variable, he can write the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, where to put this code is less clear. In the end, the captain opts
    for the following nested solution, and changing the test for `wavingWhiteFlag`
    to logical NOT, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that we can nest `if` and `else` statements inside one another
    in order to create deep and detailed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We could go on making more and more complicated decisions with `if` and `else,`
    but what we have seen here is more than enough as an introduction.
  prefs: []
  type: TYPE_NORMAL
- en: It is probably worth pointing out that, very often, there is more than one way
    to arrive at a solution to a problem. The *right* way will usually be the way
    that solves the problem in the clearest and simplest manner.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at some other ways to make decisions in Kotlin, and then we
    can put them all together in an app.
  prefs: []
  type: TYPE_NORMAL
- en: Using when to make decisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the vast and virtually limitless possibilities of combining the
    Kotlin operators with `if` and `else` statements. But, sometimes, a decision in
    Kotlin can be better made in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to make decisions and execute different sections of code based
    on a range of possible outcomes, we can use `when`. The following code declares
    and initializes the `rating` variable and then outputs a different response to
    the logcat window based on the value of `rating`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you copy and paste the preceding code into the `onCreate` function of an
    app, it will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The code works by first initializing the `Int` variable, called `rating`, to
    `4`. The `when` block then uses `rating` as its condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, five separate possibilities for the values that rating could be initialized
    to are handled. For each of the values, `1` through `5`, a different message is
    output to the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is an `else` block that executes if none of the specified options
    are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at a slightly different usage of `when` by building a small
    demo app.
  prefs: []
  type: TYPE_NORMAL
- en: The When Demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, create a new Android project called `When Demo`. Use an **Empty
    Activity** project template and leave all the other options in their usual settings.
    Switch to the `MainActivity.kt` file by left-clicking on the **MainActivity.kt**
    tab above the editor and we can start coding.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the code for this app in the `Chapter08/When Demo` folder of the
    download bundle. The file also includes code that is related to our previous discussions
    on expressions and `if`. Why not play around with the code, run the app, and study
    the output?
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code inside the `onCreate` function. The app demonstrates
    that multiple different values can trigger the same path of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, there are four possible paths of execution based on
    the value that the `name` variable is initialized to. If any of the `Atlantic`,
    `Pacific`, or `Arctic` values are used, then the following line of code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If any of the `Thames`, `Nile`, or `Mississippi` values are used, then the
    following line of code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If any of the = `Labrador`, `Beagle`, or `Jack Russel` values are used, then
    the following line of code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If none of the oceans, rivers, or dogs are used to initialize the `name` variable,
    then the app branches to the `else` block and executes this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the app with `name` initialized to `Nile` (as the preceding
    code does), this is the output that you will see in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Run the app a few times and, each time, change the initialization of `name`
    to something new. Notice that when you initialize `name` to something that is
    explicitly handled by a statement, we get the expected output. Otherwise, we get
    the default output handled by the `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a lot of code to execute for an option in a `when` block, we can
    contain it all in a function and then call that function. I have highlighted the
    changed line in the following hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we will then need to write the new `printFullDetailsOfOcean` function.
    Then, when `name` is initialized to one of the oceans explicitly handled, the
    `printFullDetailsOfOcean` function will be executed. The execution will then return
    to the first line of code outside the `when` block.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering about the significance of placing the `name` variable
    in the brackets of the `printFullDetailsOfOcean(name)` function call. What is
    happening is that we are passing the data stored in the `name` variable to the
    `printFullDetailsOfOcean` function. This then means that the `printFullDetailsOfOcean`
    function can use that data. This will be covered in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one of the things that this code seriously lacks is interaction with
    a GUI. We have seen how we can call functions from button clicks, but even that
    isn't enough to make this code worthwhile in a real app. We will see how we solve
    this problem in [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to the
    UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem we have is that after the code has been executed, then that's
    it – the app won't do anything else! We need it to continually ask the user for
    instructions, not just once, but over and over. We will look at a solution to
    this problem next.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating code with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will learn how to repeatedly execute portions of our code in a controlled
    and precise way by looking at several types of **loop** in Kotlin. These include
    `while` loops, `do-while` loops, and `for` loops. We will also learn about the
    most appropriate situations in which to use these different types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: It is completely reasonable to ask what loops have to do with programming, but
    they are exactly what the name implies. They are a way of repeating the same part
    of the code more than once, or looping over the same part of code, although, potentially
    for a different outcome each time.
  prefs: []
  type: TYPE_NORMAL
- en: This can simply mean doing the same thing until the code being looped over (**iterated**)
    prompts the loop to end. It could be a predetermined number of iterations as specified
    by the loop code itself. It might be until a predetermined situation or **condition**
    is met. Or, it could be a combination of these things. Along with `if`, `else`,
    and `when`, loops are part of the Kotlin **control flow statements**.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at all the major types of loop that Kotlin offers us to control
    our code, and we will use some of them to implement a working mini-app to make
    sure that we understand them completely. Let's take a look at the first and simplest
    loop type in Kotlin, the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin `while` loops have the simplest syntax. Think back to the `if` statements
    for a moment; we could use virtually any combination of operators and variables
    in the conditional expression of the `if` statement. If the expression evaluated
    to true, then the code in the body of the `if` block is executed. With the `while`
    loop, we also use an expression that can evaluate to true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the preceding code; what happens here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the `while` loop, an `Int` type named `x` is declared and initialized
    to 10\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `while` loop begins; its condition is `x > 0`. So, the `while` loop
    will execute the code in its body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code in its body will repeatedly execute until the condition evaluates to
    false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the preceding code will execute 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: On the first pass, `x` equals 10 on the second pass it equals 9, then 8, and
    so on. But once `x` is equal to 0, it is, of course, no longer greater than 0\.
    At this point, the execution will exit the `while` loop and continue with the
    first line of code (if any) after the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way as an `if` statement, it is possible that the `while` loop
    will not execute even once. Take a look at the following example, where the code
    in the `while` loop will not execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, there is no limit to the complexity of the conditional expression
    or the amount of code that can go in the loop body; here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `while` loop will continue to execute until both `newMessages`
    and `unreadMessages` are equal to, or less than, zero. As the condition uses the
    logical OR operator (`||`), either one of those conditions being true will cause
    the `while` loop to continue executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete, even if the expression evaluates to false part of the way through.
    This is because it is not tested again until the code tries to start another pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever! This is called an **infinite loop**; here is an example
    of an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will never end; it will loop round and round forever. We
    will see some solutions for controlling when to break out of a `while` loop shortly.
    Next, we will look at a variation on the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: do-while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `do` – `while` loop works in the same way as the ordinary `while` loop
    except that the presence of a `do` block guarantees that the code will execute
    at least once, even when the condition of the `while` expression does not evaluate
    to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you copy and paste this code into one of your apps in the `onCreate` function,
    and then execute it, the output might not be what you expect. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is a less-used but sometimes perfect solution for a problem. Even though
    the condition of the `while` loop is false, the `do` block executes its code,
    increments the `y` variable to 11, and prints a message to logcat. The condition
    of the `while` loop is `y < 10`, so the code in the `do` block is not executed
    again. If the expression in the `while` condition is true, however, then the code
    in the `do` block continues to execute as though it was a regular `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to continue our discussion on loops, it is necessary to briefly introduce
    the topic of ranges. Ranges are intimately connected to the Kotlin topic of arrays,
    which we will discuss more fully in [Chapter 15](ch15.html "Chapter 15. Handling
    Data and Generating Random Numbers"), *Handling Data and Generating Random Numbers*.
    What follows is a quick introduction to ranges to enable us to then go on to cover
    `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following line of code that uses a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What is happening is that we are using type inference to create a list of values
    that contains the values 1, 2, 3, and 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also explicitly declare and initialize a list, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `listOf` keyword to explicitly create a list containing
    the numbers 1 through to 10 inclusively.
  prefs: []
  type: TYPE_NORMAL
- en: How these work under the hood will be explored in more depth when we learn about
    arrays in [Chapter 15](ch15.html "Chapter 15. Handling Data and Generating Random
    Numbers"), *Handling Data and Generating Random Numbers*. Then, we will see that
    there is much more to ranges, arrays, and lists than we have covered here. It
    is just helpful to have this quick introduction to complete our discussion of
    loops by looking at the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a `for` loop, we need a range or list. We can then use a `for` loop
    to step through that list and execute some code in each step; take a look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the output this will produce if copied and pasted into an app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output that the `list` variable does indeed contain all
    the values from 1 through to 10\. On each pass through the loop, the `i` variable
    holds the current value. You can also see that the `for` loop allows us to iterate
    through all those values and execute some code based on those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can use the opening and closing curly braces with a `for` loop
    when we want the loop to contain multiple lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, the `for` loop is extremely flexible and can handle much more than
    just simple `Int` values. We will not explore all the options in this chapter
    because we need to learn more about classes first. We will, however, be returning
    to the `for` loop in a number of places throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling loops with break and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having just discussed all the ways that we can control looping through code,
    it is important to know that sometimes we need to break out of a loop earlier
    than the condition of the loop specifies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such occasions, Kotlin has the `break` keyword. Here is `break` in action
    with a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the condition of the `while` loop should make the code
    repeatedly execute while the `countDown` variable is greater than zero. However,
    inside the `while` loop, there is an `if` expression that checks to see whether
    `countDown` is equal to 5\. If it is equal to 5, the `break` statement is used.
    Also, inside the `while` loop, the value of `countDown` is printed to the logcat
    window and is decremented (reduced by 1). Take a look at the following output
    when this code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding output that when `countDown` equals 5, the `break`
    statement executes, and execution exits the `while` loop before it gets to print
    to the logcat window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we might want to execute only a part of the code within a loop but
    not stop looping entirely. For this, Kotlin has the `continue` keyword. Take a
    look at the following code with a `while` loop, which demonstrates how we can
    make use of `continue` in our apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we initialize a variable called `countUp` to zero. We
    then set up a `while` loop to keep executing while `countUp` is less than 10\.
    Inside the `while` loop, we increment (increase by 1) `countUp`. The next line
    of code checks to see whether `countUp` is greater than 5 and, if it is, the `continue`
    statement is executed. The next line of code prints the value of `countUp` to
    the logcat window. The line of code that prints the value will only execute when
    `countUp` is 5 or lower because the `continue` statement sends the execution of
    the app back to the start of the loop. Take a look at the following output of
    code to verify what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding output that `countUp` is printed while its value
    is 5 or lower. Once its value exceeds 5, the `continue` statement prevents the
    line of code that does the printing from being executed. However, the final line
    of code outside the loop prints the value of `countUp`, and you can see that its
    value is 10, indicating that the first line of code in the loop, which increments
    `countUp`, executed continuously through to the completion of the `while` loop
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` and `continue` keywords can also be used in `for` loops and `do`
    – `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to play around with loop code, you can create a new project called
    `Loops Demo` and copy any of the code from this chapter into the end of the `onCreate`
    function. I have placed the code that we have used throughout our discussion of
    loops in the `Chapter08/Loops Demo` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used `if`, `else`, and `when` to make decisions with expressions
    and branch our code. We saw and practiced with `while`, `for`, and `do`- `while`
    to repeat parts of our code. Furthermore, we used `break` for breaking out of
    a loop before the condition would otherwise allow, and we used `continue` to conditionally
    execute only part of the code in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter if you don't remember everything straight away, as we will
    constantly be using all these techniques and keywords throughout the book. We
    will also explore a number of more advanced ways to use some of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a much closer look at Kotlin functions, which
    is where all our tests and loops code will go.
  prefs: []
  type: TYPE_NORMAL
