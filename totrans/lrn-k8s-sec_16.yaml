- en: '*Chapter 13*: Learning from Kubernetes CVEs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Common Vulnerabilities and Exposures** (**CVEs**) are identifications for
    publicly known security vulnerabilities and exposures that are found in popular
    applications. The CVE ID is made up of the `CVE` string followed by the year and
    the ID number for the vulnerability. The CVE database is publicly available and
    is maintained by the MITRE Corporation. The CVE entries include a brief description
    of each issue, which is helpful to understand the root cause and severity of the
    issue. These entries do not include technical details about the issue. CVEs are
    useful for IT professionals to coordinate and prioritize updates. Each CVE has
    a severity associated with it. MITRE uses a **Common Vulnerability Scoring System**
    (**CVSS**) to assign a severity rating to a CVE. It is recommended to patch high-severity
    CVEs immediately. Let''s look at an example of a CVE entry on [cve.mitre.org](http://cve.mitre.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, a CVE entry includes the ID, a
    brief description, references, the name of the **CVE Numbering Authority** (**CNA**),
    and the date on which the entry was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – MITRE entry for CVE-2018-18264'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_13_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – MITRE entry for CVE-2018-18264
  prefs: []
  type: TYPE_NORMAL
- en: For security researchers and attackers, the most interesting part of a CVE entry
    is the **References** section. References for CVEs are links to blogs published
    by researchers covering the technical details of the issue, as well as links to
    issue descriptions and pull requests. Security researchers study the references
    to understand the vulnerability and develop mitigations for similar issues or
    for known issues that don't have a fix yet. Attackers, on the other hand, study
    the references to find unpatched variations of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss four publicly known security vulnerabilities
    of Kubernetes. First, we will look at a path-traversal issue—CVE-2019-11246\.
    This issue allowed attackers to modify the content on the client side, which could
    potentially lead to exfiltration or code execution on the cluster administrator's
    machine. Next, we will discuss CVE-2019-1002100, which allows users to cause **Denial-of-Service**
    (**DoS**) attacks on the API server. Then, we will discuss CVE-2019-11253, which
    allows unauthenticated users to cause DoS attacks on `kube-apiserver`. Lastly,
    we will discuss CVE-2019-11247, which allows users with namespace privileges to
    modify cluster-wide resources. We will discuss mitigation strategies for each
    CVE. Upgrading to the latest version of Kubernetes and `kubectl`, which patches
    vulnerabilities, should be your first priority. The latest stable version of Kubernetes
    can be found at [https://github.com/kubernetes/kubernetes/releases](https://github.com/kubernetes/kubernetes/releases).
    The mitigation strategies that we will discuss will help strengthen your cluster
    against attacks of a similar nature. Finally, we will introduce `kube-hunter`,
    which can be used to scan Kubernetes clusters for known security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The path traversal issue in kubectl cp—CVE-2019-11246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DoS issue in JSON parsing—CVE-2019-1002100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DoS issue in YAML parsing—CVE-2019-11253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The privilege-escalation issue in role parsing—CVE-2019-11247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning known vulnerabilities using kube-hunter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path traversal issue in kubectl cp – CVE-2019-11246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers often copy files to or from containers in a Pod for debugging. `kubectl
    cp` allows developers to copy files from or to a container in a Pod (by default,
    this is done in the first container within the Pod).
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy files to a Pod, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy files from a Pod, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When files are copied from a pod, Kubernetes first creates a TAR archive of
    the files inside the container. It then copies the TAR archive to the client and
    then finally unpacks the TAR archive for the client. In 2018, researchers found
    a way to use `kubectl cp` to overwrite files on the client's host. If an attacker
    has access to a pod, this vulnerability could be used to replace the TAR archive
    with special files that use relative paths by overwriting the original TAR binary
    with a malicious one. When the malformed TAR file was copied to the host, it could
    overwrite the files on the host when it was extracted. This could lead to data
    compromise and code execution on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example where the attacker modifies the TAR archive to have
    two files: `regular.txt` and `foo/../../../../bin/ps`. In this archive, `regular.txt`
    is the file that the user is expecting and `ps` is a malicious binary. If this
    archive is copied to `/home/user/admin`, the malicious binary overwrites the well-known
    `ps` binary in the `bin` folder. The first patch for this issue was incomplete
    and attackers found a way to exploit the same issue using symlinks. Researchers
    found a way to bypass the fix for symlinks, which was finally addressed in versions
    1.12.9, 1.13.6, and 1.14.2, and was assigned CVE-2019-11246.'
  prefs: []
  type: TYPE_NORMAL
- en: Mitigation strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following strategies to harden your cluster against this issue
    and issues similar to CVE-2019-11246 that haven''t yet been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always use the updated version of kubectl**: You can find the latest version
    of the `kubectl` binary by using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Use admission controllers to limit the use of kubectl cp**: As we discussed
    in [*Chapter 7*](B15566_07_Final_ASB_ePub.xhtml#_idTextAnchor186), *Authentication,
    Authorization, and Admission Control*, Open Policy Agent can be used as an admission
    controller. Let''s look at a policy that denies calls to `kubectl cp`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This policy denies the execution of a TAR binary in the pod, thereby disabling
    `kubectl cp` for all users. You can update this policy to allow `kubectl cp` for
    specific users or groups.
  prefs: []
  type: TYPE_NORMAL
- en: '**Apply appropriate access controls to the client**: If you are an administrator
    of a production cluster, there are many secrets on your work machine that the
    attackers might want access to. Ideally, the build machine should not be your
    work laptop. Having dedicated hardware that admins can `ssh` into to access the
    Kubernetes cluster is good practice. You should also ensure that any sensitive
    data on the build machine has appropriate access controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set the security context for all pods**: As discussed in [*Chapter 8*](B15566_08_Final_ASB_ePub.xhtml#_idTextAnchor249),
    *Securing Kubernetes Pods*, ensure that pods have `readOnlyRootFilesystem`, which
    will prevent the files from being tampered with (for example, overwrite `/bin/tar
    binary`) by attackers in the filesystem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Use Falco rules to detect file modification**: We discussed Falco in [*Chapter
    11*](B15566_11_Final_ASB_ePub.xhtml#_idTextAnchor324), *Defense in Depth*. Falco
    rules (which can be found at [https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml](https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml))
    can be set up to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detect modification of a binary in a pod**: Use `Write below monitored dir`
    in the default Falco rules to detect changes to the TAR binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Detect the use of a vulnerable kubectl instance**: `kubectl` versions 1.12.9,
    1.13.6, and 1.14.2 have a fix for this issue. The use of any versions earlier
    than this will trigger the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: CVE-2019-11246 is a great example of why you need to keep track of security
    advisories and read through the technical details to add mitigation strategies
    to your cluster to ensure that if any variations of an issue are discovered, your
    cluster is safe. Next, we will look at CVE-2019-1002100, which can be used to
    cause DoS issues on `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: DoS issues in JSON parsing – CVE-2019-1002100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Patching is a commonly used technique used to update API objects at runtime.
    Developers use `kubectl patch` to update API objects at runtime. A simple example
    of this can be adding a container to a pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding patch file allows a pod to be updated to have a new Redis container.
    `kubectl patch` allows patches to be in JSON format. The issue was in the JSON
    parsing code of `kube-apiserver`, which allowed an attacker to send a malformed
    `json-patch` instance to cause a DoS attack in the API server. In [*Chapter 10*](B15566_10_Final_ASB_ePub.xhtml#_idTextAnchor305),
    *Real-Time Monitoring and Resource Management of a Kubernetes Cluster*, we discussed
    the importance of the availability of services within Kubernetes clusters. The
    root cause of this issue was unchecked error conditions and unbounded memory allocation
    to `kube-apiserver` for the `patch` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigation strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following strategies to harden your cluster against this issue
    and issues similar to CVE-2019-100210 that haven''t yet been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use resource monitoring tools in Kubernetes clusters**: As discussed in [*Chapter
    10*](B15566_10_Final_ASB_ePub.xhtml#_idTextAnchor305), *Real-Time Monitoring and
    Resource Management of a Kubernetes Cluster*, resource-monitoring tools such as
    Prometheus and Grafana can help identify issues of higher memory consumption in
    the master node. High values in the graphs for Prometheus metrics could look as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These resources graph maximum memory, CPU, and network usage by `kube-apiserver`
    over 5-minute intervals. Any abnormality in these usage patterns is a sign of
    an attack on `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up high-availability Kubernetes masters**: We learned about high-availability
    clusters in [*Chapter 11*](B15566_11_Final_ASB_ePub.xhtml#_idTextAnchor324), *Defense
    in Depth*. High-availability clusters have multiple instances of Kubernetes components.
    If the load on one component is high, other instances can be used until the load
    is reduced or the first instance is restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `kops`, you can use `--master-zones={zone1, zone2}` to have multiple
    masters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are multiple `kube-apiserver` pods running in this cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Limit users'' privileges using RBAC**: Privileges to users should also follow
    the principle of least privilege, which was discussed in [*Chapter 4*](B15566_04_Final_ASB_ePub.xhtml#_idTextAnchor108),
    *Applying the Principle of Least Privilege in Kubernetes*. If a user does not
    require access to `PATCH` privileges for any resource, the role should be updated
    so that they don''t have access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test your patches in the staging environment**: Staging environments should
    be set up as a replica of the production environment. Developers are not perfect,
    so it''s possible for a developer to create a malformed patch. If patches or updates
    to the cluster are tested in the staging environment, bugs in the patch can be
    found without disrupting the production services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DoS is often considered a low-severity issue, but if it happens to the core
    component of your cluster, you should take it seriously. DoS attacks on `kube-apiserver`
    can disrupt the availability of the whole cluster. Next, we look at another DoS
    attack against an API server. This attack can be performed by unauthenticated
    users, making it more severe than CVE-2019-1002100.
  prefs: []
  type: TYPE_NORMAL
- en: A DoS issue in YAML parsing – CVE-2019-11253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML bombs, or billion laughs attacks, are popular with any XML parsing code.
    Similar to parsing issues in XML, this was a parsing issue in YAML files that
    were sent to `kube-apiserver`. If a YAML file sent to the server has recursive
    references, it triggers the `kube-apiserver` to consume CPU resources, which causes
    availability issues on the API server. In most cases, requests parsed by `kube-apiserver`
    are restricted to authenticated users, so unauthenticated users should not be
    able to trigger this issue. There was an exception to this rule in the Kubernetes
    versions preceding 1.14 that allowed unauthenticated users to check whether they
    could perform an action using `kubectl auth can-i`.
  prefs: []
  type: TYPE_NORMAL
- en: This issue is similar to CVE-2019-1002100, but is more severe as unauthenticated
    users can also trigger this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigation strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following strategies to harden your cluster against this issue
    and issues similar to CVE-2019-11253 that haven''t yet been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use resource-monitoring tools in Kubernetes clusters**: Similar to CVE-2019-1002100,
    resource-monitoring tools, such as Prometheus and Grafana, which we discussed
    in [*Chapter 10*](B15566_10_Final_ASB_ePub.xhtml#_idTextAnchor305), *Real-Time
    Monitoring and Resource Management of a Kubernetes Cluster*, can help identify
    issues of higher memory consumption in the master node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable RBAC**: The vulnerability is caused by the improper handling of recursive
    entities in the YAML file by `kube-apiserver` and the ability of unauthenticated
    users to interact with the `kube-apiserver`. We discussed RBAC in [*Chapter 7*](B15566_07_Final_ASB_ePub.xhtml#_idTextAnchor186),
    *Authentication, Authorization, and Admission Control*. RBAC is enabled by default
    in the current version of Kubernetes. You can also enable it by passing `--authorization-mode=RBAC`
    to the `kube-apiserver`. In this case, unauthenticated users should not be allowed
    to interact with `kube-apiserver`. For authenticated users, the principle of least
    privilege should be followed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable auth can-i for unauthenticated users (for v1.14.x)**: Unauthenticated
    users should not be allowed to interact with `kube-apiserver`. In Kubernetes v1.14.x,
    you can disable `auth can-i` for unauthenticated servers using the RBAC file at
    [https://github.com/kubernetes/kubernetes/files/3735508/rbac.yaml.txt](https://github.com/kubernetes/kubernetes/files/3735508/rbac.yaml.txt):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The second command disables auto-updates for `clusterrolebinding`, which will
    ensure that the changes are not overwritten on restart.
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-apiserver should not be exposed to the internet**: Allowing access to
    the API servers from trusted entities using a firewall or VPCs is good practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable anonymous-auth**: We discussed `anonymous-auth` as an option that
    should be disabled if possible in [*Chapter 6*](B15566_06_Final_ASB_ePub.xhtml#_idTextAnchor170),
    *Securing Cluster Components*. Anonymous authentication is enabled by default
    in Kubernetes 1.16+ for legacy policy rules. If you are not using any legacy rules,
    it is recommended to disable `anonymous-auth` by default passing `--anonymous-auth=false`
    to the API server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed earlier, a DoS attack on `kube-apiserver` can cause a disruption
    of services throughout the cluster. In addition to using the latest version of
    Kubernetes, which includes a patch for this issue, it is important to follow these
    mitigation strategies to avoid similar issues in your cluster. Next, we will discuss
    an issue in the authorization module that triggers privilege escalation for authenticated
    users.
  prefs: []
  type: TYPE_NORMAL
- en: The Privilege escalation issue in role parsing – CVE-2019-11247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed RBAC in detail in [*Chapter 7*](B15566_07_Final_ASB_ePub.xhtml#_idTextAnchor186),
    *Authentication, Authorization, and Admission Control*. Roles and RoleBindings
    allow users to get the privileges to perform certain actions. These privileges
    are namespaced. If a user needs a cluster-wide privilege, ClusterRoles and ClusterRolebindings
    are used. This issue allowed users to make cluster-wide modifications even if
    their privileges were namespaced. Configurations for admission controllers, such
    as Open Policy Access, could be modified by users with a namespaced role.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigation strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following strategies to harden your cluster against this issue
    and issues similar to CVE-2019-11247 that haven''t yet been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid wildcards in Roles and RoleBindings**: Roles and ClusterRoles should
    be specific to the resource names, verbs, and API groups. Adding `*` to `roles`
    can allow users to have access to resources that they should not have access to.
    This adheres to the principle of least privilege, which we discussed in [*Chapter
    4*](B15566_04_Final_ASB_ePub.xhtml#_idTextAnchor108), *Applying the Principle
    of Least Privilege in Kubernetes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable Kubernetes auditing**: We discussed auditing and audit policies for
    Kubernetes in [*Chapter 11*](B15566_11_Final_ASB_ePub.xhtml#_idTextAnchor324),
    *Defense in Depth*. Kubernetes auditing can help identify any unintended actions
    in a Kubernetes cluster. In most cases, a vulnerability such as this will be used
    to modify and delete any additional controls within the cluster. You can use the
    following policy to identify instances of these kinds of exploits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This policy logs any instances of the deletion or modification of pods in `kube-system`
    or the `monitoring` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: This issue is certainly an interesting one since it highlights that the security
    features provided by Kubernetes can also be harmful if they are misconfigured.
    Next, we will talk about `kube-hunter`, which is an open source tool to find any
    known security issues in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for known vulnerabilities using kube-hunter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security advisories and announcements ([https://kubernetes.io/docs/reference/issues-security/security/](https://kubernetes.io/docs/reference/issues-security/security/))
    published by Kubernetes are the best way to keep track of new security vulnerabilities
    found in Kubernetes. The announcements and advisory emails can get a bit overwhelming
    and it's always possible to miss an important vulnerability. To avoid these situations,
    a tool that periodically checks the cluster for any known CVEs comes to the rescue.
    `kube-hunter` is an open source tool that is developed and maintained by Aqua
    that helps identify known security issues in your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to set up `kube-hunter` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `kube-hunter` pod in your cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'View the logs to find any issues with your cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows a list of known vulnerabilities in Kubernetes v1.13.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Results of kube-hunter'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_13_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Results of kube-hunter
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot highlights some of the issues discovered by `kube-hunter` for
    a Kubernetes v1.13.0 cluster. The issues found by `kube-hunter` should be treated
    as critical and should be addressed immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the importance of CVEs. These publicly known identifiers
    are important for cluster administrators, security researchers, and attackers.
    We discussed the important aspects of CVE entries, which are maintained by MITRE.
    We then looked at four well-known CVEs and discussed the issue and the mitigation
    strategy for each CVE. As a cluster administrator, upgrading the `kubectl` client
    and Kubernetes version should always be your first priority. However, adding mitigation
    strategies to detect and prevent exploits caused by similar issues that have not
    been reported publicly is equally important. Finally, we discussed an open source
    tool, `kube-hunter`, which can be used to periodically identify issues in your
    Kubernetes cluster. This removes the overhead of cluster administrators keeping
    a close eye on security advisories and announcements by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to understand the importance of publicly disclosed vulnerabilities
    and how these advisories help strengthen the overall security posture of your
    Kubernetes cluster. Reading through these advisories will help you identify any
    problems in your cluster and help harden your cluster going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the most important parts of a CVE entry for cluster administrators,
    security researchers, and attackers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are client-side security issues such as CVE-2019-11246 important for a Kubernetes
    cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are DoS issues in the kube-apiserver treated as high-severity issues?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare authenticated versus unauthenticated DoS issues in the API server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discuss the importance of `kube-hunter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CVE list: [https://cve.mitre.org/cve/search_cve_list.html](https://cve.mitre.org/cve/search_cve_list.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting CVE-2019-11246 with Falco: [https://sysdig.com/blog/how-to-detect-kubernetes-vulnerability-cve-2019-11246-using-falco/](https://sysdig.com/blog/how-to-detect-kubernetes-vulnerability-cve-2019-11246-using-falco/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preventing CVE-2019-11246 with OPA: [https://blog.styra.com/blog/investigate-and-correct-cves-with-the-k8s-api](https://blog.styra.com/blog/investigate-and-correct-cves-with-the-k8s-api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub issue for CVE-2019-1002100: [https://github.com/kubernetes/kubernetes/issues/74534](https://github.com/kubernetes/kubernetes/issues/74534)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub issue for CVE-2019-11253: [https://github.com/kubernetes/kubernetes/issues/83253](https://github.com/kubernetes/kubernetes/issues/83253)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub issue for CVE-2019-11247: [https://github.com/kubernetes/kubernetes/issues/80983](https://github.com/kubernetes/kubernetes/issues/80983)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-hunter`: [https://github.com/aquasecurity/kube-hunter](https://github.com/aquasecurity/kube-hunter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub issue for CVE 2020-8555: [https://github.com/kubernetes/kubernetes/issues/91542](https://github.com/kubernetes/kubernetes/issues/91542)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub issue for CVE 2020-8555: [https://github.com/kubernetes/kubernetes/issues/91507](https://github.com/kubernetes/kubernetes/issues/91507)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
