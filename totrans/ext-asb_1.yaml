- en: Chapter 1. Getting Started with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As technology has advanced, computing has become more and more complex. With
    better hardware being manufactured each day, the complexity of computing systems
    has increased. Distributed computing started flourishing, and soon "the cloud"
    was invented. Software became trivial and managing it became a pain. Development
    cycles picked up the pace, and manual testing and deployments soon felt outdated,
    hence calling for automation. If you are reading this book, you probably understand
    the importance of automation, be it for testing an application or managing the
    whole infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: With increasing load and ever-scaling infrastructure, system administrators
    have stopped being simple craftspeople by configuring each system manually and
    have begun to manage thousands of systems at once. For any environment, however
    big it is, you need a reliable system to manage it all. The geographically scattered
    workplaces and ever-growing infrastructure make it nearly impossible to keep track
    of the inventory and manually configure and manage each machine. The paced development
    cycles and reduced time to market leaves little margin for error and throws the
    manual process out the window.
  prefs: []
  type: TYPE_NORMAL
- en: The key to managing the whole infrastructure, deploying builds, speeding up
    the process, and at the same time keeping track of the changes is to have a system
    that is user-friendly, has a small learning curve, and is pluggable as per your
    requirements. What's most important is that you stay focused and spend more time
    managing your infrastructure and the processes rather than the automation scripts
    and management tool itself. Out of the many available solutions, Ansible is one
    such tool with many interesting features. It is easy to extend and works out of
    the box for 90% of user requirements. This book focuses on the remaining 10%.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be exploring:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Ansible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why extend Ansible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Ansible?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Out of the many available tools in the market, how do you choose which tool
    best fits your need? What factors should you consider while choosing a tool to
    satisfy your requirements? Questions may come to mind such as:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the **return on investment** (**ROI**) in terms of money, time, and
    effort?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of support do I get with the tool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the potential associated security risks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the tool flexible enough to be plugged into my infrastructure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the coverage? Are all my requirements addressed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these are the questions that come to mind, I'll try answering them in favor
    of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is free. The only investment you need is some time and effort. Ansible
    playbooks are YAML-based and hence are very easy to read, understand, and maintain,
    thus involving a very small learning curve. Modules hide the complexity underneath.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible is open source. Hence, there is an entire community to back you up.
    You can file in issues or even fix them yourself, since you will always have access
    to the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike other solutions, which are mostly agent-based, Ansible works purely on
    SSH. There is no agent required. Therefore, you can sit back and relax, as there
    is no extra package lying on your production system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible provides a very good API, which you can use to build your own Ansible
    modules that suit your needs and can then be plugged into your infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible provides 90% of user requirements out of the box. The remaining 10%
    has a well-documented API and community support to build your own modules, hence
    increasing the coverage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are satisfied by the above arguments and willing to give Ansible a try,
    read on.
  prefs: []
  type: TYPE_NORMAL
- en: Why extend Ansible?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible comes in handy in various contexts – as a configuration management tool
    and deployment automation tool, as well as for provisioning and orchestration.
    It comes out of the box with a lot of plugins and modules that can be used for
    building playbooks. You can manage your entire infrastructure using Ansible in
    the way most software development projects do. **Infrastructure as Code** (**IAC**)
    applies the same principles of software development to configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: People like Ansible for its simplicity and clear separation of concerns. It
    doesn't force you to adhere to one particular vision of how you should manage
    your configurations. It provides a perfect building block for designing your IAC
    solution, tailored to your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There can be many reasons to extend Ansible. This might range from adding missing
    features to modifying/enhancing existing features as per your own needs. With
    Ansible being an open source, community driven project, not everything can be
    integrated at once. There is always a trade-off between utility and demand. If
    there are not many users of one particular feature, it becomes an overhead for
    the project maintainer to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Need something new
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, you come across a situation where Ansible, in its native form with the available
    modules and plugins, is not enough to meet your requirements. What do you do?
    Change the tool? Look for other options? Maybe even curse your bad luck for not
    being able to foresee what was coming and now you need to change everything?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the answer is NO. Ansible provides a very good API and boilerplate that
    you can use to write your own Ansible modules or plugins as per your requirements.
    Building Ansible modules is easy. Since Ansible is community driven, you might
    even file a feature request for the required module if you feel more people are
    likely to face the same issue you encountered. If you are a developer, you can
    simply write your own Ansible module or plugin and share it with the community.
    Send in a pull request for your module and get into a discussion with the project
    maintainers. Hopefully, the module will be merged and made available in future
    releases of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will see how to extend Ansible as per the requirements and
    distribute the customizations by contributing to an open source project, specifically,
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Company-wide abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Treating your infrastructure as code offers many advantages, but it comes with
    a cost. Not all members of your team will be willing to climb the learning curve.
    As a result, only a few people will become powerful users of any configuration
    management tool such as Ansible, and they will become the bottleneck for the whole
    team.
  prefs: []
  type: TYPE_NORMAL
- en: A good IAC implementation should make it easy for everyone to interact with
    the infrastructure, deploy new software, provision resources, and weave components
    together. Details should be abstracted away as much as possible, behavior should
    be clear, and definitions should be navigable. There should also exist an easy
    way to trace any problems back to a high-level configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, one can develop plugins and modules that can abstract the details
    and provide interfaces that people can directly use and get results from. This
    will help everyone get up to speed and interact with the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: You can create modules and plugins that can make your routine tasks easy. You
    can share these as utilities that can be used by anyone in the company to carry
    out similar tasks. This would require some developer efforts, but would enable
    even the not so powerful users to get the most out of their infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Infrastructure grows gradually to a point where you finally give up managing
    it manually and begin to feel the need for a better way to manage the emergent
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to spend a lot of time looking for the right tool, then
    you end up adopting a complete configuration management solution, and bend over
    backwards to change your problem in order to make it fit into the existing solution.
    Obviously, this approach sounds flawed.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to keep it simple and incrementally exploit the power of
    existing tools when they actually give you an immediate advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is more suited for the latter approach. It is well-written and offers
    a clear separation of concerns and a simple model. In fact, you can choose to
    what degree you want to engage with it. It allows you to reuse components provided
    by the community while remaining in control.
  prefs: []
  type: TYPE_NORMAL
- en: You can exploit the various extension points exposed by Ansible to build modules
    and plugins that suit your needs. Reusing already existing plugins and modules
    and creating your own as and when required provides even more control over your
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is an open source project hosted on GitHub. If you have a GitHub account,
    you can easily fork the Ansible repository and start contributing to the project
    (Ansible code: [https://github.com/ansible/ansible](https://github.com/ansible/ansible)).'
  prefs: []
  type: TYPE_NORMAL
- en: You can fork the project in your own account, clone it, and then make changes
    and send out pull requests to the project owner. This applies to all the open
    source projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know where to start contributing, you can also look at the *Issues*
    section in the repository. The *Issues* section contains bug reports and feature
    requests from people using the tool. You might choose to verify and fix the issues
    and then send in your patch to the project owner as a pull request against an
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: The patches go through a review process, and only after the project maintainer's
    approval, the patch will be merged. Once merged, the feature will then be available
    to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we assume our readers have a working knowledge of Ansible, it is
    useful to run through a brief overview of the Ansible architecture, so as to have
    a better understanding of the various extension points.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is an agentless configuration management system, meaning no special
    software has to run on the managed hosts. Ansible connects to its targets usually
    via plain SSH, copies all the necessary code, and runs it on the target machine.
    Being agentless is one of the main advantages of Ansible over other solutions.
    This reduces the overhead of the setup of agents required on the target machines,
    also reducing security risks, as no extra packages or agents need to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core Ansible components include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inventory**: Target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables**: Information about the target hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection**: How to talk to the target hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runner**: Connect to the target and execute actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playbook**: Recipe to be executed on the target host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facts**: Dynamic information about the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**: Code that implements actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callback**: Collects the results of the playbook actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the architecture of Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ansible architecture](images/B04624_01-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Brief overview of Ansible components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a closer look at the Ansible components.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of Ansible is the **runner**. The runner allows you to execute
    actions on one or more hosts and gather results.
  prefs: []
  type: TYPE_NORMAL
- en: The runner uses an inventory to choose which hosts to connect to. An inventory
    may also associate a set of variables with each host. These variables can then
    be accessed through the playbook and by other Ansible components like the connection
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connection plugins (with a default SSH connection) can use specific host variables
    to figure out how to connect to the remote host. Variables may include information
    like a username to be used to connect to the remote host, a non-default port number,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving on to another component, the **playbook** is one of the most important,
    as all the recipes are written in the form of Ansible playbooks. Playbooks are
    modeled as a collection of plays, each of which defines a set of tasks to be executed
    on a group of remote hosts. A play also defines the environment where the tasks
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Playbook can be broken down into **roles** for better organization. Roles help
    in modularizing the playbook tasks. These roles can later be included in the play
    against specific host groups. For instance, if your infrastructure involves web
    servers and proxy servers, each requiring a common set of tasks (preparing the
    systems) and then type-specific tasks (setting up and configuring web/proxy servers),
    these can be simply broken down into roles, which can later be run against specific
    hosts. Common tasks can be defined against all hosts, at which time webserver
    and proxy server roles can then be executed against respective host groups.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important component in Ansible architecture is **variables**. Variables
    can be used to extract common values and parameterize shared playbook fragments.
    They can also be used to categorize hosts based on some quality they share.
  prefs: []
  type: TYPE_NORMAL
- en: Facts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since every host can give out a lot of information about itself, managing them
    manually is not a recommended practice. Hence, Ansible included a special variable
    called **facts** in its software.
  prefs: []
  type: TYPE_NORMAL
- en: The facts variable is provided by the setup module and gets implicitly executed
    on every host (unless explicitly disabled). This variable collects information
    about the remote host before the runner starts the execution of the playbook on
    the remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the Ansible playbook in place and all facts about the remote
    host group have been collected, the runner kicks in. The runner variable executes
    the specific actions (as specified in the Ansible playbook) on the remote hosts
    by copying the action code to the target machine and preparing the environment
    before executing the action code.
  prefs: []
  type: TYPE_NORMAL
- en: Once the runner evaluates and executes the tasks, it cleans up the copied code
    from the remote host, finally reporting the status through **callbacks**.
  prefs: []
  type: TYPE_NORMAL
- en: Playbook expressiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The expressiveness of the playbook language is limited in order to promote a
    somewhat declarative and descriptive structure of your configuration. However,
    Ansible does not go overboard in trying to model a strictly declarative configuration.
    Ansible plays are modeled as a sequential execution of tasks, affected only by
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tricks that allow you to insert complex logic within the playbooks,
    as well as some extension points, which we will see later, that allow you to achieve
    what you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible provides various extension points that can be used to extend Ansible
    and fit it to customize your needs. It has four main entry points where you can
    put in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom fact scripts**: gathers custom facts from remote hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible modules**: actuators of actual infrastructure changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins**: extends the Ansible execution life cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python API**: inverts the control and exploits parts of Ansible from your
    custom tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom fact scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic inventories may provide some knowledge about the infrastructure and
    how it's grouped and managed, but it does not provide a view of the actual state
    of things.
  prefs: []
  type: TYPE_NORMAL
- en: Before every Ansible run, facts are gathered about the infrastructure against
    which the playbook is executed. This collects a lot of information about the hosts
    and can be later used in the Ansible playbook itself, if required.
  prefs: []
  type: TYPE_NORMAL
- en: However, you may find yourself in a position where the default facts gathered
    as part of the fact-gathering process are not enough. To tackle this, Ansible
    allows you to run your custom code as part of the fact-gathering phase, right
    before the Ansible play execution.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules define the primitive operations that can be performed on your infrastructure.
    They allow you to exactly describe what to do right from the playbook. They can
    encapsulate a complex high-level task, such as interacting with some external
    infrastructure component, and deploy a virtual machine or whole environment.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are the key to Ansible customization. Modules can be written in any
    programming language, and if suitable, they can use Ansible itself to perform
    the nitty-gritty details of their operation.
  prefs: []
  type: TYPE_NORMAL
- en: A substantial part of this book is devoted to building Ansible modules.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term **plugin** groups a number of extension points that hook deeply in
    the Ansible core and extend its behavior in powerful ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The currently available plugins for Ansible are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Action plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loopback plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vars plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins will be covered in detail in [Chapter 4](ch04.html "Chapter 4. Exploring
    API"), *Exploring API* and [Chapter 5](ch05.html "Chapter 5. An In-Depth Look
    at Ansible Plugins"), *An In-depth Look at Ansible Plugins*, where you'll learn
    all you need to know about plugins, including how you can implement them and build
    your own plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Python API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ansible Python API allows you to use Ansible as a library, thus making use
    of the things that Ansible is good for right from your custom configuration management
    solution (whatever it is). You can run Ansible playbooks programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: The Python API can also be used from within other Ansible extensions; we'll
    highlight the important parts throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After going through this chapter, you might be tempted to use Ansible as a configuration
    management and orchestration tool. Perhaps we have also given you a reason to
    choose Ansible as an IAC solution. This chapter provided you with a brief introduction
    to Ansible and its capabilities and use cases. It familiarized you with the Ansible
    architecture, the different components of Ansible, and the various extension points
    provided by Ansible. This chapter also took you through the process of contributing
    to an Ansible project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be learning about Ansible modules. The chapter
    will take you through what you need to know before you start writing an Ansible
    module and guide you through writing your first one. The chapter will also teach
    you about some best practices that should be followed while developing an Ansible
    module. Additionally, the chapter will create a base for the more advanced topics
    that will be covered later in the book, which includes real-life scenarios of
    where and how you can exploit the power of Ansible.
  prefs: []
  type: TYPE_NORMAL
