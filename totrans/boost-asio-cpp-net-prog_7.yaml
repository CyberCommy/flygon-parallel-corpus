- en: Chapter 7. Debugging the Code and Solving the Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We successfully developed a server-client program in the previous chapter.
    We also smoothly ran the program that we created. However, sometimes, we will
    face some problems when we run the application, such as receiving an unexpected
    result or the application crashing during runtime. In this situation, the debugging
    tool has the ability to help us to solve these problems. While discussing the
    debugging tool, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the debugging tool for our use and keeping it simple and lightweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the debugging tool and preparing the executable file to be debugged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarizing with commands that are used in the debugging tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a debugging tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many debugging tools around come with the **Integrated Development Environment**
    (**IDE**) of the programing language. For instance, **Visual Studio** has a debugging
    tool for C, C++, C#, and Visual Basic. Alternatively, you may have heard about
    CodeBlock and Bloodshed Dev-C++, which have their own debugging tools as well.
    However, if you remember what we discussed in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*, we decided not to use an IDE because its heavy load will
    not load much resource to our computer. We need a tool that is lightweight to
    develop our network application.
  prefs: []
  type: TYPE_NORMAL
- en: Our choice of tool is the **GNU Debugger** (**GDB**). GDB is a powerful debugging
    tool based on a command-line tool; this means that we don't need the complex **Graphic
    User Interface** (**GUI**). In other words, all we need is a keyboard, not even
    a mouse, so the system becomes lightweight as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main things that GDB can do to help us solve the code problem,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running our code line-by-line**: When GDB runs our program, we can see which
    line is being executed at the moment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopping our code on a specific line**: This is useful when we suspect that
    a certain line has caused an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examining the suspected line**: When we successfully stop at the suspected
    line, we can continue to examine it, for example, by checking the value of the
    variable involved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changing the value of the variable**: If we find the unexpected variable
    value that has caused an error, we can replace the value at GDB runtime with our
    expected value to ensure that the change of the value will solve the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a debugging tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, you will not need to install anything else if you followed all
    the steps related to the installation of MinGW-w64 in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*, because the installer package contains the GDB tool as well.
    What we need to do now is to run the GDB tool in our command console to check
    whether it runs properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any active directory of our command prompt, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output in our console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding output that we got on the console, we have the
    version 7.8.1 (this is not the latest version as we just obtained it from the
    MinGW-w64 installer package). In the last line, we also have `(gdb)` with a blinking
    cursor next to it; this means that GDB is ready to receive the command. However,
    for now, the command we need to know is `quit` (alternatively, we can use `q`
    as a shortcut) to exit the GDB. Just type `q` and press *Enter*, and you will
    come back to the command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a file for debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GDB needs at least one executable file to be debugged. For this purpose, we
    will go back to the previous chapter to borrow the source code from there. Do
    you remember that we created a game in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*, where we had to guess the random number that the computer
    was thinking of? If you remember, we have the source code, that we saved as `rangen.cpp`
    in the first chapter, and we have modified it by adding the `Boost` library, saving
    it as `rangen_boost.cpp` in [Chapter 3](part0025_split_000.html#page "Chapter 3. Introducing
    the Boost C++ Libraries"), *Introducing the Boost C++ Libraries*. In the next
    section, we will use the `rangen_boost.cpp` source code to demonstrate the use
    of GDB. Also, for those who have forgotten the source code, I''ve rewritten it
    for you here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will modify the compiling command in order for it to be used in GDB. We
    will use the `-g` option so that the executable file that is created will contain
    the debugging information and symbols that will be read by GDB. We will produce
    the `rangen_boost_gdb.exe` executable file from the `rangen_boost.cpp` file, which
    contains the debugging information and symbols using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding command, we add the `-g` option in the compiling
    command in order to record the debugging information and symbols in the executable
    file. Now, we should have the file named `rangen_boost_gdb.exe` in our active
    directory. In the next section, we will debug it using GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are only able to debug the executable file that is compiled using the `-g`
    option. In other words, we will not be able to debug the executable file without
    having debugging information and symbols. Also, we cannot debug the source code
    file (`*.cpp` file) or header file (`*.h` file).
  prefs: []
  type: TYPE_NORMAL
- en: Running the program under GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After preparing the executable file that contains the debugging information
    and symbols, let''s run GDB to read all the symbols from the file and debug it.
    Run the following command to start the debugging process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We got the same output as the previous GDB output, except for the last line
    before `(gdb)`. This line tells us that GDB has successfully read all the debugging
    symbols and is ready to initiate the debugging process. In this step, we can also
    specify the arguments, if our program needs any. Since our program does not need
    to specify any argument, we can ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the debugging process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start the debugging process, we can call either the `run` or `start` command.
    The former will start our program under GDB, while the latter will behave similarly
    but will execute the code line-by-line. The difference is that if we have not
    yet set the breakpoint, the program will run as usual if we call the `run` command,
    whereas the debugger will automatically set the breakpoint in the main block of
    code, stopping the program if it reaches that point, if we start with the `start`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s use the `start` command for the debugging process. Just type
    `start` in the GDB prompt, and the console will append the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The debugging process is started. From the output, we can find that one breakpoint
    is created automatically inside the `main` block which is in line 10\. When there
    is no breakpoint, the debugger will choose the first statement inside the main
    block. That is why we get `line 10` as our automatic breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The continuing and stepping debugging process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we successfully start our program under GDB, the next step is to continue
    and step. We can use one of the following commands to continue and step the debugging
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`: This command will resume the execution of the program until our
    program completes normally. If it finds a breakpoint, the execution will stop
    at the line where the breakpoint is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: This command will execute just one more step of our program. The *step*
    might mean either one line of source code or one machine instruction. If it finds
    the invocation of function, it will come into the function and run one more step
    inside the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: This command behaves similar to the `step` command, but it only continues
    to the next line in the current stack frame. In other words, if the `next` command
    finds the invocation of a function, it will not come into the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, let''s use the `next` command. Type the `next` command in the GDB
    prompt just after we call the `start` command. We should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The GDB executes the 10th line and then continues to the 11th line. We will
    call the `next` command again to continue the debugging process. However, if we
    just press the *Enter* key, the GDB will execute our previous command. This is
    why we now just need to press the *Enter* key, which will give us a blinking cursor.
    Now, we have to input the number that we guessed to be stored in the `guessNumber`
    variable. I will input the number `4`, but you may enter your favorite number.
    Press the *Enter* key again to continue debugging as many times as needed to exit
    the program normally. The following output will be appended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding output, after we enter the number guessed, the
    program executes the `if` statement to ensure that the number we entered is not
    out of range. If our guessing number is valid, the program continues to generate
    a random number. Our guessing number is then compared with a random number generated
    by our program. The program will give a different output irrespective of the two
    numbers being same or not. Unfortunately, my guessing number is different than
    the random number. You might obtain a different output if you are able to guess
    the number correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we may want to examine our source file while we run the debugging
    process. Since the debugging information and symbol are recorded in our program,
    GDB can print the source code even if it is an executable file. To print the source
    code, we can type `list` (or the `l` command for the shortcut) in the GDB prompt.
    By default, GDB will print ten lines at every invocation of the command. However,
    we can change this setting using the `set listsize` command. Also, to know the
    number of lines that will be displayed by the `list` command, we can invoke the
    `show listsize` command. Let''s see the following command line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We increase the number of lines to be displayed using the `list` command. Now,
    every time the `list` command is invoked, the output will display twenty lines
    of source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are several forms of the `list` command, which are the most common:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`: This command will show the source code for as many lines as the list
    size defines. If we call it again, it will display the remaining lines as many
    as the list size defines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list [linenumber]`: This command will display the lines centered on `linenumber`.
    The command `list 10` will display line 5 to line 14 since line 10 is at the center.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list [functionname]`: This command will display lines centered on the beginning
    of the `functionname` variable. The command `list main` will display the `int
    main(void)` function at the center of list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list [first,last]`: This command will display lines from first to last. The
    command `list 15,16` will display line 15 and line 16 only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list [,last]`: This command will display lines ending with the `last`. The
    command `list ,5` will display line 1 to line 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list [first,]`: This command will display all the lines starting with the
    specified line as the first. The command `list 5,` will display line 5 to the
    rest of line if the number of the lines is more than the specified line number.
    Otherwise, it will display as many lines as the list size setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list +`: This command will display all the lines following the lines last
    displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list -`: This command will display all the lines preceding the lines last
    displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and deleting the breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we suspect that a line makes an error, we can set a breakpoint in that line
    so that the debugger stops the debugging process at that line. To set a breakpoint,
    we can call the `break [linenumber]` command. Consider that we want to stop at
    line 20, which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will have to call the `break 20` command just after we load our program
    under GDB to set a breakpoint at line 20\. The following output console illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output console, just after our program is loaded under GDB,
    we call the `break 20` command. The debugger then sets a new breakpoint at line
    20\. Instead of calling the `start` command as we previously did, we call the
    `run` command to execute the program and let it stop when it finds a breakpoint.
    After we enter our guessing number, `2` for example, the debugger stops at line
    20, the line at which we expected it to stop. Then, we call the `next` command
    to continue the debugger and press the *Enter* key several times until the program
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to delete a breakpoint, simply use the `delete N` command, in which
    `N` is the order in which all the breakpoints are set. If we do not memorize all
    the locations of the breakpoints that we set, we can call the `info break` command
    to get a list of all breakpoints. We can also use the `delete` command (without
    `N`), which will delete all breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Printing a variable value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We were already able to stop at our desired line. We can also discover the
    value of the variable that we use in our program. We can call the `print [variablename]`
    command to print the value of any variable. Using the previous breakpoint, we
    will print the value of the variable `randomNumber`. Just after the debugger hits
    the breakpoint in line 20, we will call the print `randomNumber` command. Then,
    we call the `next` command and print the `randomNumber` variable again. Look at
    the following illustration of the command invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding output, the following line is where the breakpoint
    is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before the line is executed, we peek the value of `randomNumber` variable. The
    value of the variable is `0`. Then, we call the `next` command to instruct debugger
    to execute the line. After that, we peek at the value of the variable again, and
    this time it is `8`. Of course, in this experiment, you might get the different
    value rather than 8.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a variable value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will cheat our program by modifying the value of one of the variables. The
    value of a variable can be reassigned using the `set var [variablename]=[newvalue]`
    command. To ensure the type of the variable that we want to modify, we can call
    the `whatis [variablename]` command to get the required type of variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's change the value of the `randomNumber` variable after the program
    assigns a random number to the variable. We will restart the debugging process,
    delete all the breakpoints we set already, set a new breakpoint at line 22, and
    continue the debugging process by typing the `continue` command until the debugger
    hits the breakpoint in line 22\. On this condition, we can reassign the value
    of the `randomNumber` variable to be exactly the same as the value of the `guessNumber`
    variable. Now, call the `continue` command again. After this, we will be congratulated
    for guessing the correct number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details, let''s take a look at the following output console, which
    will illustrate the preceding step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding output, when we call the `start` command, the
    debugger asks us to stop the previous debugging process since it is still running.
    Just type the *Y* key and press the *Enter* key to answer the query. We can list
    all the available breakpoints using the `info break` command and then delete the
    desired breakpoint based on the order we get from the `info break` command. We
    call the `continue` command to resume the debugging process, and when the debugger
    hits the breakpoint, we reassign the `randomNumber` variable with the value of
    the `guessNumber` variable. We continue the debugging process and successfully
    modify the value of the `randomNumber` variable at runtime since we are congratulated
    by the program.
  prefs: []
  type: TYPE_NORMAL
- en: If we have many variables in the program, instead of printing all of the variables
    one-by-one, we can print the values of all the variables using the `info locals`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the command prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I occasionally call the Windows shell command inside the GDB prompt, such as
    the `cls` command to clear the screen, the `dir` command to list the content of
    the active directory, and even the compiling command. If you also want to execute
    the Windows shell command, the GDB command that you can use is `shell [Windows
    shell command]`. It actually just adds the `shell` command before the Windows
    shell command and argument when needed. Let''s see the following console output
    to understand executing the Windows shell command inside the GDB prompt. Let''s
    take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding console output, we invoke the `dir` command to list all files
    that begin with the `rangen_boost` name within the active directory. Then, we
    invoke the compiling command to produce the `rangen_boost_gdb_2.exe` executable
    file in the active directory. Then, we call the `dir` command again to ensure
    that the `rangen_boost_gdb_2.exe` executable file has been successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `apropos shell` command to get more information about shell
    command in GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0034_split_000.html#page "Chapter 5. Delving into the Boost.Asio
    Library"), *Delving into the Boost.Asio Library*, we discussed handling exception
    and error. If we follow all the source code in this book, we may never get any
    error code to confuse us. However, if we try to modify the source code, even just
    a little, an error code may be thrown for which the program will not give us any
    description. Since the error code thrown by the `Boost` library is based on Windows
    system error code and is beyond the scope of this book, we can find the description
    on **Microsoft Developer Network** (**MSDN**) website at [msdn.microsoft.com/en-us/library/windows/desktop/ms681381%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms681381%28v=vs.85%29.aspx).
    Here, we can find all translations of error codes from error 0 to 15999\. Using
    GDB and error code translation from MSDN would become a powerful tool for solving
    an error that occurs in our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to [Chapter 6](part0038_split_000.html#page "Chapter 6. Creating
    a Client-server Application"), *Creating a Client-server Application* and run
    the `serverasync` program. When the program is run, it listens to the client in
    `127.0.0.1` on port `4444`, which will be simulated by telnet in our example.
    However, what will happen if the client is not responding? To know further, let''s
    run the `serverasync` program without running telnet. The following error will
    be displayed because the client is not responding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving the error](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We got the system error code `995`. Now, with this error code, we can visit
    MSDN System Error Codes and find the error description, which is **The I/O operation
    has been aborted because of either a thread exit or an application request. (ERROR_OPERATION_ABORTED)**.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are familiar with the basic GDB commands. There are many more commands in
    GDB that we cannot discuss in this book. GDB has an official site that we can
    visit at [www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/).
    Here, we can find all the complete commands that we have not yet discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also get more detailed information on Boost C++ Libraries on the official
    website at [www.boost.org](http://www.boost.org), especially for the `Boost.Asio`
    library documentation, which is available at [www.boost.org/doc/libs/1_58_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debugging process is an essential thing that we can do to analyse our program
    by running it step-by-step. When our program produces unexpected results or it
    crashes in the middle of an execution, there is no other choice than to run the
    debugging process. GDB is our choice since it is compatible with the C++ language,
    as it comes with MinGW-w64 installer packages and is lightweight when loaded.
  prefs: []
  type: TYPE_NORMAL
- en: GDB can only run an executable file that compiles using the `-g` option. This
    option will add the debugging information and symbol, which are important in the
    debugging process. You will be unable to debug the executable files that are compiled
    without the `-g` option.
  prefs: []
  type: TYPE_NORMAL
- en: After we successfully load our program under GDB, we can choose either the `run`
    or `start` command to execute the debugging process. The `run` command will execute
    our program as usual but will stop if the debugger finds a breakpoint, while the
    `start` command will stop at the `main` block of program at the first execution.
  prefs: []
  type: TYPE_NORMAL
- en: When the debugger stops at certain line, we have to decide whether to continue
    the debugging process. We have the option to run the program until it exits or
    if the breakpoint is found using the `continue` command. Alternatively, we can
    run the debugger step-by-step using the `next` command.
  prefs: []
  type: TYPE_NORMAL
- en: To make the debugger stop at the execution of the debugging process, call the
    `break [linenumber]` command to set the breakpoint. If we want to ensure that
    we set the correct line number, call the `list` command to print the source code.
    Calling the `delete N` command will then delete the breakpoint where `N` can find
    the `info break` command.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the value of a variable is also important when finding an error.
    If the program produces unexpected output, we can trace the value of a variable
    by printing it. We can do this by using the `print [variablename]` command. At
    the variable we suspect is causing an error, we can reassign the value of that
    variable with a new one using the `set var [variablename]=[newvalue]` command.
    We can then run the debugger again until we obtain the expected output. When we
    have fixed all the errors, and are sure that everything is perfect, we can recompile
    our program by calling the compiling command inside GDB prompt using the `shell
    [Windows shell command]` command.
  prefs: []
  type: TYPE_NORMAL
