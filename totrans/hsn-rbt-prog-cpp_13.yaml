- en: Building a Voice-Controlled Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2012, I wanted to create a robot that could be controlled by an Android smartphone.
    At that time, however, I did not know much about Android programming. To my surprise,
    I came across an amazing website called **App Inventor** ([http://www.appinventor.org/](http://www.appinventor.org/)),
    which allows users to develop Android applications by joining programming blocks
    in the same way as joining pieces in a puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this final chapter, we will use the App Inventor website and learn to control
    our robot with an Android smartphone using our voice as an input. We will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to App Inventor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a voice application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pairing the Android smartphone and **Raspberry Pi** (**RPi**) via Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the Bluetooth program for RPi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Android smartphone running on Android version Lollipop (version number 5.0-5.1.1)
    or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to App Inventor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: App Inventor is an open source web-based application that was originally developed
    by Google. It is currently maintained by the **Massachusetts Institute of Technology**
    (**MIT**). It allows users to develop Android applications using its state-of-the-art
    graphical programming interface, which is similar to Scratch. Developers have
    to drag and drop visual blocks to create an Android app with App Inventor. The
    current version of App Inventor is referred to as **App Inventor 2** (version
    2), or **AI2**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram you can see how each programming block is connected
    to each other like a puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/106e3ae8-18e2-4d62-8fed-508cc292b450.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we'll look at how to create an App Inventor account and then
    create our first Android app using App Inventor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Talking Pi Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Talking Pi is a simple Android application in which you type text inside a
    textbox and the smartphone displays and reads out the text. Before creating this
    Android app, we first need to get access to the App Inventor 2 dashboard. The
    final layout of the Talking Pi application will look somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/262e76be-be85-4a38-8b33-c4bcea156dab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create Android applications using App Inventor 2, you must have a Gmail
    account. If you have one already, sign in on a browser of your choice. If you
    do not have one, you will need to create one. Let''s now look at the steps for
    linking App Inventor 2 with your Gmail account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After signing in, go to the following link: [ai2.appinventor.mit.edu/](http://ai2.appinventor.mit.edu/).
    If you have signed in with multiple Gmail accounts inside your browser, you''ll
    need to select one ID in particular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e92662e-a4f0-4f96-ab82-217da900b7de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you''ll need to agree to the AI2 terms of service. You''ll then be ready
    to create your Talking Pi application. To create a new Android application project,
    click on the Start new project button as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd3bf335-2e0c-45d2-97e5-0502451e4489.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, name the project `TalkingPi` and then click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/370d2f1e-a6ed-4e83-a8a8-8dbbe810fbe8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating your project, you will see the following four main panels inside
    App Inventor called Palette, Viewer, Components, and Properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5e655d-b757-4d9f-81b8-1d7dbe73c611.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now understand the workings of each of these panels as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Palette panel consists of different components such as buttons, textboxes,
    canvases, Bluetooth, a video player, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Viewer panel consists of a screen in which we can drag and drop UI components
    from the Palette.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Components panel displays a list of visible and non-visible components that
    are added inside the screen. A button, for example, is a visible component, as
    it is visible on the screen. On the other hand, Bluetooth is a non-visible component
    as it is not visible on the screen, but it functions in the background. All invisible
    components are displayed below the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Properties panel allows us to modify the properties of the components that
    are selected in the Components panel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now move on to designing the app.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our Talking Pi app, we are going to add four main components: TextBox, Button,
    Label, and TextToSpeech. The TextBox, Button, and Label components are inside
    the User Interface option. Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drag the TextBox, Button, and Label components one by one inside the
    screen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b28a61d6-d43b-4cc6-8a18-634d0fd00ac4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding these three components, you will notice that they are aligned
    to the top-left of the screen, which looks a bit odd. To position them horizontally
    in the center of the screen, select **Screen1** from the Components panel and
    change **AlignHorizontal** to **Center**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/419d3883-e216-4906-9d59-bff0f83ee91b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, to add some spacing between the three components, we can add layout components
    in between the TextBox, Button, and Label components. You can choose either a
    HorizontalArrangement or VerticalArrangement, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3da6e22-7752-49dd-91a8-2c58159430a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to vary the distance between two components, you will need to change
    the height of the HorizontalArrangement. To do this, select the Height property
    and set a particular pixel value on the HorizontalArrangement, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a15c482-e6b7-4407-91d5-fee5d10b6d9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the **Button1** component and change its text to `CLICK HERE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d404157c-e941-47c0-987a-4e89b611b19b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, select the **Label1** component, change its text to `TalkingPi`,
    and increase its **FontSize** to `24`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e8f19dd-4871-4d1d-93bd-afdd42f33a62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, open the Media option and drag the TextToSpeech component on to the
    screen. Since the TextToSpeech component is a non-visible component, it will appear
    below the screen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/682dd31f-c4d1-42b2-a098-425547639ea4.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now basically finished designing the Talking Pi application. Let's now
    go inside the Blocks option and create the programming blocks for displaying the
    text and translating it into speech at the click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After designing the UI for the app, click on the Blocks button, which is next
    to the Design button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/914d6df9-254d-4e2d-88db-80354357d845.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the block section, on the left side you will see **Screen1**, which
    contains all the components (both visible and non-visible) that we have dragged
    onto the screen. If you click on any of the components, you will notice the following
    types of blocks for each component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d682f238-1e76-453e-b7c0-3201187fa27e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will focus our attention mainly on the three types of block that make up
    each component. We will refer to these as **Main block**, **Intermediate block**,
    and **Final block**. Each of these blocks must be connected in the correct sequence
    to get a proper working program, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0288f5-fecf-43b9-9256-d0dc6e1f482b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at each block.
  prefs: []
  type: TYPE_NORMAL
- en: Main block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **main block** inside App Inventor 2 is similar to a **when** loop, which
    indicates an action to carry out when something happens. The **main block** is
    always connected to an **intermediate block**. We cannot connect the **final block**
    directly to the **main block**. The main block consists of a drop-down menu from
    which we can choose between multiple components that are of the same type. For
    example, look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a63e10e-f7ea-49bd-ad90-c5389660e864.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that in a scenario where you have multiple buttons, you can choose
    a particular button from the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **intermediate block** consists of an **input socket** and an **output
    socket**. The **input socket** is connected to the **main block** and the **output
    socket** is connected to the **final block**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ec27222-399b-4c55-aaad-ed05547a438d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **intermediate block** consists of two drop-down menus. The first drop-down
    menu represents the components of the same type. For example, if you have multiple
    labels, you can choose a particular label from the first drop-down menu. The second
    drop-down menu represents the properties of the component. For **Label1**, for
    example, we have **Text**, **BackgroundColor**, **Width**, and so on, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13e026f4-ee9d-48bf-83c8-15fcaedeefd6.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, **Label1** . **Text** means that we want to set or change the text
    of **Label1**.
  prefs: []
  type: TYPE_NORMAL
- en: Final block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **final block** is connected to the **intermediate block**. It also consists
    of two drop-down menus from which we can select a particular component and its
    specific properties, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cea0ac6c-7000-41a7-aba9-65e319e70faf.png)'
  prefs: []
  type: TYPE_IMG
- en: We will be using these three types of blocks to create our Talking Pi program.
    Let's start with the block programming.
  prefs: []
  type: TYPE_NORMAL
- en: The Talking Pi program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Talking Pi programming logic is very simple. When **Button1** is pressed,
    **Label1** must display the text that is typed inside **Textbox1** and **TextToSpeech1**
    must read out that text. The steps for executing this block program are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, click on the **Button1** component and select the **when Button1.Click**
    main block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/651bb807-3f0a-48a0-bf79-7bee856033b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, since we want to change the text of **Label1** when **Button1** is clicked,
    choose the **Label1.Text** block from the **Label1** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c70ab7e-e25c-4e0a-b272-6c9a9ea59e76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, drag the **Label1.Text** block inside the **Button1.Click** block to
    join both the blocks. Once both the blocks are joined, you will hear a click sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b1ff765-8f38-4439-b3e3-21056ba5ee2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we want to display the text inside the TextBox in the label component.
    From the **TextBox1** component, select the **TextBox1.Text** block as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8aca2f50-3528-43e9-bc39-ef5d90bada51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, attach the **TextBox1.Text** block to the **Label1.Text** block. Now,
    when you press the button, the label will display the text that is written inside
    the Textbox. **Label1** is now set to display the text that is inside **TextBox1**,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09643073-3089-4413-9015-0cb7d4e35fb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, to read out the text that is inside the textbox, click on the **TextToSpeech1**
    component and choose the **call TextToSpeech1.Speak** block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b82dfd6-2a49-4369-a390-b4e43953c594.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect this block below the **Label1.Text** block. Inside the message socket,
    connect the **TextBox1.Text** final block. This means that whatever text is written
    inside the textBox will be spoken as a message by the **TextToSpeech1** block,
    for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44c3d91d-4f08-41d4-b742-8ad44a514e19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have now finished designing our block program. To build and run this app
    inside your Android smartphone, click on the Build drop-down menu and choose between
    the two build types, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/805760c9-7fde-42fb-9eec-a15bc29e16ec.png)'
  prefs: []
  type: TYPE_IMG
- en: The first option, App (provide QR Code for .apk), will generate a QR code that
    you can scan with your Android smartphone (using a QR scanner app). After scanning
    the QR code, the `.apk` file of the application will be downloaded inside your
    Android smartphone. Install the `.apk` file to test the output of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The second option, App (save .apk to my computer), will generate and download
    a `.apk` file inside your computer. You will need to transfer the `.apk` file
    from your computer to your smartphone and install the `.apk` file. I personally
    prefer the first option as the `.apk` file is directly downloaded inside the smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also download the MIT AI2 companion application from the Android play
    store and install it inside your Android smartphone to test the application in
    real time. So in the play store, search for **MIT AI2 Companion** and then click
    on the Install button to install the app. The app page is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8719229-0505-4088-9e0c-b1236135caa0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After installing the MIT AI2 Companion app inside your Android smartphone,
    click on the **Scan QR code** button or enter the six-digit alphabetical code
    (next to the QR code) inside the MIT AI2 Companion app, and then click on the **Connect
    with code** button. To generate the QR code or the six-digit number, click on
    **Connect** and then select **AI Companion**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/394cd7a3-2ca9-4f83-b9cd-7ec0198c74f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Importing and exporting the .aia file of the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can export your Android application by generating its `.aia` file. To create
    a `.aia` file, follow any one of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Projects** and then select **Export selected project (.aia) to my
    computer**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5142d183-0049-409a-bba4-9ca708771ebb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, you can click on **Projects** and then select **Import project (.aia)
    from my computer**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6fbc06a5-67d6-401f-bc17-811cf2030309.png)'
  prefs: []
  type: TYPE_IMG
- en: You can download the `.aia` file of the Talking Pi and voice-control bot application
    file from the `Chapter09` folder of GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a voice-controlled bot app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The voice-controlled bot application is the main focus of this chapter. The
    following are the three main parts involved in creating a voice-controlled robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A voice recognition application**: The voice recognition application will
    recognize our voice and send data as text when a particular word is recognized.
    For example, if we say the word **forward**, the application would send an **F**
    to the robot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth connection**: This involves establishing a working connection between
    the Bluetooth of the smartphone and the Bluetooth of the RPi.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RPi Robot program**: In this section, we will decode the text information
    that is transmitted from the smartphone and move the robot accordingly. For example,
    if the incoming text is **F**, then we will write a program to move the robot
    forward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will create a voice recognition application. In the later
    sections, we will look at establishing a Bluetooth connection and programming
    our robot. You can download the `VoiceControlBot.aia` file from the `Chapter09` folder
    of GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: To create the `VoiceControlBot` app, click on **Projects** and then select **Start
    new Project:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dde256fe-6d86-4dd0-8a00-f963492b4781.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Call it `VoiceControlBot` and then press the OK button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ba3cead-a20e-47dd-b381-85b83363437b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now move on to the designing part.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Designing the voice-control bot application is very easy. The final application
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fab12089-edf9-4cd6-8b52-6d65136ef364.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following components will be used for designing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ListPicker**: The ListPicker will display a list of Bluetooth devices that
    are connected to our smartphone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speech-recognizer**: The speech-recognizer component will listen to what
    we are saying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speech-recognizer button**: When the speech-recognizer button is clicked,
    the speech-recognizer component will be called, which will listen to what we are
    saying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disconnect button**: The disconnect button is used to disconnect the smartphone
    from the RPi.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Label**: The label component will display the text that is spoken by the
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth client**: The Bluetooth client component activates our smartphone''s
    Bluetooth connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal or vertical arrangement**: We have one horizontal arrangement
    component to position the speech-recognizer button properly in the center of the
    screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next let's see how to add and customize components.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To design the `VoiceControlBot` application, drag the **ListPicker **(not ListView)
    component inside the screen. Next, drag a **Horizontal Arrangement** and, inside
    that, drag a **Button**. Below the **Horizontal Arrangement**, drag a **Label **and
    then another **Button**. If you have dragged all the components correctly, your
    screen should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05facfe8-3140-4b76-9dde-0599a293df2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following steps, I have customized each component in the app based on
    my own requirements. You can customize the components as you wish. Take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, with the **ListPicker1** selected, change the **background color** to
    green, set the **Width** to `Fill parent`, and change the **text** to `CONNECT`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d73397d-7f19-4ade-a0f5-88c352e006ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the **HorizontalArrangement1** and change both its **Height**
    and **Width** to `Fill parent`*.* Change the **AlignHorizontal** and **AlignVertical**
    to `Center` so that Button1 is positioned in the center of the HorizontalArrangement1,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67ad4bf4-0936-4922-8a13-8cda872d12b0.png)'
  prefs: []
  type: TYPE_IMG
- en: After this, select **Button1**, click on the Rename button and rename Button1
    to `SRButton`. **SR** is short for **speech recognition:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f4287f6-9635-4862-ada0-f21ab0585b38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will add a microphone image as the background of the **SRButton**.
    You can download this image from the `Chapter09` folder of the GitHub repository.
    To add a background image, change the **Width** and **Height** of the button to
    `200 pixels`, so that the button is square. Next, remove the default text from
    the Text box, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/309fffc8-c084-476c-9b37-2125c16b18b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, click on the Image option and then select the mic image to set
    it as the background image for the SRButton:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95f8e5eb-08d9-4446-b581-1027ef944556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, with **Label1** selected, change the **FontSize** to `20` and the **Text**
    to `WORD SPOKEN` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e623b52d-85d6-437e-ab2e-f6ae0bfc7ab4.png)'
  prefs: []
  type: TYPE_IMG
- en: After this, to position Label1 horizontally in the center of the screen, select
    Screen1 and set **AlignHorizontal** to `Center`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, select **Button2** and rename it as `DeleteButton`. Change its **Background
    color** to `RED`, its **Width** to `Fill parent`, its **Text** to `DELETE`, and
    the **TextColor** to `White`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28951a7e-5e5f-4635-a1e7-0cb7cf7ed4ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After designing the UI for the app, we need to drag the BluetoothClient and
    the SpeechRecognizer component to our screen. The BluetoothClient is inside the
    Connectivity option and the SpeechRecognizer component is inside the Media option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/228a02e6-fa7c-420a-8aa5-c6d088c17e81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have added all the necessary components, your screen should look as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90f1bd01-9822-4439-8786-506a69911348.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now move on to programming the voice-controlled bot block.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the voice-controlled bot block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After designing the app, it''s time to program the voice-controlled bot application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will use the **ListPicker1.BeforePicking** block from **ListPicker1** and
    display the Bluetooth devices connected to our smartphone in a list as list items.
    Connect this block to the ListPicker1.Elements blocks. Next, from the **BluetoothClient1**
    components, connect the **BluetoothClient1.AddressAndNames** block to the **ListPicker1.Elements** block,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84aef84e-245b-4f46-ba1d-450e3d5ebcc8.png)'
  prefs: []
  type: TYPE_IMG
- en: The **ListPicker1.Elements** represents the elements (the list items) in the
    list, which are the addresses and names of the devices that are paired to our
    smartphone's Bluetooth. If we select an element from the list, the **ListPicker1.AfterPicking**
    block comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ListPicker1.AfterPicking** block is used to connect to the **AddressesAndNames** Bluetooth, which
    is selected from the list, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b55fbc71-ed73-4706-a3d2-77cd86ee98a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once both the devices are connected using Bluetooth, choose the **SRbutton.Click**
    block from the **SRbutton**. Then, select the **SpeechRecognizer1.GetText** from
    the **SpeechRecognizer1** block and connect it to the **SRbutton.Click** block
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ff28c2d-e164-4b06-a24c-4ab846f237f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The **SpeechRecognizer1.GetText** block will activate the Google speech recognizer
    and try to recognize what you are saying. It will convert your spoken words into
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, using the **SpeechRecognizer1.AfterGettingText** block, we will display
    the spoken text inside the label, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35e8844c-41c2-48a4-9414-e80e50def2d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, using the `if...then` blocks, we will establish whether the spoken
    words are forward, back, left, right, or stop. If any of these words are detected,
    then we will send an alphabetical character to our RPi robot using the BluetoothClient
    component. The if...then block is inside the **Control** option, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59e27c2a-8ac1-46d3-8eec-96918847caca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the if...then block and place it below the **Label1.Text** block inside
    the **SpeechRecognizer1.AfterGettingText** block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f14e0c62-1d88-4c39-93c3-6a2a791a9dce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, to understand the spoken words, we will use the comparison operator,
    which is inside the **Logic** option, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/129dba10-c6d5-42f1-b05e-674af198a213.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the comparison block in the `if` socket of the `if...then` block as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95be015b-a9ef-4c6d-bd38-ac634449a678.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the left socket of the comparison operator, connect the SpeechRecognizer1.Result
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08b441c4-62f7-4e87-9331-6f9c3f8324b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the right socket of the comparison operator, connect an empty text string
    box. The text string box is inside the Text option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccdb09c2-5bc7-41a0-a77b-d69993fef890.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After connecting the text string box to the comparison operator, enter the
    text `forward` inside it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e8494eb-9e5e-45cd-ad36-f555007f4d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that if the **SpeechRecognizer1.Result** is equal to **forward**,
    then inside the then socket, we will add a BluetoothClient1.SendText block. After
    this, we will connect a textbox to the BluetoothClient1.SendText block and enter
    the letter `F`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47f31e36-eb36-4583-beee-94f4e0185f8f.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that when the word forward is detected, the character **F** will
    be sent from the smartphone's Bluetooth to the RPi's Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `if...then` block and duplicate it to create four additional
    blocks for the words back, left, right, and stop. When the word **back** is detected,
    you should send the letter **B**; when the word **left** is detected, you should
    send **L**; when the word **right** is detected, you should send **R**; and, finally,
    when the word **stop** is detected, you should send **S.** This is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f7bb1f6-10a9-45ce-9a4b-33e26238d660.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, connect the BluetoothClient1.Disconnect block to the **Disconnectbutton**,
    so that the Bluetooth connection is disconnected when this button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e3999fc-4cfc-479f-baa7-2dc65b0288cf.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now finished designing and programming our `VoiceControlBot` application.
    You can download and install this application inside your Android smartphone.
    In the next section, we will pair our smartphone's Bluetooth with the RPi's Bluetooth.
    Power up your RPi and let's get started with the pairing process.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing the Android smartphone and RPi via Bluetooth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use the Terminal window to pair the Android''s Bluetooth
    with the RPi''s Bluetooth. Before we start with the pairing process, we need to
    install a Bluetooth package inside our RPi and make modifications to certain files.
    To do this, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to install the Bluetooth package, enter the following command in the
    Terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55c769ea-0d89-4a7a-8250-5065f7c184de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will open the `bluetooth.service` file and make some minor modifications.
    To open the file, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, type `-C` after `/bluetoothd`. This will turn on the compatible mode
    of the RPi''s Bluetooth as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cda6bf7f-765c-45db-aacc-e949c78539fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, press *Ctrl* + *O* and then hit *Enter* to **save** the file. Next,
    press *Ctrl* + *X* to exit the file. Reboot your RPi with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the RPi has restarted, check its status by entering the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see `-C` next to `bluetoothhd`. If, after entering the preceding
    command, you see `lines 1-19/19(END)` and you can''t enter any new commands in
    the Terminal window, close the Terminal window and reopen it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7008cf9-f4c0-47e5-9d67-d7c8803aecd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, to pair the RPi''s Bluetooth with the smartphone''s Bluetooth, we first
    need to make the RPi''s Bluetooth discoverable. To pair the devices, enter the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the **Media Access Control** (**MAC**) address of your Bluetooth
    along with its name. The MAC address is a 12-digit address and is unique for each
    Bluetooth device. Your RPi''s Bluetooth will have a default name of `raspberrypi`,
    as you can see in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f4ba947-718b-4b1f-8d7f-c7e30c1f82ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before entering the next set of code,**turn your Android device''s Bluetooth** **on**
    and click on the **Pair new device** option as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8b328de-b207-4913-96ab-404697f58fc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, enter the following five commands one by one to put the RPi''s
    Bluetooth in discoverable mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After turning discoverable mode on, you should see the name raspberrypi in
    the Available devices option. Select this option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/97034ce4-49d1-47d1-9381-114fab195e8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After selecting the **raspberrypi** option, you will see a pop-up box asking
    you whether you want to pair with the Raspberry Pi''s Bluetooth. Click on the
    PAIR button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f4793582-30a7-4640-91b1-ce6bb3d78791.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, inside the Terminal window, you will see a message asking whether you
    want to pair with your smartphone''s Bluetooth. Type `yes` (in lower-case letters)
    and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb92f9f2-4914-4dd9-828c-112ac6182c57.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, you will see a small pop-up box in the Terminal window asking if you want
    to accept the pairing request. Click **OK:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/138b4adb-16f2-4fc8-904e-9fde1388e81e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may then see another pop-up box stating that the connection failed. Ignore
    this error and press OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4522e413-52a0-462b-ac52-1a4627795a77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, type `exit`. You can now check whether the device is paired to
    your RPi by typing `sudo bluetoothctl`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b51d761-18b3-45be-bb0d-51bf542ff1e8.png)'
  prefs: []
  type: TYPE_IMG
- en: So we have finished pairing the RPi's Bluetooth to the Android smartphone's
    Bluetooth. Next we will enable the serial port of the RPi Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Bluetooth serial port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After pairing the devices, we need to create a script for enabling the Bluetooth
    serial port. We will name this script `bt_serial` (**bt** being short for **Bluetooth**).
    To create this script, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this script, enter the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ca062cf5-1ed9-49f2-95f5-56760e768db0.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, save (*Ctrl* + *O*) and exit (*Ctrl* + *X*) this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then need to execute and run this script. Type the following commands: `sudo
    chmod +x bt_serial` (this is the execution command) and `sudo ./bt_serial` (this
    is the run command):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a21cf02b-bf28-4249-a579-60a0637d484e.png)'
  prefs: []
  type: TYPE_IMG
- en: After running the script, you will see the message `Serial Port service registered`.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Bluetooth program for RPi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After designing the Android application, pairing the devices, and enabling the
    serial port, it is now time to program the RPi so that it can receive text data
    from the Android smartphone. To receive incoming text data from the smartphone,
    we are going to use sockets from socket programming.
  prefs: []
  type: TYPE_NORMAL
- en: Socket programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A socket is an endpoint of a two-way communication system in a network. We create
    sockets so that we can send bits of information through them. To establish a Bluetooth
    communication between the devices, we need to create a socket. One socket will
    be on the server side and the other will be on the client side. In our case, the
    Android smartphone is the client and the RPi is the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client socket tries to establish a connection with the server socket, while
    the server socket tries to listen to the incoming connection request from the
    client socket. In Bluetooth programming, we can choose between two socket options,
    RFCOMM and L2CAP, as represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53c12a55-31de-43d5-9dc1-eea624977799.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a socket program, the following connection steps have to happen one after
    another from the client and server side. Each step represents a function, which
    is declared either in the client, server, or both scripts. Take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket creation (client/server)**: Creates sockets in the client and server
    programs as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the first parameter refers to the communication domain. In
    our case, the communication domain is Bluetooth (`AF_BLUETOOTH`). The second parameter refers
    to the communication type (`SOCK_STREAM`). The third parameterrefers to the communication
    protocol. In Bluetooth programming, we can choose the **Radio Frequency Communication**
    (**RFCOMM**) protocol or the **Logical Link Control and Adaption Protocol** (**L2CAP**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Connect (client)**: This function tries to establish a connection with the
    server socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the first parameter refers to the socket, the second parameter
    refers to the address of the server, and the third parameter is used to find the
    size of device address. In our case, the device address is the RPi address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bind (server)**: The `bind` function binds the address and port number of
    the server device. The MAC address of the RPi will be stored inside the bind function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the first parameter refers to the socket, the second parameter
    refers to the address of the server device (Raspberry Pi), and the third parameter
    is used to find the size of the device address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listen (server)**: With the `listen` function, the server socket waits for
    the client to approach it in order to make a connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter refers to the socket. The backlog is generally set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept (server)**: The `accept` function waits for an incoming connection
    request and creates a new socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the second parameter refers to the address of the client,
    which is the Android smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: '**Send (client/server)**: The `send` function is used to send data from the
    client to the server and the other way around.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Read (client/server)**: The `read` function is used to read data transferred
    from the client to the server and the other way around.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Close (client/server)**: The `close` function shuts down the socket and frees
    the memory allocated to the socket.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, since we have already created the `VoiceControlBot` Android application
    using App Inventor, there is no need to write a client program. All that's left
    is to write the server program for our RPi robot.
  prefs: []
  type: TYPE_NORMAL
- en: VoiceBot server program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this `VoiceBot` server program, we will first use a socket program to establish
    a socket connection between the devices. Next, we will receive the incoming data,
    which is sent from the Android smartphone. Finally, we will move the robot based
    on the data that is sent. The `VoiceBot.c` program can be downloaded from the `Chapter09`
    folder of the GitHub repository. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, all the necessary header files are declared as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside the `main()` function, the wiringPi pin numbers 0, 2, 3, and 4
    are declared as output pins as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To establish RFCOMM with the other device, `sockaddr_rc` is declared along
    with the `server_address` and `client_address`. The `data` variable will store
    and display the incoming data. The `s` and `clientsocket` are for storing the
    values of the server and client socket respectively. The `bytes` variable will
    read the incoming byte information. The `socklen_t opt` contains the size of `client_address`.
    This is shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `s` is created with the communication domain set to `AF_BLUETOOTH`,
    the communication type set to `SOCK_STREAM`, and the communication protocol set
    to `BTPROTO_RFCOMM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The RPi''s Bluetooth MAC address is then bound to the server socket using the
    bind function and the `s` (server socket) enters listening mode as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the connection is accepted, a new client socket is created using the accept
    function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The incoming byte data is then converted to a string using the `ba2str` function.
    After that, the MAC address of the connected Bluetooth is displayed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, inside the `for` loop, the incoming data is read using the `read`
    function. If the value inside the byte variable is greater than `0`, we print
    the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use five `if` conditions to check whether the incoming data contains
    the letters `F`, `B`, `L`, `R`, or `S`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*data == ''F''`: The robot will move forward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*data == ''S''`: The robot will move backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*data == ''L''`: The robot will take an axial left turn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*data == ''R''`: The robot will take an axial right turn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*data == ''S''`: The robot will stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, to disconnect the devices, the `close` function is used to close the
    `clientsocket` and the `s` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, since this code contains a socket and a Bluetooth header file, to compile
    this code, you will need to add the `-lbluetooth` command inside the Build command. As
    this is a C program and not a C++ program, you will also have to add the -lwiringPi
    command to compile the wiringPi code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c856383-3c63-40c2-a0a3-2fa497f76465.png)'
  prefs: []
  type: TYPE_IMG
- en: Next let's test the code and check the final output.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, before compiling and building the program, make sure that you have paired
    both the Android smartphone's Bluetooth and the RPi's Bluetooth. If they are not
    paired, then the RPi Bluetooth name (`raspberrypi`) will not appear in the Bluetooth
    list when you run the `VoiceControlBot` application. The steps for pairing the
    devices are listed in the *Pairing the Android smartphone and RPi via Bluetooth* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done this, you will need to execute and run the `bt_serial` script,
    which we created previously, inside the Terminal window. The commands for executing
    and running this script are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You do not need to execute this script each time you run the program but you
    will need to execute and run this script when you start a new RPi session and
    want to test the `VoiceBot.c` program. Next, compile and build the `VoiceBot.c`
    program. After this, open the `VoiceControlBot` Android app and press the **CONNECT**
    list picker. You will see the name of the raspberrypi along with its MAC address
    in the Bluetooth list. Select the raspberrypi option to connect the devices as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7ae03f1-7a53-4aa7-9950-12cc879e9719.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once they are connected, you will get a notification inside the Terminal window
    stating `Connected to:` and the Android Bluetooth MAC address, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e44e66ce-cbb9-494f-928e-becfde6ca5e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you get the following **Error 507: Unable to Connect. Is the device turned
    on?** error, don''t worry. Click on the connect button and select the raspberrypi
    Bluetooth again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bc55ecd-8e60-4c96-814b-b8ab9c5bcc90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the devices are connected, you can click on the speech recognizer button
    and start speaking. If you say the word *forward*, this should be displayed on
    the screen, as in the following screenshot, and the letter **F** will be sent
    to the RPi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01b59e04-19ff-488e-a8bf-a15e264448d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, when you say the words *back*, *left*, *right*, and *stop*, the
    letters **B**, **L**, **R**, and **S**, as shown in the following screenshot, will
    be sent to the RPi''s Bluetooth and the robot will move in the appropriate direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce63f3db-bbf8-4e6f-9eea-2555c5027665.png)'
  prefs: []
  type: TYPE_IMG
- en: If you say any other word, the speech recognizer should recognize the word and
    display it on the screen, but it will not send any text data to the RPi.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by creating our first Android application called Talking
    Pi, in which text written inside the textbox was displayed in a label and also
    read out by the smartphone. We then developed a voice-controlled bot Android app,
    which recognized our voice and sent text to the RPi via Bluetooth. After this,
    using the Terminal window, we paired the Android smartphone's Bluetooth with the
    RPi's Bluetooth. Finally, we looked at socket programming and wrote the `VoiceBot`
    program to establish a connection with the Android smartphone's Bluetooth to control
    the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which communication protocol did we use to send data over a Bluetooth connection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of address do Bluetooth devices have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the use of ListPicker inside the `VoiceControlBot` application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the client side, which function is used to connect the client socket to the
    server socket?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default Bluetooth name of your RPi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
