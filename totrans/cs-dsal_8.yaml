- en: Classification of data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen while reading the book, there are many data structures with
    many configuration variants. Thus, choosing a proper data structure is not an
    easy task, which could have a significant impact on the performance of the developed
    solution. Even the topics mentioned in this book form quite a long list of described
    data structures. For this reason, it is a good idea to classify them in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Within this chapter, the described data structures are grouped into linear and
    non-linear categories. Each element in a linear data structure can be logically
    adjacent to the following or the previous element. In the case of a nonlinear
    data structure, a single element can be logically adjacent to numerous others,
    not necessarily only one or two. They can be freely distributed throughout the
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following diagram, which shows the classification
    of data structures according to the mentioned criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaaed9fa-1216-4071-a635-d462e5e24db1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the group of linear data structures contains arrays, lists,
    stacks, and queues. Of course, you should also take care of various subtypes of
    the mentioned data structures, such as three variants of a linked list, which
    is a subtype of a list.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of non-linear data structures, a graph performs the most important
    role, because it also includes a tree subtype. Moreover, trees include binary
    trees and heaps, while a binary search tree is a subtype of a binary tree. In
    the same way, you can describe the relationships of other data structures presented
    and explained in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Diversity of applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember all of the data structures shown in the book? Due to the high
    number of described topics, it is a good idea to take a look at the following
    data structures once more, together with their associated algorithms, just in
    the form of a brief summary with information about some real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with arrays, which is one of the two main topics in the first chapter.
    You can use this data structure to store many variables of the same type, such
    as `int`, `string`, or a user-defined class. The important assumption is that
    the number of elements in an array cannot be changed after initialization. Moreover,
    arrays belong to random access data structures, which means that you can use indices
    to get access to the first, the middle, the *n*-th, or the last element from the
    array. You can benefit from a few variants of arrays, namely single-dimensional,
    multi-dimensional, and jagged arrays, also referred to as an array of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these variants are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39074937-888a-45ff-96cc-6176c90d0b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a lot of applications of arrays and, as a developer, you have probably
    used this data structure many times. In this book, you have seen how you can use
    it to store various data, such as the names of months, the multiplication table,
    or even a map of a game. In the last case, you created a two-dimensional array
    with the same size as a map, where each element specifies a certain type of terrain,
    for example, grass or a wall.
  prefs: []
  type: TYPE_NORMAL
- en: There are many algorithms that perform various operations on arrays. However,
    one of the most common tasks is sorting an array to arrange its elements in the
    correct order, either ascending or descending. This book focuses on four algorithms,
    namely selection sort, insertion sort, bubble sort, as well as quick sort.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next group of data structures, described in the first chapter, is related
    to lists. They are similar to arrays, but make it possible to dynamically increase
    the size of the collection if necessary. In the following diagram, you can see
    a few variants of a list, namely single-linked, double-linked, and circular-linked,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/498191b3-418b-4cb8-bd06-edc301235c9e.png)'
  prefs: []
  type: TYPE_IMG
- en: It is worth mentioning that the built-in implementation is available for the
    array list (`ArrayList`), as well as its generic (`List`) and sorted (`SortedList`)
    variants. The latter can be understood as a collection of key-value pairs, always
    sorted by keys.
  prefs: []
  type: TYPE_NORMAL
- en: A short comment may be beneficial for a single-linked, double-linked, and circular-linked
    list. The first data structure makes it possible to easily navigate from one element
    to the next using the `Next` property. However, it can be further expanded by
    adding the `Previous` property to allow navigating in forward and backward directions,
    forming the double-linked list. In the circular-linked list, the `Previous` property
    of the first node navigates to the last one, while the `Next` property links the
    last node to the first. It is worth noting that there is a built-in implementation
    of the double-linked list (`LinkedList`), and you can quite easily extend the
    double-linked list to behave as the circular-linked list.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of applications for the lists to solve diverse problems in various
    kinds of applications. In this book, you have seen how to utilize the list for
    storing some floating point values and calculating the average value, how to use
    this data structure to create a simple database of people, and how to develop
    an automatically sorted address book. Moreover, you have prepared a simple application
    that allows a user to read the book by changing the pages, as well as the game,
    in which the user spins the wheel with random power. The wheel rotates slower
    and slower until it stops. Then, the user can spin it again, from the previous
    stop position, which illustrates the circular-linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third chapter of this book focuses on stacks and queues. In this section,
    let's take a look at a stack, which is a representative of limited access data
    structures. This name means that you cannot access every element from the structure,
    and the way of getting elements is strictly specified. In the case of a stack,
    you can only add a new element at the top (the push operation) and get an element
    by removing it from the top (the pop operation). For this reason, a stack is consistent
    with the LIFO principle, which means Last-In First-Out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram of a stack is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474d2469-2ac1-47f0-9c22-7d3d5436f783.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, a stack has many real-world applications. One of the mentioned examples
    is related to a pile of many plates, each placed on top of the other. You can
    only add a new plate at the top of the pile, and you can only get a plate from
    the top of the pile. You cannot remove the seventh plate without taking the previous
    six from the top, and you cannot add a plate to the middle of the pile. You have
    also seen how to use a stack to reverse a word and how to apply it for solving
    the mathematical game Tower of Hanoi.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another leading subject of the third chapter is a queue. While using this data
    structure, you can only add new elements at the end of the queue (the enqueue
    operation) and only remove the element from the queue from the beginning of the
    queue (the dequeue operation). For this reason, this data structure is consistent
    with the FIFO principle, which stands for First-In First-Out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram of a queue is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6250fe7d-3cb5-4ecf-b654-d944151ec9d1.png)'
  prefs: []
  type: TYPE_IMG
- en: It is also possible to use a priority queue, which extends the concept of a
    queue by setting the priority for each element. Thus, the `Dequeue` operation
    returns the element with the highest priority, which has been added earliest to
    the queue.
  prefs: []
  type: TYPE_NORMAL
- en: There are many real-world applications of a queue. For example, a queue can
    be used to represent a line of people waiting in a shop at a checkout. New people
    stand at the end of the line, and the next person is taken to the checkout from
    the beginning of the line. You are not allowed to choose a person from the middle
    and serve them. Moreover, you have seen a few examples of the solution of a call
    center, where there are many callers (with different client identifiers) and one
    consultant, many callers and many consultants, as well as many callers (with different
    plans, either standard or priority support) and only one consultant, who answers
    the waiting calls.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of the fourth chapter is related to dictionaries and sets. First,
    let's take a look at a dictionary, which allows mapping keys to values and performing
    fast lookups. A dictionary uses a hash function and can be understood as a collection
    of pairs, each consisting of a key and a value. There are two built-in versions
    of a dictionary, namely non-generic (`Hashtable`) and generic (`Dictionary`).
    The sorted variant of a dictionary (`SortedDictionary`) is available, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism of the hash table is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73a7e5c3-bc69-45cf-a947-d5684220a97e.png)'
  prefs: []
  type: TYPE_IMG
- en: Due to the great performance of the hash table, such a data structure is frequently
    used in many real-world applications, such as for associative arrays, database
    indices, or cache systems. Within this book, you have seen how to create the phone
    book to store entries where a person's name is a key and a phone number is a value.
    Among other examples, you have developed an application that helps employees of
    shops to find the location of where a product should be placed, and you have applied
    the sorted dictionary to create the simple encyclopedia, where a user can add
    entries and show its full content.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another data structure is a set, which is a collection of distinct objects without
    duplicated elements and without any particular order. Therefore, you can only
    get to know whether a given element is in the set or not. The sets are strictly
    connected with mathematical models and operations, such as union, intersection,
    subtraction, and symmetric difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exemplary sets, storing data of various types, are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f426b497-d916-4491-9fb3-3a4d1c6fceeb.png)'
  prefs: []
  type: TYPE_IMG
- en: While developing applications in the C# language, you can benefit from high-performance,
    set-related operations provided by the `HashSet` class. As an example, you have
    seen how to create a system that handles one-time promotional coupons and allows
    you to check whether the scanned one has been already used. Another example is
    the reporting service for the system of a SPA center with four swimming pools.
    By using sets, you have calculated statistics, such as the number of visitors
    to a pool, the most popular pool, and the number of people who visited at least
    one pool.
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next topic is about trees, which are data structures that consist of nodes
    with one root. The root contains no parent node, while all other nodes do. Moreover,
    each node can have any number of child nodes. The child nodes of the same node
    can be called siblings, while a node without children is called a leaf.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, each node in a tree can contain any number of children.
    However, in the case of binary trees, a node cannot contain more than two children,
    that is, it can contain no child nodes, or only one or two, but there are no rules
    about relations between the nodes. If you want to use a binary search tree (BST),
    the next rule is introduced. It states that, for any node, values of all nodes
    in its left subtree must be smaller than its value, and that the values of all
    nodes in its right subtree must be greater than its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exemplary BSTs are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/633e03bc-cdd7-42a5-b25c-ca8b34be1fa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Another group of trees is called the self-balancing trees, which keeps a tree
    balanced all the time while adding and removing nodes. Their application is very
    important, because it allows you to form the correctly arranged tree, which has
    a positive impact on performance. There are various variants of the self-balancing
    trees, but AVL and Red-Black Trees (RBTs) are ones of the most popular. Both have
    been briefly described in this book.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about trees, it is also beneficial to present a few approaches
    on how you can traverse a tree. In this book, you have learned pre-order, in-order,
    and post-order variants.
  prefs: []
  type: TYPE_NORMAL
- en: A tree is a data structure that is perfect for the representation of various
    data, such as the structure of a company, divided into a few departments, where
    each has its own structure. You have also seen an example where a tree is used
    to arrange a simple quiz consisting of a few questions and answers, which are
    shown depending on the previously taken decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap is another variant of a tree, which exists in two versions, namely min-heap
    and max-heap. For each of them, the additional property must be satisfied. For
    the min-heap, the value of each node must be greater than or equal to the value
    of its parent node. For the max-heap, the value of each node must be less than
    or equal to the value of its parent node. The mentioned rule performs the crucial
    role of ensuring that the root node always contains the smallest (in the min-heap)
    or the largest (in the max-heap) value. For this reason, it is a very convenient
    data structure for implementing a priority queue.
  prefs: []
  type: TYPE_NORMAL
- en: The heaps exist in many variants, including binary heaps, which must also maintain
    the complete binary tree rule, that is, each node cannot contain more than two
    children, and that all levels of a tree must be fully filled, except the last
    one, which can be filled from left to right with some empty space on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exemplary heaps are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8be416c2-bb1a-4ee9-b294-578a15d11647.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, a binary heap is not the only one that is available. Among others,
    binomial heaps and Fibonacci heaps exist. All three variants have been described
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: One of the interesting applications of a heap is the sorting algorithm, named
    heap sort.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter is related to graphs, as a very popular data structure
    with a broad range of real-world applications. As a reminder, a graph is a data
    structure that consists of nodes and edges. Each edge connects two nodes. Moreover,
    there are a few variants of edges in a graph, such as undirected and directed,
    as well as unweighted and weighted. A graph can be represented either as an adjacency
    list or as an adjacency matrix.
  prefs: []
  type: TYPE_NORMAL
- en: All of these topics have been described in this book, together with the problem
    of graph traversal, finding the minimum spanning tree, node coloring, and finding
    the shortest path in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exemplary graphs are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba397110-c2a0-493f-9cc2-be665e23e4da.png)'
  prefs: []
  type: TYPE_IMG
- en: A graph data structure is commonly used in various applications, and it is a
    great way to represent diverse data, such as the structure of friends available
    on a social media site. Here, the nodes can represent contacts, while edges represent
    relations between people. Thus, you can easily check whether two contacts know
    each other or how many people should be involved to arrange a meeting between
    two particular people.
  prefs: []
  type: TYPE_NORMAL
- en: Another common application of graphs involves the problem of finding a path.
    As an example, you can use a graph to find a path between two points in the city,
    taking into account distance or time necessary for driving. You can use a graph
    to represent a map of a city, where nodes are intersections and edges represent
    roads. Of course, you should assign weights to edges to indicate the necessary
    distance or time for driving a given road.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other applications related to graphs. For instance, the minimum
    spanning tree can be used to create a plan of connections between buildings to
    supply all of them with a telecommunication cable with the smallest cost, as explained
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The node coloring problem has been used for coloring voivodeships on a map of
    Poland according to the rule that two voivodeships that have common borders cannot
    have the same color. Of course, the number of colors should be limited.
  prefs: []
  type: TYPE_NORMAL
- en: Another example shown in this book involves Dijkstra's algorithm for finding
    the shortest path in a game map. The task is to find the shortest path between
    two places on a board, taking into account various obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The last word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have just reached the end of the last chapter of the book. First, the classification
    of data structures has been presented, taking into account linear and non-linear
    data structures. In the first group, you can find arrays, lists, stacks, and queues,
    while the second group involves graphs, trees, heaps, as well as their variants.
    In the following part of this chapter, the diversity of applications of various
    data structures has been taken into account. You have seen a short summary of
    each described data structure, as well as information about some problems which
    can be solved with the use of a particular data structure, such as a queue or
    a graph. To make the content easier to understand, as well as to remind you of
    the various topics from the previous chapters, the summary has been equipped with
    illustrations of data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In the introduction to this book, I invited you to start your adventure with
    data structures and algorithms. While reading the following chapters, writing
    hundreds of lines of code and debugging, you had a chance to familiarize yourself
    with various data structures, starting with arrays and lists, through stacks,
    queues, dictionaries, and hash sets, ending with trees, heaps, and graphs. I hope
    that this book is only the first step into your long, challenging, and successful
    adventure with data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to thank you for reading this book. If you have any questions or
    problems regarding the described content, please do not hesitate to contact me
    directly using the contact information shown at [http://jamro.biz](http://jamro.biz).
    I would like to wish you all the best in your career as a software developer,
    and I hope that you have many successful projects!
  prefs: []
  type: TYPE_NORMAL
