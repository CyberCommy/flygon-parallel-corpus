- en: Chapter 6. Debugging and Reverse Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debuggers are the main tools used for reverse engineering. With debuggers, we
    can perform analysis at runtime to understand the program. We can identify the
    call chains and track indirect calls. With debuggers, we can analyze and watch
    program runtime to guide our reverse engineering. In this chapter, we'll learn
    how to use debuggers in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Portable executable analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disassembling with Capstone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEfile with Capstone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging using PyDBG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main kinds of reverse engineering analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static analysis**: Analysis of the contents of a binary file. This helps
    to determine the structure of the executable portions and print out readable portions
    to get more details about the purpose of the executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic analysis**: This type will execute the binary with or without attaching
    a debugger to discover what the purpose is and how the executable works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid analysis**: This is a mixture of static and dynamic analysis. Repeating
    between static analyses, followed by a dynamic debugging, will give better intuition
    about the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable executable analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any UNIX or Windows binary executable file will have a header to describe its
    structure. This includes the base address of its code, data sections, and a list
    of functions that can be exported from the executable. When an executable file
    is executed by the operating system, first of all the operating system reads its
    header information and then loads the binary data from the binary file to populate
    the contents of the code and data sections of the address for the corresponding
    process.
  prefs: []
  type: TYPE_NORMAL
- en: A **Portable Executable** (**PE**) file is the file type that a Windows operating
    system can execute or run. The files that we run on Windows systems are Windows
    PE files; these can have EXE, DLL (Dynamic Link Library), and SYS (Device Driver)
    extensions. Also, they contain the PE file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary executable files on Windows have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: DOS Header (64 bytes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PE Header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sections (code and data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now examine each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: DOS header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DOS Header starts with the magic numbers `4D 5A 50 00` (the first two bytes
    are the letters `MZ`), and the last four bytes (`e_lfanew`) indicates the location
    of the PE header in the binary executable file. All other fields are not relevant.
  prefs: []
  type: TYPE_NORMAL
- en: PE header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PE header contains more interesting information. The following is the structure
    of the PE header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PE header](img/image_06_001-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The PE header consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 4-byte magic code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20-byte file header, whose data type is **IMAGE_FILE_HEADER**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 224-byte optional header, whose data type is **IMAGE_OPTIONAL_HEADER32**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the optional header has two parts. The first 96 bytes contain information
    such as major operating systems and entry point. The second part consists of 16
    entries with 8 bytes in each entry, to form a data directory of 128 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about PE files at: [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx) and 
    structures used within the file headers at: [http://msdn2.microsoft.com/en-gb/library/ms680198.aspx](http://msdn2.microsoft.com/en-gb/library/ms680198.aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `pefile` module (a multi-platform full Python module intended
    for handling PE files) to get all the details of these file headers in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Loading PE file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loading a file is as simple as creating an instance of the PE class in the module
    with the path to the executable as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the module `pefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Initiate the instance with the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an interactive terminal, we can do a basic inspection of PE file headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, import the `pefile` and load the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the object. To better understand, we can use the `pprint` module
    to print this object in a readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all in a readable format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting headers](img/image_06_002-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also print the contents of a specific header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the hex value of each header with hex():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To inspect sections in the executable, we have to iterate `pe.sections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: PE packers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Packers** are the tools used to compress PE files. This will reduce the size
    of the file as well as adding another layer of obfuscation to the file being reverse
    engineered statically. Even though packers were created to decrease the overall
    file size of executables, later, the benefits of obfuscation were used by many
    malware authors. Packers wrap the compressed data inside a working PE file structure
    and decompress the PE file data into memory, and run it while executing.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use signature databases to detect the packer used if the executable is
    packed. Signature database files can be found by searching the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: For this we require another module, `peutils`, which comes with the `pefile`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can load the signature database from a local file or from a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After loading the signature database, we can run the PE instance with this
    database to identify the signature for the packer used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will output the possible packer used.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we check the section names in the packed executable, they will have
    a slight difference. For example, an executable which is packed with UPX, its
    section names will be `UPX0`, `UPX1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all imported and exported symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The imports can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can''t list the exports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Disassembling with Capstone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Disassembling** is the opposite process of assembling. Disassemblers try
    to create the assembly code from the binary machine code. For this, we are using
    a Python module named **Capstone**. Capstone is a free, multiplatform and multi-architecture
    disassembler engine.'
  prefs: []
  type: TYPE_NORMAL
- en: After installation, we can use this module in our Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to run a simple test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line imports the module, then initiates the `capstone` Python class
    with `Cs`, which takes two arguments: hardware architecture and hardware mode.
    Here we instruct to disassemble 64 bit code for x86 architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line iterates the code list and passes the code to the `disasm()` in
    the `capstone` instance `cs`. The second parameter for `disasm()` is the address
    of the first installation. The output of `disasm()` is a list of installations
    of type `Cslnsn`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we print out some of this output. `Cslnsn` exposes all internal information
    about the disassembled installations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Id**: Instruction ID of the instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address**: Address of the instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mnemonic**: Mnemonic of the instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**op_str**: Operand of the instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**size**: Size of the instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**byte**: The byte sequence of the instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like this, we can disassemble binary files with Capstone.
  prefs: []
  type: TYPE_NORMAL
- en: PEfile with Capstone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we use the `capstone` disassembler to disassemble the code we extracted
    with `pefile` to get the assemble code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we start by importing the required modules. Here, these are `capstone`
    and `pefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `AddressofEntryPoint` value within the `IMAGE_OPTIONAL_HEADER` is the pointer
    to the entry point function relative to the image base address. In the case of
    executable files, this is the exact point where the code of the application begins.
    So, we get the starting of the code with the help of `pefile` as `pe.OPTIONAL_HEADER.AddressOfEntryPoint` 
    and pass this to the disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the process of fixing bugs in a program. Debuggers are those programs
    that can run and watchdog the execution of another program. So, the debugger can
    have control over the execution of the target program and can monitor or alter
    the memory and variables of the targeted program.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints help to stop the execution of the target program within the debugger
    at a location where we choose. At that time, execution stops and control is passed
    to the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breakpoints come in two different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Breakpoints**: Hardware breakpoints require hardware support from
    the CPU. They use special debug registers. These registers contain the breakpoint
    addresses, control information, and breakpoint type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software Breakpoints**: A software breakpoint replaces the original instruction
    with an instruction that traps the debugger. This can only break on execution.
    The main difference between them is that hardware breakpoints can be set on memory.
    But, software breakpoints cannot be set on memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PyDBG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the PyDBG module to debug executables in run time. We can go through
    a basic script with PyDBG to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define a function to handle the breakpoint. Also, it takes the `pydbg`
    instance as the argument. Inside this function, it prints out the execution context
    of the process and instructs `pydbg` to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we initialize the `pydbg` instance and set the `handler_breakpoint` function
    to handle the breakpoint exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then attach the process ID of the process which we need to debug using `pydbg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will set the address at which to trigger the breakpoint. Here, we use
    `bp_set()` function, which accepts three arguments. The first is the address at
    which to set the breakpoint, the second is an optional description, and the third
    argument indicates whether `pydbg` restores this breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start `pydbg` in the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we pass the breakpoint as an argument to this script. So,
    we can run this script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pydbg` contains many other useful functionalities that can be found in the
    documentation at: [http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html](http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the basic tools that can be used to programmatically reverse
    engineer and debug binary files with Python. Now you will be able to write custom
    scripts to debug and reverse engineer the executables, which will help in malware
    analysis. We will discuss some crypto, hash, and conversion functions with Python
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
