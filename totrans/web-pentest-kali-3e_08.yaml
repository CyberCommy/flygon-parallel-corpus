- en: Attacking Flaws in Cryptographic Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main objectives of information security is to protect the confidentiality
    of data. In a web application, the goal is to ensure that the data exchanged between
    the user and the application is secure and hidden from any third party. When stored
    on the server, the data also needs to be secured from hackers. **Cryptography**,
    the practice of communicating through and deciphering secret writings or messages,
    is used to protect the confidentiality as well as the integrity of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Current standard cryptographic algorithms have been designed, tested, and corrected
    at length by highly specialized teams of mathematicians and computer scientists.
    Examining their work in depth is beyond the scope of this book; also, trying to
    find vulnerabilities inherent in these algorithms is not the goal of this book.
    Instead, we will focus on certain implementations of these algorithms and how
    you can detect and exploit implementation failures, including those custom implementations
    which have not undergone the same level of design and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers will try to find different ways to defeat layers of encryption and
    expose plaintext data. They use different techniques, such as exploiting design
    flaws in the encryption protocol or tricking the user into sending data over a
    nonencrypted channel, circumventing the encryption itself. As a penetration tester,
    you need to be aware of such techniques and be able to identify the lack of encryption
    or a flawed implementation, exploit such flaws, and issue a recommendation to
    fix the issue as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will analyze how cryptography works in web applications
    and explore some of the most common issues found in its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A cryptography primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to establish a clear differentiation between concepts that are
    often confused when talking about cryptography: encryption, encoding, obfuscation,
    and hashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**: This is the process of altering data through mathematical algorithms
    in order to make it unintelligible to unauthorized parties. Authorized parties
    are able to decrypt the message back to cleartext using a key. AES, DES, Blowfish,
    and RSA are well-known encryption algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encoding**: This also alters the message, but its main goal is to allow that
    message to be processed by a different system. It doesn''t require a key, and
    it''s not considered a proper way of protecting information. Base64 encoding is
    commonly used in modern web applications to allow the transmission of binary data
    through HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obfuscation**: This makes the original message harder to read by transforming
    the message. JavaScript code obfuscation is used to prevent debugging and/or protect
    intellectual property and its most common use is in web applications. It is not
    considered a way of protecting information from third parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hashing**: A hashing function is the calculation of a fixed length, a unique
    number that represents the contents of the message. The same message must always
    result in the same hash, and no two messages can share hash values. Hash functions
    are theoretically nonreversible, which means that you cannot recover a message
    from its hash. Due to this constraint, they are useful as signatures and integrity
    checks, but not to store information that will need to be recovered at some point.
    Hashing functions are also widely used to store passwords. Common hash functions
    are MD5, SHA1, SHA-512, and bcrypt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms and modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A cryptographic algorithm or cipher is one that takes cleartext and converts
    it into ciphertext through some calculations. These algorithms can be broadly
    classified in two different ways as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: By their use of public and private keys or shared secrets, they can be either
    **asymmetric** or **symmetric**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By how they process the original message, they can be either **stream** or **block
    ciphers**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asymmetric encryption versus symmetric encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asymmetric encryption** uses a combination of public-private keys and is
    more secure than symmetric encryption. The public key is shared with everyone,
    and the private key is stored separately. Encrypted data with one key can only
    be decrypted with other key, which makes it very secure and efficient to implement
    on a larger scale.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric encryption**, on the other hand, uses the same key to encrypt and
    decrypt the data, and you''ll need to find a safe method to share the symmetric
    key with the other party.'
  prefs: []
  type: TYPE_NORMAL
- en: A question that is often asked is why isn't the public-private key pair used
    to encrypt the data stream and instead a session key generated, which uses symmetric
    encryption. The combination of the public-private key is generated through a complex
    mathematical process, which is a processor-intensive and time-consuming task.
    Therefore, it is only used to authenticate the endpoints and to generate and protect
    the session key, which is then used in the symmetric encryption that encrypts
    the bulk data. The combination of the two encryption techniques results in a faster
    and more efficient encryption of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of asymmetric encryption algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Diffie-Hellman key exchange**: This was the first asymmetric encryption algorithm
    developed in 1976, which used discrete logarithms in a finite field. It allows
    two endpoints to exchange secret keys on an insecure medium without any prior
    knowledge of each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rivest Shamir Adleman (RSA)**: This is the most widely used asymmetric algorithm.
    The RSA algorithm is used for both encrypting data and for signing, providing
    confidentiality, and nonrepudiation. The algorithm uses a series of modular multiplications
    to encrypt the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elliptic Curve Cryptography (ECC)**: This is primarily used in handheld devices
    such as smartphones, as it requires less computing power for its encryption and
    decryption process. The ECC functionality is similar to the RSA functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric encryption algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In **symmetric encryption**, a shared secret is used to generate an encryption
    key. The same key is then used to encrypt and decrypt the data. This way of encrypting
    the data has been used for ages in various forms. It provides an easy way to encrypt
    and decrypt data, since the keys are identical. Symmetric encryption is simple
    and easier to implement, but it comes with the challenge of sharing the key with
    the users in a secure way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of symmetric algorithms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Encryption Standard (DES)**: This algorithm uses the DEA cipher. DEA
    is a block cipher that uses a key size of 64 bits; 8 bits being for error detection
    and 56 bits for the actual key. Considering the computing power of today''s computers,
    this encryption algorithm is easily breakable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Triple DES (3DES)**: This algorithm applies the DES algorithm three times
    to each block. It uses three, 56-bit keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Encryption Standard (AES)**: This standard was first published in
    1998, and it is considered to be more secure than other symmetric encryption algorithms.
    AES uses the Rijndael cipher, which was developed by two Belgian cryptographers,
    Joan Daemen and Vincent Rijmen. It replaces the DES algorithm. It can be configured
    to use a variable key size with a minimum size of 128 bits, up to a maximum size
    of 256 bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rivest Cipher 4 (RC4)**: RC4 is a widely used stream cipher, and it has a
    variable key size of 40 to 2,048 bits. RC4 has some design flaws that makes it
    susceptible to attacks, although such attacks may not be practical to perform
    and require a huge amount of computing power. RC4 has been widely used in the
    SSL/TLS protocol. Many organizations, however, have started to move to AES instead
    of RC4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream and block ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symmetric algorithms are divided into two major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stream ciphers:** This algorithm encrypts individual bits at a time and therefore
    requires more processing power. It also requires a lot of randomness, as each
    bit is to be encrypted with a unique key stream. Stream ciphers are more suitable
    to be implemented at the hardware layer and are used to encrypt streaming communication,
    such as audio and video, as it can quickly encrypt and decrypt each bit. The ciphertext
    resulting from the use of this kind of algorithm is the same size as the original
    cleartext.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block ciphers:** With this algorithm, the original message is divided into
    fixed-length blocks and padded (extended to fulfill the required length) in the
    last one. Then each block is processed independently depending on the mode utilized.
    We will discuss cipher modes further in the subsequent sections. The size of the
    ciphertext resulting from a block cipher is always a multiple of the block size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption algorithms are *deterministic*. This means that the same input will
    always result in the same output. This is a good thing, given that, when decrypting,
    you want to be able to recover the exact same message that was encrypted. Unfortunately,
    this makes encryption weaker, as it makes it vulnerable to cryptanalysis and known-text
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: To face this issue, **Initialization Vectors** (**IVs**) were implemented. An
    IV is an extra piece of information that is different each time the algorithm
    is executed. It is used to generate the encryption key or to preprocess the cleartext,
    usually through an XOR operation. This way, if two messages are encrypted with
    the same algorithm and the same key, but a different IV, the resulting ciphertexts
    will be different. IVs are attached to the ciphertext, as the recipient has no
    way of knowing them beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The golden rule, especially for stream ciphers, is never to repeat IVs. The
    RC4 implementation of the **Wired Equivalent Privacy** (**WEP**) authentication
    in wireless networks uses a 24-bit (3 bytes) IV that permits duplicated keystreams
    in a short period of time. Having a known text, such as a DHCP request, sent through
    the network multiple times with the same IV allows an attacker to recover the
    keystreams, and multiple keystreams/IV pairs can be used to recover the shared
    secret.
  prefs: []
  type: TYPE_NORMAL
- en: Block cipher modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **mode of operation** is how an encryption algorithm uses the IV and how
    it implements the encryption of each block of cleartext. Next, we will talk about
    the most common modes of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Code Book (ECB)**: With this mode of operation, there is no use
    of IV and each block is encrypted independently. Thus, when blocks that contain
    the same information result in the same ciphertext, they make analysis and attacks
    easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cipher Block Chaining (CBC)**: With the CBC mode, blocks are encrypted sequentially;
    an IV is applied to the first block, and the resulting ciphertext in each block
    is used as the IV to encrypt the next one. CBC mode ciphers may be vulnerable
    to padding oracle attacks, where the padding done to the last block may be used
    to recover the keystream provided that the attacker can recover large amounts
    of encrypted packages and that there is a way of knowing if a package has the
    correct padding (an oracle).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Counter (CTR)**: This is probably the most convenient and secure method,
    if implemented correctly. Blocks are encrypted independently using the same IV
    plus a counter that is different for each block. This makes the mode capable of
    processing all blocks of a message in parallel and having different ciphertext
    for each block, even if the cleartext is the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hashing functions** are commonly used to ensure the integrity of the message
    transmitted and as an identifier to determine quickly if two pieces of information
    are the same. A hashing function generates a fixed-length value (hash) that represents
    the actual data.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing functions are suitable to those tasks, because, by definition, no two
    different pieces of information should have the same resulting hash (collision),
    and the original information should not be recoverable from the hash alone (that
    is, hashing functions are not reversible).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most common hashing functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: MD5 (Message Digest 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA (Secure Hashing Algorithm) versions 1 and 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NT and NTLM, used by Microsoft Windows to store passwords, based on MD4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salt values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When used to store secrets, such as passwords, hashes are vulnerable to dictionary
    and brute-force attacks. An attacker that captures a set of password hashes may
    try to use a dictionary of known common passwords, hash them, and compare the
    results to the captured hashes, when looking for matches and discovering the cleartext
    passwords when found. Once a hash-password pair is found, all other users or accounts
    using the same password will also be discovered, as all hashes would be the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Salt values** are used to make this task more difficult by appending a random
    value to the information to be hashed and causing the hashing of the same piece
    of data with different salts to result in different hashes. In our previous hypothetical
    case, an attacker recovering the plaintext for one hash would not have recovered
    all of the other instances of the same password automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with IVs, salts are stored and sent along with the hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Secure communication over SSL/TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure Sockets Layer** (**SSL**) is an encryption protocol designed to secure
    communications over the network. Netscape developed the SSL protocol in 1994\.
    In 1999, the **Internet Engineering Task Force** (**IETF**) released the **Transport
    Layer Security** (**TLS**) protocol, superseding SSL protocol version 3\. SSL
    is now considered insecure because of multiple vulnerabilities identified over
    the years. The POODLE and BEAST vulnerabilities, which we will discuss further
    in later sections, expose flaws in the SSL protocol itself and hence cannot be
    fixed with a software patch. SSL was declared deprecated by the IETF, and upgrading
    to TLS was suggested as the protocol to use for secure communications. The most
    recent version of TLS is version 1.2\. We always recommend that you use the latest
    version of TLS and avoid allowing connections from clients using older versions
    or the SSL protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: Most websites have migrated to and have started using the TLS protocol, but
    the encrypted communication is still commonly referred to as an SSL connection.
    SSL/TLS not only provides confidentiality, but it also helps to maintain the integrity
    of the data and to achieve nonrepudiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Securing the communication between the client and the web application is the
    most common use of TLS/SSL, and it is known as **HTTP over SSL** or **HTTPS**.
    TLS is also used to secure the communication channel used by other protocols in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It is used by mail servers to encrypt emails between two mail servers and also
    between the client and the mail server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS is used to secure communication between database servers and LDAP authentication
    servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used to encrypt **Virtual Private Network** (**VPN**) connections known
    as **SSL VPN**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote desktop services in the Windows operating system use TLS to encrypt and
    authenticate the client connecting to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other applications and implementations where TLS is used to
    secure the communication between two parties. In the following sections, we will
    refer to the protocol used by HTTPS as TLS and we will specify when something
    only applies either to SSL or TLS.
  prefs: []
  type: TYPE_NORMAL
- en: Secure communication in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TLS uses the public-private key encryption mechanism to scramble data, which
    helps protect it from third parties listening in on the communication. Sniffing
    the data over the network would only reveal the encrypted information, which is
    of no use without access to the corresponding key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TLS protocol is designed to protect the three facets of the CIA triad—confidentiality,
    integrity, and availability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**: Maintaining the privacy and secrecy of the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: Maintaining the accuracy and consistency of the data, and the
    assurance that it is not altered in transit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Preventing data loss and maintaining access to data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web server administrators implement TLS to make sure that sensitive user information
    shared between the web server and the client is secure. In addition to protecting
    the confidentiality of the data, TLS also provides nonrepudiation using TLS certificates
    and digital signatures. This provides the assurance that the message is indeed
    sent by the party who is claiming to have sent it. This is similar to how a signature
    works in our day-to-day life. These certificates are signed, verified, and issued
    by an independent third-party known as **Certificate Authority** (**CA**). Some
    of the well-known certificate authorities are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: VeriSign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thawte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comodo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DigiCert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entrust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GlobalSign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an attacker tries to fake the certificate, the browser displays a warning
    message informing the user that an invalid certificate is being used to encrypt
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Data integrity is achieved by calculating a message digest using a hashing algorithm,
    which is attached to the message and verified at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: TLS encryption process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encryption is a multistep process, but it is a seamless experience for end
    users. The entire process can be broken down into two parts: the first part of
    encryption is done using the asymmetric encryption technique, and the second part
    is done using the symmetric encryption process. Here is a description of the major
    steps to encrypt and transmit data using SSL:'
  prefs: []
  type: TYPE_NORMAL
- en: The handshake between the client and the server is the initial step in which
    the client presents the SSL/TLS version number and the encryption algorithms that
    it supports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server responds by identifying the SSL version and encryption algorithm
    that it supports, and both parties agree on the highest mutual value. The server
    also responds with the SSL certificate. This certificate contains the server's
    public key and general information about the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The client then authenticates the server by verifying the certificate against
    the list of root certificates stored on the local computer. The client checks
    with the certificate CA that the signed certificate issued to the website is stored
    in the list of trusted CAs. In Internet Explorer, the list of trusted CAs can
    be viewed by navigating to Tools | Internet options | Content | Certificates |
    Trusted Root Certification Authorities, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the information shared during the handshake, the client can generate a
    pre-master secret for the session. It then encrypts the secret with the server's
    public key and sends the encrypted pre-master key back to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server decrypts the pre-master key using the private key (since it was encrypted
    with the public key). The server and the client then both generate a session key
    from the pre-master key using a series of steps. This session key encrypts the
    data throughout the entire session, which is called the symmetric encryption.
    A hash is also calculated and appended to the message, which helps test the integrity
    of the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying weak implementations of SSL/TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in the previous section, TLS is a combination of various encryption
    algorithms packaged into one in order to provide confidentiality, integrity, and
    authentication. In the first step, when two endpoints negotiate for an SSL connection,
    they identify the common cipher suites supported by them. This allows SSL to support
    a wide variety of devices, which may not have the hardware and software to support
    the newer ciphers. Supporting older encryption algorithms has a major drawback.
    Most older cipher suites are easily breakable in a reasonable amount of time by
    cryptanalysts using the computing power available today.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenSSL command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to identify the cipher suites negotiated by the remote web server,
    you can use the OpenSSL command-line tool that comes preinstalled on all major
    Linux distributions, and it is also included in Kali Linux. The tool can be used
    to test the various functions of the OpenSSL library directly from the bash shell
    without writing any code. It is also used as a troubleshooting tool.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL is a well-known library used in Linux to implement the SSL protocol,
    and **Secure channel** (**Schannel**) is a provider of the SSL functionality in
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `s_client` command-line option that establishes
    a connection to the remote server using SSL/TLS. The output of the command is
    difficult to interpret for a newbie, but it is useful for identifying the TLS/SSL
    version and cipher suites agreed upon between the server and the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The OpenSSL utility contains various command-line options that can be used
    to test the server using specific SSL versions and cipher suites. In the following
    example, we are trying to connect using TLS version 1.2 and a weak algorithm,
    RC4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the command. Since the client
    could not negotiate with the `ECDHE-RSA-AES256-SHA` cipher suite, the handshake
    failed and no cipher was selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we are trying to negotiate a weak encryption algorithm
    with the server. It fails, as Google has rightly disabled the weak cipher suites
    on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find out the cipher suites that are easily breakable using the computing
    power available today, enter the command shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will often see cipher suites written as **ECDHE-RSA-RC4-MD5**. The format
    is broken down into the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ECDHE**: This is a key exchange algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RSA**: This is an authentication algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RC4**: This is an encryption algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MD5**: This is a hashing algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comprehensive list of SSL and TLS cipher suites can be found at [https://www.openssl.org/docs/apps/ciphers.html](https://www.openssl.org/docs/apps/ciphers.html).
  prefs: []
  type: TYPE_NORMAL
- en: SSLScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the OpenSSL command-line tool provides many options to test the SSL
    configuration, the output of the tool is not user friendly. The tool also requires
    a fair amount of knowledge about the cipher suites that you want to test.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux comes with many tools that automate the task of identifying SSL misconfigurations,
    outdated protocol versions, and weak cipher suites and hashing algorithms. One
    of the tools is **SSLScan**, which can be accessed by going to Applications |
    Information Gathering | SSL Analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, SSLScan checks if the server is vulnerable to the CRIME and Heartbleed
    vulnerabilities. The `-tls` option will force SSLScan only to test the cipher
    suites using the TLS protocol. The output is distributed in various colors, with
    green indicating that the cipher suite is secure and the sections that are colored
    in red and yellow are trying to attract your attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The cipher suites supported by the client can be identified by running the
    following command. It will display a long list of ciphers that are supported by
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to analyze the certificate-related data, use the following command
    that will display detailed information on the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output of the command can be exported in an XML document using the `-xml=<filename>`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Watch out when `NULL` is pointed out in the names of the supported ciphers.
    If the `NULL` cipher is selected, the SSL/TLS handshake will complete and the
    browser will display the secure padlock, but the HTTP data will be transmitted
    in cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: SSLyze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting tool that comes with Kali Linux, which is helpful in analyzing
    the SSL configuration, is the SSLyze tool released by iSEC Partners. The tool
    is hosted on GitHub at [https://github.com/iSECPartners/sslyze](https://github.com/iSECPartners/sslyze),
    and it can be found in Kali Linux at Applications | Information Gathering | SSL
    Analysis. SSLyze is written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool comes with various plugins, which help in testing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for older versions of SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the cipher suites and identifying weak ciphers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning multiple servers using an input file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for session resumption support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `-regular` option includes all of the common options in which you
    might be interested, such as testing all available protocols (SSL versions 2 and
    3 and TLS 1.0, 1.1, and 1.2), testing for insecure cipher suites, and identifying
    if compression is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, compression is not supported by the server, and it
    is vulnerable to Heartbleed. The output also lists the accepted cipher suites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing SSL configuration using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap includes a script known as `ssl-enum-ciphers`, which can identify the cipher
    suites supported by the server and also rates them based on their cryptographic
    strength. It makes multiple connections using SSLv3, TLS 1.1, and TLS 1.2\. There
    are also scripts that can identify known vulnerabilities, such as Heartbleed or
    POODLE.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run Nmap against the target (bee-box v1.6, [https://sourceforge.net/projects/bwapp/files/bee-box/](https://sourceforge.net/projects/bwapp/files/bee-box/))
    using three scripts: `ssl-enum-ciphers`, to list all the ciphers allowed by the
    server—`ssl-heartbleed` and `ssl-poodle`—to test for those specific vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This first screenshot shows the result of `ssl-enum-ciphers`, displaying the
    ciphers allowed for SSLv3\. In the next screenshot, the `ssl-heartbleed` script
    shows that the server is vulnerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, the `ssl-poodle` script identifies the server as vulnerable to POODLE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exploiting Heartbleed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heartbleed was discovered in April 2014\. It consists of a buffer over-read
    situation in the OpenSSL TLS implementation; that is, more data can be read from
    memory than should be allowed. This situation allows an attacker to read information
    from the OpenSSL server's memory in cleartext. This means that there is no need
    to decrypt or even intercept any communication between client and server; you
    simply *ask* the server what's in its memory and it will answer with the unencrypted
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, Heartbleed can be exploited over any unpatched OpenSSL server (versions
    1.0.1 through 1.0.1f and 1.0.2-beta through 1.0.2-beta1) that supports TLS, and
    by exploiting, it reads up to 64 KB from the server's memory in plaintext. This
    can be done repeatedly and without leaving any trace or log in the server. This
    means that an attacker may be able to read plaintext information from the server,
    such as the server's private keys or encryption certificates, session cookies,
    or HTTPS requests that may contain the users' passwords and other sensitive information.
    More information on Heartbleed can be found on its Wikipedia page at [https://en.wikipedia.org/wiki/Heartbleed](https://en.wikipedia.org/wiki/Heartbleed).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a Metasploit module to exploit a Heartbleed vulnerability in bee-box.
    First, you need to open the Metasploit console and load the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the `show options` command, you can see the parameters the module requires
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the host and port to be attacked and run the module. Notice that
    this module can be run against many hosts at once by entering a list of space
    separated IP addresses and hostnames in the `RHOSTS` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following executed script shows that the server is vulnerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, no relevant information was extracted here. What went wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the module extracted information from the server''s memory, but there
    are more options to set. You can use `show advanced` for Metasploit to display
    the advanced options of a module. To see the information obtained, set the `VERBOSE`
    option to `true` and run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have captured some information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you analyze the result, you'll find that, in this case, the server had a
    password change request in memory, and you can see the previous and current passwords
    as well as a session cookie for the user.
  prefs: []
  type: TYPE_NORMAL
- en: POODLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Padding Oracle On Downgraded Legacy Encryption** (**POODLE**), as its name
    indicates, is a padding oracle attack that abuses the downgrading process from
    TLS to SSLv3.'
  prefs: []
  type: TYPE_NORMAL
- en: Padding oracle attacks require the existence of an oracle, which means a way
    of identifying when the padding of a packet is correct. This could be as simple
    as a *padding error* response from the server. This occurs when an attacker alters
    the last byte of a valid message and the server responds with an error. When the
    message is altered and doesn't result in error, the padding was accepted for the
    value of that byte. Along with the IV, this can reveal one byte of the keystream
    and, with that, the encrypted text can be decrypted. Let's remember that IVs need
    to be sent along with the packages so that the recipient knows how to decrypt
    the information. This works very much like a blind SQL injection attack.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the attacker would need to achieve a man-in-the-middle position
    between the client and server and have a mechanism to make the client send the
    malicious probes. This last requirement can be achieved by making the client open
    a page that contains JavaScript code that performs that work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kali Linux doesn''t include an out-of-the-box tool to exploit POODLE, but there
    is a **Proof of Concept** (**PoC**) to do this by Thomas Patzke on GitHub: [https://github.com/thomaspatzke/POODLEAttack](https://github.com/thomaspatzke/POODLEAttack).
    It is left to the reader to test this PoC as an exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time during web application penetration testing, it will be enough
    for you to see the SSLScan, SSLyze, or Nmap output to know if SSLv3 is allowed,
    so that a server is vulnerable to POODLE; also that no more tests are required
    to prove this fact or to convince your client to disable a protocol that has been
    superseded for nearly 20 years and most recently declared obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Although POODLE is a serious vulnerability for an encryption protocol such as
    TLS, the complexity of executing it in a real-world scenario makes it much more
    likely that an attacker will use techniques such as SSL Stripping ([https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf))
    to force a victim to browse over unencrypted protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Custom encryption protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As penetration testers, it's not uncommon to find applications where developers
    make custom implementations of standard encryption protocols or attempt to create
    their own custom algorithms. In such cases, you need to pay special attention
    to these modules, as they may contain several flaws that could prove catastrophic
    if released into production environments.
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, encryption algorithms are created by information security
    experts and mathematicians specialized in cryptography through years of experimentation
    and testing. It is highly improbable for a single developer or small team to design
    a cryptographically strong algorithm or to improve on an intensively tested implementation
    such as OpenSSL or the established cryptographic libraries of programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying encrypted and hashed information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step when encountering a custom cryptographic implementation or data
    that cannot be identified as cleartext, is to define the process to which such
    data was submitted. This task is rather straightforward if the source code is
    readily accessible. In the more likely case that it isn't available, the data
    needs to be analyzed in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the result of a process is always the same length irrespective of the amount
    of data provided, you may be facing a hashing function. To determine which function,
    you can use the length of the resulting value:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Length** | **Example, hash ("Web Penetration Testing with
    Kali Linux")** |'
  prefs: []
  type: TYPE_TB
- en: '| MD5 | 16 bytes | `fbdcd5041c96ddbd82224270b57f11fc` |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-1 | 20 bytes | `e8dd62289bcff206905cf269c06692ef7c6938a0` |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-2 (256) | 32 bytes | `dbb5195ef411019954650b6805bf66efc5fa5fef4f80a5f4afda702154ee07d3`
    |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-2 (512) | 64 bytes | `6f0b5c34cbd9d66132b7d3a4484f1a9af02965904de38e3e3c4e66676d9``48f20bd0b5b3ebcac9fdbd2f89b76cfde5b0a0ad9c06bccbc662be420b877c080e8fe`
    |'
  prefs: []
  type: TYPE_TB
- en: Notice how the preceding examples represent each byte in a hexadecimal codification
    using two hexadecimal digits to represent the value of each byte (0-255). For
    clarification, the 16 bytes in the MD5 hash are fb-dc-d5-04-1c-96-dd-bd-82-22-42-70-b5-7f-11-fc.
    The eleventh byte (`42`), for example, is the decimal value 66, which is the ASCII
    letter `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it is not uncommon to find hashes in base64 encoding. For example, the
    SHA-512 hash in the preceding table could also be presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Base64 is an encoding technique used to represent binary data using only the
    set of printable ASCII characters, where a base64-encoded byte represents 6 bits
    from the original byte so that 3 bytes (24 bits) can be represented in base64
    with 4 ASCII printable bytes.
  prefs: []
  type: TYPE_NORMAL
- en: hash-identifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kali Linux includes a tool called `hash-identifier`, which has a long list
    of hash patterns and is very useful to determine the type of hash involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Frequency analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very useful way to tell if a set of data is encrypted, encoded, or obfuscated
    is to analyze the frequency at which each character repeats inside the data. In
    a cleartext message, say a letter for example, the ASCII characters in the alphanumeric
    range (32 to 126) will have a much higher frequency than slashes or nonprintable
    characters, such as the *Escape* (27) or *Delete* (127) keys.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, one would expect that an encrypted file would have a very
    similar frequency for every character from 0 to 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be tested by preparing a simple set of files to compare with. Let''s
    compare a plaintext file as base with two other versions of that file: one obfuscated
    and the other encrypted. First create a plaintext file. Use `dmesg` to send the
    kernel messages to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also apply an obfuscation technique called **rotation**, which replaces
    one letter by another in a circular manner around the alphabet. We will use *ROT13*,
    rotating 13 places in the alphabet (that is, `a` will change to `n`, `b` will
    change to `o`, and so on). This can be done through programming or using sites
    such as [http://www.rot13.com/](http://www.rot13.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, encrypt the cleartext file using the OpenSSL command-line utility with
    the AES-256 algorithm and CBC mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, OpenSSL's output is base64 encoded. You will need to take that
    into account when analyzing the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how is a frequency analysis performed on those files? We will use Python
    and the Matplotlib ([https://matplotlib.org/](https://matplotlib.org/)) library,
    preinstalled in Kali Linux, to represent graphically the character frequency for
    each file. The following script takes two command-line parameters, a file name
    and an indicator, if the file is base64 encoded (`1` or `0`), reads that file,
    and decodes it if necessary. Then, it counts the repetitions of each character
    in the ASCII space (0-255) and plots the character count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing the frequency of the plaintext (left) and ROT13 (right) files,
    you will see that there is no big difference—all characters are concentrated in
    the printable range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, when viewing the encrypted file''s plot, the distribution
    is much more chaotic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Entropy analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A definitive characteristic of encrypted information that helps to differentiate
    it from cleartext or encoding is the randomness found in the data at the character
    level. **Entropy** is a statistical measure of the randomness of a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of network communications where file is storage based on the use
    of bytes formed by eight bits, the maximum level of entropy per character is eight.
    This means that all of the eight bits in such bytes are used the same number of
    times in the sample. An entropy lower than six may indicate that the sample is
    not encrypted, but is obfuscated or encoded, or that the encryption algorithm
    used may be vulnerable to cryptanalysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kali Linux, you can use `ent` to calculate the entropy of a file. It is
    not preinstalled, but it can be found in the `apt` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a PoC, let''s execute `ent` over a cleartext sample, for example, the output
    of `dmesg` (the kernel message buffer), which contains a large amount of text
    including numbers and symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s encrypt the same information and calculate the entropy. In this
    example, we''ll use Blowfish with the CBC mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Entropy is increased, but it is not as high as that for an encrypted sample.
    This may be because of the limited sample (that is, only printable ASCII characters).
    Let''s do a final test using Linux''s built-in random number generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Ideally, a strong encryption algorithm should have entropy values very close
    to eight, which would be indistinguishable from random data.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the encryption algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have done frequency and entropy analyses and can tell that the data
    is encrypted, we need to identify which algorithm was used. A simple way to do
    this is to compare the length of a number of encrypted messages; consider these
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: If the length is not consistently divisible by eight, you might be facing a
    stream cipher, with RC4 being the most popular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES is a block cipher whose output's length is always divisible by 16 (128,
    192, 256, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES is also a block cipher; its output's length is always divisible by 8, but
    not always divisible by 16 (as its keystream is 56 bits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common flaws in sensitive data storage and transmission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a penetration tester, one of the important things to look for in web applications
    is how they store and transmit sensitive information. The application's owner
    could face a major security problem if data is transmitted in plaintext or stored
    that way.
  prefs: []
  type: TYPE_NORMAL
- en: If sensitive information, such as passwords or credit card data, is stored in
    a database in plaintext, an attacker who exploits a SQL injection vulnerability
    or gains access to the server by any other means will be able to read such information
    and profit from it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, developers implement their own obfuscation or encryption mechanisms
    thinking that only they know the algorithm, and that nobody else will be able
    to obtain the original information without a valid key. Even though this may prevent
    the occasional random attacker from picking that application as a target, a more
    dedicated attacker, or one that can profit enough from the information, will take
    the time to understand the algorithm and break it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These custom encryption algorithms often involve some variant of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XOR**: Performing a bitwise XOR operation between the original text and some
    other text that acts like a key and is repeated enough times to fill the length
    of the text to encrypt. This is easily breakable as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Substitution**: This algorithm involves the consistent replacement of one
    character with another, along all of the text. Here, frequency analysis is used
    to decrypt a text (for example, *e* is the most common letter in the English language,
    [https://en.wikipedia.org/wiki/Letter_frequency](https://en.wikipedia.org/wiki/Letter_frequency))
    or to compare the frequencies of known text and its encrypted version to deduce
    the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scrambling**: This involves changing the positions of the characters. For
    scrambling to work as a way of making information recoverable, this needs to be
    done in a consistent way. This means that it can be discovered and reversed through
    analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common mistake when implementing encryption in applications is storing
    the encryption keys in unsafe places, such as configuration files that can be
    downloaded from the web server's root directory or other easily accessible locations.
    More often than not, encryption keys and passwords are hardcoded in source files,
    even in the client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Today's computers are much more powerful than those of 10-20 years ago. Thus,
    some algorithms considered cryptographically strong in the past may reasonably
    be broken in a few hours or days, in light of modern CPUs and GPUs. It is not
    uncommon to find information encrypted using DES or passwords hashed with MD5,
    even when those algorithms can be cracked in few minutes, using current technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, though perhaps the most common flaw around, especially in encrypted
    storage, is the use of weak passwords and keys to protect information. An analysis
    made on passwords found in recent leaks tells us that the most used passwords
    are as follows (refer to [https://13639-presscdn-0-80-pagely.netdna-ssl.com/wp-content/uploads/2017/12/Top-100-Worst-Passwords-of-2017a.pdf](https://13639-presscdn-0-80-pagely.netdna-ssl.com/wp-content/uploads/2017/12/Top-100-Worst-Passwords-of-2017a.pdf)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`123456`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`12345678`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`qwerty`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`12345`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`123456789`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`letmein`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1234567`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`football`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`iloveyou`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`admin`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`welcome`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using offline cracking tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are able to retrieve encrypted information from the application, you
    may want to test the strength of the encryption and how effective the key is,
    which is protecting the information. To do this, Kali Linux includes two of the
    most popular and effective offline cracking tools: John the Ripper and Hashcat.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](part0198.html#5SQFC0-d48f8b63a8cc440fbc92835fec01cc38), *Detecting
    and Exploiting Injection-Based Flaws*, in the *Extracting data with SQL Injection*
    section, we extracted a list of usernames and hashes. Here, we will use John the
    Ripper (or simply John) and Hashcat to try and retrieve the passwords corresponding
    to those hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, retrieve the hashes and usernames in a file in a `username:hash` format,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using John the Ripper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'John the Ripper is preinstalled in Kali Linux, and its use is pretty straightforward.
    You can just type `john` to see its basic use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you just use the command and filename as a parameter, John will try to identify
    the kind of encryption or hashing used in the file, attempt a dictionary attack
    with its default dictionaries, and then go into brute force mode and try all possible
    character combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a dictionary attack using the RockYou wordlist included in Kali Linux.
    In the latest versions of Kali Linux, this list comes compressed using GZIP; so
    you will need to decompress it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can run John to crack the collected hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the use of the format parameter. As mentioned earlier, John can try to
    guess the format of the hashes. We already know the hashing algorithm used in
    DVWA and can take advantage of that knowledge to make the attack more precise.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hashcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent versions, Hashcat has merged its two variants (CPU and GPU-based)
    into one, and that is how it's found in Kali Linux. If you are using Kali Linux
    in a virtual machine, as we are in the version used for this book, you may not
    be able to use the full power of GPU cracking, which takes advantage of the parallel
    processing of graphics cards. However, Hashcat will still work in CPU mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To crack the file using the RockYou dictionary in Hashcat, issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**![](img/00226.jpeg)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters used here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-m 0`: `0` (zero) is the identifier for the MD5 hashing algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--force`: This option forces Hashcat to run even when no GPU devices are found,
    this is useful to run Hashcat inside the virtual machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--username`: This tells Hashcat that the input file contains not only hashes
    but also usernames; it expects the `username:hash` format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first filename is always the file to crack, and the next one is the dictionary
    to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After a few seconds, you will see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see all of the options and algorithms supported, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Preventing flaws in cryptographic implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For HTTPS communication, disable all deprecated protocols, such as any version
    of SSL and even TLS 1.0 and 1.1\. The last two need to be taken into consideration
    for the target users of the application, as TLS 1.2 may not be fully supported
    by older browsers or systems. Also, disabling weak encryption algorithms, such
    as DES and MD5 hashing, and modes, such as ECB, must be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the responses of applications must include the secure flag in cookies
    and the **HTTP Strict-Transport-Security** (**HSTS**) header to prevent SSL Strip
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: More information about TLS configuration can be found at [https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet](https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: Passwords must never be stored in cleartext, and it's inadvisable to use encryption
    algorithms to protect them. Rather, a one-way, salted hash function should be
    used. PBKDF2, bcrypt, and SHA-512 are the recommended alternatives. Use of MD5
    is discouraged, as modern GPUs can calculate millions of MD5 hashes per second,
    making it possible to crack any password of less than ten characters in a few
    hours or days with a high-end computer. OWASP also has a useful cheat sheet on
    this subject at [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: For storing sensitive information that needs to be recoverable, such as payment
    information, use strong encryption algorithms. AES-256, Blowfish, and Twofish
    are good alternatives. If asymmetric encryption, such as RSA, is an option, you
    should prefer that ([https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet)).
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using custom implementations or creating custom algorithms. It is much
    better to rely on what has already been used, tested, and attacked multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basic concepts of cryptography, such as symmetric
    and asymmetric encryption, stream and block ciphers, hashing, encoding, and obfuscation.
    You learned how secure communication works in the HTTPS protocol and how to identify
    vulnerabilities in its implementation and configuration. Then we examined the
    common flaws found in the storage of sensitive information and the creation of
    custom encryption algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter with comments on how to prevent such flaws and how
    to make web applications more secure when transmitting and storing sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn about AJAX and HTML5 and the challenges and
    opportunities they pose from the security and penetration testing perspective,
    especially when it comes to client-side code.
  prefs: []
  type: TYPE_NORMAL
