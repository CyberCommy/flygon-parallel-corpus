- en: Chapter 10. Understanding Linux User and Kernel Limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used tools such as `lsof` and `strace` to identify
    the root cause of an application issue.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will once again identify the root cause of an application-related
    issue. However, we will also focus on learning and understanding Linux user and
    kernel limitations.
  prefs: []
  type: TYPE_NORMAL
- en: A reported issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like the previous chapter, which focused on an issue with a custom application,
    today's issue comes from the same custom application.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we will be working on an issue reported by an application support team.
    However, this time the support team was able to provide us with quite a bit of
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The application we were working on in [Chapter 9](part0061_split_000.html#1Q5IA1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 9. Using System Tools to Troubleshoot Applications"), *Using System Tools
    to Troubleshoot Applications*, now receives messages over `port 25` and stores
    them in a queue directory. Periodically, a job runs to process those queued messages,
    but the job *doesn't seem to be working anymore*.
  prefs: []
  type: TYPE_NORMAL
- en: The application support team has noticed quite a large amount of messages backlogged
    in the queue. However, even though they have been troubleshooting the issue as
    much as possible, they are stuck and require our assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the job failing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the issue being reported is that a scheduled job is not working, we should
    first focus on the job itself. In this scenario, we have the application support
    team available to answer any questions. So, let's get a few more details about
    this job.
  prefs: []
  type: TYPE_NORMAL
- en: Background questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a quick list of questions that should help provide you with
    additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: How is the job run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we run the job manually if we need to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does this job execute?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three questions may seem pretty basic, but they are important. Let''s
    first look at the answers the application team provides:'
  prefs: []
  type: TYPE_NORMAL
- en: How is the job run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The job is executed as a cron job.*'
  prefs: []
  type: TYPE_NORMAL
- en: Can we run the job manually if we need to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Yes, it should be okay to execute the job manually as often as needed.*'
  prefs: []
  type: TYPE_NORMAL
- en: What does this job execute?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The job executes the /opt/myapp/bin/processor command as the vagrant user*.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding three questions are important because they will save us quite
    a bit of troubleshooting time. The first question is focused on how the job is
    executed. Since the reported issue is that the job is not working, we don't know
    yet if the issue is because the job is not running or if the job is being executed
    but failing for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the first question tells us that the job is executed by `crond`,
    which is the **cron daemon** that runs on Linux. This is useful as we can use
    this information to identify whether the job is being executed or not. In general,
    there are many methods for scheduled jobs to be executed. Sometimes the software
    that is executing the scheduled job runs on a different system and sometimes it
    runs on the same local system.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the job is being executed by `crond` on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: The second question is also important. Just like we had to launch the application
    manually in the last chapter, we may need to perform this troubleshooting step
    with this reported issue as well. Based on the answer, it seems we are free to
    execute this command as many times as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The third question is useful as it tells us not only what command is being executed
    but also which job to look out for. Cron jobs are a very common method of scheduling
    tasks. It is common for a system to have many cron jobs scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: Is the cron job even running?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we know that the job is being executed by `crond`, we should first check
    whether the job is being executed or not. To do this, we can check the cron logs
    on the server in question. For example, consider the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, on Red Hat based Linux systems we can check the `/var/log/cron`
    log file. I specified "Red Hat based" in the previous sentence because on non-Red-Hat-based
    systems the cron logs may be located in a different log file. Debian-based systems,
    for example, default to `/var/log/syslog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we didn''t know which log file contained cron logs, there is a simple trick
    to find it. Just run the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will use `grep` to search all of the log files in `/var/log`
    for the string `cron`. The command will also search for `Cron`, `CRON`, `cRon`,
    and so on, as we added the `–i` (insensitive) flag to the `grep` command. This
    tells `grep` to search in case-insensitivity mode. Essentially, this means any
    match of the word "cron" will be found even if the word is capitalized or mixed
    case. We also added the `–c` (count) flag to the `grep` command, which causes
    it to count the number of instances it has found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the first result, we can see that `grep` has found 400 instances
    of the word "cron" in `/var/log/cron`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we redirect the results to another `grep` command with the `–v` flag
    followed by `:0`. This `grep` will take the results of the first execution and
    omit (`-v`) any lines with the string `:0`. This is useful for restricting the
    results to only files with the `cron` string within them.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding results, we can see that the file, `/var/log/cron`, has the
    most instances of the word "cron" within it. This fact alone is a good indication
    that `/var/log/cron` is the log file for the `crond` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know which log file has the log messages we are looking for, we
    can take a look at the contents of that log file. Since this log file is quite
    large we will use the `less` command to read this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is quite a bit of information in this log, we will only focus on
    log entries that will help explain the issue. The following segment is an interesting
    group of log messages that should answer whether our job is running or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding log messages show quite a few lines. Let''s break down the logs
    to get a better understanding of what is being executed. Consider the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines do not seem to be the job we are searching for but rather
    the `cron.hourly` jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux systems, there are multiple ways to specify cron jobs. On RHEL systems,
    there are several directories within `/etc/` that start with the name `cron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `cron.daily`, `cron.hourly`, `cron.monthly`, and `cron.weekly` directories
    are all directories that can contain scripts. These scripts are to be run per
    the time specified in the directory name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at `/etc/cron.hourly/0yum-hourly.cron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file is a simple `bash` script that the `crond` daemon will execute
    every hour, as it is in the `cron.hourly` directory. In general the scripts that
    are contained within these directories are put there by system services. However,
    these directories are also open to systems administrators to place their own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: User crontabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we continue down the log file, we can see an entry that is relevant to our
    custom job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This line shows the `processor` command that the application support team referenced.
    This line must be the job the application support team is having issues with.
    The log entry tells us quite a bit of useful information. For one, it provides
    us with the command line options being passed to this job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It also tells us the job is being executed as `vagrant`. The most important
    thing this log entry tells us though is that the job is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know the job is being executed, we should then verify if the job is
    successful. To do this we will take an easy approach and execute the job manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We should omit `> /dev/null` from the end of the cron task as this will redirect
    the output to `/dev/null`. This is a common way of throwing away the output of
    cron jobs. For this manual execution, we can utilize the output to help troubleshoot
    the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once executed, the job seems to fail. Not only does it fail, but it is also
    producing an error message along with the failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This error is interesting, as it seems to suggest that the application is opening
    too many files. *Why would that matter?*
  prefs: []
  type: TYPE_NORMAL
- en: Understanding user limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Linux systems, there are limitations that every process is held to. These
    limits are in place to prevent processes from utilizing too many system resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these limits are enforced on every user, it is possible, however, to
    set different limits per user. To check what limits are set on the `vagrant` user
    by default, we can use the `ulimit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we executed the `ulimit` command, we did so as the vagrant user. This is
    important as when we run the `ulimit` command as any other user including root,
    the output will be the limits of that user.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the output of the `ulimit` command, we can see that there are
    quite a few limitations that can be set.
  prefs: []
  type: TYPE_NORMAL
- en: The file size limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look and breakdown a few key limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first interesting item is the `file size` limit. This limit will restrict
    how large a file the user can create. The current setting for the vagrant user
    is `unlimited` but what would happen if we set this value to a smaller number?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by executing `ulimit –f` followed by the number of blocks to
    limit the file to. For example, consider the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting the value to `10` we can verify it took effect by running `ulimit
    –f` again, but this time with no value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our limit is set to 10 blocks, let''s try to create a 500 MB file
    by using the `dd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One nice thing about user limits on Linux is generally the errors provided are
    self-explanatory. We can see from the preceding output that not only was the `dd`
    command unable to create the file it received an error stating that the file,
    size limit was exceeded.
  prefs: []
  type: TYPE_NORMAL
- en: The max user processes limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting limit is the `max processes` limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This limit prevents a user from having *too many running processes* at one time.
    This is a very useful and interesting limitation as it can easily prevent a rogue
    application from taking over a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be a limitation that you will often encounter. This is especially
    true for applications that launch many sub processes or threads. To see how this
    limitation works, we can change our setting to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Like the file size limit, we can modify the process limit using the `ulimit`
    command. This time, however, we use the `-u` flag. Each user limit has its own
    unique flag with the `ulimit` command. We can see these flags in the output of
    `ulimit –a`, and of course, each flag is referenced in the man page for `ulimit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have set our processes to be limited to `10`, we can see that limit
    enforced by running a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By simply being logged into the vagrant user through SSH, we are already utilizing
    multiple processes. It will be quite easy to run into the limit of `10` processes
    as any new command we run will put our login over the limitation.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding example we can see that when the `man` command was executed,
    it was not able to start a child process and thus returned an error stating `Resource
    temporarily unavailable`.
  prefs: []
  type: TYPE_NORMAL
- en: The open files limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final interesting user limit that I want explore is the `open files` limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `open files` limit will restrict a process from opening more than the defined
    number of files. This limit can be used to prevent a process from opening too
    many files at one time. This is something that can come in handy when preventing
    an application from consuming too many of the system's resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the other limits, let''s see what happens when we reduce this limit to
    a very unreasonable number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As with the other examples, we received an error, `Too many open files`, in
    this case. However, this error looks quite familiar. If we were to look back at
    the error received from our scheduled job we will see why.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After setting our max number of open files to `2`, the `ls` command produced
    an error; the error has the same exact error message our application received
    when executed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that our application is trying to open more files than our system
    is configured to allow? That is a strong possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Changing user limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we suspect the `open files` limit is preventing the application from
    executing, we can set its limit to a higher value. However, this is not as simple
    as executing `ulimit –n`; the following output is what we get when it''s executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By default, on our example system the highest the vagrant user is allowed to
    raise the `open files` limitation to is `4096`. As we can see from the preceding
    error, anything higher is denied; but like most things with Linux we can change
    this.
  prefs: []
  type: TYPE_NORMAL
- en: The limits.conf file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user limits that we have been using and modifying are part of Linux's PAM
    system. PAM or Pluggable Authentication Modules is a system that provides a modular
    authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if our system was to utilize LDAP for authentication, the `pam_ldap.so`
    library would be used to provide this functionality. However, since our system
    uses local users for authentication, the `pam_localuser.so` library handles the
    user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can validate this if we read the `/etc/pam.d/system-auth` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the preceding example, we can see that `pam_localuser.so` is
    listed with `account` as the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This means the `pam_localuser.so` module is a `sufficient` module to allow an
    account to be utilized, which essentially means that the user is able to log in
    if they have a correct `/etc/passwd` and `/etc/shadow` entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the preceding line, we can see where user limits are enforced.
    This line essentially tells the system that the `pam_limits.so` module is required
    for all user sessions. This effectively ensures that the user limits, which the
    `pam_limits.so` module identifies are enforced on each user session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for this PAM module is located in `/etc/security/limits.conf`
    and `/etc/security/limits.d/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we read the `limits.conf` file, we can see quite a bit of useful information
    about user limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this file, the available limitations are listed along with a description
    of what that limitation enforces. For example, in the preceding command lines,
    we can see the following for the number of `open files` limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From this line we can see that if we want to change the number of open files
    available to our user, we will need to use the `nofile` type. On top of listing
    what each limitation does, the `limits.conf` file also contains examples of setting
    custom limits for users and groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this example we can see what format we need to use to set the limit;
    but what should we set the limitation too? If we look back at the error from our
    job, we can see that the error listed a file in the `/opt/myapp/queue` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It is safe to say that the application is trying to open the files within this
    directory. So, to determine how many files this process needs to have open, let''s
    find out how many files exist in this directory by using the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command uses `ls –la` to list all of the files and directories
    within the `queue/` directory and redirects that output to `wc –l`. The `wc` command
    will count the number of lines (`-l`) from the provided output, which essentially
    means that within the `queue/` directory, there are 492,304 files and/or directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the large number, we should set the number of `open files` limit to `500000`,
    enough to process the `queue/` directory with a little extra just in case. We
    can do this by appending the following line to the `limits.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding our line with `vi`, or another text editor, we can verify it is
    there with the `tail` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Changing these settings does not mean our login shell instantly has a limit
    of `500000`. Our logged in session still has a limitation of `4096` set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We also still cannot increase it beyond that value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In order for our change to take effect, we must log in to our user once again.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, these limitations are set by PAM, which is applied
    during the login of our shell session. Since the limitations are set during login,
    we are still being restricted by the previous values picked up when we last logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the new limitations, we must log out and log back in (or spawn a new
    login session). For our examples, we will log out of our shell and log back in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the preceding command lines, we can see something quite interesting.
  prefs: []
  type: TYPE_NORMAL
- en: When we logged in this time, our number of files limitation was set to `100000`,
    which just happens to be the same limit we set as the `soft` limit in the `limits.conf`
    file. This happened because the `soft` limit is the limit set by default for each
    session.
  prefs: []
  type: TYPE_NORMAL
- en: The `hard` limit is the highest value above the `soft` limit that this user
    can set. We can see this in action in the preceding example, as we were able to
    set the `nofile` limit to `500000` but not `501000`.
  prefs: []
  type: TYPE_NORMAL
- en: Future proofing the scheduled job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we set the `soft` limit to `100000` was because we are planning for
    similar scenarios in the future. With the `soft` limit set at `100000`, the cron
    job that runs this scheduled job will be limited to 100,000 open files. However,
    since the `hard` limit is set to `500000`, someone can then manually run the job
    with a higher limit set on their login session.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the number of files in the `queue` directory does not exceed 500,000,
    there should no longer be a need for anyone to edit the `/etc/security/limits.conf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Running the job again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our limitations have been increased, we can try to run the job again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once again we received an error. However, this time the error is just a little
    bit different.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous run, we received the following error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: However, this time we received this error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The difference is extremely subtle, but in the second run our error stated **Too
    many open files in system**, whereas our first run did not include `in system`.
    The reason for this is because we hit a different type of limitation, not a **user**
    limitation, but a **system** limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel tunables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux Kernel itself can set limitations on a system as well. These limits
    are defined based on kernel parameters. Some of these parameters are static and
    cannot be changed during runtime; while others can. When a kernel parameter can
    be changed during runtime this is called a **tunable parameter**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see both static and tunable kernel parameters and their current values
    by using the `sysctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Since there are many parameters available, I used the `head` command to limit
    the output to the first 10\. The error we received earlier mentioned a limitation
    on the system, this suggests we may be hitting a limit imposed by the kernel itself.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is how do we know which one? The fastest answer of course is
    to search Google. Since there are so many kernel parameters (800+ on the system
    we are working on), it is difficult to simply read the output of `sysctl –a` and
    find the right one.
  prefs: []
  type: TYPE_NORMAL
- en: A more realistic approach is to simply search for the type of parameter we are
    looking to modify. An example search for our scenario would be `Linux parameter
    max open files`. If we were to perform this search we will most likely find the
    parameter and how to modify it. If Google is not an option however, there is another
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the kernel parameters have a name that describes what the parameter
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we were to look for the kernel parameter that disables IPv6
    we would first start by searching for the `net` string, as in network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, this still returns a large number of results. Within those results,
    we can see the string `ipv6` though.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, quite a few results; however, we get the following output if we add
    a search for the string `disable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can finally narrow down the possible parameters. However, we do not fully
    know what these parameters do. Not yet, at least.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we perform a quick search through `/usr/share/doc`, we might find a few
    documents that explain what these settings do. We can do this quickly by performing
    a recursive search for `-r` through this directory using `grep`. In order to keep
    the output simple, we can add `-l` (list file), which causes `grep` to only list
    the filenames it finds the desired string within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: On Red Hat based Linux systems, the `/usr/share/doc` directory is used for additional
    documentation outside of the system's man pages. If we were limited to only utilizing
    the documentation on the system itself, the `/usr/share/doc` directory is one
    of the first places to check.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the kernel parameter for open files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we like performing tasks the hard way, we will try to identify the kernel
    parameter that is potentially limiting us without searching for it on Google.
    The first step to do this will be to search the `sysctl` output for the string
    `file`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we are searching for `file` is because we are hitting a limitation
    on the number of files. While this may not provide the exact parameter we are
    trying to identify, the search at least is going to get us started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Searching for `file` may have actually been a very good choice after all. Simply
    based on the names of the parameters, the two that may be interesting to us are
    `fs.file-max` and `fs.file-nr`. At this point, we do not know which one controls
    the number of open files or if either of these do.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more information we can search through the `doc` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that a document named `TUNING_README`, located in the Postfix services
    documentation, has a reference to at least one of our values. Let''s check out
    the file to see what this document says about this kernel parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we read the contents of the file around where it lists our kernel parameter,
    we can see that it specifically calls out parameters to *configure the kernel
    for more open files and sockets*.
  prefs: []
  type: TYPE_NORMAL
- en: This document calls out two kernel parameters to allow for more open files and
    sockets. The first is called `fs.file-max`, which is one we also identified with
    our `sysctl` search. The second is called `kernel.threads-max`, which is fairly
    new.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply based on the names, it seems the tunable parameter we want to modify
    is the `fs.file-max` parameter. Let''s take a look at its current value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can list the current value of this parameter by executing `sysctl` followed
    by the parameter name (as shown in the preceding command lines). This will simply
    display the value as it is defined currently; which seems to be set at `48582`
    a number far lower than our current user limits.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding example, we found this parameter in a postfix document. While
    this may be good, it is not exact. If you often find yourself needing to search
    locally for kernel parameters, it would be a good idea to install the `kernel-doc`
    package. The `kernel-doc` package contains quite a bit of information, especially
    about tunables.
  prefs: []
  type: TYPE_NORMAL
- en: Changing kernel tunables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we believe the `fs.file-max` parameter controls the maximum number of
    open files a system can have, we should change this value to allow our job to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Like most system configuration items on Linux, there is the option to change
    this value ad-hoc and on reboot. Earlier we set the `limits.conf` file to allow
    the vagrant user the ability to open 100,000 files as a `soft` limit and 500,000
    as a `hard` limit. The question is do we want this user to be able to open 500,000
    files as a normal operation? Or should this be a one-time task to correct the
    issue we are currently facing?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simply: *it depends!*'
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the situation we are working on currently, the job in question
    has not been run for quite a while. Because of this there is a large backlog of
    messages in the queue. However, these are not normal conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier when we set the user limit to 100,000 files, we did so as this is a
    somewhat appropriate value for this job. With this considered, we should also
    set the kernel parameter to a value slightly over `100000` but not too far over.
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario and in this environment, we are going to perform two actions.
    The first is to configure the system to allow for *125,000 open files by default*.
    The second is to set the current parameter to *525,000 open files* to allow the
    scheduled job to run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Permanently changing a tunable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we want to change the value of `fs.file-max` to `125000` by default, we
    will need to edit the `sysctl.conf` file. The `sysctl.conf` file is a system configuration
    file, which allows you to specify custom values for tunable kernel parameters.
    During every reboot of the system, this file is read and the values within it
    are applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set our `fs.file-max` value to `125000` we can simply append the
    following line to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have added our custom value, we will need to tell the system to
    apply it.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the `sysctl.conf` file is applied on reboot, however we
    can also apply the settings to this file at any time using the `sysctl` command
    with the `–p` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When given the `–p` flag, the `sysctl` command will read and apply the values
    to the file specified, or if no file is specified `/etc/sysctl.conf`. Since we
    did not specify a file after the `–p` flag, the `sysctl` command applied the values
    added to `/etc/sysctl.conf` and printed the values it modified.
  prefs: []
  type: TYPE_NORMAL
- en: Let's validate it was applied appropriately by executing `sysctl` again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It appears that in fact the value was applied appropriately, but what about
    setting it to `525000`?
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily changing a tunable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it may be simple enough to change the `/etc/sysctl.conf` to a higher value,
    apply it, and then revert the change. There is a much easier way to change a tunable's
    value temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: The `sysctl` command, when provided with the `–w` option, will allow modification
    of tunable values. To see this in action, we will use this to set the `fs.file-max`
    value to `525000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Like when we applied the `sysctl.conf` file''s values, when we executed `sysctl
    –w` it printed the values it applied. If we validate them again, we will see the
    value is set to `525000` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Running the job one last time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have set our `open files` limit to `500000` for the vagrant user
    and `525000` on the system as a whole. We can execute this job manually one more
    time, and this time it should be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This time the job executed without providing any errors! We can see from the
    output of the job that all of the files in `/opt/myapp/queue` were processed as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: A look back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have resolved the issue, let's take a second to look at what we
    did to resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Too many open files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to troubleshoot our issue, we executed a scheduled cron job manually.
    If we circle back to previous chapters, this is a prime example of duplicating
    an issue and seeing it for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the job was not performing the tasks it was supposed to. In order
    to identify the reason, we ran it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'During that manual execution, we were able to identify the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This error is very common and is caused by the job running into user limits
    that prevent a single user from opening too many files. To resolve this we added
    custom settings to the `/etc/security/limits.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'These changes set the `soft` limitation of `open files` to `100000` for our
    user by default. We also allowed the user to increase the `open files` limit to
    `500000` on an ad-hoc basis via the `hard` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: After modifying these limits, we executed the job again and experienced a similar
    but different error.
  prefs: []
  type: TYPE_NORMAL
- en: This time the `open files` limitation was being imposed on the system itself,
    which in this case imposed a system-wide limit of 48,000 open files.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this we set a permanent setting of `125000` in the `/etc/sysctl.conf`
    file and temporarily changed the value to `525000`.
  prefs: []
  type: TYPE_NORMAL
- en: From that point we were able to execute the job manually. Beyond this instance
    however, since we changed the default limitations we also gave this job more resources
    to execute normally. As long as there is not a backlog of greater than 100,000
    files this job should execute without issue in the future.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of clean up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Speaking of normal executions, in order to reduce the kernel's limitation of
    open files we can execute the `sysctl` command again with the `–p` option. This
    will reset the value to the defined value within the `/etc/sysctl.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: One caveat to this method is that `sysctl -p` will only reset the values specified
    in `/etc/sysctl.conf`; *which only contains a handful of tunable values by default*.
    If a value not specified in `/etc/sysctl.conf` is modified, the `sysctl -p` method
    will not reset this value to default.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we became very familiar with the kernel and user limitations
    enforced within Linux. These settings become very useful as any application that
    utilizes many resources will eventually run into one of these.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be focusing on a very common but very tricky issue.
    We will focus on troubleshooting and identifying the cause of a system running
    out of memory. When a system runs out of memory, there are a lot of consequences
    such as application processes being killed.
  prefs: []
  type: TYPE_NORMAL
