- en: Working with Different Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developers of desktop applications usually pay little attention to the hardware
    architecture. First, they often use high-level programming languages that hide
    these complexities at the cost of performance. Second, in most cases, their code
    runs on the x86 architecture, and they often take its features for granted. For
    example, they may assume that the size of int is 32 bits, but that is not true
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded developers deal with a much wider variety of architectures. Even if
    they do not write code in an assembly language that's native to the target platform,
    they should be aware that all C and C++ fundamental types are architecture-dependent;
    the standard only guarantees that int is at least 16-bit. They should also know the
    traits of particular architectures, such as endianness and alignment, and take
    into account that operations that are performed with the floating-point or 64-bit
    numbers, which are relatively cheap on the x86 architecture, can be much more
    expensive on other architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Since they aim to achieve maximal possible performance from embedded hardware,
    they should understand how to organize data in memory to get the most efficient
    use out of the CPU cache and operating system paging mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring fixed-width integer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the `size_t` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the endianness of the platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the endianness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with packed structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning data with cache lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By looking at these topics, we will learn how to tailor our code to target platforms
    to achieve maximum performance and portability.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring fixed-width integer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C and C++ developers often forget that the size of fundamental data types such
    as char, short, and int are architecture-dependent. At the same time, most of
    the hardware peripherals define specific requirements regarding the size of the
    fields that are used for data exchanges. To make the code working with the external
    hardware or communication protocols portable, embedded developers use fixed-size
    integer types, which explicitly specify the size of a data field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most commonly used data types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Width** | **Signed** | **Unsigned** |'
  prefs: []
  type: TYPE_TB
- en: '| 8-bit | `int8_t` | `uint8_t` |'
  prefs: []
  type: TYPE_TB
- en: '| 16-bit | `int16_t` | `uint16_t` |'
  prefs: []
  type: TYPE_TB
- en: '| 32-bit | `int32_t` | `uint32_t` |'
  prefs: []
  type: TYPE_TB
- en: The pointer size also depends on the architecture. Developers often need to
    address the elements of arrays, and since arrays are internally represented as
    pointers, the offset representation depends on the pointer's size. `size_t` is
    a special data type as it represents the offset and data sizes in an architecture-independent
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use fixed-size data types in our code to
    make it portable across architectures. This way, we can make our application work
    with other target platforms faster and with fewer code modifications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create an application that emulates data exchange with a peripheral
    device. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `fixed_types`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create a file called `fixed_types.cpp` in
    the `fixed_types` subdirectory. Copy the following code snippet into the `fixed_types.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml),
    *Setting Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the binary to see how it works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run the binary, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2a222c6-a006-4c01-ad57-fa2463d6e63f.png)'
  prefs: []
  type: TYPE_IMG
- en: In this simple program, we're simulating communication with an external device.
    Since we don't have a real device, the `SendDataToDevice` function just prints
    the size of the data it is supposed to send to the target device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the device can operate on chunks of data of a variable size. Each chunk
    of data is prepended by its size and encoded as a 32-bit unsigned integer. This
    can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Size** | **Payload** |'
  prefs: []
  type: TYPE_TB
- en: '| 0-4 bytes | 5 - N bytes, where N is Size |'
  prefs: []
  type: TYPE_TB
- en: 'In our code, we declare `size` as `uint32_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This means that it will take 32 bits exactly on every platform – 16-, 32-, or
    64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will send the size to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`SendDataToDevice` doesn''t send the actual data; instead, it reports the size
    of the data to be sent. As we can see, the size is `4` bytes, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we declare the `int` data type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, this code can only work on 32- and 64-bit systems, and silently
    produce incorrect results on 16-bit systems, since `sizeof(int)` is 16 here.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code we implemented in this recipe is not fully portable since it doesn't
    take the order of bytes in a 32-bit word into account. This order is called **endianness**,
    and its implications will be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the size_t type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pointer size also depends on the architecture. Developers often need to
    address the elements of arrays, and, since arrays are internally represented as
    pointers, the offset representation depends on the pointer's size.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a 32-bit system, pointers are 32-bit, the same as `int`. However,
    in a 64-bit system, the size of `int` is still 32-bit, while pointers are 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: '`size_t` is a special data type since it represents offset and data sizes in
    an architecture-independent way.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use `size_t` when working with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that handles a data buffer of a variable size.
    We need an ability to access any address of memory provided by a target platform
    if needed. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `sizet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create a file called `sizet.cpp` in the `sizet` subdirectory.
    Copy the following code snippet into the `sizet.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials if
    needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `sizet` application executable file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we're emulating a function that stores arbitrary data in a
    file or a database. The function accepts a pointer to the data and data size.
    But what type should we use to represent the size? If we use an unsigned int in
    a 64-bit system, we're artificially limiting the capability of our function to
    handle only up to 4 GB of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such limitations, we use `size_t` as a data type for `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Most standard library APIs that accept indices and sizes also deal with `size_t`
    parameters. For example, the `memcpy` C function, which copies a chunk of data
    from the source buffer to the destination buffer, is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d7eb07-66fc-465b-b089-36506a38e18d.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the size of the pointer on the target system is 64-bit, despite
    the size of `int` being 32-bit. Using `size_t` in our program allows it to use
    all the memory of the embedded board.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard defines an `std::size_t` type. It is identical to the plain
    C `size_t`, except it is defined in the `std` namespace. Usage of `std::size_t`
    is preferable in your C++ code since it is part of the standard, but both `std::size_t`
    and `size_t` are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the endianness of the platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Endianness defines the order in which bytes that represent large numerical values
    are stored in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of endianness:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Big-endian**: The most significant byte is stored first. A 32-bit value, *0x01020304*, is
    stored at the `ptr` address, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Offset in memory (byte)** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| ptr | 0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| ptr + 1 | 0x02 |'
  prefs: []
  type: TYPE_TB
- en: '| ptr + 2 | ox03 |'
  prefs: []
  type: TYPE_TB
- en: '| ptr + 3 | 0x04 |'
  prefs: []
  type: TYPE_TB
- en: Examples of big-endian architectures include AVR32 and Motorola 68000.
  prefs: []
  type: TYPE_NORMAL
- en: '**Little-endian**: The least significant byte is stored first. A 32-bit value, *0x01020304*,
    is stored at the `ptr` address, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Offset in memory (byte)** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| ptr | 0x04 |'
  prefs: []
  type: TYPE_TB
- en: '| ptr + 1 | 0x03 |'
  prefs: []
  type: TYPE_TB
- en: '| ptr + 2 | 0x02 |'
  prefs: []
  type: TYPE_TB
- en: '| ptr + 3 | 0x01 |'
  prefs: []
  type: TYPE_TB
- en: The x86 architecture is little-endian.
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of endianness is especially essential when exchanging data with
    other systems. If a developer sends a 32-bit integer, say, 0x01020304, as it is,
    it may be read as 0x04030201 if the endianness of the receiver does not match
    the endianness of the sender. That is why data should be serialized.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to determine the endianness of our target
    system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a simple program that can detect the endianness of the target
    platform. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `endianness`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create a file called `loop.cpp` in the loop
    subdirectory. Copy the following code snippet into the `endianness.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the resulting executable binary to the target
    system. Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we utilized the capability of C's `union` function to map the
    representation of different data types to the same memory space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a union with two data fields – an array of 8-bit integers and a single
    32-bit integer. These data fields share the same memory, so changes that are made
    in one field are automatically reflected in another field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we assign the 32-bit integer field a specially crafted value, where each
    byte is known in advance and different from any of the others. We used bytes with
    values of one, two, three, and four to compose the target value.
  prefs: []
  type: TYPE_NORMAL
- en: When the value is assigned to the 32-bit field, `i`, it automatically rewrites
    all the fields into the `c` byte array field. Now, we can read the first element
    of the array, and, depending on what we read, we can infer the endianness of the
    hardware platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value is one, this means that the first byte contains the most significant
    byte, and hence the architecture is big-endian. Otherwise, it is little-endian.
    When we run the binary, it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dca32ea5-56bc-4cb2-9515-285e8f26f7a2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the program detected our system as little-endian. This technique
    can be used to detect the endianness in our runtime and adjust the application
    logic accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, most widespread platforms, such as x86 and **Acorn RISC Machine** (**ARM**),
    are little-endian. However, your code should never assume the endianness of the
    system implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to exchange data between applications running on the same system,
    it is safe to stick with the target platform's endianness. However, if your application
    needs to exchange data with other systems, either via network protocols or common
    data storage, consider converting your binary data into the common endianness.
  prefs: []
  type: TYPE_NORMAL
- en: Text-based data formats do not have issues with endianness. Use JSON format
    for platform-independent and human-readable representations of your data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Converting from a binary representation and back can be costly for
    your target embedded platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the endianness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While serialization libraries deal with the endianness under the hood, there
    are situations where developers might want to implement a lightweight communication
    protocol themselves.
  prefs: []
  type: TYPE_NORMAL
- en: While the C++ Standard Library does not provide functions for serialization,
    developers may utilize the fact that, in binary network protocols, byte order
    is defined and is always big-endian.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Standard Library provides a set of functions that can be used for conversion
    between the current platform (hardware) and big-endian (network) byte orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint32_t` htonl (`uint32_t` value): Converts `uint32_t` from hardware to network
    order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32_t` ntohl (`uint32_t` value): Converts `uint32_t` from network to hardware
    order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint16_t` htons (`uint16_t` value): Converts `uint16_t` from hardware to network
    order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint16_t` ntohl (`uint16_t` value): Converts `uint16_t` from network to hardware
    order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can use these functions to exchange binary data between applications
    running on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to encode strings so that they can be exchanged
    between two systems that may have the same or different endianness.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create two applications: a sender and a receiver.
    The sender will write data for the receiver, thus encoding them in a platform-independent
    way. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `enconv`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create and edit a file called `sender.cpp`
    in the `enconv` subdirectory. Include the required header files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a function that writes data to the file descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define a function that formats and writes messages, along with
    the main function that invokes it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create a file called `receiver.cpp` with the same set of includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code, which reads data from a file descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define a function that will read messages, along with the main function
    that invokes it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the two resulting executable binaries, `sender`
    and `receiver`, to the target system. Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `sender` binary and pass two command-line arguments: `Hello` and `Worlds`.
    This won''t generate any output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, run the receiver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, check the content of the file for both the `sender` and `receiver` that
    were used for data exchange. It will be in binary format, so we need to use the `xxd`
    tool to convert it into hexadecimal format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The file contains two strings, `hello` and `world`, prepended by their sizes.
    The `size` fields are always stored in big-endian byte order, independent of the architecture.
    This allows the sender and the receiver to be run on two different machines with
    different endianness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created two binaries, sender and receiver, that emulate data
    exchange between two hosts. We can't make any assumptions regarding their endianness,
    which is why the data exchange format has to be unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: The sender and receiver exchange data blocks of variable size. We encoded each
    block as a 4-byte integer in order to define the upcoming block size, followed
    by the block content.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the sender does not generate any output on the screen, it saves an encoded
    block of data in a file. When we run the receiver, it is able to read, decode,
    and display any information that was saved by the sender, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6bdbd6-7451-47f5-8926-0ceaa8b67dcc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While we keep the block size in the platform format locally, we need to convert
    it into a unified representation when sending it out. We use the `htonl` function
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can write the encoded size to the output stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The block''s content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The receiver, in turn, reads the size from the input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The size is encoded and cannot be used directly until the receiver converts
    it into a platform representation using the `ntohl` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Only after doing this, will it know the size of the block that follows and
    can allocate and read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since the serialized `data` size is always represented as big-endian, the read
    function doesn't need to make assumptions about the endianness of the platform
    where the data was written. It can deal with data coming from any processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processors read and write data not in bytes, but in memory words – chunks that
    match their data address size. 32-bit processors work with 32-bit words, 64-bit
    processors with 64-bit words, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reads and writes are most efficient when words are aligned – the data address
    is a multiple of the word size. For example, for 32-bit architectures, the address
    0x00000004 is aligned, while 0x00000005 is unaligned. On x86 platform, access
    to unaligned data is slower that to aligned. On ARM, however, access to unaligned
    data generates a hardware exception and lead to program termination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What is the output of the preceding code snippet? `sizeof(uint8_t)` is 1, while `sizeof(uint32_t)`
    is 4\. A developer may expect the size of the structure to be the sum of the individual
    sizes; however, the result highly depends on the target architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'For x86, the result is `8`. Let''s add one more `uint8_t` field before `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The result is still 8! The compiler optimizes the placement of the data fields
    within a structure according to the alignment rules by adding padding bytes. The
    rules are architecture-dependent, and the result may be different for other architectures.
    As a result, structures cannot be exchanged directly between two different systems
    without *serialization, *which will be explained in depth in [Chapter 8](24063f32-0b00-46d8-a65d-12e09b599ade.xhtml), *Communication
    and Serialization*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the rules that compilers implicitly
    apply to align data to write more memory-efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a program that allocates an array of structures and check how
    the order of the fields affects memory consumption. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `alignment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create a file called `alignment.cpp` in the
    loop subdirectory. Add the required header and define two data types, that is, `Category`
    and `ObjectMetadata1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define another data type, called `ObjectMetadata2`, along with
    the code that uses all of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials if
    needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our sample application, we defined two data structures, `ObjectMetadata1` and
    `ObjectMetadata2`, that will hold some metadata about file objects. We defined
    four fields that represent an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access flags**: A combination of bits representing a type of file access,
    such as read, write, or execute. All bit fields are packed into a single `uint8_t`
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size**: Object size as a 32-bit unsigned integer. It limits the supported
    object size to 4 GB, but it is sufficient for our goal to demonstrate the importance
    of proper data alignment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Owner ID**: A 32-bit integer that identifies a user in our system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category**: The category of the object. This can be a file, a directory,
    or a socket. Since we''ve only defined three categories, the `uint8_t` data type
    is sufficient to represent all of them. This is why we declare them using the `enum`
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Both `ObjectMetadata1` and `ObjectMetadata2` contain exactly the same fields;
    the only difference is how they are ordered within their structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we declare two pools of objects. Both pools contain 1,000 objects; `object_pool1`
    holds metadata in `ObjectMetadata1` structures, while `object_pool2` uses `ObjectMetadata2`
    structures. Now, let''s check the output of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9ba5450-5659-4cb2-a383-bd4285356c9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both object pools are identical in terms of functionality and performance.
    However, if we check how much memory they occupy, we can see a significant difference:
    `object_pool1` is 4 KB larger than `object_pool2`. Given the size of `object_pool2`
    is 12 KB, we wasted 33% of memory by not paying attention to data alignment. Be
    aware of alignment and padding when working on your data structures, as improper
    field ordering may lead to inefficient memory usage, as in the case of `object_pool2`.
    Use these simple rules to organize your data fields in order to keep them properly
    aligned:'
  prefs: []
  type: TYPE_NORMAL
- en: Group them by their size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order the groups from largest to smallest data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-aligned data structures are fast, memory-efficient, and do not require
    any additional code to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each hardware platform has its own alignment requirements, and some of them
    are tricky. You might need to consult the target platform compiler documentation
    and best practices to get the most out of the hardware. If your target platform
    is ARM, consider reading the ARM technical article at [http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15414.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka15414.html)
    on alignment expectations.
  prefs: []
  type: TYPE_NORMAL
- en: While the proper alignment of data fields within a structure can result in a
    more compact data representation, be aware of performance implications. Keeping
    data that's used together in the same memory region is called **data locality**
    and may significantly improve data access performance. Data elements that fit
    into the same cache line can be read or written much faster than elements that
    span the cache line boundaries. In many cases, it is preferable to get a performance
    gain at the cost of additional memory use. We will review this technique in more
    detail in the *Aligning data with cache lines* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Working with packed structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to define structures that do not have any
    padding bytes between their data members. This may significantly reduce the amount
    of memory that's used by your application if it works with a large number of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note, though, that this has a cost. Unaligned memory access is slower, which
    results in sub-optimal performance. For some architectures, unaligned access is
    forbidden, thus requiring the C++ compiler to generate much more code to access
    the data fields than for aligned access.
  prefs: []
  type: TYPE_NORMAL
- en: Although packing your structs may result in more efficient memory usage, avoid
    using this technique unless it's really necessary. It has too many implied limitations
    that may lead to obscure, hard-to-find issues in your application later.
  prefs: []
  type: TYPE_NORMAL
- en: Consider packed structures as transport encoding and only use them to store,
    load, or exchange data outside of your application. But, even in these cases,
    using a proper data serialize is a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this simple application, we will define an array of packed structures and
    see how this affects the amount of memory it requires. Follow these steps to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a copy of the `alignment` subdirectory.
    Name it `packed_alignment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `alignment.cpp` file by adding `__attribute__((packed))` to the
    definition of each structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we modified the code from the *Working with data alignment* recipe
    by adding a packed attribute to each struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This attribute instructs the compiler to not add padding bytes to the structs
    in order to conform to the alignment requirements of the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/521bd29e-1012-4d5a-b7fc-08a360183077.png)'
  prefs: []
  type: TYPE_IMG
- en: If the compiler does not add padding bytes, the order of the data fields becomes
    insignificant. Given that the `ObjectMetadata1` and `ObjectMetadata2` structs
    have exactly the same data fields, their size in packed form becomes identical.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GNU Compiler Collection` (**GCC**) gives developers lots of control over
    data layout using its attributes. You can find out about all of the supported
    attributes and their meaning by going to the [GCC Type Attributes](https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Type-Attributes.html#Type-Attributes) page.
  prefs: []
  type: TYPE_NORMAL
- en: Other compilers provide similar functionality, but their APIs might differ.
    For example, Microsoft compilers define the `#pragma pack` compiler directive
    to declare packed structures. More details can be found on the [Pragma Pack Reference](https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning data with cache lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to align data structures with cache lines.
    Data alignment can significantly affect the performance of your system, especially
    in the case of a multithreaded application that works in a multicore system.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, frequently accessing data that's used together is much faster if they
    live in the same cache line. If you program accesses variable A and then variable
    B consistently, a processor has to invalidate and reload its cache every time,
    if they are not in the same line.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you don't want to keep data that's used independently by different
    threads in the same cache line. If the same cache line is modified by different
    CPU cores, this requires cache synchronization, which affects the overall performance
    of a multithreaded application that uses shared data, since in this scenario memory
    access time significantly increases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create an application that allocates four buffers using four
    different methods to learn how to align statically and dynamically allocated memory.
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `cache_align`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create a file called `cache_align.cpp` in
    the `cache_align` subdirectory. Copy the following code snippet into the `cache_align.cpp` file
    to define the necessary constants and a function that detects the alignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define several buffers that are allocated in different ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code, which uses them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the loop subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Build the application and copy the resulting executable binary to the target system.
    Use the recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the target system's Terminal. Log in using your user credentials,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first code snippet, we created two pairs of memory buffers. In each pair,
    the first buffer is allocated to the stack, while the second one is allocated
    to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pair is created using the standard C++ technique. The static buffer
    on the stack is declared as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a dynamic buffer, we use the `new` C++ keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second pair, we create memory-aligned buffers. Declaring the static
    buffer on the stack is similar to the regular static buffer. We use an additional
    attribute, `alignas`, which was introduced in C++11 as a standardized and platform-independent
    way to align data in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This attribute requires an alignment size as a parameter. We want to have data
    aligned by the cache line boundaries. Depending on the platform, the cache line
    size may differ. The most common sizes are 32, 64, and 128 bytes. Using 128 bytes
    makes our buffer aligned for any of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no standard way to do the same for a dynamic buffer. To allocate memory
    on the heap, we use a C function called `posix_memalign`. This is available only
    in **Portable Operating System** **Interface** (**POSIX**) systems (mostly Unix-like),
    but this doesn''t require the support of the C++11 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`posix_memalign` is similar to `malloc`, but has three parameters instead of
    one. The second parameter is an alignment size, the same as it is for the align
    attribute. The third is the size of the memory to allocate. The first parameter
    is used to return a pointer to the allocated memory. Unlike `malloc`, `posix_memalign`
    may fail not only if it can''t allocate memory, but also if the alignment size
    passed to the function is not a power of two. `posix_memalign` returns an error
    code as its result value to help developers differentiate between these two cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define function overlap to calculate an unaligned part of a pointer by masking
    out all the aligned bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application, we can see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/007b6140-8b16-49a8-b066-43024d936300.png)'
  prefs: []
  type: TYPE_IMG
- en: The addresses of both buffers in the first pair have unaligned parts, while
    the addresses of the second pair are aligned – the unaligned part is zero. As
    a result, random access to the elements of the second pair of buffers is faster,
    because all of them are available in the cache at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CPU access data alignment is also crucial for efficiently mapping memory through
    a hardware address translation mechanism. Modern operating systems operate 4 KB
    memory blocks or pages to map a process' virtual address space to physical memory.
    Aligning data structures on 4 KB boundaries can lead to performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: The same technique we described in this recipe can be applied to align data
    to the memory page boundaries. Note, however, that `posix_memalign` may require
    twice as much memory than what was requested to fulfill this request. This memory
    overhead growth may be significant for larger alignment blocks.
  prefs: []
  type: TYPE_NORMAL
