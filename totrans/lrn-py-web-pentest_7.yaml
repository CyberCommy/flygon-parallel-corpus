- en: Intercepting HTTP Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about HTTP proxies and how we can intercept
    and manipulate HTTP requests. We are going to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP proxy anatomy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to mitmproxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating SQLi in mitmproxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP proxy anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn what an HTTP proxy is, why proxies are
    needed and used, and what types of HTTP proxy exist.
  prefs: []
  type: TYPE_NORMAL
- en: What is an HTTP proxy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An HTTP proxy is a server that acts as an intermediary between two communication
    parties. There is no direct communication between the client and the server. Instead,
    the client connects to the proxy and sends a request to it. Then the proxy will
    fetch the resources from the remote server, and finally return the response back
    to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Why do we need a proxy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a proxy for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privacy**: When we don''t want the service to know where we''re coming from
    or who we are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bypassing filters and censorship**: In countries where internet censorship
    is common and services are blocked, proxies can help us to get around this block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and eavesdropping**: Many companies implement proxies in order to
    log what employees are browsing and to eavesdrop on their communications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Companies who utilize caching use proxies in order to cache content
    and speed up communications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering and blocking**: Companies may directly want to block and limit
    what services an employee can visit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulating and modifying traffic**: As security testers, we are interested
    in intercepting communications between browsers and web applications in order
    to analyze and manipulate requests and responses in order to identify vulnerabilities
    and also debug problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of HTTP proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to HTTP proxies, there are a few different distinctions that
    we should make:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward proxies**: This is the most common example of proxies. It is the
    example we used in the explanation of what a proxy is. Forward proxies are the
    ones where the client sends a request to the proxy and the proxy fetches the resource
    on their behalf. In this case, the user chooses to, or is forced to, use a proxy
    in a company. The user knows that a proxy is being used, but the server doesn''t:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Reverse proxies**: These are proxies used by companies in order to hide behind
    network architecture or when they need to distribute the load between real servers.
    The user thinks they are connecting to the real server, but they are connecting
    to a proxy that will handle the request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Transparent proxies**: These intercept normal communications at the network
    layer without requiring any configuration on the client side. Usually, clients
    do not know they are using a transparent proxy. Transparent proxies usually do
    not modify requests and responses. They are commonly used by ISPs in order to
    provide faster responses to their customers. The proxy acts as a router or gateway:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Introduction to mitmproxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at why we work with mitmproxy, how
    to use the basic HTTP proxy feature in mitmproxy, and a brief introduction to
    mitmproxy inline scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Why mitmproxy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mitmproxy is an interactive console program that allows traffic flows to be
    intercepted, inspected, modified, and replayed. After researching for this section,
    I decided that the easiest and most complete way to learn about HTTP proxies in
    Python is by using mitmproxy. Any other attempt is more complex and limited than
    mitmproxy.
  prefs: []
  type: TYPE_NORMAL
- en: Mitmproxy is developed in Python and allows users to extend it via their inline
    scripts. It supports SSL out of the box, unlike other alternatives out there that
    support only HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how mitmproxy works using a simple example. If we go to the Terminal
    and type `mitmproxy`, we get an mitmproxy console listening at port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we change our browser settings to use proxy for HTTP connections, and we
    fire up a request such as [http://www.edge-security.com/](http://www.edge-security.com/),
    we will see all the requests in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click on the Open menu icon on the right-hand side of the browser and
    go to Preferences | Advanced | Network | Connection | Settings... | Manual proxy
    configuration. Set the HTTP Proxy as `127.0.0.1`  and the Port as `8080` and hit
    OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load [http://www.edge-security.com/](http://www.edge-security.com/)
    in the browser now; you can see the request history in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you select a request and press *Enter*, you will see the details for
    that request, the response, the headers, and the connection details. If you want
    to edit the request, press *E*. When done, you can send it by pressing *R*. This
    is the basic usage of mitmproxy.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to learn about all you can do with mitmproxy at [https://mitmproxy.org/](https://mitmproxy.org/).
    It is really well documented. There are multiple examples, and you will find all
    the necessary information about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to remind you how proxies work, in this particular case I have set up
    my browser to connect to mitmproxy on the localhost in port `8080`. The browser
    and the proxy are on the same machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Mitmproxy has a powerful scripting API that will let us access requests on
    the fly to manipulate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The mitm scripting API is event-driven and its script is simply a Python module
    that exposes a set of event methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the screenshot an example of a simple inline script that will
    add a new header to every HTTP response before it is returned to the client. That
    is all the code needed for the script. In the next section, we're going to learn
    how to write a script to manipulate requests in mitmproxy.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn more about inline scripts, and we're going
    to see an example of how to intercept requests and access their different parts
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Inline scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we defined a simple inline script in order to access
    the response from a request. Other parts of the communication, the mitmproxy,
    let us access the response via handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`: This is called once the script starts up, before any other events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientconnect` : This is called when a client initiates a connection to the
    proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A connection can correspond to multiple HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: '`request`: This is called when a client request has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serverconnect` : This is called when the proxy initiates a connection to the
    target server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseheaders`: This is called when the `responseheaders` for a server response
    have been received, but the response body has not been processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response`: This is called when a server response has been received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This is called when a flow error has occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientdisconnect`: This is called when a client disconnects from the proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`done`: This is called when the script shuts down after all other events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now that we know what handlers are available to us, let's look at an example
    where we access a request.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open the `mitm-0.py` script, located in the source code for `Section-7`, in
    the editor. This script will basically log every request that the proxy receives
    from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that this script is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have the handler for the `request`, with the mandatory first parameter called
    `context` and the second being `flow`. `flow`, as the name suggests, holds all
    the information about the communication. In the function, we open the `httplogs.txt`
    file, then we write `flow.request.url`, which is the URL requested by the client,
    and we finally close the `f` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Terminal in the `Section-7` directory. Type `mitmproxy
    -s mitm-0.py` and the mitmproxy console will come up. Then, we will open our browser
    and change the proxy configuration so it points to localhost `8080`. Click on
    the Open menu icon at the right-hand side of the browser and go to Preferences
    | Advanced | Network | Connection | Settings... | Manual proxy configuration.
    Set the Port as `8080`. Remove `localhost` and `127.0.0.1` from No Proxy for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load `www.scruffybank.com` in the browser. You can see all the requests
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s close the console and view the `httplogs.txt` file. We can open it with
    the editor. We can see all URLs requested in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Excellent work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a filter to log unique URLs to avoid storing duplicate URLs.
    Open the `mitm-1.py` file in the editor. In order to prevent duplicates, let''s
    create a global variable in the script called `history`; then, in the function,
    we just check that the URL is not in the history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If not present, we log it and then we add it to the `history`. Let's try it
    again and see if it works. First, we can remove the `httplogs.txt` file by right-clicking
    on it and selecting the Delete option. Run `mitmproxy -s mitm-1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the browser and open `www.scruffybank.com/login.php` and
    refresh it several times. Close the proxy console, and open the results again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great! No duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to access requests, let's see how we can add a query string
    parameter to every request. You may ask why. Well, we need to add certain parameters
    in a request in order to access certain information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `mitm-2.py` in the editor. Now, what we''re doing is getting the
    query string with `flow.request.get_query()`, and then we''re checking whether
    the query string has some content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If there is content, we add a new parameter called `isadmin` with the value
    `True`. And finally, we update the request query string with `flow.request.set_query(q)`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it in the command line. Let's launch `mitm-2.py` by typing `mitmproxy
    -s mitm-2.py`. In the browser, click on the Learn More link, which has parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the mitmproxy console, you can see that mitmproxy is adding the `isadmin`
    query string parameter with the `True` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, it won't do anything, but it is a warm-up for the next section
    where we're going to learn how to do something more complex such as testing SQLi
    for every parameter we see in the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Automating SQLi in mitmproxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how we can automate a test case for SQL
    injection in mitmproxy, creating an inline script that we use, the request handler,
    and some of the things we learned in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: SQLi process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The objective of this section is to create an inline script for an mitmproxy,
    which will allow us to test SQL injection in every URL that has a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So the process is that, for every URL that has parameters, we need to replace
    each parameter value with FUZZ while conserving the rest of the parameter values.
    We do this instead of replacing all the values with FUZZ at once. Then, we replace
    the FUZZ string in each URL with each value in the injections array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then execute the request a match to results content with MySQL errors in
    the errors array. Let''s see the code. Let''s go to the editor and open the `mitm-3.py` file.
    We have a few new imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`copy` from `deepcopy`, we need the highlighted code from the preceding code
    to copy objects and `urlparse`, which will help parse the URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the `request` handler function. Whenever there is a `query` string,
    it will call the `injector` function. The `injector` function has the arrays of
    `errors` and the `injections` array, similar to the ones we used in the SQLi scripts.
    Then, we open a file to log the results, and we use `urlparse` to get the `query`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: We need to split it with `&` and obtain the length as to how many parameters
    we have. Once we know the length, we do a `while` loop. For each iteration, we
    are going to do a `deepcopy` of the object `query` in order to preserve the original
    and work in a new copy. We then replace the value of the `qlen-1` parameter with
    the `FUZZ` string.
  prefs: []
  type: TYPE_NORMAL
- en: In `url_to_test`, we rebuild the URL. Then, we cycle through injections and
    replace `FUZZ` with the injection string. Finally, we check the resulting content and
    the content in the `errors` array. If we have a match, we write the logs and that's
    it. We have a basic SQL injection capability included in mitmproxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the Terminal, run `mitmproxy -s mitm-3.py`, then browse around
    in the application. Finally, go to `www.scruffybank.com/users.php`. We know that
    this page is vulnerable to SQLi from previous exercises, for example, by typing
    `1` in USER ID, and that should be enough for this demo. Close mitmproxy and check
    the `sqlinjection_results.txt file` log in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great, we can see which URL is vulnerable to SQLi. And we can see the parameter
    with the injection that generated the error. From this point, you can continue
    using the SQL injector script we created before. Now you have a basis on which
    to build your own script to cover your needs and test custom scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how mitmproxy works and learnt how to create inline scripts to
    extend the proxy and manipulate communication. We have learnt to add a vulnerability
    scanner function to the HTTP proxy to assist us during web application penetration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: We provided you with the basic knowledge and skills to help you in the future
    when creating your own custom tools. If you are starting your journey as a pentester,
    this will give you a solid foundation on which to build your custom tools for
    every situation, and will allow you to modify and extend existing tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the basics, you can continue your journey, improving your
    skills and putting them into practice. In order to do so, I recommend the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP WebGoat ([https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project](https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project)).
    This is a training course provided on the form of a VM. This training focuses
    on the OWASP top 10 vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pentester Lab ([https://www.pentesterlab.com/](https://www.pentesterlab.com/))
    provides vulnerable applications that can be used to test and understand vulnerabilities.
    Also, you can test your skills in other vulnerable apps, like the ones you can
    find in the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP-WADP ([https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project](https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project)),
    a collection of vulnerable apps to provide environments close to reality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that is it. Thank you very much for choosing this book, and I hope you have
    enjoyed learning about web application testing with Python.
  prefs: []
  type: TYPE_NORMAL
