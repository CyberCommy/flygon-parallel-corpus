- en: '[*Chapter 10*](B17385_10_Final_PD_ePub.xhtml#_idTextAnchor129): Exploring Skaffold
    Alternatives, Best Practices, and Pitfalls'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how you can create a CI/CD pipeline for
    a Spring Boot application using GitHub Actions and Skaffold. In this chapter,
    we will start by looking at other tools available on the market that provide similar
    functionalities as Skaffold. We will learn about tips and tricks that developers
    can adhere to while developing cloud-native Kubernetes applications with Skaffold.
    We will conclude by understanding Skaffold pitfalls that developers can typically
    avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Skaffold with other alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Skaffold best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding Skaffold pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future roadmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of tools other
    than Skaffold for improving the developer experience with Kubernetes. You will
    also learn about Skaffold best practices that you can use for your development
    workflow and some common pitfalls that can be avoided in your development life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Skaffold with other alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will compare Skaffold with other alternative tools that
    address similar problems that Skaffold solves, that is, improving the developer
    experience with Kubernetes. However, there may be use cases where Skaffold may
    not be the best tool for the job, so we will look into tools other than Skaffold
    if your use case is complex in the next section. We will also look at the features
    that these Kubernetes development tools provide in comparison with Skaffold. Let's
    begin!
  prefs: []
  type: TYPE_NORMAL
- en: Telepresence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Telepresence** ([https://www.telepresence.io/](https://www.telepresence.io/))
    is a tool developed by Ambassador Labs. It''s a Cloud Native Computing Foundation
    sandbox project. Its goal is to improve the developer experience with Kubernetes.
    Telepresence allows you to run a single service locally while connecting that
    service to a remote Kubernetes cluster. You can read more about it here: [https://www.telepresence.io/about/](https://www.telepresence.io/about/).'
  prefs: []
  type: TYPE_NORMAL
- en: With Telepresence, you can develop and debug a service locally as part of the
    cluster. You don't have to publish and deploy new artifacts in the Kubernetes
    cluster continuously. Telepresence doesn't require a local Kubernetes cluster
    in comparison with Skaffold. It runs a pod as a placeholder for your application
    in the remote cluster, and incoming traffic is routed to the container running
    on your local workstation. When a developer changes the application code, it will
    be reflected in your remote cluster without deploying a new container.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that you only need compute resources, namely, CPU and memory,
    to run your services locally as you are directly working with a remote cluster.
    Moreover, you don't have to set up and run a local Kubernetes cluster, such as
    minikube or Docker Desktop. It is helpful in cases where you have, say, five to
    six microservices running and your application must interact with them. In contrast,
    Skaffold is more of a complete solution packaged into one thing addressing your
    local development needs and CI/CD workflows. But let's suppose your application
    needs to interact with many microservices. In that case, it gets tricky as it
    would be difficult to run all the instances locally because of resource constraints,
    and you may end up mocking some of the services that may not replicate your actual
    production behavior. This is where Telepresence can help with its remote development
    capabilities from your laptop and with minimal resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: There are some disadvantages, such as it has some known issues with volume mount
    for the Windows OS and needs a high-speed network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Tilt.dev
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tilt** ([https://tilt.dev/](https://tilt.dev/)) is an open source tool for
    improving the developer experience with Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Skaffold, we use the `skaffold.yaml` configuration file to define, build,
    and deploy; and similarly, in Tilt, we use a Tiltfile for configuration. Tiltfiles
    are written in a dialect of Python called **Starlark**. Check out the API reference
    here: [https://docs.tilt.dev/api.html](https://docs.tilt.dev/api.html). The following
    is a sample Tiltfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can run the `tilt run` command. Tilt is not just a CLI tool in comparison
    with Skaffold. Tilt also provides a neat UI where you can view each of your service's
    health status, their build, and runtime logs. While Skaffold is an open source
    project with no vendor support, Tilt does offer vendor support with its enterprise
    edition.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of Tilt is that you have to get familiar with its Starlark Python
    syntax language, which is required to write the Tiltfile, while Skaffold uses
    the `skaffold.yaml` configuration file as the YAML syntax file. But if you work
    with Kubernetes manifests, then this is not something new and most developers
    are already familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift Do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing an application with Kubernetes or **Platform-as-a-Service** (**PaaS**)
    offerings such as OpenShift is hard if you are not using the correct tools throughout
    your development. In the case of OpenShift, it already has a CLI tool, **oc**,
    but unfortunately, it is more focused on helping operations folks and is not very
    developer-friendly. The oc CLI requires you to know and understand concepts related
    to OpenShift, such as deployment and build configurations to name a few, which,
    as a developer, you might not really be interested in knowing. The Red Hat team
    realized this issue and developed a new CLI called **OpenShift Do** (**odo**),
    which is more targeted toward developers. It also helps in improving the developer
    experience while developing cloud-native applications deployed to Kubernetes or
    OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of its features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop faster and accelerate the inner development loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live feedback with the `odo watch` command. If you have worked with Skaffold,
    then it is quite similar to the `skaffold dev` command. The odo CLI uses developer-focused
    concepts such as **projects**, **applications**, and **components**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a completely CLI client-based tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenShift odo is very specific to OpenShift itself; even though the documentation
    says that it works with vanilla Kubernetes distributions. There is a lack of documentation
    and practical examples to use odo with minikube or other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Oketo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Oketo** ([https://okteto.com/](https://okteto.com/)) is a CLI tool that takes
    an approach that is completely different than Skaffold. Instead of automating
    your inner development loop in your local workstation, Oketo moves the inner development
    loop to the cluster itself. You define your development environment in a YAML
    manifest file, `oketo.yaml`, and then use `oketo init` and `oketo up` to get up
    and running with your development environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the highlighted features of Oketo:'
  prefs: []
  type: TYPE_NORMAL
- en: File synchronization between the local and remote Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single binary that works across different OSes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get a remote terminal in your container development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot reload your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works with local and remote Kubernetes clusters, Helm, and serverless functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port forwarding in both directions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No building, pushing, or deploying is required as you develop directly on your
    cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to install Docker or Kubernetes on your workstation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even runtimes (JRE, npm, Python) are not required as everything is inside a
    Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garden
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Garden** ([https://garden.io/](https://garden.io/)) follows the same philosophy
    as Oketo of deploying to a remote cluster instead of doing the setup on your local
    system. Garden is an open source tool that runs Kubernetes applications in a remote
    cluster for development, automated testing, manual testing, and review.'
  prefs: []
  type: TYPE_NORMAL
- en: With Garden, you can start by using CLI helper commands such as `garden create
    project`. You will manage the Garden configuration through a YAML configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key elements of the Garden YAML configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules**: In modules, you specify how to build your containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: In services, you specify how to run your containers on Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests**: In tests, you specify unit and integration tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the features that Garden provides:'
  prefs: []
  type: TYPE_NORMAL
- en: It automatically redeploys the application to the remote cluster when the source
    code is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports multi-module and multi-service operations (tree of dependencies).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a graphical dashboard for dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to run tasks (for example, database migrations as part of the build
    flow).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports Helm and OpenFass deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports hot reload features where source code is sent directly to running
    containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to stream container logs to your terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports file watching and hot reloading of code for remote clusters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garden has a more complex setup than Skaffold, and it takes a while to get familiar
    with its concepts, so there is a steep learning curve involved. With Skaffold,
    you work with familiar build and deploy tools, and it's easy to get started with
    it. It might also be overkill to use Garden for small applications due to its
    inherent complexities. Garden is commercial open source, so some of its features
    are paid compared to Skaffold, which is entirely open source.
  prefs: []
  type: TYPE_NORMAL
- en: docker-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker-compose` is a tool that is primarily used for local development with
    containers. It allows you to run multiple containers locally and mimic how an
    application would look when deployed to Kubernetes. Docker needs to be installed
    on the workstation to get started with it. While `docker-compose` may give some
    developers a false impression of running their application in a Kubernetes environment
    such as minikube, in reality, it is nothing like running it in a Kubernetes cluster.
    It also means that because your application works on `docker-compose`, it will
    not work or behave similarly when deployed to the Kubernetes cluster in production.
    While we know that containers solve the problem of *works on my machine*, with
    `docker-compose`, we introduce a new problem, that is, *works on my docker-compose
    setup*.'
  prefs: []
  type: TYPE_NORMAL
- en: It may be tempting to use `docker-compose` as a replacement to ease the inner
    development loop of cloud applications, but as explained earlier, your local and
    production environment will not be the same. It would be hard to debug any environment
    because of this difference, while with Skaffold, you get to use the exact same
    stack for your local and remote build and deployment. If, for some reason, you
    are stuck with the `docker-compose` setup, you can even pair it with Skaffold.
    Skaffold internally uses Kompose ([https://kompose.io/](https://kompose.io/))
    to convert `docker-compose.yaml` into Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to use your existing `docker-compose.yaml`
    file with Skaffold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have looked at Kubernetes development tools other than Skaffold,
    helping developers develop faster and get quick feedback in their inner development
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about some best practices to apply to our
    existing or new workflow with Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Skaffold best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about Skaffold best practices that you, as a
    developer, can take advantage of, to either speed up your deployment in the inner
    or outer development loop or use some flags to make things easier while using
    Skaffold. Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'While working with multiple microservices applications deployed to Kubernetes,
    sometimes, it''s challenging to create a single `skaffold.yaml` configuration
    file for each application. In those common cases, you can create `skaffold.yaml`
    scoped for each application, and then run the `skaffold dev` or `run` command
    independently for each application. You can even iterate both the applications
    together in a single Skaffold session. Let''s assume we have a frontend app and
    a backend app for both of them; your single `skaffold.yaml` file should look like
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you are bootstrapping your project with Skaffold and you don't have Kubernetes
    manifests, you can pass the `--generate-manifests` flag with the `skaffold init`
    command to generate basic Kubernetes manifests for your project.
  prefs: []
  type: TYPE_NORMAL
- en: It would be best if you always use the `default-repo` functionality with Skaffold.
    If you are using `default-repo`, you don't have to manually edit the YAML files
    as Skaffold can prefix the image names with the container image registry specified
    by you. So, instead of writing `gcr.io/myproject/imagename`, you can enter the
    image name in the `skaffold.yaml` configuration file. Another advantage is that
    you can share your `skaffold.yaml` file easily with other teams as they don't
    have to manually edit the YAML file if they use a different container image registry.
    So, basically, you don't have to hardcode the container image registry names inside
    your `skaffold.yaml` configuration files by using the `default-repo` functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can utilize the `default-repo` functionality in the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a. By passing the `--default-repo` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'b. By passing the `SKAFFOLD_DEFAULT_REPO` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'c. By setting Skaffold''s global config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It gets tricky to know the actual issue when you run into an issue with the
    Skaffold command. In some cases, you may need more information than what Skaffold
    typically displays while streaming logs. For such cases, you can use the `–v`
    `or –verbosity` flag to use a specific log level. For example, you use `skaffold
    dev –v info` to view information-level logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skaffold supports the following log levels, and the default is `warn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fatal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a faster build, you can take advantage of the concurrency flag by setting
    it to `0`. The default value is `0`, meaning no limits on the number of parallel
    builds so all your builds are done in parallel. Only in the case of local build
    concurrency will the value default to `1`, which means the build will be done
    sequentially to avoid any side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using Jib to build and push container images, then you can use the
    special sync support using the auto configuration. You can enable it by using
    the `sync:` option, as mentioned in the following `skaffold.yaml` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this option, Jib can sync your class files, resource files, and Jib's *extra
    directories* files to a container running locally or remotely. You don't have
    to rebuild, redeploy, or restart the pod for each change in your inner development
    loop. However, for this to work with your Spring Boot application, you need to
    have the `spring-boot-devtools` dependency in your `pom.xml` file for your Maven
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold also supports Cloud Native Buildpacks to build your container images
    and, similar to Jib, it also supports the `sync` option to automatically rebuild
    and relaunch your application when changes are made to a certain type of file.
    It supports the following type of source files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go**: `*.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java**: `*.java`, `*.kt`, `*.scala`, `*.groovy`, `*.clj`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js**: `*.js`, `*.mjs`, `*.coffee`, `*.litcoffee`, `*.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have learned some best practices that we can apply to develop
    efficiently and accelerate the development loop even faster with Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at some of the common Skaffold traps
    that we, as developers, should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Skaffold pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we have used various features provided by Skaffold. Now
    let''s discuss some common Skaffold pitfalls that we, as developers, should understand
    and try to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: Skaffold requires that either you have some local or remote Kubernetes setup
    so in comparison with other tools that we discussed in the previous section Skaffold
    doesn't reduce the time required to set up your development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Skaffold, in most cases, you work with some local Kubernetes such as minikube
    or Docker Desktop and you cannot replicate your entire production-like setup with
    them because of their limitations. This leaves space for integration issues that
    you may not see on local systems but could pop up in higher environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, more hardware resources are wasted on your machine with Skaffold.
    For example, if you need to run, let's say, 10 microservices, then it becomes
    challenging as you're limited by resources on your laptop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skaffold has built-in support for integrating with debuggers via the (beta)
    `skaffold debug` command. With this debugging option, Skaffold automatically configures
    the application runtime for remote debugging. It is a great feature, but using
    debuggers in a microservices environment is tricky at best. It gets even tougher
    working with remote clusters. Use it judiciously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skaffold has no web UI. While we discussed many tools in the previous section
    that provide a UI for a better experience, I would not cry about it. It is more
    of a personal preference as some people tend to prefer a UI and some a CLI. If
    you are more of a UI person, then you may not get along with Skaffold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skaffold is excellent for local development and testing in your inner development
    loop. Even though it is marketed as a complete CI/CD solution for some use cases,
    it may not be the best tool for the job. For example, if we want to scale to production
    or pre-production use cases, it is better to use dedicated tools for that such
    as **Spinnaker pipelines** ([https://spinnaker.io/](https://spinnaker.io/)) or
    **Argo Rollouts** ([https://argoproj.github.io/argo-rollouts/](https://argoproj.github.io/argo-rollouts/)).
    These tools Spinnaker/Agro Rollouts provide some advantages over Skaffold. Let''s
    see them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of Spinnaker/Agro Rollouts, both can support sophisticated/complex
    deployment strategies. You can define deployment strategies such as canary and
    blue/green deployment, stuff like that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spinnaker allows multi-cluster deployments. Also, you can configure easy UI-based
    deployment to multiple clusters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spinnaker has great visualization. It provides a rich UI that displays any deployment
    or pod status across clusters, regions, namespace, and cloud providers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we have covered Skaffold pitfalls that you should look out
    for before deciding to go ahead with it for your Kubernetes workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Future roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The community primarily drives the Skaffold roadmap since it is an open source
    tool, and the team of engineers from Google makes the final call. Google developers
    also propose exciting new features that would enhance the user experience with
    Skaffold on top of the changes requested by the community.
  prefs: []
  type: TYPE_NORMAL
- en: However, a roadmap should not be considered a list of promises delivered no
    matter what. It is a sort of wish list that the Skaffold engineering team thinks
    could be worth investing their time on. The primary motivation behind the roadmap
    is to get feedback from the community around the features they want to see in
    Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the Skaffold roadmap for 2021 by accessing the [https://github.com/GoogleContainerTools/skaffold/blob/master/ROADMAP.md#2021-roadmap](https://github.com/GoogleContainerTools/skaffold/blob/master/ROADMAP.md#2021-roadmap)  URL.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tooling around Kubernetes developer tools has improved significantly in recent
    years. The primary motivation for that is the increased adoption of Kubernetes
    in the industry. Modern age developers want a tool that increases their productivity
    while developing applications for the cloud. Skaffold dramatically enhances the
    productivity of developers building and deploying Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: Many tools internally use Skaffold, such as Jenkins X and Cloud Code, to improve
    the overall developer experience with Kubernetes. In contrast to Jenkins X, which
    uses Skaffold to build and push the image in the pipeline, Cloud Code is entirely
    built around Skaffold and its supported tools to provide a seamless onboarding
    experience for Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I would like to conclude by saying that Skaffold simplifies Kubernetes
    development, and in my opinion, it is doing a good job. It provides flexibility
    and extensibility on what kind of integrations it should be used with. Its extensible
    and pluggable architecture allows developers to choose an appropriate tool for
    each step involved in building and deploying the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by comparing Skaffold with other tools such as Tilt,
    Telepresence, Garden, Oketo, `docker-compose`, and OpenShift odo. These tools,
    in principle, try to provide a solution to a similar problem that Skaffold addresses.
    Then, we covered features that these tools offer in comparison to Skaffold. We
    also looked at some best practices that we can use with Skaffold for a better
    developer experience. Finally, we concluded by explaining some pitfalls related
    to Skaffold, which you should watch out for if your use case is more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: You have discovered how you can take advantage of Skaffold by following some
    of the best practices that we have tried to explain. You are now in a better position
    to decide whether Skaffold fulfills your use case, or whether you need to consider
    other options we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have reached the end of the journey and I hope you are encouraged
    to try out and explore a lot of Skaffold!
  prefs: []
  type: TYPE_NORMAL
