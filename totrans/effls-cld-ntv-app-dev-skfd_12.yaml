- en: '[*Chapter 9*](B17385_09_Final_PD_ePub.xhtml#_idTextAnchor116): Creating a Production-Ready
    CI/CD Pipeline with Skaffold'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to deploy a Spring Boot application
    to Google Cloud Platform using Skaffold. In this chapter, the focus will be on
    introducing you to GitHub Actions and their related concepts. We will also demonstrate
    how we can create a production-ready **continuous integration (CI)** and **continuous
    deployment (CD)** pipeline of a Spring Boot application using Skaffold and GitHub
    Actions. In the last section, we will get familiarized with GitOps concepts and
    learn about creating a continuous delivery pipeline for Kubernetes applications
    using Argo CD and Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GitHub Action workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CI/CD pipeline with GitHub Actions and Skaffold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a GitOps workflow with Argo CD and Skaffold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how you can
    create an effective CI/CD pipeline using GitHub Actions and Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code from the GitHub repository can be found at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold/tree/main/Chapter07](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Actions allows you to build, test, and deploy your workloads from your
    GitHub repository GitHub Actions is event-driven; for example, when someone creates
    a pull request, opens an issue, does a deployment, and so on. The specific actions
    are triggered based upon the events. You can even create your own GitHub Actions
    to customize the workflow based upon your use case. There is a great marketplace
    available too, at https://github.com/marketplace, from where you can integrate
    existing GitHub Actions into your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions uses a YAML syntax file to define events, jobs, actions, and
    commands. In the following diagram, you can see a complete list of GitHub Actions
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – GitHub Actions components'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – GitHub Actions components
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the GitHub components in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workflow**: This is used to build, test, package, release, or deploy the
    project on GitHub. A workflow consists of jobs and is triggered by events. The
    workflow is defined in a YAML syntax file available in your GitHub repository
    inside the `.github/workflows` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: This represents an activity that triggers a workflow; for example,
    pushing changes to a branch or creating a pull request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jobs**: This consists of steps that are executed on a runner. It uses steps
    to control the order in which actions are performed. You can run multiple jobs
    for your workflow. They can be run in parallel or sequentially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**: These represent an action, that is, checking out source code or
    shell command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: These represent commands that you would like to run, such as checking
    out your source code or downloading JDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runners**: This is a server hosted on GitHub that has the runner application
    installed. You can host your own runner or use the one provided by GitHub. Your
    jobs defined in the workflow are executed on the runner machine. It sends the
    results, progress, and logs back to the GitHub repository. GitHub-hosted runners
    support Ubuntu Linux, Microsoft Windows, and macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have learned details about GitHub Action components. In the next section,
    we will create a GitHub Action workflow for a Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub Actions workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a workflow that will build a Spring Boot Java
    application with GitHub Actions. This workflow will build a Spring Boot application
    using the `mvn clean install` Maven build tool command. The following is an example
    of a workflow file of building a Java project with Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation of the workflow YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: In the workflow YAML file, we have subscribed to a `push` and `pull` request
    event. So whenever a `pull` request is raised or change is pushed for the main
    branch, this workflow will trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then inside the `jobs` section, first we have specified that the job will run
    on a `ubuntu` Linux operating system runner hosted by GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `steps`, we have defined the actions that need to be executed for this workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we are checking out the source code on the runner using `actions/checkout@v2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we are installing dependencies such as Java. We doing that using the `AdoptOpenJDK/install-jdk@v1`
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last and final step, we are building a Java project using the `mvn clean
    install` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see this workflow in action. So next, we will create this workflow in
    our GitHub repository and trigger the workflow by pushing changes to the main
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the Spring Boot application we created in [*Chapter 7*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092),
    *Building and Deploying a Spring Boot Application with the Cloud Code Plugin*,
    for this demonstration. I have already explained the application in detail so
    I will not be explaining it again here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create the workflow YAML file inside your GitHub repository.
    This can be done by navigating to the **Actions** tab in your GitHub repository
    and clicking on the **set up a workflow yourself** link as shown in the following
    screenshot:![Figure 9.2 – Getting started with GitHub Actions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Getting started with GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next screen, paste the content of the workflow YAML file that we discussed
    earlier. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Creating a workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Creating a workflow
  prefs: []
  type: TYPE_NORMAL
- en: After you click on the **Start commit** button, a new commit message window
    will open where you can enter the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: Then click on **Commit new file** to add the workflow file to the GitHub repository:![Figure
    9.4 – Committing the workflow file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.4_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Committing the workflow file
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the repository, now you can see that there is a `.github/workflows`
    directory and inside that directory, we have the `main.yml` workflow file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – GitHub workflow file added to your repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.5_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – GitHub workflow file added to your repository
  prefs: []
  type: TYPE_NORMAL
- en: 'This also creates a commit and pushes a change to the repository, which triggers
    the workflow. In the following screenshot, you can see the workflow is triggered
    and in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Executing the GitHub workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.6_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Executing the GitHub workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the pipeline is green and the triggered
    workflow has completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – GitHub workflow completed successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.7_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – GitHub workflow completed successfully
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully built a Spring Boot application using GitHub Actions. The
    next section will use Skaffold and GitHub Actions to create a CI/CD pipeline for
    a Spring Boot application from the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CI/CD pipeline with GitHub Actions and Skaffold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI and CD are among the main pillars of the DevOps life cycle. As the name suggests,
    **continuous integration** (**CI**) is a software development practice where developers
    commit the code to a version control system several times a day. In **continuous
    deployment** (**CD**), software functionalities are delivered frequently through
    automated deployments, and there is no manual intervention or approval in this
    process. Only a failed test would halt your deployment to production. Another
    thing that is often confused with continuous deployment is continuous delivery,
    but they are different in reality. In continuous delivery, the main focus is on
    release and the release strategy and doing the actual deployment to production
    with approval. It is often termed **single-click deployment**.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you will have developed some understanding of how GitHub Actions is
    event-driven and can automate your software development tasks. You will have also
    learned that you can trigger your entire CI/CD pipeline from your GitHub repository
    using GitHub Actions based upon certain events such as Git push or creating a
    pull request on a particular branch.
  prefs: []
  type: TYPE_NORMAL
- en: This section will focus on deploying a Spring Boot application to Google Kubernetes
    Engine using Skaffold and GitHub Actions. The workflow will closely mimic how
    we typically do the deployment in production using a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed further with this task, there are a few prerequisites that
    we should be aware of. The following are some of the highlighted prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please take a note of the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to create a new Google Cloud Project (or select an existing project).
    This part is already done in [*Chapter 8*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099),
    *Deploying a Spring Boot Microservice to Google Cloud Platform Using Skaffold*,
    and we will use the same project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please make sure that you enable the **Container Registry** and **Kubernetes
    Engine** APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also have to create a new **Google Kubernetes Engine** (**GKE**) cluster
    or select an existing GKE cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not done already, you also need to create a JSON service account key for
    the service account and add Kubernetes Engine Developer and Storage Admin roles.
    Service account keys are a safe way of accessing your cloud resources from outside.
    To establish the identity of a service account, a public/private key pair is used.
    The public key is stored in Google Cloud and the private key is available to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a service account key, click on **IAM & Admin** on the left-hand
    side navigation bar on the Google Cloud Console. Click on **Service accounts**
    and then you will see the following screen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.8  – Service account of your GCP project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.8_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8  – Service account of your GCP project
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click the email address of the service account and select **Keys** from
    the right-hand side tab. Click on **ADD KEY** and select **Create new key,** as
    shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Adding a key to your service account'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.9_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Adding a key to your service account
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose **JSON** for **Key type** and click on **CREATE**. It will download
    the keys to your system, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Selecting the key type for your service account'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.10_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Selecting the key type for your service account
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add the following Cloud IAM roles to your service account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. **Kubernetes Engine Developer**: This role will allow you to deploy to GKE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. **Storage Admin**: This role will allow you to publish the container image
    to the Google Container registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Adding roles for your service account'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.11_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Adding roles for your service account
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following secrets to your GitHub repository''s secrets. You can add
    GitHub repository secrets by navigating to the **Settings** tab and then clicking
    on **Secrets** on the left-hand side navigation bar. There, click on **New repository
    secret** and add the following secrets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. **PROJECT_ID**: The Google Cloud project ID'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. **SERVICE_ACCOUNT_KEY**: The content of the service account JSON file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Adding secrets to your GitHub repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.12_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Adding secrets to your GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have completed all the prerequisites. In the next section, we
    will create a CI/CD pipeline using GitHub Actions and Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CI/CD workflow with GitHub Actions and Skaffold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will create a production-ready CI/CD pipeline using Skaffold
    and GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure demonstrates the CI/CD workflow with Skaffold and GitHub
    Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – CI/CD workflow with Skaffold'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.13_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – CI/CD workflow with Skaffold
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following workflow YAML file. Here, I have explained the workflow
    YAML file with comments in each step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the name and event of the workflow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we pass GitHub secrets as environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the job that runs on an Ubuntu Linux runner hosted by GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While defining steps, the first step is to check out source code and then install
    Java 16:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we set up the `gcloud` CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, download `kubectl` for post-deployment verification and `skaffold` for
    continuous delivery:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, cache artifacts such as dependencies to improve workflow execution time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure docker to use the gcloud command-line tool as a credential helper
    for authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the GKE credentials and deploy to the cluster using the `skaffold run`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, build and deploy to GKE using `skaffold run` and do verification with
    `kubectl get all` post deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can use this workflow YAML file in your project and replace the secrets
    with your values. If you have placed the `skaffold.yaml` file in the root directory
    of your repository then it's OK, otherwise you can pass the `–filename` flag with
    the `skaffold run` command to point to the Skaffold configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the workflow is executed successfully then you should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 –  Successful build and deployment to GKE with Skaffold'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.14_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 –  Successful build and deployment to GKE with Skaffold
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have successfully built and deployed a Spring Boot application
    to a remote cluster with a customized CI/CD pipeline from the GitHub repository
    using Skaffold and GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we implement the workflow with Argo CD and Skaffold while
    understanding what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a GitOps workflow with Argo CD and Skaffold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B17385_04_Final_PD_ePub.xhtml#_idTextAnchor044), *Understanding
    Skaffold's Features and Architecture*, while explaining Skaffold features, we
    briefly talked about how we can use the `skaffold render` and `skaffold apply`
    commands to create a GitOps style continuous delivery workflow with Skaffold.
    In this section, we will implement a GitOps workflow using Skaffold and Argo CD.
    But first, let's understand what GitOps is and its benefit.
  prefs: []
  type: TYPE_NORMAL
- en: What is GitOps, and what are its benefits?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word *GitOps* was coined by a company named Weaveworks. The idea behind
    GitOps is to consider Git as a single source of truth for your application and
    declarative infrastructure. Using Git to manage your declarative infrastructure
    makes it easy for developers because they interact with Git daily. Once you add
    configuration inside Git, you get the benefits of version control, such as reviewing
    changes using pull requests, audit, and compliance.
  prefs: []
  type: TYPE_NORMAL
- en: With GitOps, we create automated pipelines to roll out changes to your infrastructure
    when someone pushes changes to a Git repository. Then we use GitOps tools to compare
    the actual production state of your application with what you have defined under
    source control. Then it also tells you when your cluster doesn't match what you
    have in production and automatically or manually reconciles it with the desired
    state. This is true CD.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily roll back your changes from Kubernetes by doing a simple `git`
    `revert`. In disaster scenarios or if someone accidentally nuked your entire Kubernetes
    cluster, we could quickly reproduce your whole cluster infrastructure from Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s understand a few benefits of GitOps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using GitOps, the team is shipping 30-100 changes per day to production. Of
    course, you need to use deployment strategies such as blue-green and canary to
    validate your changes before making them available to all the users. The overall
    benefit is an increase in developer productivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get a better developer experience with GitOps as developers are pushing
    code and not containers. Moreover, they use familiar tools such as Git and don't
    need to know about the internals of Kubernetes (that is, `kubectl` commands).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By putting declarative infrastructure as code in the Git repository, you automatically
    get benefits such as audit trail for your cluster, such as who did what and when.
    It further ensures the compliance and stability of your Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also recover your cluster faster, in case of a disaster, from hours
    to minutes because your entire system is described in Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application code is already on Git, and with GitOps, your operation tasks
    are part of the same end-to-end workflows. You have a consistent Git workflow
    across your entire organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's only fair that we also cover some details about Argo CD so that it's easier
    to understand the later part where we implement a GitOps workflow using Skaffold
    and Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: What is Argo CD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As per the official documentation of **Argo CD**, [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/),
    it is a declarative, GitOps continuous delivery tool for Kubernetes. In the previous
    section, we used the term *GitOps tool* that can compare and sync the application
    state if it deviates from what we have defined in the Git repository, so it is
    safe to say that Argo CD is the tool that handles this automation. Kubernetes
    introduced us to the concept of control loops through which Kubernetes checks
    whether the number of replicas running matches with the desired number of replicas.
    Argo CD leverages the same **Kubernetes** (**K8s**) capabilities, and its core
    component is `argocd-application-controller`, which is basically a Kubernetes
    controller. It monitors the state of your application and adjusts the cluster
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: And now it's time to learn about GitOps by implementing it with Skaffold and
    Argo CD on Google Kubernetes Engine. Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery with Argo CD and Skaffold on GKE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, we need to make sure that we have met the following prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to install `kubectl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current Kubernetes context is set to a remote GKE cluster. You can verify
    the current context with the `kubectl config current-context` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can run this demonstration on the local Kubernetes cluster but, ideally,
    you would be running it with a managed Kubernetes service such as GKE. Let''s
    begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will install Argo CD on GKE using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We created a separate namespace, `argocd,` and all Argo CD-related components
    will be part of it. We can verify the installation by navigating to the workloads
    section under GKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that Argo CD stateful set components,
    that is, `argocd-application-controller`, and deployment components such as `argocd-server`
    are up and running on GKE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 –  Argo CD Kubernetes resources deployed to GKE'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.15_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 –  Argo CD Kubernetes resources deployed to GKE
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can install the Argo CD CLI. This is an optional step as we will be
    using the Argo CD UI instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to expose the Argo CD API server as by default it is not exposed
    for external access. We can run the following command to change the service type
    to `LoadBalancer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see that the service type has changed
    to `External load balancer` and we will access the Argo CD GUI using that IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 –  Argo CD API server exposed as LoadBalancer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.16_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 –  Argo CD API server exposed as LoadBalancer
  prefs: []
  type: TYPE_NORMAL
- en: You can even use ingress or `kubectl` port forwarding for accessing the Argo
    CD API server without exposing the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now access the Argo CD GUI using the default admin user name and get
    the password using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Argo CD login screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.17_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – Argo CD login screen
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in, click the **+ NEW APP** button, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Create application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.18_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Create application
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next screen, enter your application name, choose the default project,
    and set **SYNC POLICY** to **Automatic**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Argo CD application onboarding'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.19_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – Argo CD application onboarding
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the source Git repository URL. Provide the path for Kubernetes manifests
    inside the Git repository. Argo CD polls your Git repository every 3 minutes to
    apply updated manifests to your Kubernetes cluster. You can avoid this delay by
    setting up a webhook event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Providing application Git repository details to Argo CD'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.20_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – Providing application Git repository details to Argo CD
  prefs: []
  type: TYPE_NORMAL
- en: 'For **DESTINATION**, set cluster to in-cluster and **Namespace** to **default,**
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 –  Providing destination cluster details to Argo CD'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.21_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 –  Providing destination cluster details to Argo CD
  prefs: []
  type: TYPE_NORMAL
- en: 'After filling out the required information, click **CREATE** at the top of
    the UI to create the application. After clicking on the **CREATE** button, the
    Kubernetes manifests available in the Git repository at the path `Chapter09/gitops`
    are retrieved, and Argo CD performs `kubectl apply` on those manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Figure_9.22_B17385.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Create application
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the application, you should see the following screen. The **Status**
    is **Progressing**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Application created and synced'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.23_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – Application created and synced
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the application and you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Application deployed and in Healthy status'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.24_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – Application deployed and in Healthy status
  prefs: []
  type: TYPE_NORMAL
- en: You can see the deployments, `svc`, and pods listed here. The application **SYNC
    STATUS** is **Synced** and **APP HEALTH** is **Healthy**. Argo CD has built-in
    health checks for different Kubernetes resource types such as Deployment and ReplicaSets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have set up the continuous delivery workflow for our application, and the
    application is synced successfully. Now we will try to test the workflow by doing
    some local changes with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the default container registry to GCR using the `skaffold config set default-repo
    gcr.io/project-id` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will build, tag, and push the container image using the `skaffold build`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we will run the `skaffold render` command. This command will generate hydrated
    (that is, with newly generated image tags) Kubernetes manifests to a file that
    we will later commit and push to the Git repository. The GitOps pipeline using
    Argo CD will pick and sync those changes to the target Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's begin with this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make cosmetic code changes, increase replicas from one to two and run
    the `skaffold render` command. As per the `skaffold.yaml` file, the Kubernetes
    manifests are defined in the k8s directory. While running the `skaffold render`
    command, we will also pass the `--output=gtipos/manifest.yaml` flag so that we
    can later push it to the Git repository. The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I just wanted to highlight that `skaffold render` doesn't generate anew but
    will use existing Kubernetes manifests and update the image with a new tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we commit the changes and push them to the GitHub repository with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Soon after the push, Argo CD will sync the changes to the GKE cluster, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Increased number of replicas'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.25_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – Increased number of replicas
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, you can see that now we have two pods running as we have
    increased the number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot illustrates a typical GitOps workflow with Skaffold
    and Argo CD. We have pretty much already covered the same steps so far. Let's
    try to summarize what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Figure_9.26_B17385.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – GitOps workflow with Skaffold and Argo CD
  prefs: []
  type: TYPE_NORMAL
- en: 'We can conclude the following from the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: A developer commits and pushes code changes to the Git repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration pipeline kicks in and using skaffold build, we will build,
    tag, and push the image to container registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also generate hydrated manifests using skaffold render and commit them
    to either the same or different repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either sync action is triggered using CI webhook, or changes are pulled after
    regular polling intervals by Argo CD controller running inside the Kubernetes
    cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, the Argo CD controller will compare the live state against the desired
    target state (as per the git commit done on the config repository).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Argo CD detects that the application is OutOfSync, it will apply the latest
    changes to the Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we have learned how to create a GitOps pipeline combining
    two powerful tools: Skaffold and Argo CD. We could have used the `skaffold apply`
    command instead of Argo CD but the `skaffold apply` command always uses `kubetcl`
    to deploy resources to the target cluster. If you have an application bundled
    as Helm charts then it will not work. Furthermore, with Argo CD, you can combine
    Argo Rollouts to do blue-green and canary deployments as they are natively not
    supported with Skaffold.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how you can use GitHub Actions to automate
    your development workflows. We started the chapter by explaining GitHub Actions
    and their components. We explained GitHub Actions and related concepts with an
    example. In the example, we explained how you could build, test, and deploy your
    Java applications from your GitHub repository. Then we described how you could
    create a CI/CD pipeline for your Kubernetes applications using Skaffold and GitHub
    Actions.
  prefs: []
  type: TYPE_NORMAL
- en: You have discovered how you can take advantage of GitHub Actions and combine
    them with Skaffold to create CI/CD pipelines. Then in the final section, we took
    deep dive into setting up GitOps style continuous delivery workflow with Skaffold
    and Argo CD. We have learned that in GitOps we consider Git repository as a single
    source of truth for any change related to your infrastructure. We have also demonstrated
    how we can implement GitOps pipeline with Argo CD and Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Skaffold alternatives, and we will also
    cover its best practices and common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learn more about automating workflow with GitHub actions from Automating Workflows
    with GitHub Actions ([https://www.packtpub.com/product/automating-workflows-with-github-actions/9781800560406](https://www.packtpub.com/product/automating-workflows-with-github-actions/9781800560406)),
    published by Packt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about GitHub from GitHub Essentials ([https://www.packtpub.com/product/github-essentials-second-edition/9781789138337](https://www.packtpub.com/product/github-essentials-second-edition/9781789138337)),
    published by Packt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
