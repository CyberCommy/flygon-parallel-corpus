- en: Implementing Asynchronous Programming in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the `asyncio` module in Python. It will cover
    the idea behind this new concurrency module, which utilizes event loops and coroutines
    and provides an API that is as readable as synchronous code. In this chapter,
    we will also discuss the implementation of asynchronous programming, in addition
    to threading and multiprocessing through the `concurrent.futures` module. During
    this process, we will cover the application of asynchronous programming via the
    most common uses of `asyncio`, including asynchronous input/output and avoiding
    blocking tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental elements of implementing asynchronous programming using `asyncio`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework for asynchronous programming provided by `asyncio`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `concurrent.futures` module and its usage, in respect to `asyncio`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the list a prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder titled `Chapter10`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2TAtTrA](http://bit.ly/2TAtTrA)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asyncio module
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, the `asyncio` module provides an easy way
    to convert a sequential program to an asynchronous one. In this section, we will
    be discussing the general structure of an asynchronous program, and subsequently,
    how to implement the conversion from a sequential to an asynchronous program in
    Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines, event loops, and futures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few common elements that most asynchronous programs have, and coroutines,
    event loops, and futures are three of those elements. They are defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Event loops** are the main coordinators of tasks in an asynchronous program.
    An event loop keeps track of all of the tasks that are to be run asynchronously,
    and decides which of those tasks should be executed at a given moment. In other
    words, event loops handle the task switching aspect (or the execution flow) of
    asynchronous programming.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutines** are a special type of function that wrap around specific tasks,
    so that they can be executed asynchronously. A coroutine is required in order
    to specify where in the function the task switching should take place; in other
    words, they specify when the function should give back the flow of execution to
    the event loop. The tasks for coroutines are typically either stored in a task
    queue or created inside the event loop.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Futures** are placeholders for the results returned from coroutines. These
    future objects are created as soon as coroutines are initiated in the event loop,
    so futures can represent actual results, pending results (if the coroutines have
    not finished executing), or even an exception (if that is what the coroutine will
    return).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event loop, coroutines, and their corresponding futures, are the core elements
    of an asynchronous programming process. First, the event loop is started and interacts
    with its task queue, in order to obtain the first task. The coroutine for this
    task and its corresponding future are then created. When a task switching has
    to take place inside of that coroutine, the coroutine suspends, and the next coroutine
    is called; all data and the context from the first coroutine are also saved.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Now, if that coroutine is blocking (for example, input/output processing or
    sleeping), the flow of execution is released back to the event loop, which will
    move on to the next item in the task queue. The event loop will initiate the last
    item in the task queue before it switches back to the first coroutine, and will
    proceed the execution from where it was last suspended.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'As each task finishes executing, it will be dequeued from the task queue, its
    coroutine will be terminated, and the corresponding future will register the returned
    result from the coroutine. This process will go on until all tasks in the task
    queue are completely executed. The following diagram further illustrates the general
    structure of the asynchronous process described earlier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e37c350-e34c-4f29-9459-8084491a0a3e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Asynchronous programming process
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Asyncio API
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the general structure of an asynchronous program in mind, let's consider
    the specific APIs that the `asyncio` module and Python provide for the implementation
    of asynchronous programs. The first foundation for this API is the `async` and
    `await` keywords that were added to Python 3.5\. These keywords are used to specify
    the main elements of an asynchronous program to Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, `async` is typically put in front of the `def` keyword when a
    function is declared. A function with the `async` keyword in front of it will
    be interpreted by Python as a coroutine. As we discussed, inside of each coroutine,
    there has to be a specification regarding when the task switching events will
    take place. The `await` keyword is then used to specify where and when, exactly,
    to give back the flow of execution to the event loop; this is typically done through
    waiting for another coroutine to produce a result (`await coroutine`) or through
    helper functions from the `asyncio` module, such as the `asyncio.sleep()` and
    `asyncio.wait()` functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `async` and `await` keywords are actually provided
    by Python and are not managed by the `asyncio` module. This means that asynchronous
    programming can actually be implemented without `asyncio`, but, as you will see,
    `asyncio` provides a framework and infrastructure to streamline this process,
    and is therefore the primary tool in Python for the implementation of asynchronous
    programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the most commonly used API from the `asyncio` module is event-loop-managing
    functionalities. With `asyncio`, you can start to manipulate your tasks and event
    loop with intuitive and easy function calls, without extensive boilerplate code.
    These include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio.get_event_loop()`: This method returns the event loop for the current
    context, which is an `AbstractEventLoop` object. Most of the time, we do not need
    to worry about this class, as the `asyncio` module already provides a high-level
    API to manage our event loops.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.create_task()`: This method is to be called by an event
    loop. It adds its input to the current task queue of the calling event loop; the
    input is typically a coroutine (that is, a function with the `async` keyword).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.run_until_complete()`: This method is also to be called
    by an event loop. It takes in the main coroutine of an asynchronous program and
    executes it until the corresponding future of the coroutine is returned. While
    the method initiates the event loop execution, it also blocks all subsequent code
    following it, until all futures are complete.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.run_forever()`: This method is somewhat similar to `AbstractEventLoop.run_until_complete()`,
    except for the fact that, as suggested by the method name, the calling event loop
    will run forever, unless the `AbstractEventLoop.stop()` method is called. So,
    instead of exiting, the loop will continue to run, even upon obtaining the returned
    futures.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractEventLoop.stop()`: This method causes the calling event loop to stop
    executing and exit at the nearest appropriate opportunity, without causing the
    whole program to crash.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aside from these methods, we use a number of non-blocking functions to facilitate
    the task switching event. These include the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio.sleep()`: While in itself a coroutine, this function creates an additional
    coroutine that completes after a given time (specified by the input, in seconds).
    It is typically used as `asyncio.sleep(0)`, to cause an immediate task switching
    event.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio.wait()`: This function is also a coroutine, and hence, it can be used
    to switch tasks. It takes in a sequence (usually a list) of futures and waits
    for them to complete their execution.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asyncio framework in action
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, `asyncio` provides a simple and intuitive way to implement
    the framework of an asynchronous program with Python's asynchronous programming
    keywords. With that, let's consider the process of applying the framework provided
    to a synchronous application in Python, and convert it to an asynchronous one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously counting down
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Chapter10/example1.py` file, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goal of this example is to illustrate the asynchronous nature of overlapping
    the processing and waiting time of independent tasks. To do this, we will be analyzing
    a countdown function (`count_down()`) that takes in a string and a delay time.
    It will then count down from three to one, in seconds, while printing out the
    time elapsed from the beginning of the function's execution and the input string
    (with the current countdown number).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main program, we will call the `count_down()` function on the letters
    `A`, `B`, and `C`, with different delay times. After running the script, your
    output should be similar to the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The numbers at the beginning of the lines indicate the total numbers of seconds
    elapsed from the beginning of the program. You can see that the program counted
    down for letter `A` first, with one-second intervals, and it moved on to letter
    `B`, with 0.8-second intervals, and finally, to letter `C`, with 0.5-second intervals.
    This is a purely sequential, synchronous program, since there is no overlapping
    between processing and waiting time. Additionally, it took approximately 6.9 seconds
    to run the program, which is the sum of the counting down time of all three letters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keeping the idea behind asynchronous programming in mind, we can see that it
    is actually possible for us to convert this program to an asynchronous one. Specifically,
    let's suppose that during the first second of the program, while we are waiting
    to count down the letter `A`, we can switch tasks to move to other letters. In
    fact, we will implement this setup for all of the letters inside the `count_down()`
    function (in other words, we will turn `count_down()` into a coroutine).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, now that all counting down tasks are coroutines in an asynchronous
    program, we should achieve better execution time and responsiveness for our program.
    Since all three tasks are processed independently, the countdown messages should
    be printed out of order (jumping between different letters), and the asynchronous
    program should only take about the same time as the largest task takes (that is,
    three seconds for letter `A`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s make our program asynchronous. To do this, we first need
    to make `count_down()` into a coroutine and specify a point inside the function
    to be a task switching event. In other words, we will add the keyword `async`
    in front of the function, and, instead of the `time.sleep()` function, we will
    be using the `asyncio.sleep()` function along with the `await` keyword; the rest
    of the function should remain the same. Our `count_down()` coroutine should now
    be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As for our main program, we will need to initialize and manage an event loop.
    Specifically, we will create an empty event loop with the `asyncio.get_event_loop()`
    method, add all of the three counting down tasks into the task queue with `AbstractEventLoop.create_task()`,
    and, finally, start running the event loop with `AbstractEventLoop.run_until_complete()`.
    Our main program should look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The complete script can also be found in the code repository of the book, inside
    the `Chapter10` subfolder, named `example2.py`. After running the script, your
    output should look similar to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本也可以在书的代码存储库中找到，在`Chapter10`子文件夹中，名为`example2.py`。运行脚本后，您的输出应该类似于以下内容：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can see how having an asynchronous program can improve the execution
    time and responsiveness of our programs. Instead of executing individual tasks
    sequentially, our program now switches between different countdowns and overlaps
    their processing/waiting times. This, as we discussed, results in different letters
    being printed out in between each other, or simultaneously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到异步程序如何可以提高程序的执行时间和响应性。我们的程序不再按顺序执行单个任务，而是在不同的倒计时之间切换，并重叠它们的处理/等待时间。正如我们讨论过的，这导致不同的字母在彼此之间或同时被打印出来。
- en: At the beginning of the program, instead of waiting for the whole first second
    to print out the first message `A = 3`, the program switches to the next task
    in the task queue (in this case, it is waiting for 0.8 seconds for the letter
    `B`). This process continues until 0.5 seconds have passed and `C = 3` is printed
    out, and 0.3 seconds later (at the time 0.8 seconds), `B = 3` is printed out.
    This all happens before `A = 3` is printed out.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序开始时，程序不再等待整整一秒才打印出第一条消息`A = 3`，而是切换到任务队列中的下一个任务（在这种情况下，它等待0.8秒来打印字母`B`）。这个过程一直持续，直到过去了0.5秒，打印出`C
    = 3`，再过0.3秒（在0.8秒时），打印出`B = 3`。这都发生在打印出`A = 3`之前。
- en: 'This task-switching property of our asynchronous program makes it significantly
    more responsive. Instead of hanging for one second before the first message is
    printed, the program now only takes 0.5 seconds (the shortest waiting period)
    to print out its first message. As for the execution time, you can see that this
    time, it only takes three seconds, in total, to execute the whole program (instead
    of 6.9 seconds). This corresponds to what we speculated: that the execution time
    would be right around the time it takes to execute the largest task.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的异步程序的这种任务切换属性使其更具响应性。在打印第一条消息之前不再等待一秒，程序现在只需要0.5秒（最短的等待时间）就可以打印出第一条消息。至于执行时间，您可以看到这一次，整个程序只需要三秒的时间来执行（而不是6.9秒）。这符合我们的推测：执行时间将会接近执行最大任务所需的时间。
- en: A note about blocking functions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于阻塞函数的说明
- en: 'As you have seen, we have to replace our original `time.sleep()` function with
    its equivalent from the `asyncio` module. This is because `time.sleep()` is, by
    nature, a blocking function, which means that it cannot be used to implement a
    task switching event. To test this, in our `Chapter10/example2.py` file (our asynchronous
    program), we will replace the following line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们必须用`asyncio`模块中的等效函数替换我们原始的`time.sleep()`函数。这是因为`time.sleep()`本质上是一个阻塞函数，这意味着它不能用于实现任务切换事件。为了测试这一点，在我们的`Chapter10/example2.py`文件（我们的异步程序）中，我们将替换以下代码行：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will be replaced with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码将被替换为以下代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running this new script, your output will simply be the same as that of
    our original sequential, synchronous program. So, replacing `await asyncio.sleep()`
    with `time.sleep()` actually converts our program back to synchronous, ignoring
    the event loop that we implemented. What happened was, when our program proceeded
    to that line inside of the `count_down()` function, `time.sleep()` actually blocked
    and prevented the release of the execution flow, essentially rendering the whole
    program synchronous once again. Revert `time.sleep()` back to `await asyncio.sleep()`
    to fix this problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新脚本后，您的输出将与我们原始的顺序同步程序的输出相同。因此，用`time.sleep()`替换`await asyncio.sleep()`实际上将我们的程序重新转换为同步，忽略了我们实现的事件循环。发生的情况是，当我们的程序继续执行`count_down()`函数中的那行时，`time.sleep()`实际上阻塞并阻止了执行流的释放，从根本上使整个程序再次变成同步。将`time.sleep()`恢复为`await
    asyncio.sleep()`以解决这个问题。
- en: 'The following diagram illustrates an example of the difference in execution
    time between blocking and non-blocking file handling:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了阻塞和非阻塞文件处理之间执行时间差异的示例：
- en: '![](assets/14eb98aa-5364-4486-8fba-75e4434c5293.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14eb98aa-5364-4486-8fba-75e4434c5293.png)'
- en: Blocking versus non-blocking
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞与非阻塞
- en: 'This phenomenon raises an interesting issue: if a heavy, long-running task
    is blocking, then it is literally impossible to implement asynchronous programming
    with that task as a coroutine. So, if we really wanted to achieve what a blocking
    function returns in an asynchronous application, we would need to implement another
    version of that blocking function, which could be made into a coroutine and allow
    for task switching events to take place at at least one point inside the function.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现象引发了一个有趣的问题：如果一个耗时长的任务是阻塞的，那么使用该任务作为协程实现异步编程就是不可能的。因此，如果我们真的想要在异步应用程序中实现阻塞函数返回的内容，我们需要实现该阻塞函数的另一个版本，该版本可以成为协程，并允许在函数内至少有一个点进行任务切换。
- en: Luckily, after implementing `asyncio` as one of the official features of Python,
    Python core developers have been on working to produce the coroutine version of
    the most commonly used Python blocking functions. This means that if you ever
    find blocking functions that prevent your program from being truly asynchronous,
    you will most likely be able to find the coroutine versions of those functions
    to implement in your program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在将`asyncio`作为Python的官方功能之一后，Python核心开发人员一直在努力制作最常用的Python阻塞函数的协程版本。这意味着，如果您发现阻塞函数阻止您的程序真正实现异步，您很可能能够找到这些函数的协程版本来在您的程序中实现。
- en: However, the fact that there are asynchronous versions of traditionally blocking
    functions in Python with potentially different APIs means that you will need to
    familiarize yourself with those APIs from separate functions. Another way to handle
    blocking functions without having to implement their coroutine versions is to
    use an executor to run the functions in separate threads or separate processes,
    to avoid blocking the thread of the main event loop.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python中传统阻塞函数的异步版本具有潜在不同的API，这意味着您需要熟悉来自单独函数的这些API。处理阻塞函数的另一种方法，而无需实现它们的协程版本，是使用执行器在单独的线程或单独的进程中运行函数，以避免阻塞主事件循环的线程。
- en: Asynchronous prime-checking
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步素数检查
- en: 'Moving on from our starting counting-down example, let''s reconsider the example
    from the previous chapter. As a refresher, the following is the code for the synchronous
    version of the program:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们开始的倒计时例子中继续，让我们重新考虑上一章的例子。作为一个复习，以下是程序同步版本的代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we discussed in the last chapter, here, we have a simple prime-checking function, `is_prime(x)`,
    that prints out messages indicating whether the input integer that it takes in, `x`,
    is a prime number. In our main program, we call `is_prime()` on three prime numbers,
    in an order of decreasing magnitude sequentially. This setup again creates a significant
    period of time during which the program appears to be hanging while processing
    the large input, resulting in a low responsiveness for the program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章讨论的那样，这里我们有一个简单的素数检查函数`is_prime(x)`，它打印出消息，指示它接收的输入整数`x`是否是素数。在我们的主程序中，我们按照递减的顺序依次对三个素数调用`is_prime()`。这种设置再次在处理大输入时创建了一个显著的时间段，导致程序在处理大输入时出现停顿，从而降低了程序的响应性。
- en: 'The output produced by the program will look similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序产生的输出将类似于以下内容：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To implement asynchronous programming for this script, first, we will have
    to create our first main component: the event loop. To do this, instead of using
    the `''__main__''` scope, we will convert it to a separate function. This function
    and our `is_prime()` prime-checking function will be the coroutines in our final
    asynchronous program.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要为此脚本实现异步编程，首先，我们将不得不创建我们的第一个主要组件：事件循环。为此，我们将其转换为一个单独的函数，而不是使用`'__main__'`范围。这个函数和我们的`is_prime()`素数检查函数将成为我们最终异步程序中的协程。
- en: 'Now, we need to convert both the `is_prime()` and `main()` functions into coroutines;
    again, this means putting the `async` keyword in front of the `def` keyword, and
    the `await` keyword inside each function, to specify the task-switching event.
    For `main()`, we simply implement that event while waiting for the task queue
    by using `aysncio.wait()`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`is_prime()`和`main()`函数都转换为协程；同样，这意味着在`def`关键字前面加上`async`关键字，并在每个函数内部使用`await`关键字来指定任务切换事件。对于`main()`，我们只需在等待任务队列时实现该事件，使用`aysncio.wait()`，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Things are more complicated in the `is_prime()` function, as there is no clear
    point during which the execution flow should be released back to the event loop,
    like in our previous counting-down example. Recall that the goal of asynchronous
    programming is to achieve a better execution time and responsiveness, and to implement
    this, the task-switching event should take place during a heavy, long-running
    task. This requirement, however, is dependent on the specifics of your program—particularly,
    the coroutine, the task queue of the program, and the individual tasks in the
    queue.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_prime()`函数中的情况更加复杂，因为在执行流程应该释放回事件循环的时间点不明确，就像我们之前倒计时的例子一样。回想一下，异步编程的目标是实现更好的执行时间和响应性，为了实现这一点，任务切换事件应该发生在一个繁重且长时间运行的任务中。然而，这一要求取决于您的程序的具体情况，特别是协程、程序的任务队列和队列中的各个任务。'
- en: 'For example, the task queue of our program consists of three numbers: `9637529763296797`,
    `427920331`, and `157`; in order, we can consider them as a large task, a medium
    task, and a small task. To improve responsiveness, we would like to switch tasks
    during the large task, and not during the small task. This setup will allow the
    medium and small tasks to be started, processed, and maybe finished during the
    execution of the large task, even if the large task is in front in the task queue
    of the program.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们程序的任务队列包括三个数字：`9637529763296797`、`427920331`和`157`；按顺序，我们可以将它们视为一个大任务、一个中等任务和一个小任务。为了提高响应性，我们希望在大任务期间切换任务，而不是在小任务期间。这种设置将允许在执行大任务时启动、处理和可能完成中等和小任务，即使大任务在程序的任务队列中处于前列。
- en: Then, we will consider our `is_prime()` coroutine. After checking for some specific
    edge cases, it iterates in a `for` loop through every odd number under the square
    root of the input integer and tests for the divisibility of the input with regards
    to the current odd number in question. Inside this long-running `for` loop, then,
    is the perfect place to switch tasks—that is, to release the execution flow back
    to the event loop.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将考虑我们的`is_prime()`协程。在检查一些特定边界情况后，它通过`for`循环遍历输入整数平方根下的每个奇数，并测试输入与当前奇数的可除性。在这个长时间运行的`for`循环中，是切换任务的完美位置——即释放执行流程回事件循环。
- en: 'However, we still need to decide at which specific points in the `for` loop
    to implement the task-switching event. Again, taking into account the individual
    tasks in the task queue, we are looking for a point that is fairly common in the
    large task, not so common in the medium task, and non-existent in the small task.
    I have decided that this point is every 1,00,000-number period, which does satisfy
    our requirements, and I have used the `await asyncio.sleep(0)` command to facilitate
    the task-switching event, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要决定在`for`循环中的哪些具体点实现任务切换事件。再次考虑任务队列中的各个任务，我们正在寻找一个在大任务中相当常见，在中等任务中不太常见，并且在小任务中不存在的点。我决定这一点是每1,00,000个数字周期，这满足我们的要求，我使用了`await
    asyncio.sleep(0)`命令来促进任务切换事件，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, in our main program (not to be confused with the `main()` coroutine),
    we create our event loop and use it to run our `main()` coroutine, until it completes
    its execution:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的主程序（不要与`main()`协程混淆），我们创建事件循环并使用它来运行我们的`main()`协程，直到它完成执行：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you saw in the previous chapter, better responsiveness was achieved through
    this asynchronous version of the script. Specifically, instead of appearing like
    it is hanging while processing the first large task, our program now prints out
    output messages for the other, smaller tasks, before it finishes executing the
    large task. Our end result will look similar to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中看到的，通过脚本的这种异步版本实现了更好的响应性。具体来说，我们的程序现在在处理第一个大任务时不会像挂起一样，而是在完成执行大任务之前，会打印出其他较小任务的输出消息。我们的最终结果将类似于以下内容：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Improvements from Python 3.7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3.7的改进
- en: As of 2018, Python 3.7 has just come out, with several major new features, such
    as data classes, guaranteed ordered dictionaries, better timing precision, and
    so on. Asynchronous programming and the `asyncio` module received a number of
    important improvements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年，Python 3.7刚刚发布，带来了几个重大的新功能，例如数据类、有序字典、更好的时间精度等。异步编程和`asyncio`模块也得到了一些重要的改进。
- en: 'First of all, `async` and `await` are now officially reserved keywords in Python.
    While we have been calling them keywords, Python did not, in fact, treat these
    words as reserved keywords, up until now. This means that neither `async` nor
    `await` can be used to name variables or functions in a Python program. If you
    are using Python 3.7, fire up a Python interpreter and try to use these keywords
    for variable or function names, and you should receive the following error message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`async`和`await`现在在Python中是正式保留的关键字。虽然我们一直称它们为关键字，但事实上，Python直到现在都没有将这些词视为保留关键字。这意味着在Python程序中既不能使用`async`也不能使用`await`来命名变量或函数。如果您正在使用Python
    3.7，请启动Python解释器并尝试使用这些关键字作为变量或函数名称，您应该会收到以下错误消息：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A major improvement in Python 3.7 comes with the `asyncio` module. Specifically,
    you might have noticed from our previous examples that the main program typically
    contains a fair amount of boilerplate code to initiate and run the event loop,
    which most likely remains the same in all asynchronous programs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.7的一个重大改进是`asyncio`模块。具体来说，您可能已经注意到从我们之前的例子中，主程序通常包含大量样板代码来初始化和运行事件循环，这在所有异步程序中可能都是相同的：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With `main()` being a coroutine in our program, `asyncio` allows us to simply
    run it in an event loop by using the `asyncio.run()` method. This eliminates significant
    boilerplate code in Python asynchronous programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，`main()`是一个协程，`asyncio`允许我们使用`asyncio.run()`方法在事件循环中简单地运行它。这消除了Python异步编程中的重要样板代码。
- en: 'So, we can convert the preceding code to a more simplified version in Python
    3.7, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将前面的代码转换为Python 3.7中更简化的版本，如下所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are other improvements regarding asynchronous programming, in both performance
    and ease in usage, that were implemented in Python 3.7; however, we will not be
    discussing them in this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异步编程，Python 3.7还实现了性能和使用便利方面的其他改进；但是，在本书中我们将不会讨论它们。
- en: Inherently blocking tasks
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固有阻塞任务
- en: In the first example in this chapter, you saw that asynchronous programming
    can provide our Python programs with better execution time, but that is not always
    the case. Asynchronous programming alone can only provide improvements in speed
    if all processing tasks are non-blocking. However, similar to the comparison between
    concurrency and inherent sequentiality in programming tasks, some computing tasks
    in Python are inherently blocking, and therefore, they cannot be taken advantage
    of by asynchronous programming.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个例子中，您看到异步编程可以为我们的Python程序提供更好的执行时间，但并非总是如此。仅有异步编程本身只能在所有处理任务都是非阻塞的情况下提供速度上的改进。然而，类似于并发和编程任务中固有的顺序性之间的比较，Python中的一些计算任务是固有阻塞的，因此无法利用异步编程。
- en: This means that if your asynchronous programming has inherently blocking tasks
    in some coroutines, the program will not gain any additional improvement in speed
    from the asynchronous architecture. While task-switching events still take place
    in those programs, which will improve the responsiveness of the programs, no instructions
    will be overlapping each other, and no additional speed will thus be gained. In
    fact, since there is considerable overhead regarding the implementation of asynchronous
    programming in Python, our programs might even take longer to finish their execution
    than the original, synchronous programs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您的异步编程在某些协程中具有固有的阻塞任务，程序将无法从异步架构中获得额外的速度改进。虽然这些程序仍然会发生任务切换事件，从而提高程序的响应性，但指令不会重叠，因此也不会获得额外的速度。事实上，由于Python中异步编程的实现存在相当大的开销，我们的程序甚至可能需要更长的时间来完成执行，而不是原始的同步程序。
- en: For example, let's look at a comparison in speed between the two versions of
    our prime-checking program. Since the primary processing portion of the program
    is the `is_prime()` coroutine, which solely consists of number crunching, we know
    that this coroutine contains blocking tasks. So, the asynchronous version is,
    in fact, expected to run more slowly than the synchronous version.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Chapter10` subfolder of the code repository and take a look
    at the files `example3.py` and `example4.py`. These files contain the same code
    for the synchronous and asynchronous prime-checking programs that we have been
    seeing, but with the addition that we are also tracking how much time it takes
    to run the respective programs. The following is my output after running `example3.py`,
    the synchronous version of the program:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code shows my output when running `example4.py`, the asynchronous
    program:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While the output that you receive might be different in the specific times it
    took to run either program, it should be the case that, as we discussed, the asynchronous
    program actually took longer to run than the synchronous (sequential) one. Again,
    this is because the number crunching tasks inside our `is_prime()` coroutine are
    blocking, and, instead of overlapping these tasks in order to gain additional
    speed, our asynchronous program simply switched between these tasks in its execution.
    In this case, only responsiveness is achieved through asynchronous programming.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: However, this does not mean that if your program contains blocking functions,
    asynchronous programming is out of the question. As mentioned previously, all
    execution in an asynchronous program, if not specified otherwise, occurs entirely
    in the same thread and process, and blocking CPU-bound tasks can thus prevent
    program instructions from overlapping each other. However, this is not the case
    if the tasks are distributed to separate threads/processes. In other words, threading
    and multiprocessing can help asynchronous programs with blocking instructions
    to achieve better execution time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: concurrent.futures as a solution for blocking tasks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be considering another way to implement threading/multiprocessing:
    the `concurrent.futures` module, which is designed to be a high-level interface
    for implementing asynchronous tasks. Specifically, the `concurrent.futures` module
    works seamlessly with the `asyncio` module, and, in addition, it provides an abstract
    class called `Executor`, which contains the skeleton of the two main classes that
    implement asynchronous threading and multiprocessing, respectively (as suggested
    by their names): `ThreadPoolExecutor` and `ProcessPoolExecutor`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the framework
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the API from `concurrent.futures`, let's discuss the theoretical
    basics of asynchronous threading/multiprocessing, and how it plays into the framework
    of the asynchronous programming that `asyncio` provides.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, we have three major elements in our ecosystem of asynchronous
    programming: the event loop, the coroutines, and their corresponding futures.
    We still need the event loop while utilizing threading/multiprocessing, to coordinate
    the tasks and handle their returned results (futures), so these elements typically
    remain consistent with single-threaded asynchronous programming.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: As for the coroutines, since the idea of combining asynchronous programming
    with threading and multiprocessing involves avoiding blocking tasks in the coroutines
    by executing them in separate threads and processes, the coroutines do not necessarily
    have to be interpreted as actual coroutines by Python anymore. Instead, they can
    simply be traditional Python functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: One new element that we will need to implement is the executor that facilitates
    threading or multiprocessing; this can be an instance of the `ThreadPoolExecutor`
    class or the `ProcessPoolExecutor` class. Now, every time we add a task to our
    task queue in the event loop, we will also need to reference this executor, so
    that separate tasks will be executed in separated threads/processes. This is done
    through the `AbstractEventLoop.run_in_executor()` method, which takes in an executor,
    a coroutine (though, again, it does not have to be an actual coroutine), and arguments
    for the coroutines to be executed in separate threads/processes. We will see an
    example of this API in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要实现的一个新元素是执行器，它可以促进线程或多进程；这可以是`ThreadPoolExecutor`类或`ProcessPoolExecutor`类的实例。现在，每当我们在事件循环中向任务队列添加任务时，我们还需要引用这个执行器，这样分离的任务将在不同的线程/进程中执行。这是通过`AbstractEventLoop.run_in_executor()`方法完成的，该方法接受一个执行器、一个协程（尽管它不必是一个真正的协程），以及要在单独的线程/进程中执行的协程的参数。我们将在下一节中看到这个API的示例。
- en: Examples in Python
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python示例
- en: Let's look at a specific implementation of the `concurrent.futures` module.
    Recall that in this chapter's first example (the counting down example), the blocking
    `time.sleep()` function prevented our asynchronous program from becoming truly
    asynchronous, and had to be replaced with its non-blocking version, `asyncio.sleep()`.
    Now, we are executing the individual countdowns in separate threads or processes,
    which means that the blocking `time.sleep()` function will not pose any problems
    in terms of executing our program asynchronously.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`concurrent.futures`模块的具体实现。回想一下，在本章的第一个示例（倒计时示例）中，阻塞的`time.sleep()`函数阻止了我们的异步程序真正成为异步，必须用其非阻塞版本`asyncio.sleep()`替换。现在，我们在单独的线程或进程中执行各自的倒计时，这意味着阻塞的`time.sleep()`函数不会在执行我们的程序异步方面造成任何问题。
- en: 'Navigate to the `Chapter10/example5.py` file, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`Chapter10/example5.py`文件，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that `count_down()` is declared as a typical, non-coroutine Python function.
    In `main()`, which remains a coroutine, we declare our task queue for the event
    loop. Again, we are using the `run_in_executor()` method during this process,
    instead of the `create_task()` method that is used in single-threaded asynchronous
    programming. In our main program, we also need to initiate an executor, which,
    in this case, is an instance of the `ThreadPoolExecutor` class from the `concurrent.futures`
    module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`count_down()`被声明为一个典型的非协程Python函数。在`main()`中，仍然是一个协程，我们为事件循环声明了我们的任务队列。同样，在这个过程中，我们使用`run_in_executor()`方法，而不是在单线程异步编程中使用的`create_task()`方法。在我们的主程序中，我们还需要初始化一个执行器，这种情况下，它是来自`concurrent.futures`模块的`ThreadPoolExecutor`类的实例。
- en: The decision between using threading and multiprocessing is, as we discussed
    in previous chapters, dependent on the nature of the program. Here, we need to
    share the `start` variable (holding the time at which the program starts to execute)
    among separate coroutines, so that they can perform the act of counting down;
    so, threading is chosen over multiprocessing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程和多进程的决定，正如我们在之前的章节中讨论的那样，取决于程序的性质。在这里，我们需要在单独的协程之间共享`start`变量（保存程序开始执行的时间），以便它们可以执行倒计时的动作；因此，选择了多线程而不是多进程。
- en: 'After running the script, your output should be similar to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您的输出应该类似于以下内容：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This output is identical to the one that we obtained from the asynchronous program
    with pure `asyncio` support. So, even with a blocking processing function, we
    were able to make the execution of our program asynchronous, with threading implemented
    by the `concurrent.futures` module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出与我们从纯`asyncio`支持的异步程序中获得的输出是相同的。因此，即使有一个阻塞处理函数，我们也能够使我们的程序的执行异步化，通过`concurrent.futures`模块实现了线程。
- en: 'Let''s now apply the same concept to our prime-checking problem. We are first
    converting our `is_prime()` coroutine to its original, non-coroutine form, and
    executing it in separate processes again (which are more desirable than threads,
    as the `is_prime()` function is an intensive number-crunching task). An additional
    benefit of using the original version of `is_prime()` is that we will not have
    to perform a check of the task-switching condition that we have in our single-threaded
    asynchronous program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将相同的概念应用到我们的素数检查问题上。我们首先将我们的`is_prime()`协程转换为其原始的非协程形式，并再次在单独的进程中执行它（这比线程更可取，因为`is_prime()`函数是一个密集的数值计算任务）。使用原始版本的`is_prime()`的另一个好处是，我们不必执行我们在单线程异步程序中的任务切换条件的检查。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will provide us with a significant speedup, as well. Let''s take a look
    at the `Chapter10/example6.py` file, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将为我们提供显著的加速。让我们看一下`Chapter10/example6.py`文件，如下所示：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running the script, I obtained the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，我得到了以下输出：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, your execution time will most likely be different from mine, although
    the comparison between this and the other two versions of our prime-checking program
    should always be consistent: the original, synchronous version takes less time
    than the single-threaded asynchronous version, but more than the multiprocessing
    asynchronous version. In other words, by combining multiprocessing with asynchronous
    programming, we get the best of both worlds: the consistent responsiveness from
    asynchronous programming, and the improvement in speed from multiprocessing.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您的执行时间很可能与我的不同，尽管我们的原始、同步版本所花费的时间应该始终与单线程异步版本和多进程异步版本的比较一致：原始的同步版本所花费的时间少于单线程异步版本，但多于多进程异步版本。换句话说，通过将多进程与异步编程结合起来，我们既得到了异步编程的一致响应性，又得到了多进程的速度提升。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about asynchronous programming, which is a model
    of programming that takes advantage of coordinating computing tasks to overlap
    the waiting and processing times. There are three main components to an asynchronous
    program: the event loop, the coroutines, and the futures. The event loop is in
    charge of scheduling and managing coroutines using its task queue. Coroutines
    are computing tasks that are to be executed asynchronously; each coroutine has
    to specify inside of its function exactly where it will give the execution flow
    back to the event loop (that is, the task-switching event). Futures are placeholder
    objects that contain the results obtained from the coroutines.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio` module, together with the Python keywords `async` and `await`,
    provides an easy-to-use API and an intuitive framework to implement asynchronous
    programs; additionally, this framework makes the asynchronous code just as readable
    as synchronous code, which is generally quite rare in asynchronous programming.
    However, we cannot apply single-threaded asynchronous programming on blocking
    computing tasks with the `asyncio` module alone. The solution to this is the `concurrent.futures`
    module, which provides a high-level API to implement asynchronous threading and
    multiprocessing, and can be used in addition to the `asyncio` module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing one of the most common applications
    of asynchronous programming, **Transmission Control Protocol** (**TCP**), as a
    means of server-client communication. You will learn about the basics of the concept,
    how it takes advantage of asynchronous programming, and how to implement it in
    Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is asynchronous programming? What advantages does it provide?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the main elements in an asynchronous program? How do they interact
    with each other?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the `async` and `await` keywords? What purposes do they serve?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What options does the `asyncio` module provide, in terms of the implementation
    of asynchronous programming?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the improvements in regards to asynchronous programming provided in
    Python 3.7?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are blocking functions? Why do they pose a problem for traditional asynchronous
    programming?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `concurrent.futures` provide a solution to blocking functions for asynchronous
    programming? What options does it provide?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Zaccone, Giancarlo. *Python Parallel Programming Cookbook*. Packt Publishing
    Ltd, 2015
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A guide to asynchronous programming in Python with asyncio* ([medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio](https://medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio-232e2afa44f6)), Mariia Yakimova'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AsyncIO for the Working Python Developer* ([hackernoon.com/asyncio-for-the-working-python-developer](https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e)), Yeray Diaz'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Documentation. Tasks and coroutines. [docs.python.org/3/library/asyncio](https://docs.python.org/3/library/asyncio.html)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modern Concurrency*, ([speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency](https://speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency)),
    PyBay 2017'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
