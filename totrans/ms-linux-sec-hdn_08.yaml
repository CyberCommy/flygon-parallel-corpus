- en: Scanning, Auditing, and Hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common misconception is that Linux users never need to worry about malware.
    Yes, it's true that Linux is much more resistant to viruses than Windows is. But,
    viruses are only one type of malware, and other types of malware can be planted
    on Linux machines. And, if you're running a server that will share files with
    Windows users, you'll want to make sure that you don't share any virus-infected
    files with them.
  prefs: []
  type: TYPE_NORMAL
- en: While Linux system log files are nice, they don't always give a good picture
    of who does what or who accesses what. It could be that either intruders or insiders
    are trying to access data that they're not authorized to access. What we really
    want is a good auditing system to alert us when people do things that they're
    not supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: And then, there's the issue of regulatory compliance. Your organization may
    have to deal with one or more regulatory bodies that dictate how you harden your
    servers against attacks. If you're not in compliance, you could be fined or put
    out of business.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have ways to deal with all of these issues, and they aren't
    all that complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and updating ClamAV and maldet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning with ClamAV and maldet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning for rootkits with Rootkit Hunter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the auditd daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating audit rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ausearch` and `aureport` utilities to search the audit logs for problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oscap`, the command-line utility in order to manage and apply OpenSCAP policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSCAP Workbench, the GUI utility to manage and apply OpenSCAP policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSCAP policy files and the compliance standards that each of them is designed
    to meet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a policy during operating system installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and updating ClamAV and maldet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we don't have to worry much about viruses infecting our Linux machines,
    we do need to worry about sharing infected files with Windows users. ClamAV is
    a **Free Open Source Software** (**FOSS**) antivirus solution that can either
    run as a standalone program or can be integrated with a mail server daemon, such
    as Postfix. It's a traditional antivirus scanner that works pretty much the same
    as the antivirus program on your typical Windows workstation. The included `freshclam`
    utility allows you to update virus signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Malware Detect*, which you''ll often see abbreviated as either **LMD**
    or **maldet**, is another FOSS antivirus program that can work alongside ClamAV.
    (To save typing, I''ll just refer to it as LMD from now on.) As far as I know,
    it''s not available in the repositories of any Linux distro, but it''s still simple
    enough to install and configure. One of its features is that it automatically
    generates malware detection signatures when it sees malware on the network''s
    edge intrusion detection systems. End users can also submit their own malware
    samples. When you install it, you''ll get a systemd service that''s already enabled
    and a cron job that will periodically update both the malware signatures and the
    program itself. It works with the Linux kernel''s inotify capability to automatically
    monitor directories for files that have changed. The procedure to install it is
    pretty much the same for any systemd-based Linux distro.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get all the nitty-gritty details about Linux Malware Detect at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rfxn.com/projects/linux-malware-detect/.](https://www.rfxn.com/projects/linux-malware-detect/)'
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we're installing ClamAV and LMD together is that, as the LMD
    folk freely admit, the ClamAV scan engine gives a much better performance when
    scanning large file sets. Also, by having them both together, ClamAV can use the
    LMD malware signatures as well as its own malware signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Installing ClamAV and maldet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin by installing ClamAV. (It's in the normal repository for Ubuntu,
    but not for CentOS. For CentOS, you'll need to install the EPEL repository, as
    I showed you how to do in [Chapter 1](366f0919-598d-4648-8873-b4dbe636d171.xhtml),
    *Running Linux in a Virtual Environment*.) We'll also install Wget, which we'll
    use to download LMD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will help you install ClamAV and Wget on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will help you install ClamAV and Wget on CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For Ubuntu, the `clamav` package contains everything you need. For CentOS, you'll
    need to also install `clamav-update` in order to obtain virus updates.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the steps will be the same for either virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll download and install LMD. Here, you''ll want to do something
    that I rarely tell people to do. That is, you''ll want to log in to the root user
    shell. The reason is that although the LMD installer works fine with sudo, you''ll
    end up with the program files being owned by the user who performed the installation,
    instead of by the root user. Performing the installation from the root user''s
    shell saves us the trouble of tracking down those files and changing ownership.
    So, download the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll now have the file in the root user''s home directory. Now, extract
    the archive, enter the resultant directory, and run the installer. Once the installer
    finishes, copy the `README` file to your own home directory so that you can have
    it for ready reference. (This `README` file is the documentation for LMD.) Then,
    exit from the root user''s shell back to your own shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the installer automatically creates the symbolic link that enables
    the maldet service, and it also automatically downloads and installs the newest
    malware signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring maldet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you try to start the maldet service at this point, it will fail. To make
    it work, you need to configure the directories that you want it to automatically
    monitor and scan. To do this, you''ll add the directories to the `/usr/local/maldetect/monitor_paths`
    file. For now, I just want to monitor the `/home` and `/root` directories, so
    my `monitor_paths` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After you save the file, you''ll be able to start the maldet daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can add more directories to the `monitor_paths` file at any time, but remember
    to restart the maldet daemon any time that you do, in order to read in the new
    additions.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file for LMD is `/usr/local/maldetect/conf.maldet`. It's very
    well-documented with well-written comments for every configuration item, so you
    shouldn't have any trouble figuring it out. For now, we're only going to make
    a few configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, enable email alerts and set your username as the email
    address. The two lines should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'LMD isn''t already configured to move suspicious files to the quarantine folder,
    and we want to make it do that.  Open the `conf.maldet` file in your text editor
    and look for the line that says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the previous line to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see a few other quarantine actions that you can configure, but for
    now, this is all we need.  After you save the file, restart maldet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The new changes will now be in effect.
  prefs: []
  type: TYPE_NORMAL
- en: Updating ClamAV and maldet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The good news for busy admins is that you don''t have to do anything to keep
    either of these programs updated. Both of them run with a cron job that gets created
    automatically and that does the updates for us. To prove that ClamAV is getting
    updated, we can look in the system log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You'll see these same entries in either the Ubuntu logs or the CentOS logs.
    However, there is a difference between how the updates get run automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/etc/clamav/freshclam.conf` file of your Ubuntu machine, you''ll see
    the following lines at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So essentially, this means that on Ubuntu, ClamAV will be checking for updates
    every hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your CentOS machine, you''ll see a `clamav-update` cron job in the `/etc/cron.d`
    directory that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*/3` in the second column from the left indicates that ClamAV will check
    for updates every 3 hours. You can change that if you like, but you''ll also need
    to change the setting in the `/etc/sysconfig/freshclam` file. Let''s say that
    you want for CentOS to also check for ClamAV updates every hour. In the cron job
    file, change the `*/3` to `*`. (You don''t need to do `*/1` because the asterisk
    by itself in that position already indicates that the job will run every hour.)
    Then, in the `/etc/sysconfig/freshclam` file, look for this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncomment that line and add the number of minutes that you want between updates.
    To set it to 1 hour, in order to match the cron job, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove that maldet is getting updated, you can look in its own log files
    in the `/usr/local/maldetect/logs/` directory. In the `event_log` file, you''ll
    see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `/usr/local/maldetect/conf.maldet` file, you''ll see these two lines,
    but with some comments in between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Not only will LMD automatically update its malware signatures, it will also
    ensure that you have the latest version of LMD itself.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with ClamAV and maldet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LMD's maldet daemon constantly monitors the directories that you specify in
    the `/usr/local/maldetect/monitor_paths` file. When it finds a file that it suspects
    might be malware, it automatically takes whatever action that you specified in
    the `conf.maldet` file. To see how this works, I'll create a simulated malware
    file in my home directory. Fortunately, that's easier than it sounds, because
    we have a website that will help us out.
  prefs: []
  type: TYPE_NORMAL
- en: '**EICAR**, which used to be known by its full name of **European Institute
    for Computer Antivirus Research**, provides a virus signature that you can include
    in a plain text file.  You can get it at: [http://www.eicar.org/86-0-Intended-use.html](http://www.eicar.org/86-0-Intended-use.html).'
  prefs: []
  type: TYPE_NORMAL
- en: To create the simulated virus file, go to the page that I've listed in the preceding
    link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down toward the bottom of the page until you see this line of text within
    a text box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy that line of text and insert it into a text file that you''ll save to
    your home directory of either virtual machine. (You can name it anything you want,
    but I''ll just name mine `testing.txt`.) Wait just a few moments, and you should
    see the file disappear. Then, look in the `/usr/local/maldetect/logs/event_log`
    file to verify that the LMD moved the file to quarantine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's still a bit more to LMD than what I can show you here. However, you
    can read all about it in the `README` file that comes with it.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It used to be that doing an antivirus scan on a Red Hat-type system would trigger
    an SELinux alert. But, in the course of proofing this chapter, the scans all worked
    as they should, and SELinux never bothered me even once. So, it would appear that
    that problem is now fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever do generate any SELinux alerts with your virus scans, all you need
    to do to fix it is to change one Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What interests us here is the `antivirus_can_scan_system` Boolean, which is
    off by default. To turn it on to enable virus scans, just follow this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That should fix any SELinux-related scan problems that you may have. But, as
    things stand now, you probably won't need to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for rootkits with Rootkit Hunter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rootkits are exceedingly nasty pieces of malware that can definitely ruin your
    day. They can listen for commands from their masters, steal sensitive data and
    send it to their masters, or provide an easy-access back door for their masters.
    They're designed to be stealthy, with the ability to hide themselves from plain
    view. Sometimes, they'll replace utilities such as `ls` or `ps` with their own
    trojaned versions that will show all files or processes on the system except for
    the ones that are associated with the rootkit. Rootkits can infect any operating
    system, even our beloved Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In order to plant a rootkit, an attacker has to have already gained administrative
    privileges on a system. This is one of the many reasons why I always cringe when
    I see people doing all of their work from the root user's shell and why I'm a
    firm advocate of using sudo whenever possible. I mean, really, why should we make
    it easy for the bad guys?
  prefs: []
  type: TYPE_NORMAL
- en: Several years ago, back in the dark days of Windows XP, Sony Music got into
    a bit of trouble when someone discovered that they had planted a rootkit on their
    music CDs. They didn't mean to do anything malicious, but only wanted to stop
    people from using their computers to make illegal copies. Of course, most people
    ran Windows XP with an administrator account, which made it really easy for the
    rootkit to infect their computers. Windows users still mostly run with administrator
    accounts, but they at least now have User Access Control to help mitigate these
    types of problems.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of different programs that scan for rootkits, and both are
    used pretty much the same way. The one that we'll look at now is named, Rootkit
    Hunter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and updating Rootkit Hunter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Ubuntu, Rootkit Hunter is in the normal repository. For CentOS, you'll need
    to install the EPEL repository, as I showed you how to do in [Chapter 1](366f0919-598d-4648-8873-b4dbe636d171.xhtml),
    *Running Linux in a Virtual Environment*. For both Linux distros, the package
    name is `rkhunter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After it''s installed, you can look at its options with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing you''ll need to do is to update the rootkit signatures, using
    the `--update` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, we're ready to scan.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for rootkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run your scan, use the `-c` option. (That''s `-c` for check.)  Be patient,
    because it will take a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you run the scan in this manner, Rootkit Hunter will periodically stop
    and ask you to hit the *Enter* key to continue. When the scan completes, you'll
    find an `rkhunter.log` file in the `/var/log` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have Rootkit Hunter automatically run as a cron job, you''ll want to use
    the `--cronjob` option, which will cause the program to run all the way through
    without prompting you to keep hitting the *Enter* key. You might also want to
    use the `--rwo` option, which will cause the program to only report warnings,
    instead of also reporting on everything that''s good.  From the command line,
    the command would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a cron job that will automatically run Rootkit Hunter on a nightly
    basis, open the crontab editor for the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that you want to run Rootkit Hunter every night at 20 minutes past
    10\. Enter this into the crontab editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since cron only works with 24 hour clock time, you'll have to express 10:00
    P.M. as 22\. (Just add 12 to the normal P.M. clock times that you're used to using.)
    The three asterisks mean, respectively, that the job will run every day of the
    month, every month, and every day of the week. You'll need to list the entire
    path for the command, or else cron won't be able to find it.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find more options that might interest you in the `rkhunter` man page,
    but this should be enough to get you going with it.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the auditd daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you have a directory full of super-secret files that only a very few people
    need to see, and you want to know when unauthorized people try to see them. Or,
    maybe you want to see when a certain file gets changed. Or, maybe you want to
    see when people log into the system and what they're doing once they do log in.
    For all this and more, you have the auditd system. It's a really cool system,
    and I think that you'll like it.
  prefs: []
  type: TYPE_NORMAL
- en: One of the beauties of auditd is that it works at the Linux kernel level, rather
    than at the user-mode level. This makes it much harder for attackers to subvert.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Red Hat-type systems, auditd comes installed and enabled by default. So,
    you''ll find it already there on your CentOS machine. On Ubuntu, it isn''t already
    installed, so you''ll have to do it yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, you can control the auditd daemon with the normal `systemctl` commands.
    So, if you need to restart auditd to read in a new configuration, you can do that
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS 7, for some reason that I don''t understand, the normal `systemctl`
    commands don''t work with auditd. (For all other daemons, they do.) So, on your
    CentOS 7 machine, you''ll restart the auditd daemon with the old-fashioned `service`
    command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Other than this minor difference, everything I tell you about auditd from here
    on will apply to both Ubuntu and CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating audit rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, let''s start with something simple and work our way up to something awesome.
    First, let''s check to see whether any audit rules are in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `auditctl` command is what we use to manage audit rules.
    The `-l` option lists the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing a file for changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s say that we want to see when someone changes the `/etc/passwd`
    file. (The command that we''ll use will look a bit daunting, but I promise that
    it will make sense once we break it down.) Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-w`: This stands for where, and it points to the object that we want to monitor. 
    In this case, it''s `/etc/passwd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`: This indicates the object''s permissions that we want to monitor. In
    this case, we''re monitoring to see when anyone either tries to (w)rite to the
    file, or tries to make (a)ttribute changes. (The other two permissions that we
    can audit are (r)ead and e(x)ecute.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-k`: The `k` stands for key, which is just auditd''s way of assigning a name
    to a rule.  So, `passwd_changes` is the key, or the name, of the rule that we''re
    creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `auditctl -l` command shows us that the rule is indeed there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the slight problem with this is that the rule is only temporary and will
    disappear when we reboot the machine. To make it permanent, we need to create
    a custom rules file in the `/etc/audit/rules.d/` directory. Then, when you restart
    the auditd daemon, the custom rules will get inserted into the `/etc/audit/audit.rules`
    file. Because the `/etc/audit/` directory can only be accessed by someone with
    root privileges, I''ll just open the file by listing the entire path to the file,
    rather than trying to enter the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s not a whole lot in this default file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown for this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-D`: This will cause all rules and watches that are currently in effect to
    be deleted, so that we can start from a clean slate. So, if I were to restart
    the auditd daemon right now, it would read this `audit.rules` file, which would
    delete the rule that I just now created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b 8192`: This sets the number of outstanding audit buffers that we can have
    going at one time. If all of the buffers get full, the system can''t generate
    any more audit messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f 1`: This sets the failure mode for critical errors, and the value can be
    either 0, 1, or 2.  A `-f 0` would set the mode to silent, meaning that auditd
    wouldn''t do anything about critical errors. A `-f 1`, as we see here, tells auditd
    to only report the critical errors, and a `-f 2` would cause the Linux kernel
    to go into panic mode. According to the `auditctl` man page, anyone in a high-security
    environment would likely want to change this to `-f 2`. For our purposes though,
    `-f1` works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You could use your text editor to create a new rules file in the `/etc/audit/rules.d/`
    directory. Or, you could just redirect the `auditctl -l` output into a new file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the Bash shell doesn''t allow me to directly redirect information into
    a file in the `/etc` directory, even with sudo, I have to use the `sudo sh -c`
    command in order to execute the `auditctl` command. After restarting the auditd
    daemon, our `audit.rules` file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, the rule will take effect every time the machine gets rebooted, and every
    time that you manually restart the auditd daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vicky and Cleopatra, my solid gray kitty and my gray-and-white tabby kitty,
    have some supersensitive secrets that they need to safeguard. So, I created the
    `secretcats` group and added them to it. I then created the `secretcats` shared
    directory and set the access controls on it as I showed you how to do in [Chapter
    6](0db2a305-ea20-4b70-820a-38b1bd81dd98.xhtml), *Access Control Lists and Shared
    Directory Management*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Vicky and Cleopatra want to be absolutely sure that nobody gets into their
    stuff, so they requested that I set up an auditing rule for their directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, the `-w` denotes what we want to monitor, and the `-k` denotes the
    name of the audit rule. This time, I left out the `-p` option because I want to
    monitor for every type of access. In other words, I want to monitor for any read,
    write, attribute change, or execute actions. (Because this is a directory, the
    execute action happens when somebody tries to `cd` into the directory.) You can
    see in the `auditctl -l` output that by leaving out the `-p`, we will now monitor
    for everything. However, let''s say that I only want to monitor for when someone
    tries to `cd` into this directory. Instead, I could have made the rule look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Easy enough so far, right? Let's now look at something a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating rules to monitor when someone performs a certain action isn''t hard,
    but the command syntax is a bit trickier than what we''ve seen so far. With this
    rule, we''re going to be alerted every time that Charlie either tries to open
    a file or tries to create a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a always,exit`: Here, we have the action and the list. The `exit` part means
    that this rule will be added to the system call exit list. Whenever the operating
    system exits from a system call, the exit list will be used to determine if an
    audit event needs to be generated. The `always` part is the action, which means
    that an audit record for this rule will always be created on exit from the specified
    system call. Note that the action and list parameters have to be separated by
    a comma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-F arch=b64`: The `-F` option is used to build a rule field, and we see two
    rule fields in this command. This first rule field specifies the machine''s CPU
    architecture.  The `b64` means that the computer is running with an x86_64 CPU.
    (Whether it''s Intel or AMD doesn''t matter.) Considering that 32-bit machines
    are dying off and that Sun SPARC and PowerPC machines aren''t all that common,
    `b64` is what you''ll now mostly see.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-S openat`: The `-S` option specifies the system call that we want to monitor. 
    `openat` is the system call that either opens or creates a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-F auid=1006`: This second audit field specifies the user ID number of the
    user that we want to monitor. (Charlie''s user ID number is `1006`.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete explanation about system calls, or syscalls, is a bit too esoteric
    for our present purpose. For now, suffice it to say that a syscall happens whenever
    a user issues a command that requests that the Linux kernel provide a service.
    If you're so inclined, you can read more about syscalls at: [https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/](https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/).
  prefs: []
  type: TYPE_NORMAL
- en: 'What I''ve presented here are just a few of the many things that you can do
    with auditing rules. To see more examples, check out the `auditctl` man page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, now you're wondering, "*Now that I have these rules, how do I know when
    someone tries to violate them?*" As always, I'm glad that you asked.
  prefs: []
  type: TYPE_NORMAL
- en: Using ausearch and aureport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The auditd daemon logs events to the `/var/log/audit/audit.log` file. Although
    you could directly read the file with something like `less`, you really don't
    want to. The `ausearch` and `aureport` utilities will help you translate the file
    into a language that makes some sort of sense.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for file change alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the rule that we created that will alert us whenever
    a change is made to the `/etc/passwd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make a change to the file and look for the alert message. Rather
    than add another user, since I''m running out of cats whose names I can use, I''ll
    just use the `chfn` utility to  add contact information to the comment field for
    Cleopatra''s entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll now use `ausearch` to look for any audit messages that this event may
    have generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i`: This takes any numeric data and, whenever possible, converts it into
    text.  In this case, it takes user ID numbers and converts them to the actual
    username, which shows up here as `auid=donnie`. If I were to leave the `-i` out,
    the user information would instead show up as `auid=1000`, which is my user ID
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-k passwd_changes`: This specifies the key, or the name, of the audit rule
    for which we want to see audit messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see that there are two parts to this output. The first part just shows
    when I created the audit rule, so we''re not interested in that. In the second
    part, you can see when I triggered the rule, but it doesn''t show how I triggered
    it. So, let''s use `aureport` to see if it will give us a bit more of a clue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What's curious is that with `ausearch`, you have to specify the name, or key,
    of the audit rule that interests you after the `-k` option. With `aureport`, the
    `-k` option means that you want to look at all log entries that have to do with
    all audit rule keys. To see log entries for a specific key, just pipe the output
    into grep.  The `-i` option does the same thing that it does for `ausearch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `aureport` parses the cryptic language of the `audit.log` file
    into plain language that''s easier to understand. I wasn''t sure about what I
    had done to generate events 1 and 2, so I looked in the `/var/log/secure` file
    to see if I could find out. I saw these two entries for those times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: So, event 1 was from when I initially created the audit rule, and event 2 happened
    when I did an `ausearch` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'I must confess that the events in lines 4 and 5 are a bit of a mystery. Both
    were created when I invoked the `usermod` command, and both of them correlate
    to the secure log entries where I added Vicky and Cleopatra to the `secretcats` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The strange part about this is that adding a user to a secondary group doesn't
    modify the `passwd` file. So, I really don't know why the rule got triggered to
    create the events in lines 4 and 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with the event in line 3, which is where I used `chfn` to actually
    modify the `passwd` file. Here''s the `secure` log entry for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, out of all of these events, the one in line 3 is the only one where the
    `/etc/passwd` file actually got modified.
  prefs: []
  type: TYPE_NORMAL
- en: The `/var/log/secure` file that I keep mentioning here is on Red Hat-type operating
    systems, such as CentOS. On your Ubuntu machine, you'll see the `/var/log/auth.log` file,
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for directory access rule violations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our next scenario, we created a shared directory for Vicky and Cleopatra
    and created an audit rule for it that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So, all accesses or attempted accesses to this directory should trigger an
    alert. First, let''s have Vicky enter the `/secretcats` directory and run an `ls
    -l` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that Cleopatra has already been there and has created a file. (We''ll
    get back to that in a moment.) When an event triggers an auditd rule, it often
    creates multiple records in the `/var/log/audit/audit.log` file. If you study
    through each record for an event, you''ll see that each one covers a different
    aspect of that event. When I do an `ausearch` command, I see a total of five records
    just from that one `ls -l` operation. For the sake of saving space, I''ll just
    put the first one and the last one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In both records, you see the action that was taken (`ls -l`), and information
    about the person—or, cat, in this case—that took the action.  Since this is a
    CentOS machine, you also see SELinux context information.  In the second record,
    you also see the name of the file that Vicky saw when she did the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s say that that sneaky Charlie guy logs in and tries to get into
    the `/secretcats` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Charlie isn''t a member of the `secretcats` group and doesn''t have permission
    to go into the `secretcats` directory. So, he should trigger an alert message.
    Well, he actually triggered one that consists of four records, and I''ll again
    just list the first and the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There are two things to note here. First, just attempting to `cd` into the directory
    doesn't trigger an alert. However, using `ls` to try to read the contents of the
    directory does. Secondly, note the `Permission denied` message that shows up in
    the second record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last set of alerts that we''ll look at got created when Cleopatra created
    her `cleopatrafile.txt` file. This event triggered an alert that consists of 30
    records. Here are two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can tell that the first of these two messages happened when Cleopatra saved
    the file and exited vim because the second message shows `objtype=DELETE`, where
    her temporary vim swap file got deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this is all good, but what if this is too much information? What if you
    just want a quick and sparse list of all of the security events that got triggered
    by this rule? For that, we'll use `aureport`. We'll use it just like we did before.
  prefs: []
  type: TYPE_NORMAL
- en: 'First,  let''s pipe the `aureport` output into `less` instead of into `grep` so
    that we can see the column headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The status in the `success` column will be either `yes` or `no`, depending on
    if the user was able to successfully perform an action that violated a rule. Or,
    it could be a question mark if the event isn't the result of the rule getting
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Charlie, we see a `yes` event in line 48, with the events in lines 49 through
    51 all having a `no` status. We also see that all of these entries were triggered
    by Charlie''s use of the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You''d be tempted to think that the `yes` event in line 48 indicates that Charlie
    was successful in reading the contents of the `secretcats` directory. To analyze
    further, look at the event numbers at the end of each line and correlate them
    to the output of our previous `ausearch` command. You''ll see that event numbers
    14152 through 14155 belong to records that all have the same timestamp. We can
    see that in the first line of each record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As we noted before, the last record of this series shows `Permission denied` for
    Charlie and that's what really counts.
  prefs: []
  type: TYPE_NORMAL
- en: Space doesn't permit me to give a full explanation of each individual item in
    an audit log record. But, you can read about it here in the official Red Hat documentation: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-understanding_audit_log_files](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-understanding_audit_log_files).
  prefs: []
  type: TYPE_NORMAL
- en: Searching for system call rule violations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third rule that we created was to monitor that sneaky Charlie. This rule
    will alert us whenever Charlie tries to open or create a file. (As we noted before,
    `1006` is Charlie''s user ID number.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though Charlie hasn''t done that much on this system, this rule gives
    us a lot more log entries than what we bargained for. We''ll look at just a couple
    of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This record was generated when Charlie tried to access the `/secretcats/` directory.
    So, we can expect to see this one. But, what we didn''t expect to see was the
    exceedingly long list of records of files that Charlie indirectly accessed when
    he logged in to the system through Secure Shell. Here are just a couple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the first record, we see that Charlie accessed the `/usr/sbin/sshd` file.
    In the second, we see that he accessed the `/usr/bin/bash` file. It's not that
    Charlie chose to access those files. The operating system accessed those files
    for him in the course of just a normal login event. So as you can see, when you
    create audit rules, you have to be careful of what you wish because there's a
    definite danger that the wish might be granted. If you really need to monitor
    someone, you'll want to create a rule that won't give you quite this much information.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, we might as well see what the `aureport` output for this
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In addition to what Charlie did, we also see what Vicky and Cleopatra did. That's
    because the rule that we set for the `/secretcats/` directory generated `openat` events
    when Vicky and Cleopatra accessed, viewed, or created files in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: Generating authentication reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can generate user authentication reports without having to define any audit
    rules. Just use `aureport` with the `-au` option switch. (Remember `au`, the first
    two letters of authentication.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'For login events, this tells us whether the user logged in at the local terminal
    or remotely through Secure Shell. To see the details of any event, use `ausearch` with
    the `-a` option, followed by the event number that you see at the end of a line.
    (Strangely, the `-a` option stands for an event.) Let''s look at event number
    14122 for Charlie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this is that it really doesn''t make any sense. I''m the one
    who did the logins for Charlie, and I know for a fact that Charlie never had any
    failed logins. In fact, we can correlate this with the matching entry from the
    `/var/log/secure` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The time stamps for these two entries are a few seconds later than the timestamp
    for the `ausearch` output, but that's okay. There's nothing in this log file to
    suggest that Charlie ever had a failed login, and these two entries clearly show
    that Charlie's login really was successful. The lesson here is that when you see
    something strange in either the `ausearch` or `aureport` output, be sure to correlate
    it with the matching entry in the proper authentication log file to get a better
    idea of what's going on. (By *authentication log file*, I mean `/var/log/secure` for
    Red Hat-type systems and `/var/log/auth.log` for Ubuntu systems. The names may
    vary for other Linux distros.)
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined rules sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `/usr/share/doc/audit-version_number/` directory of your CentOS machine,
    you''ll see some premade rule sets for different scenarios. Once you install auditd
    on Ubuntu, you''ll have audit rules for it too, but the location is different
    for Ubuntu 16.04 and Ubuntu 17.10.  On Ubuntu 16.04, the rules are in the `/usr/share/doc/auditd/examples/` directory.
    On Ubuntu 17.10, they''re in the `/usr/share/doc/auditd/examples/rules/` directory.
    In any case, some of the rule sets are common among all three of these distros.
    Let''s look on the CentOS machine to see what we have there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The three files I want to focus on are the `nispom`, `pci-dss`, and `stig` files.
    Each of these three rule sets is designed to meet the auditing standards of a
    particular certifying agency. In order, these rules sets are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nispom`: The National Industrial Security Program—you''ll see this rule set
    used at either the U.S. Department of Defense or its contractors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pci-dss`: Payment Card Industry Data Security Standard—if you work in the
    banking or financial industries, or even if you''re just running an online business
    that accepts credit cards, you''ll likely become very familiar with this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stig`: Security Technical Implementation Guides—if you work for the U.S. Government
    or possibly other governments, you''ll be dealing with this one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use one of these rules sets, copy the appropriate files over to the `/etc/audit/rules.d/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Then, restart the auditd daemon to read in the new rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Red Hat or CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there's always the chance that a particular rule in one of these
    sets might not work for you or that you might need to enable a rule that's currently
    disabled. If so, just open the rules file in your text editor, and comment out
    what doesn't work or uncomment what you need to enable.
  prefs: []
  type: TYPE_NORMAL
- en: Even though auditd is very cool, bear in mind that it only alerts you about
    potential security breaches. It doesn't do anything to harden the system against
    them.
  prefs: []
  type: TYPE_NORMAL
- en: That pretty much wraps it up for our discussion of the auditd system. Give it
    a go and see what you think.
  prefs: []
  type: TYPE_NORMAL
- en: Applying OpenSCAP policies with oscap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SCAP, the **Security Content Automation Protocol** (**SCAP**), was created
    by the U.S. National Institute of Standards and Technology. It consists of hardening
    guides, hardening templates, and baseline configuration guides for setting up
    secure systems. OpenSCAP is a set of free open source software tools that can
    be used to implement SCAP. It consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Security profiles that you can apply to a system. There are different profiles
    for meeting the requirements of several different certifying agencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security guides to help with the initial setup of your system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `oscap` command-line utility to apply security templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Red Hat-type systems that have a desktop interface, you have SCAP Workbench,
    a GUI-type utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install OpenSCAP on either the Red Hat or the Ubuntu distros, but it's
    much better implemented on the Red Hat distros. For one thing, the Red Hat world
    has the very cool SCAP Workbench, but the Ubuntu world doesn't. When you install
    a Red Hat-type operating system, you can choose to apply a SCAP profile during
    installation. You can't do that with Ubuntu. Finally, the Red Hat distros come
    with a fairly complete set of ready-to-use profiles. Curiously, Ubuntu only comes
    with profiles for older versions of Fedora and Red Hat, which aren't usable on
    an Ubuntu system. If you want usable profiles for Ubuntu, you'll have to download
    them from the OpenSCAP website and manually install them yourself. (We'll cover
    that in the last section of the chapter.) Having said this, let's see how to install
    OpenSCAP and how to use the command-line utility that's common to both of our
    distros.  Since CentOS has the more complete implementation, I'll use it for the
    demos.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenSCAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On your CentOS machine, assuming that you didn''t install OpenSCAP during operating
    system installation, follow this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Ubuntu machine, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the profile files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the CentOS machine, you''ll see the profile files in the `/usr/share/xml/scap/ssg/content/` directory.
    On the Ubuntu machine, you''ll see what few profiles there are in the `/usr/share/openscap/` directory.
    The profile files are in the `.xml` format, and each one contains one or more
    profiles that you can apply to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The command-line utility for working with OpenSCAP is `oscap`. We can use this
    with the `info` switch to view information about any of the profile files. Let''s
    look at the `ssg-centos7-xccdf.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this file contains 11 different profiles that we can apply to
    the system. Among them, you see profiles for `stig` and `pci-dss`, just as we
    had for the auditing rules. And, if you're running Docker containers, the `docker-host` profile
    would be extremely handy.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's say that we need to ensure that our systems are compliant with Payment
    Card Industry standards. We'll first scan the CentOS machine to see what needs
    remediation. (Note that the following command is very long and wraps around on
    the printed page.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As we always like to do,  let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xccdf eval`: The Extensible Configuration Checklist Description is one of
    the languages with which we can write security profile rules. We''re going to
    use a profile that was written in this language to perform an evaluation of the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--profile pci-dss`: Here, I specified that I want to use the Payment Card
    Industry Data Security Standard profile to evaluate the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--results scan-xccdf-results.xml`: I''m going to save the scan results to
    this `.xml` format file. When the scan has finished, I''ll create a report from
    this file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/share/xml/scap/ssg/content/ssg-centos7-xccdf.xml`: This is the file that
    contains the `pci-dss` profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the scan progresses, the output will get sent to the screen as well as to
    the designated output file.  It''s a long list of items, so I''ll only show you
    a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: So, we have GPG encryption installed, which is good. But, it's a bad thing that
    we don't have the AIDE intrusion detection system installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I''ve run the scan and created an output file with the results, I
    can build my report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This extracts the information from the `.xml` format file, which isn't meant
    for humans to read, and transfers it to a `.html` file that you can open in your
    web browser. (For the record, the report says that there are total 20 problems
    that need to be fixed.)
  prefs: []
  type: TYPE_NORMAL
- en: Remediating the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have 20 problems that we need to fix before our system can be considered
    as compliant with Payment Card Industry standards. Let''s see how many of them
    that `oscap` can fix for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This is the same command that I used to perform the initial scan, except that
    I added the `--remediate` option, and I'm saving the results to a different file.
    You'll want to have a bit of patience when you run this command, because fixing
    some problems involves downloading and installing software packages. In fact,
    even as I type this, `oscap` is busy downloading and installing the missing AIDE
    intrusion detection system package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, the remediation is still running, but I can still show you some of the
    things that got fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of errors because of things that `oscap` couldn't fix, but
    that's normal.  At least you know about them so that you can try to fix them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, check this out. Do you remember how in [Chapter 2](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml), *Securing
    User Accounts*, I made you jump through hoops to ensure that users had strong
    passwords that expire on a regular basis? Well, by applying this OpenSCAP profile,
    you get all that fixed for you automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: So yeah, OpenSCAP is pretty cool, and even the command-line tools aren't hard
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using SCAP Workbench
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Red Hat and CentOS machines with a desktop environment installed, we have
    SCAP Workbench. However, if the last time you ever worked with SCAP Workbench
    was on Red Hat/CentOS 7.0 or Red Hat/CentOS 7.1, you were likely quite disappointed.
    Indeed, the early versions of the Workbench were so bad that they weren't even
    usable. Thankfully, things greatly improved with the introduction of Red Hat 7.2
    and CentOS 7.2\. Now, the Workbench is quite the nice little tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get it on your CentOS machine, just use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, the package name is just `scap-workbench` instead of `openscap-workbench`.
    I don't know why, but I do know that you'll never find it if you're searching
    for `openscap` packages.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get it installed, you'll see its menu item under the System Tools menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26aaca25-75db-4280-974f-2a44a9db0dca.png)'
  prefs: []
  type: TYPE_IMG
- en: When you first open the program, you would think that the system would ask you
    for a root or sudo password. But, it doesn't. We'll see in a moment if that affects
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing you''ll see on the opening screen is a drop-down list for you to
    select the type of content that you want to load. I''ll select CentOS7 and then
    click on the Load content button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3459006f-dc60-4e4b-b27c-ba2e94233104.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you''ll see in the top panel where you can select the desired profile.
    You can also choose to customize the profile, and whether you want to run the
    scan on the local machine or on a remote machine. In the bottom pane, you''ll
    see a list of rules for that profile. You can expand each rule item to get a description
    of that rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abfefe14-1610-4ffe-b02a-9167e174e0a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s click that Scan button to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24d3c1d1-303e-481e-a3f0-ab80761c44ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Cool.  As I had hoped, it prompts you for your sudo password. Beyond that, I'll
    leave it to you to play with it. It's just another one of those GUI-thingies,
    so the rest of it should be fairly easy to figure out.
  prefs: []
  type: TYPE_NORMAL
- en: More about OpenSCAP profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now you're saying, "*Okay, this is all good, but how do I find out what's
    in these profiles and which one I need?*" Well, there are several ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first way, which I've just shown you, is to install the SCAP Workbench on
    a machine with a desktop interface and read through the descriptions of all the
    rules for each profile.
  prefs: []
  type: TYPE_NORMAL
- en: The second way, which might be a bit easier, is to go to the OpenSCAP website
    and look through the documentation that they have there.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find information about the available OpenSCAP profiles at [https://www.open-scap.org/security-policies/choosing-policy/.](https://www.open-scap.org/security-policies/choosing-policy/)
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as knowing which profile to choose, there are a few things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If you work in the financial sector or in a business that does online financial
    transactions, then go with the `pci-dss` profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you work for a government agency, especially if it's the U.S. government,
    then go with either the `stig` profile or the `nispom` profile, as dictated by
    the particular agency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither of these two considerations applies to your situation, then you'll
    just want to do some research and planning, in order to figure out what really
    needs to be locked down. Look through the rules in each profile and read through
    the documentation at the OpenSCAP website to help decide what you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next thing on your mind is, "*What about Ubuntu?  We''ve already seen that
    the profiles that come with Ubuntu are useless because they''re for RHEL and Fedora.*"
    That''s true, but you''ll find profiles for various different distros, including
    for the Long Term Support versions of Ubuntu, at the OpenSCAP website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb3ec2e6-131d-444a-aea6-1924176405a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying an OpenSCAP profile during system installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that I love about the Red Hat folk is that they totally get
    this whole security thing. Yeah, we can lock down other distros and make them
    more secure, as we've already seen. But, with Red Hat distros, it's a bit easier.
    For a lot of things, the maintainers of the Red Hat-type distros have set secure
    default options that aren't securely set on other distros. (For example, Red Hat
    distros are the only ones that come with users' home directories locked down by
    default.) For other things, the Red Hat-type distros come with tools and installation
    options that help make life easier for a busy, security-conscious administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you install a Red Hat 7-type distro, you''ll be given the chance to apply
    an OpenSCAP profile during the operating system installation. Here on this CentOS
    7 installer screen, you see the option to choose a security profile at the lower
    right-hand corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ef9ba2c-943b-4540-bc12-8be66cddc9b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All you have to do is to click on that and then choose your profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4ccb457-c84a-4702-acd2-93e90b799d51.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, that pretty much wraps it up for our discussion of OpenSCAP. The only
    thing left to add is that, as great as OpenSCAP is, it won't do everything. For
    example, some security standards require that you have certain directories, such
    as `/home/` or `/var/`, on their own separate partitions. An OpenSCAP scan will
    alert you if that's not the case, but it can't change your existing partitioning
    scheme. So for things like that, you'll need to get a checklist from the governing
    body that dictates your security requirements and do a bit of advanced work before
    you even touch OpenSCAP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter, and we saw some really cool stuff.
    We began by looking at a couple of antivirus scanners so that we can prevent infecting
    any Windows machines that access our Linux servers. In the Rootkit Hunter section,
    we saw how to scan for those nasty rootkits. It's important to know how to audit
    systems, especially in high-security environments, and we saw how to do that.
    Finally, we wrapped things up with a discussion of hardening our systems with
    OpenSCAP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at vulnerability scanning and intrusion detection.
    I'll see you there.
  prefs: []
  type: TYPE_NORMAL
