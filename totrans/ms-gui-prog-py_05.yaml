- en: Building Applications with QMainWindow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Qt widgets can take us a long way when building simple forms, but full
    applications include features such as menus, toolbars, dialog boxes, and other
    functionality that can be tedious and tricky to build from scratch. Fortunately,
    PyQt provides us with ready-made classes for these standard components to make
    building applications relatively painless.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QMainWindow` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard dialog boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving settings with `QSettings`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will require the same setup as shown in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*. You may also wish to reference the code found in
    our GitHub repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5OGnq](http://bit.ly/2M5OGnq)
  prefs: []
  type: TYPE_NORMAL
- en: The QMainWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we've been using the humble `QWidget` as the base class for our
    top-level window. This works well for simple forms, but it lacks many of the features
    that we might expect from an application's main window, such as menu bars or toolbars.
    Qt provides the `QMainWindow` class to address this need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a copy of the application template from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and let''s make a small but crucial change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Instead of inheriting from `QWidget`, we'll inherit from `QMainWindow`. As you'll
    see, this will change the way we have to code our GUI, but it will also add a
    number of nice features to our main window.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore these new features, let''s build a simple plain text editor. The
    following screenshot shows what our completed editor will look like, along with
    labels showing the main components of the `QMainWindow` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67b30b0a-e7d2-42cf-8b9d-3d2f92ee0828.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your updated template, copy it to a new file called `text_editor.py`, and
    open the new file in your code editor. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Setting a central widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QMainWindow` is divided into several sections, the most important of which
    is the **central widget**. This is a single widget that represents the main business
    part of the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set this by passing a reference to any widget to the `QMainWindow.setCentralWidget()`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There can be only one central widget, so in a more complex application (such
    as a data entry app, for instance) it will more likely be a `QWidget` object on
    which you've arranged a more complex GUI; for our simple text editor, a single
    `QTextEdit` widget will suffice. Notice that we do not set a layout on the `QMainWindow`;
    doing so would break the preset arrangement of components.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a status bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **status bar** is a strip across the bottom of the application window designed
    for displaying short text messages and informational widgets. In Qt, a status
    bar is a `QStatusBar` object that we can assign to the main window's `statusBar`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create one like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, there's no need to go to so much trouble; the `QMainWindow` object's
    `statusBar()` method automatically creates a new status bar if there isn't one,
    or returns the existing one if there is.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can reduce all that code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `showMessage()` method does exactly what it says, displaying the given string
    in the status bar. This is by far the most common use of the status bar; however,
    `QStatusBar` objects can also contain other widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add a widget that keeps track of our character count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `QLabel` is updated with the number of characters entered whenever our
    text changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we''ve added it directly to the status bar, without referencing a
    layout object; `QStatusBar` has its own methods for adding or inserting widgets
    that come in two flavors: **regular** and **permanent**. In regular mode, widgets
    can be covered up if the status bar is sent a long message to display. In permanent
    mode, they will remain visible. In this case, we used the `addPermanentWidget()`
    method to add `charcount_label` in permanent mode so it won''t be covered up by
    a long text message.'
  prefs: []
  type: TYPE_NORMAL
- en: The methods for adding a widget in regular mode are `addWidget()` and `insertWidget()`;
    for permanent mode, use `addPermanentWidget()` and `insertPermanentWidget()`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **application menu** is a crucial feature for most applications, offering
    access to all the application's functionality in hierarchically organized drop-down
    menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create on easily using the `QMainWindow.menuBar()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `menuBar()` method returns a `QMenuBar` object, and as with `statusBar()`,
    this method will give us the window's existing menu if it exists, or simply create
    a new one if it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the menu is blank, but we can add submenus using the menu bar''s
    `addMenu()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`addMenu()` returns a `QMenu` object, which represents a drop-down submenu.
    The string passed into the method will be used to label the menu in the main menu
    bar.'
  prefs: []
  type: TYPE_NORMAL
- en: Certain platforms, such as macOS, will not display empty submenus. See the *Menus
    on macOS* section for more information on building menus in macOS.
  prefs: []
  type: TYPE_NORMAL
- en: To populate these menus with items, we need to create some **actions**. Actions
    are simply objects of the `QAction` class that represent things our program can
    do. To be useful, a `QAction` object needs at least a name and a callback; they
    can optionally define a keyboard shortcut and icon for the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to create actions is to call a `QMenu` object''s `addAction()` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've created two actions called `Open` and `Save`. Neither of them actually
    does anything, because we haven't assigned callback methods, but if you run your
    application script, you'll see that the file menu does indeed have two items listed,
    `Open` and `Save`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create items that actually do something, we can pass in a second argument
    containing a Python callable or Qt slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For cases where we want more control, it''s possible to create a `QAction` object
    explicitly and add it to the menu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`QAction` objects have a `triggered` signal that must be connected to a callable
    or slot for the action to have any effect. This is handled automatically when
    we use the `addAction()` method of creating actions, but it must be done manually
    when creating `QAction` objects explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: Although not technically required, it's very important to pass in a parent widget
    when creating a `QAction` object explicitly. Failing to do so will result in the
    item not showing up, even when you add it to the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Menus on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QMenuBar` wraps the OS''s native menu system by default. On macOS, the native
    menu system has a few peculiarities that you need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: macOS uses a **global menu**, meaning the menu bar is not part of the application
    window but is attached to the bar at the top of the desktop. By default, your
    main window's menu bar will be used as the global menu. If you have an application
    with multiple main windows and you want them all to use the same menu bar, do
    not use `QMainWindow.menuBar()` to create the menu bar. Instead, create a `QMenuBar`
    object explicitly and assign it to the main window objects you create using the
    `setMenuBar()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS also has a number of default submenus and menu items. To access these
    items, simply use the same when adding a submenu. When adding a submenu see the
    *Further reading* section for more details on macOS menus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned previously, macOS will not display an empty submenu on the global
    menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you find these issues too problematic for your application, you can always
    instruct Qt not to use the native menu system, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will place the menu bar in the application window as it is on other platforms
    and remove the platform-specific issues. However, be aware that this approach
    breaks the workflow typical to macOS software and users may find it jarring.
  prefs: []
  type: TYPE_NORMAL
- en: More information about Qt menus on macOS can be found at [https://doc.qt.io/qt-5/macos-issues.html#menu-bar](https://doc.qt.io/qt-5/macos-issues.html#menu-bar).
  prefs: []
  type: TYPE_NORMAL
- en: Adding toolbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **toolbar** is a long row of buttons often used for editing commands or similar
    actions. Unlike main menus, toolbars are not hierarchical and the buttons are
    typically only labeled with an icon.
  prefs: []
  type: TYPE_NORMAL
- en: '`QMainWindow` allows us to add multiple toolbars to our application using the
    `addToolBar()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `addToolBar()` method creates and returns a `QToolBar` object. The string
    passed into the method becomes the toolbar's title.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add `QAction` objects much like we can to a `QMenu` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just as with a menu, we can add `QAction` objects or just the information to
    build an action (title, callback, and other).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application; it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f019127f-1cea-4671-84cd-3379db227da6.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the title of the toolbar is not displayed on it. However, if you right-click
    the toolbar area, you'll see a pop-up menu containing all the toolbar titles with
    checkboxes that allow you to show or hide any of the application's toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, toolbars can be torn from the application and left floating or
    docked to any of the four edges of the application. This can be disabled by setting
    the `movable` and `floatable` properties to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can also restrict the sides of the window to which the bar can be docked
    by setting its `allowedAreas` property to a combination of flags from the `QtCore.Qt.QToolBarAreas`
    enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s restrict our toolbar to the top and bottom areas only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our toolbar currently has text-labeled buttons, but normally a toolbar would
    have icon-labeled buttons. To show how that works, we'll need some icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract some icons from the built-in style, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about how this code works right now; a complete discussion of styles
    and icons will come along in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*. For now, just understand that `open_icon` and `save_icon`
    are `QIcon` objects, which is how Qt handles icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'These can be attached to our `QAction` objects, which can be then attached
    to the toolbar, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, that looks a bit better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7b1be327-2b73-4735-a461-fc53946a9f16.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice when you run this that the File | Open option in the menu also now has
    an icon. Because both use the `open_action` object, any changes we make to that
    action object will carry to all uses of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon objects can be passed into the toolbar''s `addAction` method as the first
    argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This adds a Save action to the toolbar with an icon and a rather useless callback.
    Notice that this time, the File | Save action in the menu did not get an icon;
    despite the fact that we used the same label text, calling `addAction()` with
    discrete arguments in both places results in two distinct and unrelated `QAction`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, just like with the menu, we can create `QAction` objects explicitly
    and add them to the toolbar, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To synchronize actions across multiple action containers (toolbars, menus, and
    so on), either explicitly create `QAction` objects or save the references returned
    from `addAction()` to make sure you're adding the same action objects in each
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add as many toolbars as we wish to our application and attach them to
    whichever side of the application we wish. To specify a side, we have to use an
    alternative form of `addToolBar()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To use this form of `addToolBar()`, we have to create the toolbar first then
    pass it in along with a `QtCore.Qt.ToolBarArea` constant.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dock widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dock widgets** are similar to toolbars, but they sit between the toolbar
    areas and the central widget and are able to contain any kind of widget.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a dock widget is much like explicitly creating a toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like toolbars, dock widgets by default can be closed, floated, or moved to another
    side of the application. To change whether a dock widget can be closed, floated,
    or moved, we have to set its `features` property to a combination of `QDockWidget.DockWidgetFeatures`
    flag values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s make it so the user cannot close our dock widget, by adding
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've set `features` to `DockWidgetMovable` and `DockWidgetFloatable`. Since
    `DockWidgetClosable` is missing here, the user won't be able to close the widget.
  prefs: []
  type: TYPE_NORMAL
- en: The dock widget is designed to hold a single widget that is set using the `setWidget()`
    method. As with our main application's `centralWidget`, we typically will set
    this to a `QWidget` containing some kind of form or other GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a form to place in the dock widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `addStretch()` method can be called on a layout to add an expanding `QWidget`
    that pushes the other widgets together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a fairly simple form containing two `QLineEdit` widgets and a button.
    When the button is clicked, it calls the main window''s `search_and_replace()`
    method. Let''s code that quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method simply retrieves the contents of the two-line edits; then, if there
    is content in the first, it replaces all instances of the first text with the
    second in the text edit's contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program at this point and you should see our dock widget on the left
    side of the application, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/755c0898-64be-465f-8532-8db0e1916875.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the icon in the upper right of the dock widget. This allows the user to
    detach and float the widget outside the application window.
  prefs: []
  type: TYPE_NORMAL
- en: Other QMainWindow features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we've covered its main components, the `QMainWindow` offers many other
    features and configuration options that you can explore in its documentation at
    [https://doc.qt.io/qt-5/qmainwindow.html](https://doc.qt.io/qt-5/qmainwindow.html).
    We may touch on some of these in future chapters, as we will make extensive use
    of `QMainWindow` from here onward.
  prefs: []
  type: TYPE_NORMAL
- en: Standard dialog boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dialog boxes** are commonly required in applications, whether to ask a question,
    present a form or merely alert the user to some information. Qt provides a wide
    variety of ready-made dialog boxes for common situations, as well as the capability
    to define custom dialog boxes of our own. In this section, we''ll look at some
    of the more commonly used dialog box classes and take a stab at designing our
    own.'
  prefs: []
  type: TYPE_NORMAL
- en: QMessageBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QMessageBox` is a simple dialog box used mainly to display short messages
    or ask yes-or-no questions. The simplest way to use `QMessageBox` is to take advantage
    of its convenient static methods, which create and show a dialog box with minimal
    fuss.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The six static methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Type | Dialog |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `about()` | Modeless | Shows an **About** dialog box for your application
    with the given text. |'
  prefs: []
  type: TYPE_TB
- en: '| `aboutQt()` | Modeless | Shows an **About** dialog box for Qt. |'
  prefs: []
  type: TYPE_TB
- en: '| `critical()` | Modal | Show a critical error message with the provided text.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `information()` | Modal | Show an informational message with the provided
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `warning()` | Modal | Show a warning message with the provided text. |'
  prefs: []
  type: TYPE_TB
- en: '| `question()` | Modal | Asks the user a question. |'
  prefs: []
  type: TYPE_TB
- en: The main difference between most of these boxes are the default icons, the default
    buttons, and the modality of the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Dialog boxes can be either **modal** or **modeless**. Modal dialog boxes prevent
    the user from interacting with any other part of the program and block program
    execution while displayed, and they can return a value when finished. Modeless
    dialog boxes do not block execution, but they also do not return a value. In the
    case of a modal `QMessageBox`, the return value is an `enum` constant representing
    the button pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `about()` method to add an **About** message to our application.
    First, we''ll create a callback to display the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The **About** dialog is modeless, so it's really just a way to display information
    passively. The arguments are, in order, the dialog's parent widget, the dialog's
    window title text, and the dialog's main text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the constructor, let''s add a menu action to call this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Modal dialog boxes can be used to retrieve a response from the user. For instance,
    we could warn the user about the unfinished nature of our editor and see whether
    they are really intent on using it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All modal dialog boxes return a Qt constant corresponding to the button the
    user pushed; by default, `question()` creates a dialog box with the `QMessageBox.Yes`
    and `QMessageBox.No` button values so we can test the response and react accordingly.
    The buttons presented can also be overridden by passing in a fourth argument containing
    multiple buttons combined with the pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can change `No` to `Abort`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the static `QMessageBox` methods do not provide enough flexibility, you
    can also explicitly create a `QMessageBox` object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can set quite a few properties on the message box; these
    are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `windowTitle` | The title printed in the taskbar and title bar of the dialog.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | The text displayed in the dialog. |'
  prefs: []
  type: TYPE_TB
- en: '| `informativeText` | A longer, explanatory piece of text displayed under the
    `text` string often displayed in a smaller or lighter font face. |'
  prefs: []
  type: TYPE_TB
- en: '| `detailedText` | Text that will be hidden behind a Show details button and
    displayed in a scrolling textbox. Useful for debugging or log output. |'
  prefs: []
  type: TYPE_TB
- en: '| `windowModality` | Used to set whether the message box is modal or modeless.
    Requires a `QtCore.Qt.WindowModality` constant. |'
  prefs: []
  type: TYPE_TB
- en: We can also add any number of buttons to the dialog box using the `addButton()`
    method and then display the dialog box by calling its `exec()` method. If we configured
    the dialog box to be modal, this method will return the constant matching the
    button that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: QFileDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications commonly need to open or save files, and users need an easy way
    to browse and select those files. Qt provides us with the `QFileDialog` class
    to meet this need.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with `QMessageBox`, the `QFileDialog` class contains several static
    methods that display an appropriate modal dialog box and return the value selected
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table shows the static methods and their intended use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Returns | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getExistingDirectory` | String | Select an existing directory path. |'
  prefs: []
  type: TYPE_TB
- en: '| `getExistingDirectoryUrl` | `QUrl` | Select an existing directory URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOpenFileName` | String | Select an existing filename path to open. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOpenFileNames` | List | Select multiple existing filename paths to open.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getOpenFileUrl` | `QUrl` | Select an existing filename URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `getSaveFileName` | String | Select a new or existing filename path to save
    to. |'
  prefs: []
  type: TYPE_TB
- en: '| `getSaveFileUrl` | `QUrl` | Select a new or existing URL. |'
  prefs: []
  type: TYPE_TB
- en: On platforms that support it, the URL versions of these methods allow for selecting
    remote files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how file dialog boxes work, let''s create the ability to open a file
    in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`getOpenFileName()` returns a tuple containing the filename selected and the
    selected file type filter. If the user cancels the dialog, an empty string is
    returned for the filename, and our method will exit. If we receive a filename,
    we attempt to open the file and write into it the contents of our `textedit` widget.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we aren't using the second value returned from the method, we're assigning
    it to the `_` (underscore) variable. This is a standard Python convention for
    naming variables you don't intend to use.
  prefs: []
  type: TYPE_NORMAL
- en: '`getOpenFileName()` has a number of arguments for configuring the dialog, all
    of which are optional. In order, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The parent widget
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caption, used in the window title
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The starting directory, as a path string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filters available for the file type filter dropdown
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default selected filter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Option flags
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s configure our file dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`QDir.homePath()` is a static method that returns the user''s home directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the filters are specified as a single string; each filter is a
    description plus a wildcard string in parenthesis, and the filters are separated
    by double semi-colons. This results in a filter dropdown that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cf80d69c-0bbc-402c-8a6b-ec719c7d9afe.png)'
  prefs: []
  type: TYPE_IMG
- en: Last, of all, we can specify a collection of option flags combined using the
    pipe operator. In this case, we're telling Qt not to use the native OS file dialog
    boxes and not to resolve symbolic links (both of which it does by default). See
    the `QFileDialog` documentation at [https://doc.qt.io/qt-5/qfiledialog.html#Option-enum](https://doc.qt.io/qt-5/qfiledialog.html#Option-enum)
    for a complete list of option flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The save file dialog box works much the same way but provides an interface
    more appropriate for saving a file. We can implement our `saveFile()` method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Other `QFileDialog` convenience methods work the same way. As with `QMessageBox`,
    it's also possible to explicitly create a `QFileDialog` object, configure its
    properties manually, and then display it with its `exec()` method. However, this
    is rarely necessary as the built-in methods are adequate for most file-selection
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, don''t forget to add actions to call these methods back in
    the `MainWindow` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: QFontDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides a number of other convenient selection dialog boxes similar to the
    `QFileDialog`; one such dialog box is the `QFontDialog`, which allows users to
    select and configure various aspects of a text font.
  prefs: []
  type: TYPE_NORMAL
- en: Like the other dialog box classes, this is most easily used by calling a static
    method to display the dialog box and return the user's selection, in this case,
    the `getFont()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a callback method to our `MainWindow` class to set the editor font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`getFont` takes the current font as an argument, which allows it to set the
    selected font to whatever is current (if you neglect to do this, the dialog box
    will default to the first font listed).'
  prefs: []
  type: TYPE_NORMAL
- en: It returns a tuple containing the selected font and a Boolean indicating whether
    the user clicked OK. The font is returned as a `QFont` object, which encapsulates
    not only the font family but also the style, size, effects, and writing system
    of the font. Our method can pass this object back to the `QTextEdit` object's
    `setCurrentFont()` slot to set its font.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `QFileDialog`, Qt tries to use the operating system''s native font
    dialog box if it has one; otherwise, it will use its own widget. You can force
    it to use the Qt version of the dialog box by passing in the `DontUseNativeDialog`
    option to the `options` keyword argument, as we''ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We've also passed in an option here to limit the dialog box to mono-spaced fonts.
    See the Qt documentation on `QFontDialog` at [https://doc.qt.io/qt-5/qfontdialog.html#FontDialogOption-enum](https://doc.qt.io/qt-5/qfontdialog.html#FontDialogOption-enum)
    for more information about the available options.
  prefs: []
  type: TYPE_NORMAL
- en: Other dialog boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt contains other dialog box classes for selecting colors, requesting input
    values, and more. All of these work more or less like the file and font dialog
    boxes, and they descend from the `QDialog` class. We can subclass `QDialog` ourselves
    to create a custom dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we want to have a dialog box for entering our settings.
    We could start building it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code isn''t far removed from pop-up boxes we''ve made in past chapters
    using `QWidget`. However, by using `QDialog` we get a few things for free, namely
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: We get `accept` and `reject` slots to which we can connect the appropriate buttons.
    By default, these cause the window to close and emit either an `accepted` or `rejected`
    signal respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also get the `exec()` method that returns a Boolean value indicating whether
    the dialog box was accepted or rejected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily set the dialog box to be modal or modeless, by passing the appropriate
    values to the `super()` constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QDialog` gives us a lot of flexibility on how to make use of the data entered
    by the user. We could use a signal to emit the data or override `exec()` to return
    the data, for instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, since we''re passing in a mutable `dict` object, we''ll override
    `accept()` to alter that `dict` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `MainWindow` class, let''s create a property and method to use
    the new dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using a `QDialog` class is as simple as creating an instance of the dialog box
    class and calling `exec()`. Since we're editing our `settings` dict directly,
    in this case, we don't need to worry about connecting the `accepted` signal or
    using the output of `exec()`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving settings with QSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications of any reasonable size are likely to accumulate settings that need
    to be stored between sessions. Saving these settings usually involves a lot of
    tedious work with file operations and data serialization, and becomes even more
    complex when we want to do it in a way that works well across platforms. Qt rescues
    us from this work with its `QtCore.QSettings` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `QSettings` class is a simple key-value data store that is automatically
    persisted in a platform-appropriate way. For example, on Windows, the settings
    are stored in the registry database, while on Linux they are placed in a plain-text
    configuration file under `~/.config`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's replace the settings `dict` object we created in our text editor with
    a `QSettings` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `QSettings` object, we need to pass in a company name and application
    name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These strings will determine the registry key or file path where the settings
    will be stored. On Linux, for example, this settings file will be saved at `~/.config/Alan
    D Moore/text editor.conf`. On Windows, it will be stored in the registry at `HKEY_CURRENT_USER\Alan
    D Moore\text editor\`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can query the value of any setting using the object''s `value()` method;
    for instance, we can make our startup warning dialog boxes conditional on the
    `show _warnings` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The arguments to `value()` are the key string, the default value if the key
    is not found, and the `type` keyword argument, which tells `QSettings` how to
    interpret the saved value. The `type` argument is crucial; not all platforms can
    adequately represent all data types in an unambiguous way. Boolean values, for
    instance, are returned as the strings `true` and `false` if the data type is not
    specified, both of which are `True` in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the value of a key uses the `setValue()` method, as shown here in the
    `SettingsDialog.accept()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't have to do anything to store these values to disk; they are
    automatically synced to disk periodically by the Qt event loop. They are also
    read automatically from disk the moment the `QSettings` object is created. Simply
    replacing our original `settings` dict with a `QSettings` object is enough to
    give us persistent settings without writing a single line of file I/O code!
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of QSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As powerful as they are, `QSettings` objects can't store just anything. All
    values in the settings object are stored as `QVariant` objects, so only objects
    that can be cast to `QVariant` can be stored. This encompasses a long list of
    types, including nearly any Python built-in type and most of the data classes
    from `QtCore`. Even function references can be stored (though not the function
    definitions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, in the event that you try to store an object that cannot be
    properly stored, `QSettings.setValue()` will neither throw an exception or return
    an error. It will print a warning to the console and store something that will
    likely not be useful, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In general, if you're storing objects that clearly represent data, you shouldn't
    have problems.
  prefs: []
  type: TYPE_NORMAL
- en: The other major limitation of the `QSettings` object is its inability to automatically
    identify the data type of some stored objects, as we saw with our Boolean value.
    For this reason, it's critical to pass a `type` argument when dealing with anything
    that is not a string value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about PyQt classes that help construct complete
    applications. You learned about the `QMainWindow` class, its menus, status bar,
    toolbars, and dock widgets. You also learned about standard dialog boxes and message
    boxes derived from `QDialog`, and how to store application settings with `QSettings`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about the model-view classes in Qt, which will
    help us separate our concerns and create more robust application designs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to use `QMainWindow` with the `calendar_app.py` script from [Chapter
    3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling Events with Signals
    and Slots*. How would you go about converting it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're working on an app and have added the submenu names to the menu bar but
    not populated any of them with items. Your coworker says that none of the menu
    names are appearing on his desktop when they test it. Your code looks correct;
    what is probably going on here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're developing a code editor and want to create a sidebar panel for interacting
    with a debugger. Which `QMainWindow` feature would be most appropriate for this
    task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code isn't working correctly; it proceeds no matter what is clicked.
    Why doesn't it work, and how do you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You're building a custom dialog box by subclassing `QDialog`. You need to get
    information entered into the dialog box back to the main window object. Which
    of these approaches will not work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass in a mutable object and use the dialog's `accept()` method to alter its
    values.
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the objects `accept()` method and have it `return` a dict of the entered
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the dialog's `accepted` signal with one that passes along a dict of
    the entered values. Connect this signal to a callback in your main window class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''re writing a photo editor called **SuperPhoto** on Linux. You''ve written
    the code and saved the user settings, but looking in `~/.config/` you can''t find
    `SuperPhoto.conf`. Look at the code and determine what went wrong:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You're saving preferences from a settings dialog, but for some reason, the settings
    being saved are coming back very strangely. What is wrong here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt's `QMainWindow` documentation can be found at [https://doc.qt.io/qt-5/qmainwindow.html](https://doc.qt.io/qt-5/qmainwindow.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of using `QMainWindow` can be found at [https://github.com/pyqt/examples/tree/master/mainwindows](https://github.com/pyqt/examples/tree/master/mainwindows).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple's Human Interface Guidelines for macOS include guidance on how to structure
    the application menus. These can be found at [https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-anatomy/](https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-anatomy/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft offers guidance for designing menus for Windows applications at [https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-menus](https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-menus).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyQt offers some examples of dialog box usage at [https://github.com/pyqt/examples/tree/master/dialogs](https://github.com/pyqt/examples/tree/master/dialogs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMainWindow` can also be used to create **Multiple Document Interfaces** (**MDIs**).
    For more information on how to build an MDI application, see [https://www.pythonstudio.us/pyqt-programming/multiple-document-interface-mdi.html](https://www.pythonstudio.us/pyqt-programming/multiple-document-interface-mdi.html)
    and the example code at [https://doc.qt.io/qt-5/qtwidgets-mainwindows-mdi-example.html](https://doc.qt.io/qt-5/qtwidgets-mainwindows-mdi-example.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
