- en: Chapter 8. Put on the Monitor's Cap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Disk usage hacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the execution time for a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about logged users, boot logs, failure boots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the 10 most frequently-used commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing the top 10 CPU consuming process in 1 hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring command outputs with watch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging access to files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logfile management with logrotate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging with syslog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring user logins to find intruders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote disk usage health monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out active user hours on a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operating system consists of a collection of system software, designed for
    different purposes, serving different task sets. Each of these programs requires
    to be monitored by the operating system or the system administrator in order to
    know whether it is working properly or not. We will also use a technique called
    logging by which important information is written to a file while the application
    is running. By reading this file, we can understand the timeline of the operations
    that are taking place with a particular software or a daemon. If an application
    or a service crashes, this information helps to debug the issue and enables us
    to fix any issues. Logging and monitoring also helps to gather information from
    a pool of data. Logging and monitoring are important tasks for ensuring security
    in the operating system and for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter deals with different commands that can be used to monitor different
    activities. It also goes through logging techniques and their usages.
  prefs: []
  type: TYPE_NORMAL
- en: Disk usage hacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disk space is a limited resource. We frequently perform disk usage calculation
    on hard disks or any storage media to find out the free space available on the
    disk. When free space becomes scarce, we will need to find out large-sized files
    that are to be deleted or moved in order to create free space. Disk usage manipulations
    are commonly used in shell scripting contexts. This recipe will illustrate various
    commands used for disk manipulations and problems where disk usages can be calculated
    with a variety of options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`df` and `du` are the two significant commands that are used for calculating
    disk usage in Linux. The command `df` stands for disk free and `du` stands for
    disk usage. Let''s see how we can use them to perform various tasks that involve
    disk usage calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find the disk space used by a file (or files), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to obtain the disk usage for all files inside a directory along with
    the individual disk usage for each file showed in each line, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`-a` outputs results for all files in the specified directory or directories
    recursively.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running `du DIRECTORY` will output a similar result, but it will show only the
    size consumed by subdirectories. However, they do not show the disk usage for
    each of the files. For printing the disk usage by files, `-a` is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of using `du DIRECTORY` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional usage practices for the `du` command.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying disk usage in KB, MB, or Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the disk usage command displays the total bytes used by a file.
    A more human-readable format is when disk usage is expressed in standard units
    KB, MB, or GB. In order to print the disk usage in a display-friendly format,
    use `–h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the grand total sum of disk usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we need to calculate the total size taken by all the files or directories,
    displaying individual file sizes won''t help. `du` has an option `-c` such that
    it will output the total disk usage of all files and directories given as an argument.
    It appends a line SIZE total with the result. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`-c` can be used along with other options like `-a` and `-h`. It gives the
    same output as without using `-c`. The only difference is that it appends an extra
    line containing the total size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another option `–s` (summarize), which will print only the grand total
    as the output. It will print the total sum, and flag `-h` can be used along with
    it to print in human readable format. This command has frequent use in practice.
    The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Printing files in specified units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can force `du` to print the disk usage in specified units. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print size in bytes (by default) by using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the size in kilobytes by using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the size in megabytes by using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Print size in given BLOCK size specified by using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `BLOCK_SIZE` is specified in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example consisting of all the commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Excluding files from disk usage calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are circumstances when we need to exclude certain files from disk usage
    calculation. Such excluded files can be specified in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wildcards**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can specify a wildcard as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Exclude list**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can specify a list of files to be excluded from a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are also some other handy options available with `du` to restrict the
    disk usage calculation. We can specify the maximum depth of the hierarchy that
    the `du` should traverse as a whole by calculating disk usage with the `--max-depth`
    parameter. Specifying a depth of `1` calculates the sizes of files in the current
    directory. Depth `2` will calculate files in the current directory and the next
    subdirectory and stop traversal at that second subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`du` can be restricted to traverse only a single file system by using the `-x`
    argument. Suppose `du DIRECTORY` is run, it will traverse through every possible
    subdirectory of `DIRECTORY` recursively. A subdirectory in the directory hierarchy
    may be a mount point (for example, `/mnt/sda1` is a subdirectory of `/mnt` and
    it is a mount point for the device `/dev/sda1`). `du` will traverse that mount
    point and calculate the sum of disk usage for that device filesystem also. In
    order to prevent `du` from traversing and to calculate from other mount points
    or filesystems, use the `-x` flag along with other `du` options. `du –x /` will
    exclude all mount points in `/mnt/` for disk usage calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: While using `du` make sure that the directories or files it traverses have the
    proper read permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the 10 largest size files from a given directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finding large-size files is a regular task we come across. We regularly require
    to delete those huge size files or move them. We can easily find out large-size
    files using `du` and `sort` commands. The following one-line script can achieve
    this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here `-a` specifies all directories and files. Hence `du` traverses the `SOURCE_DIR`
    and calculates the size of all files. The first column of the output contains
    the size in Kilobytes since `-k` is specified and the second column contains the
    file or folder name.
  prefs: []
  type: TYPE_NORMAL
- en: '`sort` is used to perform numerical sort with column 1 and reverse it. `head`
    is used to parse the first 10 lines from the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the drawbacks of the above one-liner is that it includes directories
    in the result. However, when we need to find only the largest files and not directories
    we can improve the one-liner to output only the large-size files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We used `find` to filter only files to `du` rather than allow `du` to traverse
    recursively by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Disk free information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `du` command provides information about the usage, whereas `df` provides
    information about free disk space. It can be used with and without `-h`. When
    `-h` is issued with `df` it prints the disk space in human readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Calculating execution time for a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While testing an application or comparing different algorithms for a given problem,
    execution time taken by a program is very critical. A good algorithm should execute
    in minimum amount of time. There are several situations in which we need to monitor
    the time taken for execution by a program. For example, while learning about sorting
    algorithms, how do you practically state which algorithm is faster? The answer
    to this is to calculate the execution time for the same data set. Let's see how
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`time` is a command that is available with any UNIX-like operating systems.
    You can prefix `time` with the command you want to calculate execution time, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will execute and its output will be shown. Along with output, the
    `time` command appends the time taken in `stderr`. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show real, user, and system times for execution. The three different
    times can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real** is wall clock time—the time from start to finish of the call. This
    is all elapsed time including time slices used by other processes and the time
    that the process spends when blocked (for example, if it is waiting for I/O to
    complete).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User** is the amount of CPU time spent in user-mode code (outside the kernel)
    within the process. This is only the actual CPU time used in executing the process.
    Other processes and the time that the process spends when blocked do not count
    towards this figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sys** is the amount of CPU time spent in the kernel within the process. This
    means executing the CPU time spent in system calls within the kernel, as opposed
    to library code, which is still running in the user space. Like ''user time'',
    this is only the CPU time used by the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An executable binary of the `time` command is available at `/usr/bin/time` as
    well as a shell built-in named `time` exists. When we run `time`, it calls the
    shell built-in by default. The shell built-in time has limited options. Hence,
    we should use an absolute path for the executable (`/usr/bin/time`) for performing
    additional functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this time statistics to a file using the `-o filename` option
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The filename should always appear after the `–o` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to append the time statistics to a file without overwriting, use the
    `-a` flag along with the `-o` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also format the time outputs using format strings with the `-f` option.
    A format string consists of parameters corresponding to specific options prefixed
    with `%`. The format strings for real time, user time, and sys time are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Real time - `%e`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User - `%U`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sys - `%S`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By combining parameter strings, we can create formatted output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here `%U` is the parameter for user time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When formatted output is produced, the formatted output of the command is written
    to the standard output and the output of the `COMMAND`, which is timed, is written
    to standard error. We can redirect the formatted output using a redirection operator
    (`>`) and redirect the time information output using the (`2>`) error redirection
    operator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Many details regarding a process can be collected using the `time` command.
    The important details include, exit status, number of signals received, number
    of context switches made, and so on. Each parameter can be displayed by using
    a suitable format string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the interesting parameters that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%C` | Name and command-line arguments of the command being timed. |'
  prefs: []
  type: TYPE_TB
- en: '| `%D` | Average size of the process''s unshared data area, in kilobytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `%E` | Elapsed real (wall clock) time used by the process in [hours:]minutes:seconds.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Exit status of the command. |'
  prefs: []
  type: TYPE_TB
- en: '| `%k` | Number of signals delivered to the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | Number of times the process was swapped out of the main memory. |'
  prefs: []
  type: TYPE_TB
- en: '| `%Z` | System''s page size in bytes. This is a per-system constant, but varies
    between systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `%P` | Percentage of the CPU that this job got. This is just user + system
    times divided by the total running time. It also prints a percentage sign. |'
  prefs: []
  type: TYPE_TB
- en: '| `%K` | Average total (data + stack + text) memory usage of the process, in
    kilobytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `%w` | Number of times that the program was context-switched voluntarily,
    for instance while waiting for an I/O operation to complete. |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Number of times the process was context-switched involuntarily (because
    the time slice expired). |'
  prefs: []
  type: TYPE_TB
- en: 'For example, the page size can be displayed using the `%Z` parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here the output of the timed command is not required and hence the standard
    output is directed to the `/dev/null` device in order to prevent it from writing
    to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: More format strings parameters are available. Read `man time` for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Information about logged users, boot logs, and failure boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting information about the operating environment, logged in users, the
    time for which the computer has been powered on, and any boot failures are very
    helpful. This recipe will go through a few commands used to gather information
    about a live machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will introduce the commands `who`, `w`, `users`, `uptime`, `last`,
    and `lastb`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To obtain information about users currently logged in to the machine use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It will provide information about logged in users, the pseudo TTY used by the
    users, the command that is currently executing from the pseudo terminal, and the
    IP address from which the users have logged in. If it is localhost, it will show
    the hostname. `who` and `w` format outputs with slight difference. The `w` command
    provides more detail than `who` .
  prefs: []
  type: TYPE_NORMAL
- en: TTY is the device file associated with a text terminal. When a terminal is newly
    spawned by the user, a corresponding device is created in `/dev/` (for example,
    `/dev/pts/3`). The device path for the current terminal can be found out by typing
    and executing the command `tty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to list the users currently logged in to the machine, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user has opened multiple pseudo terminals, it will show that many entries
    for the same user. In the above output, the user `slynux` has opened three pseudo
    terminals. The easiest way to print unique users is to use `sort` and `uniq` to
    filter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have used `tr` to replace `' '` with `'\n'`. Then combination of `sort` and
    `uniq` will produce unique entries for each user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see how long the system has been powered on, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The time that follows the word `up` indicates the time for which the system
    has been powered on. We can write a simple one-liner to extract the uptime only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load average in uptime''s output is a parameter that indicates system load.
    This is explained in more detail in the chapter, *Administration Calls!*. In order
    to get information about previous boot and user logged sessions, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `last` command will provide information about logged in sessions. It is
    actually a log of system logins that consists of information such as `tty` from
    which it has logged in, login time, status, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `last` command uses the log file `/var/log/wtmp` for input log data. It
    is also possible to explicitly specify the log file for the last command using
    the `–f` option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to obtain info about login sessions for a single user, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about reboot sessions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get information about failed user login sessions use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You should run `lastb` as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the 10 most frequently-used commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terminal is the tool used to access the shell prompt where we type and execute
    commands. Users run many commands in the shell. Many of them are frequently used.
    A user's nature can be identified easily by looking at the commands he frequently
    uses. This recipe is a small exercise to find out 10 most frequently-used commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash keeps track of previously typed commands by the user and stores in the
    file `~/.bash_history`. But it only keeps a specific number (say 500) of the recently
    executed commands. The history of commands can be viewed by using the command
    history or `cat ~/.bash_history`. We will use this for finding out frequently-used
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get the list of commands from `~/.bash_history`, take only the command
    excluding the arguments, count the occurrence of each command, and find out the
    10 commands with the highest count.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script can be used to find out frequently-used commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the above script, the history file `~/.bash_history` is the source file used.
    The source input is passed to `awk` through a pipe. Inside `awk`, we have an associative
    array list. This array can use command names as index and it stores the count
    of the commands in array locations. Hence for each arrival or occurrence of a
    command it will increment by one (`list[$1]++`). `$1` is used as the index. `$1`
    is the first word of text in a line input. If `$0` were used it would contain
    all the arguments for the command also. For example, if `ssh 192.168.0.4` is a
    line from `.bash_history`, `$0` equals to `ssh 192.168.0.4` and `$1` equals to
    `ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the lines of the history files are traversed, we will have the array
    with command names as indexes and their count as the value. Hence command names
    with maximum count values will be the commands most frequently used. Hence in
    the `END{}` block of `awk`, we traverse through the indexes of commands and print
    all command names and their counts. `sort -nrk 2` will perform a numeric sort
    based on the second column (`COUNT`) and reverse it. Hence we use the `head` command
    to extract only the first 10 commands from the list. You can customize the top
    10 to top 5 or any other number by using the argument `head -n NUMBER`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the top 10 CPU consuming process in a hour
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CPU time is a major resource and sometimes we require to keep track of the processes
    that consume the most CPU cycles in a period of time. In regular desktops or laptops,
    it might not be an issue that the CPU is heavily consumed. However, for a server
    that handles numerous requests, CPU is a critical resource. By monitoring the
    CPU usage for a certain period we can identify the processes that keep the CPU
    busy all the time and optimize them to efficiently use the CPU or to debug them
    due to any other issues. This recipe is a practice with process monitoring and
    logging.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ps` is a command used for collecting details about the processes running on
    the system. It can be used to gather details such as CPU usage, commands under
    execution, memory usage, status of process, and so on. Processes that consume
    the CPU for one hour can be logged, and the top 10 can be determined by proper
    usage of `ps` and text processing. For more details on the `ps` command, see the
    chapter: *Administration Calls!*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the following shell script for monitoring and calculating
    CPU usages in one hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the above script, the major input source is `ps -eocomm, pcpu`. `comm` stands
    for command name and `pcpu` stands for the CPU usage in percent. It will output
    all the process names and the CPU usage in percent. For each process there exists
    a line in the output. Since we need to monitor the CPU usage for one hour, we
    repeatedly take usage statistics using `ps -eo comm,pcpu` `| tail -n +2` and append
    to a file `/tmp/cpu_usage.$$` running inside a `for` loop with 60 seconds wait
    in each iteration. This wait is provided by `sleep 60`. It will execute `ps` once
    in each minute.
  prefs: []
  type: TYPE_NORMAL
- en: '`tail -n +2` is used to strip off the header and `COMMAND %CPU` in the `ps`
    output.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$$` in `cpu_usage.$$` signifies that it is the process ID of the current script.
    Suppose PID is 1345, during execution it will be replaced as `/tmp/cpu_usage.1345`.
    We place this file in `/tmp` since it is a temporary file.'
  prefs: []
  type: TYPE_NORMAL
- en: The statistics file will be ready after one hour and will contain 60 entries
    corresponding to the process status for each minute. Then `awk` is used to sum
    the total CPU usage for each process. An associative array process is used for
    the summation of CPU usages. It uses the process name as an array index. Finally,
    it sorts the result with a numeric reverse sort according to the total CPU usage
    and pass through head to obtain top 10 usage entries.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic awk primer* of[Chapter 4](ch04.html "Chapter 4. Texting and Driving"),
    explains the awk command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*head and tail - printing the last or first ten lines* of[Chapter 3](ch03.html
    "Chapter 3. File In, File Out"), explains the tail command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring command outputs with watch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We might need to continuously watch the output of a command for a period of
    time in equal intervals. For example, for a large file copy, we need to watch
    the growing file size. In order to do that, newbies repeatedly type commands and
    press return a number of times. Instead we can use the watch command to view output
    repeatedly. This recipe explains how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `watch` command can be used to monitor the output of a command on the terminal
    at regular intervals. The syntax of the `watch` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This command will update the output at a default interval of two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify the time interval at which the output needs to be updated,
    by using `-n SECONDS`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore an additional feature of the `watch` command.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the differences in watch output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `watch`, there is an option for updating the differences that occur during
    the execution of the command at an update interval to be highlighted using colors.
    Difference highlighting can be enabled by using the `-d` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Logging access to files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging of file and directory access is very helpful to keep track of changes
    that are happening to files and folders. This recipe will describe how to log
    user accesses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inotifywait` command can be used to gather information about file accesses.
    It doesn't come by default with every Linux distro. You have to install the `inotify-tools`
    package by using a package manager. It also requires the Linux kernel to be compiled
    with inotify support. Most of the new GNU/Linux distributions come with inotify
    enabled in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s walk through the shell script to monitor the directory access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous script will log events create, move, and delete files and folders
    from the given path. The `-m` option is given for monitoring the changes continuously
    rather than going to exit after an event happens. `-r` is given for enabling a
    recursive watch the directories. `-e` specifies the list of events to be watched.
    `-q` is to reduce the verbose messages and print only required ones. This output
    can be redirected to a log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add or remove the event list. Important events available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `access` | When some read happens to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `modify` | When file contents are modified. |'
  prefs: []
  type: TYPE_TB
- en: '| `attrib` | When metadata is changed. |'
  prefs: []
  type: TYPE_TB
- en: '| `move` | When a file undergoes move operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | When a new file is created. |'
  prefs: []
  type: TYPE_TB
- en: '| `open` | When a file undergoes open operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | When a file undergoes close operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | When a file is removed. |'
  prefs: []
  type: TYPE_TB
- en: Logfile management with logrotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logfiles are essential components of a Linux system's maintenance. Logfiles
    help to keep track of events happening on different services on the system. This
    helps the sysadmin to debug issues and also provides statistics on events happening
    on the live machine. Management of logfiles is required because as time passes
    the size of a logfile gets bigger and bigger. Therefore, we use a technique called
    rotation to limit the size of the logfile and if the logfile reaches a size beyond
    the limit, it will strip the logfile and store the older entries from the logfile
    in an archive. Hence older logs can be stored and kept for future reference. Let's
    see how to rotate logs and store them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`logrotate` is a command every Linux system admin should know. It helps to
    restrict the size of logfile to the given SIZE. In a logfile, the logger appends
    information to the log file. Hence the recent information appears at the bottom
    of the log file. `logrotate` will scan specific logfiles according to the configuration
    file. It will keep the last 100 kilobytes (for example, specified SIZE = 100k)
    from the logfile and move rest of the data (older log data) to a new file `logfile_name.1`
    with older entries. When more entries occur in the logfile (`logfile_name.1`)
    and it exceeds the SIZE, it updates the logfile with recent entries and creates
    `logfile_name.2` with older logs. This process can easily be configured with `logrotate`.
    `logrotate` can also compress the older logs as `logfile_name.1.gz`, `logfile_name2.gz`,
    and so on. The option for whether older log files are to be compressed or not
    is available with the `logrotate` configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`logrotate` has the configuration directory at `/etc/logrotate.d`. If you look
    at this directory by listing contents, many other logfile configurations can be
    found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write our custom configuration for our logfile (say `/var/log/program.log`)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the configuration is complete. `/var/log/program.log` in the configuration
    specifies the logfile path. It will archive old logs in the same directory path.
    Let''s see what each of these parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `missingok` | Ignore if the logfile is missing and return without rotating
    the log. |'
  prefs: []
  type: TYPE_TB
- en: '| `notifempty` | Only rotate the log if the source logfile is not empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `size 30k` | Limit the size of the logfile for which the rotation is to be
    made. It can be 1M for 1MB. |'
  prefs: []
  type: TYPE_TB
- en: '| `compress` | Enable compression with gzip for older logs. |'
  prefs: []
  type: TYPE_TB
- en: '| `weekly` | Specify the interval at which the rotation is to be performed.
    It can be weekly, yearly, or daily. |'
  prefs: []
  type: TYPE_TB
- en: '| `rotate 5` | It is the number of older copies of logfile archives to be kept.
    Since 5 is specified, there will be `program.log.1.gz`, `program.log.2.gz`, and
    so on till `program.log.5.gz`. |'
  prefs: []
  type: TYPE_TB
- en: '| `create 0600 root root` | Specify the mode, user, and the group of the logfile
    archive to be created. |'
  prefs: []
  type: TYPE_TB
- en: The options specified in the table are optional; we can specify the required
    options only in the `logrotate` configuration file. There are numerous options
    available with `logrotate`. Please refer to the man pages ([http://linux.die.net/man/8/logrotate](http://linux.die.net/man/8/logrotate))
    for more information on `logrotate`.
  prefs: []
  type: TYPE_NORMAL
- en: Logging with syslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logfiles are an important component of applications that provide services to
    the users. An applications writes status information to its logfile while it is
    running. If any crash occurs or we need to enquire some information about the
    service, we look into the logfile. You can find lots of logfiles related to different
    daemons and applications in the `/var/log` directory. It is the common directory
    for storing log files. If you read through a few lines of the logfiles, you can
    see that lines in the log are in a common format. In Linux, creating and writing
    log information to logfiles at `/var/log` are handled by a protocol called syslog.
    It is handled by the `syslogd` daemon. Every standard application makes use of
    syslog for logging information. In this recipe, we will discuss how to make use
    of `syslogd` for logging information from a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logfiles are useful for helping you deduce what is going wrong with a system.
    Hence while writing critical applications, it is always a good practice to log
    the progress of application with messages into a logfile. We will learn the command
    logger to log into log files with `syslogd`. Before getting to know how to write
    into logfiles, let''s go through a list of important logfiles used in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Log file | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/boot.log` | Boot log information. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/httpd` | Apache web server log. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/messages` | Post boot kernel information. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/auth.log` | User authentication log. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/dmesg` | System boot up messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/mail.log` | Mail server log. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/Xorg.0.log` | X Server log. |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to log to the syslog file `/var/log/messages` use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The logfile `/var/log/messages` is a general purpose logfile. When the `logger`
    command is used, it logs to `/var/log/messages` by default. In order to log to
    the syslog with a specified tag, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: syslog handles a number of logfiles in `/var/log`. However, while logger sends
    a message, it uses the tag string to determine in which logfile it needs to be
    logged. `syslogd` decides to which file the log should be made by using the `TAG`
    associated with the log. You can see the tag strings and associated logfiles from
    the configuration files located in the `/etc/rsyslog.d/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to log to the system log with the last line from another logfile use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*head and tail - printing the last or first 10 lines* of[Chapter 3](ch03.html
    "Chapter 3. File In, File Out"), explains the head and tail commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring user logins to find intruders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logfiles can be used to gather details about the state of the system. Here
    is an interesting scripting problem statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a system connected to the Internet with SSH enabled. Many attackers
    are trying to log in to the system. We need to design an intrusion detection system
    by writing a shell script. Intruders are defined as users who are trying to log
    in with multiple attempts for more than two minutes and whose attempts are all
    failing. Such users are to be detected and a report should be generated with the
    following details:'
  prefs: []
  type: TYPE_NORMAL
- en: User account to which a login is attempted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address of the attacker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host mapping for IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time range for which login attempts are performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can write a shell script that can scan through the logfiles and gather the
    required information from them. Here, we are dealing with SSH login failures.
    The user authentication session log is written to the log file `/var/log/auth.log`.
    The script should scan the log file to detect the failure login attempts and perform
    different checks on the log to infer the data. We can use the `host` command to
    find out the host mapping from the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write an intruder detection script that can generate a report of intruders
    by using the authentication logfile as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3760_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `intruder_detect.sh` script, we use the `auth.log` file as input. We
    can either provide a log file as input to the script by using a command-line argument
    to the script or, by default, it reads the `/var/log/auth.log` file. We need to
    log details about login attempts for valid user names only. When a login attempt
    for an invalid user occurs, a log similar to `Failed password for invalid user
    bob from 203.83.248.32 port 7016 ssh2` is logged to `auth.log`. Hence, we need
    to exclude all lines in the log file having the word "invalid". The `grep` command
    with the invert option (`-v`) is used to remove all logs corresponding to invalid
    users. The next step is to find out the list of users for which login attempts
    occurred and failed. The SSH will log lines similar to `sshd[21197]: Failed password
    for bob1 from 203.83.248.32 port 50035 ssh2` for a failed password.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence we should find all the lines with words "failed password". Now all the
    unique IP addresses are to be found out for extracting all the log lines corresponding
    to each IP address. The list of IP address is extracted by using a regular expression
    for IP address and the `egrep` command. A `for` loop is used to iterate through
    IP address and the corresponding log lines are found using `grep` and are written
    to a temporary file. The sixth word from the last word in the log line is the
    user name (for example, bob1 ). The `awk` command is used to extract the sixth
    word from the last word. `NF` returns the column number of the last word. Therefore,
    `NF-5` gives the column number of the sixth word from the last word. We use `sort`
    and `uniq` commands to produce a list of users without duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Now we should collect the failed login log lines containing the name of each
    users. A `for` loop is used for reading the lines corresponding to each user and
    the lines are written to a temporary file. The first 16 characters in each of
    the log lines is the timestamp. The `cut` command is used to extract the timestamp.
    Once we have all the timestamps for failed login attempts for a user, we should
    check the difference in time between the first attempt and the last attempt. The
    first log line corresponds to the first attempt and last log line corresponds
    to last attempt. We have used `head -1` to extract the first line and `tail -1`
    to extract the last line. Now we have a time stamp for first (`tstart`) and last
    attempt (`tends`) in string format. Using the `date` command, we can convert the
    date in string representation to total seconds in UNIX Epoch time (the recipe,
    *Getting, setting dates, and delays* of [Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains Epoch time).
  prefs: []
  type: TYPE_NORMAL
- en: The variables start and end have a time in seconds corresponding to the start
    and end timestamps in the date string. Now, take the difference between them and
    check whether it exceeds two minutes (120 seconds). Thus, the particular user
    is termed as an intruder and the corresponding entry with details are to be produced
    as a log. IP addresses can be extracted from the log by using a regular expression
    for IP address and the `egrep` command. The number of attempts is the number of
    log lines for the user. The number of lines can be found out by using the `wc`
    command. The host name mapping can be extracted from the output of the host command
    by running with IP address as argument. The time range can be printed using the
    timestamp we extracted. Finally, the temporary files used in the script are removed.
  prefs: []
  type: TYPE_NORMAL
- en: The above script is aimed only at illustrating a model for scanning the log
    and producing a report from it. It has tried to make the script smaller and simpler
    to leave out the complexity. Hence it has few bugs. You can improve the script
    by using better logic.
  prefs: []
  type: TYPE_NORMAL
- en: Remote disk usage health monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A network consists of several machines with different users. The network requires
    centralized monitoring of disk usage of remote machines. The system administrator
    of the network needs to log the disk usage of all the machines in the network
    every day. Each log line should contain details such as the date, IP address of
    the machine, device, capacity of the device, used space, free space, percentage
    usage, and health status. If the disk usage of any of the partitions in any remote
    machine exceeds 80 percent, the health status should be set to ALERT, else it
    should be set to SAFE. This recipe will illustrate how to write a monitoring script
    that can collect details from remote machines in a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to collect the disk usage statistics from each machine on the network,
    individually, and write a log file in the central machine. A script that collects
    the details and writes the log can be scheduled to run everyday at a particular
    time. The SSH can be used to log in to remote systems to collect disk usage data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we have to set up a common user account on all the remote machines in
    the network. It is for the disklog program to log in to the system. We should
    configure auto-login with SSH for that particular user (the recipe, *Password-less
    auto-login with SSH* in[Chapter 7](ch07.html "Chapter 7. The Old-boy Network"),
    explains configuration of auto-login). We assume that there is a user called test
    in all remote machines configured with auto-login. Let''s go through the shell
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can schedule using the cron utility to run the script at regular intervals.
    For example, to run the script everyday at 10 am, write the following entry in
    the `crontab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Run the command `crontab –e`. Add the above line and save the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the script manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output log for the above script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3760_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `disklog.sh` script, we can provide the logfile path as a command-line
    argument or else it will use the default logfile. If the logfile does not exists,
    it will write the logfile header text into the new file. `–e $logfile` is used
    to check whether the file exists or not. The list of IP addresses of remote machines
    are stored in the variable `IP_LIST` delimited with spaces. It should be made
    sure that all the remote systems listed in the `IP_LIST` have a common user `test`
    with auto-login with SSH configured. A `for` loop is used to iterate through each
    of the IP addresses. A remote command `df –H` is executed to get the disk free
    usage data using the `ssh` command. It is stored in a temporary file. A `while`
    loop is used to read the file line by line. Data is extracted using `awk` and
    is printed. The date is also printed. The percentage usage is extracted using
    the `egrep` command and `%` is replaced with `none` to get the numeric value of
    percent. It is checked whether the percentage value exceeds 80\. If it is less
    than 80, the status is set as SAFE and if greater than or equal to 80, the status
    is set as ALERT. The entire printed data should be redirected to the logfile.
    Hence the portion of code is enclosed in a subshell `()` and the standard output
    is redirected to the logfile.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Scheduling with cron* of[Chapter 9](ch09.html "Chapter 9. Administration Calls"),
    explains the crontab command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out active user hours on a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a web server with shared hosting. Many users log in to and log out
    of the server every day. The user activity gets logged in the server's system
    log. This recipe is a practice task to make use of the system logs and to find
    out how many hours each of the users have spent on the server and rank them according
    to the total usage hours. A report should be generated with the details, such
    as the rank, user, first logged in date, last logged in date, number of times
    logged in, and total usage hours. Let's see how we can approach this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `last` command is used to list the details about the login sessions of the
    users in a system. The log data is stored in the `/var/log/wtmp` file. By individually
    adding the session hours for each user we can find out the total usage hours.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the script to find out active users and generate the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `active_users.sh` script, we can either provide the `wtmp` log file as
    a command-line argument or it will use the `defaulwtmp` log file. The `last –f`
    command is used to print the logfile contents. The first column in the logfile
    is the user name. By using `cut` we extract the first column from the logfile.
    Then the unique users are found out by using the `sort` and `uniq` commands. Now
    for each user, the log lines corresponding to their login sessions are found out
    using `grep` and are written to a temporary file. The last column in the last
    log is the duration for which the user logged a session. Hence in order to find
    out the total usage hours for a user, the session durations are to be added. The
    usage duration is in `(HOUR:SEC)` format and it is to be converted into seconds
    using the date command.
  prefs: []
  type: TYPE_NORMAL
- en: In order to extract the session hours for the users, we have used the `awk`
    command. For removing the parenthesis, `tr –d` is used. The list of usage hour
    string is passed to the standard input for the `while` loop using the `<( COMMANDS
    )` operator. It acts as a file input. Each hour string, by using the `date` command,
    is converted into seconds and added to the variable `seconds`. The first login
    time for a user is in the last line and it is extracted. The number of login attempts
    is the number of log lines. In order to calculate the rank of each user according
    to the total usage hours, the data record is to be sorted in the descending order
    with usage hours as the key. For specifying the number reverse sort `-nr` option
    is used along with the `sort` command. `–k4` is used to specify the key column
    (usage hour). Finally, the output of the sort is passed to `awk`. The `awk` command
    prefixes a line number to each of the lines, which becomes the rank for each user.
  prefs: []
  type: TYPE_NORMAL
