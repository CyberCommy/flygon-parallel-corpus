- en: Composing Widgets with Vue.js Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are becoming an essential aspect of frontend development, and are
    a feature in most modern frontend frameworks, including Vue, React, Angular, Polymer,
    and so on. Components are even becoming native to the web through a new standard
    called **Web Components**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use components to create an image carousel for Vuebnb,
    which allows users to peruse the different photos of a room listing. We'll also
    refactor Vuebnb to conform to a component-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What components are and how to create them with Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component communication through props and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-file components-one of Vue's most useful features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom content to a component with slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of architecting apps entirely from components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How render functions can be used to skip the template compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the runtime-only build of Vue to lighten the bundle size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're constructing a template for a web app, we can use HTML elements such
    as `div`, `table`, and `span`. This variety of elements makes it easy to create
    whatever structures we need for organizing content on the page.
  prefs: []
  type: TYPE_NORMAL
- en: What if we could create our own custom elements, through, for example, `my-element`?
    This would allow us to create reusable structures specifically designed for our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '*Components* are a tool for creating custom elements in Vue.js. When we register
    a component, we define a template which renders as one or more standard HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e6ef921-1671-4a44-8e89-91c53b8bc046.png)Figure 6.1\. Components
    facilitate reusable markup and render as standard HTML'
  prefs: []
  type: TYPE_NORMAL
- en: Registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways to register a component, but the easiest is to use the `component` API
    method. The first argument is the name you want to give the component, the second
    is the configuration object. The configuration object will often include a `template` property
    to declare the component''s markup using a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve registered a component like this, we can use it within our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to reusable markup, components allow us to reuse JavaScript functionality.
    The configuration object can not only include a template but can also include
    its own state, just like the Vue instance. In fact, each component can be thought
    of as a mini-instance of Vue with its own data, methods, lifecycle hooks, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We treat component data slightly differently to the Vue instance though, as
    components are meant to be reusable. For example, we might create a bank of `check-box` components
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As it is, if a user clicks a checkbox `div`, the `checked` state toggles from
    true to false for every checkbox simultaneously! This is not what we want, but
    it is what will happen, as all instances of the component refer to the same `data` object
    and therefore have the same state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give each instance its own unique state, the `data` property shouldn''t
    be an object, but a factory function that returns an object. That way, every time
    the component is instantiated, it links to a fresh data object. Implementing this
    is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Image carousel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a new feature for the Vuebnb frontend app using components. As you'll
    recall from previous chapters, each of our mock data listings has four different
    images, and we're passing the URLs to the frontend app.
  prefs: []
  type: TYPE_NORMAL
- en: To allow the user to peruse these images, we're going to create an image carousel.
    This carousel will replace the static image that currently occupies the modal
    window that pops up when you click the header of a listing.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by opening the app view. Remove the static image and replace it with a
    custom HTML element `image-carousel`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A component can be referred to in your code by a kebab-case name such as `my-component`,
    a PascalCase name such as `MyComponent`, or a camelCase name such as `myComponent`.
    Vue sees these all as the same component. However, in a DOM or string template,
    the component should always be kebab-cased. Vue doesn't enforce this, but markup
    in the page gets parsed by the browser before Vue gets to work with it, so it
    should conform to W3C naming conventions or the parser may strip it out.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now register the component in our entry file. The template of this new
    component will simply be the image tag we removed from the view, wrapped in a `div`.
    We add this wrapping element, as component templates must have a single root element,
    and we'll soon be adding more elements inside it.
  prefs: []
  type: TYPE_NORMAL
- en: As a proof of concept, the component data will include an array of hard-coded
    image URLs. Once we learn how to pass data into a component, we will remove these
    hard-coded URLs and replace them with dynamic ones from our model.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before we test this component, let's make an adjustment to our CSS. We previously
    had a rule to ensure the image inside the modal window stretched to full width
    by using the `.modal-content img `selector. Let's instead use the `.image-carousel` selector for
    this rule, as we're decoupling the image from the modal window.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/css/style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After your code has rebuilt, navigate the browser to `/listing/1` and you should
    see no difference, as the component should render in almost exactly the same way
    as the previous markup did.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check Vue Devtools, however, and open up to the Components tab, you''ll
    see that we now have the `ImageCarousel` component nested below the `Root` instance.
    Selecting `ImageCarousel`, we can even inspect its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76c74b58-9265-42c3-9131-918c8cb0861d.png)Figure 6.2\. Vue Devtools
    showing ImageCarousel component'
  prefs: []
  type: TYPE_NORMAL
- en: Changing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point of a carousel is to allow the user to peruse a collection of images
    without having to scroll the page. To permit this functionality, we'll need to
    create some UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's add a new data property, `index`, to our component, which will
    dictate the current image being displayed. It will be initialized at 0 and the
    UI controls will later be able to increment or decrement the value.
  prefs: []
  type: TYPE_NORMAL
- en: We will bind the image source to the array item at position `index`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A page refresh should, again, reveal no change to what you see on screen. However,
    if you initialize the value of `index` to `1`, `2`, or `3`, you will find a different
    image is shown when you re-open the modal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/17bc76a6-6066-4702-8d8e-6beab3b10cde.png)Figure 6.3\. Setting index to
    2 selects a different URL and a different image is shown'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's convenient to write logic straight into our template as an expression,
    for example, `v-if="myExpression"`. But what about more complex logic that can't
    be defined as an expression, or simply becomes too verbose for the template?
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario, we use **computed properties**. These are properties we add
    to our Vue configuration that can be thought of as reactive methods which are
    rerun whenever a dependent value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we've declared a computed property, `message`, under
    the `computed` configuration section. Note the function is dependent on `val`,
    that is, the returned value of of `message` will be different as `val` changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this script runs, Vue will note any dependencies of `message` and will
    set up reactive binding so that, unlike a regular method, the function will be
    rerun whenever the dependencies change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Going back to the image carousel, let's make the template terser by abstracting
    the expression bound to the image `src` into a computed property.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Composing with components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components can be nested in other components in the same way that standard
    HTML elements can be nested. For example, `component B` can be a child of `component
    A`, if `component A` declares `component B` in its template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Registration scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While some components are designed for use anywhere in an app, other components
    may be designed with a more specific purpose. When we register a component using
    the API, that is, `Vue.component`, that component is *globally *registered and
    can be used within any other component or instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also *locally* register a component by declaring it in the `components` option
    in the root instance, or in another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Carousel controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow a user to change the currently shown image in the carousel, let's create
    a new component, `CarouselControl`. This component will be presented as an arrowhead
    that floats over the carousel and will respond to a user's click. We'll use two
    instances, as there will be a left and right arrow for either decrementing or
    incrementing the image index.
  prefs: []
  type: TYPE_NORMAL
- en: We'll register `CarouselControl` locally for the `ImageCarousel` component.
    The `CarouselControl` template will render as an `i` tag, which is often used
    for displaying icons. A good icon for carousels is the Font Awesome *chevron *icon,
    which is an elegantly shaped arrowhead. Currently, we don't have a way to distinguish
    between the left and right, so for now, both instances will have a left-facing
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To have these controls float nicely over our image carousel, we'll add some
    new rules to our CSS file as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/css/style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With that code added, open the modal window to see our handywork so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dbcc4ccc-a1b8-424e-81df-c859ebe02e2f.png)Figure 6.4\. Carousel controls
    added to the image carousel'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key aspect of components is that they are reusable, which is why we give them
    their own state to keep them independent from the rest of the app. However, we
    may still want to send in data, or send it out. Components have an interface for
    communicating with other parts of the app, which we will now explore.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can send data to a component through a custom HTML property know as a *prop*.
    We must also register this custom property in an array, `props`, in the component''s
    configuration. In the following example, we''ve created a prop, `title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A prop can be used just like any data property of the component: you can interpolate
    it in the template, use it in methods and computed properties, and so on. However,
    you should not mutate prop data. Think of prop data as being *borrowed* from another
    component or instance - only the owner should change it.'
  prefs: []
  type: TYPE_NORMAL
- en: Props are proxied to the instance just like data properties, meaning you can
    refer to a prop as `this.myprop` within that component's code. Be sure to name
    your props uniquely to your data properties to avoid a clash!
  prefs: []
  type: TYPE_NORMAL
- en: One-way data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since props must be declared in the template where the component is used, prop
    data can only pass from a parent to a child. This is why you shouldn't mutate
    a prop - since data flows down, the change will not be reflected in the parent,
    and therefore you will have different versions of what is meant to be the same
    bit of state.
  prefs: []
  type: TYPE_NORMAL
- en: If you do need to tell the owner to change the data, there is a separate interface
    for passing data from a child to a parent, which we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can reactively bind data to a component using the `v-bind` directive. When
    the data changes in the parent, it will automatically flow down to the child.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the value of `title` in the root instance gets programmatically
    updated after two seconds. This change will automatically flow down to `MyComponent`,
    which will reactively re-render to display the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since the `v-bind` directive is used so commonly in templates, you can omit
    the directive name as a shorthand: `<div v-bind:title="title">` can be shortened
    to `<div :title="title">`.
  prefs: []
  type: TYPE_NORMAL
- en: Image URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created `ImageCarousel`, we hard-coded the image URLs. With props, we
    now have a mechanism for sending dynamic data from the root instance down to a
    component. Let's bind the root instance data property `images` to a prop, also
    called `images`, in our `ImageCarousel` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, delete the data property `images` in the `ImageCarousel` component, and
    instead declare `images` as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The root instance will now be responsible for the state of the image URLs, and
    the image carousel component will just be responsible for displaying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Vue Devtools, we can inspect the state of the image carousel component,
    which now includes `images` as a prop value instead of a data value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4733eab-446b-46cd-a129-5fb17c0adf3b.png)Figure 6.5\. Image URLs
    are props sent to the ImageCarousel component'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the image URLs are coming from the model, we can access other listing
    routes, such as `/listing/2`, and see the correct image displaying in the modal
    window again.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing carousel controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CarouselControl` component should have two possible states: either left-pointing
    or right-pointing. When clicked by the user, the former will ascend through the
    available images, the latter will descend.'
  prefs: []
  type: TYPE_NORMAL
- en: This state should not be internally determined, but instead passed down from `ImageCarousel`.
    To do so, let's add a prop `dir` to `CarouselControl` that will take a string
    value, and should be either `left` or `right`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `dir` prop, we can now bind the correct icon to the `i` element. This
    is done with a computed property which appends the prop's value to the string
    `fa-chevron-`, resulting in either `fa-chevron-left`or `fa-chevron-right`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the carousel control icons correctly directed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a890fe8a-97f2-4cd0-87f5-c056108af4a1.png)Figure 6.6\. Carousel control
    icons are now correctly directed'
  prefs: []
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our carousel controls are displaying nicely, but they still don't do anything!
    When they're clicked, we need them to tell `ImageCarousel` to either increment
    or decrement its `index` value, which will result in the image being changed.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic props won't work for this task, as props can only send data down from
    a parent to a child. What do we do when the child needs to send data up to the
    parent?
  prefs: []
  type: TYPE_NORMAL
- en: '*Custom events* can be emitted from a child component and listened to by its
    parent. To implement this, we use the `$emit` instance method in the child, which
    takes the event name as the first argument and an arbitrary number of additional
    arguments for any data to be sent along with the event, such as `this.$emit(''my-event'',
    ''My event payload'');`.'
  prefs: []
  type: TYPE_NORMAL
- en: The parent can listen to this event using the `v-on` directive in the template
    where the component is declared. If you handle the event with a method, any arguments
    sent with the event will be passed to this method as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example, where a child component, `MyComponent`, emits an event
    called `toggle` to tell the parent, the root instance, to change the value of
    a data property, `toggle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Changing carousel images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returning to `CarouselControl`, let's respond to a user's click by using the `v-on` directive
    and triggering a method, `clicked`. This method will, in turn, emit a custom event, `change-image`, which
    will include a payload of either `-1` or `1`, depending on whether the state of
    the component is `left` or `right`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with `v-bind`, there is a shorthand for `v-on` as well. Simply replace `v-on:` with `@`;
    for instance, `<div @click="handler"></div>` is the equivalent of `<div v-on:click="handler"></div>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Open Vue Devtools to the Events tab, and, at the same time, click on the carousel
    controls. Custom events are logged here, so we can verify `change-image` is being
    emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2505411-760b-4363-a19d-8f6938340b2b.png)Figure 6.7\. Screenshot
    showing a custom event and its payload'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageCarousel` will now need to listen for the `change-image` event via the `v-on` directive.
    The event will be handled by a method `changeImage` which will have a single parameter, `val`,
    reflecting the payload being sent in the event. The method will then use `val` to
    step the value of `index`, ensuring it loops to the start or end if it exceeds
    the bounds of the array it indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, the image carousel will now work perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6a518db-81ab-4501-9a2e-355fff9be282.png)Figure 6.8\. The state
    of the image carousel after the image has been changed'
  prefs: []
  type: TYPE_NORMAL
- en: Single-file components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single-File Components** (**SFCs**) are files with a `.vue` extension that
    contain the complete definition of a single component and can be imported into
    your Vue.js app. SFCs make it simple to create and use components, and come with
    a variety of other benefits which we''ll soon explore.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SFCs are similar to HTML files but have (at most) three root elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The component definition goes inside the `script` tag and will be exactly like
    any other component definition except:'
  prefs: []
  type: TYPE_NORMAL
- en: It will export an ES module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will not need a `template` property (or a `render` function; more on that
    later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component's template will be declared as HTML markup inside the `template` tag.
    This should be a welcome relief from writing cumbersome template strings!
  prefs: []
  type: TYPE_NORMAL
- en: The `style` tag is a feature unique to SFCs and can contain any CSS rules you
    need for the component. This mostly just helps with the organization of your CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of the declaration and usage of a single-file component.
  prefs: []
  type: TYPE_NORMAL
- en: '`MyComponent.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use a single-file component in your app, you simply `import` it like it were
    an ES module. The *.vue* file is not a valid JavaScript module file, however.
    Just like we use the Webpack Babel plugin to transpile our ES2015 code into ES5
    code, we must use *Vue Loader* to transform *.vue* files into JavaScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: Vue Loader is already configured by default with Laravel Mix, so there's nothing
    further we need to do in this project; any SFCs we import will just work!
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Vue Loader, check out the documentation at [https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring components to SFCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `resource/assets/js/app.js` file is almost 100 lines long now. If we keep
    adding components, it will start to get unmanageable, so it's time to think about
    splitting it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by refactoring our existing components to be SFCs. First, we''ll
    create a new directory, then we will create the `.vue` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Starting with `ImageCarousel.vue`, the first step is to create the three root
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ImageCarousel.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we move the `template` string into the `template `tag, and the component
    definition into the `script` tag. The component definition must be exported as
    a module.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ImageCarousel.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we can import this file into our app and register it locally in the root
    instance. As mentioned, Vue is able to automatically switch between kebab-case
    component names and Pascal-case ones. This means we can use the object shorthand
    syntax inside the `component` configuration and Vue will correctly resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to delete any remaining code from the original `ImageCarousel` component
    definition in `app.js` before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SFCs allow us to add style to a component, helping to better organize our CSS
    code. Let''s move the CSS rules we created for the image carousel into this new
    SFC''s `style` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the project builds, you should find it still appears the same. The interesting
    thing, though, is where the CSS has ended up in the build. If you check `public/css/style.css`,
    you'll find it's not there.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually included in the JavaScript bundle as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a6e3bbf-577a-4800-b4bc-c5c0fe1243b2.png)Figure 6.9\. CSS stored
    as a string in the JavaScript bundle file'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, Webpack''s bootstrapping code will inline this CSS string into the
    head of the document when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4260368f-354f-4695-8013-8ca5a8a38001.png)Figure 6.10\. Inlined CSS
    in document head'
  prefs: []
  type: TYPE_NORMAL
- en: Inlining CSS is actually the default behavior of Vue Loader. However, we can
    override this and get Webpack to write SFC styles to their own file. Add the following
    to the bottom of the Mix configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now an additional file, `public/css/vue-style.css`, will be outputted in the
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45e46db4-744d-462d-ba87-afe089b1541a.png)Figure 6.11\. Webpack output
    including single-file component styles'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to load this new file in our view, after the main style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: CarouselControl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now abstract our `CarouselControl` component into an SFC, and move any
    relevant CSS rules from `resources/assets/css/style.css` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/CarouselControl.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This file can now be imported by the `ImageCarousel` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ImageCarousel.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With that done, our existing components have been refactored to SFCs. This has
    not made any obvious difference to the functionality of our app (although it is
    slightly faster, as I'll explain later), but it will make development easier as
    we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Content distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you''re going to build a component-based Vue.js app that resembles
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62c38159-a04a-4e5c-8993-6a17f3a97de1.png)Figure 6.12\. Component-based
    Vue.js app'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the left-branch of the above diagram, `ComponentC` is declared
    by `ComponentB`. However, in the right branch, `ComponentD` is declared by a different
    instance of `ComponentB`.
  prefs: []
  type: TYPE_NORMAL
- en: With what you know about components so far, how would you make the template
    for `ComponentB`, given that it has to declare two different components? Perhaps
    it would include a `v-if` directive to use either `ComponentC` or `ComponentD`
    depending on some variable passed down as a prop from `ComponentA`. This approach
    would work, however, it makes `ComponentB` very inflexible, limiting its reusability
    in other parts of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve learned so far that the content of a component is defined by its own
    template, not by its parent, so we wouldn''t expect the following to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But it will work if `MyComponent` has a *slot*. Slots are distribution outlets
    inside a component, defined with the special `slot` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If `ComponentB` has a slot in its template, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve the problem just stated without having to use a cumbersome `v-for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that content declared inside a component in the parent
    template is compiled in the scope of the parent. Although it is rendered inside
    the child, it cannot access any of the child''s data. The following example should
    distinguish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Modal window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of the functionality left in our root Vue instance concerns the modal
    window. Let''s abstract this into a separate component. First, we''ll create the
    new component file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll transplant the markup from the view to the component. To ensure the
    carousel stays decoupled from the modal window, we'll replace the `ImageCarousel` declaration
    in the markup with a slot.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ModalWindow.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can now declare a `ModalWindow` element in the hole we just created in the
    view, with an `ImageCarousel` as content for the slot.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We will now move the needed functionality from the root instance and place it
    inside the `script` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ModalWindow.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next we import `ModalWindow` in the entry file.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s move any modal-related CSS rules into the SFC as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: After the project builds, you'll notice the modal window won't open. We'll fix
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check Vue Devtools, you''ll see a `ModalWindow` component in the hierarchy
    of components now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa3d425e-e848-4b0a-87fa-a45c5e02f7a7.png)Figure 6.13\. Vue Devtools
    showing hierarchy of componentsThe representation of our app in Vue Devtools is
    slightly misleading. It makes it seem as though `ImageCarousel` is a child of `ModalWindow`.
    Even though `ImageCarousel` renders within `ModalWindow` due to the slot, these
    components are actually siblings!'
  prefs: []
  type: TYPE_NORMAL
- en: Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its initial state, the modal window is hidden with a `display: none` CSS
    rule. To open the modal, the user must click the header image. A click event listener
    will then set the root instance data property `modelOpen` to true, which will,
    in turn, add a class to the modal to overwrite the `display: none` to `display:
    block`.'
  prefs: []
  type: TYPE_NORMAL
- en: After refactoring, however, `modalOpen` has been moved into the `ModalWindow` component along
    with the rest of the modal logic, and hence the modal opening functionality is
    currently broken. One possible way to fix this is to let the root instance manage
    the opened/closed state of the modal by moving the logic back into the root instance.
    We could then use a prop to inform the modal when it needs to open. When the modal
    is closed (this happens in the scope of the modal component, where the close button
    is) it would send an event to the root instance to update the state.
  prefs: []
  type: TYPE_NORMAL
- en: This approach would work, but it's not in the spirit of making our components
    decoupled and reusable; the modal component should manage its own state. How,
    then, can we allow the modal to keep its state, but let the root instance (the
    parent) change it? An event won't work, as events can only flow up, not down.
  prefs: []
  type: TYPE_NORMAL
- en: '`ref` is a special property that allows you to directly reference a child component''s
    data. To use it, declare the `ref` property and assign it a unique value, such
    as `imagemodal`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now the root instance has access to this specific `ModalWindow` component's
    data via the `$refs` object. This means we can change the value of `modalOpen` inside
    a root instance method, just like we could from within `ModalWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now we can call the `openModal` method in the header image's click listener,
    thus restoring the modal opening functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It is an anti-pattern to use `ref` when the normal methods of interacting with
    a component, props and events, are sufficient. `ref` is usually only required
    for communicating with elements that fall outside of the normal flow of a page,
    as a modal window does.
  prefs: []
  type: TYPE_NORMAL
- en: Header image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now abstract the header image into a component. Firstly, create a new `.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now move in the markup, data, and CSS. Take note of the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: An event `header-clicked` must be emitted. This will be used to open the modal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image URL is passed as a prop, `image-url`, then transformed to be an inline
    style rule via a computed property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource/assets/components/HeaderImage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once you've imported this component in `resources/assets/js/app.js`, declare
    it in the main template. Be sure to bind the `image-url` prop and handle the click
    event.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Feature lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue our process of refactoring Vuebnb into components, and abstract
    the amenities and prices lists. These lists have a similar purpose and structure,
    so it makes sense that we create a single, versatile component for both.
  prefs: []
  type: TYPE_NORMAL
- en: Let's remind ourselves of how the markup for the lists currently looks.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between the two lists is inside the `<div class="content">...</div>` section,
    as the data being displayed in each list has a slightly different structure. The
    amenities have an icon and a title whereas the prices have a title and a value.
    We'll use a slot in this section to allow the parent to customize the content
    for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s create the new `FeatureList` component file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We'll move the markup for one of the lists in, using a slot to replace the list
    content. We'll also add a prop for the title and move in any list-related CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/FeatureList.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and import `FeatureList` into `resources/assets/js/app.js`, and add
    it to the locally registered components. Now we can use `FeatureList` in our main
    template, with a separate instance for each list.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Scoped slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FeatureList` component works but is quite weak. The majority of the content
    comes through the slot and so it seems like the parent is doing too much work,
    and the child too little. Given that there's repeated code in both declarations
    of the component (`<div class="list-item" v-for="...">`), it'd be good to delegate
    this to the child.
  prefs: []
  type: TYPE_NORMAL
- en: To allow our component template to be more versatile, we can use a *scoped slot* instead
    of a regular slot. Scoped slots allow you to pass a *template* to the slot instead
    of passing a rendered element. When this template is declared in the parent, it
    will have access to any props supplied in the child.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a component `child` with a scoped slot might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A parent that uses this component will declare a `template` element, which
    will have a property `slot-scope` that names an alias object. Any props added
    to the slot in the child template are available as properties of the alias object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the steps of including a scoped slot with our `FeatureList` component.
    The goal is to be able to pass the list items array in as a prop and get the `FeatureList` component
    to iterate them. That way, `FeatureList` is taking ownership of any repeated functionality.
    The parent will then provide a template to define how each list item should display.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Focusing now on the `FeatureList` component, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `items` to the props array in the configuration object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`items` will be array which we iterate inside the `<div class="content">` section'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the loop, `item` is an alias to any particular list item. We can create a
    slot and bind that list item to the slot using `v-bind="item"`. (We haven't used `v-bind` without
    an argument before, but this will bind the properties of an entire object to the
    element. This is useful as the amenities and prices objects have different properties
    and we now don't have to specify them.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`resources/assets/components/FeatureList.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll return to our view. Let''s work on the amenities list first:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `template` element inside the `FeatureList` declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The template must include the `slot-scope` property to which we assign an alias, `amenity`.
    This alias allows us to access the scoped props.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the template, we can use exactly the same markup we had before to display
    our amenity list items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here's the complete main template with prices as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Although this approach has just as much markup as before, it has delegated more
    common functionality to the component, which makes for a more robust design.
  prefs: []
  type: TYPE_NORMAL
- en: Expandable text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created functionality back in [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping
    Vuebnb, Your First Vue.js Project*, to allow the About text to be partially contracted
    when the page loads and expanded to its full length by clicking a button. Let''s
    abstract this functionality into a component as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Move all the markup, configuration, and CSS into the new component. Note that
    we use a slot for the text content.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ExpandableText.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Once you've imported this component in `resources/assets/js/app.js`, declare
    it in the main template, remembering to interpolate the `about` data property
    in the slot.
  prefs: []
  type: TYPE_NORMAL
- en: '`resource/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With that done, most of the data and functionality of the Vuebnb client app
    has been abstracted into components. Let's take a look at `resources/assets/js/app.js` and
    see how bare it has become!
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s change tack now and discuss how Vue renders components. Take a look
    at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for Vue to be able to render this component to the page, it will first
    transform the template string into a JavaScript object using an internal template
    compiler library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31012e53-0217-44bf-b43c-e5c75c221a59.png)Figure 6.14\. How the template
    compiler turns a template string into an object'
  prefs: []
  type: TYPE_NORMAL
- en: Once the template has been compiled, any state or directives can easily be applied.
    For example, if the template includes a `v-for`, a simple for-loop can be used
    to multiply the nodes and interpolate the correct variables.
  prefs: []
  type: TYPE_NORMAL
- en: After that, Vue can interface with the DOM API to synchronize the page with
    the state of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Render functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than supplying a string template for your component, you can instead
    supply a `render` function. Without understanding the syntax, you can probably
    tell from the following example that the `render` function is generating a semantically
    equivalent template to the string template in the previous example. Both define
    a `div` with an `id` attribute of `my-component` and with inner text of `My component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Render functions are more efficient because they don't require Vue to first
    compile the template string. The downside, though, is that writing a render function
    is not as easy or expressive as markup syntax, and, once you get a large template,
    will be difficult to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Vue Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be great if we could create HTML markup templates in development,
    then get Vue's template compiler to turn them into `render` functions as part
    of the build step? That would be the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly what happens to single-file components when Webpack transforms
    them via *Vue Loader*. Take a look at the following snippet of the JavaScript
    bundle and you can see the `ImageCarousel` component after Webpack has transformed
    and bundled it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/69fddd6b-68ae-49e6-ac7a-940ebb773a41.png)Figure 6.15\. image-carousel
    component in the bundle file'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the main template as single-file component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template for our app's root instance is the content within the `#app` element
    in the *app* view. A DOM template like this requires the Vue template compiler,
    just like any string template does.
  prefs: []
  type: TYPE_NORMAL
- en: If we were able to abstract this DOM template into an SFC as well, it would
    mean all our frontend app templates would be built as `render` functions and would
    not need to invoke the template compiler at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new SFC for the main template and call it `ListingPage`, as
    this part of the app is our listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll move the main template, root configuration and any relevant CSS into
    this component. Take note of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to put the template inside a wrapping `div` as components must have
    a single root element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now remove the `@` escapes as this file won't be processed by Blade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component is now adjacent to the other components we created, so be sure
    to change the relative paths of the imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Mounting the root-level component with a render function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the mount element in our main template will be empty. We need to declare
    the `Listing` component, but we don't want to do it in the view.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If we do it like that, we wouldn't fully eliminate all string and DOM templates
    from our app, so we'll keep the mount element empty.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can now declare `Listing` with a render function inside our root instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: To avoid getting side-tracked, I won't explain the syntax of `render` functions
    here, as this is the only one we'll write throughout the book. If you'd like to
    learn more about `render` functions, check out the Vue.js documentation at [https://vuejs.org/](https://vuejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that Vuebnb is no longer using string or DOM templates, we don't need the
    template compiler functionality anymore. There's a special build of Vue we can
    use which doesn't include it!
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of different environments and use cases for running Vue.js.
    In one project, you might load Vue directly in the browser, in another you may
    load it on a Node.js server for the purpose of server rendering. As such, there
    are different *builds* of Vue provided so you can choose the most suitable one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking in the *dist* folder of the Vue NPM package, we can see eight different
    Vue.js builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98257a32-3bf0-455f-bd0a-9ebee829d1e9.png)Figure 6.16\. The various
    builds in the node_modules/vue/dist folder'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vue.js website provides a table to explain these eight different builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | UMD | CommonJS | ES Module |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Full** | vue.js | vue.common.js | vue.esm.js |'
  prefs: []
  type: TYPE_TB
- en: '| **Runtime-only** | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Full (production)** | vue.min.js | - | - |'
  prefs: []
  type: TYPE_TB
- en: '| **Runtime-only (production)** | vue.runtime.min.js | - | - |'
  prefs: []
  type: TYPE_TB
- en: Module system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The columns of the table categorize the builds as either *UMD*, *CommonJS*, or *ES
    Module*. We discussed CommonJS and ES modules back in [Chapter 5](f7d2046c-81c6-416b-977e-2f166a911244.xhtml), *Integrating
    Laravel And Vue.js with Webpack*, but we didn't mention **UMD** (**Universal Module
    Definition)**. The main things you need to know about UMD is that it's yet another
    module pattern, and that it works well in a browser. UMD is the choice if you
    are directly linking to Vue in a `script` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Production builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rows of the table are split into two types: full or runtime, and with or
    without production.'
  prefs: []
  type: TYPE_NORMAL
- en: A *production* build is used in a deployed app, as opposed to one running in
    development. It has been minified, and any warnings, comments, or other development
    options are turned off or stripped out. The point is to make the build as small
    and secure as possible, which is what you'd want in production.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is only a UMD version of the production build as only UMD runs
    directly in a browser. CommonJS and ES Module are to be used in conjunction with
    a build tool, like Webpack, which provides its own production processing.
  prefs: []
  type: TYPE_NORMAL
- en: Full build vs runtime-only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've been discussing, Vue includes a template compiler for converting any
    string or DOM templates to render functions at runtime. The *full* build includes
    the template compiler and is what you would normally use. However, if you've already
    transformed your templates into render functions in development, you can use the *runtime-only* build,
    which drops the compiler and is about 30% smaller!
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good build for Vuebnb is `vue.runtime.esm.js` since we're using Webpack and
    we don't need the template compiler. We could also use `vue.runtime.common.js`,
    but that wouldn't be consistent with our use of ES modules elsewhere in the project.
    In practice, though, there is no difference as Webpack will process them in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we include Vue at the top of our entry file with the statement `import
    Vue from 'vue'`. The last `'vue'` is an *alias* to the Vue build that Webpack
    resolves when it runs. Currently, this alias is defined within the default Mix
    configuration and is set to the build `vue.common.js`. We can override that configuration
    by adding the following to the bottom of our `webpack.mix.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'After a new build, we should expect to see a smaller bundle size due to the
    template compiler being removed. In the following screenshot, I''ve shown the
    bundle before and after I ran a `dev` build in a separate Terminal tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21dc9800-03ab-44d0-9134-ac9040b78935.png)Figure 6.17\. The difference
    between bundle sizes after applying the runtime-only build'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that without the template compiler we can no longer provide string
    templates for our components. Doing so will cause an error at runtime. That shouldn't
    be a problem though since we've got the far more powerful option of SFCs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how components are used to create reusable custom elements.
    We then registered our first Vue.js components, defining them with template strings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at component communication with props and custom events. We
    used this knowledge to build an image carousel within the listing page modal window.
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of the chapter, we got an introduction to single-file components,
    which we used to refactor Vuebnb into a component-based architecture. We then
    learned how slots can help us make more versatile components by combining parent
    and child content.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how the runtime-only build can be used to give a Vue app a smaller
    size.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will make Vuebnb a multi-page app by building a home
    page, and using Vue Router to allow navigation between pages without reloading.
  prefs: []
  type: TYPE_NORMAL
