- en: The Idea of Functional Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen in the past chapters how to write pure functions and lambdas. These
    are the basic building blocks of functional programming. It's time to take them
    to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to obtain more functions from existing functions,
    thus building complex behavior from the simple examples that we've looked at so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Composing functions in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic decomposition strategy for functions with multiple arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing duplication (or code similarity) using functional composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is on GitHub at [https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp),
    in the `Chapter04` folder. It includes and uses `doctest`, which is a single-header
    open source unit testing library. You can find it in its GitHub repository here:
    [https://github.com/onqtam/doctest](https://github.com/onqtam/doctest).'
  prefs: []
  type: TYPE_NORMAL
- en: What is functional composition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions and lambdas are the basic blocks of functional programming. But
    all the examples we've looked at so far use very simple functions. We obviously
    deal with much more complex problems in our industry. However, as we've seen,
    we still want our basic blocks to be very simple, since we want to understand
    and maintain them easily. So, how can we create complex programs from the simple
    lambdas and pure functions we've seen so far? Functional programming has a simple
    answer—let's create more complex functions by combining the simple functions we
    have. The fundamental way to create complex functions in functional programming
    is functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: Functional composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, functional composition is very simple. We'll use a basic example
    to illustrate it. We will start with our `increment` function. Also, from now
    on, I will use test cases to show how the code works. I'm using `doctest`, a single-header
    open source unit testing library ([https://github.com/onqtam/doctest](https://github.com/onqtam/doctest)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our `increment` function with a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also say that, for some reason, we need to increment the value twice.
    Since we''re thinking in functions, we want to reuse our function. We could, therefore,
    call it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine if we only need a double increment in a single place. If we
    need it in multiple places in our code, we will need a function. It''s easy enough
    to extract a function that performs a double increment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we look at `incrementTwiceLambda`, we can see that it is formed by `increment`
    called on the result of `increment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s let it rest for now, and move on to another case. We now want to compute
    the square of a number, still using functions. It''s easy to write, once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next requirement is to compute the incremented square of a value. Once
    again, we could extract a lambda that combines `increment` and `square` as we
    need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s very nice. However, we have a hidden similarity in the code. Let''s
    look at the `incrementTwiceLambda` and `incrementSquareLambda` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: They both have the same pattern—we created a function, *C*, by having a function, *f*,
    call on the result of another function, *g*, applied to the value passed to our
    function, *C*. This is a kind of code similarity that we can expect to see a lot
    when we use small, pure functions. It would be nice to have a name and maybe even
    a way to implement it without writing so much boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out, it does have a name—this is functional composition. In general
    terms, for any *f* or *g* function with single arguments, we can obtain a function, *C*,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/332f1ee6-da2c-45e7-8605-58a475e6b52f.png) meaning that for every value
    of *x*, ![](img/fc102ff6-21a4-45e8-aa49-1b6bf0f9daf7.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The ![](img/14204b22-3e95-49e7-b99f-9726698eca8d.png) symbol is the mathematical
    operator for functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, what we're actually trying to do is to obtain functions from
    other functions by having operations on the functions themselves! It's a type
    of calculus that uses lambdas instead of numbers, and defines operations on lambdas.
    Lambda calculus is an apt name, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: This is the concept of functional composition. The next question is—can we eliminate
    the boilerplate code?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functional composition in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It would be nice to have an operator that allows us to perform functional composition.
    Indeed, other programming languages provide one; for example, in Groovy, we can
    use the `<<` operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, C++ doesn't (yet) have a standard operator for functional composition.
    However, C++ is a powerful language, so it should be possible to write our own
    function that performs functional composition, at least for limited cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s clearly define the problem. We would like to have a `compose` function
    that receives two lambdas, `f` and `g`, and returns a new lambda that calls `value
    -> f(g(value)`. The simplest implementation in C++ would look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this code doesn''t compile because C++ doesn''t allow parameters
    with `auto` types. One way would be to specify the function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This works fine and passes the tests. But now our `compose` function depends
    on the function type. That's not very useful, since we will have to reimplement
    `compose` for every type of function that we need. It's less boilerplate than
    before, but still far from ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is exactly the type of problem resolved by C++ templates. Maybe they
    can help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, this code works! So, we now know that, although there is no operator
    for functional composition in C++,  we can implement it with an elegant function.
  prefs: []
  type: TYPE_NORMAL
- en: Please note how compose returns a lambda, which uses lazy evaluation. Therefore,
    our functional composition function also uses lazy evaluation. This is an advantage,
    since the composed lambda will only be initialized when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: Functional composition is not commutative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s important to realize that functional composition is not commutative.
    Indeed, it''s easy to see why when we speak—*the increment square of a value*
    is different from *squaring the increment of a value*. However, we need to be
    careful in code because the two differ just by the order of the parameters for
    the compose function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've seen what functional composition is, how to implement it in C++, and how
    to use it for simple cases. I bet you're eager to try it now for more complex
    programs. We'll get there, but first let's look at more complex situations. What
    about functions with multiple parameters?
  prefs: []
  type: TYPE_NORMAL
- en: Complex functional composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our compose function has a problem—it only works with lambdas that receive one
    argument. So, what do we do if we want to compose functions with multiple arguments?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following example—given two lambdas, `multiply` and `increment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Can we obtain a lambda that increments the result of the multiplication?
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, we cannot use our `compose` function since it assumes that both
    functions have one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, what are our options?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing more compose functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could implement a variant of the `compose` function that takes a function, `f`,
    which takes one argument, and another function, `g`, which takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is simple enough. However, if we need to obtain a function that
    multiplies the incremented values of its arguments, we need yet another `compose`
    variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What if we only want to increment one of the arguments? There are a lot of possible
    combinations, and while we can cover them with multiple variants of compose, it's
    worth visiting other options as well.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing functions with multiple arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of implementing more variations of compose, we could look into the
    `multiply` function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a trick we can use to decompose it into two lambdas, each taking one
    argument. The key idea is that a lambda is just a value, so it can be returned
    by a function. We''ve already seen this in action in our `compose` function; it
    creates and returns a new lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, therefore, decompose a function with two arguments by returning a new
    lambda with a single argument that captures the `first` argument from the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s unpack this code, because it''s quite complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`multiplyDecomposed` takes one argument, `first`, and it returns a lambda.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned lambda captures `first` from the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then receives one parameter, `second`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the result of the addition of `first` and `second`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It turns out that any function with two arguments can be decomposed like this.
    We can, therefore, write a generic implementation using templates. We just need
    to use the same trick—specify the function type as a template type, and proceed
    with using it in our decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method is promising; it might simplify our implementation of functional
    composition. Let's see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing the result of multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move forward toward our goal. Can we use `compose` to obtain a function
    that increments the result of the multiplication? It''s easy now, since `add`
    is decomposed into lambdas that receive one argument. We would expect to just
    compose `multiplyDecomposed` with `increment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, this doesn't compile. Our compose function assumes that the result
    of `multiplyDecomposed(first)` can be passed to increment. But `multiplyDecompose(first)`
    returns a lambda, and `increment` takes an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need, therefore, to compose `increment` with `multipyDecomposed(first)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This works, but we have not yet achieved our goal. We didn't obtain a function
    that takes the two values in; instead, the first value is passed to `multiplyDecomposed`
    when composing it with the `increment` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this is the perfect place to use a lambda, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This definitely works, and we''ve achieved our goal! The `incrementResultOfMultiplication`
    lambda takes two parameters and returns the increment of the multiplication. It
    would be nicer, though, if we didn''t have to rewrite `multiply`. Fortunately,
    we have our `decomposeToOneParameter` function to help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's time to look at the reversed composition—what if we wanted to multiply
    the increments of both our arguments?
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying increments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to obtain a function that multiplies the increments of our arguments,
    by using our `compose` function. The simplest code, which doesn''t use `compose`,
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen, we need to decompose the `multiply` lambda first if we want
    to use our version of compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the call to `multiplyDecomposed(increment(first))`, which is
    the composition between `multiplyDecomposed` and `increment`. We can replace it
    with our `compose` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, it would be nice if we didn''t have to rewrite our `multiply` function.
    But remember that we implemented a useful function that can decompose any function
    with two parameters into two functions with a parameter. We don''t have to rewrite
    `multiply`; we just have to call our decomposition utility on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We've achieved our goal!
  prefs: []
  type: TYPE_NORMAL
- en: Reflections on the composition and decomposition of functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a moment to look at the results and at our working method. Here's
    the good news—we made good progress with learning how to think in functions. Our
    previous examples work just by operating on functions as first-class citizens
    of our code, which is exactly the mindset we need if we want to design applications
    using the functional paradigm. The decomposition and recomposition of functions
    is incredibly powerful; master it and you will be able to implement very complex
    behavior with very little code.
  prefs: []
  type: TYPE_NORMAL
- en: As for the resulting code, it has an interesting property—we can generalize
    it to reuse on many combinations of functions.
  prefs: []
  type: TYPE_NORMAL
- en: But we're not done yet! We can use these functions to remove certain types of
    duplication from our code. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Using functional composition to remove duplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how we can write functions that compose lambdas in various
    ways. But code tends to repeat itself, so we would like to make this method more
    general. We can indeed take this even further; let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing incrementResultOfMultiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take another look at our `incrementResultOfMultiplication` lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s something interesting about it—it''s not specific to `increment` and
    `multiply`. Since lambdas are just values, we can pass them as parameters and
    obtain a general `composeWithTwoParameters` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function allows us to *compose any other two functions,* `f` *and* `g`*,
    where* `g` *takes two parameters and* `f` *only one parameter*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do some more of this. Let's generalize `multiplyIncrementedValues`.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing multiplyIncrementedValues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, we can easily generalize our `multiplyIncrementedValues` lambda,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same manner, we need to pass the `multiply` and `increment` lambdas
    as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can use this new function to create a function, *C*, which implements `g(f(first),
    f(second))`, no matter what `g` and `f` are.
  prefs: []
  type: TYPE_NORMAL
- en: Our work here is done for now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you thought that pure functions and lambdas are powerful, you will now realize
    how much you can do by composing them! In this chapter, you learned what functional
    composition is and how to compose functions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also worked on something much more important. In this chapter, we really
    started to think in functions. Here are some things we learned:'
  prefs: []
  type: TYPE_NORMAL
- en: A lambda is just a value, so we can have functions that return lambdas, or lambdas
    that return lambdas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we can have functions that receive one or more lambdas and return a new
    lambda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any function with multiple arguments can be decomposed into multiple lambdas
    with single arguments and captured values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations with functions are quite complex. If you feel your head spinning,
    that's OK—we've been playing with very powerful and abstract concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's very difficult to instantly come up with a solution when it comes to various
    ways of composing functions. The best way is to go step by step, have a clear
    goal and a clear mind, and use the techniques described in this chapter to improve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional composition can help remove some types of duplication; for example,
    when you have multiple compositions between different functions with similar signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is a cost to implementing the compose family of functions as
    we did in this chapter—a higher level of abstraction. It's quite difficult to
    understand how the functions that perform operations on lambdas work; indeed,
    trust me that I also have trouble understanding the results. Still, they are quite
    easy to use once you understand their goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After all this effort, let's take a moment to consider the result. Imagine that
    any two functions you already have in your code base, or in libraries that you
    use, could be composed just with a function call and expressed as variables. Moreover,
    these calls can stack; the functions you obtain can be composed even more. Functional
    composition is extremely powerful; with very simple lambdas and a few operations
    with functions, we can very quickly implement complex behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to compose two functions. There's yet another operation on functions
    we need to learn—obtaining new functions by playing around with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is functional composition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional composition has a property that is usually associated with mathematical
    operations. What is it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you turn an `add` function with two parameters into two functions with
    one parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you write a C++ function that comprises two single argument functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of functional composition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the potential disadvantages of implementing operations on functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
