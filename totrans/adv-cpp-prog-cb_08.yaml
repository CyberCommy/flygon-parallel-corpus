- en: Creating and Implementing Your Own Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create your own custom container in C++
    by leveraging an existing container that the C++ Standard Template Library already
    provides. This chapter is important because, in a lot of cases, your code will
    have common operations that are performed on a Standard Template Library container
    that are duplicated throughout the code (as is the case with implementing thread
    safety). The recipes in this chapter will teach you how to easily encapsulate
    this duplicated code into a custom container without having to write your own
    container from scratch or littering your code with duplicated logic that is hard
    to test and validate.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you will learn the skills needed to implement a custom
    wrapper container, capable of ensuring that `std::vector` is maintained in sorted
    order at all times. The first recipe will teach you the basics of how to create
    this wrapper. The second recipe will expand upon the first, teaching you how to
    redefine the interface of a container based on how the container operates. In
    this case, since the container is always in sorted order, you will learn why providing
    a `push_back()` function doesn't make sense, even though all we are doing is creating
    a wrapper (the addition of the wrapper changes the concept of the container itself).
    In the third recipe you will learn the skills to work with iterators and why,
    in this example, `const` iterators can only be supported. Finally, we will add
    several additional APIs to our container to provide a complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple wrapper around std::vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the relevant parts of the std::set API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the relevant parts of the std::vector API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, the reader must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, the reader must install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter08](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple wrapper around std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create our own custom container by wrapping
    an existing Standard Template Library container to provide custom functionality
    as needed. In the later recipes, we will build upon this custom container to eventually
    create a complete container based on `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is important because oftentimes, code that leverages an existing
    container is accompanied by common logic that is duplicated each time the container
    is used. This recipe (and this entire chapter) will teach you how to encapsulate
    this duplicated logic into your own container so that it can be independently
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to try out the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each one does and how it relates to the lessons being taught in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a simple wrapper container around
    `std::vector`. Most of the time, the **Standard Template Library** (**STL**) containers
    are sufficient to perform the tasks that your applications might need, and, in
    general, creating your own containers should be avoided as they are complicated
    to get right.
  prefs: []
  type: TYPE_NORMAL
- en: From time to time, however, you might find yourself repeatedly performing the
    same actions on a container. When this occurs, it is often helpful to wrap these
    common operations into a wrapper container that can be independently unit tested
    to ensure that the container works as expected. For example, the STL containers
    are not thread safe. If you need a container to function with thread safety each
    time you access the container, you will first need to ensure that you have exclusive
    access to the container (for example, by locking a `std::mutex`) before the container
    operation can take place. This pattern will be repeated throughout your code,
    increasing the chances of entering deadlock. This issue can be prevented by creating
    a container wrapper that adds a `std::mutex` to each public member of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, let''s consider an example where we create a vector (that is,
    an array of elements in contiguous memory that you must have direct access to)
    that must remain in sorted order at all times. To start, we will need some headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement our container, we will leverage `std::vector`. Although we could
    implement our own container from scratch, most of the time this is not needed,
    and should be avoided, as such a task is extremely time consuming and complicated.
    We will need the `algorithm` header for `std::sort` and `iostream` for testing.
    So let''s add this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The container's definition will start with its template definition, which is
    the same as the definition of the `std::vector` with an added `Compare` type that
    will be used to define the order in which we would like our container to be sorted.
    By default, the container will be sorted in ascending order, but this can be changed
    as needed. Finally, the container will have one private member variable that is
    an instance of the `std::vector` that this container is wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the container to function properly with C++ utilities, template functions,
    and even some key language features, the container will need to define the same
    aliases as `std::vector`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no need to manually define the aliases ourselves. Instead,
    we can simply forward the declaration of the aliases from the `std::vector` itself.
    The exception to this is the `compare_type` alias, as this is an alias that we
    are adding to our wrapper container that represents the type used by the template
    class for the comparison operation that will ultimately be given to `std::sort`.
  prefs: []
  type: TYPE_NORMAL
- en: We also do not include the non-const versions of the reference aliases. The
    reason for this is that our container must keep the `std::vector` in sorted order
    at all times. If we provide the user with direct write access to the elements
    stored within `std::vector`, the user could put `std::vector` into an unordered
    state without our custom container having the ability to reorder as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's define our constructors (which map to the same constructors that
    `std::vector` provides).
  prefs: []
  type: TYPE_NORMAL
- en: Default constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following defines our default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since the default constructor for `std::vector` produces an empty vector, there
    is no additional logic that we must add as an empty vector is sorted by default.
    Next, we must define a constructor that takes a custom allocator.
  prefs: []
  type: TYPE_NORMAL
- en: Custom allocator constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our custom allocator constructor is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous constructor, this constructor creates an empty vector,
    but with an allocator that already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Count constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next two constructors allow the user of the API to set the minimum size
    of the vector as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first constructor will create the vector of `count` elements, all initialized
    with a value of `value`, while the second creates the elements with their default
    values (for example, a vector of integers would be initialized to zero).
  prefs: []
  type: TYPE_NORMAL
- en: Copy/move constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support the ability to copy and move our container, we will need to implement
    a copy and move constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since our custom wrapper container must always remain in sorted order, copying
    or moving one container to another doesn't change the order of the elements in
    the container, meaning that no sort operation is needed for these constructors
    either. We do, however, take special care to ensure that a copy and a move occur
    properly by copying or moving the internal `std::vector` that our container encapsulates.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, we also provide a move constructor that allows us, just like
    the `std::vector`, to move while providing a custom allocator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will provide a constructor that takes an initializer list.
  prefs: []
  type: TYPE_NORMAL
- en: Initializer list constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will also add a constructor that takes an initializer list, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the initializer list could provide the initial
    elements for the `std::vector` in any order. As a result, we must sort the list
    after the vector is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test this container to ensure that each constructor works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code block, we test our constructors by calling each
    one, which results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05b7686-5517-4965-80e9-17420fc8564b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, each constructor was successfully executed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to our container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our constructors in place, we will also need to provide the ability to
    manually add data to our container (for example, if we initially created our container
    using the default constructor).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s focus on the `push_back()` function that `std::vector` provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the `push_back()` function has the same
    function signatures as the version `std::vector` provides, allowing us to simply
    forward the function call to `std::vector`. The problem is, pushing a value to
    the end of `std::vector` could result in `std::vector` entering an unordered state,
    requiring us to reorder `std::vector` on every single push (the result of requiring
    `std::vector` to remain in sorted order at all times).
  prefs: []
  type: TYPE_NORMAL
- en: One way to resolve this issue is by adding another member variable to the container
    wrapper that tracks when the `std::vector` is tainted. Another way to implement
    these functions is to add the elements in a sorted order (that is, traverse the
    vector sorted order and place the element in the proper position, shifting the
    remaining elements as needed). If elements are rarely added to the `std::vector`,
    then this approach might outperform a call to `std::sort`. If, however, elements
    are added to the `std::vector` a lot, then the tainted approach might perform
    better.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of creating a container wrapper is that these types
    of optimizations can be implemented and tested without changing the code that
    relies on the container itself. Both implementations (or others) can be implemented,
    tested, and compared to determine which optimization is best suited to your particular
    needs, while the code that uses the container never changes. Not only does this
    declutter the code, but this added encapsulation strikes at the heart of object-oriented
    design, ensuring that each object in your code has only one purpose. In the case
    of the container wrapper, the purpose is to encapsulate the operation of maintaining `std::vector`
    in sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, we will also add the `emplace_back()` version of `push_back()`,
    just like `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The difference with the `emplace_back()` function compared to the `std::vector`
    equivalent is that our version does not return a reference to the element created.
    This is because of the fact that the sort would invalidate the reference, making
    it impossible to return a valid reference.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of push/emplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s test our `push_back()` and `emplace` functions to ensure that
    they are called properly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we call each version of `push_back()`
    as well as the `emplace_back()` function to ensure that they are properly called
    as expected, which results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e13fb0-f3e4-460b-8109-137c99e246ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can take this a step further and add better test data to our test container,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we add the integers `4`, `42`, `15`,
    `8`, `23`, and `16` to our vector. In the next recipe, we will steal APIs from
    `std::set` to provide better `push` and `emplace` APIs to our container, as well
    as an output function to get a better idea of what `std::vector` contains and
    the order in which it contains its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the relevant parts of the std::set API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add APIs from `std::set` to the custom
    container we created in the first recipe. Specifically, we will learn why `std::vector::push_back()`
    and `std::vector::emplace_back()` do not make sense when used with our custom
    container that always maintains its internal elements in sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to try out the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first recipe of this chapter, we created a custom container wrapper that
    mimics a `std::vector`, but which ensures that elements in the vector remain in
    sorted order at all times, including the addition of the `std::vector::push_back()`
    function and the `std::vector::emplace_back()` function. In this recipe, we will
    add the `std::set::insert()` and `std::set::emplace()` functions to our custom
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Since our container wrapper always ensures that `std::vector` is in sorted order,
    there is no difference between adding an element to the front, back, or middle
    of the vector. No matter which position an element is added to the vector, it
    must be sorted prior to the vector being accessed, which means that the order
    in which the element is added will likely change regardless of which position
    it is added in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lack of concern for where an element is added is similar to that of `std::set`.
    The `std::set` adds elements to a set, and then later returns `true` or `false`,
    depending on whether the element being tested is a member of the set. The `std::set`
    provides the `insert()` and `emplace()` functions for adding elements to the set.
    Let''s add these same APIs to our custom container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we have added an `insert()` function
    (both the copy and the move), as well as an `emplace()` function, which does nothing
    more than call their `push_back()` and `emplace_back()` equivalents, ensuring
    that the parameters passed to these functions are properly forwarded. The only
    difference between these APIs and the APIs that we added in the previous recipe, *Using
    a simple wrapper around std::vector*, is the name of the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: Although such a change might seem trivial, this is important as it redefines
    the concept between the container's APIs with the user. The `push_back()` and
    `emplace_back()` functions suggest that the element is added to the back of the
    vector when, in fact, it is not. Instead, they are simply added to the `std::vector`,
    and the order of the `std::vector` is changed based on the value of the element
    added. For this reason, the `push_back()` and `emplace_back()` functions are needed,
    but should either be renamed or marked as private to ensure that the user only
    uses the `insert()` and `emplace()` versions to properly manage expectations.
    When writing your own containers (even for wrappers), it is important that you
    adhere to the principle of least surprise, which ensures that the APIs that a
    user is using will work the way that the APIs might suggest.
  prefs: []
  type: TYPE_NORMAL
- en: Working with iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add iterator support to the custom container
    we started in the first recipe, which wraps a `std::vector`, ensuring that its
    contents remain in sorted order at all times.
  prefs: []
  type: TYPE_NORMAL
- en: To add iterator support, we will learn how to forward the iterators already
    provided by the `std::vector` (we will not be implementing iterators from scratch
    as that is a topic way outside the scope of this book, as implementing a container
    from scratch is incredibly difficult).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to go through the following steps to try out this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::vector` that our custom container wraps already provides an efficient
    implementation of iterators that can be used to work with our container. We will,
    however, need to forward specific parts of the APIs that `std::vector` provides
    to ensure the iterators work properly, including key C++ features, such as range-based
    for loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s add the last remaining constructor that `std::vector` provides
    to our custom container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the iterator type that we are given
    is not defined. The iterator could come from another instance of our container
    or it could come from `std::vector` directly, which does not store its elements
    in sorted order. Even if the iterator came from an instance of our custom container,
    the order in which the iterator stores elements might not be the same as the order
    of the container elements. As a result, we must sort `std::vector` after it is
    initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to construction, it is important that our custom container also
    includes the iterator-based alias that `std::vector` provides, as these aliases
    are required for the container to properly work with C++ APIs. The following is
    an example code snippet for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, like the aliases defined in the first
    recipe, we only need to forward declare the aliases that the `std::vector` already
    provided so that our custom container can leverage them as well. The difference
    is that we do not include the non-const versions of these iterator aliases. Since
    our custom container must leave the data in sorted order at all times, we must
    restrict the user's ability to modify the iterator's contents directly as this
    could result in changing the order of the container's elements, without the ability
    for our container to reorder as needed. Instead, modifications to the container
    should be made through the use of `insert()`, `emplace()`, and `erase()`.
  prefs: []
  type: TYPE_NORMAL
- en: C++ template-based functions rely on these aliases to properly implement their
    features, which also include range-based for loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are a series of member functions, based on iterators, that `std::vector`
    provides that should also be forwarded through our custom container. The following
    code depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The first set of member functions are the `begin()` functions, which provide
    an iterator representing the first element in the `std::vector`. As with the aliases,
    we do not forward the non-const versions of these member functions. In addition,
    we include the `c` versions of these functions for completeness. In C++17, these
    are optional, as you can use `std::as_const()` instead if preferred. The next
    set of iterators is the `end()` iterators, which provide an iterator that represents
    the end of the `std::vector` (not to be confused with the iterator that represents
    the last element in the `std::vector`). The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, and as with most of these member functions,
    we simply need to forward the APIs to the private `std::vector` that our custom
    container encapsulates. This same process can be repeated for `rbegin()`, and
    `rend()`, which provide the same APIs as earlier, but return a reverse iterator,
    which traverses the `std::vector` in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement the iterator-based `emplace()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although providing the `emplace()` API provides a more complete implementation,
    it should be noted that it would only be useful if further optimizations were
    made to take advantage of the intended position in the way the element is added
    to the container. This is in combination with a better approach to sorting the
    `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the preceding implementation works, it is likely to perform similarly
    to the version of `emplace()` we implemented in the first recipe. Since the custom
    container always remains in sorted order, where the element is inserted into the
    `std::vector` is irrelevant as the new order of the `std::vector` will change
    the position of the element being added. This is, of course, unless the addition
    of the position argument provides some additional support to the API to better
    optimize the addition, which our implementation doesn't do. For this reason, unless
    the `pos` argument is used for optimizations, the preceding function is likely
    redundant and unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Like the previous `emplace()` functions, we do not attempt to return the iterator
    that represents the element that was added to the container, as this iterator
    becomes invalid after the sort, and there isn't enough information about what
    was added to the `std::vector` to relocate the iterator (for example, if duplicates
    exist, there is no way to know which element was actually just added).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we implement the `erase` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the `emplace()` function, removing an element from the `std::vector`
    does not change the order of the `std::vector`, so no sort is needed. It should
    also be noted that our version of the `erase()` functions return the `const` versions.
    Once again, this is because we cannot support the non-const versions of the iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, now that we have the ability to access the elements stored in the
    container, let''s create some test logic to ensure that our container works as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To start, we will create a container from an initializer list that contains
    integers with no order. After this container is created, the `std::vector` that
    is storing these elements should be in sorted order. To prove this, let''s loop
    through the container and output the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we start by outputting a label to `stdout`
    and then we use a ranged-based for loop to iterate over our container, outputting
    each element one at a time. Finally, we output a new line after all of the elements
    have been outputted to `stdout`, which results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This output is in sorted order, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that our ranged for loop must define each element as `const`.
    This is because we do not support the non-const versions of the iterators. Any
    attempt to use the non-const versions of these iterators would result in a compiler
    error, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following compiler error (which is intended):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason that this compiler error occurs is because the ranged for loop can
    also be written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the element is not labeled as `const`,
    as the ranged for loop uses the `begin()` and `end()` member functions, resulting
    in a read-write iterator (unless you explicitly state `const`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a test for our new `emplace()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding output, the number `1` was added to our container
    in sorted order, even though we told the container to add our element to the end
    of the `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also reverse the preceding operation and validate that our `erase()`
    functions work properly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the newly added `1` has successfully been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the relevant parts of the std::vector API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will complete the custom container that we have been building
    in the first three recipes of this chapter by adding the remaining APIs that the
    `std::vector` already provides. Along the way, we will remove the APIs that do
    not make sense, or that we cannot support because our custom container must keep
    the elements in the `std::vector` in sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is important as it will show you how to properly create a wrapper
    container that can be used to encapsulate an existing container with logic that
    is needed from the container (for example, thread-safety, or in our case, element
    order).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to try out the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our custom container is capable of being constructed, added to,
    iterated over, and erased. The container does not, however, support the ability
    to directly access the container or support simple operations, such as a `std::move()`
    or comparison. To address these issues, let''s start by adding the `operator=()`
    overloads that are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first `operator=()` overload provides support for a copy assignment, while
    the second overload provides support for a move assignment. Since we only have
    a single private member variable that already provides proper copy and move semantics,
    we do not need to worry about self assignment (or moving), as the `std::vector` function's
    implementation of copy and move will handle this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your own custom containers have additional private elements, self-assignment
    checks are likely needed. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining `operator=()` overload takes an initializer list, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, like the initializer list constructor,
    we must reorder the `std::vector` after the assignment, as the initializer list
    could be provided in any order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next member functions to implement are the `assign()` functions. The following
    code snippet shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are similar to the `operator=()` overloads, but do not provide
    return values or support additional functionality. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `assign()` function fills the `std::vector` with a specific `value` count
    number of times. Since the value never changes, the `std::vector` will always
    be in sorted order, in which case there is no need to sort the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `assign()` function takes an iterator range similar to the constructor
    version of this function. Like that function, the iterator that is passed to this
    function could come from a raw `std::vector` or another instance of our custom
    container, but with a different sort order. For this reason, we must sort the
    `std::vector` after assignment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `assign()` function also provides an initializer list version that
    is the same as our `operator=()` overload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should also be noted that we have added `constexpr` to each of our functions.
    This is because most of the functions in our custom container do nothing more
    than forward a call from the custom container to the `std::vector`, and, in some
    cases, make a call to `std::sort()`. The addition of `constexpr` tells the compiler
    to treat the code as a compile-time expression, enabling it to optimize out the
    additional function call when optimizations are enabled (if possible), ensuring
    that our custom wrapper has the smallest possible overhead.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, this type of optimization was performed using the `inline` keyword.
    The `constexpr`, which was added in C++11, is not only capable of providing `inline`
    hints to the compiler, but it also tells the compiler that this function can be
    used at compile time instead of runtime (meaning that the compiler can execute
    the function while the code is being compiled to perform custom compile-time logic).
    In our example here, however, the runtime use of a `std::vector` is not possible
    as allocations are needed. As a result, the use of `constexpr` is simply for optimizations,
    and, on most compilers, the `inline` keyword would provide a similar benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of additional functions that the `std::vector` also supports,
    such as `get_allocator()`, `empty()`, `size()`, and `max_size()`, all of which
    are just direct forwards. Let''s focus on the accessors that, until now, have
    been missing from our custom container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first function that we provide to access the `std::vector` directly is the
    `at()` function. As with most of our member functions, this is a direct forward.
    Unlike a `std::vector`, however, we have no plans to add the `operator[]()` overloads
    that a `std::vector` provides. The difference between the `at()` function and
    the `operator[]()` overload is that the `operator[]()` does not check to ensure
    that the index that is provided is in bounds (that is, that it does not access
    elements outside the bounds of the `std::vector`).
  prefs: []
  type: TYPE_NORMAL
- en: The `operator[]()` overload is designed to function similarly to a standard
    C array. The problem with this operator (called the subscript operator) is that
    the lack of a bounds check opens the door for reliability and security bugs to
    make their way into your program. For this reason, the C++ core guidelines discourage
    the use of the subscript operator or any other forms of pointer arithmetic (anything
    that attempts to calculate the position of data through the use of a pointer without
    an explicit bounds check).
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the use of the `operator[]()` overload from being used, we do not
    include it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `std::vector`, we can also add the `front()` and `back()` accessors as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding additional accessors provide support for getting the first and
    last elements in our `std::vector`. As with the `at()` function, we only support
    the use of the `const_reference` versions of these functions that the `std::vector`
    already provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the code snippet `data()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The same goes for the `data()` function. We can only support the `const` versions
    of these member functions, as providing the non-const versions of these functions
    would provide the user direct access to the `std::vector`, allowing them to insert
    unordered data without the container having the ability to reorder as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now focus on the comparison operators. We start by defining the comparison
    operator's prototypes as friends of our container. This is needed as the comparison
    operators are typically implemented as non-member functions, and, as a result,
    will need private access to the container to compare the instances of `std::vector` that
    they contain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we implement the comparison operators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As with the member functions, we only need to forward the calls to the `std::vector`,
    as there is no need to implement custom logic. The same applies to the remaining
    comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can implement the `>`, `<`, `>=`, and `<=` comparison operators
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That is it! That is how you implement your own container by leveraging an existing
    container.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, in most cases, there is no need to implement a container from scratch
    unless the container you need cannot be implemented using one of the containers
    that the C++ Standard Template Library already provides.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, it is possible to not only create your own containers,
    but, more importantly, it is possible to encapsulate functionality that is duplicated
    throughout your code into a single container that can be independently tested
    and verified. This not only improves the reliability of your applications, but
    it makes them easier to read and maintain as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to use smart pointers in C++.
  prefs: []
  type: TYPE_NORMAL
