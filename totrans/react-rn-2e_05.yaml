- en: Crafting Reusable Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter is to show you how to implement React components that
    serve more than just one purpose. After reading this chapter, you'll feel confident
    about how to compose application features.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter starts with a brief look at HTML elements and how they work in terms
    of helping to implement features versus having a high level of utility. Then,
    you'll see the implementation of a monolithic component and discover the issues
    that it will cause down the road. The next section is devoted to re-implementing
    the monolithic component in such a way that the feature is composed of smaller
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the chapter ends with a discussion of rendering trees of React components,
    and gives you some tips on how to avoid introducing too much complexity as a result
    of decomposing components. I'll close this final section by reiterating the concept
    of high-level feature components versus utility components.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable HTML elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about HTML elements for a moment. Depending on the type of HTML
    element, it's either *feature-centric* or *utility-centric*. Utility-centric HTML
    elements are more reusable than feature-centric HTML elements. For example, consider
    the `<section>` element. This is a generic element that can be used just about
    anywhere, but its primary purpose is to compose the structural aspects of a feature—the
    outer shell of the feature and the inner sections of the feature. This is where
    the `<section>` element is most useful.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of the fence, you have elements such as `<p>` and `<span>`
    and `<button>`. These elements provide a high level of utility because they're
    generic by design. You're supposed to use `<button>` elements whenever you have
    something that's clickable by the user, resulting in an action. This is a level
    lower than the concept of a feature.
  prefs: []
  type: TYPE_NORMAL
- en: While it's easy to talk about HTML elements that have a high level of utility
    versus those that are geared toward specific features, the discussion is more
    detailed when *data* is involved. HTML is static markup—React components combine
    static markup with data. The question is, how do you make sure that you're creating
    the right feature-centric and utility-centric components?
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this chapter is to find out how to go from a monolithic React component
    that defines a feature, to a smaller feature-centric component combined with utility
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty with monolithic components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you could implement just one component for any given feature, it would simplify
    your job. At the very least, there wouldn't be many components to maintain, and
    there wouldn't be many communication paths for data to flow through, because everything
    would be internal to the component.
  prefs: []
  type: TYPE_NORMAL
- en: However, this idea doesn't work for a number of reasons. Having monolithic feature
    components makes it difficult to coordinate any kind of team development effort.
    The bigger monolithic components become, the more difficult they are to refactor
    into something better later on.
  prefs: []
  type: TYPE_NORMAL
- en: There's also the problem of feature overlap and feature communication. Overlap
    happens because of similarities between features—it's unlikely that an application
    will have a set of features that are completely unique to one another. That would
    make the application very difficult to learn and use. Component communication
    essentially means that the state of something in one feature will impact the state
    of something in another feature. State is difficult to deal with, and even more
    so when there is a lot of state packaged up into a monolithic component.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn how to avoid monolithic components is to experience one
    first hand. You'll spend the remainder of this section implementing a monolithic
    component. In the following section, you'll see how this component can be refactored
    into something a little more sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: The JSX markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The monolithic component we''re going to implement is a feature that lists
    articles. It''s just for illustrative purposes, so we don''t want to go overboard
    on the size of the component. It''ll be simple, yet monolithic. The user can add
    new items to the list, toggle the summary of items in the list, and remove items
    from the list. Here is the `render` method of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Definitely more JSX than is necessary in one place. You'll improve on this in
    the following section, but for now, let's implement the initial state for this
    component.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly encourage you to download the companion code for this book from [https://github.com/PacktPublishing/React-and-React-Native-Second-Edition](https://github.com/PacktPublishing/React-and-React-Native-Second-Edition).
    I can break apart the component code so that I can explain it on these pages.
    However, it's an easier learning experience if you can see the code modules in
    their entirety, in addition to running them.
  prefs: []
  type: TYPE_NORMAL
- en: Initial state and state helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s look at the initial state of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two interesting functions used to initialize the state. The first
    is `cuid()` from the `cuid` package—a useful tool for generating unique IDs. The
    second is `fromJS()` from the `immutable` package. Here are the imports that pull
    in these two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As the name suggests, the `fromJS()` function is used to construct an immutable
    data structure. `Immutable.js` has very useful functionality for manipulating
    the state of React components. You'll be using `Immutable.js` throughout the remainder
    of the book, and you'll learn more of the specifics as you go, starting with this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: For a more in-depth look at **Immutable.js**, check out Mastering Immutable.js: [https://www.packtpub.com/web-development/mastering-immutablejs](https://www.packtpub.com/web-development/mastering-immutablejs)
  prefs: []
  type: TYPE_NORMAL
- en: 'You may remember from the previous chapter that the `setState()` method only
    works with plain objects. Well, `Immutable.js` objects aren''t plain objects.
    If we want to use immutable data, you need to wrap them in a plain object. Let''s
    implement a helper getter and setter for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use your immutable component state inside of our event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Event handler implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you have the initial state, state helper properties, and the
    JSX of the component. Now it''s time to implement the event handlers themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Yikes! That''s a lot of `Immutable.js` code! Not to worry, it''s actually less
    code compared to trying to implement these transformations using plain JavaScript.
    Here are some pointers to help you understand this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setState()` is always called with a plain object as its argument. This is
    why we''ve introduced the data setter. When you assign a new value to `this.data`,
    it will call `setState()` with a plain object. You only need to worry about `Immutable.js`
    data. Likewise, the data getter returns the `Immutable.js` object instead of the
    whole state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable methods always return a new instance. When you see something like
    `article.set(...)`, it doesn't actually change the `article`, it creates a new
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `render()` method, the immutable data structures are converted back to
    plain JavaScript arrays and objects for use in the JSX markup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If necessary, take all the time you need to understand what is happening here.
    As you progress through the book, you'll see ways that immutable state can be
    exploited by React components. These event handlers can only change the state
    of this component. That is, they can't accidentally change the state of other
    components. As you'll see in the following section, these handlers are actually
    in pretty good shape as they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the rendered output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/82062a09-5dad-4592-bbd9-46ee033c8c8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Refactoring component structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have a monolithic feature component—now what? Let's make it better.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll learn how to take the feature component that you just
    implemented in the preceding section and split it into more maintainable components.
    You'll start with the JSX, as this is probably the best refactor starting point.
    Then, you'll implement new components for the feature.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll make these new components functional, instead of class-based. Finally,
    you'll learn how to use render props to reduce the number of direct component
    dependencies in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Start with the JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JSX of any monolithic component is the best starting point for figuring
    out how to refactor it into smaller components. Let''s visualize the structure
    of the component that we''re currently refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/67e3c588-4bad-4016-a2c7-1ab4337467b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The top part of the JSX is form controls, so this could easily become its own
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you have the list of articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Within this list, there's potential for an article item, which would be everything
    in the `<li>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The JSX alone paints a picture of how the UI structure can be decomposed into
    smaller React components. This refactoring exercise would be difficult without
    declarative JSX markup.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an article list component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s what the article list component implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re just taking the relevant JSX out of the monolithic component and putting
    it here. Now let''s see what the feature component JSX looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The list of articles is now rendered by the `<ArticleList>` component. The list
    of articles to render is passed to this component as a property as well as two
    of the event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, why are we passing event handlers to a child component? The reason is
    so that the `ArticleList` component doesn't have to worry about state or how the
    state changes. All it cares about is rendering content, and making sure the appropriate
    event callbacks are hooked up to the appropriate DOM elements. This is a *container
    component* concept that I'll expand upon later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an article item component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After implementing the article list component, you might decide that it's a
    good idea to break this component down further, because the item might be rendered
    in another list on another page. Perhaps the most important aspect of implementing
    the article list item as its own component is that we don't know how the markup
    will change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at it is this—if it turns out that we don''t actually need
    the item as its own component, this new component doesn''t introduce much indirection
    or complexity. Without further ado, here''s the article item component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the new `ArticleItem` component being rendered by the `ArticleList`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do you see how this list just maps the list of articles? What if you wanted
    to implement another article list that does some filtering too? If so, it's beneficial
    to have a reusable `ArticleItem` component.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an add article component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you''re done with the article list, it''s time to think about the
    form controls used to add a new article. Let''s implement a component for this
    aspect of the feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your feature component only needs to render `<AddArticle>` and `<ArticleList>`
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The focus of this component is on the feature data while it defers to other
    components for rendering UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Making components functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While implementing these new components, you might have noticed that they don't
    have any responsibilities other than rendering JSX using property values. These
    components are good candidates for *pure function components*. Whenever you come
    across components that only use property values, it's a good idea to make them
    functional. For one thing, it makes it explicit that the component doesn't rely
    on any state or lifecycle methods. It's also more efficient, because React doesn't
    perform as much work when it detects that a component is a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the functional version of the article list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the functional version of the article item component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the functional version of the add article component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Another added benefit of making components functional is that there's less opportunity
    to introduce unnecessary methods or other data.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging render props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine implementing a feature that is composed of several smaller components
    – like what you've been working on in this chapter. The `MyFeature` component
    depends on `ArticleList` and `AddArticle`. Now imagine using `MyFeature` in different
    parts of your application where it makes sense to use a different implementation
    of `ArticleList` or `AddArticle`. The fundamental challenge is substituting one
    component for another.
  prefs: []
  type: TYPE_NORMAL
- en: Render props are a nice way to address this challenge. The idea is that you
    pass a property to your component whose value is a function that returns a component
    to render. This way, instead of having the feature component directly depend on
    its child components, you can configure them as you like; they pass them in as
    render prop values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Render props** aren''t a React 16 feature. They''re a technique whose popularity
    increase coincided with the release of React 16\. It''s an officially recognized
    way to deal with dependency and substitution problems. You can read more about
    render props here: [https://reactjs.org/docs/render-props.html](https://reactjs.org/docs/render-props.html)Let''s
    look at an example. Instead of having `MyFeature` directly depend on `AddArticle`
    and `ArticleList`, you can pass them as render props. Here''s what the `render()`
    method of `MyFeature` looks like when it''s using render props to fill in the
    holes where `<AddArticle>` and `<ArticleList>` used to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `addArticle()` and `articleList()` functions are called with the same property
    values that would have been passed to `<AddArticle>` and `<ArticleList>`, respectively.
    The difference now is that this module no longer imports `AddArticle` or `ArticleList`
    as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the `index.js` where `<MyFeature>` is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot more going on here now than there was when it was just `<MyFeature>`
    being rendered. Let's break down why that is. Here is where you pass the `addArticle`
    and `articleList` render props. These prop values are functions that accept argument
    values from `MyComponent`. For example, the `onClickToggle()` function comes from
    `MyFeature` and is used to change the state of that component. You can use the
    render prop function to pass this to the component that will be rendered, along
    with any other values. The return value of these functions are what is ultimately
    rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering component trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a moment and reflect on what we've accomplished so far in this chapter.
    The feature component that was once monolithic ended up focusing almost entirely
    on the *state data*. It handled the initial state and handled transforming the
    state, and it would handle network requests that fetch state, if there were any.
    This is a typical *container component* in a React application, and it's the starting
    point for data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new components that you implemented, to better compose the feature, were
    the recipients of this data. The difference between these components and their
    container is that they only care about the properties that are passed into them
    at the time they''re rendered. In other words, they only care about *data snapshots*
    at a particular point in time. From here, these components might pass the property
    data into their own child components as properties. The generic pattern to composing
    React components is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2cfd94f4-e9eb-48f0-bc45-3f120c2c3055.png)'
  prefs: []
  type: TYPE_IMG
- en: The container component will typically contain one direct child. In this diagram,
    you can see that the container has either an item detail component or a list component.
    Of course, there will be variations in these two categories, as every application
    is different. This generic pattern has three levels of component composition.
    Data flows in one direction from the container all the way down to the utility
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Once you add more than three layers, the application architecture becomes difficult
    to comprehend. There will be the odd case where you'll need to add four layers
    of React components but, as a rule-of-thumb, you should avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: Feature components and utility components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the monolithic component example, you started off with a single component
    that was entirely focused on a feature. This means that the component has very
    little utility elsewhere in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is because top-level components deal with application state.
    **Stateful components** are difficult to use in any other context. As you refactored
    the monolithic feature component, you created new components that moved further
    away from the data. The general rule is that the further your components move
    from stateful data, the more utility they have, because their property values
    could be passed in from anywhere in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about avoiding monolithic component design. However, monoliths
    are often a necessary starting point in the design of any React component.
  prefs: []
  type: TYPE_NORMAL
- en: You began by learning about how the different HTML elements have varying degrees
    of utility. Next, you learned about the issues with monolithic React components
    and walked through the implementation of a monolithic component.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you spent several sections learning how to refactor the monolithic component
    into a more sustainable design. From this exercise, you learned that container
    components should only have to think in terms of handling state, while smaller
    components have more utility because their property values can be passed from
    anywhere. You also learned that you can use render props for better control over
    component dependencies and substitution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about the React component lifecycle. This
    is an especially relevant topic for implementing container components.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why should monolithic React components be avoided?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because once components reach a certain size, the performance of the overall
    app begins to suffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because they're difficult to comprehend, and difficult to refactor into smaller
    reusable components later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't need to worry about avoiding monolithic components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you make components functional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional components only rely on property values that are passed to it. They
    don't rely on state or lifecycle methods, both potential problem sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional components are easier to read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You shouldn't make components functional, even if they don't have any state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do render props simplify React apps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They reduce the amount of code that you need to write for a given component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They don't simplify React apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They reduce the number of direct dependencies that a component has, allowing
    you to compose new behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/render-props.html](https://reactjs.org/docs/render-props.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/components-and-props.html#functional-and-class-components](https://reactjs.org/docs/components-and-props.html#functional-and-class-components)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
