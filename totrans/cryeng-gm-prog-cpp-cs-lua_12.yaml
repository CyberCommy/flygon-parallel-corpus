- en: Chapter 12. Debugging and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating efficient and bug-free code can be difficult. Therefore, the engine
    exposes a number of tools to help developers in this regard, allowing easy identification
    of bugs and visualization of performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep the debugging and profiling tools in mind at all times
    when writing both game and engine logic, in order to make sure that your code
    runs optimally and can be easily scanned for issues. Simply adding a few game
    log warnings can be vital for saving a bunch of time when resolving future issues!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning common ways of debugging CryENGINE applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the built-in profilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our own console variables and commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping your code bug-free can be very difficult, especially if you only rely
    on your debugger. CryENGINE exposes a number of systems for aiding the debugging
    of your code, even when you're not attached to the running process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always keep in mind which configuration you build the GameDll with. This can
    be changed before building your project in Visual Studio, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the game logic](img/5909_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, there are three primary configurations as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Configuration name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Profile | Used when developing the application, makes sure debug databases
    are generated. |'
  prefs: []
  type: TYPE_TB
- en: '| Debug | Used when you need compilation optimizations turned off, as well
    as extra CryENGINE helpers that are turned on specifically for this mode. |'
  prefs: []
  type: TYPE_TB
- en: '| Release | This mode is meant to be used earlier for final builds that are
    sent to end users.This configuration does a bunch of things, including disabling
    the generation of debug databases and multiple debug-only CryENGINE systems.It
    is also common practice for CryENGINE games to link all libraries such as CryGame
    into one Launcher application for security. |'
  prefs: []
  type: TYPE_TB
- en: Logging to the console and files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logging system allows for printing text to console and the `.log` file
    contained in the root file structure. The name of the log depends on which application
    was launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Log name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Game.log` | Used by the Launcher application. |'
  prefs: []
  type: TYPE_TB
- en: '| `Editor.log` | Only used by the Sandbox Editor application. |'
  prefs: []
  type: TYPE_TB
- en: '| `Server.log` | Used for the dedicated server. |'
  prefs: []
  type: TYPE_TB
- en: Logging functionality is commonly used for very severe issues, or to warn designers
    of unsupported behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest benefit of logging severe errors and initialization statistics is
    that you'll often be able to figure out why your code is not working as it should
    on the end user's computer by simply reading their game log.
  prefs: []
  type: TYPE_NORMAL
- en: Log verbosity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The log verbosity is set by using the `log_verbosity` console variable (for
    the visual part of the console) and `log_writeToFileVerbosity` (for the log written
    to disk).
  prefs: []
  type: TYPE_NORMAL
- en: Verbosity determines which messages should be logged/displayed, and is useful
    for filtering out less severe messages.
  prefs: []
  type: TYPE_NORMAL
- en: '| Verbosity level | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-1` (no logging) | Suppresses all logged information, including `CryLogAlways`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0` (always) | Suppresses all logged information, excluding that logged using
    `CryLogAlways`. |'
  prefs: []
  type: TYPE_TB
- en: '| `1` (error) | Same as level 0, but with additional errors. |'
  prefs: []
  type: TYPE_TB
- en: '| `2` (warning) | Same as level 1, but with additional warnings. |'
  prefs: []
  type: TYPE_TB
- en: '| `3` (message) | Same as level 2, but with additional messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `4` (comment) | Highest verbosity, logs everything mentioned previously as
    well as additional comments. |'
  prefs: []
  type: TYPE_TB
- en: Global log functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a list of global log functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CryLog`: This function logs a message to the console and file log, assuming
    log verbosity is 3 or higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`CryLogAlways`: This function logs a message to the console and file, assuming
    log verbosity is 0 or higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`CryWarning`: This function outputs a warning to the log and console, prefixed
    by [Warning]. It is also useful for warning designers that they''re using functionality
    incorrectly. It will only log to file if log verbosity is 2 or higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`CryFatalError`: This function is used to designate that a severe error has
    occurred, and results in a message box followed by program termination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`CryComment`: This function outputs a comment, assuming log verbosity is 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Logging in C# is done by using the static `Debug` class. For example,
    to log a message, one would use `Debug.Log("message");`'
  prefs: []
  type: TYPE_NORMAL
- en: To log using Lua, use the `System.Log` function, for example, `System.Log("MyMessage");`
  prefs: []
  type: TYPE_NORMAL
- en: The persistent debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The persistent debug system allows the drawing of persistent helpers that give
    visual feedback on game logic. For example, the system is used in the following
    screenshot to draw the direction the player is facing at their world position
    on every frame, where each arrow lasts for a specified number of seconds before
    disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system can bring very interesting effects, such as a way to see player
    rotation and physical interactions, as displayed in the free-to-play game SNOW:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The persistent debug](img/5909_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `IPersistantDebug` interface can be accessed via the game framework as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Prior to calling the various drawing functions, we'll need to call `IPersistantDebug::Begin`
    to signal that a new group of persistant debug should begin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The last boolean parameter specifies whether or not the system should clear
    all previously drawn persistent debug objects for the selected scope (`"myPersistentDebug"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the various **Add*** functions, such as `AddSphere`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, the system will draw a red sphere of radius `0.3` at
    `0`, `0`, `10` in the game world. The sphere will disappear after `2` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C#, the persistent debug interface can be accessed by using the static `Debug`
    class. For example, to add a sphere as we did previously, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: CryAssert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CryAssert system allows developers to make sure that certain variables are
    kept within boundaries. By doing checks that are only compiled in developer builds,
    it's possible to continuously test how systems interact with others. This is good
    for both performance and for making sure that your features are less bug-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The system can be toggled by using the `sys_asserts` CVar, and may require defining
    the `USE_CRYASSERT` macro in your `StdAfx` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do an assertion, use the `CRY_ASSERT` macro as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will then be checked each time the code is run, except in release mode,
    and will output a big warning message box when the condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with real-time products such as CryENGINE, programmers constantly
    have to consider the performance of their code. To aid in this, we'll be able
    to use the `profile` console variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CVar allows for getting visual statistics on the most intensive parts of
    your code as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling](img/5909_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, profile was set to `1`, the default mode, which
    sorts the most intensive functions being called for each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Profile usages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the profile variable supports 13 different states as listed in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Default value; when this is set, the profiling system will be inactive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Self time |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Hierarchical time |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Extended self time |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Extended hierarchical time |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Peaks time |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Subsystem info |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Calls number |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Standard deviation |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Memory allocation |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Memory allocation (in bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Stalls |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | Used to enable the profiling system, without drawing information to
    the screen. |'
  prefs: []
  type: TYPE_TB
- en: Profiling in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To profile in C++, we can make use of the `FUNCTION_PROFILER` pre-processor
    macro definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro will set up the necessary profiler objects: one static `CFrameProfiler`
    object that is kept for the method, and one `CFrameProfilerSection` object that
    is created each time the method is run (and destroyed when returning).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the profiler detects that your code runs heavily in relation to other engine
    functions, it will be displayed further up the profile graphs, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling in C++](img/5909_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to debug a certain section of your code, you can also use the `FRAME_PROFILER`
    macro, which works the same as `FUNCTION_PROFILER`, except that it allows you
    to specify the name of the profiled section.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example use case for `FRAME_PROFILER` is inside an `if` block, as the frame
    profiler section will be destroyed after the block is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now profile the previous code in the game, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling in C++](img/5909_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Profiling in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's also possible to profile your C# code in roughly the same manner. The difference
    is that we can't rely on destructors/finalizers in managed code, and will, therefore,
    have to do a bit of work ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we have to do is create a `CryEngine.Profiling.FrameProfiler`
    object which will persist for the lifetime of our entity. Then simply call `FrameProfiler.CreateSection`
    on the new frame profiler object each time you need to profile your function,
    and then call `FrameProfilerSection.End` on the resulting object when you''re
    done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will then result in the profiler listing `SpawnPoint.OnUpdate`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling in C#](img/5909_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although not directly linked to debugging, the CryENGINE console provides the
    means for creating commands that can execute functions directly from the game,
    and the creation of variables that can be modified to change the way the world
    behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fun fact: by using the hashtag (`#`) sign in the console, we can execute Lua
    directly in-game, for example, `#System.Log("My message!");`'
  prefs: []
  type: TYPE_NORMAL
- en: Console variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Console variables**, commonly referred to as **CVars**, allow the exposure
    of variables in your code to the CryENGINE console, effectively allowing the tweaking
    of settings at runtime or through config (`.cfg`) files.'
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much every subsystem uses console variables at runtime in order to tweak
    the behaviour of systems without requiring code modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a CVar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When registering a new CVar, it's important to distinguish between by-reference
    variables and wrapped variables.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that a by-reference CVar points to a variable defined in your
    own code that updated directly when the value is changed via the console.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapped variables contain the variable itself inside a specialized **ICVar**
    (C++) implementation inside `CrySystem.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: By-reference, CVars are most commonly used, as they do not require calling `IConsole::GetCVar`
    every time we want to know the value of the console variable.
  prefs: []
  type: TYPE_NORMAL
- en: In C++
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To register a by-reference console variable in C++, call `IConsole::Register`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, the default value of the `g_myVariable` CVar will be `3.0f`. If we changed
    the value via the console, `m_myVariable` will be updated immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out what the `VF_CHEAT` flag does, see the *Flags* section discussed
    further.
  prefs: []
  type: TYPE_NORMAL
- en: To register a wrapped console variable, use `IConsole::RegisterString`, `RegisterFloat`,
    or `RegisterInt`.
  prefs: []
  type: TYPE_NORMAL
- en: In C#
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To register a by-reference console variable via CryMono, use `CVar.RegisterFloat`
    or `CVar.RegisterInt`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the backend structure of C++ and C# strings being different, creating
    by-reference string CVars is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to use wrapped variables, use `CVar.Register`.
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When registering a new CVar, the developer should specify a default flag. The
    flags control how the variable behaves when modified or queried.
  prefs: []
  type: TYPE_NORMAL
- en: '`VF_NULL`: This flag is set to zero, and is used when no other flags are present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_CHEAT`: This flag is used to prevent changes to the variable when cheats
    are enabled, for example, in release mode or multiplayer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_READONLY`: This flag can never be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_REQUIRE_LEVEL_RELOAD`: This flag warns the user that a change to the variable
    will require a level reload to come into effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_REQUIRE_APP_RESTART`: This flag warns the user that a change will require
    an application restart to come into effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_MODIFIED`: This flag is set when the variable is modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_WASINCONFIG`: This flag is set if the variable is changed via a configuration
    (`.cfg`) file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_RESTRICTEDMODE`: This flag is set if the variable should be visible and
    usable in restricted (release) console mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_INVISIBLE`: This flag is set if the variable should not be visible to the
    user in the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_ALWAYSONCHANGE`: This flag always accepts the new value, and calls on-change
    callbacks even if the value stayed the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_BLOCKFRAME`: This flag blocks the execution of further console commands
    for one frame after the variable was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_CONST_CVAR`: This flag is set if the variable should not be editable via
    configuration (`.cfg`) files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_CHEAT_ALWAYS_CHECK`: This flag is set if the variable is very vulnerable,
    and should be checked continuously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VF_CHEAT_NOCHECK`: This flag is same as `VF_CHEAT`, except that it will not
    be checked due to changes to it being harmless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console variable groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to facilitate the creation of different system specifications (Low
    / Medium / High / Very High graphic levels), otherwise called **Sys Spec**, we
    can utilize CVar groups. These groups allow the value of multiple CVars to be
    changed simultaneously whenever the spec is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unsure of what Sys Specs do, read the *System specifications* section
    discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To change the system spec, the user can simply change the value of the `sys_spec`
    console variable. Once changed, the engine will parse the linked spec file in
    `Engine/Config/CVarGroups/` and set the CVar values defined.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the `sys_spec_GameEffects` CVar is changed, the engine will
    open `Engine/Config/CVarGroups/sys_spec_GameEffects.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sys_spec_Full` group is considered the root group, and is what is triggered
    when the `sys_spec` CVar is changed. It is set to update all subgroups, such as
    `sys_spec_Quality`, when it is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Cfg structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The structure of a CVar group configuration file is relatively easy to understand.
    As an example, see the following `sys_spec_GameEffects` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines defines which spec is default for this configuration file,
    in this case High (`3`).
  prefs: []
  type: TYPE_NORMAL
- en: Following the default spec are the default values for CVars in the high spec.
    These will be used as a baseline and applied to all specs, unless overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Postioned after the default spec are Low Spec (`[1]`), Medium Spec (`[2]`) and
    Very High Spec (`[4]`). The CVars placed after the definitions define what values
    the variables should be set to in that spec.
  prefs: []
  type: TYPE_NORMAL
- en: System specifications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The current system spec is determined by the value of the `sys_spec` CVar. Changing
    the value of the variable will automatically load shaders and CVar groups that
    have been tweaked specifically for that spec. For example, if the game is running
    a bit badly on your PC, you might want to change the spec to Low (`1`).
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: Custom'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Low'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: Medium'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: High'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: Very High'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`: Xbox 360'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6`: PlayStation 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Console commands** (commonly referred to as **CCommands**), are essentially
    functions that have been mapped to console variables. However, instead of changing
    the value of a referenced variable when the command is entered into the console,
    the call will trigger a function that was specified while registering the command.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that console variables can also specify `On Change` callbacks that are
    automatically invoked when the value is changed. Prefer console commands when
    an internal variable is not relevant to your intent.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a console command in C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To register a console command in C#, use `ConsoleCommand.Register` as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Triggering `MyCSharpCommand` in the console will now result in the `OnMyCSharpCommand`
    function being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When your callback is triggered, you'll be able to retrieve the set of arguments
    that were added after the command itself. For example, if the user were to activate
    the command by typing `MyCommand 2`, we might want to retrieve the `2` part of
    the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, use the `ConsoleCommandArgs.Args` array, and specify which index
    the argument you want is at. For the previous example, it would look like the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To retrieve the full command line that was specified with the command, use `ConsoleCommandArgs.FullCommandLine`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Console Command in C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a new console command in C++, use `IConsole::AddCommand` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After compiling and starting the engine, you will be able to type `MyCommand`
    in the console and trigger your `MyCommandCallback` function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned how to use a selection of the engine's debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiled our code to ensure optimal performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned what console variables (CVars) are, and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created custom console commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now have a basic understanding of how to best program in CryENGINE.
    Make sure that you always keep profiling and debugging methods in mind, in order
    to ensure that your code runs optimally.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you've read the book's chapters in order, you should now be aware
    of the workings of the most important engine systems. We hope you enjoyed the
    read, and wish you the best of luck with using your newly-gained CryENGINE knowledge!
  prefs: []
  type: TYPE_NORMAL
