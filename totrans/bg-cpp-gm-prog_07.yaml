- en: Chapter 7. C++ References, Sprite Sheets, and Vertex Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations,
    and Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions - Implementing Game Mechanics*, we talked about scope. The concept
    that variables declared in a function or inner block of code only have scope (can
    be seen or used) in that function or block. Using only the C++ knowledge we have
    at the moment, this can cause a problem. What do we do if we need to work on a
    number of complex objects which are needed in `main`? This could imply that all
    the code must be in `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will explore **C++references** which allow us to work on
    variables and objects that are otherwise out of scope. In addition, references
    will help us avoid having to pass large objects between functions, which is a
    slow process. It is a slow process because each time we do this, a copy of the
    variable or object must be made.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this new knowledge about references, we will take a look at the SFML
    `VertexArray` class that allows us to build up a large image that can be very
    quickly and efficiently drawn to the screen using multiple images from a single
    image file. By the end of the chapter we will have a scaleable, random, scrolling
    background, using references, and a `VertexArray` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFML vertex arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a random and scrolling background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we pass values to a function or return values from a function, that is
    exactly what we are doing. Passing/returning by **value**. What happens is that
    a copy of the value held by the variable is made, and sent into the function where
    it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The significance of this is two-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want the function to make a permanent change to a variable, this system
    is no good to us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a copy is made, to pass in as an argument or return from the function,
    processing power and memory are consumed. For a simple `int` or even perhaps a
    sprite, this is fairly insignificant. However, for a complex object, perhaps an
    entire game world (or background), the copying process will seriously affect our
    game's performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'References are the solution to these two problems. A reference is a special
    type of variable. A reference refers to another variable. An example will be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the code above we declare and initialize a regular `int` called `numZombies`.
    We then declare and initialize an `int` reference called `rNumZombies`. The reference
    operator `&` that follows the type, determines that a reference is being declared.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `r` prefix at the front of the reference name is optional but useful for
    remembering that we are dealing with a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an `int` called `numZombies` which stores the value `100` and an
    `int` reference called `rNumZombies` that refers to `numZombies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything we do to `numZombies` can be seen through `rNumZombies`, and anything
    we do to `rNumZombies` we are actually doing to `numZombies`. Take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code we declare an `int` called `score`. Next we declare an
    `int` reference called `rScore` that refers to `score`. Remember that anything
    we do to `score` can be seen by `rScore` and anything we do to `rScore` is actually
    being done to `score`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, when we increment score like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The score variable now stores the value 11\. In addition, if we were to output
    `rScore` it would also output 11\. The following line of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now `score` actually holds the value 12 because anything we do to `rScore` is
    actually done to `score`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to know how this works then more will be revealed in the next chapter
    when we discuss **pointers**. But simply put, you can consider a reference as
    storing a place/address in the computer's memory. That place in memory is the
    same place where the variable it refers to stores its value. Therefore, an operation
    on either the reference or the variable has exactly the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, it is much more important to talk more about the *why* of references.
    There are two reasons to use references and we have already mentioned them. Here
    they are summarized again:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing/reading the value of a variable/object in another function which is
    otherwise out of scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing/returning without making a copy (and therefore more efficiently)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Study this code and then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code begins with the prototypes of two functions, `add` and `referenceAdd`.
    The `add` function takes three `int` variables and the `referenceAdd` function
    takes two `int` variables and an `int` reference.
  prefs: []
  type: TYPE_NORMAL
- en: When the `add` function is called and the variables `number1`, `number2`, and
    `answer` are passed in, a copy of the values is made and new local variables to
    add (`n1`, `n2`, and `a`) are manipulated. As a result of this, `answer`, back
    in `main`, remains at zero.
  prefs: []
  type: TYPE_NORMAL
- en: When the `referenceAdd` function is called, `number1` and `number2` are again
    passed by value. However, `answer` is passed by reference. When the value of `n1`
    added to `n2` is assigned to the reference `a`, what is really happening is that
    the value is assigned to `answer` back in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: It is probably obvious that we would never need to actually use a reference
    for something this simple. It does, however, demonstrate the mechanics of passing
    by reference.
  prefs: []
  type: TYPE_NORMAL
- en: References summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous code demonstrated how a reference can be used to alter the value
    of a variable in one scope using code in another. As well as being extremely convenient,
    passing by reference is also very efficient because no copy is made. The example
    using a reference to an `int` is a bit ambiguous because as an `int` is so small
    there is no real efficiency gain. Later in the chapter we will use a reference
    to pass an entire level layout and the efficiency gain will be significant.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one gotcha with references! You must assign the reference to a variable
    at the time you create it. This means it is not completely flexible. Don't worry
    about this for now. We will explore references further as well as their more flexible
    (and slightly more complicated) relations, pointers, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is largely irrelevant for an `int` but potentially significant for a large
    object of a class. We will use this exact technique when we implement the scrolling
    background of the Zombie Arena game.
  prefs: []
  type: TYPE_NORMAL
- en: SFML vertex arrays and sprite sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are nearly ready to implement the scrolling background. We just need to learn
    about SFML vertex arrays and sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: What is a sprite sheet?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **sprite sheet** is a set of images, either frames of animation or totally
    individual graphics, contained in one image file. Take a closer look at the sprite
    sheet that contains four separate images that will be used to draw the background
    in Zombie Arena:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a sprite sheet?](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SFML allows us to load a sprite sheet as a regular texture in exactly the same
    way we have done for every texture in the book so far. When we load multiple images
    as a single texture, the GPU can handle it much more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually a modern PC could handle these four textures without using a sprite
    sheet. It is worth using these techniques as our games are going to start getting
    progressively more demanding on the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do when we draw an image from the sprite sheet is make sure
    we refer to the precise pixel coordinates of the part of the sprite sheet we require:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a sprite sheet?](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous image labels each part/tile with the coordinates of its position
    within the sprite sheet. These coordinates are called **texture coordinates**.
    We will use these texture coordinates in our code to draw just the right parts
    that we require.
  prefs: []
  type: TYPE_NORMAL
- en: What is a vertex array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need to ask: what is a vertex? A **vertex** is a single graphical
    point, a coordinate. This point is defined by a horizontal and vertical position.
    The plural of vertex is vertices. A vertex array, then, is a whole collection
    of vertices.'
  prefs: []
  type: TYPE_NORMAL
- en: In SFML, each vertex in a vertex array also has a color and a related additional
    vertex (pair of coordinates) called texture coordinates. Texture coordinates are
    the position in a sprite sheet of the image we want to use. We will see quite
    soon how we position graphics and choose a part of the sprite sheet to display
    at each position, all with a single vertex array.
  prefs: []
  type: TYPE_NORMAL
- en: The SFML `VertexArray` class can hold different types of vertex set. But each
    `VertexArray` should only hold one type of set. We use the type of set that suits
    the occasion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common scenarios in video games include, but are not limited to, the following
    **primitive** types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point**: A single vertex per point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line**: Two vertices per set that define the start and endpoint of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Triangle**: Three vertices per point. Among the thousands used, this is probably
    the most common for complex 3D models or in pairs to create a simple rectangle,
    like a sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quad**: Four vertices per set, a convenient way to map rectangular areas
    from a sprite sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use quads in this project.
  prefs: []
  type: TYPE_NORMAL
- en: Building a background from tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Zombie Arena background will be made up of a random arrangement of square
    images. You can think of this arrangement like tiles on a floor.
  prefs: []
  type: TYPE_NORMAL
- en: In this project we will be using vertex arrays with **quad** sets. Each vertex
    will be part of a set of four (a quad). Each vertex will define one corner of
    a tile from our background. Each texture coordinate will hold an appropriate value
    based on a specific image from the sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some code to get us started. This isn't the exact code
    we will use in the project but it is fairly close and enables us to study vertex
    arrays before we move on to the actual implementation we will use.
  prefs: []
  type: TYPE_NORMAL
- en: Building a vertex array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we do when we create an instance of a class, we declare our new object.
    The following code declares a new object of type `VertexArray` called background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to let our instance of `VertexArray` know which type of primitive we
    will be using. Remember that points, lines, triangles, and quads all have a different
    number of vertices. By setting the `VertexArray` to hold a particular type, it
    will be possible to know the start of each primitive. In our case we want quads.
    Here is the code that will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As with regular C++ arrays, a `VertexArray` needs to be set to a size. The
    `VertexArray` is more flexible, however. It allows us to change its size while
    the game is running. The size could be configured at the same time as the declaration
    but our background needs to expand with each wave. The `VertexArray` class provides
    this functionality with the `resize` function. Here is the code that would set
    the size of our arena to a 10 by 10 tile size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previous line of code, the first `10` is the width, the second `10` is
    the height, and `4` is the number of vertices in a quad. We could have just passed
    in 400 but showing the calculation like this makes it clear what we are doing.
    When we code the project for real, we will go a step further and declare variables
    for each part of the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a `VertexArray` ready to have its hundreds of vertices configured.
    Here is how we set the position coordinates on the first four vertices (the first
    quad):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we set the texture coordinates of these same vertices to the first
    image in the sprite sheet. These coordinates in the image file are `0,0` (in the
    top left corner) to `49,49` (in the bottom right):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to set the texture coordinates to the second image in the sprite
    sheet we would have written the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if we define each and every vertex like this individually, then we
    are going to be configuring even a simple `10` by `10` arena for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement our background for real, we will devise a set of nested `for`
    loops that loop through each quad, pick a random background image, and assign
    the appropriate texture coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The code will need to be quite smart. It will need to know when it is an edge
    tile so it can use the wall image from the sprite sheet. It will also need to
    use appropriate variables that know the position of each background tile in the
    sprite sheet as well as the overall size of the required arena.
  prefs: []
  type: TYPE_NORMAL
- en: We will make this complexity manageable by putting all the code in both a separate
    function and a separate file. We will make the `VertexArray` usable in `main`
    by using a C++ reference.
  prefs: []
  type: TYPE_NORMAL
- en: We will come to these details soon. You may have noticed that at no point have
    we associated a texture (the sprite sheet with the vertex array).
  prefs: []
  type: TYPE_NORMAL
- en: Using the vertex array to draw
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can load the sprite sheet as a texture in exactly the same way as we load
    any other texture, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then draw the entire `VertexArray` with one call to `draw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is many times more efficient than drawing each and every tile
    as an individual sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we move on, notice the slightly odd looking `&` before `textureBackground`.
    Your immediate thought might be that this has something to do with references.
    What is going on here is we are passing the address of our texture instead of
    the actual texture. We will learn more about this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position to use our knowledge of references and vertex arrays
    to implement the next stage of the Zombie Arena project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a randomly generated scrolling background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create the function that makes a background in a separate file. We will
    ensure the background will be available (in scope) to the `main` function by using
    a vertex array reference.
  prefs: []
  type: TYPE_NORMAL
- en: As we will be writing other functions that share data with the `main` function,
    we will write them all in their own `.cpp` files. We will provide prototypes for
    these functions in a new header file that we will include (with an include directive)
    in `ZombieArena.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, let's first make the new header file. Right-click **Header
    Files** in the **Solution Explorer** and select **Add** | **New Item...**. In
    the **Add New Item** window, highlight (by left-clicking) **Header File** (`.h`),
    and then in the **Name** field type `ZombieArena.h`. Finally click the **Add**
    button. We are now ready to code the header file for our new function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this new `ZombieArena.h` header file, add the following highlighted code
    including the function prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous code enables us to write the definition of a function called `createBackground`.
    To match the prototype, the function must return an `int` value and receive as
    parameters a `VertexArray` reference and an `IntRect` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create a new `.cpp` file in which we will code the function definition.
    Right-click **Source Files** in the **Solution Explorer** and select **Add** |
    **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** ( **`.cpp`** ), and then in the **Name** field type `CreateBackground.cpp`.
    Finally click the **Add** button. We are now ready to code the function definition
    that will create our background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `CreateBackground.cpp` file and then we will
    review it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we write the function signature as well as the opening
    and closing curly brackets that mark out the function body.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function body we declare and initialize three new `int` constants
    to hold values that we will need to refer to throughout the rest of the function.
    They are `TILE_SIZE`, `TILE_TYPES`, and `VERTS_IN_QUAD`. The `TILE_SIZE` constant
    refers to the size in pixels of each tile within the sprite sheet. `TILE_TYPES`
    refers to the number of different tiles within the sprite sheet. We could add
    more tiles into our sprite sheet, change `TILE_TYPES` to match, and the code we
    are about to write would still work. `VERTS_IN_QUAD` refers to the fact that there
    are four vertices in every quad. It is less error-prone to use this constant compared
    to repeatedly typing the number `4`, which is less clear.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare and initialize two `int` variables, `worldWidth` and `worldHeight`.
    These variables might appear blindingly obvious as to their use. They are betrayed
    by their names but it is worth pointing out that they refer to the width and height
    of the world in number of tiles, not pixels. The `worldWidth` and `worldHeight`
    variables are initialized by dividing the height and width of the passed-in arena
    by the constant, `TILE_SIZE`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we get to use our reference for the first time. Remember that anything
    we do to `rVA` we are really doing to the variable that was passed-in which is
    in scope in the `main` function (or will be when we code it).
  prefs: []
  type: TYPE_NORMAL
- en: First we prepare the vertex array to use quads using `rVA.setType`, and then
    we make it just the right size by calling `rVA.resize`. To the `resize` function
    we pass in the result of `worldWidth * worldHeight * VERTS_IN_QUAD`, which equates
    to exactly the number of vertices that our vertex array will have when we are
    done preparing it.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of code declares and initializes `currentVertex` to zero. We will
    use `currentVertex` as we loop through the vertex array initializing all the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write the first part of a nested `for` loop that will prepare the
    vertex array. Add the following highlighted code, and based on what we have learnt
    about vertex arrays, try and work out what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code that we just added steps through the vertex array by using a nested
    `for` loop that first steps through the first four vertices. `currentVertex +
    1`, `currentVertex + 2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We access each vertex in the array using array notation. `rvA[currentVertex
    + 0]..` and so on. Using array notation we call the `position` function `rvA[currentVertex
    + 0].position...`.
  prefs: []
  type: TYPE_NORMAL
- en: Into the `position` function we pass the horizontal and vertical coordinates
    of each vertex. We can work these coordinates out programmatically by using a
    combination of `w`, `h`, and `TILE_SIZE`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the previous code we position `currentVertex` ready for the next
    pass through the nested `for` loop by advancing it four places (adding four) with
    the code `currentVertex = currentVertex + VERTS_IN_QUAD`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all this does is set the coordinates of our vertices; it doesn't
    assign a texture coordinate from the sprite sheet. This is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it absolutely clear where the new code goes I have shown it in context
    with all the code that we wrote a moment ago. Add and study the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous code sets up the coordinates within the sprite sheet that each
    vertex is related to. Notice the somewhat long if condition. The condition checks
    whether the current quad is either one of the very first or the very last quads
    in the arena. If it is then this means it is part of the boundary. We can then
    use a simple formula using `TILE_SIZE` and `TILE_TYPES` to target the wall texture
    from the sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Array notation and the `texCoords` member are initialized for each vertex in
    turn to assign the appropriate corner of the wall texture within the sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is wrapped in an `else` block. This means that it will run
    each time through the nested for loop when the quad does not represent a border/wall
    tile. Add the highlighted code amongst the existing code and we can then examine
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The previous new code starts by seeding the random number generator with a formula
    that will be different each pass through the loop. Then the `mOrG` variable is
    initialized with a number between 0 and `TILE_TYPES`. This is just what we need
    to pick one of the tile types randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`mOrG` stands for mud or grass. The name is arbitrary.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we declare and initialize a variable called `verticalOffset` by multiplying
    `mOrG` by `TileSize`. We now have a vertical reference point within the sprite
    sheet to the starting height of the randomly chosen texture for the current quad.
  prefs: []
  type: TYPE_NORMAL
- en: Now we use a simple formula involving `TILE_SIZE` and `verticalOffset` to assign
    the precise coordinates of each corner of the texture to the appropriate vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can put our new function to work in the game engine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have done the tricky stuff, this will be simple. There are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `VertexArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize it after leveling up each wave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw it in each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code highlighted in the following to declare a `VertexArray` called
    `background` and load the `background_sheet.png` as a texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to call the `createBackground` function, passing in
    `background` as a reference and `arena` by value. Notice in the highlighted code
    that we have also modified the way that we initialize the `tileSize` variable.
    Add the highlighted code exactly as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note we have replaced the `int tileSize = 50` line of code because we get the
    value directly from the return value of the `createBackground` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the sake of future code clarity, you should delete the `int tileSize = 50`
    line of code and its related comment. I just commented it out to give the new
    code a clearer context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is time to do the drawing. This is really simple. All we do is
    call `window.draw` and pass the `VertexArray` along with the `textureBackground`
    texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering what is going on with the odd-looking `&` sign in front
    of `textureBackground`, then all will be made clear in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the game as shown in this next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the background](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note how the player sprite glides and rotates smoothly within the arena confines.
    Although the current code in main draws a small arena, the `CreateBackground`
    function can create an arena of any size we tell it. We will see arenas bigger
    than the screen in [Chapter 11](ch11.html "Chapter 11. Sound Effects, File I/O,
    and Finishing the Game"): *Sound Effects, File I/O, and Finishing the Game*.'
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions that might be on your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Q) Can you summarize these references again?
  prefs: []
  type: TYPE_NORMAL
- en: A) You must initialize a reference immediately and cannot change it to reference
    another variable. Use references with functions so you are not working on a copy.
    This is good for efficiency because it avoids making copies and helps us more
    easily abstract our code into functions.
  prefs: []
  type: TYPE_NORMAL
- en: Q) Is there an easy way to remember the main benefit of using references?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) To help you remember what a reference is for, consider this short rhyme:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Moving large objects can make our games choppy, passing by reference is faster
    than copy.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discovered C++ references that are special variables that
    act as an alias to another variable. When we pass a variable by reference instead
    of by value, then any work we do on the reference happens to the variable back
    in the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: We also learnt about vertex arrays and created a vertex array full of quads
    to draw the tiles from a sprite sheet as a background.
  prefs: []
  type: TYPE_NORMAL
- en: The elephant in the room, of course, is that our zombie game doesn't have any
    zombies. Let's fix that now by learning about C++ pointers and the Standard Template
    Library.
  prefs: []
  type: TYPE_NORMAL
