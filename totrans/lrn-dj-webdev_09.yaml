- en: Chapter 9. Extending and Deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will prepare our application for deployment in production
    by utilizing various Django framework features. We will add support for multiple
    languages, improve performance by caching and automated testing, and configure
    the project for a production environment. There is a lot of interesting and useful
    information in this chapter, so make sure you go through it before publishing
    your application online!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending invitation e-mails to friends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization (i18n)—offering the site in multiple languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching—improving the performance of your site during high traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing—automating the process of testing your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending invitation e-mails to friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enabling our users to invite their friends carries many benefits. People are
    more likely to join our site if their friends already use it. After they join,
    they will also invite their friends, and so on, which means more and more users
    for our application. Therefore, it is a good idea to include an "invite a friend"
    feature in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building this feature requires the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: An invitation data model to store invitations in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form in which users can type the e-mail IDs of their friends and send invitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An invitation e-mail with an activation link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mechanism to process activation links sent in e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout this section, we will implement each of these components. However,
    because this section involves sending e-mails, we first need to configure Django
    to send e-mails by adding some options to the `settings.py` file. So, open the
    `settings.py` file and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what each variable in the preceding code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SITE_HOST`: This is the hostname of your server. Leave it as `127.0.0.1:8000`
    for now. When we deploy our server in the next chapter, we will change this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT_FROM_EMAIL`: This is the e-mail address that appears in the **From**
    field of the outgoing e-mail server. For the host username, input your username
    plus your e-mail server, as shown in the preceding code snippet. Leave the fields
    empty if your ISP does not require them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST`: This is the hostname of your e-mail server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_PORT`: This is the port number of the outgoing e-mail server. If you
    leave it empty, the default value (25) will be used. You also need to obtain this
    from your ISP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST_USER` and `EMAIL_HOST_PASSWORD`: This is the username and password
    for e-mails sent by Django.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your development machine doesn't run a mail server, most likely this is the
    case, then you need to enter your ISP's outgoing e-mail server. Contact your ISP
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that your settings are correct, launch the interactive shell and
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `your_email@example.com` parameter with your actual e-mail address.
    If the preceding call to send mail does not raise an exception and you receive
    the e-mail, then all is set. Otherwise, you need to verify your settings with
    your ISP and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait, what if you don''t get any information from the ISP? We then try
    the alternate way: using Gmail to send a mail (of course, not as `noreply@mytweet.com`,
    but from your real e-mail ID). Let''s look at the changes you will have to make
    in the `settings.py` file of `MyTweeets` project for the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the previous `settings.py` file entries entirely and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are getting an error such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `EMAIL_HOST_PASSWORD` parameter needs a application authorization
    password that is not your e-mail password. Follow the link mentioned in the host
    section to get more details on how to create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the things up, try sending the mail again from the shell using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `your_email@example.com` parameter is any e-mail address that you
    want to send a mail to. The from address of the mail will be the Gmail e-mail
    address that we passed to the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, once the settings are correct, sending an e-mail in Django is a piece of
    cake! We will use the `EmailMessage` function to send the invitation e-mail, but
    first, let's create a data model to store invitations.
  prefs: []
  type: TYPE_NORMAL
- en: The invitation data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An invitation consists of the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The recipient name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipient e-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user object of the sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also need to store an activation code for the invitation. This code will
    be sent in the invitation e-mail. The code will serve two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Before accepting the invitation, we can use the code to verify that the invitation
    actually exists in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After accepting the invitation, we can use the code to retrieve the invitation
    information from the database and to follow relationships between the sender and
    recipient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding information in mind, let''s create the invitation data model.
    Open the `user_profile/models.py` file and append the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There shouldn't be anything new or difficult to understand in this model. We
    have simply defined fields for the recipient name, recipient e-mail, activation
    code, and the sender of the invitation. We also created a `__unicode__` method
    for debugging and enabled the model in the administration interface. Do not forget
    to run the `python manage.py syncdb` command to create the new model's table in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also create the invitation form for this. Create a file called `forms.py`
    in the `user_profile` directory and update it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the view page from where the invitations will be sent is similar to
    creating the other pages that we created for search and tweets forms that we made
    by creating a new file called `template/invite.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL entry for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to create `get` and `post` methods to send an invitation mail with
    this form.
  prefs: []
  type: TYPE_NORMAL
- en: As sending an e-mail is more specific to a user than a tweet, we will create
    this method in `user_profile` views, contrary to the tweet view that we used before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `user_profile/views.py` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `get()` method is as simple as rendering the `invite.html` file with
    the invite form as a parameter and a flag called the `success` and `email` variable
    is initially unset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `post()` method uses the usual form check and variable extraction concept;
    the code you will see for the first time is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually a static function call that generated the activation token
    with a unique key for every invited user. The `render_to_string()` method works
    when you load a template called `_invite_email_template.html` and pass the following
    variables to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sender_name`: This is the name of the person who has invited or is the sender
    of the e-mail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sender_email`: This is the e-mail address of the sender'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: This is the e-mail address of the person who has been invited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link`: This is the invitation acceptance link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template is then used to render the body of the invitation e-mail. After
    that, we use the `EmailMultiAlternatives()` method to send the e-mail, as we did
    during the interactive session in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several observations to be made here:'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the activation link is `http://SITE_HOST/invite/accept/CODE/`.
    We will write a view to handle such URLs later in this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the first time we used a template to render something other than a web
    page. As you can see, the template system is quite flexible and allows us to build
    e-mails, as well as web pages, or any other text for that matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `render_to_string()` and `render()` methods to build the message
    body as opposed to the usual `render_to_response` call. If you remember, this
    is how we rendered templates earlier in this book. We are doing this here because
    we are not rendering a web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the `send` method loads a template called `_invite_email_template.html`,
    create a file with this name in the templates folder and insert the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are halfway through the implementation of the "invite a friend" feature.
    At the moment, clicking on the activation link produces a 404 page not found error,
    so, next, we will write a view to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Handling activation links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have made good progress; users are now able to send invitations to their
    friends via e-mail. The next step is to build a mechanism that handles activation
    links in invitations. Here is an outline of what we are going to do.
  prefs: []
  type: TYPE_NORMAL
- en: We will build a view that handles activation links. This view verifies that
    the invitation code actually exists in the database, and that the user who registers
    automatically follows the user who sent the link and gets redirected to the registration
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing a URL entry for the view. Open the `urls.py` file and
    add the highlighted line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create a class in the `user_profile/view.py` file with thename of the class
    as `InviteAccept()`.
  prefs: []
  type: TYPE_NORMAL
- en: Logically, InviteAccept will work as the users will be asked to register for
    the application, and if they have already registered, they will be asked to follow
    the user who invited them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we will redirect the user to the registration page
    with the activation code so that when they register, they automatically become
    followers. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will write the registration page with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the view follows the URL format sent in invitation e-mails.
    The activation code is captured from the URL using a regular expression and is,
    then, passed to the view as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This was a bit time-consuming, but we were able to put our Django knowledge
    to good use while implementing it. You can now click on the invitation link that
    you received via e-mail to see what happens. You will be redirected to the registration
    page; you can create a new account there, log in, and note how the new account,
    and your original one, became followers of the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization (i18n) – offering the site in multiple languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People won't use our application if they cannot read its pages. So far, we have
    been concerned with English-speaking users only. However, there are people all
    over the world who do not know English or prefer to use their native language.
    To appeal to those people, it would be a good idea to offer the interface of our
    application in multiple languages. This would overcome the language barrier and
    open new frontiers for our application, especially in regions where English is
    not common.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, Django provides all the components needed to translate
    a project into multiple languages. The system that is responsible for providing
    this feature is called the **internationalization system** (**i18n**). The process
    of translating a Django project is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'You follow these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify which strings should be translated in your application—for example,
    status and error messages are translatable, whereas usernames are not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a translation file for each language you want to support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable and configure the i18n system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will go through each step in detail in the following subsections. By the
    end of this section of the chapter, our application will support multiple languages
    and you will be able to translate any other Django project with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Marking strings as translatable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in translating an application is telling Django which strings
    should be translated. Generally speaking, strings that are part of views and templates
    need to be translated, while strings that are entered by the user do not need
    to be. Marking a string as translatable is done with a function call. The name
    of the function and how it is called depends on where the string is located: in
    a view, template, model, or form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This step is much easier than it initially looks. Let''s learn about it with
    an example. We will translate the "invite follower" functionality in our application.
    The process of translating the rest of the application will be exactly the same.
    Open the `user_profile/views.py` file and make the highlighted changes to the
    invite view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the subject string starts with a "`_`"; alternatively, you can also
    write it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Either way, it works well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the changes are minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported a function called `ugettext` from `django.utils.translation`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used as a keyword to assign a shorter name to the function (the underscore
    character). We did so because this function will be used to mark strings as translatable
    in views, and since this is a very common task, it's a good idea to give the function
    a shorter name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We marked a string as translatable simply by passing it to the `_` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That was pretty simple, wasn''t it? However, there is one little observation
    that we need to make here. The first message uses string formatting, and we applied
    the `%` operator after calling the `_()` function. This is necessary to avoid
    translating the e-mail address. It''s also preferable to use named formats, which
    give you greater control while doing the actual translation later. So, you may
    want to define the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to mark strings as translatable in views, let''s move
    to templates. Open the `invite.html` file in the templates folder and modify it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we placed the `{% load i18n %}` parameter at the beginning of the template
    to give it access to translation tags. The `<load>` tag is generally used to enable
    additional template tags that are not available by default. You need to place
    it at the top of every template that uses translation tags. i18n is shorthand
    for internationalization, which is the name of the Django framework that provides
    translation features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we used a template tag called `trans` to mark strings as translatable.
    This template tag works exactly the same as the `gettext` function in views. It''s
    worth noting that the `trans` tag does not work if the string contains a template
    variable. In this case, you would need to use the `blocktrans` tag like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can pass a variable block, that is, `{{ variable }}` also inside `{% endblocktrans
    %}` block to make it more meaningful for the readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how to deal with translatable strings in templates too. So, let''s
    move to forms and models. Marking a string as translatable in a form or model
    is slightly different from views. To learn how it is done, open the `user_profile/forms.py`
    file and modify the invite form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here is that we imported the `gettext_lazy` function instead
    of `gettext . gettext_lazy`, which delays translating the string until its return
    value is accessed. This is needed here because the attributes of the form are
    created only once: when the application is started. If we use the normal `gettext`
    function, the translated labels will be stored in the form attributes using the
    default language (usually English) and will never be translated again. However,
    if we use the `gettext_lazy` function, the function will return a special object
    that will translate the string every time it is accessed and, hence, the translation
    will be done correctly. This feature makes the `gettext_lazy` function ideal for
    form and model attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we finish marking the strings of the "invite friend" view for translation.
    To help you remember what''s covered in this subsection, here is a quick summary
    of the techniques used to mark the translatable strings:'
  prefs: []
  type: TYPE_NORMAL
- en: In views, mark the translatable strings using the `gettext` function (usually
    imported as `_` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In templates, mark the translatable strings using the `trans` template tag for
    strings that do not contain variables and the `blocktrans` tag for the strings
    that do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In forms and models, mark the translatable strings using the `gettext_lazy`
    function (usually imported as `_` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are special cases that may need to be handled separately. For
    example, you may want to translate default parameter values in views using the
    `gettext_lazy` function instead of the `gettext` function. As long as you understand
    the difference between these two functions, you should be able to decide when
    you need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Creating translation files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have finished marking strings for translation, the next step is
    to create a translation file for each language that we want to support. This file
    contains all the translatable strings along with their translations and is created
    using a utility provided by Django.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a translation file. First, you need to locate a file named `make-messages.py`
    in the `bin` directory inside your Django installation folder. The easiest way
    to find it is by using the search functionality in your operating system. Once
    you find it, copy it to your system path (`/usr/bin/` in Linux and Mac OS X and.
    `c:\windows\` in Windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, make sure that it is executable by running the following command in Linux
    and Mac OS X (this step is not needed for Windows users):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `make-messages.py` utility uses a software package called GNU gettext to
    extract the translatable strings from the source code. So, you need to install
    this package. For Linux, search for the package in your package manager and install
    it. Windows users will find an installer for the package at [http://gnuwin32.sourceforge.net/packages/gettext.htm](http://gnuwin32.sourceforge.net/packages/gettext.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Mac OS X users will find a version of the package for their operating
    system along with the installation instructions at [http://gettext.darwinports.com/](http://gettext.darwinports.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the GNU gettext package installed, open a terminal, go to your
    project folder, create a folder called `locale` there, and then run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a translation file for the German language. The `de` variable
    is the language code for German. If you want to target another language, put its
    language code instead of `de` and continue to do so for the rest of the chapter.
    In addition to this, if you want to support more than one language, run the previous
    command for each language and apply the instructions to the rest of this section
    to all languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run the preceding command, it will create a file called `django.po`
    at `locale/de/LC_MESSAGES/`. This is the translation file for the German language.
    Open it in a text editor to see what it looks like. The file starts with some
    metadata, such as the creation date and a character set. After that, you will
    find an entry for each translatable string. Each entry consists of the filename
    and line number of the string, the string itself, and an empty string below it
    where the translation should go. Here is a sample entry from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To translate the string, simply use your text editor to type the translation
    in the empty string on the third line. You can also use a specialized translation
    editor, such as `Poedit` (available for all major operating systems at [http://www.poedit.net/](http://www.poedit.net/)),
    but for our simple file, a regular text editor should suffice. Make sure that
    you set a valid character in the metadata section of the file. I recommend that
    you use **UTF-8**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You may note that the translation file contains some strings from the admin
    interface. This is because the `admin/base_site.html` admin template uses the
    `trans` template tag to mark its strings as translatable. There is no need to
    translate these strings; Django already comes with translation files for them.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're done translating, you need to compile the translation file into
    a format that Django can use. This is done using another utility provided by Django
    called the `compile-messages.py` command. Locate and move this file to your system
    path and make sure that it is executable by following the same procedure as we
    did with the `make-messages.py` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the following command from within your project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the utility complains about an error in the file (such as a missing quotation
    mark), correct the error and try again. Once it is successful, the utility will
    create a compiled translation file called `django.mo` in the same folder and everything
    will be set for the next step in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and configuring the i18n system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django comes with the i18n system enabled by default. You can verify this by
    searching for the following line in the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are two ways to configure the i18n system. You can either set the language
    globally for all users or let users specify their preferred languages individually.
    We will see how to do both in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the active language globally, find the variable called `LANGUAGE_CODE`
    in the `settings.py` file and assign your preferred language code to it. For example,
    if you want to set German as the default language for our project, change the
    language code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, start the development server if it's not already running, and navigate
    to the "invite friend" page. There, you will find that the strings have changed
    according to what you entered in the German translation file. Now, change the
    value of the `LANGUAGE_CODE` variable to '`en`' and note how the page reverts
    back to English.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second configuration method is to let users choose the language. To do
    so, we should enable a class called `LocaleMiddleware`. To put it simply, a middleware
    is a class that processes a request or response object. Many components of Django
    make use of middleware classes to implement features. To see this, open the `settings.py`
    file and search for the `MIDDLEWARE_CLASSES` variable. You will find a list of
    strings there, and one of them will be `django.contrib.sessions.middleware.SessionMiddleware`,
    which attaches session data to the request object. We don''t need to learn how
    middleware classes are implemented before using them. To enable `LocaleMiddleware`,
    simply add its classpath to the `MIDDLEWARE_CLASSES` list. Make sure that you
    put `LocaleMiddleware` after `SessionMiddleware` because the locale middleware
    utilizes the session API, as we will see next. Open the `settings.py` file and
    modify the file as highlighted in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The locale middleware determines the active language for the user by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It looks for a key named `django_language` in the session data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the key does not exist, it looks for a cookie called `django_language`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the cookie does not exist, it looks at the language code in the Accept-Language
    HTTP header. This header is sent by the browser to the web server indicating which
    languages you would prefer to receive content in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all else fails, the `LANGUAGE_CODE` variable in the `settings.py` file is
    used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In all the preceding steps, Django looks for a language code that matches one
    of the available translation files. To effectively utilize the locale middleware,
    we need a view that enables the user to choose a language and updates the session
    data accordingly. Fortunately, Django already comes with such a view for us to
    use. The view is called **setlanguage**, and it expects a language code in a GET
    variable called language. It updates the session data using this variable and
    redirects the user to the originating page. To enable this view, edit the `urls.py`
    file and add the following highlighted lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the preceding lines is similar to how we added URL entries for the admin
    interface. If you recall from a previous chapter, the `include()` function can
    be used to include URL entries from another application under a specific path.
    Now, we can let the user change the language to German by providing a link, such
    as `/i18n/setlang/language=de`. We will modify the base template to add such links
    to all pages. Open the `templates/base.html` file and add the following highlighted
    lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we will style the new footer by appending the following CSS code
    to the `site_media/style.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, the i18n functionality of our application is ready. Point your browser
    to the "invite friend" page and try the new language links at the bottom of the
    page. The language should change according to which link is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we conclude this section, there are a few observations to be made here:'
  prefs: []
  type: TYPE_NORMAL
- en: You can access the currently active language in views using the request `LANGUAGE_CODE`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django itself is translated in a number of languages. You can see this by triggering
    a form error while a language other than English is active. Error messages will
    appear in the selected language even though you didn't translate them yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In templates, when the `RequestContext` variable is used, the currently active
    language is accessible using the `LANGUAGE_CODE` template variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section was a bit long, but you learned a very important feature from it.
    By offering our application in multiple languages, we make it accessible to a
    broader audience, which gives it greater potential to attract more and more users.
    This actually applies to any web application, and, now, we will be able to translate
    any Django project in multiple languages with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will shift to a different topic. When the user base
    of your application grows, the load on your server will increase and you will
    start to look for ways to improve the performance of your application. This is
    where caching comes to rescue.
  prefs: []
  type: TYPE_NORMAL
- en: So, please read on to learn about this very useful technique!
  prefs: []
  type: TYPE_NORMAL
- en: Caching – improving the performance of your site during high traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pages of web applications are dynamically generated. Code is executed to process
    user input and generate output every time a page is requested. There are a lot
    of overheads involved in generating dynamic pages, especially when compared to
    serving static HTML files. The code may connect to a database, perform expensive
    calculations, process files, and so on. At the same time, being able to generate
    pages with code is exactly what makes a website dynamic and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be great if we could get the best of both worlds? This is what caching
    does, and it's a feature that is implemented on most the sites with medium to
    high traffic. When a page is requested, caching stores the generated HTML of the
    page and reuses it later when the same page is requested again. This cuts a lot
    of overheads by avoiding the generation of the same page over and over again.
    Of course, cached pages are not stored forever. When a page is cached, an expiration
    period is set for the cache. When the cached page expires, it is deleted and the
    page is generated and cached again. The expiration period is usually between a
    few seconds and a few minutes, depending on the traffic of the site. The expiration
    period ensures that the cache is updated periodically and that users receive content
    updates, while, at the same time, reducing the overhead of generating pages.
  prefs: []
  type: TYPE_NORMAL
- en: Although caching is particularly useful for medium to high traffic sites, sites
    with low traffic can also benefit from it. If the site happens to receive a surge
    of high traffic suddenly, perhaps because it was featured on a major news site,
    you can enable caching to reduce the server load and help your website survive
    the surge of high traffic. Later, when the traffic calms down, you can turn off
    caching. So, caching is also useful for small websites. You never know when you
    may need it, so you'd better have this information ready.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start this section by enabling the caching system. To use caching,
    you first need to choose a caching backend and specify your choice in a variable
    called `CACHE_BACKEND` in the `settings.py` file. The contents of this variable
    depend on the caching backend you choose. Some of the available options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Caching**: For this, the cache data is stored in process memory. This
    is only useful to test the caching system during development and must not be used
    in production. To enable it, add the following to the `settings.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Database Caching**: For this, the cache data is stored in a database table.
    To create the cache table, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, the cache table was called `cache_table`. You can call it whatever you
    want as long as it doesn't conflict with an existing table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem Caching**: Here, the cache data is stored in the local filesystem.
    To use it, add the following to the `settings.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `/tmp/django_cache` variable is used to store cache files. You can
    specify another path if you like.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memcached**: Memcached is an advanced, highly efficient, and fast caching
    framework. Installing and configuring it is beyond the scope of this book, but
    if you already have a Memcached server available, you can specify its IP and port
    in the `settings.py` file, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you are not sure which backend to choose for this section, go with simple
    caching. In reality, however, if you are caught in a sudden surge of traffic and
    want to improve server performance, go with Memcached or database caching, depending
    on what's available to you on the server. On the other hand, if you have a website
    with medium to high traffic, I highly recommend you to use Memcached, as it is
    definitely the fastest caching solution available for Django. The information
    presented in this section works the same regardless of which caching backend you
    choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, decide on a caching backend and insert the corresponding `CACHE_BACKEND`
    variable in the `settings.py` file. Next, you should specify the expiration duration
    of cached pages in seconds. Add the following to the `settings.py` file to cache
    pages for five minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are done with enabling the caching system. Continue reading to learn
    how to utilize caching to improve the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can configure Django to cache your whole site or specific views. We will
    learn how to do both in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the whole site
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To cache your whole site, add the `CacheMiddleware` class to your `MIDDLEWARE_CLASSES`
    class in the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Order matters here as it did when we added the locale middleware. The caching
    middleware class should be added after the session and authentication middleware
    classes and before the locale middleware class.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that you need to cache your Django site. From now on, whenever a
    page is requested, Django will store the generated HTML and reuse it later. It's
    important to realize that the caching system only caches pages that do not have
    `GET` and `POST` variables. So, our users will still be able to post tweets and
    follow friends because the views of these pages expect GET or POST variables.
    On the other hand, pages such as tweets and hashtag listings will be cached.
  prefs: []
  type: TYPE_NORMAL
- en: Caching specific views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you will want to cache only specific pages of your website—perhaps
    a high-traffic site linked to a page of yours, so that most of the traffic will
    be directed to this particular page. In this case, it would make sense to cache
    this page only. Another good candidate for caching is a page that is expensive
    to generate, so you would only want it to be generated once every five minutes
    or so. The tag cloud page in our application fits the latter case. Every time
    the page is requested, Django iterates through all the tags in the database and
    counts the number of tweets for each tag. This is an expensive operation because
    it requires a large number of database queries. Therefore, caching this view is
    a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cache the view based on the hashtag class, you simply apply a method called
    `cache_page` and the caching parameter with it. Try this by editing the `mytweets/urls.py`
    file as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using the `cache_page()` method is straightforward. It lets you specify which
    views to cache. The rules mentioned in site caching also apply to view caching.
    If the view receives GET or POST parameters, Django won't cache it.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, we finish this section. Caching won't be necessary when
    you first release your website to the public. However, when your website grows,
    or if you suddenly receive a surge of high traffic, the caching system will certainly
    become handy. So, keep it in mind while monitoring the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to learn about the Django testing framework. Testing can
    sometimes be a tedious task. Wouldn't it be great if you could run a single command
    and it took care of testing your site? Django lets you do this, and we will learn
    about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template fragments can be cached in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing – automating the process of testing your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this book, we sometimes modified a view that we wrote previously.
    This actually happens quite often while developing software. One may modify or
    even rewrite a function to change the implementation details, because the requirements
    have changed, or simply to refactor the code and make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: When you modify a function, you have to test it again to make sure that your
    changes didn't introduce bugs. However, testing will become a boring task if you
    have to repeat the same tests over and over every time you modify a function.
    You may also forget to test all aspects of the function if they are not well documented.
    Clearly, this is not an ideal situation; we definitely need a better mechanism
    to handle testing.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, a solution already exists for this. It is called unit testing.
    The idea is that you write code to test your code. The testing code calls your
    functions and verifies that they behave as expected and then prints a report of
    the results. You only have to write the testing code once. Later, whenever you
    want to test, you can simply run the testing code and examine the resulting report.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a framework for unit testing. It is located in the unit test
    module. Django extends this framework to add support for view testing. We will
    learn how to use the Django unit testing framework in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The test client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to interact with views, Django provides a class that emulates browser
    functionality. You can use it to send requests to your application and receive
    the responses. Let''s learn about it using the interactive console. Launch the
    console using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `Client()` class, create a `Client` object, and retrieve the homepage
    of the application using a GET request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to send a POST request to the login view. The output will vary depending
    on whether you provide correct credentials or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if there is a view that is restricted only to the users that are logged
    in, you can send a request to it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the interactive session, the `Client()` class provides
    three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method sends a GET request to a view. It takes the URL of the view
    as a parameter. You can pass an optional dictionary of GET variables to this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method sends sends a POST request to a view. It takes the URL
    of the view and a dictionary of POST variables as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: This method sends a GET request to a view that is restricted to logged
    in users only. It takes the URL of the view, a username, and password as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Client()` class is stateful, which means that it retains its state across
    requests. Once you log in, later requests will be handled while you are logged
    in. The response object returned by the `Client()` class''s methods contains the
    following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status_code`: This is the HTTP status of the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: This is the body of the response page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: This is the `Template` instance used to render the page; if multiple
    templates were used, this attribute would be a list of Template objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context` : This is the `Context` object used to render the template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These fields are useful to check whether the test succeeded or failed, as we
    will see next. Feel free to experiment more with the `Client()` class. It's important
    to understand how it works before you continue to the next subsection, where we
    will create the first unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the registration view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you are comfortable with the `Client()` class, let''s write our first
    test. Unit tests should reside in a module named `tests.py` inside the application
    folder. Each test should be a method in a class derived from the `django.test.TestCase`
    module. The name of the method must start with the word test. With this in mind,
    we will write a test method that tries to register a new user account. So, create
    a file named `tests.py` inside the `bookmarks` folder and type the following content
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we imported the `TestCase` and `Client` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a class called `ViewTest()`, which is derived from the `TestCase`
    class. As I said earlier, all test classes must be derived from this base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we defined a method called `setUp()`. This method is called when
    the testing process starts. Here, we created a `Client` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we defined a method called `test_register_page`. The name of the method
    starts with the word test, indicating that it is a test method. The method sends
    a POST request to the registration view and checks the status code for equality
    with the number `302`. This number is the HTTP status for a redirect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you recall from a previous chapter, the registration view redirects the user
    if the request succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: We checked the response object using a method called `assertEqual()`. This method
    is inherited from the `TestCase` class. It raises an exception if the two passed
    arguments are not equal. If an exception is raised, the testing framework knows
    that the test failed; otherwise, if no exception is raised, it assumes that the
    test succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TestCase` class provides a set of methods to be used in testing. Here
    is a list of the important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertEqual`: This expects two values to be equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotEquals`: This expects two values to be unequal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertTrue`: This expects a value to be `True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFalse`: This expects a value to be `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you understand the test class, let''s run the actual test by issuing
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, what has happened here? The testing framework starts by creating a test
    database with tables similar to those in the real database. Next, it runs the
    tests found in the tests module. Finally, it prints a report of the results and
    destroys the test database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, our single test succeeded. To see what the output would be like if the
    test fails, modify the `test_register_page` view in the `tests.py` file by removing
    a required form field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `python manage.py test` command again to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our test is working! Django detected an error and gave us the exact details
    of what happened. Don't forget to return the test to its original form once you're
    done. Now, let's write another test, a slightly more advanced one, to understand
    the testing framework better.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other scenarios for which you can write unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether registration fails if the two password fields do not match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the "add friend" and "invite friend" views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the "edit bookmark" functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing that a search returns correct results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list shows just examples. Writing unit tests to cover as many
    use cases as possible is important to maintain a healthy application and to minimize
    bugs and regressions. The more unit tests you write, the more confident you can
    be when your application passes all the tests. Django makes it extremely easy
    to unit test your application, so make use of this fact.
  prefs: []
  type: TYPE_NORMAL
- en: At some point in the application's life, it will move from the development mode
    to production. The next section explains how to prepare your Django project for
    a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you have done a lot of work on your web application, and now it is the time
    to go live. To make sure that the transition from development to production goes
    smoothly, there are a number of changes that must be made to the application before
    it goes live. This section covers these changes to help make the launch of your
    web application successful.
  prefs: []
  type: TYPE_NORMAL
- en: The production web server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been using the development web server that comes with Django throughout
    this book. While this server is perfect for the development process, it's definitely
    not intended to be a production web server, as it wasn't developed with security
    or performance in mind. Therefore, it is certainly not suitable for production.
  prefs: []
  type: TYPE_NORMAL
- en: There are several options to choose from when it comes to a web server, but
    **Apache** is by far the most popular choice, and the Django development team
    actually recommends it. The details of how to set up Django with Apache depends
    on your hosting solution. Some hosting plans offer preconfigured Django hosting,
    where you only have to copy your project files to the server, whereas other hosting
    plans give you the freedom to configure everything yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The details of setting up Apache can vary depending on a number of factors and
    are beyond the scope of this book. If you end up having to configure Apache yourself,
    consult the Django documentation at [http://www.djangoproject.com/documentation/apache_auth/](http://www.djangoproject.com/documentation/apache_auth/)
    for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a variety of interesting topics. We developed an important
    set of features for our project in this chapter. A follower's networks are very
    important to help users socialize and share interests together. We learned about
    several Django frameworks that are useful while deploying Django. We also learned
    how to move a Django project from a development to a production environment. Notably,
    the frameworks that we learned about are all very easy to use, so you will be
    able to effectively utilize them in your future projects. These features are common
    in web 2.0 applications, and, now, you will be able to incorporate them in any
    Django website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about improving various aspects of our application,
    mainly performance and localization. We will also learn how to deploy our project
    on a production server. The next chapter comes with a lot of useful information,
    so read on!
  prefs: []
  type: TYPE_NORMAL
