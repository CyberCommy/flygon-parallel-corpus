- en: Chapter 1. Node.js Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js is one of the most popular JavaScript-driven technologies nowadays.
    It was created in 2009 by Ryan Dahl and since then, the framework has evolved
    into a well-developed ecosystem. Its package manager is full of useful modules
    and developers around the world have started using Node.js in their production
    environments. In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js building blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main capabilities of the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package management of Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Node.js architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the days, Ryan was interested in developing network applications. He
    found out that most high performance servers followed similar concepts. Their
    architecture was similar to that of an event loop and they worked with nonblocking
    input/output operations. These operations would permit other processing activities
    to continue before an ongoing task could be finished. These characteristics are
    very important if we want to handle thousands of simultaneous requests.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the servers written in Java or C use multithreading. They process every
    request in a new thread. Ryan decided to try something different—a single-threaded
    architecture. In other words, all the requests that come to the server are processed
    by a single thread. This may sound like a nonscalable solution, but Node.js is
    definitely scalable. We just have to run different Node.js processes and use a
    load balancer that distributes the requests between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ryan needed something that is event-loop-based and which works fast. As he
    pointed out in one of his presentations, big companies such as Google, Apple,
    and Microsoft invest a lot of time in developing high performance JavaScript engines.
    They have become faster and faster every year. There, event-loop architecture
    is implemented. JavaScript has become really popular in recent years. The community
    and the hundreds of thousands of developers who are ready to contribute made Ryan
    think about using JavaScript. Here is a diagram of the Node.js architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Node.js architecture](img/image00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In general, Node.js is made up of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: V8 is Google's JavaScript engine that is used in the Chrome web browser ([https://developers.google.com/v8/](https://developers.google.com/v8/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A thread pool is the part that handles the file input/output operations. All
    the blocking system calls are executed here ([http://software.schmorp.de/pkg/libeio.html](http://software.schmorp.de/pkg/libeio.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event loop library ([http://software.schmorp.de/pkg/libev.html](http://software.schmorp.de/pkg/libev.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of these three blocks, we have several bindings that expose low-level
    interfaces. The rest of Node.js is written in JavaScript. Almost all the APIs
    that we see as built-in modules and which are present in the documentation, are
    written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fast and easy way to install Node.js is by visiting [https://nodejs.org/download/](https://nodejs.org/download/)
    and downloading the appropriate installer for your operating system. For OS X
    and Windows users, the installer provides a nice, easy-to-use interface. For developers
    that use Linux as an operating system, Node.js is available in the APT package
    manager. The following commands will set up Node.js and **Node Package Manager**
    (**NPM**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running Node.js server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js is a command-line tool. After installing it, the `node` command will
    be available on our terminal. The `node` command accepts several arguments, but
    the most important one is the file that contains our JavaScript. Let''s create
    a file called `server.js` and put the following code inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books that you have purchased. If you purchased this
    book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `node ./server.js` in your console, you will have the Node.js server
    running. It listens for incoming requests at localhost (`127.0.0.1`) on port `9000`.
    The very first line of the preceding code requires the built-in `http` module.
    In Node.js, we have the `require` global function that provides the mechanism
    to use external modules. We will see how to define our own modules in a bit. After
    that, the scripts continue with the `createServer` and `listen` methods on the
    `http` module. In this case, the API of the module is designed in such a way that
    we can chain these two methods like in jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: The first one (`createServer`) accepts a function that is also known as a callback,
    which is called every time a new request comes to the server. The second one makes
    the server listen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result that we will get in a browser is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Node.js server](img/image00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Defining and using modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript as a language does not have mechanisms to define real classes. In
    fact, everything in JavaScript is an object. We normally inherit properties and
    functions from one object to another. Thankfully, Node.js adopts the concepts
    defined by **CommonJS**—a project that specifies an ecosystem for JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encapsulate logic in modules. Every module is defined in its own file. Let''s
    illustrate how everything works with a simple example. Let''s say that we have
    a module that represents this book and we save it in a file called `book.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a public property and a public function. Now, we will use `require`
    to access them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create another file named `script.js`. To test our code, we will
    run `node ./script.js`. The result in the terminal looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining and using modules](img/image00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with `exports`, we also have `module.exports` available. There is a difference
    between the two. Look at the following pseudocode. It illustrates how Node.js
    constructs our modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in the end, `module.exports` is returned and this is what `require` produces.
    We should be careful because if at some point we apply a value directly to `exports`
    or `module.exports`, we may not receive what we need. Like at the end of the following
    snippet, we set a function as a value and that function is exposed to the outside
    world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we do not have an access to `.name` and `.read`. If we try to
    execute `node ./script.js` again, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining and using modules](img/image00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To avoid such issues, we should stick to one of the two options—`exports` or
    `module.exports`—but make sure that we do not have both.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also keep in mind that by default, `require` caches the object that
    is returned. So, if we need two different instances, we should export a function.
    Here is a version of the `book` class that provides API methods to rate the books
    and that do not work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create two instances and rate the books with different `points` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The logical response should be `10 20`, but we got `20 20`. This is why it
    is a common practice to export a function that produces a different object every
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should also have `require('./book.js')()` because `require` returns
    a function and not an object anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Managing and distributing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we understand the idea of `require` and `exports`, we should start thinking
    about grouping our logic into building blocks. In the Node.js world, these blocks
    are called **modules** (or **packages**). One of the reasons behind the popularity
    of Node.js is its package management.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js normally comes with two executables—`node` and `npm`. NPM is a command-line
    tool that downloads and uploads Node.js packages. The official site, [https://npmjs.org/](https://npmjs.org/),
    acts as a central registry. When we create a package via the `npm` command, we
    store it there so that every other developer may use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every module should live in its own directory, which also contains a metadata
    file called `package.json`. In this file, we have set at least two properties—`name`
    and `version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can place whatever code we like in the same directory. Once we publish the
    module to the NPM registry and someone installs it, he/she will get the same files.
    For example, let''s add an `index.js` file so that we have two files in the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our module does only one thing—it displays a simple message to the console.
    Now, to upload the modules, we need to navigate to the directory containing the
    `package.json` file and execute `npm publish`. This is the result that we should
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a module](img/image00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are ready. Now our little module is listed in the Node.js package manager's
    site and everyone is able to download it.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, there are three ways to use the modules that are already created.
    All three ways involve the package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may install a specific module manually. Let''s say that we have a folder
    called `project`. We open the folder and run the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The manager automatically downloads the latest version of the module and puts
    it in a folder called `node_modules`. If we want to use it, we do not need to
    reference the exact path. By default, Node.js checks the `node_modules` folder
    before requiring something. So, just `require('my-awesome-nodejs-module')` will
    be enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of modules globally is a common practice, especially if we
    talk about command-line tools made with Node.js. It has become an easy-to-use
    technology to develop such tools. The little module that we created is not made
    as a command-line program, but we can still install it globally by running the
    following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the `-g` flag at the end. This is how we tell the manager that we want
    this module to be a global one. When the process finishes, we do not have a `node_modules`
    directory. The `my-awesome-nodejs-module` folder is stored in another place on
    our system. To be able to use it, we have to add another property to `package.json`,
    but we'll talk more about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resolving of dependencies is one of the key features of the package manager
    of Node.js. Every module can have as many dependencies as you want. These dependences
    are nothing but other Node.js modules that were uploaded to the registry. All
    we have to do is list the needed packages in the `package.json` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we don't have to specify the module explicitly and we can simply execute
    `npm install` to install our dependencies. The manager reads the `package.json`
    file and saves our module again in the `node_modules` directory. It is good to
    use this technique because we may add several dependencies and install them at
    once. It also makes our module transferable and self-documented. There is no need
    to explain to other programmers what our module is made up of.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s transform our module into a command-line tool. Once we do this, users
    will have a `my-awesome-nodejs-module` command available in their terminals. There
    are two changes in the `package.json` file that we have to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A new `bin` property is added. It points to the entry point of our application.
    We have a really simple example and only one file—`index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other change that we have to make is to update the `version` property.
    In Node.js, the version of the module plays important role. If we look back, we
    will see that while describing dependencies in the `package.json` file, we pointed
    out the exact version. This ensures that in the future, we will get the same module
    with the same APIs. Every number from the `version` property means something.
    The package manager uses **Semantic Versioning 2.0.0** ([http://semver.org/](http://semver.org/)).
    Its format is *MAJOR.MINOR.PATCH*. So, we as developers should increment the following:'
  prefs: []
  type: TYPE_NORMAL
- en: MAJOR number if we make incompatible API changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MINOR number if we add new functions/features in a backwards-compatible manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PATCH number if we have bug fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we may see a version like `2.12.*`. This means that the developer
    is interested in using the exact MAJOR and MINOR version, but he/she agrees that
    there may be bug fixes in the future. It's also possible to use values like `>=1.2.7`
    to match any equal-or-greater version, for example, `1.2.7`, `1.2.8`, or `2.5.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We updated our `package.json` file. The next step is to send the changes to
    the registry. This could be done again with `npm publish` in the directory that
    holds the JSON file. The result will be similar. We will see the new **0.0.2**
    version number on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating our module](img/image00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just after this, we may run `npm install my-awesome-nodejs-module -g` and the
    new version of the module will be installed on our machine. The difference is
    that now we have the `my-awesome-nodejs-module` command available and if you run
    it, it displays the message written in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating our module](img/image00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Introducing built-in modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is considered a technology that you can use to write backend applications.
    As such, we need to perform various tasks. Thankfully, we have a bunch of helpful
    built-in modules at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server with the HTTP module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already used the HTTP module. It''s perhaps the most important one for web
    development because it starts a server that listens on a particular port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have a `createServer` method that returns a new web server object. In most
    cases, we run the `listen` method. If needed, there is `close`, which stops the
    server from accepting new connections. The callback function that we pass always
    accepts the `request` (`req`) and `response` (`res`) objects. We can use the first
    one to retrieve information about incoming request, such as, `GET` or `POST` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The module that is responsible for the read and write processes is called `fs`
    (it is derived from **filesystem**). Here is a simple example that illustrates
    how to write data to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the API functions have synchronous versions. The preceding script could
    be written with `writeFileSync`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, the usage of the synchronous versions of the functions in this module
    blocks the event loop. This means that while operating with the filesystem, our
    JavaScript code is paused. Therefore, it is a best practice with Node to use asynchronous
    versions of methods wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reading of the file is almost the same. We should use the `readFile` method
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Working with events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The observer design pattern is widely used in the world of JavaScript. This
    is where the objects in our system subscribe to the changes happening in other
    objects. Node.js has a built-in module to manage events. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `eventEmitter` object is the object that we subscribed to. We did this with
    the help of the `on` method. The `emit` function fires the event and the `somethingHappen`
    handler is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `events` module provides the necessary functionality, but we need to use
    it in our own classes. Let''s get the book idea from the previous section and
    make it work with events. Once someone rates the book, we will dispatch an event
    in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to inherit the behavior of the `EventEmitter` object. The easiest way
    to achieve this in Node.js is by using the utility module (`util`) and its `inherits`
    method. The defined class could be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We again used the `on` method to subscribe to the `rated` event. The `book`
    class displays that message once we set the points. The terminal then shows the
    **Rated with 10** text.
  prefs: []
  type: TYPE_NORMAL
- en: Managing child processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some things that we can''t do with Node.js. We need to use external
    programs for the same. The good news is that we can execute shell commands from
    within a Node.js script. For example, let''s say that we want to list the files
    in the current directory. The file system APIs do provide methods for that, but
    it would be nice if we could get the output of the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The module that we used is called `child_process`. Its `exec` method accepts
    the desired command as a string and a callback. The `stdout` item is the output
    of the command. If we want to process the errors (if any), we may use the `error`
    object or the `stderr` buffer data. The preceding code produces the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing child processes](img/image00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with the `exec` method, we have `spawn`. It''s a bit different and really
    interesting. Imagine that we have a command that not only does its job, but also
    outputs the result. For example, `git push` may take a few seconds and it may
    send messages to the console continuously. In such cases, `spawn` is a good variant
    because we get an access to a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `stdout` and `stderr` are streams. They dispatch events and if we subscribe
    to these events, we will get the exact output of the command as it was produced.
    In the preceding example, we run `git push origin master` and sent the full command
    responses to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is used by many companies nowadays. This proves that it is mature enough
    to work in a production environment. In this chapter, we saw what the fundamentals
    of this technology are. We covered some of the commonly used cases. In the next
    chapter, we will start with the basic architecture of our example application.
    It is not a trivial one. We are going to build our own social network.
  prefs: []
  type: TYPE_NORMAL
