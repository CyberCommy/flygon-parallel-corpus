- en: Persisting Object Data to Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, the process of reading and writing data to and from a file
    system-resident data store probably looks much simpler than the equivalent processes
    for many database-backed storage mechanisms. Reading and writing files, after
    all, is a very basic process. In reality, it's a slightly more complex process,
    though. There are precautions that need to be taken to deal with things such as
    file system permissions, hard shutdowns of the application using data access,
    and even system crashes, to some degree. While these complicate development somewhat,
    they are perhaps more challenging to identify as possibilities than they are to
    implement safeguards around.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic component project setup for `hms_artisan`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A further abstraction layer to encapsulate the file system-based data storage
    needs involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The development of data objects in the `hms_artisan` component project for
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artisans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the hms_artisan project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the foundation classes we need (so far) defined in `hms_core`,
    we can start building out the concrete classes that correspond to them in other
    projects. Since the plan is for the **Artisan Application** to have a custom,
    local data storage mechanism, and that''s likely going to be more complicated
    than the equivalents in the Central Office application and the Artisan Gateway
    service, it arguably makes the most sense to start with that project, and by creating
    a project structure to meet the needs of this story:'
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, I need a project for the Artisan Application so that I have
    a place to put the relevant code and build the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, the code for the `hms_artisan` classes could start in the `hms_artisan/__init__.py` file,
    just as the business object ABCs in `hms_core` started in its root `__init__.py` file, but
    it seems reasonable to assume that some variant of the reason why those were just
    moved to their own `business_objects.py` module would be likely in the Artisan
    Application codebase. With that in mind, we'll create an `artisan_objects.py` module
    to keep them grouped and organized. That will also make it easier to keep any
    data storage classes that we might need that aren't themselves data objects in
    a separate module in the same package. We could just as easily put all of the
    Artisan Application code into a single module (`hms_artisan.py`) instead of having
    a package directory and the attendant files therein. There's no functional reason
    for not doing so, but unless there's some certainty that there would never be
    a need to change from that single module file implementation to a package structure,
    it raises the longer-term risk of having to reorganize the entire namespace file
    structure. The starting project structure looks very much like the default defined
    in [Chapter 7](cabfde73-7c51-4741-8832-ca8427793869.xhtml), *Setting Up Projects
    and Processes:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9949e782-e703-4bd8-9ba5-f4d5636b28a8.png)'
  prefs: []
  type: TYPE_IMG
- en: That sort of reorganization is not difficult, but it is time consuming, all
    the more so if unit test modules also have to be reorganized. When such a reorganization
    is under way, it has the potential to limit other work against a codebase by anyone
    who isn't part of the reorganization effort. It also has a lot of potential to
    make source control management very messy until it's complete, which isn't a great
    situation for a member of a dev team with other tasks to execute against that
    codebase to be in.
  prefs: []
  type: TYPE_NORMAL
- en: The odds are good that we'll want or need a separate module for the actual application
    anyway, though, so it just makes sense to start subdividing code into logical
    groupings at the outset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local file system data store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Artisans'' needs for storing data are captured in two stories:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need a local data store for all of my system data, so that
    I don't have to be connected to the internet to make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Artisan, I need my local data store to be as simple as possible, requiring
    no additional software installations, so that I don't have to worry about installing
    and maintaining a database system as well as the Artisan Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final relationships between the various Artisan Application data objects
    and `BaseDataObject` could be as simple as having each Artisan-level class derive
    directly from `BaseDataObject`. Indeed, if there were only one such class at the
    Artisan level, and no expectation of that changing in the foreseeable future,
    it would make a lot of sense to take that approach. The code that would handle
    the creation of record files, updating the data therein, reading it, or deleting
    it could live in a lone class. Since there are three object types that we need
    to be concerned with, though, there is at least some potential benefit to collecting
    a common functionality for file-based data stores into another abstract class
    that lives between `BaseDataObject` and the concrete `hms_artisan` classes, such
    as `hms_artisan..Artisan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1069c52d-81b7-4a36-a9be-92c7ce612eb6.png)'
  prefs: []
  type: TYPE_IMG
- en: That intermediary class, `JSONFileDataObject`, would extend `BaseDataObject`,
    adding functionality and data that is specific to the task of managing object
    state data that lives in a collection of JSON-formatted files. At the same time,
    it would preserve the abstraction requirements from `BaseDataObject`, or provide
    a concrete implementation of them and make them available to classes such as `hms_artisan..Artisan`.
    The net benefit of this inheritance structure is that, ideally, all of the functionality
    necessary to perform CRUD operations against a JSON-backed data store of objects would
    be able to reside in one place. Realistically, some of the specifics may have to
    live in the concrete class implementations – otherwise, they could all be wrapped
    into a single class, after all – but there will almost certainly be substantial
    commonalities that can be implemented in that middle inheritance level.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complete collection of goals for any class derived from `JSONFileDataObject` would
    include the following, at a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the stored data for any derived class should probably live in one location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance data for each object type (class) should probably live in a common
    location within the top-level location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data for any given instance should probably reside in a single, distinct file,
    whose name can be uniquely related to the instance whose data it stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some should-have or nice-to-have functionalities that
    are worth considering:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data reading operations would be faster if the process didn''t involve finding,
    opening, reading, and creating objects for every file every time a data read was
    executed. A trade-off for this is that any time data-altering operations are executed,
    they have to be responsible for making the appropriate alterations to whatever
    data is involved, in all the places it lives. If there is an in-memory collection
    of objects that were read from the persistent files, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create operations would have to add new objects to the in-memory store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates would have to write to the data-store file and update the in-memory
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletions would have to remove the relevant file and remove the appropriate
    object from the in-memory store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these are particularly difficult to implement, though.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JSONFileDataObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining the `JSONFileDataObject` abstract class starts with a standard `ABCMeta` metaclass
    specification, and some class-level attributes for various purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_file_store_dir` is a default file system directory specification that will
    eventually need to be read from a configuration file in the final installable
    application. For the time being, and for unit testing purposes, it will have a
    hardcoded value set that can be used during development and testing, and we''ll
    look at the configuration setup when we get to the Artisan Application''s implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_file_store_ready` is a flag value that will be used to indicate to the class
    whether it''s loaded all of the available objects from the data files, and thus
    whether it needs to load them before performing any CRUD operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_loaded_objects` is where the collection of objects loaded by the class will
    be stored. The actual object stores will be a `dict` of object instances, but
    until the loading operation has completed, it''s defaulted to `None` in order
    to make the determination between unloaded (`None`) and loaded-with-no-objects
    (an empty `dict`) states later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it inherits from `BaseDataObject`, the class will start with the abstraction
    requirements defined there, and could not be instantiated without fulfilling those
    requirements. However, since we want `JSONFileDataObject` to also be abstract,
    it also has the standard ABC metaclass specification, and is itself abstract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the initialization method of `JSONFileDataObject` is identical
    to that of the `BaseDataObject` it derives from, but it performs a few additional
    tasks during that process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first new functionality involved is checking for a non-`None` value for
    the `_file_store_dir` class attribute. Since the whole point of these classes
    is to be able to save object data to JSON files, and that requires a place for
    those files to actually reside, not having one specified is a critical issue that
    would prevent any useful execution of CRUD operations, so an error is raised if
    a problem is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, even if the file storage location is specified, that location has
    to exist, and be accessible to the code as it runs under the user''s account with
    the attendant permissions. Each class, then, needs to check for the location''s
    existence (and create it if it doesn''t exist), and make sure that files can be
    written, read, and deleted. This checking process could fire off every time an
    instance of the class is created, but if the process has completed once already,
    it should be satisfactory to skip it from that point on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth noting that since the `_file_store_ready` value is a class attribute,
    that value will persist for an entire Python run. That is, using the Artisan Application as
    an example, the following will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The application is started
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At some point, a data object class instance is initialized (say, a `Product`),
    and the checking process runs, successfully verifying all the data storage needs
    for product objects and setting the `_file_store_ready` to `True` accordingly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user does things with the application that don't interact with any product
    objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another product object is initialized, but because the `_file_store_ready` flag
    has been set to `True`, the check process is skipped
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as the application is shut down, though, that flag value goes away,
    so the next time the application is started up, the check process is repeated
    the first time a product object is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'File access permissions are, as noted already, also checked by first writing a
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by reading the file that was just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, by deleting that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The balance of `__init__()` follows the same structure established earlier.
    Since the class has a parent class – `BaseDataObject` – it calls that initializer,
    but since there are no local properties to initialize or set values for, there
    aren''t any of those calls. All of the other properties'' initializations are
    handled by the call to `BaseDataObject.__init__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Three of the methods, either required by the abstraction in `BaseDataObject` or
    with concrete implementations, need to be addressed in `JSONFileDataObject`. The `_create` and `_update` methods
    are required by `BaseDataObject`, but don''t make a lot of sense in the context
    of this class because the same basic operation would take place whether the operation
    involved was a creation or update effort. Both of those, while implemented, do
    nothing more than raise an error with some information that would be useful for
    developers who encounter it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Those changes, then, put all the responsibility for writing data to files on
    the `save` method, no matter whether the data being saved represents a new/create
    action or an edit/update one. Although it''s not likely, it''s not impossible
    for the permissions of the directory where data files are stored to change while
    the program is running. They were checked initially, but that only means that
    they were valid at the time they were checked, so the process of writing data
    to files should check them as well, independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It does need to confirm that objects have been loaded into memory first with `_load_objects`; at
    execution time, this will always be an instance of the class calling a class method that''s inherited, so
    the class has to be explicitly passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it saves the data and confirms that the object itself is stored in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file write fails (the `json.dump` call) with a permissions-related error,
    none of the in-memory updates will be committed, and a more end user-friendly
    error message should be raised, in case it needs to be displayed to that end user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The same common storage location file system path values that allow the save method
    to be made concrete also allow the `delete` and `get` class methods to be made
    concrete class methods of `JSONFileDataObject`. Because the class properties define
    what''s needed to find the data files relevant to any/all object instances, delete
    code can directly make the needed file-deletion efforts, with the appropriate
    error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` method doesn''t need read access to the files directly – the `_load_objects` class
    method handles that, loading all the data that  `get` relies upon – and once the
    relevant objects exist in memory, finding them, even with criteria or a combination
    of object IDs and criteria, is quite simple and fast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If `oids` have been supplied, the process has to account for those, and for `criteria` if it was
    supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If no `oids` were supplied, but `criteria` was, the process is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In both branches, any filtering based on `criteria` is handled by the individual
    object's `matches` method, making the process of searching for objects by specific
    property values very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these rely, then, on the `_load_objects` class method to retrieve and
    populate the in-memory copies of all objects whose data has been persisted as
    JSON files, and attaching them to the relevant class, in the `_loaded_objects` dictionary
    that was defined as a common class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the data has not been loaded (indicated by the `_loaded_objects` attribute
    containing a `None` value), or if an explicit reload of data was called for (a `True` value
    received in the `force_load` argument), the method retrieves a list of all files
    in the class data directory, after verifying that the relevant directories exist,
    trying to create them if they don''t, and raising errors if they need to be created
    but cannot be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are any files found, then an attempt is made to read each one, convert
    it from the JSON-encoded `data_dict` expected into an actual instance of the class,
    and add the instance to the `_loaded_objects` attribute. Since `_loaded_objects` is
    a class attribute, loaded values will persist for as long as that class definition
    is active. Barring an explicit purge or redefinition of the class itself, this
    will persist for the duration of the Python interpreter that''s running the code, allowing
    the data read in by the process to persist for as long as the code that''s using
    it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s possible, even if it''s unlikely, for the file system permissions
    of the data files themselves or of the parent directories of the file to change
    while the Artisan Application is running, file reads could throw `PermissionError` exceptions,
    so those are caught and tracked until the process is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the content of a data file is invalid, an error is raised, though
    in this case it''s immediate. The rationale for the immediacy is that data has
    been corrupted, and that needs to be resolved before allowing any changes to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Any other errors will cascade out to the calling code, to be handled there or
    allowed to abort the application's execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original goals, including the should-have or nice-to-have functionalities, have
    all been accounted for at this point, in a complete set of CRUD operation mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the stored data for any derived class should probably live in one location. This
    is enforced by the `_file_store_dir` class attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance data for each object type (class) should probably live in a common
    location within the top-level location and data for any given instance should
    probably reside in a single, distinct file, whose name can be uniquely related
    to the instance whose data it stores. These are managed by ensuring that all the
    file paths used contain the class name, so that, for example, all product instance
    data will be stored in `_file_store_dir/Product-data/*.json` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data reading operations would be faster if the process didn't involve finding,
    opening, reading, and creating objects for every file every time that a data read
    was executed. The `_load_objects` class method performs the load, and making sure
    that it gets called before any CRUD operations are executed takes care of making
    them available. The create, update, and delete processes all take into account
    both the persistent data files and the in-memory instances that relate to those
    instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concrete business objects of hms_artisan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final definition of the concrete classes in the Artisan Application really
    just boils down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining each concrete class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving from the corresponding base class in `hms_core`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving from `JSONFileDataObject` that was just defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting the arguments for the new class `__init__` method, which needs to
    account for all of the arguments of the parent classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing any of the abstract instance and class methods required by the
    parent classes, many of which have already been set up to allow the derived class
    to call the parent's abstract method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a `_file_store_dir` class attribute value that can be used by instances
    of the classes until the final application configuration is worked out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These relationships may make more sense if they are diagrammed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38603a7f-8659-43ec-b12f-1f879bcb4a48.png)'
  prefs: []
  type: TYPE_IMG
- en: Dealing with is_dirty and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BaseDataObject` provides `is_dirty`, a property that''s intended to indicate
    when the state data of an object has been changed (for example, it should be set
    to `True` when any of the various `_set_` or `_del_` methods have been called).
    Since the concrete objects'' property setter and deleter methods, as defined in
    their corresponding base classes, aren''t aware of that capability at all, it''s
    up to the concrete objects to implement that functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since those setter and deleter methods can be called in the derived
    concrete class definitions, the implementation is very straightforward. Using
    the `address` property of `Artisan` as an example, we essentially define local
    setter and deleter methods that call their counterparts in `BaseArtisan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once those are defined, the property itself has to be redefined in order to
    point to the appropriate methods. Without this step, the `Artisan` objects'' properties
    would still point to the `BaseArtisan` setter and deleter methods, so the `is_dirty` flag
    would never get set, and data changes would never be saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This same pattern will play out for all of the properties of the `hms_artisan` classes.
  prefs: []
  type: TYPE_NORMAL
- en: That also means, however, that all of those classes, since they all use their
    various `_del_` methods to initialize instance values during the execution of
    their `__init__` methods, may also need to explicitly reset `is_dirty` to `False` when
    an object is created.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simplistic approach to handling the dirty state of object instances.
    The fundamental assumption behind this implementation is that any property setting
    or deletion that occurs will make a change to the applicable state value, so the
    instance is dirty as a result. Even if the new value was the same as the old value
    of a property, this would be the case. In systems where there is an actual monetary
    cost for each database transaction (some cloud-based data stores), it might be
    worth the additional effort of checking the property value before executing the
    set code or delete code, and not even making the change, let alone setting the `is_dirty` flag,
    if the incoming new value isn't different from the existing one.
  prefs: []
  type: TYPE_NORMAL
- en: hms_artisan.Artisan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Artisans need to be able to manipulate their own data in the Artisan Application:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to create, manage, and store my own system
    data so that I can keep it up to date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The initial code for the `Artisan` class that provides the data structure and
    persistence that fulfills this story''s needs is very lightweight, since most
    of the functionality is inherited from `hms_core`, `BaseArtisan` (for properties
    and data-structure), and `JSONFileDataObject` (for methods and persistence functionality).
    Not counting comments and documentation, it''s just under 60 lines of real code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__init__` method has a long and detailed argument signature, with 12 arguments
    (three of which are required), and the `products` arglist. It may seem daunting,
    but is not expected to be needed for most use cases (more on that shortly). All
    it really needs to do is call the parent initializers to set the applicable property
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The bulk of the instance methods can call the original abstract methods (with
    their existing implementations) in the classes that they originate from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The exception to that is the `to_data_dict` method, which must be customized
    for each concrete class. All that it needs to do, though, is return a `dict` of
    all the properties and values that should be persisted, and that can be used in
    the initialization of an object. The `address` property has an issue with it,
    from the perspective of being able to store it in a JSON file, and that will be
    examined shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `datetime` and `UUID` properties are converted to string values for the
    outgoing data dictionary, and they are already situated during the initialization
    of an `Artisan` object to be converted back to their native data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The single class method, like the bulk of the preceding instance methods, also
    uses the original abstract class methods that have implementations within them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The long argument signature of `Artisan.__init__` may feel a bit daunting at
    first glance. There are a lot of arguments, after all, and Python's language stipulation
    that requires that arguments have to go before optional ones in method and function
    argument definitions means that three of those arguments have to come first (though
    their sequence with respect to each other is up to the developer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, however, that `__init__` method will probably not be called
    directly. The creation of an instance from data retrieved from the data store
    is expected to be handled with the `from_data_dict` method of the class, probably
    looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'An `Artisan` instance could also be created directly by passing a dictionary
    of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The only considerations for that approach are that the required arguments must
    have valid entries in the `data_dict` being passed, and that `data_dict` cannot
    contain keys that don''t exist as argument names in the `__init__` method – essentially,
    that object creation is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It was noted that there were issues with the `address` property when it came
    to creating JSON output for an `Artisan` instance. The core issue is that the `Address` class
    is not directly serializable into JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding code is executed, `TypeError: <hms_core.business_objects.Address
    object> is not JSON serializable` is raised.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are several possible solutions for this issue, since we''ve
    already established a pattern of converting objects to and reading/creating them
    from dictionary values, the one that is most like that pattern is to implement
    the `to_dict` and `from_dict` methods on the original `Address` class in `hms_core`,
    and change the `to_data_dict` result to use the `to_dict` of the instance''s `address`.
    The new `Address` methods are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the change to `Artisan.to_data_dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With those changes in place, rerunning the code that raised the `TypeError` before
    now yields usable JSON, meaning that the results of a `to_data_dict` call can
    be used to directly write the JSON files needed to persist `Artisan` data to the
    file system data store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16314853-dd95-4532-a293-d99f6cd53e66.png)'
  prefs: []
  type: TYPE_IMG
- en: hms_artisan.Product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Artisans have a similar data persistence need for `Product` object data:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to create, manage, and store `Product` data,
    so that I can keep `product` information current in the central office system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hms_artisan..Product` class, like the `Artisan` class of the package, leverages
    its corresponding `hms_core` base class (`BaseProduct`) and the `JSONFileDataObject` ABC
    to minimize the amount of actual code needed in the concrete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the only real differences are in the `__init__` method (with different
    arguments, and calling a different parent initialization method set):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `to_data_dict` method (which has to account for the different properties
    of the class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar simple creation of a `Product` object, and a dump of its `to_data_dict` results,
    yield viable JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e7aef5cd-6c79-4a1d-ade0-8db10121250f.png)'
  prefs: []
  type: TYPE_IMG
- en: hms_artisan.Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability for Artisans to have locally saved order data is also needed:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to create, manage, and store `Order` data so
    that I can fulfill orders when they are relayed to me, and flag them as fulfilled
    for the Central Office
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order data, though, is a bit different from the `Artisan` and `Product` data
    that we have explored so far at a structural level:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Order`, when it comes right down to it, is an association of one customer
    with one-to-many products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no expected need for Artisans to keep track of individual customers,
    except as they relate to orders, so Artisans need `Customer` objects that aren't also
    data objects, in much the same way that `Artisan` objects have an `Address` associated
    with them that aren't themselves data objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Customer` object that is part of an `Order` also has an `Address` that
    has to be accounted for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The products associated with an order imply at least the possibility of a quantity associated
    with them – a customer may want to order two of one product, five of another,
    and one of a third, for example – and don't really need to have all of the `Product` data
    transmitted, so long as the `oid` for each `Product` in the order is supplied.
    That would be sufficient information for the Artisan Application to look up products
    from its local `Product` data store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That last item, in retrospect, calls into question some of the structure of `BaseOrder` in `hms_core`, or
    at least whether it''s relevant in the scope of the Artisan Application. As it''s
    currently defined, it derives from `hms_core` ... `HasProducts`, with the original
    intention that actual `Product` objects would be associated with an `Order`. That might make
    sense in a Central Office or gateway service context, but it''s not going to be
    terribly useful in the context of the Artisan Application. A better order-to-product
    relationship is probably to store the `oids` and quantities of each `Product`  in
    an `Order`, and let the applications and service look them up when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ef57d52-c880-4be6-b81e-49f8f9620215.png)'
  prefs: []
  type: TYPE_IMG
- en: Taking a step back and looking at what an Artisan Application's `Order` really is,
    it would seem to be an `Address`, with the addition of a `name` property (who
    the order is for), and some `Product` quantity data. The association between `oid` product
    specifications and quantity values is easily managed in a `dict` property, and
    the processes for adding and removing order items can be wrapped in a single method
    that accepts the `oid` and a quantity value.
  prefs: []
  type: TYPE_NORMAL
- en: 'That feels like a much better solution for Artisans'' order data. They don''t
    really need to know anything more than the data this structure covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Who the order is for (`name`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where it gets sent to (the properties derived from `Address`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What products are part of the order, and in what quantities (`items`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Order` class, then, starts by deriving from `Address` and `JSONFileDataObject`,
    with the usual class attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The property definitions, getter, setter, and deleter methods, and the property
    declarations follow the pattern we''ve used everywhere else so far, with `_get_items` returning
    a copy of the current property in order to prevent unwanted manipulation of the
    actual data. The setter and deleter methods also have to explicitly call `_set_is_dirty(True)` to
    ensure that the `is_dirty` flag of the instance gets changed appropriately when
    a local property is deleted or set, and the properties themselves, with their setter
    and deleter methods that are inherited from `Address`, have to be overridden. There
    are two local getter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the setter methods call their ancestor methods, set `is_dirty`, and
    `exit`, but the two that correspond to the local getters are full implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The deleter methods follow the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And the properties follow suit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization process (`__init__`) has a long signature again, since it
    has to accommodate all of the arguments from its parent classes, plus arguments
    for the local properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `matches` method can still just call the `matches` method of `BaseDataObject`; there''s
    no expectation that any matching will need to happen that would require anything
    more or different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for setting item quantities in an order has a fair amount of type
    and value checking to do, but those all follow patterns that have been used in
    earlier code, including checking for types, conversion of `oid` string values
    to `UUID` objects, and checking for valid values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `quantity` specified for a given item is zero, the item in question
    is removed entirely rather than leaving what is essentially a line item in the
    order for zero items of a given product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The data dictionary generation actively converts the instance''s items into
    a dictionary with string value keys instead of `UUID` objects, but is otherwise
    pretty typical of the implementations written so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_load_objects` and `from_data_dict` class methods are identical to those
    put in play in earlier code. The `Address` class `standard_address` method cannot
    be left as it is inherited by `Order`, since any attempt to call it would result
    in an error – it would not have the new, required `name` argument – so it is overridden
    with a new class method with a nearly identical argument set (adding the `name`),
    that can be used to generate a new `Order` instance with no items added, but all
    of the other relevant information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of these data storage operations can be seen in the file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3456f833-1030-4ef5-a0f8-6d26ebfe4476.png)'
  prefs: []
  type: TYPE_IMG
- en: Barring any corrections or changes prompted by unit testing later in the iteration,
    that accounts for all of the classes in the Artisan Application that have any
    anticipated need to persist data. Basic testing of the data persistence functionality
    by creating a minimal data instance of each shows that they do, indeed, write
    JSON data to the expected location, and that the data written is at least superficially
    correct. Detailed unit testing will still have to be undertaken to ensure that
    the data really is accurately written and retrievable without loss or corruption,
    but the bulk of the main development for these objects is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationships between these concrete classes and the `hms_core` equivalents
    has changed somewhat, with the creation of `Order` as a class no longer attached
    to `hms_core..BaseOrder`, and the removal of the `Customer` class at the Artisan
    Application level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/140d3641-f87d-450f-92ce-7197bd816ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: The underlying data storage residing in structured JSON data could also be repurposed
    to providing data access and CRUD operations against a remote API of some sort.
    A RESTful/JSON web service, for example, that returned the same JSON structures
    or accepted them as payloads for creation and update requests, could almost certainly
    use these objects with only a little bit of modification, in most cases. That
    sort of approach might be worth looking at in this system, were it ever to go
    further than it will in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it still needs to be thoroughly tested, which will be addressed in [Chapter
    14](4d1c6624-dca4-4f64-beac-4c5132125cec.xhtml), *Testing Data Persistence*, preliminary
    testing of the JSON-based data file persistence feels pretty solid at this point.
    The CRUD operations that are required by `BaseDataObject`, passing through `JSONFileDataObject`
    to all of the concrete data objects, are all present and accounted for, and they
    appear to be fully functional. The change to the structure of the `Order` class
    might be cause for some concern with respect to the original design, but was not
    difficult to deal with. That change should be specifically called out during the
    approval process for the iteration, since it represents a change to the original
    design, but it doesn't feel like it will be a cause for any major concerns at
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: With one data persistence mechanism done, and while the concepts are still fresh,
    it's time to look at the equivalent processes, backed by a real database engine,
    for the Central Office applications and service.
  prefs: []
  type: TYPE_NORMAL
