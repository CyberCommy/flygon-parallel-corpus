- en: Chapter 8. Creating Pages and Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 7](part0050.xhtml#aid-1FLS42 "Chapter 7. Posting Content"), *Posting
    Content*, covered the posting of content. We gave an interface to user to send
    text and images to our database. Later, these resources were shown as a message
    feed on the home page. In this chapter, we will learn how to create pages and
    events that are attached to these pages. Here is the plan that we are going to
    follow:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a form to create pages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a record in the database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the currently added pages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a specific page
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting a comment to a page
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing comments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing events attached to a particular page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you check the files that you ended up with in the previous chapter, you will
    see that the `backend/API.js` file is quite big. It will get more and more difficult
    to work with. We are going to refactor this part of our system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a bunch of helper methods that are used all over the route handlers.
    Functions such as `response`, `error`, and `getDatabaseConnection` may be placed
    in an external module. We will create a new `api` folder under the `backend` directory.
    The newly created `helpers.js` file will host all these utility functions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will skip the implementation of the functions so that we don't bloat the
    chapter with the code that we already saw. We also copied a few variables used
    by the methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step of our refactoring is the extraction of all the route handlers
    into their own methods. So far, the file is structured as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The whole structure is a bunch of route definitions and their respective handlers.
    We often have a `switch` statement that checks the type of the request. In practice,
    every function (`req`, `res`) can be represented by an independent module. Again,
    we are not going to paste the content of all the created files, but we will talk
    about the final result. After the refactoring, we will have the following structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring the API](img/image00181.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'The number of lines in `API.js` decreased significantly. Now, we have just
    the route''s definition and its handlers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The functions that the new files export are still the same. The only thing
    that you should consider is the helper functions. You have to provide them in
    all the new modules. For example, the `friends.js` file contains the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Check out the files that came with this chapter for the complete source code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Adding a form to create pages
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every user in our social network should be able to browse and create pages.
    This is a completely new functionality. So, we will need a new route and controller.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by updating `frontend/js/app.js`, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just above the default handler, we will register a route that creates an instance
    of a new controller called `Pages`. We will make sure that the visitor is logged
    in before seeing the page. In the same file, at the top, we will add `var Pages
    = require('./controllers/Pages');`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s dive into the `controllers/Page.js` file and see how you can bootstrap
    the controller:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `onrender` function is still empty, but we will fill it in the next few
    sections. The template that stands behind this page is located in `frontend/tpl/pages.html`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code looks similar to the one used in the previous chapter when we created
    the UI to add content. We have placeholders for successful and error messages.
    There are two variables, `title` and `description`, and a button dispatching the
    `create` event.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Creating a record in the database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue and handle the situation where the user presses the **Create**
    button. After the user performs this action, we have to get the content of the
    text areas and submit a request to the backend. So, we need a new model. Let''s
    call it `Pages.js` and save it under the `models` directory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We already talked about the `FormData` interface in the previous chapter. The
    API endpoint that we are going to use is `/api/pages`. This is the URL where we
    will send a `POST` request.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the form displayed and the model ready for backend communication,
    we can continue with the code in our controller. The `onrender` handler is the
    right place to listen to the `create` event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The initialization of the model is at the top. After fetching the data filled
    by the user, we will call the `create` method of the model and handle the response
    afterwards. If something goes wrong, our application displays an error message.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in this section is updating the API so that we can keep the data
    in our database. There is still no route that matches `/api/pages`. So, let''s
    add one:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We refactored the API so that the code that will process the requests goes
    to the new `/backend/api/pages.js` file. In the first few lines, there are shortcuts
    to our helper methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the code that creates a new record in a new `pages` collection. It
    may look a little long, but a major part of the same is already covered in [Chapter
    7](part0050.xhtml#aid-1FLS42 "Chapter 7. Posting Content"), *Posting Content*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The creating and browsing of pages is a feature reserved only for the logged
    in users. The first few lines of the exported function check whether the current
    visitor has a valid session. The frontend sends a `POST` request without a file,
    but we will still require the `formidable` module because it has a nice programming
    interface and is easy to use. Every page should have a title and a description,
    and we will check whether they exist. If everything is okay, we will create a
    new record in the database by using the well-known `getDatabaseConnection` function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Showing the currently added pages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is nice that we started keeping the created pages in the database. However,
    it will also be great to show the pages to the users so that they can visit them
    and add comments. In order to do that, we have to modify our API so that it returns
    the page information. If you look at the preceding code, you will see that there
    is a `GET` case that was left empty. The following codes gets all the pages, sorts
    them by date, and sends them to the browser:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before sending the JSON object to the frontend, we will delete the ID of the
    creator. The name of the user is already there and it is a good practice to keep
    these IDs only in the backend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'After a quick restart, the Node.js server returns the created pages when we
    visit `/api/pages`. Let''s move forward and update the `controllers/Pages.js`
    file in the client side of our app. In the `onrender` handler, we will append
    the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will wrap the newly added logic in a function because we have to go through
    the same things when a new page is created. The model does most of the job. We
    will simply assign an array of objects to a `pages` variable. This variable is
    used in the template of the component—`frontend/tpl/pages.html`—as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, you will learn how to show only a particular page. The
    link that we added in this code forwards the user to a new address. This link
    is a URL that contains the information for only one page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Showing a specific page
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, to show a specific page, we need to update our API. We have the code
    that returns all the pages, but there is no solution if you want to return only
    one of the pages. We will use the ID of the page for sure. So, here is a new route
    that can be added to `backend/API.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should keep in mind that the order of the routes is important. The one
    that contains the ID of the page should be above the one that shows the list of
    the pages. Otherwise, the application will proceed with listing a new URL all
    the time, but we will keep the same handler. If there are any dynamic parts in
    the address, our router sends an additional parameter to the function. So in `backend/api/pages.js`,
    we will change `module.exports = function(req, res)` to `module.exports = function(req,
    res, params)`. In the same file, we will fetch all the pages from the database.
    In this case, we want the code to be modified so that the function returns only
    one record that matches the ID that was passed in the URL. So far, our MongoDB
    query looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In practice, we have no criteria. Now, let''s change the preceding code to
    the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By defining a `query` variable, we make the response of this API method conditional.
    It depends on the existence of the ID in the URL. If there is any such ID, it
    still returns an array of objects, but there is only one item inside.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In the frontend, we can use the same approach, or in other words, the same
    controller that covers both the cases—showing all the pages and showing only one
    page. We register a new route handler that forwards the user to the same `Pages`
    controller, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time, we passed the configuration during the initialization of the controller.
    The setting of values in the `data` property creates variables that are later
    available inside the component and its template. In our case, `pageId` will be
    accessible via `this.get(''pageId'')`. If the variable does not exist, then we
    are in the mode that shows all the pages. The following lines display the title
    and the description of a single page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The model that we used so far performs the `POST` and `GET` requests, but we
    can''t use them in this case. They are reserved for other functionalities. We
    need another method that accepts the ID of the page. This is why we will add a
    new `getPage` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We do not have any data to send. We have only a different endpoint URL. The
    ID of the page is appended at the end of the `/api/pages` string. This section
    started with changes in the backend so that we know that the API returns an array
    of one element. The rest is setting `pageTitle` and `pageDescription`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template, we use the same pattern. You can check whether `pageId` exists
    and this will be enough to find out whether we have to show one or many pages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After changing `frontend/tpl/pages.html`, we have a unique URL for every page.
    However, a page displayed with a static title and description is not very interesting
    for the users. Let's add a comments section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Posting a comment to a page
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before reaching the part where we send and process an HTTP request, we have
    to provide a user interface to create a comment. We will add a form just below
    the title and description of the page in `frontend/tpl/pages.html`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The event that is dispatched after clicking on the button is `add-comment`.
    The `Pages` controller should handle it and fire a request to the backend.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'If you stop and think a bit about how the comments look, you will notice that
    they are similar to the regular user posts that are visible in the user''s feed.
    So, instead of creating a new collection or storing complex data structures in
    the `pages` collection, we will save our comments as regular posts. For the code
    on the client side, this means one more use case of the `ContentModel` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The usage of the model is the same except for one thing—we send an additional
    `pageId` variable. We need something to distinguish the posts made in the home
    page and those made as comments. The API will still not save `pageId`. So, we
    have to make a little update in `backend/api/content.js`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the user is making a comment, the record in the database will contain the
    `pageId` property. This is enough to keep the comments away from the home page.
    Also, from another point of view, it is enough to display only the comments for
    a particular page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Showing the comments
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should update the API method that returns the pages as objects. Along with
    the title and description, we have to present a new `comments` property. Let''s
    open `backend/api/pages.js` and create a function to fetch comments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The key moment in the preceding method is the forming of the MongoDB query.
    This is the place where we filter the posts and fetch only those that are made
    for the page that matches the passed ID. The following is the updated code corresponding
    to the `GET` request:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are two types of responses. The first one is used when we have an ID added
    to the URL or, in other words, when we show information about a page. In this
    case, we have to also fetch the comments. In the other case, we do not need the
    comments because we will be displaying only the list. Checking whether `params.id`
    exists is enough to decide which type of response to send.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the backend starts returning the comments, we will write the code that
    shows them in the browser. In `frontend/js/controllers/Pages.js`, we will set
    the title and description of the page. We can directly pass the `comments` array
    to the template and loop over the post, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We wrapped the calling of `model.getPage` in a function so that we can fire
    it again once a new comment is added.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small update in the template needed to display the posts below the
    form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Managing events attached to a particular page
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last feature that we will add in this chapter is the events attached to
    some of the created pages. So far, we have comments that are actually normal posts
    kept in the `content` collection. We will extend the implementation and create
    another type of post. These posts will still have a `pageId` property so that
    they are different from the feed's posts. However, we will introduce an `eventDate`
    variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'In the frontend, we need a new URL. We should keep the same pattern that contains
    the ID of the page. This is important because we want to display the events in
    the right place and we don''t want to mix them with the list of the pages. Here
    is the new route registration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The template of the `Pages` controller should surely be changed. We need to
    support two views. The first one shows a form and comments, and the second one
    shows a form and a list of events. The `showEvents` variable will tell us which
    variant to render:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In order to switch between the views, we added two additional links. While we
    are checking the comments, we will see **View events**, and when we jump to the
    events, we will see **View comments**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The `controllers/Pages.js` file needs a solid update, too. Most importantly,
    we need to add a handler of the `add-event` event that comes from the template.
    It is fired when the user presses the button in the new event form. It looks like
    this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is similar to adding a comment, but for the additional `eventDate` property.
    It should also be set as a property of the object that goes to the `content` collection:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another change in the same frontend controller is with regard to showing the
    list of events (posts) in the template. When we get the title and description
    of the page, we know that we will receive a `comments` property. The backend will
    be updated in a minute, but we will assume that we will also have an `events`
    property. So, we will simply send the array to the template:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the backend, we have already fetched the records from the `content` collection
    that belongs to the current page. The problem is that the records are now a mixture
    of comments and events. The `getComments` function that we added in the previous
    section can be changed to `getPageItems`, and the implementation of it basically
    looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We formed the two different `events` and `comments` arrays. Based on the existence
    of `eventDate`, we will fill them with records. Just before executing the callback,
    we will sort the events by date, showing the earlier event first. The last thing
    that we will do is use `getPageItem`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们形成了两个不同的`events`和`comments`数组。根据`eventDate`的存在，我们将用记录填充它们。在执行回调之前，我们将按日期对事件进行排序，先显示较早的事件。我们要做的最后一件事是使用`getPageItem`：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we extended our social network. Every customer is now able
    to create their own pages and leave comments there or create events related to
    the page. A bunch of new components were added to our architecture. We successfully
    reused the code from the previous chapters, which is good if we want to keep our
    codebase small.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了我们的社交网络。现在每个客户都能够创建自己的页面，在那里留下评论或创建与页面相关的活动。我们的架构中添加了许多新组件。我们成功地重用了前几章的代码，这对于保持我们的代码库较小是很好的。
- en: In [Chapter 9](part0063.xhtml#aid-1S2JE1 "Chapter 9. Tagging, Sharing, and Liking"),
    *Tagging, Sharing, and Liking*, we will discuss the tagging, liking, and sharing
    of posts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0063.xhtml#aid-1S2JE1 "第9章。标记、分享和点赞")*标记、分享和点赞*中，我们将讨论帖子的标记、点赞和分享。
