- en: Chapter 1. Instant Android Systems Development How-to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Instant Android Systems Development How-to*. This book will equip
    you with all the necessary skills needed to become a successful Android systems
    programmer. We will cover a range of topics right from building the source code
    to flashing actual Android phones. The book assumes familiarity and an understanding
    of the Android software development kit. The reader is requested to practically
    perform all the steps in each recipe to gain a better understanding of how to
    develop for the Android operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Building Android (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe sets up your build computer and instructs you on how to download
    and build the Android operating system from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need Ubuntu 10.04 LTS or later (Mac OS X is also supported by the build
    system, but we will be using Ubuntu for this book). This is the supported build
    operating system, and the one for which you will get the most help from the online
    community. In my examples, I use Ubuntu 11.04, which is also reasonably well supported.
    You need approximately 6 GB of free space for the Android code files. For a complete
    build, you need 25 GB of free space. If you are using Linux in a virtual machine,
    make sure the RAM or the swap size is at least 16 GB, and you have 30 GB of disk
    space to complete the build.
  prefs: []
  type: TYPE_NORMAL
- en: As of Android Versions 2.3 (Gingerbread) and later, building the system is only
    possible on 64-bit computers. Using 32-bit machines is still possible if you work
    with Froyo (Android 2.2). However, you can still build later versions on a 32-bit
    computer using a few "hacks" on the build scripts that I will describe later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps outline the process needed to set up a build environment
    and compile the Android framework and kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a build environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the Android framework sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Android framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, your (Ubuntu Linux) build computer needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Git 1.7 or newer (GIT is a source code management tool), JDK 6 to build Gingerbread
    and later versions, or JDK 5 to build Froyo and older versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2.5 – 2.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Make 3.81 – 3.82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first set up the build environment with the help of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the following steps are targeted towards 64-bit Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the required JDK by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the required library dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[OPTIONAL]. On Ubuntu 10.10, a symlink is not created between `libGL.so.1`
    and `libGL.so`, which sometimes causes the build process to fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[OPTIONAL] On Ubuntu 11.10, an extra dependency is required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will download the Android sources from Google's repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install repo. Make sure you have a `/bin` directory and that it exists in your
    `PATH` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repo is a python script used to download the Android sources, among other tasks.
    It is designed to work on top of GIT.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize repo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, you need to decide the branch of the Android source you wish to
    download. If you wish to make use of Gerrit, which is the source code reviewing
    tool used, make sure you have a live Google mail address. You will be prompted
    to use this e-mail address when repo initializes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a working directory on your local machine. We will call this `android_src`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will initialize repo to download the "master" branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will initialize repo to download the Gingerbread 2.3.4
    branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-b` switch is used to specify the branch you wish to download.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once repo is configured, we are ready to obtain the source files. The format
    of the command is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-jX` is optional, and is used for parallel fetch.'
  prefs: []
  type: TYPE_NORMAL
- en: The following command will sync all the necessary source files for the Android
    framework. Note that these steps are only to download the Android framework files.
    Kernel download is a separate process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code access is anonymous, that is, you do not need to be registered
    with Google to be able to download the source code. The servers allocate a fixed
    quota to each IP address that accesses the source code. This is to protect the
    servers against excessive download traffic. If you happen to be behind a NAT and
    share an IP address with others, who also wish to download the code, you may encounter
    error messages from the source code servers warning about excessive usage. In
    this case, you can solve the problem with authenticated access. In this method,
    you get a separate quota based on your user ID, generated by the password generator
    system. The password generator and associated instructions are available at [https://android.googlesource.com/new-password](https://android.googlesource.com/new-password).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have obtained a user ID/password and set up your system appropriately,
    you can force authentication by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `/a/` in the URI. This indicates authenticated access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Proxy issues**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are downloading from behind a proxy, set the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export HTTP_PROXY=http://<proxy_user_id>:<proxy_password>@<proxy_server>:<proxy_port>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export HTTPS_PROXY=http://<proxy_user_id>:<proxy_password>@<proxy_server>:<proxy_port>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we describe the steps needed to build the Android framework sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the terminal environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Certain build-time tools need to be included in your current terminal environment.
    So, navigate to your source directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The sources can be built for various targets. Each target descriptor has the
    `BUILD-BUILDTYPE` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUILD`: Refers to a specific combination of the source code for a certain
    device. For example, `full_maguro` targets Galaxy Nexus or `generic` targets the
    emulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILDTYPE`: This can be one of the following three values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: Suitable for production builds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdebug`: Similar to `user`, with with root access in ADB for easier debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eng`: Development build only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be building for the emulator in our current example. Issue the following
    command to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually build the code, we will use `make`. The format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `X` indicates the number of parallel builds. The usual rule is: `X` is
    the number of CPU cores + 2.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an experimental formula, and the reader should feel free to test it
    with different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must wait till the build is complete. Depending on your system''s specifications,
    this can take anywhere between 20 minutes and 1 hour. At the end of a successful
    build, the output looks similar to the following (note that this may vary depending
    on your target):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A better check for a successful build is to examine the newly created files
    inside the following directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build produces a few main files inside `android_src/out/target/product/<DEVICE>/`,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system.img`: The system image file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot.img`: Contains the kernel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recovery.img`: Contains code for recovery partition of the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of an emulator build, the preceding files will appear at `android_src/out/target/product/generic/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test our build simply by issuing the `emulator` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This launches an Android emulator, as shown in the following screenshot, running
    the code we''ve just built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9762OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code we''ve downloaded contains prebuilt Linux kernels for each supported
    target. If you only wish to change the framework files, you can use the prebuilt
    kernels, which are automatically included in the build images. If you are making
    specific changes to the kernel, you will have to obtain a specific kernel and
    build it separately (shown here), which is explained later:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Faster Builds – CCACHE`'
  prefs: []
  type: TYPE_NORMAL
- en: The framework code contains C language and Java code. The majority of the C
    language code exists as shared objects that are built during the build process.
    If you issue the `make clean` command, which deletes all the built code (simply
    deleting the build output directory has the same effect as well) and then rebuild,
    it will take a significant amount of time. If no changes were made to these shared
    libraries, the build time can be sped up with `CCACHE`, which is a compiler cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of the source directory `android_src/`, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To set a cache size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This reserves a cache size of 50 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To watch how the cache is used during the build process, use the following
    command (navigate to your source directory in another terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we will obtain the sources and build the `goldfish` emulator kernel.
    Building kernels for devices is done in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`goldfish` is the name of the kernel modified for the Android QEMU-based emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the kernel sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a subdirectory of `android_src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will clone `goldfish.git` into a folder named `goldfish` (created automatically)
    and then list the remote branches available. The output should look like the following
    (this is seen after the execution of the `git` branch):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the following command, we notice `origin/android-goldfish-2.6.29`,
    which is the kernel we wish to obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will obtain the kernel code:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the build environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to initialize the terminal environment by updating the system `PATH`
    variable to point to a cross compiler which will be used to compile the Linux
    kernel. This cross compiler is already available as a prebuilt binary distributed
    with the Android framework sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run an emulator (you may choose to run the emulator with the system image that
    we just built earlier. We need this to obtain the kernel configuration file. Instead
    of manually configuring it, we choose to pull the config file of a running kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure ADB is still in your path. It will be in your `PATH` variable if you
    haven't closed the terminal window since building the framework code, otherwise
    execute the following steps sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: (Note that you have to change directory to `ANDROID_SRC` to execute the following
    command).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will copy the confi g fi le of the running kernel into
    our kernel build tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the compilation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the following comes up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Enter `y` as the answer. This is some additional Android-specific configuration
    needed for the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to wait till the build is complete. The final lines of the build
    output should look like the following (note that this can change depending on
    your target):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As the last line states, the new `zImage` is available inside `arch/arm/boot/`.
  prefs: []
  type: TYPE_NORMAL
- en: To test it, we boot the emulator with this newly built image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy `zImage` to an appropriate directory. I just copied it to `android_src/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the emulator is indeed running our kernel, use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is our custom kernel, since we observe the custom build string (`earlence@earlence-Satellite-L650`)
    present as well as the time of the compilation. The build string will be the name
    of your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Once the emulator has booted up, you will see a window similar to the following:![How
    to do it...](img/9762OS_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following are the steps required to build the framework on a 32-bit system:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the following simple changes to build Gingerbread on 32-bit Ubuntu. Note
    that these steps assume that you have set up the system for a Froyo build. Assuming
    a Froyo build computer setup, the following steps guide you on incrementally making
    changes such that Gingerbread and later builds are possible. To set up for Froyo,
    please follow the steps explained at [http://source.android.com/source/initializing.html](http://source.android.com/source/initializing.html).
    In `build/core/main.mk`, change `ifneq (64,$(findstring 64,$(build_arch)))` to
    `ifneq (i686,$(findstring i686,$(build_arch)))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there are two changes on that line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`external/clearsilver/cgi/Android.mk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external/clearsilver/java-jni/Android.mk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external/clearsilver/util/Android.mk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external/clearsilver/cs/Android.mk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the following packages (in addition to the packages you must have installed
    for the Froyo build):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Java 1.6 using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android build system is a combination of several standard tools and custom
    wrappers. Repo is one such wrapper script that takes care of GIT operations and
    makes it easier for us to work with the Android sources.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel trees are maintained separately from the framework source trees.
    Hence, if you need to make customizations to a particular kernel, you will have
    to download and build it separately. The keen reader may be wondering how we are
    able to run the emulator if we never built a kernel in when we just compiled the
    framework. Android framework sources include prebuilt binaries for certain targets.
    These binaries are located in the `/prebuilt` directory under the framework source
    root directory.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel build process is more or less the same as building kernels for desktop
    systems. There are only a few Android-specific compilation switches, which we
    have shown to be easily configurable given an existing configuration file for
    the intended target.
  prefs: []
  type: TYPE_NORMAL
- en: The sources consist of C/C++ and Java code. The framework does not include the
    kernel sources, as these are maintained in a separate GIT tree. In the next recipe,
    we will explain the framework code organization. It is important to understand
    how and where to make changes while developing custom builds.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the source structure (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we analyze the source structure of the framework sources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to use a suitable code editor/viewer. I usually make use of gedit with
    several code-related options enabled. Some people prefer to use vi, emacs, or
    Eclipse. Use whatever you are comfortable with to view the sources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you read the following table, refer to the directories of your Android source
    copy and feel free to explore the subdirectories. The top level folders are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All folders are relative to the Android source root, unless specified otherwise.
    Also note that the source structure can and will change with the addition of new
    folders or subfolders in subsequent Android versions. This description is for
    Gingerbread.
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/bionic/` | This contains the minimal libc (standard C library
    subset) implementation by Google, specifically for Android. It contains the sources
    for libm, libstdc++, and the dynamic linking library in addition to the linker.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/bootable/` | Includes a bootloader example. It also contains
    the code for the recovery environment. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/build/` | Contains all the build scripts used to build and maintain
    an Android framework source distribution. Includes the `envsetup.h` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/cts/` | Contains test cases to validate different parts of the
    framework. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/dalvik/` | Contains the Dalvik Virtual Machine sources, the
    `dx` tool (which converts Java `.class` files to `.dex` files), the dalvik support
    infrastructure, and the core class library implementation. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/development/` | Contains various dev time tools, scripts to
    build an SDK version and an NDK version. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/device/` | Device specific code such as Platform libraries,
    Add-ons, Hardware abstraction code, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/external/` | This is a local copy of an open source external
    project used internally in Android, such as SQLite and WebKit. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/frameworks/` | Contains all of the core framework code. |'
  prefs: []
  type: TYPE_TB
- en: '| `frameworks/base/core` | Contains all Android class library code. This is
    linked with each Android application. |'
  prefs: []
  type: TYPE_TB
- en: '| `frameworks/base/libs` | The most important item here is the `/binder` directory,
    which contains the sources for the binder IPC (inter-process communication) framework.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `frameworks/base/services` | Runtime System Servers. This represents the
    core functionality provided by Android to user apps. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/packages/` | Contains various user space Android applications,
    including the system apps such as Settings, Clock, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/prebuilt/` | Contains binaries of compilers, linkers for different
    host environments, and also prebuilt linux kernel images for Android. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANDROID_SRC/system/` | Contains several native code (`.C`) files that act
    as a minimal file system when the framework has booted up. These tools are needed
    for basic booting, operation, and debugging. |'
  prefs: []
  type: TYPE_TB
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of these subdirectories are part of the Android framework (note that they
    also contain code which is not exactly part of the framework such as the code
    under `/system`, but the definition of what exactly is in the framework can be
    relaxed a bit). During a system build, most of these are pulled together with
    the help of Android make files that exist in these directories. Creating new folders
    is not advised, since all vendor-specific code can be added under the `/vendor`
    directory (not shown earlier). This directory is created when you build for a
    particular device and it contains proprietary binaries among other things, such
    as vendor-specific framework code.
  prefs: []
  type: TYPE_NORMAL
- en: System booting sequence (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will go through the steps the system performs while booting
    up. Please refer to the files mentioned here as we walk you through the process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep your code editor/viewer ready, as we will open a lot of source files and
    inspect their contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major phases for the bootup of an Android Phone, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 1 – firmware start**: After power up, the firmware starts executing.
    This is usually a first-stage bootloader. Eventually, the kernel is loaded into
    RAM, and a jump is executed to the kernel entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 2 – kernel boot**: The kernel starts through its usual boot procedure.
    Memory and I/O is initialized. Interrupts are enabled, the process table is created,
    and eventually `init` is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 3 – user space framework boot**: There are three steps in this process.
    It begins with the execution of the `init.rc` script. This is located at `ANDROID_SRC/system/core/rootdir/init.rc`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we refer to a source extract, open up that file in your code viewer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we analyze the contents of the startup script, we observe that it sets up
    various environment variables—including `PATH` and `BOOTCLASSPATH`—that contain
    the paths to Java libraries needed by android processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, it creates a bunch of directories and sets up proper access rights.
    It also writes various configuration parameters for core services, such as `lowmemorykiller`,
    for example. It does this through the `/proc` kernel interface. Here is an example
    extract from `init.rc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android has a specific `init` language, which is described in detail at the
    following location in the Android sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Following this, there is a startup procedure for `Zygote` and `system_server`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Zygote` is the second `init` process from the point of view of the kernel,
    and the first Android process from the point of view of the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extract from `init.rc` is the initialization of `Zygote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, `app_process` is a binary that fires up the `zygote` process during system
    initialization. The last flag (`--start-system-server`) indicates that the `system_server`
    process is to be started. The `system_server` process encompasses all the core
    services provided by the Android platform. Examples are the `ActivityManagerService`,
    `LocationManagerService`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `app_process` binary invokes the functionality of `AndroidRuntime`, which
    is the entry point to start the dalvik environment; `AndroidRuntime.cpp` is located
    at `ANDROID_SRC/frameworks/base/core/jni/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app_process` binary''s code eventually comes down to the following in
    `AndroidRuntime.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This then calls `int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding line of code then loads the DVM into the native process, and results
    in a call to the `main` method of `ZygoteInit.java` located at `ANDROID_SRC/frameworks/base/core/java/com/android/internal/os`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ZygoteInit.main()` method is invoked, which causes the invocation of `startSystemServer`
    in that file. This method passes command-line arguments to the system server.
    An extract is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After starting the system server (details to follow), the `zygote` socket is
    set up and then the process runs in "select loop mode". In this mode, the process
    spins waiting for requests to start up new Android processes.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a look at the `system_server` startup process. The code for
    this process can be located at `frameworks/base/services/java/com/android/server/SystemServer.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods called during startup, one of which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This method is called by `zygote` (as we have seen earlier), and its job is
    to initialize native services which exist in the `android_servers` native object
    file. Examples of these native services are `SurfaceFlinger`, `AudioFlinger`,
    and so on. The `init1()` method is implemented at `ANDROID_SRC/frameworks/base/cmds/system_server/library/system_init.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init1()` method bootstraps `init2` via the following line in `system_init.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, the execution is back inside `SystemServer.java`, and `init2` is run. It
    creates a thread and then proceeds to start up system servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example start sequence for the servers is as follows (based on Gingerbread
    2.3.4_r1):'
  prefs: []
  type: TYPE_NORMAL
- en: Entropy Service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activity Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Telephony Registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Account Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Content Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This code can be seen inside the `run()` method of `SystemServer.java`. Once
    the `ActivityManagerService` class is started (and boot is completed), the first
    few Android applications are started up, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zygote is forked every time a new android process is needed. So, when a user
    launches an application through the UI, zygote is forked and a process is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete booting system sequence is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/9762OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now take a look at some pointers on good and secure code style to be
    followed when writing code for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Secure coding guidelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adherence to secure coding practice is of vital importance when modifying the
    system. As a developer, it is your responsibility to ensure that you do not inadvertently
    make the system insecure by your changes. To aid you in this process, here are
    a few points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always use permission strings to protect functionality**: Whenever you add
    new functionalities to the system, protect the methods with a `checkPermission(...)`
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure modified code does not evade permission checks**: The framework code
    usually invokes the `checkPermission(...)` method before the functionality of
    a method is executed. When you modify such code, make sure no code paths are introduced
    which bypass the checks. Do this using local test cases. If test cases exist for
    the method you are modifying, execute them after making your changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read the security documentation in the code**: Many system services—for example,
    `PackageManagerService.java`—have internal documentation in the form of comments.
    Just follow these instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document your newly added code**: If there are specific security guidelines
    to be followed if someone modifies your code, mention these clearly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic interface file (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will apply previously learned concepts, such as working with the build system,
    the Android startup process, and the common Android systems design patterns, to
    build a complete working system with a custom system service. In our example,
    we will create a simple service to implement a small hashing function. We will
    then add this service to the startup process. As stated in the recipe on Common
    Design patterns, a system service is a long running task that implements some
    functionality such as providing the device's GPS co-ordinates, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The interface file is written in **Android Interface Definition Language** (**AIDL**).
    The interface represents the public remote interface for the service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will write the code at `ANDROID_SRC/frameworks/base/core/java/android/os/packt`.
    The code is written at this location because it follows the conventions of Android
    systems coding and, more importantly, the build system is designed to automatically
    pick up files from these pre-known locations. Hence, to avoid modifications to
    the build system, we write our code at standard locations. Another reason is that
    since we are writing framework-level extensions, they have to be tightly integrated
    with the framework, and the above location is where all such code is written.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `packt` under `/os`. This helps us to better organize
    the code and easily distinguish custom code from framework code. This is important
    since you are modifying an already tested open source system. Simply due to the
    sheer size of Android, making indiscriminate changes to the code can introduce
    really hard-to-find bugs. Hence, having a clear separation between newly added
    code and framework code is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code represents the Android interface definition of the system
    service. It specifies the methods that are exposed by the service for use by clients.
  prefs: []
  type: TYPE_NORMAL
- en: Our example exposes a single method named `getMD5(String)` that calculates the
    MD5 hash for the input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following code file as `IPacktCrypto.aidl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We have to communicate this new file to the build system. This is done by adding
    the following line to the `LOCAL_SRC_FILES` entry in the `Android.mk` file located
    at `ANDROID_SRC/frameworks/base`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to the `LOCAL_SRC_FILES` directive. The last few lines should look like
    the following (GingerBread 2.3.4_r1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have specified our newly added interface definition file. Inclusion
    of the filename here results in the invocation of the AIDL compiler on the file
    to generate the proxy and stub classes (the proxy/stub classes contain marshalling
    code).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proxy/stub marshalling code is needed because the system server runs in its
    own process. Thus, to invoke its functions from other processes, you need an intermediate
    layer that marshals calls from one process to another. In case of Android, generated
    stub/proxy classes constitute this layer.
  prefs: []
  type: TYPE_NORMAL
- en: The AIDL file has to be compiled by the build system with the help of the AIDL
    compiler. Therefore, we list the name of our file towards the end of the existing
    framework files in the make file. When the system is being built, AIDL will be
    invoked on `IPacktCrypto.aidl`, and will result in the generation of proxy and
    stub classes. These classes are generated at `android_src/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a system service skeleton (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create the outline code of our custom system service.
    This will help us in understanding the basic mechanics and components of system
    services. To refresh your memory, a system service is a long running task that
    provides useful functionalities to Android applications. An example is the GPS
    services that interface with the GPS hardware and provide services such as proximity
    alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add our system server code to `ANDROID_SRC/frameworks/base/services/java/com/android`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `packt` at the preceding location. Inside that directory,
    create a file named `PacktCrypto.java`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the following code and save it as `PacktCrypto.java`. This is the main
    system service class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The following method implements the functionality of the system service. You
    may have noticed that the method name and signature is identical to the one specified
    in the AIDL file. This is crucial as it has to match for the correct marshalling
    code to be generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block represents the system service. It extends `IPacktCrypto.Stub`,
    which is a stub class that will be generated by the AIDL compiler when it is run
    on the `IPacktCrypto.aidl` file. We use a singleton pattern to instantiate the
    class to ensure that only one object of `PacktCrypto` exists in the system. We
    need to ensure this, as only one service will be entered into the service directory.
    The code also illustrates various other best practices. For example, the use of
    a log tag and the singleton pattern of service instantiation. These are common
    coding styles for system services.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have created an interface definition for our service, created
    methods to obtain a reference to the service, and also we have implemented the
    functionality provided by the service, that is, the hashing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run a test build to make sure everything compiles fine. Open up
    a terminal emulator and initiate a build for the emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, proxy classes represent the code component that executes on the
    client side of a remote request. Likewise, stubs execute on the server side. Therefore,
    our system server extends `IPacktCrypto.Stub`, which was generated during the
    build process from the `IPacktCrypto.aidl` file. We also have to implement the
    `getMD5()` interface method as it will provide the required functionality to the
    client. We choose to utilize the singleton pattern for our service to guarantee
    that only one object of the service exists in the system. This makes sense, since
    only one copy of the system service may exist in the service directory.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom service to the SystemServer process (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to register our service with the Android system and create an object.
    The Service Manager is a component that maintains a mapping of the service name
    and the associated service object. Processes invoke the Service Manager to obtain
    a reference to the system server by name. The method invoked to obtain a reference
    to a service object is `ServiceManager.getService(String)`. You can think of the
    Service Manager as a directory service that is available to service consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add our custom server to `SystemServer.java` located at `ANDROID_SRC/frameworks/base/services/java/com/android/server`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code represents modifications you need to make to the `SystemServer.java`
    file. Locate the `run()` method and add the following lines at an appropriate
    location. For the purpose of illustration, we choose to add this after all services
    have been started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding code modification obtains a reference to an object of type `PacktCrypto`.
    It then adds that object to the `ServiceManager` class, which, if you recall,
    is a directory service for all system services. It adds the `PacktCrypto` object
    to the directory by invoking the `addService()` method that takes as arguments
    a string service identifier and the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the code fragment, we must create an object of `PacktCrypto` and add it to
    the Service Manager directory with a string name. We choose `PacktCryptoService`
    for our example. At this stage, our custom server will be created and registered
    with the Service Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the PacktCrypto service (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, we are ready to test the custom service (`PacktCrypto`) which
    provides a hashing functionality to clients. Therefore, we will write a small
    test case inside the `SystemServer` process itself. This case is executed after
    the custom server has started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write the following test code inside `SystemServer.java` itself after the location
    where you created the service, that is, the location where changes were made in
    the *Adding a custom service to the SystemServer process* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following lines of codes are a few lines added to `SystemServer.java`.
    Add it at a location after object creation of the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After you have added the code, run a make and then start the emulator (for steps
    on how to do this, refer to the steps described in the first recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output in logcat should look like the following (after applying the appropriate
    filters to the log output). For example, if we use the following logging command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding code uses an instance of `IPacktCrypto` to store a reference of
    `PacktCrypto` that is obtained from the Service Manager. We then invoke the `getMD5()`
    method, passing in a test string. We then print the output. Since this is a cross-process
    call, a `RemoteException` can occur.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Android system partitions (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Android phone contains a few basic partitions along with other supporting
    partitions. This knowledge is vital to understanding how and where code is flashed
    to devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On our test device—Samsung Galaxy Nexus (or emulator)—we can view these partitions
    with the following command executed inside an adb shell. To obtain a shell on
    the device, you should connect the device via USB and you should make sure that
    the **USB Debugging** option is enabled (located at **Settings** | **Developer
    Options**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Jellybean or higher, the option is hidden, so you need to go
    to **Settings** | **About Phone** and keep tapping on the build number until a
    Toast pops up saying that you are now a developer. The **Developer Options** will
    appear at the usual location.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to actually obtain a shell, while the device is connected, fire up
    a terminal and type in `adb shell` and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, Linux does not detect the Android device, and in these cases, you
    need to edit the USB rules file. Since this is not a systems development issue
    and is commonly encountered by SDK developers, we will not detail the steps here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following command in a terminal with Samsung Galaxy Nexus connected
    and with debugging enabled. The following output is generated when we list the
    device''s partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, on the Nexus S and Nexus One device, we can view the partitions
    mounted with the command. The following command lists the contents of the `mtd`
    proc file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is observed when the same command is executed on Nexus
    One:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the output you see for your device may differ slightly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main thing to notice here is the existence of a few common partitions which
    are important to flashing new software. The following are major partitions on
    most Android devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/boot`: This contains the kernel image and the associated RAM disk. This is
    executed by the bootloader during the startup process. Any newly built kernel
    is written to this partition. The phone will not boot if this partition is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system`: This contains the Android framework and the related system applications.
    During system operation, this is mounted as read-only so that critical system
    files are never modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/recovery`: Is an alternative boot partition used to boot the device into
    recovery mode. The recovery code is located at `ANDROID_SRC/bootable/recovery`.
    There are many custom recovery firmware images available. A notable example is
    `ClockWorkMod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three partitions just mentioned are the ones involved in flashing a new
    build of Android on to a device. In addition to these, there are a few other partitions
    that exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/data`: This contains user data and is sometimes called the user-data partition.
    All user-installed applications, settings, and personal data are stored in this
    partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cache`: Will contain frequently accessed applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard`: This is the SD card attached to the phone. It is not a partition
    on the internal device memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling for a specific device (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device-specific binaries are flashed to the various partitions just described.
    The framework needs to be compiled for a specific target. The target represents
    the device to which you want to flash the binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Build variants: The build system provides several types of builds. These builds
    result in minor changes to the final binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: '`engineering` (`eng`): Is the default option. Plain make defaults to this.
    Includes all modules tagged `eng`, `user`, `debug`, and `userdebug`. ADB is enabled
    and will run commands as root user.'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: This is intended for the final production build. ADB is disabled and
    will not run commands as the root user.'
  prefs: []
  type: TYPE_NORMAL
- en: '`userdebug`: Basically, the same as `user`, but the system is debuggable and
    ADB is enabled by default.'
  prefs: []
  type: TYPE_NORMAL
- en: All of these tags are assigned to projects in the `Android.mk` file. If you
    open up any of these files, it is mentioned with the help of the `LOCAL_MODULE_TAGS`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to your Android source directory and include the build environment
    as usual. (`source build/envsetup.sh`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To obtain a list of available targets supported by the source version you are
    working with, use the `lunch` command in a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Before you initiate a build for a particular target, you need to obtain the
    proprietary binaries for the phone and unzip them into your source directory.
    Usually, an agreement and unzipping script accompany the binaries. After scrolling
    through the agreement, type `I AGREE` and press *Enter*. The required files will
    be unzipped to the correct location in the source directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of downloading the Orientation Sensor for Nexus S, Build
    GRJ22:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://developers.google.com/android/nexus/drivers#crespogrj22](https://developers.google.com/android/nexus/drivers#crespogrj22).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the ZIP file for Orientation Sensor and place it in the Android sources
    directory on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip it to the current directory. A file called `extract-akm-crespo.sh` will
    be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute it and scroll down the agreement. At the end, type in `I AGREE`. Then
    the binaries will be extracted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow a similar procedure for the other files of your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The binaries for the Nexus One have to be extracted from the device itself.
    In the source directory, `ANDROID_SRC/device/htc/passion`, a shell script exists
    to pull the needed binaries directly from the device. Connect your Nexus One to
    a computer and over adb execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./extract-files.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: This will pull various proprietary binaries and copy them to the appropriate
    location in the source directory (`ANDROID_SRC/vendor/`).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lunch` command is part of the build environment. It provides a list of
    available targets you can build with your current source distribution. In all
    the distributions, the simulator and `generic-eng` targets are available. Simulator
    was used before the QEMU emulator became available. This target is now deprecated
    and should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: We can build the code for a generic target (the emulator), or a simulator target
    (currently outdated, this existed when the QEMU emulator was not ready). The more
    interesting options are `full_passion-userdebug` and `full_crespo-userbedug`.
    The first one represents the Google Nexus One device. Passion is the code name
    for that device. Similarly, the latter represents the Google Nexus S.
  prefs: []
  type: TYPE_NORMAL
- en: Google Nexus One – Passion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Nexus S – Crespo + crespo4g
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Galaxy Nexus – Maguro + Toro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, based on your target device, you can select the desired build target
    and execute a make.
  prefs: []
  type: TYPE_NORMAL
- en: Although Android is an open source project, certain hardware drivers are closed
    source. These include the graphics drivers, the WiFi chipset drivers on certain
    models, orientation sensors, the radio baseband software, and camera drivers.
    Therefore, if you create a build just with the source downloaded from the Android
    GIT tree, certain phone functions will not work. For example, if the correct radio
    image was not included, you will not be able to make and receive phone calls.
    However, these drivers are made available in binary format for download from [https://developers.google.com/android/nexus/drivers](https://developers.google.com/android/nexus/drivers).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the event that something went wrong with your custom code and the device
    becomes unusable, you will need to restore it to a working state. Google provides
    Factory images for its developer devices. They contain the usual `system.img`,
    `boot.img`, and `recovery.img` images that will restore the device to its factory
    state. These are available at [https://developers.google.com/android/nexus/images](https://developers.google.com/android/nexus/images).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The files for the Nexus One are not available at that location, and you will
    need to obtain it from an alternate location, such as Cyanogen Mod or modaco.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need to execute the following command after including proprietary binaries
    to make sure they are included in the generated software images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Flashing with Fastboot (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fastboot is a tool and a protocol used to communicate with bootloaders. It exists
    as a binary and gets included in your path when you work with the Android sources.
    Fastboot is also a part of the standard SDK (under `platform-tools`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can flash any software, you need to boot the device into fastboot
    mode. There are two ways of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using key combinations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, power off the phone completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Nexus One) Passion: Press and hold the trackball, then press **Power**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Nexus S) Crespo: Press and hold **Volume Up**, then press and hold **Power**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Galaxy Nexus) Maguro: Press and hold both **Volume Up** and **Volume Down**,
    then press and hold **Power**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using ADB commands: The following command reboots the device into recovery
    mode. This has the same effect as the key combinations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlock the bootloader: You can flash software only if the bootloader allows
    it. We need to unlock the bootloader with the following command once the device
    is in fastboot mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to back up whatever files/data you need from the device, since this
    operation erases all device memory.
  prefs: []
  type: TYPE_NORMAL
- en: And follow the onscreen instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Nexus One, this operation voids the warranty.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Galaxy Nexus and Nexus S devices, you can lock the bootloader via the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fastboot oem lock`'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To flash, you need to ensure you are connected to the device in fastboot mode.
    The following command will display the device''s serial number on the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute the following in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The device will boot into the custom operation system. For additional information
    on different fastboot commands and the flashing process in general, refer to [http://source.android.com/source/building-devices.html](http://source.android.com/source/building-devices.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After a successful build, the required system images will be available at `ANDROID_SRC/target/out/product/<NAME>/`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `<NAME>` refers to the target. For the emulator, it is `generic`, similarly,
    for the Nexus S, it will be `crespo`. The available images will be `system.img`,
    `boot.img`, and `recovery.img`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fastboot is a protocol to communicate with device bootloaders. This was designed
    such that flashing can be independent of the underlying bootloader. The process
    of unlocking the bootloader is available on developer devices. This is a recent
    feature starting with Nexus S. Relocking bootloaders allows you to lock the bootloader
    preventing the installation of new firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Google developer phones can be loaded with custom software that we have been
    building in the previous recipes (Google developer phones are special devices
    designed for platform developers and not for the typical consumer). Firmware can
    be written to these devices' flash memory as the bootloader is unlocked. Consumer
    devices normally lock their bootloaders and flashing is not possible. The workflow
    for all three of the developer phones (Nexus One, Nexus S, and Galaxy Nexus) is,
    for the most part, identical. Fastboot is a protocol and a flashing tool used
    to write new software images to the device.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the fastboot protocol, refer `ANDROID_SRC/bootable/bootloader/legacy/fastboot_protocol.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a system image with your custom server for Nexus S (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to build a custom system image. We will re-use the previously
    written code and test it on an actual device. Therefore, you will need to build
    the custom system server code and flash it to the Nexus S device in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to the `ANDROID_SRC` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to the proprietary binary page for the Nexus S and download all files
    for the GRJ22 build. Unzip and extract them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lunch the `full_crespo-userdebug` target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a full make. Once successful, navigate to `ANDROID_SRC/target/out/product/crespo/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flash `system.img`, `boot.img`, and `recovery.img` as described above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reboot the phone. You can use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code images are cross compiled for an ARM architecture and the proprietary
    binaries are included in them. The appropriate prebuilt kernel image is picked
    up and included in `boot.img` during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipes, we created a custom service that can be invoked by
    obtaining a reference directly to the service via the Service Manager. In this
    recipe, we will create a class library that abstracts much of that code away into
    a clean interface. The advantage of creating a class library is that it acts like
    an SDK-API for our custom service. The example we go through here will also guide
    us in adding code to the Android class library. The code is generally independent
    of system services and can be used for other purposes as well. An example of an
    Android class library is `android.app.Activity`, which is a commonly used class
    to represent Android activities. This class is part of the Android class library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the class library (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a class library which accesses our custom system
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a directory at `ANDROID_SRC/frameworks/base/core/java/android`. We will
    name it `packt`. Inside it, we have the following code file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to write a wrapper around `PacktCryptoService`, which provides us the
    MD5 creation functionality. The wrapper we write will be the class library. I
    chose to wrap a service call, as this pattern is followed by many of Android''s
    class libraries, that is, they wrap the service functionality. However, you are
    not restricted to using this type of wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we need to write the following code which wraps `PacktCryptoService`.
    Save it in a file named `PacktCryptoService.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run `make update-api`, since we have modified the public API of the system.
    Android maintains a list of interfaces, permissions, and methods in the XML files
    under `ANDROID_SRC/frameworks/base/api`. The notable file is `current.xml`. This
    file represents the interfaces, methods, and permissions that are part of the
    public API supported by Android. Since our custom class library is intended to
    be a part of the public API, we need to update `current.xml`. Hence, use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will do something slightly different to test our code. We
    will build our custom SDK. Building the SDK generates JAR files that contain the
    Android class library. For example, when using the SDK to build normal applications,
    there is the `android.jar` file located within our project hierarchy. This file
    is the SDK that provides Android framework classes. We need to build an updated
    `android.jar` file with our newly added class library. Note that the SDK does
    not need to include the services we add to the platform as these only exist on
    the Android OS. They are not needed for SDK-based development. To build a new
    SDK, issue the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This command builds the SDK. At the end of the build, the output should look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you open up `android-sdk_eng.earlence_linux-x86.zip` and examine its contents,
    you'll find that it's basically the same as a normal Android SDK. The difference
    is that we have built this with our custom code additions. Using this SDK, we
    can build an APK which uses the custom class library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the SDK ZIP file to some external location (external to `ANDROID_SRC`).
    Now run a normal build by issuing the `make` command as described in the earlier
    recipes. This will build system images that contain the custom system service.
    These system images are used to run an emulator on which we will test our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our class library simply obtains a reference to the custom server from the Service
    Manager. It then invokes the `getMD5()` method. The advantage of this is that
    we have a simpler and more uniform API to access our custom server. The other
    advantage is that it can be packaged into an SDK without the need to package the
    actual system service itself. This makes sense, since no system services are ever
    packaged in the SDK, only the APIs that access them are packaged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SDK build target is available with every source distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Android application against the custom SDK (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write an Android application that utilizes our custom SDK build in the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, I assume that you have already installed Eclipse and a functional
    Android SDK is installed and configured with the ADT Eclipse plugin. These steps
    are the same as those found on the Android Developer site ([http://developer.android.com/index.html](http://developer.android.com/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to make our custom SDK visible to the existing Android SDK. So, unzip
    the generated custom SDK. Inside, there will be the `platforms/android-2.3.4`
    directory. We are interested in the `android-2.3.4` directory. Rename it to `android-packt`
    and copy it into `ANDROID_SDK/platforms/`, where `ANDROID_SDK` is the path to
    your Android SDK installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to update the API level number, so as not to clash with an existing
    installation of the same API level. Inside `android-packt`, a file with the name
    `build.prop` exists. Change the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting ready](img/9762OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `-20` is an arbitrary number. This is needed to prevent clashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Eclipse and navigate to the SDK Manager. You should see something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/9762OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the plugin has detected a new installation of an SDK with an API
    level of `-20`, which is our custom SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now follow the usual steps to create a skeleton Android application. Be sure
    to select the correct target when prompted to do so. As shown in the following
    screenshot, API level `-20` has to be selected. This is our custom SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/9762OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can access our `PacktCrypto` class library just like any other Android
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following simple test activity. Save the following code in a file
    named `PacktTestActivity.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we simply create an object of type `PacktCrypto`, initialize
    it, and then call the `getMD5` method that calls into our custom system server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PacktCrypto` class library methods are available in the new SDK `framework.jar`
    file. This helps in compiling the application. When deployed to the emulator,
    the class library obtains a reference to the `PacktCrypto` service that is running
    on the system and provides its functionality to the Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the class library (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very simple recipe, which we use to verify that the class library
    works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already started an emulator with our custom system image (explained
    earlier), do so now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build the APK. Install it via the command line (`adb install`). The SDK will
    not detect the running emulator since the SDK we use is standard/unmodified, and
    hence will not understand the dummy API level `-20`. Therefore, a launch from
    Eclipse will not work. However, the installation procedure is no different from
    a normal app installation via the command line. As specified in the Android Developer
    documentation, an APK may be installed by specifying the `adb install` command
    with an APK filename. The output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/9762OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The emulator is running an image of the firmware that contains the `PacktCrypto`
    service. This was started at the system boot time. The class library simply obtains
    a copy of the service object through the Service Manager and invokes the `getMD5()`
    method. This is abstracted away in the class library which allows development
    of applications independently of code that runs on an actual system.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipes, our modifications have been tightly integrated with
    the platform code. In certain cases, such levels of integration may not be needed,
    but new features need to be added to the system. In such cases, a developer can
    add code to the framework in the form of a platform library. In this recipe, we
    will learn how to create a platform library and learn how to write an application
    which uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the platform library source code (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We write simple methods to use the **Data Encryption Standard** (**DES**) to
    encrypt and decrypt a string using an 8-byte password. Our encryption library
    is named `PacktPlatformLibrary`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this code is external to the framework and does not need to be tightly
    integrated with the system, we will place it in a separate directory called `/vendor`
    under `ANDROID_SRC`. Usually, inside this directory, vendor-specific files are
    added. Create `ANDROID_SRC/vendor/PacktVendor`. Inside that, include the following
    one-liner `Android.mk` file, so that subsequent make files are called during build.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of Android 4.0 and later, the platform library code can be placed under `ANDROID_SRC/device/`.
    However, the reader should note that this is not a fundamental change in the way
    platform libraries work and the concepts here are easily extended to later versions
    of the Android source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start out by writing a one-liner make file for the project. This file is
    saved as `Android.mk` and is the top-level make file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Under PacktVendor, create a directory named PacktPlatformLibrary. Inside this
    we will create the platform library and write its code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory named `java/packt/platformlibrary` under `PacktPlatformLibrary/`.
    This will hold the source code for the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the following code as `PacktPlatformLibrary.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method simply DES encrypts a string. You can replace the function
    with anything you like. The point of the example is to demonstrate a platform
    library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `decryptDES` performs the opposite function of `encryptDES`. You
    can again choose to replace this with a function of your choice. If you choose
    to do so, keep in mind that later files will have to be adjusted a bit based on
    the new functions. However, no change is needed in any of the build files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Android system requires that an XML file is to be created for every new
    platform library. Create an XML file at `ANDROID_SRC/vendor/PacktVendor/PacktPlatformLibrary/`.
    Save this XML file as `PacktPlatformLibrary.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need a make file to pull all the components together. Create an
    `Android.mk` file in the same directory as the preceding file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding file has three sections. The first compiles the java code for
    the library and creates a JAR file. The name of this JAR is specified in the `LOCAL_MODULE`
    tag. Next, if the project directory contains documentation, that is built. Finally,
    we need to ensure the XML file is added to `/system/etc/permissions/` in the system
    image. `LOCAL_MODULE_CLASS` is used to specify this. Now, we need to build the
    components. On a terminal, inside `ANDROID_SRC`, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will compile the java code, generate a signed JAR, and
    place it in `system/framework/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This will place the XML file at `/system/etc/permissions/`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The platform library has two main components. One is the library itself, which
    is written in Java or C, and is packaged into a JAR (with an optional shared object
    if native code is used). The second component is an XML file that declares the
    JAR to the system as a platform library. This component is important as it helps
    the system to identify the location of the platform library when it is needed
    for loading into an application.
  prefs: []
  type: TYPE_NORMAL
- en: The module class `ETC` specified in the make file for the XML file is used to
    place files into the `/system/etc` directory of the firmware image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the platform client (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the platform library created, we need to create an Android application
    that uses the library. To do this, we will create a new "System APK". A System
    APK is an Android application that lives in the Read-Only `/system` partition
    on the device, similar to applications such as settings and contacts. System applications
    live in `ANDROID_SRC/packages/apps`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a directory named `PacktLibraryClient` at that location. Inside, we write
    a small Android application that accesses the platform library and invokes a method.
  prefs: []
  type: TYPE_NORMAL
- en: Create the following file at `ANDROID_SRC/packages/apps/PacktLibraryClient/src/com/packtclient`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by writing the client file that will access our platform library.
    The following code is saved as `Client.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Like any other Android application, we need a manifest file, which is created
    at `ANDROID_SRC/packages/apps/PacktLibraryClient/`. The following code is saved
    in a file named `AndroidManifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The new addition here is the `<uses-library>` tag. Notice that we have to specify
    the name of our custom platform library to indicate to the runtime that it is
    to be loaded with our client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a make file at the same directory level as the preceding file.
    Save this make file as `Android.mk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the use of the `LOCAL_JAVA_LIBRARIES` tag that is used to specify the
    platform library against which we compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to build our client APK. In a terminal, execute the following
    command (assuming the terminal environment is properly set up; for instructions,
    refer to the first recipe of this book):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to build the system image for the emulator to test our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the following files are included in the system image. This is done
    by inspecting the contents of `installed-files.txt`, which is located at `ANDROID_SRC/out/target/product/generic/`
    in the case of an emulator build. Here, I have extracted the relevant contents
    from my copy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, all of the required pieces have been integrated into the system
    image. Start the emulator, and click on the `PlatformLibraryClient` application.
    Logcat should output something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The platform client is simply another Android application. The only difference
    here is that it is bundled with the system image and is installed at `/system/app`—the
    read-only partition.
  prefs: []
  type: TYPE_NORMAL
- en: The most important line in the make file for the application is the `LOCAL_JAVA_LIBRARIES`
    tag. This specifies that we will use the functionality of the platform client.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help clarify the concepts presented in this recipe, it is often helpful to
    visualize the project structure. In the following text, we pictorially depict
    what platform libraries look like in the Android sources.
  prefs: []
  type: TYPE_NORMAL
- en: Platform library project organization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most platform libraries are structured as shown in the next figure. As stated
    earlier, the top-level directory can change from `ANDROID_SRC/vendor` to `ANDROID_SRC/device/`
    if you move from Gingerbread development to Ice Cream Sandwich development.
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform library project organization](img/9762OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: System application project organization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System applications have the following structure within the Android Sources.
    This figure depicts the organization in terms of the `PacktLibraryClient` system
    application we just built, but the organization is similar to other system applications.
    The point to note here is that system applications live under `ANDROID_SRC/packages/apps`
    and for the most part, the directory structure is the same as a normal Android
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '![System application project organization](img/9762OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our previous system service contained only Java code; however, such services
    may also contain calls to native code. Developers may choose to use native code
    for a variety of reasons. The most common being speed over interpreted code and
    re-use of existing libraries. In the next recipe, we will show you how to use
    native functions inside our `PacktCrypto` system service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, before jumping to the next recipe, I assume that you are comfortable
    with JNI technology. If not, I recommend reading the excellent book: *The Java
    Native Interface: Programmer''s Guide and Specification* by Sheng Liang. ([http://www.amazon.com/Java-Native-Interface-Programmers-Specification/dp/0201325772](http://www.amazon.com/Java-Native-Interface-Programmers-Specification/dp/0201325772)).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the native method and registration with the JNI Onload event (Should
    know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The native methods for system servers are implemented at `ANDROID_SRC/frameworks/base/services/jni`.
    This directory contains an `Android.mk` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by implementing the native method in C code. In this example, I choose
    to implement the popular quick sort algorithm. Note that the file has to be named
    as per the naming conventions. This is simply the package name in reverse order,
    but with underscores instead of dots as delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: Fire up your favorite text/code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code in a file named `com_android_packt_PacktCrypto.cpp`;
    it contains the native method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the `onload.cpp` file. There are two locations where you need
    to make additions. The first is under the `namespace android {` block. There will
    be a list of registration functions, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add a line with our custom registration function. Add the following
    line inside the `namespace` block towards the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This is the registration function we've written in `com_android_packt_PacktCrypto.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second addition is inside `JNI_OnLoad` in the same file—`onload.cpp`. Add
    the following line towards the end of all the registration function calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to communicate to the build system that some new code has
    been added. Modify the `Android.mk` file (in the same directory as all the other
    files we''ve been modifying) by adding the following line towards the end of the
    `LOCAL_SRC_FILES` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the new tag would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The native methods we write have to be loaded and identified. The Android framework
    provides a function called `jniRegisterNativeMethods` that takes as input a method
    table and a fully qualified class name of the Java class that will call the native
    method. In this case, it is our `PacktCrypto` system service. The method table
    uses the JNI method descriptor notation to indicate the type of input/output parameters.
    It also includes a function pointer to the native method implementation. The `JNI_OnLoad`
    event is called whenever a native library is loaded into the virtual machine.
    At this point, we register our native methods, like other system servers. `NELEM`
    is a framework-provided macro to calculate the length of an array. It is defined
    as follows and is located inside the `frameworks/base/include/utils/misc.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Writing the Java driver (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test our native library, we need to write some Java code that will call the
    native function. I will re-use code from an earlier example, where we created
    and tested the `PacktCrypto` system service.
  prefs: []
  type: TYPE_NORMAL
- en: We need to call the native code from the Java-based `PacktCrypto` service. Hence,
    in this recipe, we will modify the `PacktCrypto` system service so that it can
    call a native method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up the `PacktCrypto.java` file that is located in the `services/java/com/android/packt`
    directory and change it by adding the following lines towards the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the `sort` method, I simply call the `sort()` method inside our existing
    `getMD5` method. I am doing this so that you can quickly test whether the native
    code works as expected without making too many changes. If you recall, we have
    already written a test harness for `getMD5` inside `SystemServer.java`. The first
    step is to modify the `PacktCrypto.java` file by adding the following lines towards
    the end of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a fragment of the `PacktCrypto.java` file that tests our native function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the following lines to the `getMD5` method towards the end, we will
    be able to quickly test our native code. The new version of `getMD5()` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Notice the call to `sort()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build our code. In a terminal, as usual, issue the `make` command.
    Once the build is complete, run the emulator and observe the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java code contains a native method definition. The framework loads the native
    code and during the `onload` event, our native implementation is loaded and registered.
    When `getMD5()` is called, our native code is executed and the output is visible
    on the logger.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how some of the most important core Android
    services are organized and how to make changes to these services. We will also
    learn how to secure our changes with custom permissions added to the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet infrastructure on Android requires discussion as its design is
    non-conventional as compared to other services such as the Location Manager service.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the ActivityManagerService class (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ActivityManagerService` class is probably one of the most important of
    all services that exist in an Android system. In this recipe, we will go through
    its major functions and highlight peculiarities of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ActivityManagerService.java` is the source file and is located at `ANDROID_SRC/frameworks/base/services/java/com/android/server/am`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open this file in a code editor of your choice. We will move through the `ActivityManagerService`
    file and understand its various components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Activity Manager extends a class known as `ActivityManagerNative`, which
    implements the binder protocol for remote invocation. This code is written manually
    like we've written in the recipe on using IPC with our system service code. This
    was done as the AIDL compiler did not exist the time the Activity Manager code
    was written by Google employees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the beginning of the file, there are various control variables for different
    aspects related to activities. One such variable is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This defines the maximum number of activities that can be in the stack. It means
    the maximum number of activities that could be running at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting variable is the duration the system waits for a process
    to be launched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'SDK developers will know that when using a broadcast receiver, the `onReceive()`
    method should finish fast. The timeout is governed by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: which is around `10` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down in the file, there is a handler which does the majority of the
    work that does not require immediate return. As you may know, Android has the
    concept of a handler, which basically is a mechanism to execute code in a separate
    thread and have it return results later. The handler is defined as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Some example tasks performed are the ANR dialogs, indicated by case `SHOW_NOT_RESPONDING_MSG`
    and the sending of broadcasts to registered receivers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other functionality is implemented as methods that return synchronously. An
    asynchronous return means that the results of a request are returned to the caller
    at a later time, and not immediately, like a synchronous call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is a separate section in the sources for permissions manipulation and
    verification. The only public entry point for permissions checking is the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: All permission checks that are executed in the system go through this one method.
    Hence it serves as a reliable checkpoint to understand what processes are doing
    with respect to protected data and operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following this, the Activity Manager has a group of methods that manage tasks
    by manipulating the activity stack. The stack is a data structure defined in the
    `ActivityStack.java` file in the same directory as the activity manager service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following method is executed when the system has completely booted and
    is ready to start launching user processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: There are separate sections managing services, content providers, and broadcasts.
    At the start of each section, a comment indicates what type of methods follow.
    Various API methods such as `registerReceiver`, `startActivity`, and `startService`
    are implemented by the `ActivityManagerService` class in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Activity Manager service is started early during the bootup process. At
    the end, when all the initialization tasks are complete, the `systemReady` method
    is executed and the system boot complete broadcast is fired. This method is called
    by the `SystemServer` service. It is used to notify the `ActivityManagerService`
    that the system is at a point where it is possible to start running third-party
    code. While the `ActivityManagerService` does not immediately do this, it gets
    itself ready when it receives the `systemReady` call.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you make changes to the `ActivityManagerService` class, make sure that
    you don't introduce code paths that make the service vulnerable or leak sensitive
    data to malicious applications. Always follow the principles of secure coding
    and protect your methods by permission checks. If you don't want third-party developers
    to access your functionality, assign a signature permission to that method. The
    keen reader will have noticed that the `ActivityManagerService` class is like
    any other system service and executes in the context of the `SystemServer` service.
    Hence, now you realize that your custom system service executes alongside such
    important services. Any bugs in your system service have the potential to bring
    down the whole framework. So be careful when writing such code!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom method to the Activity Manager service (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will guide you through the steps needed to introduce a custom
    permission and learn how to make use of it to protect a method we add to the Activity
    Manager service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will edit the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Filename | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ActivityManagerService.java` | `ANDROID_SRC/frameworks/base/services/java/com/android/server/am`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ActivityManagerNative.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ActivityManager.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IActivityManager.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AndroidManifest.xml` | `ANDROID_SRC/frameworks/base/core/res` |'
  prefs: []
  type: TYPE_TB
- en: '| `strings.xml` | `ANDROID_SRC/frameworks/base/core/res/res/values` |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin by adding a new transaction and method prototype to `IActivityManager.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is appended to `IActivityManager.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The number 118 is just 1 plus the last transaction number I have on my version
    of the source code. The ones you may see may differ. Use whatever number you see
    in your version and add one to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding lines basically set a transaction number for our method. Since
    the underlying binder driver uses these numbers to match which methods need to
    be performed when an IPC call is made, we set our method''s transaction number
    to be one plus the last transaction known. Depending on the source code version
    you are working with, the number written above may have to be increased. The logic
    is simply adding 1 to the last transaction number you see. The IPC method needs
    to throw a `RemoteException` since this is mandated by the Binder IPC protocol.
    We then create the public interface for this method. To do this, add the following
    lines to `ActivityManager.java`, towards the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple method that does nothing useful. The aim of this recipe
    is to help you understand the mechanics of adding a new method to the Activity
    Manager service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will implement the marshalling code for this method. The concept of
    marshalling is no different than other interprocess frameworks. The basic aim
    is to serialize complex structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `ActivityManagerNative.java`, we make two changes. The first is inside
    the `ActivityManagerProxy` class that is inside the file. The code is organized
    in a way such that the `ActivityManagerProxy` class is towards the end of the
    file. Therefore, we write our proxy implementation of `packtSensitiveMethod` towards
    the end of the `ActivityManagerNative.java` file inside the scope of the `ActivityManagerProxy`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is added to `ActivityManagerNative.java` towards the end.
    It is the `packtSensitiveMethod` proxy implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The second change is made in the `onTransact` method of the file. At the last
    `case` statement, we add our `case` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to implement this method. The following implementation is
    written inside `ActivityManagerService.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have written the check permission code to secure this method. In the next
    recipe, I will guide you through the process of introducing a custom permission
    into the framework.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android, the `ActivityManagerService` class executes within the context of
    the system server process. Hence, calls into it will be remote calls. Therefore,
    we have to make use of the Binder IPC mechanism. The `IActivityManager.java` file
    contains the set of remote calls exposed by the Activity Manager service. Hence,
    we add a new interface method `packtSensitiveMethod()` and a transaction constant
    `PACKT_TRANSACTION` that will correspond to this method.
  prefs: []
  type: TYPE_NORMAL
- en: '`ActivityManager.java` represents a class library that user applications use
    to access the functionality of the Activity Manager service. This is similar to
    the custom class library we added in the earlier recipe on creating custom class
    libraries. As I''ve stated before, our implementations follow the design guidelines
    used in the Android code. Therefore, you will see several existing parallels in
    the Android source code. This is just one of the many examples that exist. Hence,
    we add a shim method to that file that invokes the real method through a remote
    procedure call.'
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, the Activity Manager service was written before the AIDL
    compiler existed, therefore the proxies and stubs for all remote calls are implemented
    manually. Hence, we add marshalling code to `ActivityManagerNative.java`.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we still add the marshalling code manually. The answer is
    that even though the AIDL compiler is now available, the build process was never
    updated for the `ActivityManagerService` class to make use of the AIDL compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom permissions to the framework (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will add a custom permission to the framework so that only
    authorized processes may access and execute our newly added method to `ActivityManagerService`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `AndroidManifest.xml` file from the location specified in the preceding
    table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will edit the manifest to insert a new permission object. Just add these
    code lines to `AndroidManifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that you have to use string resources to specify the various text properties
    of a permission. These values are defined in `strings.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, open up the file (location given in the preceding table) and append
    the following code to `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we should ensure that everything compiles fine. First issue
    the following command as we have changed the public API by adding methods to `ActivityManager.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Next, issue a normal `make` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even the Android framework has a manifest file. This file contains permission
    definitions for all permissions that exist in the system. The `permission` tag
    requires you to specify a permission description among other parameters. The system
    uses these strings for user display. For example, the permission description parameter
    is shown to a user while installing the application which asks for the permission
    in question.
  prefs: []
  type: TYPE_NORMAL
- en: Using the custom method (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to test our newly added method. Therefore, we make use of the `PacktLibraryClient`
    application that we created in the *Writing the platform library source code*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up `Client.java` from the `PacktLibraryClient` application, which is located
    at `ANDROID_SRC/packages/apps/PacktLibraryClient/src/com/packtclient/`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code represents the client code that makes use of the newly added
    method and is saved in a file named `Client.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: I have just commented the earlier code and added a method to execute `packtSensitiveMethod`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run a full system make and start the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, the emulator may complain that the partition size is too small and
    it has to be resized. In this case, you can use the memory and partition size
    switches. (Note that this command will work only if you issue it in the same window
    in which Android was built. Otherwise, you will have to use the fully qualified
    paths and specify the full paths to the emulator images—kernel image, system image
    as well.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, emulator memory as 512 and partition-size as 1024.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the `PacktLibraryClient` application. Observe logcat. The output will
    be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'What went wrong here? On analyzing the logs, we notice that a security exception
    was thrown. So, our code works! The sensitive method is protected. But, if `PacktLibraryClient`
    is a legitimate application and needs access to `packtSensitiveMethod`, we need
    to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Grant it `PACKT_PERMISSION`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sign the APK with the platform certificate since the permission is a signature
    level permission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do this, edit the `AndroidManifest.xml` file of `PacktLibraryClient` by
    adding the following tag outside the `application` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit its `Android.mk` file by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will use a shortcut to quickly build the APK. In a terminal, navigate
    to the root of your android sources and use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This will build the APK, but won''t place it into the system image or push
    it into the emulator. To do this, we will remount the system partition as read/write
    and then push it manually. If you want to place it into the system image directly
    and have it rerun the emulator, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If you closed the emulator, start it again. Then drop into a shell via `adb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find out on which block device `/system` is mounted, use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Hence, `/system` is `mtd0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remount as read/write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Now exit the `adb` shell, and push the built APK. The APK will be available
    at `ANDROID_SRC/out/target/product/generic/system/app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following command will automatically reinstall the APK onto the emulator.
    Start the application again and observe the logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We see that everything has worked fine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application obtains a reference to the Activity Manager service. This reference
    is in the form of an `ActivityManager` object. The `packtSensitiveMethod` shim
    is executed in the client, which cause an RPC to be sent out to the Activity Manager
    service, which performs a permission check before executing the main body of the
    method. When our APK wasn't signed with the platform key and didn't include the
    correct `<uses-permission>` tag, this check failed and the application crashed.
    In the second instance, we made the appropriate changes and the permission check
    succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the PackageManagerService class (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Package Manager service is a central service in the Android system and is
    one of the most important. It manages all the packages in the system and is central
    to platform security. It maintains a mapping between user/group identifiers and
    higher-level permission strings. In this recipe, we will see how permissions are
    managed and granted by the Package Manager service. As you may know, the fundamental
    aspect of the Android Security Model is the permissions system. This system is
    managed by the `PackageManagerService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code of the Package Manager service is located at `ANDROID_SRC/frameworks/base/services/java/com/android/server/`.
    Open up the file named `PackageManagerService.java` in your favorite code editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Built-in permission UID mappings are stored on the filesystem at `/system/etc/permissions/platform.xml`.
    This is loaded into the Package Manager service into the following variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The service maintains user application permissions in the filesystem at `/data/system/packages.xml`.
    Fire up the emulator and drop into an `adb` shell. We will inspect the contents
    of the `packages.xml` file. Obtain a copy with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the file in a text editor and search for the term "packt":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Here we notice that `PacktLibraryClient` has been assigned a `userId` of `10010`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Package Manager service stores and manages all configuration data in XML
    files with proper Linux permissions on these files. Internally, the service makes
    use of XML pull parsers to read and process these files. This service is interrogated
    by other services, most notably the Activity Manager service, as to whether a
    package possesses a certain permission or not.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you make changes to this service, please rethink your design carefully
    and only if there is no other way to accomplish the task, run the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run these tests, run the following command in a terminal (as always, I assume
    you have set up a build environment by including `build/envsetup.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Then start the emulator and execute this in a terminal over ADB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally drop into an `adb` shell and execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The unit tests are part of the **Compatibility Test Suite** (**CTS**). The CTS
    is part of the Android compatibility program. The aim is to achieve standardization
    among Android vendor implementations. The interested reader is referred to an
    overview of the compatibility program at [http://source.android.com/compatibility/overview.html](http://source.android.com/compatibility/overview.html).
    Details on the CTS itself may be found at [http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Internet infrastructure (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes/applications access the network (WiFi-based or GSM-based networks)
    using network sockets. Java code makes use of the Apache Harmony socket implementation
    and native code uses standard bionic sockets that are identical to libc socket
    calls. There is no Internet service. In this recipe, we will analyze how the network
    is accessed and how these accesses are guarded.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look at a kernel source file in this recipe, so locate the kernel sources
    you had downloaded and built in the first recipe of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The code for network access in Java is implemented in the Apache Harmony library
    in `OSNetworkSystem.java` located at `ANDROID_SRC/libcore/luni/src/main/java/org/apache/harmony/luni/platform`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the final point before native socket calls are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to the kernel sources we downloaded and built in the introductory recipe
    of this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file `ANDROID_SRC/kernel_code/goldfish/goldfish/net/ipv4/af_inet.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we observe the following addition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: This function makes a check as to whether the process currently executing in
    a function call is part of the `AID_INET` group or not. For example, look at the
    function named `inet_create`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a call to `current_has_network()` and, if not, it returns `-EACCES`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OSNetworkSystem.java` file contains native methods that ultimately make
    use of libc socket calls to perform I/O on the network. System library calls eventually
    invoke system calls implemented in the kernel. On Android, the network calls were
    changed to only allow execution if the process currently executing the system
    call belongs to a particular group. That group is named `inet`.
  prefs: []
  type: TYPE_NORMAL
- en: When an application requests `android.permission.INTERNET`, and when it is about
    to be run, the Package Manager service notifies Zygote that the application is
    to be run as part of the `inet` group.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, the modified system calls verify that the process is running as a
    member of `inet` and the call succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: The `current_has_network()` function makes use of the function `in_egroup_p(gid_t)`
    to check the group identifier of the process executing it. An Android process
    runs as a member of this group only if it has been granted `android.permission.INTERNET`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system applications are installed on the system/read-only partition of
    an Android device. The applications are signed with the one of system certificates
    (There are four certificates: testkey, platform, shared, and media) and perform
    certain privileged tasks. Examples include the Contacts application and the Settings
    application. Sometimes, your design may require a change of these system applications.
    In the next recipe, we will learn the purpose of the most important system applications
    and learn how to compile changes made to them.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the functions of various system applications (Must know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for all system applications are located at `ANDROID_SRC/packages/`.
    In this recipe, we will learn the significance of the most important packages
    at this location.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to the `/packages` directory under `ANDROID_SRC/`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table summarizes the four top-level directories and the code
    they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory name | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Apps` | Contains code for Activity-based applications. Always contains a
    UI element. |'
  prefs: []
  type: TYPE_TB
- en: '| `Experimental` | Random tools maintained by Googlers. Contents may be archived
    without notice. |'
  prefs: []
  type: TYPE_TB
- en: '| `Inputmethods` | The sources for the three default IMEs (as per 2.3.4_r1),
    that is LatinIME, OpenWnn, and PinyinIME |'
  prefs: []
  type: TYPE_TB
- en: '| `Providers` | Code for all major content providers including Contacts and
    SMS/MMS |'
  prefs: []
  type: TYPE_TB
- en: '| `Wallpapers` | Code for wallpapers that ship with the open source system
    |'
  prefs: []
  type: TYPE_TB
- en: Now, we will learn the purpose of the most important directories under `Apps`
    and `Providers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Directories under `/Apps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory name | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Browser/` | The frontend of the Android browser |'
  prefs: []
  type: TYPE_TB
- en: '| `Camera/` | The camera app |'
  prefs: []
  type: TYPE_TB
- en: '| `Contacts/` | Frontend Contacts application |'
  prefs: []
  type: TYPE_TB
- en: '| `Gallery/` | Application that lets you view images and videos on your SD
    card |'
  prefs: []
  type: TYPE_TB
- en: '| `Launcher2/` | The default launcher screen |'
  prefs: []
  type: TYPE_TB
- en: '| `Mms/` | MMS/SMS application |'
  prefs: []
  type: TYPE_TB
- en: '| `Nfc/` | NFC control application including native library that interacts
    with NFC chip. Includes the NFC manager and Nfc service |'
  prefs: []
  type: TYPE_TB
- en: '| `Phone/` | The dialer application and call-answering UI |'
  prefs: []
  type: TYPE_TB
- en: '| `Settings/` | System settings and secure settings application |'
  prefs: []
  type: TYPE_TB
- en: 'Directories under `/Providers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory name | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ApplicationsProvider/` | Maintains a database of all installed applications
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ContactsProvider/` | Code that maintains the Contacts datastore that is
    used by innumerable services on the device |'
  prefs: []
  type: TYPE_TB
- en: '| `TelephonyProvider/` | Stores three types of data: SMS content, MMS content,
    and current network configuration |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the above applications have a make file that is picked up by the Android
    built system during a full system build. The built APKs are packaged into `system.img`
    and during system bootup they are installed into the `/system/app` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the search widget application (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will modify the default search text in the quick search widget.
    The aim of this recipe is to make the reader comfortable with making changes,
    compiling them, and testing those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The search widget's code is in the directory named `QuickSearchBox` under `ANDROID_SRC/packages/apps/`.
    Navigate to this directory and open up `ANDROID_SRC/packages/apps/QuickSearchBox/res/drawable/text_field_search_empty_google.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the XML layout file by replacing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use a popular image editor to create an icon of your choice with dimensions
    of 97 x 40 pixels. We create a Packt logo variant for this task in GIMP. Make
    sure you save the image as a PNG type. Copy this image to three locations: `drawable-hdpi`,
    `drawable-ldpi`, and `drawable-mdpi`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each screen density, an image with different parameters should be stored.
    Otherwise, you might notice problems in rendering; images may not appear to be
    clear. As we are simply demonstrating a concept here, I do not focus on creating
    differently sized images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will build the new `QuickSearchWidget` application. In a terminal, as
    usual, navigate to the Android source directory, include the environment setup
    and lunch the emulator target. Issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This will build only the search widget. After building is complete, start the
    emulator and drop to an `adb` shell. We need to remount the system partition as
    read/write, since system applications are installed on to this partition which
    is mounted read-only. To be able to write a new executable of the `QuickSearchWidget`
    application, and without rebuilding and reflashing the entire operating system,
    we will simply "push" the generated APK onto the remounted directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to find out where the `/system` partition is mounted. In an `adb` shell,
    execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a real device, this will appear differently. The MTD mounts vary based on
    the manufacturer of the device. The output seen here is on an emulator, which
    is where you should be doing initial development and debugging before trying anything
    on a real device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that `/system` exists in `mtd0`. To remount as read/write, in an `adb`
    shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Now, exit the `adb` shell and navigate to `ANDROID_SRC/out/target/product/generic/system/app`.
    This is where the built APK is stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a terminal, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the new widget. The change should be visible on the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9762OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mmm` command selectively builds code. The argument to it is the path to
    the source directory containing an `Android.mk` file. The path should end with
    the name of a target that can be built. For example, if you open the `Android.mk`
    file, the target is identified by the `LOCAL_PACKAGE_NAME` tag.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in earlier recipes, the system partition is mounted as read-only
    for security reasons. To install a system application, we need to remount this.
    The remount can only be done by a root user. On the emulator, ADB runs as root
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: The side effect of simply pushing an APK to `/system/app` results in its installation.
  prefs: []
  type: TYPE_NORMAL
- en: The different `drawable` directories are used based on different screen densities.
    This has the same meaning as the directories used when writing SDK-based apps.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CCACHE (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CCACHE is a compiler cache for C/C++ code. The Android framework distribution
    consists of several native libraries that live in the `/external` directory. You
    may have noticed that on a clean build, these libraries are rebuilt, even if they
    were never changed. The rebuilding of these libraries takes a lot of time. To
    save you that time, you can use the CCACHE mechanism. In this recipe, we will
    highlight certain tips and tricks that make the life of an Android systems developer
    easier. In particular, we will explain how to use the CCACHE mechanism, how to
    selectively compile modules, and how to test them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to your Android sources root and issue the `make clean` command. We
    want to build up the cache from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a terminal at the Android sources root, execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The preceding two environment variables control whether we use CCACHE, and if
    so, where the CCACHE directory is located. You are free to use any directory for
    the CCACHE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `prebuilt/linux-x86`, there is the `ccache` directory that contains
    the ccache binary. Just executing the following command presents us with options
    of what this binary can do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'This command provides an output like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we can set the maximum cache size with the help of the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: This will set it to be 20 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you start a make for any target (choose emulator since it''s the easiest),
    we can watch how the CCACHE is being used. In another terminal, use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The `watch` command is used to monitor the cache status and usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper file should be saved as `build_helper.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'An example invocation for the emulator target is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'and it outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android build system is written in such a way that if CCACHE is activated
    by the environment variable, it will be used automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The above shell script is really simple and simplifies the developer's task
    of initializing an environment for further work. The commands within the shell
    script have to be executed whenever a new terminal is opened for Android systems
    development. Hence it is easier to execute one shell script instead of several
    individual commands.
  prefs: []
  type: TYPE_NORMAL
- en: Selectively compiling modules (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you do not need to compile the entire framework for one code change.
    In such a case, you can make use of selective compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example, we will use selective compilation to rebuild the `Phone` application
    under `ANDROID_SRC/packages/apps/Phone`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make a small change, like adding a comment to one of the source files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To rebuild, use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: To test your changes on a running device/emulator, simply use the system partition
    remounting technique covered earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mmm` invokes the build system only on the specified argument and places the
    output at the specified location (this is inferred from the make file of the module
    being compiled).'
  prefs: []
  type: TYPE_NORMAL
- en: You can follow this technique for any module as long as you replace all rebuilt
    components on the device/emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Building command tricks (Should know)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will equip you with some of the lesser known `make` command options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need is a terminal window with the build environment set up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table lists the command options for the standard make:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Make sdk` | Builds the SDK |'
  prefs: []
  type: TYPE_TB
- en: '| `Make snod` | Builds system image from currently available binaries |'
  prefs: []
  type: TYPE_TB
- en: '| `Make services` | Creates the services JAR that contains all system services
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Make runtime` | Builds native code which serves as the glue between the
    Java-based Android framework and native stuff used for its functionality |'
  prefs: []
  type: TYPE_TB
- en: '| `Make droid` | The default make |'
  prefs: []
  type: TYPE_TB
- en: '| `Make modules` | Shows a list of all modules that can be built by using `make
    <MODULE_NAME>` |'
  prefs: []
  type: TYPE_TB
- en: '| `Make clean` | Completely clears all compiled files |'
  prefs: []
  type: TYPE_TB
- en: '| `Make clobber` | Same as `rm -rf out/` |'
  prefs: []
  type: TYPE_TB
- en: '| `Make clean-<LOCAL_MODULE>` | Only cleans up any built files for `LOCAL_MODULE`
    |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These commands can be regularly used for several tasks during development.
    As an example, suppose I want to rebuild the Android framework and push it to
    the emulator, I can use the following sequence of commands written as a shell
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save this build file as `mk_frmwrk.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This will recompile the framework code, recompile the resources, rebuild `system.img`
    and sync it to the currently connected device.
  prefs: []
  type: TYPE_NORMAL
