- en: Chapter 3. Adding Responsive Media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A picture paints a thousand words...*'
  prefs: []
  type: TYPE_NORMAL
- en: A key element of any website is a visual content; after all, text will become
    very repetitive and dull, without adding some form of color!
  prefs: []
  type: TYPE_NORMAL
- en: Adding media not only gives color to a site, but can serve as a vital tool to
    show potential customers what a product looks like or how we should use it. In
    fact, sales can go up based purely on being able to see a product being demonstrated.
    With the advent of mobile devices, it is more important that we not only add media,
    but also ensure it works well on a range of different devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the course of this chapter, we will explore different ways of adding
    media to our pages, and see how easy it is to make it respond to any changes in
    available screen size. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of adding images using `<picture>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring alternatives to adding images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making video and audio content responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting text to fit automatically on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curious? Let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Making media responsive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our journey through the basics of adding responsive capabilities to a site has
    so far touched on how we make our layouts respond automatically to changes; it's
    time for us to do the same to media!
  prefs: []
  type: TYPE_NORMAL
- en: If your first thought is that we need lots of additional functionality to make
    media responsive, then I am sorry to disappoint; it's much easier, and requires
    zero additional software to do it! Yes, all we need is just a text editor and
    a browser; I'll be using my favorite editor, Sublime Text, but you can use whatever
    works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, we will take a look in turn at images, videos,
    audio, and text, and we'll see how with some simple changes, we can make each
    of them responsive. Let's kick off our journey, first with a look at making image
    content responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fluid images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often said that *images speak a thousand words*. We can express a lot
    more with media than we can using words. This is particularly true for websites
    selling products; a clear, crisp image clearly paints a better picture than a
    poor quality one!
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructing responsive sites, we need our images to adjust in size automatically.
    To see why this is important, go ahead and extract `coffee.html` from a copy of
    the code download that accompanies this book and run it in a browser. Try resizing
    the window. We should see something akin to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fluid images](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It doesn''t look great, does it? Leaving aside my predilection for nature''s
    finest bean drink, we can''t have images that don''t resize properly, so let''s
    take a look at what is involved to make this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and extract a copy of `coffee.html` and save it to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need our image—this is in the `img` folder; save a copy to the `img`
    folder in our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new text file, add the following code, saving it as `coffee.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Revert to `coffee.html`. You will see line 6 is currently commented out; remove
    the comment tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file, then preview it in a browser. If all is well, we will still see
    the same image as before, but this time try resizing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time around, our image grows or shrinks automatically, depending on the
    size of our browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fluid images](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although our image does indeed fit better, there are a couple of points we
    should be aware of when using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you might see `!important` set as a property against the `height`
    attribute when working with responsive images; this isn't necessary, unless you're
    setting sizes in a site where image sizes may be overridden at a later date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've set `max-width` to `100%` as a minimum; you may need to set a `width`
    value too, to be sure that your images do not become too big and break your layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an easy technique to use, although there is a downside that can trip
    us up—spot what it is? If we use a high-quality image, its file size will be hefty—we
    can't expect users of mobile devices to download it, can we?
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry though - there is a great alternative that has quickly gained popularity
    among browsers; we can use the `<picture>` element to control what is displayed,
    depending on the size of the available window. Let's dive in and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the <picture> element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a nutshell, responsive images are images that are displayed their optimal
    form on a page, depending on the device your website is being viewed from. This
    can mean several things:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to show a separate image asset based on the user's physical screen
    size. This might be a 13.5-inch laptop or a 5-inch mobile phone screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to show a separate image based on the resolution of the device or using
    the device-pixel ratio (which is the ratio of device pixels to CSS pixels).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to show an image in a specified image format (WebP, for example) if
    the browser supports it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditionally, we might have used simple scripting to achieve this, but it is
    at the risk of potentially downloading multiple images or none at all, if the
    script loads after images have loaded, or if we don't specify any image in our
    HTML and want the script to take care of loading images.
  prefs: []
  type: TYPE_NORMAL
- en: 'We clearly need a better way to manage responsive images! A relatively new
    tag for HTML5 is perfect for this job: `<picture>`. We can use this in one of
    three different ways, depending on whether we want to resize an existing image,
    display a larger one, or show a high-resolution version of the image. The recommended
    way to approach this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`srcset` attribute'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sizes` attribute'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`picture` element'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll explore all three in detail; let's start with implementing the `srcset`
    attribute in a standard `<img>` tag, before moving on to using the `<picture>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Using the srcset attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A key benefit of using the `<picture>` element is using the srcset attribute
    to select any one of several images, based on whether we want to display higher
    resolution versions or different sizes of the same image in different viewports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for this in browsers is very good, with only Opera Mini and up to IE11
    not wanting to join the party:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the srcset attribute](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://caniuse.com/#search=srcset](http://caniuse.com/#search=srcset)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this `srcset` attribute, we need to avail ourselves of sufficient
    different images, then specify what should be displayed at the appropriate trigger
    point, as shown in this example, based on defining the `device-pixel` ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `src` attribute acts as fallback image for those browsers that do
    not support `srcset` (although support is now very good!). The `srcset` attribute
    allows us to specify different images to use, either based on the device-pixel
    ratio or the available viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our fallback is `default.png`; however, if the browser being used
    supports `srcset`, then it will display `small.png` at `256w` or `med.png` at
    `511w`. If, however, we wanted to change the size and use different images based
    on the available viewport, then we would have to add an extra attribute—`sizes`.
    It's easy enough to configure, so let's pause for a moment to see what this means
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the sizes attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding pictures as part of the content on a responsive site, the images
    may each take up 100% of the element width, but the content itself doesn't always
    take 100% of the width of the window! For example, we might set each image element
    to 100% width (so they fill their parent containers), but that the overall content
    on screen only fills 50% of the available screen width.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this, we need to know the URLs for the various images to use, along
    with the width of each image resource; we can't get this from standard markup
    in the page layout, as images start downloading before CSS is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can simply set suitable widths within our HTML code using the `srcset`
    attribute and suitable width descriptors. This is a little controversial for some,
    as it starts to blur the divide between HTML markup and the CSS presentation layer.
    This aside, let''s take a look at an example of how we can set up the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this excerpt, we set a default of 50% or half of the viewport width; the
    browser can then select the appropriate image to display, depending on the available
    width.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the HTML5 <picture> element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve covered two key parts of making images responsive, but to bring it all
    together, we can use the HTML5 `<picture>` element, which has garnered good support
    in most browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating the HTML5 <picture> element](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://caniuse.com/#search=picture](http://caniuse.com/#search=picture)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<picture>` element uses this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this extract, we've tied together all of the various attributes we can use
    with the `<picture>` element; in this case, we've specified media queries (one
    of `60rem` and another of `35rem`), and that if our viewport is only 50% or less
    (indicated by the `50vw` value in the code), we display the normal images; if
    it is higher, then we display the high-definition images (as specified by using
    the `100vw` value).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will explore how this works in more detail, in *Exploring what happened*,
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've seen all three elements in use, let's pull them together and
    create a simple demo that automatically adjusts which image to use, based on the
    available viewport. For simplicity, we will concentrate just on the image, but
    there is nothing stopping us from developing this further into a full-sized page!
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a start. For this demo, I would strongly recommend using Google Chrome
    if you have it installed; its device mode is perfect for this task!
  prefs: []
  type: TYPE_NORMAL
- en: From a copy of the code download that accompanies this book, go ahead and extract
    copies of the four landscape images, and save them to the `img` folder at the
    root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, fire up your text editor, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `pictureelement.html` at the root of our project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and preview the results of the file in Google Chrome (or another browser
    if preferred). Make sure you switch on that browser's device/responsive mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all is well, we should see the image flip between two similar versions;
    to identify which is which, I''ve added the words **High Resolution Image** on
    one, and **Medium Resolution Image** on the other image used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the same image, but this time using the medium resolution version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although this demo may look simple at face value, it is deceptive. We have the
    power to construct some complex statements, which can automatically select an
    image based on a number of criteria! It's important to understand how this demo
    works, as a basis for using it for complex examples. Let's take a moment to explore
    it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what happened
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we take a look through our picture element demo, the code used may initially
    look complex, but is simpler than it looks! The key to it is understanding each
    part the `<source>` statements and how they interact with each other. Let''s tackle
    the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this one, we're specifying `high-res-image.png` as our source image; this
    will only be displayed when our browser window is showing a minimum width of `800px`.
    The size of the image will either go to a maximum of `1000px` or `100vw`—the latter
    equivalent to 100% width of the available viewport space. The `738w` against the
    image is just the width of the image specified in the code (1w unit is equal to
    1px, so our image is 738px wide).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving onto the second source statement, we find it shows a similar set up,
    but this time the media query is limited to a maximum width of `799px`, and that
    the size of the image will go to `600px` or the full width of the viewport, depending
    on its current size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To finish off the `<picture>` element, we specify `fallback-image.png` as our
    fallback for those browsers that have yet to support this element in HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've only scratched the surface of what is possible with the `<picture>` element;
    for more details, take a look at the site maintained by the Responsive Images
    Community Group, hosted at [https://responsiveimages.org/](https://responsiveimages.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real-world example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've explored the theory behind making images responsive with a couple of useful
    techniques; it's time we got practical! The basis for our next demo is going to
    look at making a responsive map using Google Maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsive maps, I hear you ask? Surely this should come automatically, right?
    Well no, it doesn''t, which makes its use a little awkward on mobile devices.
    Fortunately, we can easily fix this; the great thing about it is that it only
    requires a little additional CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a start by browsing to [http://maps.google.com](http://maps.google.com/),
    then entering the zip code of our chosen location; in this instance, I will use
    Packt's UK office, which is B3 2PB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the cog, then select **Share and embed** map, as shown in this screenshot:![Creating
    a real-world example](img/image_03_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box that appears, switch to the Embed map tab, then copy the contents
    of the text field starting with `<iframe src=...`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a copy of the code download that accompanies this book, extract a copy of
    `googlemaps.html` in your favorite text editor, and add the `<iframe>` code in
    between the google-maps div tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the following CSS styling to a new file, saving it as `googlemaps.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is well, we will see a Google Maps image of Birmingham, with Packt''s
    office marked accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a real-world example](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, try resizing the browser window. You will see that the map resizes
    automatically; the CSS styling that we've added has overridden the standard styles
    used within Google Maps to make our map responsive and accessible from any device
    we care to use.
  prefs: []
  type: TYPE_NORMAL
- en: Taking things further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the course of this chapter, we've followed the principle of using
    just a browser and text editor to construct our code. This, of course, included
    not downloading anything that was core to creating our examples (save for media
    and content).
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be times though when this approach is not sufficient, we may find
    we need to avail ourselves of additional support to get a job done. Our overriding
    question should always be to check that we really need it, and that we''re not
    just being lazy! If when answering that question, we do find that need additional
    help is needed, then there are a number of sources you can try out, to help take
    things further:'
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying, but there will come a time when we need to resort to
    using jQuery ([http://www.jquery.com](http://www.jquery.com/)) to help within
    our development. The state of responsive design is such that we should only need
    jQuery to make it easier to reference elements in the DOM, and not to make images
    or content responsive!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Responsive Images site hosted at [https://responsiveimages.org/](https://responsiveimages.org/).
    We covered it briefly at the end of the `<picture>` demo, but it's worth pointing
    it out again. It's a useful compendium of material to help understand and use
    the `<picture>` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer Scott Jehl created a polyfill for `<picture>`, to extend support
    to those browsers that do not support it natively; you can download it from [https://scottjehl.github.io/picturefill/](https://scottjehl.github.io/picturefill/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you in need of a responsive carousel? There are plenty available online,
    but one which I've found to work well, is ResponsiveSlides, available from [http://responsiveslides.com/](http://responsiveslides.com/).
    Granted, the project is a few years old, but this particular plugin keeps things
    nice and simple, which is very much in keeping with the theme for this book!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good example of where responsive capabilities are already present is in using
    the SVG image format. These are effectively vector-based images that we can manipulate
    using CSS; the key benefit though is that SVG images can automatically grow or
    shrink, with no loss of quality. Browser support for the format is excellent,
    although IE (and Edge) both have a couple of quirks that require attention when
    using these browsers (for more details, see [http://caniuse.com/#feat=svg](http://caniuse.com/#feat=svg)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another idea to try is with responsive icons. A good example that is worth a
    look is the FontAwesome library, available from [http://fontawesome.io/](http://fontawesome.io/).
    These will resize equally as well. In this instance, they would be perfect for
    smaller images, such as credit card icons or shopping baskets on e-commerce sites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking things even further afield, how about support for the WebP image format?
    Yes, this is one that hasn''t gained huge support yet, with it being limited to
    Chrome and Opera at the time of writing. However, when used with the `<picture>`
    element, it shows off a nice trick:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the browser will check for WebP support, if it can support it,
    it will display the appropriate image in WebP format, depending on what device-pixel-ratio
    is supported on the device being used. If WebP isn't supported, then it will fall
    back to using JPEG (although this could equally have been a different format such
    as PNG).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are certainly things we can do, once we've become accustomed to working
    with responsive images, and want to graduate away from just using HTML5 and CSS3\.
    It is important to note though, that there are a number of projects operating
    online that aren't listed here.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for this is age—support for responsive images was patchy for
    a while, which meant a number of projects appeared to help provide support for
    responsive images. Support for the `<picture>` and associated elements is getting
    better all of the time, which reduces some of the attraction of these older projects;
    it is worth considering whether it is sensible to use them, or if the impact of
    not using them can be mitigated by changes to the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's move on; time to get a little animated, I think! Alright, that was
    a terrible lead in to our next topic, given that we're going to explore making
    videos responsive. Over the next few pages, we'll see that although some of the
    same principles apply here, there are some bumps along the way, which might impact
    our journey.
  prefs: []
  type: TYPE_NORMAL
- en: Making video responsive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flexible videos are somewhat more complex than images. The HTML5 `<video>`
    maintains its aspect ratio just like images and therefore we can apply the same
    CSS principle to make it responsive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Until relatively recently, there have been issues with HTML5 video—this is
    mainly due to split support for the codecs required to run HTML video. The CSS
    required to make a HTML5 video is very straightforward, but using it directly
    presents a few challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Hosting video is bandwidth intensive and expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming requires complex hardware support in addition to video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not easy to maintain a consistent look and feel across different formats
    and platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For many, a better alternative is to host the video through a third-party service
    such as YouTube. There is a caveat that they would be in control of your video
    content; if this isn't an issue, we can let them worry about bandwidth issues
    and providing a consistent look and feel; we just have to make it fit on the page!
    This requires a little more CSS styling to make it work, so let's explore what
    is involved.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding externally hosted videos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To embed those videos, we need to use iframes, which unfortunately do not maintain
    aspect ratio by default; we can work around this with a CSS solution by Thierry
    Koblentz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s for argument''s sake say that we have a YouTube video, such as this
    one, titled *The Big Buck Bunny*, by the Blender Foundation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Embedding externally hosted videos](img/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (c) Blender Foundation | [www.bigbuckbunny.org](http://www.bigbuckbunny.org)
  prefs: []
  type: TYPE_NORMAL
- en: 'Looks okay, doesn''t it? Granted, we can''t immediately tell it is a video
    from YouTube, but this next screenshot clearly shows it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Embedding externally hosted videos](img/image_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hold on; that doesn't look right, does it? The screenshot was taken in Google,
    but set to emulate the screen estate of a Galaxy S5 mobile phone, but it clearly
    shows that the video is not responsive.
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, extract a copy of `youtube.html` from the code download
    that accompanies this book to our project area, then run it in a browser. Activate
    your browser's responsive mode (or device mode, depending on browser) and resize
    the screen to 360px by 640px. You will soon see how it doesn't resize well!
  prefs: []
  type: TYPE_NORMAL
- en: How do we fix this?
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is to create a box with a proper aspect ratio, say 4:3 or 16:9 (through
    zero height and bottom padding in %), and then fit the video and stretch it inside
    the box up to the box dimensions by positioning it absolutely with respect to
    the box. The bottom padding acts as the width that helps to maintain the aspect
    ratio. Let''s alter our code to fix this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `youtube.html`, add this link within the `<head>` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Further down, alter the code as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file. Switch to a new file, then add the following code and save it
    as `youtube.css` within the `css` subfolder of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word of note—setting `height: 0` ensures the element is present within the
    DOM so that older browsers can format the inner box properly.'
  prefs: []
  type: TYPE_NORMAL
- en: Save the file, revert back to your browser, and re-enable its responsive (or
    device) mode if it is not already switched on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try previewing the results now; if all is well, we should see something akin
    to this. It uses the same Galaxy S5 size settings, but this time zoomed in to
    150% for clarity:![Embedding externally hosted videos](img/image_03_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This looks much better! With some simple styling, we have the best of both worlds;
    we can let YouTube do all the heavy lifting while we concentrate on making our
    video available from our site on multiple devices. The CSS we used forces all
    of the video content to the full width of the `.video-box-wrapper` container,
    which in turn is positioned relative to its normal position. We then add `56.25%`
    to the bottom to maintain the classic 16:9 aspect ratio and provide a little extra
    padding at the top so it doesn't appear to go off screen!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Question**: How did we arrive at 56.25%? This is simply 9 divided by 16 (the
    aspect ratio), which is 0.5625 or 56.25%.'
  prefs: []
  type: TYPE_NORMAL
- en: There will be occasions, though, when we have to host our own videos; this might
    be for controlling visibility or preventing adverts from being played, if we were
    to host it externally. To achieve this, we can use the now current HTML5 `<video>`
    element to render content on a page; let's take a look and see how this works
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the new HTML5 video element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If hosting videos on an external source is not possible, then we must host
    locally; for this, we can use the native HTML5 video tag, which looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the past, codec support for the HTML5 element has been split across each
    platform; in 2015, Firefox added support for H.264 to its browsers across all
    platforms, which goes a long way to rationalize support for HTML5 video. At present,
    support for the two formats (MP4 and WebM) is good, but not 100% across all browsers
    – this screenshot indicates the current state of play for desktop and mobile browsers
    for the MP4 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the new HTML5 video element](img/image_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: CanIuse.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, support for the WebM format is not quite so complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the new HTML5 video element](img/image_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: CanIuse.com'
  prefs: []
  type: TYPE_NORMAL
- en: In reality, the only format we need to worry about using is MP4; we can use
    WebM format if desired. If we do so, then it must come first in the `<source>`
    list; otherwise, the browser will pick the first available supported format (in
    this case, MP4) and not use WebM!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before continuing, I would strongly recommend making sure you have Google Chrome
    or Firefox installed - WebM video will work in IE9 or above, but not without adding
    codec support for the format!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've been introduced, let's move on and put it into practice, with
    a simple demo to illustrate how the `<video>` element works in action.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding HTML5 video content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If our requirements are such that we have to host a video ourselves, then implementing
    it using the HTML5 standard tags is very easy; it consists of setting any number
    of different sources within the `<video>` tags so that we can play the same video
    using the supported format for that browser. Let''s dive in and take a look at
    how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by extracting copies of the following, from the code download that
    accompanies this book - the `video` folder and `html5video.html`. Save them to
    the root of our project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, go ahead and add these styles; save the file as `html5video.css`
    in the `css` subfolder of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Try previewing the results in a browser. If all is well, we should see something
    akin to this (screenshot taken from Chrome):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Embedding HTML5 video content](img/image_03_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result looks perfect—the question is, which version of our video is being
    used? One way to find out is to right-click on the video, while it is still playing,
    then click on **Save video as...**. If all is well, we should see a **Save As**
    dialog box open, ready to save the WebM format if we're using FireFox, Chrome,
    or Opera; otherwise it will be MP4 (if using IE).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what happened
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The real question, though, is not so much how does it all work, but if it is
    responsive?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is yes; our use of the HTML5`<video>` tags mean that we can select
    any number of different video formats to use; the browser will simply choose the
    first available that it is able to play. The order is critical though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we were to swap it around so that MP4 is first, then WebM will be ignored
    for almost all browsers, as MP4 can be played in almost all of the browsers!
  prefs: []
  type: TYPE_NORMAL
- en: 'The real magic lies not in the use of a specific video format, but in the CSS
    rule we''ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our use of percentage values means that it will automatically scale up or down
    when our window is resized; the maximum size of the video is constrained by the
    video's dimensions, not other elements on screen. Of course, we may decide to
    host the video within a parent container; the video will fill that container,
    but the parent may only stretch over part of the site.
  prefs: []
  type: TYPE_NORMAL
- en: Building a practical example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you spend any time on the Internet, it's possible you've come across sites
    where the developer hasn't used images as a background, but *video*.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't entirely new as a concept; it's been around for a couple of years
    now. If done with care, it can work very well. It's a perfect candidate for making
    full-size video as a responsive background. The great thing about it is that we
    can make it responsive using pure CSS. That's right, no need for any JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: For our next demo, we'll take a break from creating content. This time around,
    we'll run the demo from the code download that accompanies this book, and take
    a look at the code in more detail later in the demo. We'll be using videos from
    the Big Buck Bunny project, created by the Blender Foundation as our background;
    over this, we'll overlay a simple block of sample text, generated using the Lorem
    Ipsum generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, go ahead and run the `fullscreen .html` demo from a
    copy of the code download that accompanies this book. If all is well, you will
    see the video play behind a simple `<div>` with text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a practical example](img/image_03_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we take a look at our code in more detail, we can see the video element in
    use; it's been set to autoplay, with sound muted and a poster (or placeholder)
    image set. The real magic, though, lies in the CSS styling, so let's explore this
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what happened
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The trick that makes our video work is in this code. We need to set two media
    queries with 16:9 aspect ratio (one as a min-aspect-ratio, another as the max)
    so that our video displays correctly on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring what happened](img/image_03_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When resizing it though, it will show white space. We fix that by setting negative
    margins, which makes the viewport much wider, and allows us to center the content
    on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring what happened](img/image_03_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A key point to note is the values used for `height`, `top`, `left`, and `width`;
    although these seem extreme, they are required to help center the video on screen
    when viewing the content with a `16/9` aspect ratio set.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! Our video plays well. We can see the content without too much difficulty.
    Everything should be good, surely? Well, yes and no; concepts such as background
    video are not without their risks; it's important to understand where things might
    fall over if we're not careful. Let's pause for a moment and consider some of
    the potential traps that might upset the proverbial apple cart, if we're not careful
    with our video.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the risks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous example, we explored the concept of adding video as background
    content. It's a fashion that has taken off within the last couple of years, and
    provides an interesting effect, that is different to seeing the standard images
    we might otherwise see!
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not without a certain element of risk though; there are a few pointers
    we must consider, when adding video as the background content:'
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to add video, but we shouldn't just add it because we can—any
    video we add using this method must amplify the site's overall message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any video added will likely be set to autoplay, but the sound must be muted
    by default—if possible, it shouldn't have any sound at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does our video fit with the site brand, tone, color palette, and so on? There
    is no point building a killer site, only to ruin it with a rubbish video.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs are something we must consider; it can be expensive to host video content,
    so it must be compressed as much as possible to keep file sizes down, and in a
    suitable format that works on multiple devices, including mobile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our video should not be too long; we must strike a balance between making it
    too long and not long enough so that it does not feel too repetitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessibility is a key pointer; it must be of sufficiently high contrast so
    as to make the text overlay legible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our video may look good, but what about performance? Your customers will not
    thank you if you produce a lightning fast site, but slow it down with a large,
    poorly optimized video as a background; they will very likely vote with their
    feet!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compatibility technique we've used doesn't work on IE8, so a static placeholder
    must be included as a fallback; in the event the browser we use doesn't support
    HTML5 video or its attributes (such as autoplay, for mobiles).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though we have some clear pointers that should be considered, it should
    not stop us from using this effect; I'm one for pushing out the boundaries of
    what is possible, provided we do it well!
  prefs: []
  type: TYPE_NORMAL
- en: Making audio responsive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Question—we've worked on making videos responsive, but what about audio content?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can apply similar principles to the HTML5 `<audio>` element; instead
    of setting a specific width, we can use max-width and set a percentage figure
    to control how wide it displays on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to achieve this is very simple, and should by now be familiar—let''s
    take a look at what is involved:'
  prefs: []
  type: TYPE_NORMAL
- en: For this demo, we need to avail ourselves of suitable files; for licensing reasons,
    you won't find any in the code download that accompanies this book, unfortunately!
    One way to achieve this is to take a copy of an iTunes file (normally in `.m4a`
    format), then use an online service such as Media.io ([http://media.io/](http://media.io/))
    to convert it to the right formats. You will need to convert to both MP3 and OGG
    formats, before continuing with this demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming we now have the right files, go ahead and extract a copy of `audioelement.html`
    from the code download that accompanies this book, and save it to the root of
    our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, at the root of our project area, go ahead and create a new folder called
    `audio`; into it, save copies of the audio files you either have or created from
    step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file go ahead and add the following code, saving it as `audioelement.css`
    in the `css` subfolder at the root of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Try previewing the results of our work in a browser—if all is well, we should
    see something akin to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Making audio responsive](img/image_03_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first glance, it may not look special, but then the `<audio>` element isn't
    meant to look anything out of the ordinary! The key here though is when we resize
    the browser window; we've set a max width value of `100%`, but have constrained
    this by setting an upper limit of `50rem` in the width attribute. No matter how
    many times we resize our window, the audio player will fill the full width, but
    not go any wider than `50rem`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the `<video>` element, we can't resize the height using just CSS; to
    do this requires overriding the `<audio>` element with jQuery, which is out of
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and put our new-found knowledge to the test to create a practical
    example—how about making a video fullscreen, and responding to changes in the
    browser viewport automatically? Setting up video using this technique is always
    fraught with controversy, but I'm not one to shy away from a challenge, so without
    further ado, let's dive in and see why we must step carefully when using video
    at fullscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Taking things further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the course of this book, we've concentrated on using the core technologies
    of HTML5 and CSS3; in many cases, this is all we need, but there will come a time
    when we have to use other technologies to help fulfill a task, as we've outgrown
    the art of possible with plain CSS and HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there are lots of options available online to help with making videos
    responsive, and to take our skills. It goes without saying though that we should
    always ask ourselves if our need for another library is because the realities
    of life mean that we can't achieve our task without using it or if we've simply
    become too lazy!
  prefs: []
  type: TYPE_NORMAL
- en: 'If indeed we do need to download and use an additional library, there are a
    few good options to try out, which include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FluidVids**: It is available from [http://toddmotto.com/labs/fluidvids](http://toddmotto.com/labs/fluidvids);
    the library is a couple of years old, but may be worth a look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**responsiveVideo**: It is downloadable from [http://cbavota.bitbucket.org/responsive-video/](http://cbavota.bitbucket.org/responsive-video/).
    This has been around for a couple of years, so may not work so well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embed Responsively**: It is hosted at [http://embedresponsively.com/](http://embedresponsively.com/),
    and will return appropriate embed code for any of the major video hosting companies,
    such as YouTube; it''s also responsive to boot!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FitVids.js**: This plugin, available from [http://fitvidsjs.com](http://fitvidsjs.com/)
    and built by Chris Coyier of CSS Tricks'' fame, may be worth a look, although
    it hasn''t been updated for at least 2-3 years.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MediaElement.js**: It is available from [http://mediaelementjs.com](http://mediaelementjs.com/),
    and is a great library that works with both the `<video>` and `<audio>` elements;
    it allows us to override the standard element and customize it to our requirements
    using jQuery and CSS. There are plenty of examples of doing this online, along
    with suitable tutorials on how to achieve a custom look and feel to any player
    we skin using jQuery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small word of caution—a number of the video plugin libraries for jQuery haven't
    been updated for some time; you may well find that they no longer work properly
    with more recent versions of jQuery. This isn't necessarily a bad thing, as support
    for the HTML5 `<video>` and `<audio>` elements is now excellent; this renders
    many of these libraries surplus to requirements!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of you may ask why we need to use jQuery to skin either HTML5 audio or
    video players; many of the individual elements are not accessible using plain
    CSS, and need JavaScript to expose those elements before styling them with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! We're almost through this part of the journey, but before we move onto
    taking a look at using media queries in the next chapter, there is one more part
    of making responsive content; how about the text we have on our sites? It might
    not immediately strike you as being one we would associate with videos and text
    (at least in the context of making content responsive), but all will shortly become
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: Making text fit on screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building sites, it goes without saying but our designs clearly must start
    somewhere—this is usually with adding text. It's therefore essential that we allow
    for this in our responsive designs at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Now is a perfect opportunity to explore how to make our text fluid and fill
    the available space. Although text is not media in the same way as images or video,
    it is still content that has to be added at some point to our pages! With this
    in mind, let's dive in and explore how we can make our text responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing with em units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on non-responsive sites, it's likely that sizes will be quoted
    in pixel values; it's a perfectly acceptable way of working. However, if we begin
    to make our sites responsive, then content won't resize well using pixel values;
    we have to use something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two alternatives: em or rem units. The former is based on setting
    a base font size that in most browsers defaults to 16px; in this example, the
    equivalent pixel sizes are given in the comments that follow each rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, there is an inherent problem with using em units; if we nest
    elements, then font sizes will be compounded, as em units are calculated relative
    to its parent. For example, if the font size of a list element is set at 1.4em
    (22px), then the font size of a list item within a list becomes 30.8em (1.4 x
    22px).
  prefs: []
  type: TYPE_NORMAL
- en: To work around these issues, we can use rem values as a replacement, these are
    calculated from the root element, in place of the parent element. If you look
    carefully throughout many of the demos created for this book, you will see rem
    units being used to define the sizes of elements in the demos.
  prefs: []
  type: TYPE_NORMAL
- en: Using rem units as a replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rem (or root em) unit is set to be relative to the root, instead of the
    parent; it means that we eliminate any issues with compounding at a stroke, as
    our reference point remains constant, and is not affected by other elements on
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of this is support—rem units are not supported in IE7 or 8, so
    if we still have to support these browsers, then we must fall back to using pixel
    or em values instead. This of course raises the question: should we still support
    these browsers, or is their usage of our site so small as to not be worth the
    effort required to update our code?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the answer is that we must support IE8 or below, then we can take a hybrid
    approach; we can set both pixel/em and rem values at the same time in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we set rem values first? Browsers that support rem units will use
    these first; the ones that don't can automatically fall back to using pixel or
    em values instead. The values in each comment are the pixel equivalents; if, for
    example, we divide `18px` by `16px` (as the base value for all sizes), we would
    arrive at `1.125`, as indicated in the text.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring use of viewport units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to take it further, then there is another alternative we can explore;
    how about using viewport units?
  prefs: []
  type: TYPE_NORMAL
- en: 'These effectively combine the best of both worlds; a viewport unit (or `1vw`)
    is 1% of the viewport axis. So, if we had a viewport of 50 cm wide, a single `vw`
    unit would be 0.5 cm. We can specify sizes in the same way as we would do for
    pixel, em, or rem units. Take a look at this little extract, which gives a flavor
    of what it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The beauty though is no matter what size the viewport, the font size will always
    appear correctly, as it will automatically resize if the view port is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see a simple example of this in action, browse to [http://codepen.io/alibby251/pen/xOGrqN](http://codepen.io/alibby251/pen/xOGrqN)
    and try resizing the browser window. See how the text automatically changes size,
    with no loss of quality?
  prefs: []
  type: TYPE_NORMAL
- en: Taking things further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, at this point, we've added responsive capabilities to our text; our sites
    are looking pretty good....I can see a *but* coming....
  prefs: []
  type: TYPE_NORMAL
- en: At present, support for responsive text (and in particular vw or rem units)
    is excellent; browsers that will choke on these two units are few and far between.
    However, there *may* come a time when we need additional help; unlike images or
    video content, there are not many options available to choose from! The two best
    examples are FlowType.js, available from [http://simplefocus.com/flowtype/](http://simplefocus.com/flowtype/),
    and FitText.js, from [http://fittextjs.com/](http://fittextjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: The catch though is that these libraries haven't been updated for 2-3 years,
    so are not likely to work with recent versions of jQuery. It's a good indicator
    of how well responsive text has come along over the years, and that we really
    should be using it natively, rather than relying on JavaScript!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key part of any website must be the media used; after all, it would become
    boring without some form of color! This is no different for responsive sites;
    throughout the course of this chapter, we've covered some useful techniques for
    adding responsive media, so let's reflect on what we've covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with a look at making images fluid, which is the basic concept
    behind responsive media; we then swiftly moved on to look at using the HTML5 `<picture>`
    element, to see how it can be used to specify different sized images based on
    hardware capabilities. We explored a few pointers on what is available to use,
    should we decide to that existing native support is insufficient, and we need
    to progress from using just plain HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Next up came a look at responsive video; we examined how to make externally
    hosted videos responsive, with just plain CSS. We also covered the techniques
    required to make the HTML5 `<video>` element responsive, if hosting externally
    is not an option. We also explored the HTML5 `<audio>` element, and saw how we
    can use similar techniques to make it responsive.
  prefs: []
  type: TYPE_NORMAL
- en: We then rounded off the chapter with a look at making standard text responsive;
    we covered how this has already been used in many demos throughout the book, before
    exploring the different techniques, such as using em or rem values, which are
    often better than standard pixel units. We then finished with a quick demo on
    using viewport units for font sizes, so we could see how to get the best of everything
    when creating responsive text.
  prefs: []
  type: TYPE_NORMAL
- en: Phew—a lot covered! Let's move on. Now that we have our layout and content in
    place, we need to consider how to resize them correctly. Enter media queries—this
    will be the subject of our next chapter.
  prefs: []
  type: TYPE_NORMAL
