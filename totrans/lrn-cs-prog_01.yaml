- en: '*Chapter 1*: Starting with the Building Blocks of C#'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is one of the most widely used general-purpose programming languages. It
    is a multi-paradigm language that combines object-oriented, imperative, declarative,
    functional, generic, and dynamic programming. C# is one of the programming languages
    designed for the **Common Language Infrastructure** (**CLI**) platform, which
    is an open specification developed by Microsoft and standardized by the **International
    Organization for Standardization** (**ISO**) and **European Computer Manufacturers
    Association** (**ECMA**) that describes executable code and a runtime environment
    to be used on different computer platforms without being rewritten for specific
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, C# has evolved with powerful features released version by version.
    The most recent version (at the time of writing) is C# 8, which has introduced
    several features to empower developers to be more productive. These include nullable
    reference types, ranges and indices, asynchronous streams, default implementations
    of interface members, recursive patterns, switch expressions, and many others.
    You will learn about these features in detail in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce you to the language, the .NET Framework,
    and the basic concepts around them. We have structured the contents of this chapter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the history of C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the .NET family of frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemblies in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic structure of a C# program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will learn how to write a `Hello World!` program
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: The history of C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# development started at Microsoft in the late 1990s by a team led by Anders
    Hejlsberg. Initially, it was called **Cool**, but when the .NET project was first
    publicly announced in the summer of 2002, the language was renamed C#. The use
    of the sharp suffix was intended to denote that the language is an increment of
    C++, which, along with Java, Delphi, and Smalltalk, acted as an inspiration for
    the CLI and the C# language design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version of C#, called **1.0**, was made available in 2002 bundled
    with .NET Framework 1.0 and Visual Studio .NET 2002\. Since then, major and minor
    increments of the language have been released together with new versions of .NET
    Framework and Visual Studio. The following table lists all of the versions and
    some of the key features for each of these releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_1Table_1_01.jpg)![](img/Chapter_1Table_1_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The latest version of the language at the time of writing, 8.0, is being released
    with .NET Core 3.0\. Although most features will also work in projects targeting
    .NET Framework, some of them will not because they require changes in the runtime,
    which is something Microsoft will no longer do as .NET Framework is being deprecated
    in favor of .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an overview of the evolution of the C# language over time,
    let's start looking at the platforms that the language is targeting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CLI is a specification that describes how a runtime environment can be
    used on different computer platforms without being rewritten for specific architectures.
    It is developed by Microsoft and standardized by ECMA and ISO. The following diagram
    shows the high-level functionality of the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Diagram of the high-level functionality of the CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Diagram of the high-level functionality of the CLI
  prefs: []
  type: TYPE_NORMAL
- en: The CLI enables programs written in a variety of programming languages (that
    are CLS-compliant) to be executed on any operating system and with a single runtime.
    The CLI specifies a common language, called the **Common Language Specification
    (CLS)**, a common set of data types that any language must support, called the
    **Common Type System**, and other things such as how exceptions are handled and
    how the state is managed. The various aspects specified by the CLI are described
    in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: Because of the limited scope of this chapter, a deep dive into the specification
    is not possible. If you want more information about the CLI, you can visit the
    ISO site at [https://www.iso.org/standard/58046.html](https://www.iso.org/standard/58046.html).
  prefs: []
  type: TYPE_NORMAL
- en: There are several implementations of the CLI and among these, the most important
    ones are .NET Framework, .NET Core, and Mono/Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: Common Type System (CTS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CTS is a component of the CLI that describes how type definitions and values
    are represented and memory is intended to facilitate the sharing of data between
    programming languages. The following are some of the characteristics and functions
    of the CTS:'
  prefs: []
  type: TYPE_NORMAL
- en: It enables cross-platform integration, type safety, and high-performance code
    execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides an object-oriented model that supports the complete implementation
    of many programming languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides rules for languages to ensure that objects and data types of objects
    written in different programming languages can interact with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines rules for type visibility and access to members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines rules for type inheritance, virtual methods, and object lifetime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CTS supports two categories of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value types**: These contain their data directly and have copy semantics,
    which means when an object of such a type is copied its data is copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference types**: These contain references to the memory address where the
    data is stored. When an object of a reference type is copied, the reference is
    copied and not the data it points to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it is an implementation detail, value types are usually stored on the
    stack and reference types on the heap. Conversion between value types and a reference
    type is possible and known as **boxing**, while the other way around is called
    **unboxing**. These concepts will be explained in further detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Common Language Specification (CLS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CLS comprises a set of rules that any language that targets the CLI needs
    to adhere to, to be able to interoperate with other CLS-compliant languages. CLS
    rules fall into the broader rules of the CTS and therefore it can be said that
    the CLS is a subset of CTS. All of the rules of CTS apply to the CLS unless the
    CLS rules are stricter. Language constructs that make it impossible to easily
    verify the type safety of the code were excluded from the CLS so that all languages
    that work with the CLS can produce verifiable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between the CTS and CLS as well as the programming languages
    targeting the CLI is conceptually shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – A diagram showing the conceptual relationship between the CTS
    and CLS and the programming languages that target the CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – A diagram showing the conceptual relationship between the CTS and
    CLS and the programming languages that target the CLI
  prefs: []
  type: TYPE_NORMAL
- en: Components built using only the rules of the CLS are called **CLS-compliant**.
    An example of such components is the framework libraries that need to work across
    all of the languages supported on .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Common Intermediate Language (CIL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CIL is a platform-neutral intermediate language (formerly called **Microsoft
    Intermediate Language** or **MSIL**) that represents the intermediate language
    binary instruction set defined by the CLI. It is a stack-based object-oriented
    assembly language that represents the code in byte-code format.
  prefs: []
  type: TYPE_NORMAL
- en: Once the source code of an application is compiled, the compiler translates
    it into the CIL bytecode and produces a CLI assembly. When the CLI assembly is
    executed, the bytecode is passed through the **Just-In-Time** compiler to generate
    native code, which is then executed by the computer's processor. The CPU and the
    platform-independent nature of the CIL make it possible that the code is executed
    on any environment supporting the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us to understand the CIL, let''s look at an example. The following
    listing shows a very simple C# program that prints a `Hello, World!` message to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to view the content of the assembly produced by the compiler
    using various utility tools, such as `ildasm.exe`, which comes with .NET Framework,
    or ILSpy, which is an open source .NET assembly browser and decompiler (available
    at [http://www.ilspy.net/](http://www.ilspy.net/)). The `ildasm.exe` file shows
    a visual representation of the program and its components, such as classes and
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – A screenshot of the ildasm tool showing the content of an assembly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – A screenshot of the ildasm tool showing the content of an assembly
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the content of the manifest (which includes assembly metadata)
    as well as the CIL code for each method if you double-click on it. The following
    screenshot shows the disassembled code of the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – A screenshot of the ildasm tool showing the IL code of the Main
    method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – A screenshot of the ildasm tool showing the IL code of the Main
    method
  prefs: []
  type: TYPE_NORMAL
- en: 'A human-readable dump of the CIL code is also available. This starts with the
    manifest and continues with the class member''s declarations. A partial listing
    of the CIL code for the preceding program is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An explanation of the code here is beyond the scope of this chapter, but you
    can probably identify at a glance parts of it such as classes, methods, and instructions
    executed in each method.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Execution System (VES)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VES is a part of the CLI that represents a runtime system that provides the
    environment for executing the managed code. It has several built-in services to
    support the execution of code and handling of exceptions, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: The Common Language Runtime is .NET Framework's implementation of the Virtual
    Execution System. Other implementations of the CLI provide their own VES implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET family of frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET is a general-purpose development platform developed by Microsoft for writing
    a variety of types of applications for desktop, cloud, and mobile. .NET Framework
    was the first implementation of the CLI but, over time, a series of other frameworks
    have been created, such as .NET Micro Framework, .NET Native, and Silverlight.
    While .NET Framework works on Windows, other current implementations, such as
    .NET Core and Mono/Xamarin, are cross-platform and run on other operating systems,
    such as Linux, macOS, iOS, or Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the main characteristics of the current top
    .NET frameworks. .NET Framework is intended for developing .NET applications for
    Windows and is distributed with the operating system. .NET Core, which is cross-platform
    and open source, is optimized for modern application requirements and developer
    workflows and is distributed with the application. Xamarin, which uses a Mono-based
    runtime, is also cross-platform and open source. It is intended for developing
    mobile applications for iOS, macOS, Android, and Windows, and is distributed with
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – A diagram with the main characteristic of the most important
    .NET frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – A diagram with the main characteristic of the most important .NET
    frameworks
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these implementations are based on a common infrastructure that includes
    languages, compilers, and runtime components and supports a variety of application
    models, some of which are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – A high-level diagram of the .NET frameworks infrastructure and
    the application models they support'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – A high-level diagram of the .NET frameworks infrastructure and
    the application models they support
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that each framework resides on top of the common infrastructure
    and provides a set of base libraries as well as different application models.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Framework was the first implementation of the CLI. It is the primary development
    platform for Windows Server and client developers. It contains a large class library
    that supports many types of applications. The framework is distributed as a part
    of the operating system and as a result, new versions are serviced through **Windows
    Update**, although standalone installers are also available. Initially, .NET Framework
    was proprietary software developed by Microsoft. In recent years, parts of .NET
    Framework have been open-sourced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the history of .NET Framework, as well as the major
    features available in each release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_1Table_2_01.jpg)![](img/Chapter_1Table_2_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the future, Microsoft intends to unify all .NET frameworks into a single
    one. At the time of writing this book, this is planned to be named .NET 5.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Framework includes the **Common Language Runtime** (**CLR**), which is
    the execution engine of the framework that provides services such as memory management,
    type safety, garbage collection, exception handling, thread management, and others.
    It also includes an implementation of the CLI foundational standard libraries.
    The following is a list of the components of the standard libraries (although
    not all of them):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base Class Library** (**BCL**): It provides types to represent the CLI built-in
    types, simple file access, custom attributes, string handling, formatting, collections,
    streams, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime Infrastructure Library**: It provides services to dynamically load
    types from a stream and other services that allow the compiler to target the CLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflection Library**: It provides services that make it possible to examine
    the structure of types at runtime, instantiate objects, and invoke methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Library**: It provides networking services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended Numerics Library**: It provides support for floating-point and extended-precision
    data types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel Library**: It provides parallelism in simple forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these libraries, the `System.*` or `Microsoft.*` namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: A key aspect of developing in C# for the .NET platform is how memory is managed.
    In general, developers do not have to worry about the lifetime of objects and
    the disposal of memory. Memory management is automatically done by the CLR through
    the **Garbage Collector** (**GC**). The GC handles the allocation of objects on
    the heap and the disposal of memory when heap objects are no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collection is a *non-deterministic process* because it happens on
    a per-need basis and not at some deterministic moments. A detailed description
    of the way the garbage collection works is provided in [*Chapter 9*](B12346_09_Final_JC_ePub.xhtml#_idTextAnchor173),
    *Resource Management*.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Core is a new implementation of the CLI that is cross-platform, open source,
    and modular. It is intended for developing a variety of applications, such as
    web apps, micro-services, libraries, or console apps that run on Windows, Linux,
    and macOS. The .NET Core framework is packaged using NuGet; as a result, it is
    either compiled directly into an application or put into a folder inside the application.
    Therefore, .NET Core applications distribute the framework components directly,
    although a cache system for a centralized deployment, called **runtime package
    store**, is also available starting with version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the VES for .NET Core is called **CoreCLR**. Similarly,
    the implementation of the CLI foundational standard libraries is called **CoreFX**.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core is a part of .NET Core but also runs on the .NET Framework CLR.
    However, an ASP.NET Core app is cross-platform only when targeting .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of version 3.0 in September 2019, developers can create web
    apps, micro-services, desktop applications, machine learning, and AI applications,
    IoT applications, libraries, and console applications using .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about .NET Core in [*Chapter 16*](B12346_16_Final_JC_ePub.xhtml#_idTextAnchor296),
    *C# in Action with .NET Core 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin is a CLI implementation based on **Mono**, which is a cross-platform,
    open source .NET framework. In general, Mono APIs followed the progress of .NET
    Framework and not .NET Core. The framework is intended for writing mobile applications
    that can run on iOS, Android, macOS, and Windows devices.
  prefs: []
  type: TYPE_NORMAL
- en: Applications developed with Xamarin are *native*, which provides similar performance
    to those developed with Objective-C or Swift for iOS and Java or Kotlin for Android.
    Xamarin also provides facilities to directly invoke Objective-C, Java, C, and
    C++ libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin applications are written in C# and use the .NET Base Class Library.
    They can share most of the code, with only a small portion needed to be platform-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information about Xamarin is beyond the scope of this book. If you
    want to learn more about this implementation, you should use additional resources.
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An assembly is a basic unit for deployment, versioning, and security. Assemblies
    come in two forms, either as an `.exe`) or a `.dll`). An assembly is a collection
    of types, resources, and meta-information that forms a logical unit of functionality.
    Assemblies are loaded into memory only if needed. For .NET Framework applications,
    assemblies could either be located in the application private folder or shared
    in the Global Assembly Cache, provided they are strongly-named. For .NET Core
    applications, this latter solution is not available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each assembly contains a manifest that contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The identity of the assembly (such as name and version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file table describing the files that make up the assembly, such as other assemblies
    or resources (such as images)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of assembly references that contains the external dependencies that the
    application needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The identity of an assembly is composed of several parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The **name** of the file where the name should be compliant with the Windows
    Portable Executable file format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `major.minor.build.revision`, such as 1.12.3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **culture** that should be locale-agnostic except in the case of satellite
    assemblies (which are locale-aware assemblies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **public key token**, which is a 64-bit hash of the private key used to
    sign the assembly; signed assemblies have strong names that are meant to provide
    a unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will learn more about assemblies in [*Chapter 11*](B12346_11_Final_SK_ePub.xhtml#_idTextAnchor200),
    *Reflection and Dynamic Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Global Assembly Cache (GAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, .NET Framework assemblies could either
    be stored *locally*, in the application folder, or in *GAC*. This is a machine-wide
    code cache that enables the sharing of assemblies between applications. Since
    the release of .NET Framework 4, the default location for the GAC is `%windir%\Microsoft.NET\assembly`;
    however, previously, the location was `%windir%\assembly`. GAC also enables storing
    multiple versions of the same assembly, which is not actually possible in a private
    folder, since you cannot store multiple files with the same name in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy an assembly to the GAC, you could use the Windows SDK utility tool
    called `gacutil.exe` or an installer that is able to work with the GAC. However,
    an assembly must have a strong name to be deployed to the GAC. A `sn.exe`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about how to sign an assembly, please refer to the following
    document, which describes how to sign an assembly with a strong name: [https://docs.microsoft.com/en-us/dotnet/framework/app-domains/how-to-sign-an-assembly-with-a-strong-name](https://docs.microsoft.com/en-us/dotnet/standard/assembly/sign-strong-name).'
  prefs: []
  type: TYPE_NORMAL
- en: When you add an assembly to GAC, integrity checks are performed on all of the
    files contained by the assembly. This is done to ensure that the assembly has
    not been tampered with. The cryptographic signing ensures that any change to any
    of the files in the assembly invalidates the signature and only someone that has
    access to the private key can resign the assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime package store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GAC is not used for .NET Core assemblies. These are assemblies that can
    run on any platform and not just Windows. Prior to .NET Core 2.0, the only option
    for deployment was the application folder. Since version 2.0, however, it is possible
    to package and deploy applications against a known set of packages that exist
    in the target environment. This enables faster deployment and lower disk space
    requirements. Typically, this store is available at `/usr/local/share/dotnet/store`
    on macOS and Linux and `C:/Program Files/dotnet/store` on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The packages available in the runtime package store are listed in a target manifest
    file that is used while publishing an application. This file has a format that
    is compatible with the project file format (`.csproj`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Detailing the targeting process is beyond the scope of this chapter, but you
    can learn more about the runtime package store by visiting the following link:
    [https://docs.microsoft.com/en-us/dotnet/core/deploying/runtime-store](https://docs.microsoft.com/en-us/dotnet/core/deploying/runtime-store).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic structure of a C# program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about the basics of C# and the .NET runtime. In this
    section, we will write a simple C# program so that we can have a short introduction
    to some of the key elements of a simple program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing a program, you must create a project. For this purpose, you
    should use Visual Studio 2019; alternatively, you could use any other version
    for most of the content of this book. The source code accompanying this book was
    written in Visual Studio 2019 using .NET Core projects. When creating a new project,
    select `chapter_01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Select the Console App (.NET Core) template when creating'
  prefs: []
  type: TYPE_NORMAL
- en: a new project in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Select the Console App (.NET Core) template when creating a new
    project in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'A project with the following content will be automatically created for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Screenshot of Visual Studio and the code generated for the selected
    template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Screenshot of Visual Studio and the code generated for the selected
    template
  prefs: []
  type: TYPE_NORMAL
- en: 'This code represents the minimum a C# program must contain: a single file with
    a single class having a single method called `Main`. You can compile and run the
    project and the message **Hello World!** will be displayed to the console. However,
    to better understand it, let''s look at the actual C# program.'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the program (`using System;`) declares the namespaces that
    we want to use in this program. A namespace contains types and the one used here
    is the core namespace of the base class library.
  prefs: []
  type: TYPE_NORMAL
- en: On the following line, we define our own namespace, called `chapter_01`, which
    contains our code. A namespace is introduced with the `namespace` keyword. In
    this namespace, we define a single class called `Program`. A class is introduced
    with the `class` keyword. Furthermore, this class contains a single method called
    `Main`, with a single argument that is an array of strings called `args`. The
    code within namespaces, types (whether it's a class, struct, interface, or enum),
    and methods is always provided within curly braces `{}`. This method is the entry
    point of the program, which means it's where the execution of a program starts.
    A C# program must have one and only one `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Main` method contains a single line of code. It uses the `System.Console.WriteLine`
    static method to print a text to the console. A static method is a method that
    belongs to a type and not an instance of the type, which means you do not call
    it through an object. The `Main` method is itself a static method, but furthermore,
    it is a special method. Every C# program must have a single static method called
    `Main`, which is considered the entry point of the program and the first to be
    called when the execution of the program begins.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the next chapters, we will learn about namespaces, types, methods,
    and other key features of C#.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked in short at the history of C#. We then explored the
    basic concepts behind the CLI and its constituents, such as CTS, CLS, CIL, and
    VES. Then, we looked at the .NET family of frameworks and briefly discussed .NET
    Framework, .NET Core, and Xamarin. We also talked about assemblies, the GAC (for
    .NET Framework) and the runtime package store (for .NET Core). Finally, we wrote
    our first C# program and looked at its structure.
  prefs: []
  type: TYPE_NORMAL
- en: This overview of the frameworks and the runtime will help you to understand
    the context of writing and executing a C# program and will provide a good background
    when we talk about more advanced features such as reflection, assembly loading,
    or look at the .NET Core framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the basic data types and operators in C#
    and learn how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When was C# first released and what is the current version of the language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Common Language Infrastructure? What are its main components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Common Intermediate Language and how is it related to the Just-In-Time
    compiler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tools can you use to disassembly and explore the assemblies produced by
    the compiler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Common Language Runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Base Class Library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are currently the major .NET frameworks? Which one will no longer be developed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an assembly? What constitutes the identity of an assembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Global Assembly Cache? What about the runtime package store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the minimum a C# program must contain to be executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Chapter_1Table_1_02.png)'
  prefs: []
  type: TYPE_IMG
