- en: Chapter 11. Testing and Monitoring Concurrent Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Software testing** is a critical task of every development process. Every
    application has to fulfill the end user requirements and the testing phase is
    the place to prove this. It has to generate valid results in an acceptable time
    and with the specified format. The main objective of the testing phase is to detect
    as many errors as possible in the software to correct them and increase the global
    quality of the product.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, in the waterfall model, the testing phase begins when the development
    phase is very advanced but nowadays more and more development teams are using
    agile methodologies where the testing phase is integrated into the development
    phase. The main objective is to test the software as soon as possible to detect
    the errors earlier in the process.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there are a lot of tools such as **JUnit** or **TestNG** to automatize
    the execution of tests. Other tools such as **JMeter** allow you to test how many
    users can execute your application at the same time, and there are other tools
    such as **Selenium** that you can use to make integration tests in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing phase is more critical and more difficult in concurrent applications.
    You have two or more threads running at the same time, but you can''t control
    their order of execution. You can do a lot of tests of an application, but you
    can''t guarantee that there isn''t an order of execution of the different threads
    that provokes a race condition or a deadlock. This circumstance also causes difficulty
    in the reproduction of errors. You can find an error that only occurs in certain
    circumstances, so it can be difficult to find its real cause. In this chapter,
    we will cover the following topics to help you to test concurrent applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring concurrency objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring concurrency applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing concurrency applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring concurrency objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the concurrency objects provided by the Java concurrency API include
    methods to know their status. This status can include the number of threads that
    are executing, the number of threads blocked waiting for a condition, the number
    of tasks executed, and so on. In this section, you will learn the most important
    methods you can use and the information you can obtain from them. This information
    can be very useful to detect the cause of an error, especially if it only occurs
    in very rare conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The thread is the most basic element in the Java concurrency API. It allows
    you to implement a raw task. You decide what code is going to execute (extending
    the `Thread` class or implementing the `Runnable` interface), when it starts its
    execution, and how it synchronizes with other tasks of the application. The `Thread`
    class provides some methods to obtain information about a thread. These are the
    most useful methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getId()`: This method returns the identifier of the thread. It''s a `long`
    positive number and it''s unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getName()`: This method returns the name of the thread. By default, it has
    the format `Thread-xxx` but it can be modified in the constructor or using the
    `setName()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPriority()`: This method returns the priority of the thread. By default,
    all the threads have a priority of five but you can change it using the `setPriority()`
    method. Threads with a higher priority may have preference over threads with a
    lower priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getState()`: This method returns the state of the thread. It returns a value
    of `Enum` `Thread.State`, which can take the values: `NEW`, `RUNNABLE`, `BLOCKED`,
    `WAITING`, `TIMED_WAITING`, and `TERMINATED`. You can check the API documentation
    to see the real significance of every state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStackTrace()`: This method returns the stack of calls of this thread as
    an array of `StackTraceElement` objects. You can print this array to know what
    calls have made the thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, you can use a piece of code like this to obtain all the relevant
    information of a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With this block of code, you will obtain an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring a thread](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring a lock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **lock** is one of the basic synchronization elements provided by the Java
    concurrency API. It''s defined in the `Lock` interface and in the `ReentrantLock`
    class. In a basic way, a lock allows you to define a critical section in your
    code, but the `Lock` mechanism is more flexible than other mechanisms as the synchronized
    keyword (for example, you can have different locks to read and write operations
    or have non-linear critical sections). The `ReentrantLock` class has some methods
    that allow you to know the status of a `Lock` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getOwner()`: This method returns a `Thread` object with the thread that currently
    has the lock, that is to say, the thread that is executing the critical section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasQueuedThreads()`: This method returns a `boolean` value to indicate if
    there are threads waiting to acquire this lock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueueLength()`: This method returns an `int` value with the number of threads
    that are waiting to acquire this lock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedThreads()`: This method returns a `Collection<Thread>` object with
    the `Thread` objects that are waiting to acquire this lock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFair()`: This method returns a `boolean` value to indicate the status of
    the fairness attribute. The value of this attribute is used to determine which
    will be the next thread that acquires the lock. You can check the Java API information
    to get a detailed description of this functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLocked()`: This method returns a `boolean` value to indicate if this lock
    is owned by a thread or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getHoldCount()`: This method returns an `int` value with the number of times
    this thread has acquired the lock. The returned value is zero if this thread does
    not hold the lock. Otherwise it returns the number of times the `lock()` method
    was called in the current thread for which the matching `unlock()` method was
    not called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getOwner()` and the `getQueuedThreads()` methods are protected so you don't
    have direct access to them. To solve this problem, you can implement your own
    `Lock` class and implement methods that provide you that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can implement a class named `MyLock` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can use a fragment of code similar to this to obtain all the relevant
    information about a lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this block of code, you will obtain an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring a lock](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring an executor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **executor framework** is a mechanism that allows you to execute concurrent
    tasks without worrying about the creation and management of threads. You can send
    the tasks to the executor. It has an internal pool of threads that re-utilize
    to execute the tasks. The executor also provides a mechanism to control the resources
    consumed by your tasks so you won''t overload the system. The executor framework
    provides the `Executor` and `ExecutorService` interfaces and some classes that
    implement those interfaces. The most basic class that implements them is the `ThreadPoolExecutor`
    class. It provides some methods that allow you to know the status of the executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getActiveCount()`:This method returns the number of threads of the executor
    that are executing tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCompletedTaskCount()`: This method returns the number of tasks that have
    been executed by the executor and have finished its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCorePoolSize()`: This method returns the core number of threads. This number
    determines the minimum number of threads in the pool. Even if there are no tasks
    running in the executor, the pool won''t have less threads than the number returned
    by this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLargestPoolSize()`: This method returns the maximum number of threads that
    have been in the pool of the executor at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMaximumPoolSize()`: This method returns the maximum number of threads that
    can exist in the pool at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns the current number of threads in the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTaskCount()`: This method returns the number of tasks that have been sent
    to the executor including waiting, running, and already completed tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns `true` if the `shutdown()` or `shutdownNow()`
    method has been called and the `Executor` has finished the execution of all its
    pending tasks. This method returns `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminating()`: This method returns `true` if the `shutdown()` or `shutdownNow()`
    method has been called but the executor is still executing tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a fragment of code similar to this to obtain the relevant information
    of a `ThreadPoolExecutor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this block of code, you will obtain an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring an executor](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring the Fork/Join framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Fork/Join Framework** provides a special kind of executor for algorithms
    that can be implemented using the divide and conquer technique. It is based in
    a work-stealing algorithm. You create an initial task that has to process the
    whole problem. This task creates other subtasks that process smaller parts of
    the problem and waits for its finalization. Each task compares the size of the
    sub-problem it has to process with a predefined size. If the size is smaller than
    the predefined size, it solves the problem directly. Otherwise, it splits the
    problem in other subtasks and waits for the results returned by them. The work-stealing
    algorithm takes advantage of the threads that are executing tasks that are waiting
    for the results of their child tasks to execute other tasks. The `ForkJoinPool`
    class provides methods that allow you to obtain its status:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getParallelism()`: This method returns the desired level of parallelism established
    for the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns the number of threads in the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveThreadCount()`: This method returns the number of threads in the
    pool that are currently executing tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRunningThreadCount()`: This method returns the number of threads that are
    not waiting for the finalization of their child tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedSubmissionCount()`: This method returns the number of tasks that
    have been submitted to a pool that haven''t started their execution yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedTaskCount()`: This method returns the number of tasks in the work-stealing
    queues of this pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasQueuedSubmissions()`: This method returns `true` if there are tasks that
    have been submitted to the pool that haven''t started their execution yet. It
    returns `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStealCount()`: This method returns the number of times the Fork/Join pool
    has executed the work-stealing algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns `true` if the Fork/Join pool has finished
    its execution. It returns `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a fragment of code like this to obtain the relevant information
    of a `ForkJoinPool` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `pool` is a `ForkJoinPool` object (for example, `ForkJoinPool.commonPool()`).
    With this block of code, you will obtain an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring the Fork/Join framework](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring a Phaser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Phaser** is a synchronization mechanism that allows you to execute tasks
    that can be divided into phases. This class also includes some methods to obtain
    the status of the Phaser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getArrivedParties()`: This method returns the number of registered parties
    that have finished the current phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUnarrivedParties()`: This method returns the number of registered parties
    that haven''t finished the current phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPhase()`: This method returns the number of the current phase. The number
    of the first phase is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRegisteredParties()`: This method returns the number of registered parties
    in the Phaser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns a `boolean` value to indicate if the
    Phaser has finished its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a fragment of code like this to obtain the relevant information
    of a Phaser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this block of code, you will obtain an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring a Phaser](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stream mechanism is one of the most important new features introduced in
    Java 8\. It allows you to process big collections of data in a concurrent way,
    transforming that data and implementing the map and reduce programming model in
    an easy way. This class doesn't provide any method (except the `isParallel()`
    method that returns if the stream is parallel or not) to know the status of the
    stream, but includes a method named `peek()` that you can include in the pipeline
    of methods to write log information about the operations or transformations that
    you are executing in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code calculates the average of the square of the first 999
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `peek()` method writes the numbers the stream is processing and the
    second one the square of those numbers. If you execute this code, as you''re executing
    the stream in a concurrent way, you will obtain an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring a stream](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring concurrency applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you implement Java applications, you normally use an IDE such as Eclipse
    or NetBeans to create your projects and write your source code. But the **JDK**
    (short for **Java Development Kit**) includes tools you can use to compile, execute,
    or generate Javadoc documents. One of those tools is **Java VisualVM**, which
    is a graphical tool that shows you information about the applications that are
    executing in a JVM. You can find it in the bin directory of your JDK installation
    (`jvisualvm.exe`). You can also install a plugin for Eclipse (Eclipse launcher
    for VisualVM) to integrate its functionality on Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute it, you will see a window similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring concurrency applications](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the left side of the screen, you can see the **Applications** tab where
    you will see all the Java applications that are currently running by the current
    user in your system. If you make a double-click in one of those applications,
    you will see five tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview**: This tab shows general information about the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor**: This tab show graphical information about the CPU, memory, classes,
    and threads used by the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threads**: This tab shows the evolution over time of the threads of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sampler**: This tab shows you information about the utilization of memory
    and CPU by the application. It''s similar to the **Profiler** tab, but it obtains
    the data in a different way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiler**: This tab shows you information about the utilization of memory
    and CPU by the application. It''s similar to the **Sampler** tab, but it obtains
    the data in a different way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, you will learn what information you can obtain in every
    tab. You can consult the complete documentation about this tool at [https://visualvm.java.net/docindex.html](https://visualvm.java.net/docindex.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Overview tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned before, this tab shows you general information about the application.
    This information includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PID**: The process ID of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host**: The name of the machine that is executing the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main class**: The full name of the class that implements the `main()` method
    you''re executing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arguments**: The list of arguments you pass to the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVM**: The version of the JVM that is executing the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java**: The version of Java you''re running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Home**: The location of the JDK in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVM Flags**: Flags used with the JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVM Arguments**: This tab shows you the arguments we (or the IDE) passed
    to the JVM to execute the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System properties**: This tab shows you the properties and the values of
    the properties of the system. You can get this information using the `System.getProperties()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s the default tab when you access the data of an application and has an
    appearance similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Overview tab](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Monitor tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, this tab shows you graphical information about the
    CPU, memory, classes, and threads used by the application. You can see the evolution
    of these metrics over time. The appearance of this tab is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Monitor tab](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the upper-right corner, you have some checkboxes to select the information
    you want to see. The **CPU** graphic shows you the percentage of CPU used by the
    application. The **Heap** graphic shows you the total size of the heap and the
    size of that heap used by the application. In this part, you can see the same
    information about the **Metaspace** (the memory zone used by the JVM to store
    the classes). The **Classes** graphic shows you the number of classes used by
    the application and the **Threads** graphic shows you the number of threads that
    are running inside the application. You can also use two buttons in this tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perform GC**: It performs a garbage collection in the application immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap Dump**: It allows you to save the current status of the application
    to check it later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you create a heap dump, you will have a new tab with its information.
    Its appearance is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Monitor tab](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You have different sub-tabs to consult the status of the application in the
    moment you did the heap dump.
  prefs: []
  type: TYPE_NORMAL
- en: The Threads tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, in the **Threads** tab, you can see the evolution
    of the threads of the application over time. It shows you the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Live threads**: Number of threads in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daemon threads**: Number of threads marked as daemon threads in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeline**: The evolution of threads over time including the status of the
    threads (using a color code), the time the thread has been running, and the time
    the thread has existed. On the right of the column `Total`, you can see an arrow.
    If you click it, you can select the columns you see in this tab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its appearance is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Threads tab](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This tab also has the **Thread Dump** button. If you click this button, you
    will see a new tab with the stack trace of every thread running in the application.
    Its appearance is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Threads tab](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Sampler tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Sampler** tab shows you information about the utilization of CPU and memory
    made by your application. To obtain this information, it obtains dumps of all
    the threads of the application and processes that dump. This tab is similar to
    the **Profiler** tab but, as you will see in the next section, the difference
    between them is the way they are used to obtain the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tab''s appearance is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Sampler tab](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You have two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU**: This button is used to obtain information about the use of CPU. If
    you click this button, you will see two sub-tabs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU samples**: In this tab, you will see the utilization of CPU of the classes
    of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread CPU time**: In this tab, you will see the utilization of CPU per thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory**: This button is used to obtain information about the use of memory.
    If you click this button, you will see another two sub-tabs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap histogram**: In this tab, you will see the number of bytes allocated
    by data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per thread allocations**: In this tab, you can see the amount of memory used
    per every thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Profiler tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Profiler** tab shows you information about the CPU and memory utilization
    by the application using the instrumentation API. Basically, this API adds some
    byte-codes to the methods when the JVM loads them to obtain this information.
    This information is updated over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tab''s appearance is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Profiler tab](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By default, this tab doesn't obtain any information. You have to start a profiling
    session. To make this, you can use the **CPU** button to obtain information about
    the CPU utilization. This includes the execution time per method and the number
    of invocations to those methods. You can also use the **Memory** button. In this
    case, you can see the amount of memory and the number of objects per data type.
  prefs: []
  type: TYPE_NORMAL
- en: You can stop the profiling session when you don't need to obtain more information
    using the **Stop** button.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrency applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing concurrency applications is a hard task. The threads of your application
    run in your computer without any guarantee of their execution order (except the
    synchronization mechanisms that you have included) so it''s very difficult (impossible
    most of the time) to test all the circumstances that can occur. You can have errors
    impossible to reproduce because it only happens under rare or unique circumstances
    or errors that happen in one machine but not in others due to the number of cores
    within the CPU. To detect and reproduce this situation, you can use different
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug**: You can use the debugger to debug the application. This process
    will be very tedious if you have only a few threads in the application and you
    have to go step by step in every thread. You can configure Eclipse or NetBeans
    to test concurrent applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MultithreadedTC**: This is an archived project of **Google Code** that can
    be used to force the order of execution in a concurrent application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java PathFinder**: This is an execution environment used by NASA for verification
    of Java programs. It includes support for validating concurrent applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testin**g: You can create a bunch of unit-tests (using JUnit or TestNG)
    and launch every test, for example, 1,000 times. If every test succeeds then even
    if your application has races, their chance is not very high and probably acceptable
    for production. You can include assertions in your code to verify that it hasn''t
    any race condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, you will see basic examples of testing concurrent
    applications with the MultithreadedTC and Java PathFinder tools.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrent applications with MultithreadedTC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MultithreadedTC is an archived project that you can download from [http://code.google.com/p/multithreadedtc/](http://code.google.com/p/multithreadedtc/).
    Its latest version is from 2007, but you can still use it to test small concurrent
    applications or parts of big applications independently. You can't use it to test
    real tasks or threads but you can use it to test different orders of execution
    to check if they provoke race conditions or deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: It's based in an internal clock that works with ticks that allows you to control
    the order of execution of different threads to test if that order of execution
    can cause any concurrency problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you need to associate two libraries to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The MultithreadedTC library**: The latest version is the 1.01 version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The JUnit library**: We have tested this example with the 4.12 version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement a test using the MultithreadedTC library, you have to extend the
    `MultithreadedTestCase` class that extends the `Assert` class of the JUnit library.
    You can implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()`: This method will be executed at the beginning of the test execution.
    You can override it if you need to execute initialization code for the creation
    of data objects, database connections, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish()`: This method will be executed at the end of the test execution.
    You can override it to implement the validations of the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threadXXX()`: You have to implement a method whose name begins with the `thread`
    keyword per every thread you have in your test. For example, if you want to make
    a test with three threads, you will have three methods in your class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MultithreadedTestCase` provides the `waitForTick()` method. This method
    receives as a parameter the number of ticks you wait for. This method sleeps the
    calling thread until the internal clock arrives at that tick.
  prefs: []
  type: TYPE_NORMAL
- en: The first tick is the tick number `0`. The MultithreadedTC framework checks
    every certain time the status of the test threads. If all the running threads
    are waiting in the `waitForTick()` method, it increments the tick number and wakes
    up all the threads that are waiting for that tick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of its use. Suppose you want to test a `Data` object
    with an internal `int` attribute. You want a thread that increments the value
    and a thread that decrements the value. You can create a class named `TestClassOk`
    extending the `MultithreadedTestCase` class. We use three attributes with the
    data object: the amount we will use to increment and decrement the data and the
    initial value of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement two methods to simulate the execution of two threads. The first
    thread is implemented in the `threadAdd()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It reads the value of the data, increments its value, and writes again the
    value of the data. The second thread is implemented in the `threadSub()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we wait for the tick `1`. Then, we get the value of the data, decrement
    its value, and rewrite the value of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the test, we can use the `runOnce()` method of the `TestFramework`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the execution of the test begins, the two threads (`threadAdd()` and `threadSub()`)
    are launched in a concurrent way. `threadAdd()` begins the execution of its code
    and `threadSub()` waits in the `waitForTick()` method. When `threadAdd()` finishes
    its execution, the internal clock of the MultithreadedTC detects that the only
    thread running is waiting in the `waitForTick()` method, so it increments the
    tick value to `1` and wakes up the thread that executes its code.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, you can see the output of the execution of this
    example. In this case, everything goes well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing concurrent applications with MultithreadedTC](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'But you can change the order of execution of the threads to provoke an error.
    For example, you can implement the following order that will provoke a race condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the order of execution makes sure that both threads first read
    the value of the data and then makes its operation so the final result won't be
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the result of the execution of this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing concurrent applications with MultithreadedTC](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the `assertEquals()`method throws an exception because the expected
    and actual values are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: The main limitation of this library is that it is only useful to test basic
    concurrent code and, as you implement the tests, can't be used to test real `Thread`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrent applications with Java Pathfinder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Java Pathfinder** or JPF is an open source execution environment from NASA
    that can be used to verify Java applications. It includes its own virtual machine
    to execute the Java byte code. Internally, it detects the points of the code where
    there can be more than one execution path and executes all the possibilities.
    In concurrent applications, this means that it will execute all the possible execution
    orders between the threads that run in your application. It also includes tools
    that allow you to detect race conditions and deadlocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of this tool is that it allow you to completely test your
    concurrent application to guarantee that it is free of race conditions and deadlocks.
    The inconvenient features of this tool are:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to install it from its source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application is complex, you will have thousands of possible paths of
    execution and the test will be very long (maybe a lot of hours if the application
    is complex)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will show you how to test a concurrent application
    using Java Pathfinder.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Java Pathfinder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned earlier, you have to install JPF from its source code. That
    code is in a Mercurial repository so the first step is to install Mercurial and,
    as we will use the Eclipse IDE, the Mercurial plugin for Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Mercurial from [https://www.mercurial-scm.org/wiki/Download](https://www.mercurial-scm.org/wiki/Download).
    You download the installation program that provides an assistant to install Mercurial
    in your computer. Maybe you will need to restart your system after the installation
    of Mercurial.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the Mercurial plugin for Eclipse using `Help > Install new
    software` from the Eclipse menu and using the URL [http://mercurialeclipse.eclipselabs.org.codespot.com/hg.wiki/update_site/stable](http://mercurialeclipse.eclipselabs.org.codespot.com/hg.wiki/update_site/stable)
    as the URL to look for the software. Follow the same steps as with other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: You can also install a JPF plugin for Eclipse. You can download from [http://babelfish.arc.nasa.gov/trac/jpf/wiki/install/eclipse-plugin](http://babelfish.arc.nasa.gov/trac/jpf/wiki/install/eclipse-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: Now you can access the Mercurial repository explorer perspective and add the
    repository of Java Pathfinder. We will use only the core module that is stored
    in [http://babelfish.arc.nasa.gov/hg/jpf/jpf-core](http://babelfish.arc.nasa.gov/hg/jpf/jpf-core).
    You don't need a username or password to access the repository. Once you have
    created the repository, you can right-click over the repository and select the
    **Clone repository** option to download the source code in your computer. The
    option will open a window to select some options, but you can leave the default
    values and click on the **Next** button. Then you have to choose the version you
    want to load. Leave the default value and click on the **Next** button. Finally,
    click on the **Finish** button to finish the download process. Eclipse will automatically
    run `ant` to compile the project. If you have any compilation problems, you have
    to solve them and relaunch `ant`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, you will have a project named `jpf-core` in your workspace
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Java Pathfinder](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The last configuration step is to create a file named `site.properties` with
    the configuration of JPF. If you access the configuration window in **Window**
    | **Preferences** and select the **JPF Preferences** option, you will see the
    route where the JPF plugin is looking for that file. You can change that route
    if you want.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Java Pathfinder](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we will only use the core module, the file will only content the route to
    the `jpf-core` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running Java Pathfinder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have installed JPF, let's see how we can use it to test a concurrent
    application. First, we have to implement a concurrent application. In our case,
    we will use a `Data` class with an internal `int` value. It will be initialized
    with `0` and will have an `increment()` method to increment the value.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will have a task named `NumberTask` that implements the `Runnable`
    interface that will increment 10 times the value of a `Data` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have the `MainNumber` class that implements the `main()` method.
    We will launch two `NumberTasks` objects that will modify the same `Data` object.
    Finally, we will obtain the final value of the `Data` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well and no race conditions occur, the final result will
    be 200, but our code doesn't use any synchronization mechanism so it's possible
    that this circumstance occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to execute this application with JPF, we need to create a configuration
    file inside the project with the `.jpf` extension. For example, we have created
    the `NumberJPF.jpf` file with the most basic configuration file we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We modify the class path of JPF adding the `bin` directory of our project and
    indicate the main class of our application. Now, we're ready to execute the application
    through JPF. To make this, we right-click over the `.jpf` file and select the
    **Verify** option. We will see how in the console we can see a lot of output messages.
    Every output message comes from a different execution path of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Java Pathfinder](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When JPF ends the execution of all the possible execution paths, it shows statistical
    information about the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Java Pathfinder](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The JPF execution says that no errors were detected but we can see that most
    of the results are different from 200, so our application has race conditions
    as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the introduction of this section, we said that JPF provides tools to detect
    race conditions and deadlocks. JPF implements this as a `Listener` mechanism that
    implements the `Observer` pattern to respond to certain events that occur in the
    execution of the code. For example, we can use the following listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PreciseRaceDetector`: Use this listener to detect race conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeadlockAnalyzer`: Use this listener to detect deadlock situations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoverageAnalyzer`: Use this listener to write coverage information at the
    end of the execution of JPF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can configure the listeners you want to use in the `.jpf` file with the
    configuration of an execution. For example, we have extended the previous test
    in the `NumberListenerJPF.jpf` file by adding the `PreciseRaceDetector` and the
    `CoverageAnalyzer` listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this configuration file through JPF with the **Verify** option,
    you will see as the application ends when it detects the first race condition
    showing in the console information about this circumstance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Java Pathfinder](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will also see how the `CoverageAnalyzer` listener also writes the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Java Pathfinder](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: JPF is a very powerful application that includes more listeners and more extension
    mechanisms. You can find its whole documentation at [http://babelfish.arc.nasa.gov/trac/jpf/wiki](http://babelfish.arc.nasa.gov/trac/jpf/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing concurrent applications is a very hard task. There's no guarantee of
    the order of execution of the threads (unless the synchronization mechanisms have
    been introduced in your application) so you should test many more different situations
    than in a serial application. Sometimes, you will have errors in your application
    that you can reproduce because they only occur in very rare situations, and sometimes
    you will have errors that only occur in specific machines because of their hardware
    or software configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have learned some mechanisms that can help you to test
    concurrency applications more easily. First, you have learned how to obtain information
    about the status of the most important components of the Java concurrency API
    as `Thread`, `Lock`, `Executor` or `Stream`. This information can be very useful
    if you need to detect the cause of an error. Then, you learned how to use Java
    VisualVM to monitor Java applications in general and concurrent applications in
    particular. Finally, you learned to use two different tools to test concurrent
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Through the chapters of this book, you have learned how to use the most important
    components of the Java concurrency API as the executor framework, the `Phaser`
    class, the Fork/Join framework, and the new stream API included in Java 8 to support
    functional-style operations on streams of elements implementing real-world applications
    from the machine learning, data mining, or natural language processing world.
    You have also learned how to work with concurrency data structures and synchronization
    mechanisms and how to synchronize different concurrent blocks that are part of
    a bigger application. Finally, you learned the design principles of concurrent
    applications and how to test them, two critical factors to guarantee success using
    these kinds of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing concurrent applications is a difficult task but also an exciting
    challenge. I hope this book has been helpful for you to meet this challenge successfully.
  prefs: []
  type: TYPE_NORMAL
