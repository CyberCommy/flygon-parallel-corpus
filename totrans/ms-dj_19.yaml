- en: Chapter 19. Security in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensuring that the sites you build are secure is of the utmost importance to
    a professional web applications developer.
  prefs: []
  type: TYPE_NORMAL
- en: The Django framework is now very mature and the majority of common security
    issues are addressed in some way by the framework itself, however no security
    measure is 100% guaranteed and there are new threats emerging all the time, so
    it's up to you as a web developer to ensure that your websites and applications
    are secure.
  prefs: []
  type: TYPE_NORMAL
- en: web security is too large a subject to cover in depth in a single book chapter.
    This chapter includes an overview of Django's security features and advice on
    securing a Django-powered site that will protect your sites 99% of the time, but
    it's up to you to keep abreast of changes in web security.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information on web security, Django's archive of security
    issues(for more information visit [https://docs.djangoproject.com/en/1.8/releases/security/](https://docs.djangoproject.com/en/1.8/releases/security/))
    is a good place to start, along with Wikipedia's web application security page
    ([https://en.wikipedia.org/wiki/web_application_security](https://en.wikipedia.org/wiki/web_application_security)).
  prefs: []
  type: TYPE_NORMAL
- en: Django's built in security features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross Site Scripting (XSS) protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cross Site Scripting** (**XSS**) attacks allow a user to inject client side
    scripts into the browsers of other users.'
  prefs: []
  type: TYPE_NORMAL
- en: This is usually achieved by storing the malicious scripts in the database where
    it will be retrieved and displayed to other users, or by getting users to click
    a link which will cause the attacker's JavaScript to be executed by the user's
    browser. However, XSS attacks can originate from any untrusted source of data,
    such as cookies or web services, whenever the data is not sufficiently sanitized
    before including in a page.
  prefs: []
  type: TYPE_NORMAL
- en: Using Django templates protects you against the majority of XSS attacks. However,
    it is important to understand what protections it provides and its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django templates escape specific characters which are particularly dangerous
    to HTML. While this protects users from most malicious input, it is not entirely
    foolproof. For example, it will not protect the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If `var` is set to `'class1 onmouseover=javascript:func()'`, this can result
    in unauthorized JavaScript execution, depending on how the browser renders imperfect
    HTML. (Quoting the attribute value would fix this case).
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to be particularly careful when using `is_safe` with custom
    template tags, the `safe` template tag, `mark_safe`, and when `autoescape` is
    turned off.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if you are using the template system to output something other
    than HTML, there may be entirely separate characters and words which require escaping.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be very careful when storing HTML in the database, especially
    when that HTML is retrieved and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Cross Site Request Forgery (CSRF) protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cross Site Request Forgery** (**CSRF**) attacks allow a malicious user to
    execute actions using the credentials of another user without that user''s knowledge
    or consent.'
  prefs: []
  type: TYPE_NORMAL
- en: Django has built-in protection against most types of CSRF attacks, providing
    you have enabled and used it where appropriate. However, as with any mitigation
    technique, there are limitations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it is possible to disable the CSRF module globally or for particular
    views. You should only do this if you know what you are doing. There are other
    limitations if your site has subdomains that are outside of your control.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection works by checking for a nonce in each `POST` request. This ensures
    that a malicious user cannot simply replay a form `POST` to your website and have
    another logged in user unwittingly submit that form. The malicious user would
    have to know the nonce, which is user specific (using a cookie).
  prefs: []
  type: TYPE_NORMAL
- en: When deployed with HTTPS, `CsrfViewMiddleware` will check that the HTTP referrer
    header is set to a URL on the same origin (including subdomain and port). Because
    HTTPS provides additional security, it is imperative to ensure connections use
    HTTPS where it is available by forwarding insecure connection requests and using
    HSTS for supported browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Be very careful with marking views with the `csrf_exempt` decorator unless it
    is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Django's CSRF middleware and template tag provides easy-to-use protection against
    Cross Site Request Forgeries.
  prefs: []
  type: TYPE_NORMAL
- en: The first defense against CSRF attacks is to ensure that `GET` requests (and
    other 'safe' methods, as defined by 9.1.1 Safe Methods, HTTP 1.1, RFC 2616 (for
    more information visit [https://tools.ietf.org/html/rfc2616.html#section-9.1.1](https://tools.ietf.org/html/rfc2616.html#section-9.1.1)))
    are side-effect free. Requests via 'unsafe' methods, such as `POST`, `PUT` and
    `DELETE`, can then be protected by following the steps below.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To take advantage of CSRF protection in your views, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The CSRF middleware is activated by default in the `MIDDLEWARE_CLASSES` setting.
    If you override that setting, remember that `'django.middleware.csrf.CsrfViewMiddleware'`
    should come before any view middleware that assume that CSRF attacks have been
    dealt with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you disabled it, which is not recommended, you can use `csrf_protect()` on
    particular views you want to protect (see below).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In any template that uses a `POST` form, use the `csrf_token` tag inside the
    `<form>` element if the form is for an internal URL, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This should not be done for `POST` forms that target external URLs, since that
    would cause the CSRF token to be leaked, leading to a vulnerability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the corresponding view functions, ensure that the `''django.template.context_processors.csrf''`
    context processor is being used. Usually, this can be done in one of two ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `RequestContext`, which always uses `'django.template.context_processors.csrf'`
    (no matter what template context processors are configured in the `TEMPLATES`
    setting). If you are using generic views or contrib apps, you are covered already,
    since these apps use `RequestContext` throughout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Manually import and use the processor to generate the CSRF token and add it
    to the template context. for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may want to write your own `render_to_response()` wrapper that takes care
    of this step for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AJAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the above method can be used for AJAX POST requests, it has some inconveniences:
    you have to remember to pass the CSRF token in as POST data with every POST request.
    For this reason, there is an alternative method: on each `XMLHttpRequest`, set
    a custom `X-CSRFToken` header to the value of the CSRF token. This is often easier,
    because many JavaScript frameworks provide hooks that allow headers to be set
    on every request.'
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, you must get the CSRF token itself. The recommended source
    for the token is the `csrftoken` cookie, which will be set if you've enabled CSRF
    protection for your views as outlined above.
  prefs: []
  type: TYPE_NORMAL
- en: The CSRF token cookie is named `csrftoken` by default, but you can control the
    cookie name via the `CSRF_COOKIE_NAME` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Acquiring the token is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code could be simplified by using the jQuery cookie plugin ([http://plugins.jquery.com/cookie/](http://plugins.jquery.com/cookie/))
    to replace `getCookie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CSRF token is also present in the DOM, but only if explicitly included using
    `csrf_token` in a template. The cookie contains the canonical token; the `CsrfViewMiddleware`
    will prefer the cookie to the token in the DOM. Regardless, you're guaranteed
    to have the cookie if the token is present in the DOM, so you should use the cookie!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your view is not rendering a template containing the `csrf_token` template
    tag, Django might not set the CSRF token cookie. This is common in cases where
    forms are dynamically added to the page. To address this case, Django provides
    a view decorator which forces setting of the cookie: `ensure_csrf_cookie()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you''ll have to actually set the header on your AJAX request, while
    protecting the CSRF token from being sent to other domains using `settings.crossDomain`
    in jQuery 1.5.1 and newer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Other template engines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using a different template engine than Django's built-in engine, you can
    set the token in your forms manually after making sure it's available in the template
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the Jinja2 template language, your form could contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can use JavaScript similar to the AJAX code above to get the value of the
    CSRF token.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than adding `CsrfViewMiddleware` as a blanket protection, you can use
    the `csrf_protect` decorator, which has exactly the same functionality, on particular
    views that need the protection. It must be used both on views that insert the
    CSRF token in the output, and on those that accept the `POST` form data. (These
    are often the same view function, but not always).
  prefs: []
  type: TYPE_NORMAL
- en: Use of the decorator by itself is not recommended, since if you forget to use
    it, you will have a security hole. The *belt and braces* strategy of using both
    is fine, and will incur minimal overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '`django.views.decorators.csrf.csrf_protect(view)`'
  prefs: []
  type: TYPE_NORMAL
- en: Decorator that provides the protection of `CsrfViewMiddleware` to a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you are using class-based views, you can refer to Decorating class-based
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Rejected requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, a *403 Forbidden* response is sent to the user if an incoming request
    fails the checks performed by `CsrfViewMiddleware`. This should usually only be
    seen when there is a genuine Cross Site Request Forgery, or when, due to a programming
    error, the CSRF token has not been included with a `POST` form.
  prefs: []
  type: TYPE_NORMAL
- en: The error page, however, is not very friendly, so you may want to provide your
    own view for handling this condition. To do this, simply set the `CSRF_FAILURE_VIEW`
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The CSRF protection is based on the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A CSRF cookie that is set to a random value (a session independent nonce, as
    it is called), which other sites will not have access to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This cookie is set by `CsrfViewMiddleware`. It is meant to be permanent, but
    since there is no way to set a cookie that never expires, it is sent with every
    response that has called `django.middleware.csrf.get_token()` (the function used
    internally to retrieve the CSRF token).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hidden form field with the name *csrfmiddlewaretoken* present in all outgoing
    POST forms. The value of this field is the value of the CSRF cookie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This part is done by the template tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all incoming requests that are not using HTTP `GET`, `HEAD`, `OPTIONS`,
    or `TRACE`, a CSRF cookie must be present, and the *csrfmiddlewaretoken* field
    must be present and correct. If it isn't, the user will get a 403 error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This check is done by `CsrfViewMiddleware`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, for HTTPS requests, strict referrer checking is done by `CsrfViewMiddleware`.
    This is necessary to address a Man-In-The-Middle attack that is possible under
    HTTPS when using a session independent nonce, due to the fact that HTTP 'Set-Cookie'
    headers are (unfortunately) accepted by clients that are talking to a site under
    HTTPS. (Referer checking is not done for HTTP requests because the presence of
    the Referer header is not reliable enough under HTTP.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures that only forms that have originated from your website can be used
    to `POST` data back.
  prefs: []
  type: TYPE_NORMAL
- en: It deliberately ignores `GET` requests (and other requests that are defined
    as 'safe' by RFC 2616). These requests ought never to have any potentially dangerous
    side effects, and so a CSRF attack with a `GET` request ought to be harmless.
    RFC 2616 defines `POST`, `PUT`, and `DELETE` as 'unsafe', and all other methods
    are assumed to be unsafe, for maximum protection.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the `csrf_token` template tag is used by a template (or the `get_token`
    function is called some other way), `CsrfViewMiddleware` will add a cookie and
    a `Vary: Cookie` header to the response. This means that the middleware will play
    well with the cache middleware if it is used as instructed (`UpdateCacheMiddleware`
    goes before all other middleware).'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you use cache decorators on individual views, the CSRF middleware
    will not yet have been able to set the `Vary` header or the CSRF cookie, and the
    response will be cached without either one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, on any views that will require a CSRF token to be inserted you
    should use the `django.views.decorators.csrf.csrf_protect()` decorator first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you are using class-based views, you can refer to decorating class-based
    views in the Django documentation ([https://docs.djangoproject.com/en/1.8/topics/class-based-views/intro/#decorating-class-based-views](https://docs.djangoproject.com/en/1.8/topics/class-based-views/intro/#decorating-class-based-views)).
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CsrfViewMiddleware` will usually be a big hindrance to testing view functions,
    due to the need for the CSRF token which must be sent with every `POST` request.
    For this reason, Django's HTTP client for tests has been modified to set a flag
    on requests which relaxes the middleware and the `csrf_protect` decorator so that
    they no longer rejects requests. In every other respect (for example, sending
    cookies and so on), they behave the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for some reason, you want the test client to perform CSRF checks, you can
    create an instance of the test client that enforces CSRF checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subdomains within a site will be able to set cookies on the client for the whole
    domain. By setting the cookie and using a corresponding token, subdomains will
    be able to circumvent the CSRF protection. The only way to avoid this is to ensure
    that subdomains are controlled by trusted users (or, are at least unable to set
    cookies).
  prefs: []
  type: TYPE_NORMAL
- en: Note that even without CSRF, there are other vulnerabilities, such as session
    fixation, that make giving subdomains to untrusted parties a bad idea, and these
    vulnerabilities cannot easily be fixed with current browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Edge cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain views can have unusual requirements that mean they don't fit the normal
    pattern envisaged here. A number of utilities can be useful in these situations.
    The scenarios they might be needed in are described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples below assume you are using function-based views. If you are working
    with class-based views, you can refer to decorating class-based views in the Django
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: django.views.decorators.csrf.csrf_exempt(view)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most views require CSRF protection, but a few do not. Rather than disabling
    the middleware and applying `csrf_protect` to all the views that need it, enable
    the middleware and use `csrf_exempt()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This decorator marks a view as being exempt from the protection ensured by
    the middleware. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: django.views.decorators.csrf.requires_csrf_token(view)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are cases when `CsrfViewMiddleware.process_view` may not have run before
    your view is run-404 and 500 handlers, for example-but you still need the CSRF
    token in a form.
  prefs: []
  type: TYPE_NORMAL
- en: Normally the `csrf_token` template tag will not work if `CsrfViewMiddleware.process_view`
    or an equivalent like `csrf_protect` has not run. The view decorator `requires_csrf_token`
    can be used to ensure the template tag does work. This decorator works similarly
    to `csrf_protect`, but never rejects an incoming request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There may also be some views that are unprotected and have been exempted by
    `csrf_exempt`, but still need to include the CSRF token. In these cases, use `csrf_exempt()`
    followed by `requires_csrf_token()`. (that is, `requires_csrf_token` should be
    the innermost decorator).
  prefs: []
  type: TYPE_NORMAL
- en: A final example is where a view needs CSRF protection under one set of conditions
    only, and mustn't have it for the rest of the time. A solution is to use `csrf_exempt()`
    for the whole view function, and `csrf_protect()` for the path within it that
    needs protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: django.views.decorators.csrf.ensure_csrf_cookie(view)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This decorator forces a view to send the CSRF cookie. A scenario where this
    would be used is if a page makes a POST request via AJAX, and the page does not
    have an HTML form with a `csrf_token` that would cause the required CSRF cookie
    to be sent. The solution would be to use `ensure_csrf_cookie()` on the view that
    sends the page.
  prefs: []
  type: TYPE_NORMAL
- en: Contrib and reusable apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because it is possible for the developer to turn off the `CsrfViewMiddleware`,
    all relevant views in contrib apps use the `csrf_protect` decorator to ensure
    the security of these applications against CSRF. It is recommended that the developers
    of other reusable apps that want the same guarantees also use the `csrf_protect`
    decorator on their views.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A number of settings can be used to control Django''s CSRF behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CSRF_COOKIE_AGE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSRF_COOKIE_DOMAIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSRF_COOKIE_HTTPONLY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSRF_COOKIE_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSRF_COOKIE_PATH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSRF_COOKIE_SECURE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSRF_FAILURE_VIEW`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Appendix D](apd.xhtml "Appendix D. Settings"), *Settings*, for more information
    on each of these settings.
  prefs: []
  type: TYPE_NORMAL
- en: SOL injection protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL injection is a type of attack where a malicious user is able to execute
    arbitrary SQL code on a database. This can result in records being deleted or
    data leakage.
  prefs: []
  type: TYPE_NORMAL
- en: By using Django's querysets, the resulting SQL will be properly escaped by the
    underlying database driver. However, Django also gives developers power to write
    raw queries or execute custom SQL. These capabilities should be used sparingly
    and you should always be careful to properly escape any parameters that the user
    can control. In addition, you should exercise caution when using `extra()`.
  prefs: []
  type: TYPE_NORMAL
- en: Clickjacking protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clickjacking is a type of attack where a malicious site wraps another site in
    a frame. This type of attack occurs when a malicious site tricks a user into clicking
    on a concealed element of another site which they have loaded in a hidden frame
    or iframe.
  prefs: []
  type: TYPE_NORMAL
- en: Django contains clickjacking protection in the form of the `X-Frame-Options
    middleware` which in a supporting browser can prevent a site from being rendered
    inside a frame. It is possible to disable the protection on a per view basis or
    to configure the exact header value sent.
  prefs: []
  type: TYPE_NORMAL
- en: The middleware is strongly recommended for any site that does not need to have
    its pages wrapped in a frame by third party sites, or only needs to allow that
    for a small section of the site.
  prefs: []
  type: TYPE_NORMAL
- en: An example of clickjacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose an online store has a page where a logged in user can click **Buy Now**
    to purchase an item. A user has chosen to stay logged into the store all the time
    for convenience. An attacker site might create an **I Like Ponies** button on
    one of their own pages, and load the store's page in a transparent `iframe` such
    that the **Buy Now** button is invisibly overlaid on the **I Like Ponies** button.
    If the user visits the attacker's site, clicking **I Like Ponies** will cause
    an inadvertent click on the **Buy Now** button and an unknowing purchase of the
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing clickjacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern browsers honor the X-Frame-Options (for more information visit [https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header](https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header))
    HTTP header that indicates whether or not a resource is allowed to load within
    a frame or iframe. If the response contains the header with a value of `SAMEORIGIN`
    then the browser will only load the resource in a frame if the request originated
    from the same site. If the header is set to `DENY` then the browser will block
    the resource from loading in a frame no matter which site made the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides a few simple ways to include this header in responses from
    your site:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple middleware that sets the header in all responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of view decorators that can be used to override the middleware or to only
    set the header for certain views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting X-Frame-Options for all responses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To set the same `X-Frame-Options` value for all responses in your site, put
    `''django.middleware.clickjacking.XFrameOptionsMiddleware''` to `MIDDLEWARE_CLASSES`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This middleware is enabled in the settings file generated by `startproject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the middleware will set the `X-Frame-Options` header to `SAMEORIGIN`
    for every outgoing `HttpResponse`. If you want `DENY` instead, set the `X_FRAME_OPTIONS`
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the middleware there may be some views where you do not want the
    `X-Frame-Options` header set. For those cases, you can use a view decorator that
    tells the middleware not to set the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Setting X-Frame-Options per view
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To set the `X-Frame-Options` header on a per view basis, Django provides these
    decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can use the decorators in conjunction with the middleware. Use
    of a decorator overrides the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `X-Frame-Options` header will only protect against clickjacking in a modern
    browser. Older browsers will quietly ignore the header and need other clickjacking
    prevention techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers that support X-Frame-Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internet Explorer 8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox 3.6.9+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opera 10.5+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari 4+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome 4.1+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL/HTTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always better for security, though not always practical in all cases,
    to deploy your site behind HTTPS. Without this, it is possible for malicious network
    users to sniff authentication credentials or any other information transferred
    between client and server, and in some cases-active network attackers-to alter
    data that is sent in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the protection that HTTPS provides, and have enabled it on your
    server, there are some additional steps you may need:'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, set `SECURE_PROXY_SSL_HEADER`, ensuring that you have understood
    the warnings there thoroughly. Failure to do this can result in CSRF vulnerabilities,
    and failure to do it correctly can also be dangerous!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up redirection so that requests over HTTP are redirected to HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This could be done using a custom middleware. Please note the caveats under
    `SECURE_PROXY_SSL_HEADER`. For the case of a reverse proxy, it may be easier or
    more secure to configure the main web server to do the redirect to HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *secure* cookies. If a browser connects initially via HTTP, which is the
    default for most browsers, it is possible for existing cookies to be leaked. For
    this reason, you should set your `SESSION_COOKIE_SECURE` and `CSRF_COOKIE_SECURE`
    settings to `True`. This instructs the browser to only send these cookies over
    HTTPS connections. Note that this will mean that sessions will not work over HTTP,
    and the CSRF protection will prevent any `POST` data being accepted over HTTP
    (which will be fine if you are redirecting all HTTP traffic to HTTPS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use HTTP Strict Transport Security (HSTS). HSTS is an HTTP header that informs
    a browser that all future connections to a particular site should always use HTTPS
    (see below). Combined with redirecting requests over HTTP to HTTPS, this will
    ensure that connections always enjoy the added security of SSL provided one successful
    connection has occurred. HSTS is usually configured on the web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP strict transport security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For sites that should only be accessed over HTTPS, you can instruct modern browsers
    to refuse to connect to your domain name via an insecure connection (for a given
    period of time) by setting the Strict-Transport-Security header. This reduces
    your exposure to some SSL-stripping Man-In-The-Middle (MITM) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '`SecurityMiddleware` will set this header for you on all HTTPS responses if
    you set the `SECURE_HSTS_SECONDS` setting to a non-zero integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: When enabling HSTS, it's a good idea to first use a small value for testing,
    for example, `SECURE_HSTS_SECONDS = 3600` for one hour. Each time a web browser
    sees the HSTS header from your site, it will refuse to communicate non-securely
    (using HTTP) with your domain for the given period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Once you confirm that all assets are served securely on your site (that is,
    HSTS didn't break anything), it's a good idea to increase this value so that infrequent
    visitors will be protected (31536000 seconds, that is, 1 year, is common).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you set the `SECURE_HSTS_INCLUDE_SUBDOMAINS` setting to `True`,
    `SecurityMiddleware` will add the `includeSubDomains` tag to the `Strict-Transport-Security`
    header. This is recommended (assuming all subdomains are served exclusively using
    HTTPS), otherwise your site may still be vulnerable via an insecure connection
    to a subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HSTS policy applies to your entire domain, not just the URL of the response
    that you set the header on. Therefore, you should only use it if your entire domain
    is served via HTTPS only.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers properly respecting the HSTS header will refuse to allow users to bypass
    warnings and connect to a site with an expired, self-signed, or otherwise invalid
    SSL certificate. If you use HSTS, make sure your certificates are in good shape
    and stay that way!
  prefs: []
  type: TYPE_NORMAL
- en: If you are deployed behind a load-balancer or reverse-proxy server, and the
    `Strict-Transport-Security` header is not being added to your responses, it may
    be because Django doesn't realize that it's on a secure connection; you may need
    to set the `SECURE_PROXY_SSL_HEADER` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Host header validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django uses the `Host` header provided by the client to construct URLs in certain
    cases. While these values are sanitized to prevent Cross Site Scripting attacks,
    a fake `Host` value can be used for Cross-Site Request Forgery, cache poisoning
    attacks, and poisoning links in emails.Because even seemingly-secure web server
    configurations are susceptible to fake `Host` headers, Django validates `Host`
    headers against the `ALLOWED_HOSTS` setting in the `django.http.HttpRequest.get_host()`
    method.This validation only applies via `get_host()`; if your code accesses the
    `Host` header directly from `request.META` you are bypassing this security protection.
  prefs: []
  type: TYPE_NORMAL
- en: Session security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the CSRF limitations requiring a site to be deployed such that untrusted
    users don't have access to any subdomains, `django.contrib.sessions` also has
    limitations. See the session topic guide section on security for details.
  prefs: []
  type: TYPE_NORMAL
- en: User-Uploaded content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider serving static files from a cloud service or CDN to avoid some of these
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: If your site accepts file uploads, it is strongly advised that you limit these
    uploads in your web server configuration to a reasonable size in order to prevent
    denial of service (DOS) attacks. In Apache, this can be easily set using the `LimitRequestBody`
    directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are serving your own static files, be sure that handlers like Apache's
    `mod_php`, which would execute static files as code, are disabled. You don't want
    users to be able to execute arbitrary code by uploading and requesting a specially
    crafted file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django's media upload handling poses some vulnerabilities when that media is
    served in ways that do not follow security best practices. Specifically, an HTML
    file can be uploaded as an image if that file contains a valid PNG header followed
    by malicious HTML. This file will pass verification of the library that Django
    uses for `ImageField` image processing (Pillow). When this file is subsequently
    displayed to a user, it may be displayed as HTML depending on the type and configuration
    of your web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No bulletproof technical solution exists at the framework level to safely validate
    all user uploaded file content, however, there are some other steps you can take
    to mitigate these attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: One class of attacks can be prevented by always serving user uploaded content
    from a distinct top-level or second-level domain. This prevents any exploit blocked
    by same-origin policy(for more information visit [http://en.wikipedia.org/wiki/Same-origin_policy](http://en.wikipedia.org/wiki/Same-origin_policy))
    protections such as cross site scripting. For example, if your site runs on `example.com`,
    you would want to serve uploaded content (the `MEDIA_URL` setting) from something
    like `usercontent-example.com`. It's not sufficient to serve content from a subdomain
    like `usercontent.example.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beyond this, applications may choose to define a whitelist of allowable file
    extensions for user uploaded files and configure the web server to only serve
    such files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional security tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Django provides good security protection out of the box, it is still important
    to properly deploy your application and take advantage of the security protection
    of the web server, operating system and other components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that your Python code is outside of the web server's root. This will
    ensure that your Python code is not accidentally served as plain text (or accidentally
    executed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take care with any user uploaded files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django does not throttle requests to authenticate users. To protect against
    brute-force attacks against the authentication system, you may consider deploying
    a Django plugin or web server module to throttle these requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your `SECRET_KEY` a secret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good idea to limit the accessibility of your caching system and database
    using a firewall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive of security issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django's development team is strongly committed to responsible reporting and
    disclosure of security-related issues, as outlined in Django's security policies.As
    part of that commitment, they maintain an historical list of issues which have
    been fixed and disclosed. For the up to date list, see the archive of security
    issues ([https://docs.djangoproject.com/en/1.8/releases/security/](https://docs.djangoproject.com/en/1.8/releases/security/)).
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic signing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The golden rule of web application security is to never trust data from untrusted
    sources. Sometimes it can be useful to pass data through an untrusted medium.
    Cryptographically signed values can be passed through an untrusted channel safe
    in the knowledge that any tampering will be detected.Django provides both a low-level
    API for signing values and a high-level API for setting and reading signed cookies,
    one of the most common uses of signing in web applications.You may also find signing
    useful for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating *recover my account* URLs for sending to users who have lost their
    password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring data stored in hidden form fields has not been tampered with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating one-time secret URLs for allowing temporary access to a protected
    resource, for example, a downloadable file that a user has paid for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the SECRET_KEY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a new Django project using `startproject`, the `settings.py`
    file is generated automatically and gets a random `SECRET_KEY` value. This value
    is the key to securing signed data-it is vital you keep this secure, or attackers
    could use it to generate their own signed values.
  prefs: []
  type: TYPE_NORMAL
- en: Using the low-level API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Django''s signing methods live in the `django.core.signing` module. To sign
    a value, first instantiate a `Signer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature is appended to the end of the string, following the colon. You
    can retrieve the original value using the `unsign` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the signature or value have been altered in any way, a `django.core.signing.BadSignature`
    exception will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `Signer` class uses the `SECRET_KEY` setting to generate signatures.
    You can use a different secret by passing it to the `Signer` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`django.core.signing.Signer` returns a signer which uses `key` to generate
    signatures and `sep` to separate values. `sep` cannot be in the URL safe base64
    alphabet. This alphabet contains alphanumeric characters, hyphens, and underscores.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the salt argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you do not wish for every occurrence of a particular string to have the
    same signature hash, you can use the optional `salt` argument to the `Signer`
    class. Using a salt will seed the signing hash function with both the salt and
    your `SECRET_KEY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using salt in this way puts the different signatures into different namespaces.
    A signature that comes from one namespace (a particular salt value) cannot be
    used to validate the same plaintext string in a different namespace that is using
    a different salt setting. The result is to prevent an attacker from using a signed
    string generated in one place in the code as input to another piece of code that
    is generating (and verifying) signatures using a different salt.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike your `SECRET_KEY`, your salt argument does not need to stay secret.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying timestamped values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TimestampSigner` is a subclass of `Signer` that appends a signed timestamp
    to the value. This allows you to confirm that a signed value was created within
    a specified period of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`sign(value)` signs `value` and appends the current timestamp.'
  prefs: []
  type: TYPE_NORMAL
- en: '`unsign(value, max_age=None)` checks if `value` was signed less than `max_age`
    seconds ago, otherwise raises `SignatureExpired`. The `max_age` parameter can
    accept an integer or a `datetime.timedelta` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting complex data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you wish to protect a list, tuple or dictionary you can do so using the
    signing module''s `dumps` and `loads` functions. These imitate Python''s pickle
    module, but use JSON serialization under the hood. JSON ensures that even if your
    `SECRET_KEY` is stolen an attacker will not be able to execute arbitrary commands
    by exploiting the pickle format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the nature of JSON (there is no native distinction between lists
    and tuples) if you pass in a tuple, you will get a list from `signing.loads(object)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`django.core.signing.dumps(obj, key=None, salt=''django.core.signing'', compress=False)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns URL-safe, sha1 signed base64 compressed JSON string. Serialized object
    is signed using `TimestampSigner`.
  prefs: []
  type: TYPE_NORMAL
- en: '`django.core.signing.loads(string, key=None, salt=''django.core.signing'',
    max_age=None)`'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse of `dumps()`, raises `BadSignature` if signature fails. Checks `max_age`
    (in seconds) if given.
  prefs: []
  type: TYPE_NORMAL
- en: Security middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your deployment situation allows, it's usually a good idea to have your front-end
    web server perform the functionality provided by the `SecurityMiddleware`. That
    way, if there are requests that aren't served by Django (such as static media
    or user-uploaded files), they will have the same protections as requests to your
    Django application.
  prefs: []
  type: TYPE_NORMAL
- en: The `django.middleware.security.SecurityMiddleware` provides several security
    enhancements to the request/response cycle. Each one can be independently enabled
    or disabled with a setting.
  prefs: []
  type: TYPE_NORMAL
- en: '`SECURE_BROWSER_XSS_FILTER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURE_CONTENT_TYPE_NOSNIFF`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURE_HSTS_INCLUDE_SUBDOMAINS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURE_HSTS_SECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURE_REDIRECT_EXEMPT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURE_SSL_HOST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURE_SSL_REDIRECT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on security headers and these settings, see [Chapter 17](ch17.xhtml
    "Chapter 17. Django Middleware"), *Django Middleware*.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we will expand on the quick install guide from [Chapter
    1](ch01.xhtml "Chapter 1. Introduction to Django and Getting Started"), *Introduction
    to Django and Getting Started* and look at some additional installation and configuration
    options for Django.
  prefs: []
  type: TYPE_NORMAL
