- en: Chapter 6. Building Applications with Spring Data Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how we can set up our project and configure the used Redis connection.
    Now it is time to expand our knowledge and learn how we can use Spring Data Redis
    in our applications. We will also prove that it is possible to use Redis as data
    storage of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Salvatore Sanfilippo* is a contributor of the Redis project and he has written
    a wonderful blog entry that describes how we can use Redis in our applications.
    This blog entry is available at [http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html](http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic design principles of a Redis data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key components of Spring Data Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can implement a CRUD application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can use the publish/subscribe messaging pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can use Spring Data Redis as an implementation of the cache abstraction
    provided by Spring Framework 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a Redis data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important rules of designing a Redis data model are: Redis does not
    support ad hoc queries and it does not support relations in the same way than
    relational databases. Thus, designing a Redis data model is a total different
    ballgame than designing the data model of a relational database. The basic guidelines
    of a Redis data model design are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simply modeling the information stored in our data model, we have
    to also think how we want to search information from it. This often leads to a
    situation where we have to duplicate data in order to fulfill the requirements
    given to us. Don't be afraid to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should not concentrate on normalizing our data model. Instead, we should
    combine the data that we need to handle as an unit into an aggregate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Redis does not support relations, we have to design and implement these
    relations by using the supported data structures. This means that we have to maintain
    these relations manually when they are changed. Because this might require a lot
    of effort and code, it could be wise to simply duplicate the information instead
    of using relations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is always wise to spend a moment to verify that we are using the correct
    tool for the job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*NoSQL Distilled*, by *Martin Fowler* contains explanations of different NoSQL
    databases and their use cases, and can be found at [http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*, Redis supports multiple data structures. However, one question remained
    unanswered: which data structure should we use for our data? This question is
    addressed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| String | A string is good choice for storing information that is already
    converted to a textual form. For instance, if we want to store HTML, JSON, or
    XML, a string should be our weapon of choice. |'
  prefs: []
  type: TYPE_TB
- en: '| List | A list is a good choice if we will access it only near the start or
    end. This means that we should use it for representing queues or stacks. |'
  prefs: []
  type: TYPE_TB
- en: '| Set | We should use a set if we need to get the size of a collection or check
    if a certain item belongs to it. Also, if we want to represent relations, a set
    is a good choice (for example, "who are John''s friends?"). |'
  prefs: []
  type: TYPE_TB
- en: '| Sorted set | Sorted sets should be used in the same situations as sets when
    the ordering of items is important to us. |'
  prefs: []
  type: TYPE_TB
- en: '| Hash | A hash is a perfect data structure for representing complex objects.
    |'
  prefs: []
  type: TYPE_TB
- en: Key components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data Redis provides certain components that are the cornerstones of each
    application that uses it. This section provides a brief introduction to the components
    that we will later use to implement our example applications.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Atomic counters are for Redis what sequences are for relational databases.
    Atomic counters guarantee that the value received by a client is unique. This
    makes these counters a perfect tool for creating unique IDs to our data that is
    stored in Redis. At the moment, Spring Data Redis offers two atomic counters:
    `RedisAtomicInteger` and `RedisAtomicLong` . These classes provide atomic counter
    operations for integers and longs.'
  prefs: []
  type: TYPE_NORMAL
- en: RedisTemplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RedisTemplate<K,V>` class is the central component of Spring Data Redis.
    It provides methods that we can use to communicate with a Redis instance. This
    class requires that two type parameters are given during its instantiation: the
    type of used Redis key and the type of the Redis value.'
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `RedisTemplate` class provides two kinds of operations that we can use
    to store, fetch, and remove data from our Redis instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Operations that require that the key and the value are given every time an operation
    is performed. These operations are handy when we have to execute a single operation
    by using a key and a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations that are bound to a specific key that is given only once. We should
    use this approach when we have to perform multiple operations by using the same
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The methods that require that a key and value is given every time an operation
    is performed are described in following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashOperations<K,HK,HV> opsForHash()`: This method returns the operations
    that are performed on hashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListOperations<K,V> opsForList()`: This method returns the operations performed
    on lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetOperations<K,V> opsForSet()`: This method returns the operations performed
    on sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueOperations<K,V> opsForValue()`: This method returns the operations performed
    on simple values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZSetOperations<K,HK,HV> opsForZSet()`: This method returns the operations
    performed on sorted sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The methods of the `RedisTemplate` class that allow us to execute multiple
    operations by using the same key are described in following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BoundHashOperarations<K,HK,HV> boundHashOps(K key)`: This method returns hash
    operations that are bound to the key given as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoundListOperations<K,V> boundListOps(K key)`: This method returns list operations
    bound to the key given as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoundSetOperations<K,V> boundSetOps(K key)`: This method returns set operations,
    which are bound to the given key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoundValueOperations<K,V> boundValueOps(K key)`: This method returns operations
    performed to simple values that are bound to the given key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoundZSetOperations<K,V> boundZSetOps(K key)`: This method returns operations
    performed on sorted sets that are bound to the key that is given as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between these operations become clear to us when we start building
    our example applications.
  prefs: []
  type: TYPE_NORMAL
- en: Serializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the data is stored in Redis as bytes, we need a method for converting
    our data to bytes and vice versa. Spring Data Redis provides an interface called
    `RedisSerializer<T>`, which is used in the serialization process. This interface
    has one type parameter that describes the type of the serialized object. Spring
    Data Redis provides several implementations of this interface. These implementations
    are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Serializer | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GenericToStringSerializer<T>` | Serializes strings to bytes and vice versa.
    Uses the Spring `ConversionService` to transform objects to strings and vice versa.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JacksonJsonRedisSerializer<T>` | Converts objects to JSON and vice versa.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JdkSerializationRedisSerializer` | Provides Java based serialization to
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `OxmSerializer` | Uses the Object/XML mapping support of Spring Framework
    3. |'
  prefs: []
  type: TYPE_TB
- en: '| `StringRedisSerializer` | Converts strings to bytes and vice versa. |'
  prefs: []
  type: TYPE_TB
- en: We can customize the serialization process of the `RedisTemplate` class by using
    the described serializers. The `RedisTemplate` class provides flexible configuration
    options that can be used to set the serializers that are used to serialize value
    keys, values, hash keys, hash values, and string values.
  prefs: []
  type: TYPE_NORMAL
- en: The default serializer of the `RedisTemplate` class is `JdkSerializationRedisSerializer`.
    However, the string serializer is an exception to this rule. `StringRedisSerializer`
    is the serializer that is by default used to serialize string values.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CRUD application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes two different ways for implementing a CRUD application
    that is used to manage contact information. First, we will learn how we can implement
    a CRUD application by using the default serializer of the `RedisTemplate` class.
    Second, we will learn how we can use value serializers and implement a CRUD application
    that stores our data in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these applications will also share the same domain model. This domain
    model consists of two classes: `Contact` and `Address`. The information content
    of these classes has already been described in [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Spring Data JPA"), *Getting Started with Spring Data JPA*. However,
    we have made the following changes to these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: We removed the JPA specific annotations from them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use these classes in our web layer as form objects and they no longer have
    any other methods than getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The domain model is not the only thing that is shared by these examples. They
    also share the interface that declares the service methods for the `Contact` class.
    The source code of the `ContactService` interface is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both of these applications will communicate with the used Redis instance by
    using the Jedis connector that was described in [Chapter 5](ch05.html "Chapter 5. Getting
    Started with Spring Data Redis"), *Getting Started with Spring Data Redis*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the user''s approach, we can implement a CRUD application with
    Spring Data Redis by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the application context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the CRUD functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started and find out how we can implement the CRUD functions for contact
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Using default serializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This subsection describes how we can implement a CRUD application by using the
    default serializers of the `RedisTemplate` class. This means that `StringRedisSerializer`
    is used to serialize string values, and `JdkSerializationRedisSerializer` serializes
    other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can configure the application context of our application by making the following
    changes to the `ApplicationContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Redis template bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the Redis atomic long bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the Redis template bean
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can configure the Redis template bean by adding a `redisTemplate()` method
    to the `ApplicationContext` class and annotating this method with the `@Bean`
    annotation. We can implement this method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisTemplate` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the used connection factory to the created `RedisTemplate` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `redisTemplate()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Redis atomic long bean
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start the configuration of the Redis atomic long bean by adding a method
    called `redisAtomicLong()` to the `ApplicationContext` class and annotating the
    method with the `@Bean` annotation. Our next task is to implement this method
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisAtomicLong` object. Pass the name of the used Redis counter
    and the Redis connection factory as constructor parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `redisAtomicLong()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we need to create IDs for instances of different classes, we can use the
    same Redis counter. Thus, we have to configure only one Redis atomic long bean.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can start implementing the CRUD functions for the `Contact` class,
    we have to discuss a bit about the Redis data model of our application. We use
    two different data types for storing contact information to Redis. The information
    of a single contact is stored in a hash because as we know, a hash is a great
    structure for storing the information of complex objects. Also, we store the key
    of each contact in a set because a set provides us a fast capability to check
    if a contact exists. We also use this set when we are fetching a list of all contacts
    from Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to implement the `ContactService` interface that declares
    CRUD operations for contacts. Let''s start by creating a dummy service implementation
    and add the actual CRUD methods later. The implementation of this class includes
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `ContactService` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotating the created class with the `@Service` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the required dependencies as private members of the created class and
    annotating these members with the `@Resource` annotation. We need to have a reference
    to both the `RedisTemplate` and `RedisAtomicLong` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our dummy implementation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement common methods that are used by the methods declared
    by the `ContactService` interface. These private methods are described in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String buildKey(Long contactId)` | Returns a key for a contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact buildContact(String key)` | Fetches the information of a contact
    and returns the found contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact buildContact(Long id)` | Fetches the information of a contact and
    returns the found contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean contactDoesNotExist(Long id)` | Returns false if a contact is found
    with the given ID and true otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `String persist(Contact persisted)` | Saves the contact information and returns
    the key of the contact. |'
  prefs: []
  type: TYPE_TB
- en: 'First, we have to implement the method that is used to build keys for our contacts.
    Our implementation of the `buildKey()` method is quite simple. We build the key
    by appending the contact ID given as a parameter to a string `contact` and returning
    the resulting string. The source code of the `buildKey()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to implement the method that is used to fetch contact information
    by using the key of the contact. We can implement the `buildContact(String key)`
    method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Contact` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the information of the contact from the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use bound hash operations because this way we have to provide the key only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the implemented method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we have to implement the method that fetches contact information by
    using the ID of the contact. Our implementation of the `buildContact(Long id)`
    method is rather simple, and it includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the key of the contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the contact by using the created key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the found contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of this method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Fourth, we have to implement the method used to verify whether a contact in
    question exists or not. Our implementation of the `contactDoesNotExist()` method
    consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the key of the contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the key is found from the contacts set by calling the `isMember()`
    method of the `SetOperations` class, and passing the name of the set and the key
    as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use `setOperations` because we execute only one command.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse the return value of the `isMember()` method and return the inverted
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of this method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Fifth, we have to implement the method that saves the information of a single
    contact. Our implementation of the `persist()` method includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the persisted `Contact` object does not have an ID, create one calling the
    `incrementAndGet()` method of the `RedisAtomicLong` class and set the received
    `Long` object as the contact ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a key for the persisted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the contact in the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the persisted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `persist()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have now implemented the common methods of the `RedisContactService` class.
    Let's move on and find out how we can provide the CRUD operations for the contact
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can create a new contact by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the added contact to the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the key of the contact to our contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the added contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `add()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Read
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have to provide two methods that are used to fetch contact information from
    Redis. The first method is used to return a list of existing contacts and the
    second one is used to find the information of a single contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to implement a method that is used to return a list of existing
    contacts. We can implement the `findAll()` method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ArrayList` object that is used to store the found `Contact` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the keys of existing contacts from the contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the information of each existing contact from the hash and add them to the
    created `ArrayList` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the list of contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the implemented method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to implement a method that is used to return the information
    of a single contact. We can implement the `findById()` method by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the contact exists. If contact does not exist, throw `NotFoundException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the contact from the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the found contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Update
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can update the information of an existing contact by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if that contact exists. If no contact is found, throw a `NotFoundException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the updated contact information in the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the updated contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `update()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Delete
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can delete the information of a contact by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a reference of the deleted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `findById()` method because it throws `NotFoundException` if the
    contact is not found.
  prefs: []
  type: TYPE_NORMAL
- en: Build a key of the deleted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the contact from our contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the information of a contact from the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the deleted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `deleteById()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Storing data in JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we store object information in a hash, we have to write a lot of boilerplate
    code that is used to save, read, and delete contact information. This subsection
    describes how we reduce the amount of required code and implement a CRUD application
    that stores the contact information in JSON format. This means that `StringRedisSerializer`
    is used to serialize string values and that `JacksonJsonRedisSerializer` transforms
    our `Contact` objects into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can configure the application context of our application by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the value serializer bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Redis template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Redis atomic long bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the value serializer bean
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can configure the value serializer bean by adding a `contactSerializer()`
    method to the `ApplicationContext` class and annotating it with the `@Bean` annotation.
    We can implement this method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `JacksonJsonRedisSerializer` object and pass the type of the `Contact`
    class as a constructor parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `contactSerializer()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Redis template bean
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can configure the Redis template by adding a `redisTemplate()` method to
    the `ApplicationContex`t class, annotating it with the `@Bean` annotation and
    configuring the Redis template in its implementation. We can implement this method
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisTemplate` object and give the type of our key and value as
    type parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the used connection factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the used value serializer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `redisTemplate()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Redis atomic long bean
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will start the configuration of the Redis atomic long bean by adding a `redisAtomicLong()`
    method to the `ApplicationContext` class and annotating it with the `@Bean` annotation.
    Our next step is to implement this method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisAtomicLong` object. Pass the name of the used Redis counter
    and the Redis connection factory as constructor parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `redisAtomicLong()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: CRUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we have to talk about our Redis data model. We store the contact information
    to Redis, using two different data types. We store the information of a single
    contact to Redis as a string value. This makes sense since the contact information
    is transformed to the JSON format before it is saved. We will also use a set that
    contains the JSON representations of the `Contact` objects. We have to duplicate
    the information because otherwise we would not be able to show a list of contacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide the CRUD operations for the `Contact` objects by implementing
    the `ContactService` interface. Let''s start by creating a dummy service implementation
    and adding or implementing the actual CRUD operations later. The steps needed
    to create a dummy service implementation are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `ContactService` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the created class with the `@Service` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the required dependencies as private members of the created class and annotate
    these members with the `@Resource` annotation. We need to have a reference to
    both the `RedisTemplate` and `RedisAtomicLong` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our dummy service implementation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to implement some utility methods that are used by the methods
    declared by the `ContactService` interface. These private methods are described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String buildKey(Long contactId)` | Returns a key for a contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `void persist(Contact persisted)` | Saves the contact information to a string
    value. |'
  prefs: []
  type: TYPE_TB
- en: 'First, we have to implement a method that is used to build keys for the persisted
    `Contact` objects. The implementation of the `buildKey()` method is simple. We
    build the key by appending the contact ID given as a parameter to a string `contact`
    and return the resulting string. The source code of the `buildKey()` method is
    given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to implement a `persist()` method that saves the contact information.
    We can do this by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the contact ID is null, get a new ID and set the received `Long` object as
    an ID of the `Contact` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a key for the contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the contact information as a string value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use value operations because we need to execute only one operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of the `persist()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to start implementing the CRUD operations for contacts. Let's
    move on and find out how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can implement a method that adds new contacts by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the added contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the contact information into the contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the added contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `add()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Read
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our application has two views that present contact information: the first one
    shows a list of contacts and the second one shows the information of a single
    contact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to implement a method that fetches all the contacts from Redis.
    We can implement the `findAll()` method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch all the contacts from the contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `ArrayList` object and return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `findAll()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to implement a method that returns the information of a single
    contact. Our implementation of the `findById()` method includes the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the key of the contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `Contact` object from Redis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no contact is found, throw `NotFoundException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the found object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `findById()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Update
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can update the information of an existing contact by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the old contact information from Redis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the updated contact information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the old contact information from the contact set. This ensures that our
    set does not contain duplicate entries for the same contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the updated contact information to the contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the updated contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `update()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Delete
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can delete contact information by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the deleted contact by calling the `findById()` method. This ensures that
    `NotFoundException` is thrown if the contact is not found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a key used to get the contact information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the deleted contact from the contact set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the JSON representation of the deleted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the deleted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `delete()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The publish/subscribe messaging pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis also includes an implementation of the publish/subscribe messaging pattern.
    This section demonstrates how we can use Spring Data Redis for the purpose of
    sending and receiving messages. As an example, we will modify the CRUD application
    that stores the contact information as JSON to send notifications when a new contact
    is added, contact information is updated, and a contact is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this requirement by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create message listeners that process the received messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the application context of our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send messages by using the `RedisTemplate` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This section also describes how we can ensure that our implementation is working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating message listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to create message listeners by using Spring Data Redis:
    we can implement the `MessageListener` interface or we can create a POJO message
    listener and use the `MessageListenerAdapter` class to delegate messages to it.
    Both of these approaches are discussed in this subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MessageListener interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first way to create a message listener is to implement the `MessageListener`
    interface. Our implementation includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Logger` object that is used to log the received messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `StringRedisSerializer` object that is used to transform byte arrays
    to `String` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `onMessage()` method declared by the `MessageListener` interface.
    This method simply logs the received message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `ContactListener` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a POJO message listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second way to create message listeners is to create a normal Java class.
    We can do this by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Logger` object that is used to log the received messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a message handler method called `handleMessage()` that takes the `Contact`
    object and a `String` object as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `handleMessage()` method. This method logs the received message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `ContactPOJOMessageListener` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the application context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to make the following changes to the application context configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the message listener beans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a message listener adapter bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a message listener container bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the message listener beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we have to configure our message listener beans. The configuration is
    rather simple. We just create new message listener objects and return the created
    objects. The source code of the message listener bean configuration is given as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the message listener adapter bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next we have to configure the message listener adapter bean that is used to
    delegate the messages forward to our POJO message listener. We can configure this
    bean by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `MessageListenerAdapter` object and pass the `ContactPOJOMessageListener`
    object as a constructor parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the serializer that is used to transform the received message to a `Contact`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `messageListenerAdapter()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `defaultListenerMethod` property of the `MessageListenerAdapter` class is
    used to configure the name of the message handler method. The default value of
    this property is `handleMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the message listener container bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **message listener container** is a component that listens to the messages
    that are sent through the different channels and forwards these messages to the
    registered message listeners. We can configure this component by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisMessageListenerContainer` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the used Redis connection factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the message listeners and specify the subscribed channels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our configuration is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sending messages with RedisTemplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can send publish messages to different channels by using the `convertAndSend(String
    channel, Object message)` method of the `RedisTemplate` class. This subsection
    describes how we can send notifications about new contacts, updated contacts,
    and removed contacts by using this method.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to send change notifications about new contacts, we have to modify
    the `add()` method of the `RedisContactService` class to call the `convertAndSend()`
    method of the `RedisTemplate` class after the information of a new contact is
    saved successfully. The source code of our new `add()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can send notifications about updated contacts by modifying the `update()`
    method of the `RedisContactService` class. We simply call the `convertAndSend()`
    method of the `RedisTemplate` class after the contact information is updated.
    The source code of the new `update()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Delete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can send a notification about the deleted contacts by making a small change
    in the `deleteById()` method of the `RedisContactService` class. After the contact
    information is deleted, we will call the `convertAndSend()` method of the `RedisTemplate`
    class, which sends the notification message. The source code of the modified `deleteById()`
    method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the wanted behaviour
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now implemented our message listeners and modified our application to
    send a notification message every time the contact information is changed. Our
    next step is to verify that our implementation is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm this by making changes to the contact information and making
    sure that log lines written by our message listeners appear in the application''s
    log. The loglines that are written when a new contact is added are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the channel information passed to a POJO message handler is always
    `null`. This is a known bug of Spring Data Redis. More information about this
    is available at [https://jira.springsource.org/browse/DATAREDIS-98](https://jira.springsource.org/browse/DATAREDIS-98).
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring cache abstraction with Spring Data Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cache abstraction of Spring Framework 3.1 applies caching to Java methods.
    When a cached method is called, the cache abstraction will check from the cache
    if the method has been called earlier by using the same parameters. If this is
    the case, then the return value is fetched from the cache and the method is not
    executed. Otherwise, the method is executed and its return value is stored in
    the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cache abstraction of Spring Framework 3.1 is explained in more detail at
    [http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html](http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Data Redis provides an implementation of the Spring cache abstraction.
    Using Redis as a cache has two benefits over using local caching implementations
    such as Ehcache:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be used as a centralized cache that is shared by each servlet container
    or application server that runs our application. This reduces the overall number
    of database queries, which reduces the load of our database server and increases
    the performance of all the servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cache will not be emptied until we empty it. This means that we can restart
    our servlet container or application server without losing the information stored
    in the cache. After our server is restarted, it can take full advantage of the
    cached information right away. There is no need to warm up the cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This section describes how we can use Spring Data Redis for the purpose of
    adding a caching support to an application that uses the JPA Criteria API. This
    application has been originally introduced in [Chapter 3](ch03.html "Chapter 3. Building
    Queries with Spring Data JPA"), *Building Queries with Spring Data JPA*. The requirements
    of our caching example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method calls to the method that finds the information of a single contact
    from the database must be cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the information of a contact is updated, the information stored in the
    cache must be updated as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a contact is deleted, the deleted contact must be removed from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can add caching support to our example application by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the Spring cache abstraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the cached methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also learn how we can verify that the Spring cache abstraction is working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Spring cache abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can configure the Spring cache abstraction by making the following changes
    to the application context configuration of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the caching annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the host and port of the used Redis instance in the used properties
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Redis connection factory bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Redis template bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the cache manager bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling caching annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can enable the caching annotations by annotating our application context
    configuration class with the `@EnableCaching` annotation. The relevant part of
    the `ApplicationContext` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the host and port of the used Redis instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to configure the host and port of the used Redis instance, we have
    to add the following lines to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Redis connection factory bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can configure the Redis connection factory bean by adding a `redisConnectionFactory()`
    method to the `ApplicationContext` class and annotating this method with the `@Bean`
    annotation. We can implement this method by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `JedisConnectionFactory` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the host and port of the used Redis instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `redisConnectionFactory()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Redis template bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to configure the Redis template bean, we have to add a `redisTemplate()`
    method to the `ApplicationContext` class and annotate this method with the `@Bean`
    annotation. Our implementation of this method includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisTemplate` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the used Redis connection factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `redisTemplate()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the cache manager bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our last step is to configure the cache manager bean. We can do this by adding
    the `cacheManager()` method to the `ApplicationContext` class and annotating this
    method with the `@Bean` annotation. We can implement this method by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RedisCacheManager` object and provide the used Redis template
    as a constructor parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `cacheManager()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Identifying the cached methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now configured the Spring cache abstraction and we are ready to identify
    the cached methods. This subsection describes how we can add contact information
    in the cache, update contact information that is already stored in the cache,
    and delete the contact information from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Adding contact information to the cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to add contact information to the cache, we must cache the method
    calls to the `findById()` method of the `RepositoryContactService` class. We can
    do this by annotating the method with the `@Cacheable` annotation and providing
    the name of the cache. This tells the cache abstraction that the returned contact
    should be added to the `contacts` cache by using the provided ID as a key. The
    source code of the `findById()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Updating the contact information to the cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can update the contact information that is stored in the cache by annotating
    the `update()` method of the `RepositoryContactService` class with the `@CachePut`
    annotation. We will also have to provide the name of the cache and specify that
    the `id` property of the `ContactDTO` object is used as a key when the return
    value of this method is updated to the cache. The source code of the `update()`
    method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Deleting contact information from the cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can delete contact information from the cache by annotating the `deleteById()`
    method with the `@CacheEvict` annotation and providing the name of the cache as
    its value. This means that the cache abstraction removes the deleted contact from
    the cache after the method has been executed. The removed contact is identified
    by the ID given as a method parameter. The source code of the `deleteById()` method
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Verifying that the Spring cache abstraction is working
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now successfully added caching to our example application. We can verify
    that the Spring cache abstraction is working properly by using the cached methods
    and looking for the following lines from the log file of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If these lines are found from the log file it can mean that:'
  prefs: []
  type: TYPE_NORMAL
- en: The contact information is fetched from the cache instead of the used database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contact information is updated to the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contact information is removed from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned that:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a Redis data model is totally different from designing a data model
    of a relational database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use Redis as data storage of a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Redis provides a clean integration with the Redis publish/subscribe
    implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use Redis as a centralized cache of our application by using the Spring
    cache abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
