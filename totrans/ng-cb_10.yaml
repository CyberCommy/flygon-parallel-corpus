- en: '*Chapter 10*: Writing Unit Tests in Angular with Jest'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"It works on my machine…"* is a phrase that won''t lose its beauty with time.
    It is a shield for many engineers and a nightmare for the QAs. But honestly, what''s
    a better way than writing tests for your application''s robustness, right? And
    when it comes to writing unit tests, my personal favorite is Jest. That is because
    it is super fast, lightweight, and has an easy API to write tests. More importantly,
    it is faster than the Karma and Jasmine setup that comes out of the box with Angular.
    In this chapter, you''ll learn how to configure Jest with Angular to run these
    tests in parallel. You''ll learn how to test components, services, and pipes with
    Jest. You''ll also learn how to mock dependencies for these tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests in Angular with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking services using stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spies on an injected service in a unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the `ng-mocks` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating even easier component tests with Angular CDK component harnesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing components with Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing Angular pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the recipes in this chapter, ensure you have both **Git** and **NodeJS**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do using `npm install -g @angular/cli` from your Terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests in Angular with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a new Angular project comes bundled with a lot of goodness, including
    the configuration and tooling in which to run unit tests with Karma and Jasmine.
    While working with Karma is relatively convenient, many developers find that in
    large-scale projects, the whole testing process becomes much slower if there are
    a lot of tests involved. This is mainly because you can't run tests in parallel.
    In this recipe, we'll set up Jest for unit testing in an Angular app. Additionally,
    we'll migrate existing tests from the Karma syntax to the Jest syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/setting-up-jest`,
    which is inside the cloned repository. To begin, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The setting-up-jest app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.1_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – The setting-up-jest app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, try to run the test and monitor how much time it takes for the entire
    process to run. Run the `ng test` command from your Terminal; within a few seconds,
    a new Chrome window should open, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The tests'' results with Karma and Jasmine'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.2_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – The tests' results with Karma and Jasmine
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the preceding screenshot, you might say *"Pfffttt Ahsan, it says
    'finished in 0.126s!' What else do you want?"* Well, that time only covers how
    long it took Karma to run the tests *in the browser after the Chrome window was
    created*. It doesn't count the time it took to actually start the process, start
    the Chrome window, and then load the tests. On my machine, it takes about *15
    seconds* to run the entire process. That's why we're going to replace it with
    Jest. Now that you understand the issue, in the next section, let's take a look
    at the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have an Angular app with a really simple **Counter** component. It
    shows the value of the counter and has three action buttons: one to increment
    the value of the counter, one to decrement the value, and one to reset the value.
    Additionally, there are some tests written with Karma and Jasmine, and all of
    the tests pass if you run the `ng test` command. We''ll start by setting up Jest
    instead. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window/tab and make sure you''re inside the `chapter10/start_here/setting-up-jest`
    folder. Once inside, run the following command to install the packages that are
    required to test with Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now uninstall Karma and the unwanted dependencies. Now run the following
    command in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We also need to get rid of some extra files that we don't require. Delete the
    `karma.conf.js` file and the `src/test.ts` file from the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now update the test configuration in the `angular.json` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create a file to configure Jest for our project. Create a file
    named `jestSetup.ts` inside the project''s root folder and paste the following
    content inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify `tsconfig.spec.json` to use Jest instead of Jasmine. After
    the modification, your entire file should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now modify `package.json` to add the `npm` scripts that''ll run the
    Jest tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s wrap up the entire configuration for our Jest tests by adding
    the Jest configuration in the `package.json` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have set everything up, simply run the `test` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the tests are finished, you should be able to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The results of the tests with Jest'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.3_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – The results of the tests with Jest
  prefs: []
  type: TYPE_NORMAL
- en: Kaboom! You will notice that the entire process of running the tests with Jest
    takes about 6 seconds. It might take more time when you run it for the first time,
    but the subsequent runs should be faster. Now that you know how to configure an
    Angular app to use Jest for unit tests, please refer to the next section for resources
    in which to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Testing* *Web Frameworks with Jest* ([https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Jest* ([https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to set up Jest for Angular unit tests.
    There might be some scenarios in which you'd want to use a browser API that might
    not be part of your actual Angular code; for instance, using `localStorage` or
    `alert()`. In such cases, we need to provide some global mocks for the functions
    we want to return mock values from. This is so that we can perform tests involving
    them as well. In this recipe, you'll learn how to provide global mocks to Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter10/start_here/providing-global-mocks-for-jest`.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. The app should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The providing-global-mocks-for-jest app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.4_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – The providing-global-mocks-for-jest app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we''re using for this recipe uses two global APIs: `window.localStorage`
    and `window.alert()`. Note that when the app starts, we fetch the counter value
    from `localStorage`, and then upon increment, decrement, and reset, we store it
    in `localStorage`. When the counter value becomes greater than the `MAX_VALUE`
    or lower than the `MIN_VALUE`, we show the alert using the `alert()` method. Let''s
    begin the recipe by writing some cool unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll write our test cases to show the alert when the counter value
    goes beyond `MAX_VALUE` and `MIN_VALUE`. Modify the `counter.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the tests pass. But what if we wanted to check whether
    the value from `localStorage` is being saved and retrieved properly?
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a new test to make sure the `localStorage.getItem()` method is
    called to retrieve the last saved value from the `localStorage` API. Add the test
    to the `counter.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we''re using `it.only` for this test case. This is to ensure that
    we''re only running this test (for now). If you run the tests, you should be able
    to see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The test that is covering the localStorage API has failed'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.5_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – The test that is covering the localStorage API has failed
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `Matcher error: received value must be a mock or a spy function`
    message. This is what we''re going to do next, that is, provide a mock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file in the project''s root, called `jest-global-mocks.ts`. Then,
    add the following code to mock the `localStorage` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now import this file into the `jestSetup.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now if you rerun the tests, they should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to ensure we retrieve the last saved value from `localStorage`
    in the component initiation. Modify the `counter.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s make sure that we save the counter value to `localStorage`
    whenever we trigger the `increment()`, `decrement()`, or `reset()` methods. Update
    the `counter.component.spec.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Awesome sauce! You've just learned how to provide global mocks to Jest for testing.
    Please refer to the next section to understand how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jest provides a way in which to define a list of paths to the files that we
    want to load for each test. If you open the `package.json` file and see the `jest`
    property, you can view the `setupFilesAfterEnv` property, which takes an array
    of paths to the files. We already have the path defined there for the `jestSetup.ts`
    file. And one way to define global mocks is to create a new file and then import
    it into `jestSetup.ts`. This is because it is going to be called in the test environment
    anyway. And that's what we do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we use the `Object.defineProperty` method in the `window` object
    to provide a mock implementation for the `localStorage` object. This is actually
    the same for any API that is not implemented in the JSDOM. Similarly, you can
    provide a global mock for each API that you use in your tests. Notice that in
    the `value` property, we use the `createLocalStorageMock()` method. Essentially,
    this is one way to define mocks. We create the `createLocalStorageMock()` method,
    and in there we have a private/encapsulated object named `storage` that mimics
    the `localStorage` object. We have also defined the `getItem()` and `setItem()`
    methods in there so that we can set values to this storage and get values from
    it. Notice that we do not have the implementations of the `removeItem()` and `clear()`
    methods that we have in the original `localStorage` API. We don't have to do it
    because we're not using these methods in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the `'should call the localStorage.getItem method on component init'` test,
    we simply spy on the `localStorage` object's `getItem()` method, call the `ngOnInit()`
    method ourselves, and then expect it to have been called. Easy peasy.
  prefs: []
  type: TYPE_NORMAL
- en: In the `'should retrieve the last saved value from localStorage on component
    init'` test, we save a value in the `localStorage` object for the counter value
    as `'12'` using the `setItem()` method. Essentially, calling the `setItem()` method
    calls our mock implementation method and not the actual `localStorage` API's `setItem()`
    method. Notice that, here, we *do not* spy on the `getItem()` method; this is
    because later on, we want the value of the component's `counter` property to be
    `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we spy on a method, remember that any statements in the actual function
    will no longer be executed. This is why we do not spy on the `getItem()` method
    in the preceding test. If we do so, the `getItem()` method from the mock implementation
    *will not return anything*. Therefore, our expected value for the counter property
    will not be `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, if you have to rely on the outcome of a function's implementation,
    or the statements executed within a function, do not spy on that function and
    write your test accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'PS: I always end up learning this the hard way after debugging and bashing
    my head for a while. Just kidding!'
  prefs: []
  type: TYPE_NORMAL
- en: The final test is an easy one. In the `'should save the new counterValue to
    localStorage on increment, decrement and reset'` test, we simply spy on the `setItem()`
    method as we're not concerned about its implementation. Then, we manually set
    the value of the counter property multiple times before we run the `increment()`,
    `decrement()`, and `reset()` methods, respectively. Additionally, we expect the
    `setItem()` method to have been called with the right arguments to save the value
    to the store. Note that we do not check the store's value after saving it. As
    I mentioned earlier, since we have spied on the `setItem()` method, its internal
    statement won't trigger and the value won't be saved; therefore, we can't retrieve
    the saved value afterward.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Jest documentation for `setupFiles` ([https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Manual Mocks with Jest* ([https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking services using stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's rarely an Angular app that doesn't have a `Service` created inside it.
    And where the overall business logic is concerned, services hold a great deal
    of the business logic, particularly when it comes to interacting with APIs. In
    this recipe, you'll learn how to mock services using stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter10/start_here/mocking-services-using-stubs`.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The mocking-services-using-stubs app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.6_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The mocking-services-using-stubs app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's take a
    look at the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same application as the previous recipe; however, we''ve moved
    the logic of saving and retrieving data from `localStorage` to the `CounterService`
    we''ve created. Now all the tests pass. However, what if we wanted to hide/encapsulate
    the logic of where the counter value is stored? Perhaps we want to send a backend
    API call for it. To do this, it makes more sense to spy on the service''s methods.
    Let''s follow the recipe to provide a mock stub for our service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a folder inside the `src` folder, named `__mocks__`.
    Inside it, create another folder named `services`. Then, again inside this folder,
    create the `counter.service.mock.ts` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now provide the mock service instead of the actual service in the `counter.component.spec.ts`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding change, you should see the following error that says the
    `localStorage.setItem` hasn''t been called. This is because we''re now spying
    on the methods on our mock stub for the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – localStorage.setItem is not called because of the methods being
    spied on'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.7_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – localStorage.setItem is not called because of the methods being
    spied on
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of expecting the `localStorage` object''s methods to be called,
    let''s expect our service''s methods to be called in our tests. Update the `counter.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great! You now know how to mock services to test components with service dependencies.
    Please refer to the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing stubs for Angular services is already a breeze. This is thanks to
    Angular's out-of-the-box methods and tooling from the `@angular/core` package,
    especially `@angular/core/testing`. First, we create the stub for our `CounterService`
    and use `jest.fn()` for every method within `CounterService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `jest.fn()` returns a new, unused mock function that Jest automatically
    spies upon as well. Optionally, we can also pass a mock implementation method
    as a parameter to `jest.fn`. View the following example from the official documentation
    for `jest.fn()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once we create the stub, we pass it to the `TestBed` configuration in the provider's
    array against the `CounterService` – but with the `useValue` property set to the
    `CounterServiceMock`. This tells Angular to use our stub as it is for `CounterService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the test where we expect `CounterService.getFromStorage()` to be called
    when the component initiates, we use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding code, we are able to directly use `expect()` on
    `CounterServiceMock.getFromStorage`. While this isn't possible in Karma and Jasmine,
    it is possible with Jest, since we're using `jest.fn()` for each underlying method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for a test in which we want to check whether the `getFromStorage()` method
    is called and returns a saved value, we first use the `CounterServiceMock.getFromStorage.mockReturnValue(12);`
    statement. This ensures that when the `getFromStorage()` method is called, it
    returns the value of `12`. Then, we just run the `ngOnInit()` method in the test
    and expect that our component''s counter property has now been set to `12`. This
    actually means that the following things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnInit()` calls the `getFromStorage()` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getFromStorage()` returns the previously saved value (in our case, that''s
    `12`, but in reality, that''ll be fetched from `localStorage`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component's `counter` property is set to the retrieved value, which, in
    our case, is `12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, for the final test, we just expect that the `saveToStorage` method of
    our `CounterService` is called in each necessary case. For this, we use the following
    types of `expect()` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's pretty much about it. Unit tests are fun, aren't they? Now that you've
    understood how it all works, please refer to the next section for some helpful
    resources that you can use for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official documentation for `jest.fn()` ([https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular's *Component testing scenarios* ([https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spies on an injected service in a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can provide stubs for your services in the unit tests with Jest, sometimes,
    it might feel like an overhead creating a mock for every new service. Let's suppose
    that if the service's usage is limited to one test file, it might make more sense
    to just use spies on the actual injected service. In this recipe, that's exactly
    what we're going to do.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project for this recipe resides in `chapter10/start_here/using-spies-on-injected-service`.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should run the unit tests on the console using Jest. You should see something
    similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Unit tests failing for the ''using-spies-on-injected-service''
    project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.8_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Unit tests failing for the 'using-spies-on-injected-service' project
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the tests running locally, in the next section, let's go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tests we have in the code for `CounterComponent` are incomplete. That''s
    because we''re missing the `expect()` blocks and the code to spy on the methods
    of `CounterService`. Let''s get started with the recipe to complete writing the
    tests using spies on the actual `CounterService`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get an instance of the actual injected service in our tests.
    So, we''ll create a variable and get the injected service in a `beforeEach()`
    method. Update the `counter.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll write our first `expect()` block for the service. For the test
    that says `''should call the localStorage.getItem method on component init''`,
    add the following `spyOn()` and `expect()` blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you run `npm run test` again, you should still see one test failing but the
    rest of them passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fix the failing test. That is `''should retrieve the last saved
    value from localStorage on component init''`. In this case, we need to spy on
    the `getFromStorage()` method of `CounterService` to return the expected value
    of `12`. To do so, update the test file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s fix our last test where we expect the `increment()`, `decrement()`,
    and `reset()` methods to call the `saveToStorage()` method of `CounterService`.
    Update the test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! With this change, you should see all 12 tests passing. Let's take a
    look at the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contained a lot of knowledge from the previous recipes of this chapter.
    However, the key highlight is the `TestBed.inject()` method. Essentially, this
    magical method gets the instance of the provided service – `CounterService` –
    to us. This is the instance of the service that is bound with the instance of
    `CounterComponent`. Since we have access to the same instance of the service that
    is being used by the component's instance, we can spy on it directly and expect
    it to be called – or even mock the returned values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An introduction to Angular TestBed (https://angular.io/guide/testing-services#angular-testbed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the ng-mocks package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests mostly revolve around testing components in isolation. However, what
    if your component depends completely on another component or directive to work
    properly? In such cases, you usually provide a mock implementation for the component,
    but that is a lot of work. However, with the `ng-mocks` package, it is super easy.
    In this recipe, we'll learn an advanced example of how to use `ng-mocks` for a
    parent component that depends on a child component to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/mocking-components-with-ng-mocks`,
    which is inside the cloned repository. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – The mocking-components-with-ng-mocks app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.9_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – The mocking-components-with-ng-mocks app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run the `yarn test` command or the `npm run test` command, you''ll see
    that not all of our tests pass. Additionally, there are a bunch of errors on the
    console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – An unknown elements error during unit tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.10_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – An unknown elements error during unit tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the recipe to make sure that our tests pass correctly without
    any errors using the `ng-mocks` package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install the `ng-mocks` package within our project. To do this,
    run the following command from your project root in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll try to fix the tests for `AppComponent`. To only run specific tests
    based on a string regex, we can use the `-t` parameter with the `jest` command.
    Run the following command to only run the tests for `AppComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can see that we only run the tests for `AppComponent`, and they fail
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Error – ''app-version-control'' is not a known element'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.11_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Error – 'app-version-control' is not a known element
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the error shown in *Figure 10.11*, we''ll import `VersionControlComponent`
    into the `TestBed` definition inside the `app.component.spec.ts` file. This is
    so that our test environment also knows the missing `VersionControlComponent`.
    To do this, modify the mentioned file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you rerun the tests for `AppComponent`, you'll see some fresher and newer
    errors. Surprise! Well, that's what happens with dependencies. We'll discuss the
    details in more detail in the *How it works...* section. However, to fix this,
    let's follow the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of providing the `VersionControlComponent` directly, we need to mock
    it since we don''t really care about it for the tests for `AppComponent`. To do
    this, update the `app.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Boom! Problem solved. Run the tests again, just for the `AppComponent`, and
    you should see them all pass as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Passing all of the tests for AppComponent'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.12_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Passing all of the tests for AppComponent
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about the tests for `VersionControlComponent`. This depends
    on the `ReleaseFormComponent` as well as the `ReleaseLogsComponent`. Let''s mock
    them like a pro this time, using the `MockBuilder` and `MockRender` methods, so
    we can get rid of the errors during the tests. After the update, the `version-control.component.spec.ts`
    file should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you run `npm run test` now, you should see all of the tests passing. In the
    next steps, let's actually write some interesting tests.
  prefs: []
  type: TYPE_NORMAL
- en: '`VersionControlComponent` uses `ReleaseLogsComponent` as a child. Additionally,
    it provides the `releaseLogs` property as `@Input()` to `ReleaseLogsComponent`
    via the `[logs]` attribute. We can actually check whether the input''s value is
    set correctly. To do so, update the `version-control.component.spec.ts` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll make sure that when we have a new log created via `ReleaseFormComponent`,
    we show this new log by adding it to the `releaseLogs` array in `VersionControlComponent`.
    Then, we''ll also pass that as `@Input logs` to `ReleaseLogsComponent`. Add the
    following tests to the `version-control.component.spec.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Boom! We have implemented some interesting tests by using the `ng-mocks` package.
    I absolutely love it every time I use it. Now that we've finished the recipe,
    in the next section, let's take a look at how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of interesting things that we have covered in this recipe.
    First of all, to avoid any errors on the console complaining about unknown components,
    we use the `MockComponent` method from the `ng-mocks` package, to declare the
    components we're dependent on, as mocks. That is absolutely the simplest thing
    we achieve with the `ng-mocks` package. However, we do move on to an advanced
    situation, which I will admit is sort of an unconventional approach; that is testing
    the `@Input` and `@Output` emitters of the child components in the parent component
    in order to test an entire flow. This is what we do for the tests of `VersionControlComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we remove the usage of the `@angular/core/testing` package completely
    from the `version-control.component.spec.ts` file. This is because we're no longer
    using `TestBed` to create the test environment. Instead, we use the `MockBuilder`
    method from the `ng-mocks` package to build the test environment for our `VersionControlComponent`.
    Then, we use the `.mock()` method to mock each child component that we want to
    work with inside the tests later on. The `.mock()` method is not only used to
    mock components, but it can also be used to mock services, directives, pipes,
    and more. Please refer to the next section for further resources to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `''should add the new log when it is created via ReleaseFormComponent''`
    test, pay attention to the `ngMocks.find()` method, which we use to find the relevant
    component and get its instance. Its use is relatively similar to what we would
    do in `TestBed`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, using `ngMocks.find()` is better suited, as it has better support for
    types. Once we get a hold of the instance of `ReleaseFormComponent`, we use the
    `@Output` named `newReleaseLog` to create a new log using the `.emit()` method.
    Then, we do a quick `fixture.detectChanges()` to trigger the Angular change detection.
    We also check the `VersionControl.releaseLogs` array to determine whether our
    new release log has been added to the array. Afterward, we also check the `ReleaseLogsComponent.logs`
    property to make sure that the child component has updated the `logs` array via
    `@Input`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don't use a spy on the `VersionControlComponent.addNewReleaseLog`
    method. That is because if we do so, that function will become a Jest spy function.
    Therefore, it'll lose its functionality inside. In return, it'll never add the
    new log to the `releaseLogs` array, and none of our tests will pass. You can try
    it out for fun.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ng-mocks `.mock` method ([https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ng-mocks official documentation ([https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating even easier component tests with Angular CDK component harnesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests for components, there might be scenarios where you'd actually
    want to interact with the DOM elements. Now, this can already be achieved by using
    the `fixture.debugElement.query` method to find the element using a selector and
    then triggering events on it. However, that means maintaining it for different
    platforms, knowing the identifiers of all the selectors, and then exposing all
    of that in the tests. And this is even worse if we're talking about an Angular
    library. It certainly isn't necessary for each developer who interacts with my
    library to know all the element selectors in order to write the tests. Only the
    author of the library should know that much to respect encapsulation. Luckily,
    we have the component harnesses from the Angular CDK team, which were released
    with Angular 9 along with the IVY compiler. And they've led by example, by providing
    component harnesses for the Angular material components as well. In this recipe,
    you'll learn how to create your own component harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/tests-using-cdk-harness`,
    which is inside the cloned repository. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The tests-using-cdk-harness app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.13_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – The tests-using-cdk-harness app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the app running, let's move on to the next section to follow
    the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have our favorite Angular version control app that allows us to create release
    logs. And we have the tests written already, including tests that interact with
    the DOM element to validate a few use cases. Let''s follow the recipe to use component
    harnesses instead, and discover how easy it becomes to use in the actual tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window/tab and ensure you''re inside the `chapter10/start_here/tests-using-cdk-harness`
    folder. Once inside, run the following command to install the Angular CDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You have to restart your Angular server. So, rerun the `ng serve` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we''ll create a **component harness** for the `ReleaseFormComponent`.
    Let''s create a new file inside the `release-form` folder, and name it `release-form.component.harness.ts`.
    Then, add the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to set up the harness environment for our tests for `VersionControlComponent`.
    For this, we''ll use `HarnessLoader` and `TestbedHarnessEnvironment` from the
    Angular CDK. Update the `version-control.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write some methods in our `ReleaseFormComponentHarness` class to
    get the relevant information. We''ll use these methods in the later steps. Update
    the `release-form.component.harness.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll work on our first test, named `''should have the first app selected
    for the new release log''`, with the component harness. Update the `version-control.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now if you run `npm run test`, you should see all of the tests passing, which
    means our first test with the component harness works. Woohoo!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll work on our second test, that is, for `''should show error on wrong
    version number input''`. Update the test in the `version-control.component.spec.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Boom! Note that we just reduced the lines of code for this test from nine statements
    to only four statements. Isn't that amazing? I believe it is awesome and much
    cleaner, to be honest.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final test, we also need a component harness for `ReleaseLogsComponent`.
    Let''s quickly create it. Add a new file inside the `release-logs` folder, named
    `release-logs.component.harness.ts`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s modify our final tests in the `version-control.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Voila! That's some amazing testing right there using the Angular CDK component
    harnesses. If you run the tests now, you should see all of the tests passing.
    Now that you've finished the recipe, please refer to the next section to learn
    how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right! That was a cool recipe, which I enjoyed working on myself. The key
    factor of this recipe is the `@angular/cdk/testing` package. If you have worked
    with `e2e` tests using Protractor before, this is a similar concept to the `Pages`
    in Protractor. First, we create a component harness for both the `ReleaseLogsComponent`
    and the `ReleaseFormComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we import the `ComponentHarness` class from `@angular/cdk/testing`
    for both component harnesses. Then, we extend our custom classes called `ReleaseFormComponentHarness`
    and `ReleaseLogsComponentHarness` from the `ComponentHarness` class. Essentially,
    this is the correct way to author component harnesses. Did you notice the static
    property called `hostSelector`? We need this property for every component harness
    class that we create. And the value is always the selector of the target element/component.
    This ensures that when we load this harness into the test environment, the environment
    is able to find the host element in the DOM – for which we're creating the component
    harness. In our component harness class, we use the `this.locatorFor()` method
    to find elements within the host component. The `locateFor()` method takes a single
    argument as the `css selector` of the element to be found and returns an `AsyncFactoryFn`.
    This means the returned value is a function that we can use at a later time to
    get the required elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ReleaseFormComponentHarness` class, we find the submit button, the app
    name input, and the version number input using the `protected` methods' `getSubmitButton`,
    `getAppNameInput`, and `getAppVersionInput`, respectively, which are all of the
    `AsyncFactoryFn` type, as mentioned earlier. We have these methods set as `protected`
    because we don't want the people writing the unit tests to access or care about
    the information of the DOM elements. This makes it much easier for everyone to
    write tests without worrying about the internal implementation of accessing the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `getVersionErrorEl()` method is slightly different. It is not
    actually of the `AsyncFactoryFn` type. Instead, it is a regular `async` function
    that first calls the `locatorForAll` method to get all the elements with the `alert`
    class and the `alert-danger` class, which results in the error messages. Then,
    it selects the second alert element, which is for the app version number input.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to mention here is that when we call the `locatorFor()`
    method or the `locatorForAll()` method, we get back a `Promise` with the `TestElement`
    item or a `Promise` with a list of `TestElement` items, respectively. Each `TestElement`
    item has a bunch of handy methods such as `.click()`, `.sendKeys()`, `.focus()`,
    `.blur()`, `.getProperty()`, `.text()`, and more. And these methods are what we're
    interested in since we use them behind the scenes to interact with the DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about configuring the test environment. In the `version-control.component.spec.ts`
    file, we set up the environment to use component harnesses for both `ReleaseLogsComponent`
    and `ReleaseFormComponent`. The `TestbedHarnessEnvironment` element is the key
    element here. We use the `.loader()` method of the `TestbedHarnessEnvironment`
    class by providing our `fixture` as an argument. Note that the fixture is what
    we get in the test environment using the `TestBed.createComponent(VersionControlComponent)`
    statement. Because we provide this fixture to the `TestbedHarnessEnvironment.loader()`
    method, we get back an element of the `HarnessLoader` statement, which can now
    load component harnesses for the other components – that is, for `ReleaseLogsComponent`
    and `ReleaseFormComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the tests, we use the `harnessLoader.getHarness()` method by
    providing the harness class as an argument. This enables the test environment
    to find the DOM element associated with the `hostSelector` property of the harness
    class. Additionally, we get back the instance of the component harness that we
    can use further in the test.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding components in the DOM with component harnesses (`https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*API for component harness authors* (`https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing components with Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're building an Angular application, it is very likely that you'll work
    with Observables inside the app at some point. For instance, you could be fetching
    data from a third-party API or perhaps just managing the state. In either case,
    it becomes slightly difficult to test applications that have Observables in action.
    In this recipe, we're going to learn how to test unit tests with Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter10/start_here/unit-testing-observables`.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The unit-testing-observables app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.14_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – The unit-testing-observables app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's take a
    look at the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by writing test cases, which technically involve the usage of
    Observables. Essentially, we have to mock the methods using Observables, and we
    have to use the `fakeAsync` and `tick()` methods provided by Angular to reach
    our goal of writing good unit tests with Observables. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we''ll write a test to see what happens when we use an
    `expect()` clause in a test that involves a function containing an Observable.
    Update the `users.component.spec.ts` file by adding a test, which checks whether
    we get the users from the server when the component initiates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as soon as you run the `npm run test` command, you''ll see that the test
    fails with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Error – Cannot make XHRs from within a fake async test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.15_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Error – Cannot make XHRs from within a fake async test
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that we can't make real HTTP calls from the `fakeAsync` tests,
    which is what happens after the `ngOnInit()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper way to test this is to mock `UserService`. Luckily, we''ve already
    done this as we have the `UserServiceMock` class in the project. We need to provide
    it as a `useClass` property for `UserService` in `TestBed` and update our test
    slightly. Let''s modify the `users.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run the tests again, they should pass. We'll cover this in more
    detail in the *How it works...* section later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test for a scenario in which we want to search users. We''ll
    set the value for the `username` form control and search users using `UserService`,
    or more technically, `UserServiceMock`. Then, we will expect the results to be
    appropriate. Add a test in the `users.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write a test for `UserDetailComponent`. We need to test that our
    `UserDetailComponent` gets the appropriate user from the server when the component
    is initiated and that we get similar users as well. Update the `user-detail.component.spec.ts`
    file by adding a test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The new test should be failing at the moment. We will fix it in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug, we can quickly add a `console.log()` to the `params` that we get
    from subscribing to the `route.paramMap` Observable in the `ngOnInit()` method.
    Modify the `user-detail.component.ts` file, and then run the tests again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run the tests, you can see the error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Error – empty params and missing uuid'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.16_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – Error – empty params and missing uuid
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 10.16*, we don''t have the `uuid` in the `Params`
    object. This is because it is not a real routing process for a real user. So,
    we need to mock the `ActivatedRoute` service that is used in `UserDetailComponent`
    to get the desired result. Let''s create a new file inside the `__mocks__` folder,
    named `activated-route.mock.ts`, and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll use this mock in our tests for `UserDetailComponent`. Update the
    `user-detail.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have injected the mock into the test environment, let''s modify
    our test to get the second user from the `DUMMY_USERS` array. Update the tests
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write a test that allows us to get similar users when `UserDetailComponent`
    is loaded. Remember that according to our current business logic, similar users
    are all users except the current user on the page, which is saved in the `user`
    property. Let''s add the test in the `user-detail.component.spec.ts` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the tests, you should see them all pass as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – All of the tests are passing with mocked Observables'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.17_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.17 – All of the tests are passing with mocked Observables
  prefs: []
  type: TYPE_NORMAL
- en: Great! You now know how to work with Observables when writing unit tests for
    components. Although there's still a lot to learn about testing Observables in
    Angular, the purpose of this recipe was to keep everything simple and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have finished the recipe, please refer to the next section to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start our recipe by using the `fakeAsync()` and `tick()` methods from the
    `'@angular/core/testing'` package. Notice that we wrap our tests' callback method
    using the `fakeAsync()` method. The method wrapped in the `fakeAsync()` method
    is executed in something called a `fakeAsync` zone. This is contrary to how it
    works in the actual Angular application, which runs inside `ngZone`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In order to work with the `fakeAsync` zone, we need to import the `zone.js/dist/zone-testing`
    library in our test environment. This is usually done in the `src/test.ts` file
    when you create an Angular project. However, since we migrated to Jest, we removed
    that file.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Okay. How does it work then, Ahsan?"* Well, I''m glad you asked. While setting
    up for Jest, we use the `jest-preset-angular` package. This package ultimately
    requires all the necessary files for the `fakeAsync` tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – The jest-preset-angular package importing the required zone.js
    files'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.18_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.18 – The jest-preset-angular package importing the required zone.js
    files
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the `tick()` method simulates the passage of time in this virtual
    `fakeAsync` zone until all of the asynchronous tasks are finished. It takes a
    parameter as milliseconds, which either reflects how many milliseconds have passed
    or how much the virtual clock has advanced. In our case, we use `500` milliseconds
    as the value for the `tick()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're mocking `UserService` for the tests for `UsersComponent`.
    Specifically for `'should get users back from the API component init'`, we call
    the `component.ngOnInit()` method in the test and then call the `tick()` method.
    In the meantime, the `ngOnInit()` method calls the `searchUsers()` method, which
    calls the `UserServiceMock.searchUsers()` method since we've provided it as the
    `useClass` property in our test environment for `UserService`. Finally, that returns
    the value of the `DUMMY_USERS` array that we have defined in the `user.service.mock.ts`
    file. The other test for the `UsersComponent`, that is, `'should get the searched
    users from the API upon searching'`, is quite similar as well.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the tests for `UserDetailComponent`, we do something different,
    that is, we also have to mock the `activatedRoute` service. Why? Well, that is
    because the `UserDetailComponent` is a page that can be navigated with a `uuid`
    and because its path is defined as `'/users/:uuid'` in the `app-routing.module.ts`
    file. Therefore, we need to populate this `uuid` parameter in our tests to work
    with the `DUMMY_USERS` array. For this, we use the `ActivatedRouteMock` class
    inside the `__mocks__` folder. Notice that it has a `setParamMap()` method. This
    allows us to specify the `uuid` parameter in our tests. Then, when the actual
    code subscribes to the `this.route.paramMap` Observable, our set `uuid` parameter
    can be found there.
  prefs: []
  type: TYPE_NORMAL
- en: For the `'should get the user based on routeParams on page load'` test, we set
    the second user's `uuid` from the `DUMMY_USERS` array as the `uuid` route parameter's
    value. Then, we use the `tick()` method, after which we expect the `user` property
    to have the second user from the `DUMMY_USERS` array as the value. The other test
    in the file is also quite similar and self-explanatory. Please refer to the next
    section for more useful links regarding unit testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular testing component scenarios ([https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing routed Angular components with `RouterTestingModule` ([https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0](https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing Angular Pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my personal opinion, pipes are the easiest components to test in an Angular
    application. Why? Well, this is because they're (supposed to be) pure functions
    that return the same result based on the same set of inputs. In this recipe, we'll
    write some tests for a really simple pipe in an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/unit-testing-pipes`,
    which is inside the cloned repository. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – The unit-testing-pipes app running on http://localhost:4200'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.19_B15150.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.19 – The unit-testing-pipes app running on http://localhost:4200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have a simple recipe that takes two inputs – the digit and the max
    factor value. Based on these inputs, we show a multiplication table. We already
    have the `MultTablePipe` that is working fine according to our business logic.
    We''ll now write some unit tests to validate our inputs and expected outputs,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our first test for `MultTablePipe`. We''ll make sure it returns
    an empty array when we have an invalid value for the `digit` input. Update the
    `mult-table.pipe.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write another test to validate the `limit` input so that we also return
    an empty array if it is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll write a test to validate the output of the pipe''s transform method
    when both the `digit` and `limit` inputs are valid. In this scenario, we should
    get back the array containing the multiplication table. Write another test as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, within the app, we have the possibility to provide decimal digits
    for the `limit` input. For instance, we can write `2.5` as the max factor in the
    input. To handle this, we use a `Math.floor()` in `MultTablePipe` to round it
    down to the lower number. Let''s write a test to make sure this works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Easy peasy! Writing tests for Angular pipes is so straightforward that I love
    it. We could call this the power of pure functions. Now that you've finished the
    recipe, please refer to the next section for more informative links.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing Angular pipes official documentation ([https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test Angular Pipes With Services* ([https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
