- en: '*Chapter 10*: Writing Unit Tests in Angular with Jest'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用Jest在Angular中编写单元测试'
- en: '*"It works on my machine…"* is a phrase that won''t lose its beauty with time.
    It is a shield for many engineers and a nightmare for the QAs. But honestly, what''s
    a better way than writing tests for your application''s robustness, right? And
    when it comes to writing unit tests, my personal favorite is Jest. That is because
    it is super fast, lightweight, and has an easy API to write tests. More importantly,
    it is faster than the Karma and Jasmine setup that comes out of the box with Angular.
    In this chapter, you''ll learn how to configure Jest with Angular to run these
    tests in parallel. You''ll learn how to test components, services, and pipes with
    Jest. You''ll also learn how to mock dependencies for these tests.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"它在我的机器上运行……"*这句话不会随着时间的推移而失去它的美丽。对许多工程师来说，这是一个护身符，对QA人员来说则是一个噩梦。但老实说，有什么比为应用程序的健壮性编写测试更好的方式呢？当涉及编写单元测试时，我个人最喜欢的是Jest。因为它非常快速、轻量级，并且具有易于编写测试的简单API。更重要的是，它比Angular默认提供的Karma和Jasmine设置更快。在本章中，您将学习如何配置Angular与Jest，以便并行运行这些测试。您将学习如何使用Jest测试组件、服务和管道。您还将学习如何为这些测试模拟依赖项。'
- en: 'In this chapter, we''re going to cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up unit tests in Angular with Jest
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中使用Jest设置单元测试
- en: Providing global mocks for Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Jest提供全局模拟
- en: Mocking services using stubs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根来模拟服务
- en: Using spies on an injected service in a unit test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中对注入的服务使用间谍
- en: Mocking child components and directives using the `ng-mocks` package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ng-mocks`包模拟子组件和指令
- en: Creating even easier component tests with Angular CDK component harnesses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CDK组件测试更简单
- en: Unit testing components with Observables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Observables对组件进行单元测试
- en: Unit testing Angular pipes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试Angular管道
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, ensure you have both **Git** and **NodeJS**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do using `npm install -g @angular/cli` from your Terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的食谱中，请确保您的计算机上安装了**Git**和**NodeJS**。您还需要安装`@angular/cli`包，可以使用终端命令`npm install
    -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10)找到。
- en: Setting up unit tests in Angular with Jest
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中使用Jest设置单元测试
- en: By default, a new Angular project comes bundled with a lot of goodness, including
    the configuration and tooling in which to run unit tests with Karma and Jasmine.
    While working with Karma is relatively convenient, many developers find that in
    large-scale projects, the whole testing process becomes much slower if there are
    a lot of tests involved. This is mainly because you can't run tests in parallel.
    In this recipe, we'll set up Jest for unit testing in an Angular app. Additionally,
    we'll migrate existing tests from the Karma syntax to the Jest syntax.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的Angular项目包含了很多好东西，包括配置和工具，可以使用Karma和Jasmine来运行单元测试。虽然使用Karma相对方便，但许多开发人员发现，在大型项目中，如果涉及大量测试，整个测试过程会变得非常缓慢。这主要是因为无法并行运行测试。在本章中，我们将为Angular应用程序设置Jest进行单元测试。此外，我们还将把现有的测试从Karma语法迁移到Jest语法。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter10/start_here/setting-up-jest`,
    which is inside the cloned repository. To begin, perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter10/start_here/setting-up-jest`中，该文件夹位于克隆的存储库内。首先，执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '完成后，运行`ng serve -o`。 '
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。您应该会看到类似以下截图的内容：
- en: '![Figure 10.1 – The setting-up-jest app running on http://localhost:4200'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - 在http://localhost:4200上运行的setting-up-jest应用程序'
- en: '](image/Figure_10.1_B15150.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.1_B15150.jpg)'
- en: Figure 10.1 – The setting-up-jest app running on http://localhost:4200
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 在http://localhost:4200上运行的setting-up-jest应用程序
- en: 'Next, try to run the test and monitor how much time it takes for the entire
    process to run. Run the `ng test` command from your Terminal; within a few seconds,
    a new Chrome window should open, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试运行测试并监视整个过程运行的时间。从终端运行`ng test`命令；几秒钟后，一个新的Chrome窗口应该会打开，如下所示：
- en: '![Figure 10.2 – The tests'' results with Karma and Jasmine'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - 使用Karma和Jasmine的测试结果'
- en: '](image/Figure_10.2_B15150.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.2_B15150.jpg)'
- en: Figure 10.2 – The tests' results with Karma and Jasmine
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 使用Karma和Jasmine的测试结果
- en: Looking at the preceding screenshot, you might say *"Pfffttt Ahsan, it says
    'finished in 0.126s!' What else do you want?"* Well, that time only covers how
    long it took Karma to run the tests *in the browser after the Chrome window was
    created*. It doesn't count the time it took to actually start the process, start
    the Chrome window, and then load the tests. On my machine, it takes about *15
    seconds* to run the entire process. That's why we're going to replace it with
    Jest. Now that you understand the issue, in the next section, let's take a look
    at the steps of the recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看着前面的截图，你可能会说“Pfffttt Ahsan，它说'在0.126秒内完成！'你还想要什么？”嗯，那个时间只涵盖了Karma在Chrome窗口创建后在浏览器中运行测试所花费的时间。它没有计算实际启动过程、启动Chrome窗口，然后加载测试所花费的时间。在我的机器上，整个过程大约需要*15秒*。这就是为什么我们要用Jest替换它。现在您了解了问题，在下一节中，让我们看一下食谱的步骤。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we have an Angular app with a really simple **Counter** component. It
    shows the value of the counter and has three action buttons: one to increment
    the value of the counter, one to decrement the value, and one to reset the value.
    Additionally, there are some tests written with Karma and Jasmine, and all of
    the tests pass if you run the `ng test` command. We''ll start by setting up Jest
    instead. Perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个Angular应用程序，其中有一个非常简单的**Counter**组件。它显示计数器的值，并有三个操作按钮：一个用于增加计数器的值，一个用于减少值，一个用于重置值。此外，还有一些使用Karma和Jasmine编写的测试，如果运行`ng
    test`命令，所有测试都会通过。我们将首先设置Jest。执行以下步骤：
- en: 'First, open a new Terminal window/tab and make sure you''re inside the `chapter10/start_here/setting-up-jest`
    folder. Once inside, run the following command to install the packages that are
    required to test with Jest:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端窗口/标签，并确保您在`chapter10/start_here/setting-up-jest`文件夹内。进入后，运行以下命令以安装使用Jest所需的软件包：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now uninstall Karma and the unwanted dependencies. Now run the following
    command in your Terminal:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以卸载Karma和不需要的依赖项。现在在您的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We also need to get rid of some extra files that we don't require. Delete the
    `karma.conf.js` file and the `src/test.ts` file from the project.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要摆脱一些我们不需要的额外文件。从项目中删除`karma.conf.js`文件和`src/test.ts`文件。
- en: 'Now update the test configuration in the `angular.json` file, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式更新`angular.json`文件中的测试配置：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now create a file to configure Jest for our project. Create a file
    named `jestSetup.ts` inside the project''s root folder and paste the following
    content inside:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个文件来为我们的项目配置Jest。在项目的根文件夹中创建一个名为`jestSetup.ts`的文件，并粘贴以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s modify `tsconfig.spec.json` to use Jest instead of Jasmine. After
    the modification, your entire file should appear as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll now modify `package.json` to add the `npm` scripts that''ll run the
    Jest tests:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s wrap up the entire configuration for our Jest tests by adding
    the Jest configuration in the `package.json` file, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have set everything up, simply run the `test` command, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the tests are finished, you should be able to see the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The results of the tests with Jest'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.3_B15150.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – The results of the tests with Jest
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Kaboom! You will notice that the entire process of running the tests with Jest
    takes about 6 seconds. It might take more time when you run it for the first time,
    but the subsequent runs should be faster. Now that you know how to configure an
    Angular app to use Jest for unit tests, please refer to the next section for resources
    in which to learn more.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Testing* *Web Frameworks with Jest* ([https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks))'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Jest* ([https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started))'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to set up Jest for Angular unit tests.
    There might be some scenarios in which you'd want to use a browser API that might
    not be part of your actual Angular code; for instance, using `localStorage` or
    `alert()`. In such cases, we need to provide some global mocks for the functions
    we want to return mock values from. This is so that we can perform tests involving
    them as well. In this recipe, you'll learn how to provide global mocks to Jest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter10/start_here/providing-global-mocks-for-jest`.
    Perform the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. The app should appear as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The providing-global-mocks-for-jest app running on http://localhost:4200'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.4_B15150.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – The providing-global-mocks-for-jest app running on http://localhost:4200
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we''re using for this recipe uses two global APIs: `window.localStorage`
    and `window.alert()`. Note that when the app starts, we fetch the counter value
    from `localStorage`, and then upon increment, decrement, and reset, we store it
    in `localStorage`. When the counter value becomes greater than the `MAX_VALUE`
    or lower than the `MIN_VALUE`, we show the alert using the `alert()` method. Let''s
    begin the recipe by writing some cool unit tests:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll write our test cases to show the alert when the counter value
    goes beyond `MAX_VALUE` and `MIN_VALUE`. Modify the `counter.component.spec.ts`
    file as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you can see that the tests pass. But what if we wanted to check whether
    the value from `localStorage` is being saved and retrieved properly?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a new test to make sure the `localStorage.getItem()` method is
    called to retrieve the last saved value from the `localStorage` API. Add the test
    to the `counter.component.spec.ts` file, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that we''re using `it.only` for this test case. This is to ensure that
    we''re only running this test (for now). If you run the tests, you should be able
    to see something similar to the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The test that is covering the localStorage API has failed'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.5_B15150.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – The test that is covering the localStorage API has failed
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `Matcher error: received value must be a mock or a spy function`
    message. This is what we''re going to do next, that is, provide a mock.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file in the project''s root, called `jest-global-mocks.ts`. Then,
    add the following code to mock the `localStorage` API:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now import this file into the `jestSetup.ts` file, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now if you rerun the tests, they should pass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to ensure we retrieve the last saved value from `localStorage`
    in the component initiation. Modify the `counter.component.spec.ts` file, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s make sure that we save the counter value to `localStorage`
    whenever we trigger the `increment()`, `decrement()`, or `reset()` methods. Update
    the `counter.component.spec.ts` as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Awesome sauce! You've just learned how to provide global mocks to Jest for testing.
    Please refer to the next section to understand how this works.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jest provides a way in which to define a list of paths to the files that we
    want to load for each test. If you open the `package.json` file and see the `jest`
    property, you can view the `setupFilesAfterEnv` property, which takes an array
    of paths to the files. We already have the path defined there for the `jestSetup.ts`
    file. And one way to define global mocks is to create a new file and then import
    it into `jestSetup.ts`. This is because it is going to be called in the test environment
    anyway. And that's what we do in this recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Jest提供了一种定义要为每个测试加载的文件路径列表的方法。如果打开`package.json`文件并查看`jest`属性，您可以查看`setupFilesAfterEnv`属性，它接受一个文件路径数组。我们已经在那里为`jestSetup.ts`文件定义了路径。定义全局模拟的一种方法是创建一个新文件，然后将其导入`jestSetup.ts`。这是因为它无论如何都会在测试环境中被调用。这就是我们在这个示例中所做的。
- en: Notice that we use the `Object.defineProperty` method in the `window` object
    to provide a mock implementation for the `localStorage` object. This is actually
    the same for any API that is not implemented in the JSDOM. Similarly, you can
    provide a global mock for each API that you use in your tests. Notice that in
    the `value` property, we use the `createLocalStorageMock()` method. Essentially,
    this is one way to define mocks. We create the `createLocalStorageMock()` method,
    and in there we have a private/encapsulated object named `storage` that mimics
    the `localStorage` object. We have also defined the `getItem()` and `setItem()`
    methods in there so that we can set values to this storage and get values from
    it. Notice that we do not have the implementations of the `removeItem()` and `clear()`
    methods that we have in the original `localStorage` API. We don't have to do it
    because we're not using these methods in our tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`window`对象中使用`Object.defineProperty`方法为`localStorage`对象提供了一个模拟实现。对于JSDOM中未实现的任何API，情况都是一样的。同样，您可以为测试中使用的每个API提供全局模拟。请注意，在`value`属性中，我们使用了`createLocalStorageMock()`方法。实质上，这是定义模拟的一种方式。我们创建了`createLocalStorageMock()`方法，在其中我们有一个名为`storage`的私有/封装对象，模拟了`localStorage`对象。我们还在其中定义了`getItem()`和`setItem()`方法，以便我们可以向此存储设置值并从中获取值。请注意，我们没有在原始`localStorage`API中拥有的`removeItem()`和`clear()`方法的实现。我们不必这样做，因为我们在测试中没有使用这些方法。
- en: In the `'should call the localStorage.getItem method on component init'` test,
    we simply spy on the `localStorage` object's `getItem()` method, call the `ngOnInit()`
    method ourselves, and then expect it to have been called. Easy peasy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在“应该在组件初始化时调用localStorage.getItem方法”测试中，我们只是对`localStorage`对象的`getItem()`方法进行了间谍监视，自己调用了`ngOnInit()`方法，然后期望它已被调用。非常简单。
- en: In the `'should retrieve the last saved value from localStorage on component
    init'` test, we save a value in the `localStorage` object for the counter value
    as `'12'` using the `setItem()` method. Essentially, calling the `setItem()` method
    calls our mock implementation method and not the actual `localStorage` API's `setItem()`
    method. Notice that, here, we *do not* spy on the `getItem()` method; this is
    because later on, we want the value of the component's `counter` property to be
    `12`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在“应该在组件初始化时从localStorage中检索最后保存的值”测试中，我们使用`setItem()`方法将计数器值保存在`localStorage`对象中，值为`'12'`。实质上，调用`setItem()`方法会调用我们的模拟实现方法，而不是实际的`localStorage`API的`setItem()`方法。请注意，这里我们*不*对`getItem()`方法进行间谍监视；这是因为后来，我们希望组件的`counter`属性的值为`12`。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Whenever we spy on a method, remember that any statements in the actual function
    will no longer be executed. This is why we do not spy on the `getItem()` method
    in the preceding test. If we do so, the `getItem()` method from the mock implementation
    *will not return anything*. Therefore, our expected value for the counter property
    will not be `12`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们对一个方法进行间谍操作时，请记住实际函数中的任何语句都不会再被执行。这就是为什么我们在前面的测试中不对`getItem()`方法进行间谍操作。如果我们这样做，模拟实现中的`getItem()`方法将不会返回任何内容。因此，我们对计数器属性的预期值将不会是`12`。
- en: Put simply, if you have to rely on the outcome of a function's implementation,
    or the statements executed within a function, do not spy on that function and
    write your test accordingly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果您必须依赖于函数实现的结果，或者函数内部执行的语句，就不要对该函数进行间谍操作，并相应地编写您的测试。
- en: 'PS: I always end up learning this the hard way after debugging and bashing
    my head for a while. Just kidding!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PS：我总是在调试和苦苦思索一段时间后才艰难地学会这一点。开个玩笑！
- en: The final test is an easy one. In the `'should save the new counterValue to
    localStorage on increment, decrement and reset'` test, we simply spy on the `setItem()`
    method as we're not concerned about its implementation. Then, we manually set
    the value of the counter property multiple times before we run the `increment()`,
    `decrement()`, and `reset()` methods, respectively. Additionally, we expect the
    `setItem()` method to have been called with the right arguments to save the value
    to the store. Note that we do not check the store's value after saving it. As
    I mentioned earlier, since we have spied on the `setItem()` method, its internal
    statement won't trigger and the value won't be saved; therefore, we can't retrieve
    the saved value afterward.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试很简单。在`'should save the new counterValue to localStorage on increment, decrement
    and reset'`测试中，我们只是对`setItem()`方法进行了间谍操作，因为我们不关心它的实现。然后，我们手动多次设置计数器属性的值，然后分别运行`increment()`、`decrement()`和`reset()`方法。此外，我们期望`setItem()`方法已被调用，并使用正确的参数将值保存到存储中。请注意，我们在保存后不检查存储的值。正如我之前提到的，由于我们已经对`setItem()`方法进行了间谍操作，它的内部语句不会触发，值也不会被保存；因此，我们无法在保存后检索保存的值。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Jest documentation for `setupFiles` ([https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array))
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setupFiles`的Jest文档([https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array))'
- en: '*Manual Mocks with Jest* ([https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks))'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Jest进行手动模拟* ([https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks))'
- en: Mocking services using stubs
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根(mock)来模拟服务
- en: There's rarely an Angular app that doesn't have a `Service` created inside it.
    And where the overall business logic is concerned, services hold a great deal
    of the business logic, particularly when it comes to interacting with APIs. In
    this recipe, you'll learn how to mock services using stubs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有一个Angular应用程序不会在其中创建一个`Service`。就整体业务逻辑而言，服务在与API交互时承载了大量的业务逻辑，特别是在涉及到与API交互时。在这个食谱中，您将学习如何使用存根(mock)来模拟服务。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter10/start_here/mocking-services-using-stubs`.
    Perform the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱的项目位于`chapter10/start_here/mocking-services-using-stubs`。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something like
    the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签页中打开应用程序。您应该会看到类似以下截图的内容：
- en: '![Figure 10.6 – The mocking-services-using-stubs app running on http://localhost:4200'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 在http://localhost:4200上运行的mocking-services-using-stubs应用程序'
- en: '](image/Figure_10.6_B15150.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The mocking-services-using-stubs app running on http://localhost:4200
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's take a
    look at the steps of the recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same application as the previous recipe; however, we''ve moved
    the logic of saving and retrieving data from `localStorage` to the `CounterService`
    we''ve created. Now all the tests pass. However, what if we wanted to hide/encapsulate
    the logic of where the counter value is stored? Perhaps we want to send a backend
    API call for it. To do this, it makes more sense to spy on the service''s methods.
    Let''s follow the recipe to provide a mock stub for our service:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a folder inside the `src` folder, named `__mocks__`.
    Inside it, create another folder named `services`. Then, again inside this folder,
    create the `counter.service.mock.ts` file with the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now provide the mock service instead of the actual service in the `counter.component.spec.ts`,
    as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the preceding change, you should see the following error that says the
    `localStorage.setItem` hasn''t been called. This is because we''re now spying
    on the methods on our mock stub for the service:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – localStorage.setItem is not called because of the methods being
    spied on'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.7_B15150.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – localStorage.setItem is not called because of the methods being
    spied on
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of expecting the `localStorage` object''s methods to be called,
    let''s expect our service''s methods to be called in our tests. Update the `counter.component.spec.ts`
    file as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great! You now know how to mock services to test components with service dependencies.
    Please refer to the next section to understand how it all works.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing stubs for Angular services is already a breeze. This is thanks to
    Angular's out-of-the-box methods and tooling from the `@angular/core` package,
    especially `@angular/core/testing`. First, we create the stub for our `CounterService`
    and use `jest.fn()` for every method within `CounterService`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `jest.fn()` returns a new, unused mock function that Jest automatically
    spies upon as well. Optionally, we can also pass a mock implementation method
    as a parameter to `jest.fn`. View the following example from the official documentation
    for `jest.fn()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once we create the stub, we pass it to the `TestBed` configuration in the provider's
    array against the `CounterService` – but with the `useValue` property set to the
    `CounterServiceMock`. This tells Angular to use our stub as it is for `CounterService`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了存根，我们将其传递给`TestBed`配置中的提供者数组，针对`CounterService` - 但`useValue`属性设置为`CounterServiceMock`。这告诉Angular使用我们的存根作为`CounterService`。
- en: 'Then, in the test where we expect `CounterService.getFromStorage()` to be called
    when the component initiates, we use the following statement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们期望组件初始化时调用`CounterService.getFromStorage()`的测试中，我们使用以下语句：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that in the preceding code, we are able to directly use `expect()` on
    `CounterServiceMock.getFromStorage`. While this isn't possible in Karma and Jasmine,
    it is possible with Jest, since we're using `jest.fn()` for each underlying method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们能够直接在`CounterServiceMock.getFromStorage`上使用`expect()`。虽然这在Karma和Jasmine中是不可能的，但在Jest中是可能的，因为我们对每个基础方法使用了`jest.fn()`。
- en: 'Then, for a test in which we want to check whether the `getFromStorage()` method
    is called and returns a saved value, we first use the `CounterServiceMock.getFromStorage.mockReturnValue(12);`
    statement. This ensures that when the `getFromStorage()` method is called, it
    returns the value of `12`. Then, we just run the `ngOnInit()` method in the test
    and expect that our component''s counter property has now been set to `12`. This
    actually means that the following things happen:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于我们想要检查`getFromStorage()`方法是否被调用并返回保存的值的测试，我们首先使用`CounterServiceMock.getFromStorage.mockReturnValue(12);`语句。这确保了当调用`getFromStorage()`方法时，它会返回值`12`。然后，我们只需在测试中运行`ngOnInit()`方法，并期望我们组件的counter属性现在已经设置为`12`。这实际上意味着发生了以下事情：
- en: '`ngOnInit()` calls the `getFromStorage()` method.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ngOnInit()`调用`getFromStorage()`方法。'
- en: '`getFromStorage()` returns the previously saved value (in our case, that''s
    `12`, but in reality, that''ll be fetched from `localStorage`).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getFromStorage()`返回先前保存的值（在我们的情况下是`12`，但实际上，这将从`localStorage`中获取）。'
- en: The component's `counter` property is set to the retrieved value, which, in
    our case, is `12`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件的`counter`属性设置为检索到的值，这里是`12`。
- en: 'Now, for the final test, we just expect that the `saveToStorage` method of
    our `CounterService` is called in each necessary case. For this, we use the following
    types of `expect()` statements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于最终的测试，我们只期望`CounterService`的`saveToStorage`方法在每种必要情况下都被调用。为此，我们使用以下类型的`expect()`语句：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's pretty much about it. Unit tests are fun, aren't they? Now that you've
    understood how it all works, please refer to the next section for some helpful
    resources that you can use for further reading.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大致就是这样。单元测试很有趣，不是吗？现在您已经了解了所有的工作原理，请参考下一节，了解一些有用的资源，以便进行进一步阅读。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation for `jest.fn()` ([https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation))
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.fn()`的官方文档（[https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)）'
- en: Angular's *Component testing scenarios* ([https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios))
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的*组件测试场景*（[https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)）
- en: Using spies on an injected service in a unit test
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单元测试中使用对注入服务的间谍
- en: While you can provide stubs for your services in the unit tests with Jest, sometimes,
    it might feel like an overhead creating a mock for every new service. Let's suppose
    that if the service's usage is limited to one test file, it might make more sense
    to just use spies on the actual injected service. In this recipe, that's exactly
    what we're going to do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project for this recipe resides in `chapter10/start_here/using-spies-on-injected-service`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `npm run test`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should run the unit tests on the console using Jest. You should see something
    similar to the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Unit tests failing for the ''using-spies-on-injected-service''
    project'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.8_B15150.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Unit tests failing for the 'using-spies-on-injected-service' project
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the tests running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tests we have in the code for `CounterComponent` are incomplete. That''s
    because we''re missing the `expect()` blocks and the code to spy on the methods
    of `CounterService`. Let''s get started with the recipe to complete writing the
    tests using spies on the actual `CounterService`, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get an instance of the actual injected service in our tests.
    So, we''ll create a variable and get the injected service in a `beforeEach()`
    method. Update the `counter.component.spec.ts` file as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we''ll write our first `expect()` block for the service. For the test
    that says `''should call the localStorage.getItem method on component init''`,
    add the following `spyOn()` and `expect()` blocks:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run `npm run test` again, you should still see one test failing but the
    rest of them passing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fix the failing test. That is `''should retrieve the last saved
    value from localStorage on component init''`. In this case, we need to spy on
    the `getFromStorage()` method of `CounterService` to return the expected value
    of `12`. To do so, update the test file, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, let''s fix our last test where we expect the `increment()`, `decrement()`,
    and `reset()` methods to call the `saveToStorage()` method of `CounterService`.
    Update the test as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Awesome! With this change, you should see all 12 tests passing. Let's take a
    look at the next section to understand how it works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contained a lot of knowledge from the previous recipes of this chapter.
    However, the key highlight is the `TestBed.inject()` method. Essentially, this
    magical method gets the instance of the provided service – `CounterService` –
    to us. This is the instance of the service that is bound with the instance of
    `CounterComponent`. Since we have access to the same instance of the service that
    is being used by the component's instance, we can spy on it directly and expect
    it to be called – or even mock the returned values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An introduction to Angular TestBed (https://angular.io/guide/testing-services#angular-testbed)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the ng-mocks package
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests mostly revolve around testing components in isolation. However, what
    if your component depends completely on another component or directive to work
    properly? In such cases, you usually provide a mock implementation for the component,
    but that is a lot of work. However, with the `ng-mocks` package, it is super easy.
    In this recipe, we'll learn an advanced example of how to use `ng-mocks` for a
    parent component that depends on a child component to work properly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/mocking-components-with-ng-mocks`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – The mocking-components-with-ng-mocks app running on http://localhost:4200'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.9_B15150.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – The mocking-components-with-ng-mocks app running on http://localhost:4200
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run the `yarn test` command or the `npm run test` command, you''ll see
    that not all of our tests pass. Additionally, there are a bunch of errors on the
    console, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – An unknown elements error during unit tests'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.10_B15150.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – An unknown elements error during unit tests
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the recipe to make sure that our tests pass correctly without
    any errors using the `ng-mocks` package:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install the `ng-mocks` package within our project. To do this,
    run the following command from your project root in the Terminal:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we''ll try to fix the tests for `AppComponent`. To only run specific tests
    based on a string regex, we can use the `-t` parameter with the `jest` command.
    Run the following command to only run the tests for `AppComponent`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now you can see that we only run the tests for `AppComponent`, and they fail
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Error – ''app-version-control'' is not a known element'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.11_B15150.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Error – 'app-version-control' is not a known element
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the error shown in *Figure 10.11*, we''ll import `VersionControlComponent`
    into the `TestBed` definition inside the `app.component.spec.ts` file. This is
    so that our test environment also knows the missing `VersionControlComponent`.
    To do this, modify the mentioned file as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you rerun the tests for `AppComponent`, you'll see some fresher and newer
    errors. Surprise! Well, that's what happens with dependencies. We'll discuss the
    details in more detail in the *How it works...* section. However, to fix this,
    let's follow the next steps.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of providing the `VersionControlComponent` directly, we need to mock
    it since we don''t really care about it for the tests for `AppComponent`. To do
    this, update the `app.component.spec.ts` file as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Boom! Problem solved. Run the tests again, just for the `AppComponent`, and
    you should see them all pass as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Passing all of the tests for AppComponent'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.12_B15150.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Passing all of the tests for AppComponent
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about the tests for `VersionControlComponent`. This depends
    on the `ReleaseFormComponent` as well as the `ReleaseLogsComponent`. Let''s mock
    them like a pro this time, using the `MockBuilder` and `MockRender` methods, so
    we can get rid of the errors during the tests. After the update, the `version-control.component.spec.ts`
    file should appear as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run `npm run test` now, you should see all of the tests passing. In the
    next steps, let's actually write some interesting tests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`VersionControlComponent` uses `ReleaseLogsComponent` as a child. Additionally,
    it provides the `releaseLogs` property as `@Input()` to `ReleaseLogsComponent`
    via the `[logs]` attribute. We can actually check whether the input''s value is
    set correctly. To do so, update the `version-control.component.spec.ts` file,
    as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we''ll make sure that when we have a new log created via `ReleaseFormComponent`,
    we show this new log by adding it to the `releaseLogs` array in `VersionControlComponent`.
    Then, we''ll also pass that as `@Input logs` to `ReleaseLogsComponent`. Add the
    following tests to the `version-control.component.spec.ts` file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Boom! We have implemented some interesting tests by using the `ng-mocks` package.
    I absolutely love it every time I use it. Now that we've finished the recipe,
    in the next section, let's take a look at how it all works.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of interesting things that we have covered in this recipe.
    First of all, to avoid any errors on the console complaining about unknown components,
    we use the `MockComponent` method from the `ng-mocks` package, to declare the
    components we're dependent on, as mocks. That is absolutely the simplest thing
    we achieve with the `ng-mocks` package. However, we do move on to an advanced
    situation, which I will admit is sort of an unconventional approach; that is testing
    the `@Input` and `@Output` emitters of the child components in the parent component
    in order to test an entire flow. This is what we do for the tests of `VersionControlComponent`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we remove the usage of the `@angular/core/testing` package completely
    from the `version-control.component.spec.ts` file. This is because we're no longer
    using `TestBed` to create the test environment. Instead, we use the `MockBuilder`
    method from the `ng-mocks` package to build the test environment for our `VersionControlComponent`.
    Then, we use the `.mock()` method to mock each child component that we want to
    work with inside the tests later on. The `.mock()` method is not only used to
    mock components, but it can also be used to mock services, directives, pipes,
    and more. Please refer to the next section for further resources to read.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `''should add the new log when it is created via ReleaseFormComponent''`
    test, pay attention to the `ngMocks.find()` method, which we use to find the relevant
    component and get its instance. Its use is relatively similar to what we would
    do in `TestBed`, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, using `ngMocks.find()` is better suited, as it has better support for
    types. Once we get a hold of the instance of `ReleaseFormComponent`, we use the
    `@Output` named `newReleaseLog` to create a new log using the `.emit()` method.
    Then, we do a quick `fixture.detectChanges()` to trigger the Angular change detection.
    We also check the `VersionControl.releaseLogs` array to determine whether our
    new release log has been added to the array. Afterward, we also check the `ReleaseLogsComponent.logs`
    property to make sure that the child component has updated the `logs` array via
    `@Input`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don't use a spy on the `VersionControlComponent.addNewReleaseLog`
    method. That is because if we do so, that function will become a Jest spy function.
    Therefore, it'll lose its functionality inside. In return, it'll never add the
    new log to the `releaseLogs` array, and none of our tests will pass. You can try
    it out for fun.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ng-mocks `.mock` method ([https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock))
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ng-mocks official documentation ([https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu))
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating even easier component tests with Angular CDK component harnesses
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests for components, there might be scenarios where you'd actually
    want to interact with the DOM elements. Now, this can already be achieved by using
    the `fixture.debugElement.query` method to find the element using a selector and
    then triggering events on it. However, that means maintaining it for different
    platforms, knowing the identifiers of all the selectors, and then exposing all
    of that in the tests. And this is even worse if we're talking about an Angular
    library. It certainly isn't necessary for each developer who interacts with my
    library to know all the element selectors in order to write the tests. Only the
    author of the library should know that much to respect encapsulation. Luckily,
    we have the component harnesses from the Angular CDK team, which were released
    with Angular 9 along with the IVY compiler. And they've led by example, by providing
    component harnesses for the Angular material components as well. In this recipe,
    you'll learn how to create your own component harnesses.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/tests-using-cdk-harness`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The tests-using-cdk-harness app running on http://localhost:4200'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.13_B15150.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – The tests-using-cdk-harness app running on http://localhost:4200
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the app running, let's move on to the next section to follow
    the recipe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have our favorite Angular version control app that allows us to create release
    logs. And we have the tests written already, including tests that interact with
    the DOM element to validate a few use cases. Let''s follow the recipe to use component
    harnesses instead, and discover how easy it becomes to use in the actual tests:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window/tab and ensure you''re inside the `chapter10/start_here/tests-using-cdk-harness`
    folder. Once inside, run the following command to install the Angular CDK:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You have to restart your Angular server. So, rerun the `ng serve` command.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we''ll create a **component harness** for the `ReleaseFormComponent`.
    Let''s create a new file inside the `release-form` folder, and name it `release-form.component.harness.ts`.
    Then, add the following code inside it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we need to set up the harness environment for our tests for `VersionControlComponent`.
    For this, we''ll use `HarnessLoader` and `TestbedHarnessEnvironment` from the
    Angular CDK. Update the `version-control.component.spec.ts` file as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s write some methods in our `ReleaseFormComponentHarness` class to
    get the relevant information. We''ll use these methods in the later steps. Update
    the `release-form.component.harness.ts` file as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll work on our first test, named `''should have the first app selected
    for the new release log''`, with the component harness. Update the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now if you run `npm run test`, you should see all of the tests passing, which
    means our first test with the component harness works. Woohoo!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll work on our second test, that is, for `''should show error on wrong
    version number input''`. Update the test in the `version-control.component.spec.ts`
    file, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Boom! Note that we just reduced the lines of code for this test from nine statements
    to only four statements. Isn't that amazing? I believe it is awesome and much
    cleaner, to be honest.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final test, we also need a component harness for `ReleaseLogsComponent`.
    Let''s quickly create it. Add a new file inside the `release-logs` folder, named
    `release-logs.component.harness.ts`, and add the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, let''s modify our final tests in the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Voila! That's some amazing testing right there using the Angular CDK component
    harnesses. If you run the tests now, you should see all of the tests passing.
    Now that you've finished the recipe, please refer to the next section to learn
    how this works.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right! That was a cool recipe, which I enjoyed working on myself. The key
    factor of this recipe is the `@angular/cdk/testing` package. If you have worked
    with `e2e` tests using Protractor before, this is a similar concept to the `Pages`
    in Protractor. First, we create a component harness for both the `ReleaseLogsComponent`
    and the `ReleaseFormComponent`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we import the `ComponentHarness` class from `@angular/cdk/testing`
    for both component harnesses. Then, we extend our custom classes called `ReleaseFormComponentHarness`
    and `ReleaseLogsComponentHarness` from the `ComponentHarness` class. Essentially,
    this is the correct way to author component harnesses. Did you notice the static
    property called `hostSelector`? We need this property for every component harness
    class that we create. And the value is always the selector of the target element/component.
    This ensures that when we load this harness into the test environment, the environment
    is able to find the host element in the DOM – for which we're creating the component
    harness. In our component harness class, we use the `this.locatorFor()` method
    to find elements within the host component. The `locateFor()` method takes a single
    argument as the `css selector` of the element to be found and returns an `AsyncFactoryFn`.
    This means the returned value is a function that we can use at a later time to
    get the required elements.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the `ReleaseFormComponentHarness` class, we find the submit button, the app
    name input, and the version number input using the `protected` methods' `getSubmitButton`,
    `getAppNameInput`, and `getAppVersionInput`, respectively, which are all of the
    `AsyncFactoryFn` type, as mentioned earlier. We have these methods set as `protected`
    because we don't want the people writing the unit tests to access or care about
    the information of the DOM elements. This makes it much easier for everyone to
    write tests without worrying about the internal implementation of accessing the
    DOM.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `getVersionErrorEl()` method is slightly different. It is not
    actually of the `AsyncFactoryFn` type. Instead, it is a regular `async` function
    that first calls the `locatorForAll` method to get all the elements with the `alert`
    class and the `alert-danger` class, which results in the error messages. Then,
    it selects the second alert element, which is for the app version number input.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to mention here is that when we call the `locatorFor()`
    method or the `locatorForAll()` method, we get back a `Promise` with the `TestElement`
    item or a `Promise` with a list of `TestElement` items, respectively. Each `TestElement`
    item has a bunch of handy methods such as `.click()`, `.sendKeys()`, `.focus()`,
    `.blur()`, `.getProperty()`, `.text()`, and more. And these methods are what we're
    interested in since we use them behind the scenes to interact with the DOM elements.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about configuring the test environment. In the `version-control.component.spec.ts`
    file, we set up the environment to use component harnesses for both `ReleaseLogsComponent`
    and `ReleaseFormComponent`. The `TestbedHarnessEnvironment` element is the key
    element here. We use the `.loader()` method of the `TestbedHarnessEnvironment`
    class by providing our `fixture` as an argument. Note that the fixture is what
    we get in the test environment using the `TestBed.createComponent(VersionControlComponent)`
    statement. Because we provide this fixture to the `TestbedHarnessEnvironment.loader()`
    method, we get back an element of the `HarnessLoader` statement, which can now
    load component harnesses for the other components – that is, for `ReleaseLogsComponent`
    and `ReleaseFormComponent`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the tests, we use the `harnessLoader.getHarness()` method by
    providing the harness class as an argument. This enables the test environment
    to find the DOM element associated with the `hostSelector` property of the harness
    class. Additionally, we get back the instance of the component harness that we
    can use further in the test.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding components in the DOM with component harnesses (`https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom`)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*API for component harness authors* (`https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors`)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing components with Observables
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're building an Angular application, it is very likely that you'll work
    with Observables inside the app at some point. For instance, you could be fetching
    data from a third-party API or perhaps just managing the state. In either case,
    it becomes slightly difficult to test applications that have Observables in action.
    In this recipe, we're going to learn how to test unit tests with Observables.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter10/start_here/unit-testing-observables`.
    Perform the following steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The unit-testing-observables app running on http://localhost:4200'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.14_B15150.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – The unit-testing-observables app running on http://localhost:4200
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's take a
    look at the steps of the recipe.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by writing test cases, which technically involve the usage of
    Observables. Essentially, we have to mock the methods using Observables, and we
    have to use the `fakeAsync` and `tick()` methods provided by Angular to reach
    our goal of writing good unit tests with Observables. Let''s get started:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we''ll write a test to see what happens when we use an
    `expect()` clause in a test that involves a function containing an Observable.
    Update the `users.component.spec.ts` file by adding a test, which checks whether
    we get the users from the server when the component initiates:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, as soon as you run the `npm run test` command, you''ll see that the test
    fails with the following message:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Error – Cannot make XHRs from within a fake async test'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.15_B15150.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Error – Cannot make XHRs from within a fake async test
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that we can't make real HTTP calls from the `fakeAsync` tests,
    which is what happens after the `ngOnInit()` method is called.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper way to test this is to mock `UserService`. Luckily, we''ve already
    done this as we have the `UserServiceMock` class in the project. We need to provide
    it as a `useClass` property for `UserService` in `TestBed` and update our test
    slightly. Let''s modify the `users.component.spec.ts` file as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, if you run the tests again, they should pass. We'll cover this in more
    detail in the *How it works...* section later.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test for a scenario in which we want to search users. We''ll
    set the value for the `username` form control and search users using `UserService`,
    or more technically, `UserServiceMock`. Then, we will expect the results to be
    appropriate. Add a test in the `users.component.spec.ts` file as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we''ll write a test for `UserDetailComponent`. We need to test that our
    `UserDetailComponent` gets the appropriate user from the server when the component
    is initiated and that we get similar users as well. Update the `user-detail.component.spec.ts`
    file by adding a test, as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The new test should be failing at the moment. We will fix it in the next steps.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug, we can quickly add a `console.log()` to the `params` that we get
    from subscribing to the `route.paramMap` Observable in the `ngOnInit()` method.
    Modify the `user-detail.component.ts` file, and then run the tests again:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now when you run the tests, you can see the error, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Error – empty params and missing uuid'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.16_B15150.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – Error – empty params and missing uuid
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 10.16*, we don''t have the `uuid` in the `Params`
    object. This is because it is not a real routing process for a real user. So,
    we need to mock the `ActivatedRoute` service that is used in `UserDetailComponent`
    to get the desired result. Let''s create a new file inside the `__mocks__` folder,
    named `activated-route.mock.ts`, and add the following code to it:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we''ll use this mock in our tests for `UserDetailComponent`. Update the
    `user-detail.component.spec.ts` file, as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that we have injected the mock into the test environment, let''s modify
    our test to get the second user from the `DUMMY_USERS` array. Update the tests
    file as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we''ll write a test that allows us to get similar users when `UserDetailComponent`
    is loaded. Remember that according to our current business logic, similar users
    are all users except the current user on the page, which is saved in the `user`
    property. Let''s add the test in the `user-detail.component.spec.ts` file, as
    follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run the tests, you should see them all pass as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – All of the tests are passing with mocked Observables'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.17_B15150.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.17 – All of the tests are passing with mocked Observables
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Great! You now know how to work with Observables when writing unit tests for
    components. Although there's still a lot to learn about testing Observables in
    Angular, the purpose of this recipe was to keep everything simple and sweet.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have finished the recipe, please refer to the next section to understand
    how it works.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start our recipe by using the `fakeAsync()` and `tick()` methods from the
    `'@angular/core/testing'` package. Notice that we wrap our tests' callback method
    using the `fakeAsync()` method. The method wrapped in the `fakeAsync()` method
    is executed in something called a `fakeAsync` zone. This is contrary to how it
    works in the actual Angular application, which runs inside `ngZone`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In order to work with the `fakeAsync` zone, we need to import the `zone.js/dist/zone-testing`
    library in our test environment. This is usually done in the `src/test.ts` file
    when you create an Angular project. However, since we migrated to Jest, we removed
    that file.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '*"Okay. How does it work then, Ahsan?"* Well, I''m glad you asked. While setting
    up for Jest, we use the `jest-preset-angular` package. This package ultimately
    requires all the necessary files for the `fakeAsync` tests, as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – The jest-preset-angular package importing the required zone.js
    files'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.18_B15150.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.18 – The jest-preset-angular package importing the required zone.js
    files
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the `tick()` method simulates the passage of time in this virtual
    `fakeAsync` zone until all of the asynchronous tasks are finished. It takes a
    parameter as milliseconds, which either reflects how many milliseconds have passed
    or how much the virtual clock has advanced. In our case, we use `500` milliseconds
    as the value for the `tick()` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're mocking `UserService` for the tests for `UsersComponent`.
    Specifically for `'should get users back from the API component init'`, we call
    the `component.ngOnInit()` method in the test and then call the `tick()` method.
    In the meantime, the `ngOnInit()` method calls the `searchUsers()` method, which
    calls the `UserServiceMock.searchUsers()` method since we've provided it as the
    `useClass` property in our test environment for `UserService`. Finally, that returns
    the value of the `DUMMY_USERS` array that we have defined in the `user.service.mock.ts`
    file. The other test for the `UsersComponent`, that is, `'should get the searched
    users from the API upon searching'`, is quite similar as well.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the tests for `UserDetailComponent`, we do something different,
    that is, we also have to mock the `activatedRoute` service. Why? Well, that is
    because the `UserDetailComponent` is a page that can be navigated with a `uuid`
    and because its path is defined as `'/users/:uuid'` in the `app-routing.module.ts`
    file. Therefore, we need to populate this `uuid` parameter in our tests to work
    with the `DUMMY_USERS` array. For this, we use the `ActivatedRouteMock` class
    inside the `__mocks__` folder. Notice that it has a `setParamMap()` method. This
    allows us to specify the `uuid` parameter in our tests. Then, when the actual
    code subscribes to the `this.route.paramMap` Observable, our set `uuid` parameter
    can be found there.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: For the `'should get the user based on routeParams on page load'` test, we set
    the second user's `uuid` from the `DUMMY_USERS` array as the `uuid` route parameter's
    value. Then, we use the `tick()` method, after which we expect the `user` property
    to have the second user from the `DUMMY_USERS` array as the value. The other test
    in the file is also quite similar and self-explanatory. Please refer to the next
    section for more useful links regarding unit testing scenarios.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular testing component scenarios ([https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios))
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing routed Angular components with `RouterTestingModule` ([https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0](https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0))
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing Angular Pipes
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my personal opinion, pipes are the easiest components to test in an Angular
    application. Why? Well, this is because they're (supposed to be) pure functions
    that return the same result based on the same set of inputs. In this recipe, we'll
    write some tests for a really simple pipe in an Angular application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter10/start_here/unit-testing-pipes`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in Visual Studio Code.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – The unit-testing-pipes app running on http://localhost:4200'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_10.19_B15150.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.19 – The unit-testing-pipes app running on http://localhost:4200
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have a simple recipe that takes two inputs – the digit and the max
    factor value. Based on these inputs, we show a multiplication table. We already
    have the `MultTablePipe` that is working fine according to our business logic.
    We''ll now write some unit tests to validate our inputs and expected outputs,
    as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our first test for `MultTablePipe`. We''ll make sure it returns
    an empty array when we have an invalid value for the `digit` input. Update the
    `mult-table.pipe.spec.ts` file, as follows:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s write another test to validate the `limit` input so that we also return
    an empty array if it is invalid:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we''ll write a test to validate the output of the pipe''s transform method
    when both the `digit` and `limit` inputs are valid. In this scenario, we should
    get back the array containing the multiplication table. Write another test as
    follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Right now, within the app, we have the possibility to provide decimal digits
    for the `limit` input. For instance, we can write `2.5` as the max factor in the
    input. To handle this, we use a `Math.floor()` in `MultTablePipe` to round it
    down to the lower number. Let''s write a test to make sure this works:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Easy peasy! Writing tests for Angular pipes is so straightforward that I love
    it. We could call this the power of pure functions. Now that you've finished the
    recipe, please refer to the next section for more informative links.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing Angular pipes official documentation ([https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes))
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test Angular Pipes With Services* ([https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576))'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
