- en: Vue Router Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is a vitally important part of any **Single Page Application** (**SPA**).
    This chapter focuses on maximizing the Vue router and looks at everything from
    routing a user between pages, to parameters, to optimal configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing routing in a Vue.js application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic route matching to create route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing route parameters as component props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern JavaScript applications implement a pattern known as an SPA. In its most
    simplistic form, it can be thought of as an application that displays components
    based on a URL. As the templates are mapped to routes, there is no need for a
    page reload, as they can be injected depending on where the user navigated.
  prefs: []
  type: TYPE_NORMAL
- en: This is the job of the router.
  prefs: []
  type: TYPE_NORMAL
- en: By creating our application this way, we're able to increase both perceived
    and actual speed, because our application is much more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's spin up a playground project and install the `vue-router` library. This
    allows us to take advantage of routing inside our application and give us the
    power of a modern SPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re using webpack as part of our build system, we''ve installed the router
    with `npm`. We can then initialize the router inside of `src/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This effectively registers `VueRouter` as a global plugin. A plugin simply is
    just a function that receives `Vue` and `options` as parameters and allows libraries
    such as `VueRouter` to add functionality to our Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can then define two small components inside our `main.js` file that simply
    have a template that shows `h1` with some text inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order to display these components on screen at particular URLs (such
    as `/hello` and `/world`), we can define routes inside our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've defined what components we want to use as well as the routes
    inside of our application, we'll need to create a new instance of `VueRouter`
    and pass along the routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we''ve used `Vue.use(VueRouter)`, we still need to create a new instance
    of `VueRouter` and initialize our routes. This is because merely registering `VueRouter`
    as a plugin gives us access to the router option within our Vue instance(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to pass the `router` to our root Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to display our routed components inside of our `App.vue` component,
    we need to add the `router-view` component inside the `template`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then navigate to `/#/hello/` or `/#/world`, the appropriate component
    is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b3d1083e-1788-45d4-a2cf-b4bdd945c407.png)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also dynamically match routes depending on a particular parameter. This
    is done by specifying a route with a colon before the parameter name. Here''s
    an example using a similar greeting component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If our user navigates to `/hello`, they'll see `h1` with the text `Hello`. Otherwise,
    if they navigate to `/hello/{name}` (that is, Paul), they'll see `h1` with the
    text `Hello Paul`.
  prefs: []
  type: TYPE_NORMAL
- en: We've made a lot of progress, but it's important to know that when we navigate
    to parameterized URLs, component lifecycle hooks aren't fired again if the parameter
    changes (that is, from `/hello/paul` to `/hello/katie`). We'll look at this soon!
  prefs: []
  type: TYPE_NORMAL
- en: Route props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s change our `/hello/name` route to pass the `name` parameter as a `component`
    prop, which can be done by adding the `props: true` flag to the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update our component to take in a prop with an `id` of name and
    also log this to the console within the life cycle hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then try and navigate to different dynamic routes, we''ll see that the
    created hook only fires once (unless we refresh the page) even though our page
    shows the correct name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dde3492f-a29a-427f-a5e8-734c819d56f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Component Navigation Guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we fix the lifecycle hook problem? In this instance, we can use what's
    known as a Navigation Guard. This allows us to hook into different lifecycles
    of the router, such as the `beforeRouteEnter`, `beforeRouteUpdate`, and `beforeRouteLeave`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: beforeRouteUpdate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the `beforeRouteUpdate` method to access information about the route
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we check the JavaScript console after navigating to a different route under
    `/hello/{name}`, we'll be able to see which route the user is going to and where
    they are coming from. The `to` and `from` objects also give us access to `params`,
    queries, the full path, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we correctly get the log statements, if we try and navigate between routes,
    you''ll note that our application doesn''t update with the parameter `name` prop.
    This is because we haven''t used the `next` function after we''ve finished doing
    any computations within the guard. Let''s add that in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: beforeRouteEnter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also take advantage of `beforeRouteEnter` to perform actions prior to
    entering the component route. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We still have to call `next` to pass the stack down to the next route handler.
  prefs: []
  type: TYPE_NORMAL
- en: beforeRouteLeave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also hook into `beforeRouteLeave` to perform actions whenever we''re
    navigating away from a route. As we''re already on this route within the context
    of this hook, we have access to the component instance. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have to call `next` in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Global router hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at component Navigation Guards and while these work on a component-by-component
    basis, you may want to establish global hooks that listen to navigation events.
  prefs: []
  type: TYPE_NORMAL
- en: beforeEach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use `router.beforeEach` to listen for routing events globally across
    the application. This is worth using if you have authentication checks or other
    pieces of functionality that should be used in every route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that simply logs out the route the user is going to and
    coming from. Each one of the following examples assume that the router exists
    in scope similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have to call `next()` to trigger the next route guard.
  prefs: []
  type: TYPE_NORMAL
- en: beforeResolve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `beforeResolve` global route guard is triggered just before navigation is
    confirmed, but it's important to know that this is only after all component-specific
    guards and async components have been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: afterEach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also hook into the global `afterEach` function that allows us to perform
    the action(s), but we can''t affect navigation and thus only have access to the
    `to` and `from` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Resolution stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve familiarized ourselves with the various different route lifecycle
    hooks on offer, it''s worth investigating the entire resolution stack whenever
    we attempt to navigate to another route:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger a route change**:This is the first stage of any route lifecycle and
    is triggered any time we *attempt* to navigate to a new route. An example would
    be going from `/hello/Paul` to `/hello/Katie`. No Navigation Guards have been
    triggered at this point.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger component leave guards**:Next, any leave guards are triggered, such
    as `beforeRouteLeave`, on loaded components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger global beforeEach guards**:As global route middleware can be created
    with `beforeEach`, these functions will be called prior to any route update.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger local beforeRouteUpdate** **guards in reused components**:As we saw
    earlier, whenever we navigate to the same route with a different parameter, the
    lifecycle hooks aren''t fired twice. Instead, we use `beforeRouteUpdate` to trigger
    lifecycle changes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger beforeRouteEnter in components**:This is called each time prior to
    navigating to any route. At this stage, the component isn''t rendered, so it doesn''t
    have access to the `this` component instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resolve asynchronous route components**:It then attempts to resolve any asynchronous
    components in your project. Here''s an example of one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Trigger beforeRouteEnter in successfully activated components**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have access to the `beforeRouteEnter` hook and can perform any action(s)
    prior to resolving the route.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger global beforeResolve hooks**:Providing in-component guards and async
    route components have been resolved, we can now hook into the global `router.beforeResolve`
    method that allows us to perform action(s) at this stage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Navigation**:All prior Navigation Guards have been fired, and the user is
    now successfully navigated to a route.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger afterEach hooks**:Although the user has been navigated to the route,
    it doesn''t stop there. Next, the router triggers a global `afterEach` hook that
    has access to the `to` and `from` parameters. As the route has already been resolved
    at this stage, it doesn''t have the next parameter and thus cannot affect navigation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger DOM updates**:Routes have been resolved, and Vue can appropriately
    trigger DOM updates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger callbacks within next in beforeRouteEnter**:As `beforeRouteEnter`
    does not have access to the component''s `this` context, the `next` parameter
    takes a callback that resolves to the component instance on navigation. An example
    can be seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Programmatic navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re not limited to template navigation using `router-link`; we can also
    programmatically navigate the user to different routes from within our JavaScript.
    Inside of our `App.vue`, let''s expose the `<router-view>` and give the user the
    ability to select a button that will navigate them to either the `/hello` or `/hello/:name`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can then add a method that pushes a new route onto the route stack*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, any time we select a button, it should subsequently navigate
    the user to the appropriate route. The `$router.push()` function can take a variety
    of different arguments, depending on how you have your routes set up. Here are
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: router.replace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of pushing a navigation item on the stack, we can also replace the
    current history stack with `router.replace`. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: router.go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to navigate the user backward or forward, we can use `router.go`;
    this is essentially an abstraction over the `window.history` API. Let''s take
    a look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Lazy loading routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also lazy load our routes to take advantage of code splitting with webpack.
    This allows us to have greater performance than when eagerly loading our routes.
    To do this, we can create a small playground project. Run the following in your
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start off by creating two components, named `Hello.vue` and `World.vue`,
    inside `src/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have created our `Hello.vue` component, let''s create the second `World.vue`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then initialize our router as we usually do, inside `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference has to do with the way in which to import our components.
    This requires the use of the `syntax-dynamic-import` Babel plugin. Install it
    into your project by running the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update `.babelrc` to use the new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this allows us to import our components asynchronously, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define our routes and initialize the router, this time referencing
    the asynchronous import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then see its results by looking in Chrome via Developer Tools | Network
    tab while navigating through our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff7dcc30-147c-4a86-a2de-d3d406500244.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each route is added to its own bundle file and subsequently gives us an improved
    performance as the initial bundle is much smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cd3f60f3-23a1-4d33-b4ac-3238740e8329.png)'
  prefs: []
  type: TYPE_IMG
- en: An SPA project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a project that uses a RESTful API and the routing concepts that
    we''ve just learned. Create a new project by running the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Enabling the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can start off by enabling the `VueRouter` plugin within our application.
    To do this, we can create a new file inside `src/router` named `index.js`. We'll
    use this file to contain all the router-specific configuration, but we'll separate
    out each route into different files depending on the underlying feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import and add the router plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Defining routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To separate out the routes into different files within our application, we can
    first create a file under `src/components/user` named `user.routes.js`. Each time
    we have a different feature set (that requires routes), we can create our own
    `*.routes.js` file that can be imported into the router's `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we can just export a new empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the routes to our `index.js` (even though we have none defined
    yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We're using the ES2015+ spread operator, which allows us to use each object
    in the array instead of the array itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To then initialize the router, we can then create a new `VueRouter` and pass
    along the routes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s export the router so that it can be used inside our main Vue
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `main.js`, let''s import the router and add it to the instance, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Creating the UserList route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first section of our application will be a home page that displays a list
    of users from an API. We've used this example in the past, so you should be familiar
    with the steps involved. Let's create a new component under `src/components/user`
    named `UserList.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to add your own test data at this point. We'll be requesting this
    data from the API momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve created our component, we can then add a route to `user.routes.js`,
    which displays this component whenever the `''/''` (or a path of your choice)
    is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to show this route, we need to update `App.vue` to subsequently inject
    the content into a `router-view` node. Let''s update `App.vue` to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our application should then display a single user. Let's create an HTTP utility
    to get data from an API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file under `src/utils` named `api.js`. This will be used to create
    a base instance of `Axios`, which we can then perform HTTP requests on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `beforeRouteEnter` Navigation Guard to get user data whenever
    someone navigates to the `''/''` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We then find that we get a list of users on screen, as illustrated in the following
    screenshot, each represented as a different list item. The next step is to create
    a `detail` component, register the detail route, and find a way to link to that
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7eeabc93-4aaa-486c-8426-2df9838d78cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a detail page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create a detail page, we can create `UserDetail.vue` and follow
    steps similar to the previous component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As there should never be more than one user inside of our detail page, the `userInfo`
    variable has been created as a JavaScript object rather than an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then add the new component to our `user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to link to this component, we can add `router-link` within our `UserList`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then take a look in our browser we can see that there is only one user
    listed with the information underneath coming from the user detail linked to that
    one user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/362ddaab-acc1-4f18-bb20-8129a048dcfe.png)'
  prefs: []
  type: TYPE_IMG
- en: Child routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also access posts from our API, and as a result, we can display both
    the posts'' information alongside our user information. Let''s create a new component
    named `UserPosts.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to get posts based on our `userId` route parameter. In order
    to display this component as a child view, we''ll need to register it as such
    within the `user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add another `<router-view>` tag inside our `UserDetail.vue` component
    to display the child route. The template now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To top it off, we''ve also added some styles that display the user information
    on the left and posts on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then head to our browser, we can see how the data appears just as we
    had planned, with the user information displaying on the left and the posts on
    the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8bfff65d-623a-47b0-98c0-fef25fe81962.png)'
  prefs: []
  type: TYPE_IMG
- en: Ta-da! We've now created a Vue application with multiple routes, child routes,
    parameters, and more!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we learned about the Vue Router and how we can use it to create
    Single Page Applications. As a result, we covered everything from initializing
    the router plugin to defining routes, components, Navigation Guards, and much
    more. We now have the necessary knowledge to create Vue applications that scale
    past a singular component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have expanded our knowledge and understand how to use the Vue Router,
    we can move on to handling state management with `Vuex` in the next chapter.
  prefs: []
  type: TYPE_NORMAL
