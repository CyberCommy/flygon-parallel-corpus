- en: Chapter 3. Thread Synchronization Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling concurrent access to a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling concurrent access to multiple copies of a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for multiple concurrent events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing tasks in a common point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running concurrent phased tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling phase change in concurrent phased tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing data between concurrent tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Basic Thread Synchronization"), *Basic
    thread synchronization*, we learned the concepts of synchronization and critical
    section. Basically, we talk about synchronization when more than one concurrent
    task shares a resource, for example, an object or an attribute of an object. The
    blocks of code that access this shared resource are called critical sections.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use the appropriate mechanisms, you can have the wrong results,
    data inconsistency, or error conditions, so we have to adopt one of the synchronization
    mechanisms provided by the Java language to avoid all these problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. Basic Thread Synchronization"), *Basic thread
    synchronization*, taught us about the following basic synchronization mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: The `synchronized` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Lock` interface and its implementation classes: `ReentrantLock`, `ReentrantReadWriteLock.ReadLock`,
    and `ReentrantReadWriteLock.WriteLock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to use high-level mechanisms to get the
    synchronization of multiple threads. These high-level mechanisms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Semaphores**: A semaphore is a counter that controls the access to one or
    more shared resources. This mechanism is one of the basic tools of concurrent
    programming and is provided by most of the programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CountDownLatch**: The `CountDownLatch` class is a mechanism provided by the
    Java language that allows a thread to wait for the finalization of multiple operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CyclicBarrier**: The `CyclicBarrier` class is another mechanism provided
    by the Java language that allows the synchronization of multiple threads in a
    common point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phaser**: The `Phaser` class is another mechanism provided by the Java language
    that controls the execution of concurrent tasks divided in phases. All the threads
    must finish one phase before they can continue with the next one. This is a new
    feature of the Java 7 API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exchanger**: The `Exchanger` class is another mechanism provided by the Java
    language that provides a point of data interchange between two threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphores are a generic synchronization mechanism that you can use to protect
    any critical section in any problem. The other mechanisms are thought to be used
    in applications with specific features as it was described previously. Be sure
    to select the appropriate mechanism according to the characteristics of your application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents seven recipes that show you how to use the mechanisms
    described.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling concurrent access to a resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the semaphore mechanism provided by
    the Java language. A semaphore is a counter that protects the access to one or
    more shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was
    used for the first time in the THEOS operating system.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread wants to access one of these shared resources, first, it must
    acquire the semaphore. If the internal counter of the semaphore is greater than
    `0`, the semaphore decrements the counter and allows access to the shared resource.
    A counter bigger than `0` means there are free resources that can be used, so
    the thread can access and use one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the counter of the semaphore is `0`, the semaphore puts the thread
    to sleep until the counter is greater than `0`. A value of `0` in the counter
    means all the shared resources are used by other threads, so the thread that wants
    to use one of them must wait until one is free.
  prefs: []
  type: TYPE_NORMAL
- en: When the thread has finished the use of the shared resource, it must release
    the semaphore so that the other thread can access the shared resource. That operation
    increases the internal counter of the semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `Semaphore` class to implement
    special kinds of semaphores called **binary semaphores** . These kinds of semaphores
    protect the access to a unique shared resource, so the internal counter of the
    semaphore can only take the values `1` or `0`. To show how to use it, you are
    going to implement a print queue that can be used by concurrent tasks to print
    their jobs. This print queue will be protected by a binary semaphore, so only
    one thread can print at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `PrintQueue` that will implement the print queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Semaphore` object. Call it `semaphore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. It initializes the `semaphore` object
    that will protect the access from the print queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `printJob()` method that will simulate the printing of a document.
    It receives `Object` called `document` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inside the method, first of all, you must acquire the semaphore calling the
    `acquire()` method. This method can throw an `InterruptedException` exception,
    so you must include some code to process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, implement the lines that simulate the printing of a document waiting for
    a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, free the semaphore by calling the `release()` method of the semaphore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Create a class called `Job` and specify that it implements the `Runnable` interface.
    This class implements a job that sends a document to the printer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `PrintQueue` object. Call it `printQueue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. It initializes the `PrintQueue` object
    declared in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, the method writes a message to the console that shows that the job has
    started its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, it calls the `printJob()` method of the `PrintQueue` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the method writes a message to the console that shows that it has finished
    its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    implement the `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Create a `PrintQueue` object named `printQueue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create 10 threads. Each one of those threads will execute a `Job` object that
    will send a document to the print queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, start the 10 threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to this example is in the `printJob()` method of the `PrintQueue` class.
    This method shows the three steps you must follow when you use a semaphore to
    implement a critical section, and protect the access to a shared resource:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you acquire the semaphore, with the `acquire()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you do the necessary operations with the shared resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, release the semaphore with the `release()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another important point in this example is the constructor of the `PrintQueue`
    class and the initialization of the `Semaphore` object. You pass the value `1`
    as the parameter of this constructor, so you are creating a binary semaphore.
    The initial value of the internal counter is `1`, so you will protect the access
    to one shared resource, in this case, the print queue.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the 10 threads, the first one acquires the semaphore and gets
    the access to the critical section. The rest are blocked by the semaphore until
    the thread that has acquired it, releases it. When this occurs, the semaphore
    selects one of the waiting threads and gives it the access to the critical section.
    All the jobs print their documents, but one by one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Semaphore` class has two additional versions of the `acquire()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`acquireUninterruptibly()`: The `acquire()` method; when the internal counter
    of the semaphore is `0`, blocks the thread until the semaphore is released. During
    this blocked time, the thread may be interrupted and then this method throws an
    `InterruptedException` exception. This version of the acquire operation ignores
    the interruption of the thread and doesn''t throw any exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryAcquire()`: This method tries to acquire the semaphore. If it can, the
    method returns the `true` value. But if it can''t, the method returns the `false`
    value instead of being blocked and waits for the release of the semaphore. It''s
    your responsibility to take the correct action based on the `return` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fairness in semaphores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of fairness is used by the Java language in all classes that can
    have various threads blocked waiting for the release of a synchronization resource
    (for example, a semaphore). The default mode is called the **non-fair mode** .
    In this mode, when the synchronization resource is released, one of the waiting
    threads is selected to get this resource, but it's selected without any criteria.
    The **fair mode** changes this behavior and forces to select the thread that has
    been waiting for more time.
  prefs: []
  type: TYPE_NORMAL
- en: As occurs with other classes, the `Semaphore` class admits a second parameter
    in its constructor. This parameter must take a `Boolean` value. If you give it
    the `false` value, you are creating a semaphore that will work in non-fair mode.
    You will get the same behavior if you don't use this parameter. If you give it
    the `true` value, you are creating a semaphore that will work in fair mode.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Modifying Lock fairness* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling concurrent access to multiple copies of a resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Controlling concurrent access to a resource* recipe, you learned the
    basis of semaphores.
  prefs: []
  type: TYPE_NORMAL
- en: In that recipe, you implemented an example using binary semaphores. These kinds
    of semaphores are used to protect the access to one shared resource, or to a critical
    section that can only be executed by one thread at a time. But semaphores can
    also be used when you need to protect various copies of a resource, or when you
    have a critical section that can be executed by more than one thread at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a semaphore to protect more than one
    copy of a resource. You are going to implement an example, which has one print
    queue that can print documents in three different printers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the example described in the *Controlling concurrent access to a resource*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, you are going to modify the print queue example implemented
    with semaphores. Open the `PrintQueue` class and declare a `boolean` array called
    `freePrinters`. This array stores printers that are free to print a job and printers
    that are printing a document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, declare a `Lock` object named `lockPrinters`. You will use this object
    to protect the access to the `freePrinters` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Modify the constructor of the class to initialize the new declared objects.
    The `freePrinters` array has three elements, all initialized to the `true` value.
    The semaphore has `3` as its initial value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Modify also the `printJob()` method. It receives an `Object` called `document`
    as the unique parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First of all, the method calls the `acquire()` method to acquire the access
    to the semaphore. As this method can throw an `InterruptedException` exception,
    you must include the code to process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then you get the number of the printer assigned to print this job using the
    private method `getPrinter()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, implement the lines that simulate the printing of a document waiting for
    a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, release the semaphore calling the `release()` method and mark the printer
    used as free, assigning `true` to the corresponding index in the `freePrinters`
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getPrinter()` method. It's a private method that returns an `int`
    value and it has no parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First of all, declare an `int` variable to store the index of the printer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, get the access to the `lockPrinters` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then, find the first `true` value in the `freePrinters` array and save its index
    in a variable. Modify this value to `false`, because this printer will be busy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, free the `lockPrinters` object and return the index of the `true` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `Job` and `Core` classes have no modifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key of this example is in the `PrintQueue` class. The `Semaphore` object
    is created using `3` as the parameter of the constructor. The first three threads
    that call the `acquire()` method will get the access to the critical section of
    this example, while the rest will be blocked. When a thread finishes the critical
    section and releases the semaphore, another thread will acquire it.
  prefs: []
  type: TYPE_NORMAL
- en: In this critical section, the thread gets the index of the printer assigned
    to print this job. This part of the example is used to give more realism to the
    example, but it doesn't use any code related with semaphores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each document is printed in one of the printers. The first one is free.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `acquire()`, `acquireUninterruptibly()`, `tryAcquire()`, and `release()`
    methods have an additional version which has an `int` parameter. This parameter
    represents the number of permits that the thread that uses them wants to acquire
    or release, so as to say, the number of units that this thread wants to delete
    or to add to the internal counter of the semaphore. In the case of the `acquire()`,
    `acquireUninterruptibly()`, and `tryAcquire()` methods, if the value of this counter
    is less than this value, the thread will be blocked until the counter gets this
    value or a greater one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Controlling concurrent access to a resource* recipe in [Chapter 3](ch03.html
    "Chapter 3. Thread Synchronization Utilities"), *Thread Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Modifying lock fairness* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for multiple concurrent events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a class that allows one or more threads to
    wait until a set of operations are made. It's the `CountDownLatch` class . This
    class is initialized with an integer number, which is the number of operations
    the threads are going to wait for. When a thread wants to wait for the execution
    of these operations, it uses the `await()` method. This method puts the thread
    to sleep until the operations are completed. When one of these operations finishes,
    it uses the `countDown()` method to decrement the internal counter of the `CountDownLatch`
    class. When the counter arrives to `0`, the class wakes up all the threads that
    were sleeping in the `await()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `CountDownLatch` class implementing
    a video-conference system. The video-conference system will wait for the arrival
    of all the participants before it begins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Videoconference` and specify that it implements the `Runnable`
    interface. This class will implement the video-conference system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `CountDownLatch` object named `controller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the `CountDownLatch`
    attribute. The `Videoconference` class will wait for the arrival of the number
    of participants received as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `arrive()` method. This method will be called each time a participant
    arrives to the video conference. It receives a `String` type named `name` as the
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, it writes a message with the parameter it has received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then, it calls the `countDown()` method of the `CountDownLatch` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it writes another message with the number of participants, whose arrival
    is pending using the `getCount()` method of the `CountDownLatch` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main method of the video-conference system. It's the `run()` method
    that every `Runnable` object must have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First, use the `getCount()` method to write a message with the number of participants
    in the video conference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, use the `await()` method to wait for all the participants. As this method
    can throw an `InterruptedException` exception, you must include the code to process
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, write a message to indicate that all the participants have arrived.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create the `Participant` class and specify that it implements the `Runnable`
    interface. This class represents each participant in the video conference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Videoconference` attribute named `conference`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes both attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method of the participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, put the thread to sleep for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Then, use the `arrive()` method of the `Videoconference` object to indicate
    the arrival of this participant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Videoconference` object named `conference` that waits for 10 participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Create `Thread` to run this `Videoconference` object and start it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Create 10 `Participant` objects, a `Thread` object to run each of them, and
    start all the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CountDownLatch` class has three basic elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The initialization value that determines how many events the `CountDownLatch`
    class waits for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `await()` method, called by the threads that wait for the finalization of
    all the events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `countDown()` method, called by the events when they finish their execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you create a `CountDownLatch` object, the object uses the constructor's
    parameter to initialize an internal counter. Every time a thread calls the `countDown()`
    method, the `CountDownLatch` object decrements the internal counter in one unit.
    When the internal counter arrives to `0`, the `CountDownLatch` object wakes up
    all the threads that were waiting in the `await()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's no way to re-initialize the internal counter of the `CountDownLatch`
    object or to modify its value. Once the counter is initialized, the only method
    you can use to modify its value is the `countDown()` method explained earlier.
    When the counter arrives to `0`, all the calls to the `await()` method return
    immediately and all subsequent calls to the `countDown()` method have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some differences with respect to other synchronization methods, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CountDownLatch` mechanism is not used to protect a shared resource or a
    critical section. It is used to synchronize one or more threads with the execution
    of various tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It only admits one use. As we explained earlier, once the counter of `CountDownLatch`
    arrives at `0`, all the calls to its methods have no effect. You have to create
    a new object if you want to do the same synchronization again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the last participants arrive and, once the internal counter
    arrives to `0`, the `CountDownLatch` object wakes up the `Videoconference` object
    that writes the messages indicating that the video conference should start.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CountDownLatch` class has another version of the `await()` method, which
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await`(`long``time,``TimeUnit``unit`): The thread will be sleeping until it''s
    interrupted; the internal counter of `CountDownLatch` arrives to `0` or specified
    time passes. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing tasks in a common point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a synchronizing utility that allows the synchronization
    of two or more threads in a determined point. It's the `CyclicBarrier` class.
    This class is similar to the `CountDownLatch` class explained in the *Waiting
    for multiple concurrent events* recipe in this chapter, but presents some differences
    that make them a more powerful class.
  prefs: []
  type: TYPE_NORMAL
- en: The `CyclicBarrier` class is initialized with an integer number, which is the
    number of threads that will be synchronized in a determined point. When one of
    those threads arrives to the determined point, it calls the `await()` method to
    wait for the other threads. When the thread calls that method, the `CyclicBarrier`
    class blocks the thread that is sleeping until the other threads arrive. When
    the last thread calls the `await()` method of the `CyclicBarrier` class, it wakes
    up all the threads that were waiting and continues with its job.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting advantage of the `CyclicBarrier` class is that you can pass
    an additional `Runnable` object as an initialization parameter, and the `CyclicBarrier`
    class executes this object as a thread when all the threads have arrived to the
    common point. This characteristic makes this class adequate for the parallelization
    of tasks using the divide and conquer programming technique.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `CyclicBarrier` class to synchronize
    a set of threads in a determined point. You will also use a `Runnable` object
    that will execute after all the threads have arrived to that point. In the example,
    you will look for a number in a matrix of numbers. The matrix will be divided
    in subsets (using the divide and conquer technique), so each thread will look
    for the number in one subset. Once all the threads have finished their job, a
    final task will unify the results of them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: We're going to start the example by implementing two auxiliary classes. First,
    create a class named `MatrixMock`. This class will generate a random matrix of
    numbers between one and 10 where the threads are going to look for a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `private``int` matrix named `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. This constructor will receive the number
    of rows of the matrix, the length of each row, and the number we are going to
    look for as parameters. All the three parameters are of type `int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Initialize the variables and objects used in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Fill the matrix with random numbers. Each time you generate a number, compare
    it with the number you are going to look for. If they are equal, increment the
    counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, print a message in the console, which shows the number of occurrences
    of the number you are going to look for in the generated matrix. This message
    will be used to check that the threads get the correct result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getRow()` method. This method receives an `int` parameter with
    the number of a row in the matrix and returns the row if it exists, and returns
    `null` if it doesn't exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement a class named `Results`. This class will store, in an array,
    the number of occurrences of the searched number in each row of the matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` array named `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. This constructor receives an integer
    parameter with the number of elements of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setData()` method. This method receives a position in the array
    and a value as parameters, and establishes the value of that position in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getData()` method. This method returns the array with the array
    of the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the auxiliary classes, it's time to implement the threads.
    First, implement the `Searcher` class. This class will look for a number in determined
    rows of the matrix of random numbers. Create a class named `Searcher` and specify
    that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `int` attributes named `firstRow` and `lastRow`. These two
    attributes will determine the subset of rows where this object will look for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `MatrixMock` attribute named `mock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Results` attribute named `results`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `number` that will store the number
    we are going to look for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `CyclicBarrier` object named `barrier`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes all the attributes declared
    before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that will search for the number. It uses an internal
    variable called `counter` that will store the number of occurrences of the number
    in each row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Print a message in the console with the rows assigned to this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Process all the rows assigned to this thread. For each row, count the number
    of occurrences of the number you are searching for and store this number in the
    corresponding position of the `Results` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Print a message in the console to indicate that this object has finished searching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Call the `await()` method of the `CyclicBarrier` object and add the necessary
    code to process the `InterruptedException` and `BrokenBarrierException` exceptions
    that this method can throw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the class that calculates the total number of occurrences of
    the number in the matrix. It uses the `Results` object that stores the number
    of appearances of the number in each row of the matrix to make the calculation.
    Create a class named `Grouper` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Results` attribute named `results`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the `Results` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that will calculate the total number of occurrences
    of the number in the array of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Declare an `int` variable and write a message to the console to indicate the
    start of the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Get the number of occurrences of the number in each row using the `getData()`
    method of the `results` object. Then, process all the elements of the array and
    add their value to the `finalResult` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Print the result in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Declare and initialize five constants to store the parameters of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MatrixMock` object named `mock`. It will have 10,000 rows of 1000
    elements. Now, you are going to search for the number five.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Results` object named `results`. It will have 10,000 elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Grouper` object named `grouper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Create a `CyclicBarrier` object called `barrier`. This object will wait for
    five threads. When this thread finishes, it will execute the `Grouper` object
    created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Create five `Searcher` objects, five threads to execute them, and start the
    five threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem resolved in the example is simple. We have a big matrix of random
    integer numbers and you want to know the total number of occurrences of a number
    in this matrix. To get a better performance, we use the divide and conquer technique.
    We divide the matrix in five subsets and use a thread to look for the number in
    each subset. These threads are objects of the `Searcher` class.
  prefs: []
  type: TYPE_NORMAL
- en: We use a `CyclicBarrier` object to synchronize the completion of the five threads
    and to execute the `Grouper` task to process the partial results, and calculate
    the final one.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, the `CyclicBarrier` class has an internal counter to
    control how many threads have to arrive to the synchronization point. Each time
    a thread arrives to the synchronization point, it calls the `await()` method to
    notify the `CyclicBarrier` object that has arrived to its synchronization point.
    `CyclicBarrier` puts the thread to sleep until all the threads arrive to their
    synchronization point.
  prefs: []
  type: TYPE_NORMAL
- en: When all the threads have arrived to their synchronization point, the `CyclicBarrier`
    object wakes up all the threads that were waiting in the `await()` method and,
    optionally, creates a new thread that executes a `Runnable` object passed as the
    parameter in the construction of `CyclicBarrier` (in our case, a `Grouper` object)
    to do additional tasks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CyclicBarrier` class has another version of the `await()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await`(`long``time,``TimeUnit``unit`): The thread will be sleeping until it''s
    interrupted; the internal counter of `CyclicBarrier` arrives to `0` or specified
    time passes. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class also provides the `getNumberWaiting()` method that returns the number
    of threads that are blocked in the `await()` method, and the `getParties()` method
    that returns the number of tasks that are going to be synchronized with `CyclicBarrier`.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting a CyclicBarrier object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CyclicBarrier` class has some points in common with the `CountDownLatch`
    class, but they also have some differences. One of the most important differences
    is that a `CyclicBarrier` object can be reset to its initial state, assigning
    to its internal counter the value with which it was initialized.
  prefs: []
  type: TYPE_NORMAL
- en: This reset operation can be done using the `reset()` method of the `CyclicBarrier`
    class. When this occurs, all the threads that were waiting in the `await()` method
    receive a `BrokenBarrierException` exception. This exception was processed in
    the example presented in this recipe by printing the stack trace, but in a more
    complex application, it could perform some other operation, such as restarting
    their execution or recovering their operation at the point it was interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Broken CyclicBarrier objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `CyclicBarrier` object can be in a special state denoted by **broken**. When
    there are various threads waiting in the `await()` method and one of them is interrupted,
    this thread receives an `InterruptedException` exception, but the other threads
    that were waiting receive a `BrokenBarrierException` exception and `CyclicBarrier`
    is placed in the broken state.
  prefs: []
  type: TYPE_NORMAL
- en: The `CyclicBarrier` class provides the `isBroken()` method, then returns `true`
    if the object is in the broken state; otherwise it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Waiting for multiple concurrent events* recipe in [Chapter 3](ch03.html
    "Chapter 3. Thread Synchronization Utilities"), *Thread Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running concurrent phased tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most complex and powerful functionalities offered by the Java concurrency
    API is the ability to execute concurrent-phased tasks using the `Phaser` class
    . This mechanism is useful when we have some concurrent tasks divided into steps.
    The `Phaser` class provides us with the mechanism to synchronize the threads at
    the end of each step, so no thread starts its second step until all the threads
    have finished the first one.
  prefs: []
  type: TYPE_NORMAL
- en: As with other synchronization utilities, we have to initialize the `Phaser`
    class with the number of tasks that participate in the synchronization operation,
    but we can dynamically modify this number by increasing or decreasing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use the `Phaser` class to synchronize
    three concurrent tasks. The three tasks look for files with the extension `.log`
    modified in the last 24 hours in three different folders and their subfolders.
    This task is divided into three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of the files with the extension `.log` in the assigned folder and
    its subfolders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the list created in the first step by deleting the files modified more
    than 24 hours ago.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the results in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the steps 1 and 2 we check if the list has any elements or not.
    If it hasn't any element, the thread ends its execution and is eliminated from
    the the `phaser` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE like NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `FileSearch` and specify that it implements the `Runnable`
    interface. This class implements the operation of searching for files with a determined
    extension modified in the last 24 hours in a folder and its subfolders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute to store the folder in which the search
    operation will begin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Declare another private `String` attribute to store the extension of the files
    we are going to look for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `List` attribute to store the full path of the files we will
    find with the desired characteristics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Finally, declare a private `Phaser` attribute to control the synchronization
    of the different phases of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that will initialize the attributes of
    the class. It receives as parameters the full path of the initial folder, the
    extension of the files, and the phaser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you have to implement some auxiliary methods that will be used by the
    `run()` method. The first one is the `directoryProcess()` method. It receives
    a `File` object as a parameter and it processes all its files and subfolders.
    For each folder, the method will make a recursive call passing the folder as a
    parameter. For each file, the method will call the `fileProcess()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the `fileProcess()` method. It receives a `File` object as parameter
    and checks if its extension is equal to the one we are looking for. If they are
    equal, this method adds the absolute path of the file to the list of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the `filterResults()` method. It doesn't receive any parameter,
    and filters the list of files obtained in the first phase, deleting the files
    that were modified more than 24 hours ago. First, create a new empty list and
    get the actual date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Then, go through all the elements of the results list. For each path in the
    list of results, create a `File` object for that file and get the last modified
    date for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Then, compare that date with the actual date and, if the difference is less
    than one day, add the full path of the file to the new list of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Finally, change the old results list for the new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the `checkResults()` method. This method will be called at the
    end of the first and the second phase and it will check if the results list is
    empty or not. This method doesn't have any parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: First, check the size of the results list. If it's `0`, the object writes a
    message to the console indicating this circumstance and then, calls the `arriveAndDeregister()`
    method of the `Phaser` object to notify it that this thread has finished the actual
    phase, and it leaves the phased operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, if the results list has elements, the object writes a message to
    the console indicating this circumstance and then, calls the `arriveAndAwaitAdvance()`
    method of the `Phaser` object to notify it that this thread has finished the actual
    phase and it wants to be blocked until all the participant threads in the phased
    operation finish the actual phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The last auxiliary method is the `showInfo()` method that prints to the console
    the elements of the results list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to implement the `run()` method that executes the operation using
    the auxiliary methods described earlier and the `Phaser` object to control the
    change between phases. First, call the `arriveAndAwaitAdvance()` method of the
    `phaser` object. The search won't begin until all the threads have been created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Then, write a message to the console indicating the start of the search task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Check that the `initPath` attribute stores the name of a folder and use the
    `directoryProcess()` method to find the files with the specified extension in
    that folder and all its subfolders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Check if there are any results using the `checkResults()` method. If there are
    no results, finish the execution of the thread with the `return` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Filter the list of results using the `filterResults()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Check again if there are any results using the `checkResults()` method. If there
    are no results, finish the execution of the thread with the `return` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Print the final list of results to the console with the `showInfo()` method,
    deregister the thread, and print a message indicating the finalization of the
    thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Phaser` object with three participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Create three `FileSearch` objects with a different initial folder for each one.
    Look for the files with the `.log` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Create and start a thread to execute the first `FileSearch` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Create and start a thread to execute the second `FileSearch` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Create and start a thread to execute the third `FileSearch` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the three threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Write the value of the finalized flag of the `Phaser` object using the `isFinalized()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program starts creating a `Phaser` object that will control the synchronization
    of the threads at the end of each phase. The constructor of `Phaser` receives
    the number of participants as a parameter. In our case, `Phaser` has three participants.
    This number indicates to `Phaser` the number of threads that have to execute an
    `arriveAndAwaitAdvance()` method before `Phaser` changes the phase and wakes up
    the threads that were sleeping.
  prefs: []
  type: TYPE_NORMAL
- en: Once `Phaser` has been created, we launch three threads that execute three different
    `FileSearch` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we use paths of the Windows operating system. If you work with
    another operating system, modify the paths to adapt them to existing paths in
    your environment.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction in the `run()` method of this `FileSearch` object is a
    call to the `arriveAndAwaitAdvance()` method of the `Phaser` object. As we mentioned
    earlier, the `Phaser` knows the number of threads that we want to synchronize.
    When a thread calls this method, `Phaser` decreases the number of threads that
    have to finalize the actual phase and puts this thread to sleep until all the
    remaining threads finish this phase. Calling this method at the beginning of the
    `run()` method makes none of the `FileSearch` threads begin their job until all
    the threads have been created.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of phase one and phase two, we check if the phase has generated results
    and the list with the results has elements, or otherwise the phase hasn't generated
    results and the list is empty. In the first case, the `checkResults()` method
    calls `arriveAndAwaitAdvance()` as explained earlier. In the second case, if the
    list is empty, there's no point in the thread continuing with its execution, so
    it returns. But you have to notify the phaser that there will be one less participant.
    For this, we used `arriveAndDeregister()`. This notifies the phaser that this
    thread has finished the actual phase, but it won't participate in the future phases,
    so the phaser won't have to wait for it to continue.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the phase three implemented in the `showInfo()` method, there
    is a call to the `arriveAndAwaitAdvance()` method of the phaser. With this call,
    we guarantee that all the threads finish at the same time. When this method ends
    its execution, there is a call to the `arriveAndDeregister()` method of the phaser.
    With this call, we deregister the threads of the phaser as we explained before,
    so when all the threads finish, the phaser will have zero participants.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `main()` method waits for the completion of the three threads and
    calls the `isTerminated()` method of the phaser. When a phaser has zero participants,
    it enters the so called termination state and this method returns `true`. As we
    deregister all the threads of the phaser, it will be in the termination state
    and this call will print `true` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Phaser` object can be in two states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active**: `Phaser`enters this state when it accepts the registration of new
    participants and its synchronization at the end of each phase. In this state,
    `Phaser` works as it has been explained in this recipe. This state is not mentioned
    in the Java concurrency API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Termination**: By default,`Phaser` enters in this state when all the participants
    in `Phaser` have been deregistered, so `Phaser` has zero participants. More in
    detail, `Phaser` is in the termination state when the method `onAdvance()` returns
    the `true` value. If you override that method, you can change the default behavior.
    When `Phaser` is on this state, the synchronization method `arriveAndAwaitAdvance()`
    returns immediately without doing any synchronization operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notable feature of the `Phaser` class is that you haven't had to control any
    exception from the methods related with the phaser. Unlike other synchronization
    utilities, threads that are sleeping in a phaser don't respond to interruption
    events and don't throw an `InterruptedException` exception. There is only one
    exception that is explained in the *There's more* section below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of one execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It shows the first two phases of the execution. You can see how the **Apps**
    thread finishes its execution in phase two because its results list is empty.
    When you execute the example, you will see how some threads finish a phase before
    the rest, but they wait until all have finished one phase before continuing with
    the rest.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Phaser` class provides other methods related to the change of phase. These
    methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrive()`: This method notifies the phaser that one participant has finished
    the actual phase, but it should not wait for the rest of the participants to continue
    with its execution. Be careful with the utilization of this method, because it
    doesn''t synchronize with other threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitAdvance(int``phase)`: This method puts the current thread to sleep until
    all the participants of the phaser have finished the current phase of the phaser,
    if the number we pass as the parameter is equal to the actual phase of the phaser.
    If the parameter and the actual phase of the phaser aren''t equal, the method
    returns immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitAdvanceInterruptibly(int``phaser)`: This method is equal to the method
    explained earlier, but it throws an `InterruptedException` exception if the thread
    that is sleeping in this method is interrupted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering participants in the Phaser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you create a `Phaser` object, you indicate how many participants will
    have that phaser. But the `Phaser` class has two methods to increment the number
    of participants of a phaser. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`register()`: This method adds a new participant to `Phaser`. This new participant
    will be considered as unarrived to the actual phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bulkRegister(int``Parties)`: This method adds the specified number of participants
    to the phaser. These new participants will be considered as unarrived to the actual
    phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only method provided by the `Phaser` class to decrement the number of participants
    is the `arriveAndDeregister()` method that notifies the phaser that the thread
    has finished the actual phase, and it doesn't want to continue with the phased
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing the termination of a Phaser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a phaser has zero participants, it enters a state denoted by **Termination**.
    The `Phaser` class provides `forceTermination()` to change the status of the phaser
    and makes it enter in the Termination state independently of the number of participants
    registered in the phaser. This mechanism may be useful when one of the participants
    has an error situation, to force the termination of the phaser.
  prefs: []
  type: TYPE_NORMAL
- en: When a phaser is in the Termination state, the `awaitAdvance()` and `arriveAndAwaitAdvance()`
    methods immediately return a negative number, instead of a positive one that returns
    normally. If you know that your phaser could be terminated, you should verify
    the return value of those methods to know if the phaser has been terminated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Monitoring a Phaser* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling phase change in concurrent phased tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Phaser` class provides a method that is executed each time the phaser
    changes the phase. It''s the `onAdvance()` method. It receives two parameters:
    the number of the current phase and the number of registered participants; it
    returns a `Boolean` value, `false` if the phaser continues its execution, or `true`
    if the phaser has finished and has to enter into the termination state.'
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of this method returns `true` if the number of registered
    participants is zero, and `false` otherwise. But you can modify this behavior
    if you extend the `Phaser` class and you override this method. Normally, you will
    be interested in doing this when you have to execute some actions when you advance
    from one phase to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to control the phase change in a phaser that
    is implementing your own version of the `Phaser` class that overrides the `onAdvance()`
    method to execute some actions in every phase change. You are going to implement
    a simulation of an exam, where there will be some students who have to do three
    exercises. All the students have to finish one exercise before they can proceed
    with the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyPhaser` and specify that it extends from the `Phaser`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Override the `onAdvance()` method. According to the value of the phase attribute,
    we call a different auxiliary method. If the phase is equal to zero, you have
    to call the `studentsArrived()` method. If the phase is equal to one, you have
    to call the `finishFirstExercise()` method. If the phase is equal to two, you
    have to call the `finishSecondExercise()` method, and if the phase is equal to
    three, you have to call the `finishExam()` method. Otherwise, we return the `true`
    value to indicate that the phaser has terminated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `studentsArrived()`. It writes two log messages
    to the console and returns the `false` value to indicate that the phaser continues
    with its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `finishFirstExercise()`. It writes two messages
    to the console and returns the `false` value to indicate that the phaser continues
    with its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `finishSecondExercise()`. It writes two messages
    to the console and returns the `false` value to indicate that the phaser continues
    with its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `finishExam()`. It writes two messages to the
    console and returns the `true` value to indicate that the phaser has finished
    its work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Student` and specify that it implements the `Runnable`
    interface. This class will simulate the students of the exam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Phaser` object named `phaser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the `Phaser` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that will simulate the realization of the exam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: First, the method writes a message in the console to indicate that this student
    has arrived to the exam and calls the `arriveAndAwaitAdvance()` method of the
    phaser to wait for the rest of the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Then, write a message to the console, call the private `doExercise1()` method
    that simulates the realization of the first exercise of the exam, write another
    message to the console and the `arriveAndAwaitAdvance()` method of the phaser
    to wait for the rest of the students to finish the first exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Implement the same code for second exercise and third execise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `doExercise1()`. This method puts the thread
    to sleep for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `doExercise2()`. This method puts the thread
    to sleep for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `doExercise3()`. This method puts the thread
    to sleep for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyPhaser` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Create five `Student` objects and register them in the phaser using the `register()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Create five threads to run `students` and start them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the five threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to show that the phaser is in the termination state using the
    `isTerminated()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise simulates the realization of an exam that has three exercises.
    All the students have to finish one exercise before they can start the next one.
    To implement this synchronization requirement, we use the `Phaser` class, but
    you have implemented your own phaser extending the original class to override
    the `onAdvance()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called by the phaser before making a phase change and before
    waking up all the threads that were sleeping in the `arriveAndAwaitAdvance()`
    method. This method receives as parameters the number of the actual phase, where
    `0` is the number of the first phase and the number of registered participants.
    The most useful parameter is the actual phase. If you execute a different operation
    depending on the actual phase, you have to use an alternative structure (`if`/`else`
    or `switch`) to select the operation you want to execute. In the example, we used
    a `switch` structure to select a different method for each change of phase.
  prefs: []
  type: TYPE_NORMAL
- en: The `onAdvance()` method returns a `Boolean` value that indicates if the phaser
    has terminated or not. If the phaser returns a `false` value, it indicates that
    it hasn't terminated, so the threads will continue with the execution of other
    phases. If the phaser returns a `true` value, then the phaser still wakes up the
    pending threads, but moves the phaser to the terminated state, so all the future
    calls to any method of the phaser will return immediately, and the `isTerminated()`
    method returns the `true` value.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Core` class, when you created the `MyPhaser` object, you didn't specify
    the number of participants in the phaser. You made a call to the `register()`
    method for every `Student` object created to register a participant in the phaser.
    This calling doesn't establish a relation between the `Student` object or the
    thread that executes it and the phaser. Really, the number of participants in
    a phaser is only a number. There is no relationship between the phaser and the
    participants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the students finish the first exercise at different times. When
    all have finished that exercise, the phaser calls the `onAdvance()` method that
    writes the log messages in the console and then all the students start the second
    exercise at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running concurrent phased tasks* recipe in [Chapter 3](ch03.html "Chapter 3. Thread
    Synchronization Utilities"), *Thread Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Phaser* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing data between concurrent tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a synchronization utility that allows the
    interchange of data between two concurrent tasks. In more detail, the `Exchanger`
    class allows the definition of a synchronization point between two threads. When
    the two threads arrive to this point, they interchange a data structure so the
    data structure of the first thread goes to the second one and the data structure
    of the second thread goes to the first one.
  prefs: []
  type: TYPE_NORMAL
- en: This class may be very useful in a situation similar to the producer-consumer
    problem. This is a classic concurrent problem where you have a common buffer of
    data, one or more producers of data, and one or more consumers of data. As the
    `Exchanger` class only synchronizes two threads, you can use it if you have a
    producer-consumer problem with one producer and one consumer.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `Exchanger` class to solve the
    producer-consumer problem with one producer and one consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE like NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's begin by implementing the producer. Create a class named `Producer`
    and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `List<String>` object named `buffer`. This will be the data structure
    that the producer will interchange with the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Declare an `Exchanger<List<String>>` object named `exchanger`. This will be
    the exchanger object that will be used to synchronize producer and consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the two attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Inside it, implement 10 cycles of interchange.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: In each cycle, add 10 strings to the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Call the `exchange()` method to interchange data with the consumer. As this
    method can throw an `InterruptedException` exception, you have to add the code
    to process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's implement the consumer. Create a class named `Consumer` and specify
    that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `List<String>` object named `buffer`. This will be the data structure
    that the producer will interchange with the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Declare an `Exchanger<List<String>>` object named `exchanger`. This will be
    the exchanger object that will be used to synchronize producer and consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the two attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Inside it, implement 10 cycles of interchange.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: In each cycle, begin with a call to the `exchange()` method to synchronize with
    the producer. The consumer needs data to consume. As this method can throw an
    `InterruptedException` exception, you have to add the code to process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Write the 10 strings the producer sent in its buffer to the console and delete
    them from the buffer, to leave it empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the main class of the example by creating a class named `Core`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Create the two buffers that will be used by the producer and the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Create the `Exchanger` object that will be used to synchronize the producer
    and the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Create the `Producer` object and the `Consumer` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Create the threads to execute the producer and the consumer and start the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The consumer begins with an empty buffer and calls `Exchanger` to synchronize
    with the producer. It needs data to consume. The producer begins its execution
    with an empty buffer. It creates 10 strings, stores it in the buffer, and uses
    the exchanger to synchronize withthe consumer.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, both threads (producer and consumer) are in `Exchanger` and it
    changes the data structures, so when the consumer returns from the `exchange()`
    method, it will have a buffer with 10 strings. When the producer returns from
    the `exchange()` method, it will have an empty buffer to fill again. This operation
    will be repeated 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute the example, you will see how producer and consumer do their
    jobs concurrently and how the two objects interchange their buffers in every step.
    As it occurs with other synchronization utilities, the first thread that calls
    the `exchange()` method was put to sleep until the other threads arrived.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Exchanger` class has another version of the exchange method: `exchange(V`
    `data,` `long` `time,` `TimeUnit` `unit)` where `V` is the type used as a parameter
    in the declaration of `Phaser` (`List<String>` in our case). The thread will be
    sleeping until it''s interrupted, the other thread arrives, or the specified time
    passes. The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs: []
  type: TYPE_NORMAL
