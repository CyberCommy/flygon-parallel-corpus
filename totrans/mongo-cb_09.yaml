- en: Chapter 9. Open Source and Proprietary Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。开源和专有工具
- en: 'In this chapter, we will cover some open source and proprietary tools. The
    following are the recipes that we will go through in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一些开源和专有工具。以下是本章中将要介绍的配方：
- en: Developing using spring-data-mongodb
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用spring-data-mongodb进行开发
- en: Accessing MongoDB using JPA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JPA访问MongoDB
- en: Accessing MongoDB over REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过REST访问MongoDB
- en: Installing a GUI-based client, MongoVUE, for MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为MongoDB安装基于GUI的客户端MongoVUE
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: There is a vast array of tools/frameworks available to ease the development/administration
    process for software that uses MongoDB. We will look at some of these available
    frameworks and tools. For a developer's productivity (Java developers, in this
    case), we will look at spring-data-mongodb, which is a part of the popular spring
    data suite.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的工具/框架可用于简化使用MongoDB的软件的开发/管理过程。我们将看一些这些可用的框架和工具。对于开发人员的生产力（在这种情况下是Java开发人员），我们将看一下spring-data-mongodb，它是流行的spring
    data套件的一部分。
- en: JPA is an ORM specification that is widely used, particularly with relational
    databases. (This was the objective of the ORM frameworks.) However, there are
    a few implementations that let us use it with NoSQL stores—MongoDB, in this case.
    We will look at a provider who provides this implementation and put it to the
    test with a simple use case.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JPA是一个广泛使用的ORM规范，特别是与关系数据库一起使用。（这是ORM框架的目标。）然而，有一些实现让我们可以将其与NoSQL存储（在这种情况下是MongoDB）一起使用。我们将看一个提供这种实现的提供者，并用一个简单的用例来测试它。
- en: We will use spring-data-rest to expose the CRUD repositories for MongoDB over
    a REST interface for clients to invoke various operations supported by the underlying
    spring-data-mongo repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用spring-data-rest来为客户端公开MongoDB的CRUD存储库，以便客户端调用底层spring-data-mongo存储库支持的各种操作。
- en: Querying the database in the shell is okay, but it would be nice to have a good
    GUI to enable us to do all the administrative-related/development-related tasks
    from the GUI rather than execute the commands in the shell to perform these activities.
    We will look at one such tool in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中查询数据库是可以的，但最好有一个良好的GUI，使我们能够从GUI中执行所有与管理/开发相关的任务，而不是在shell中执行命令来执行这些活动。我们将在本章中看一个这样的工具。
- en: Developing using spring-data-mongodb
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用spring-data-mongodb进行开发
- en: 'From a developer''s perspective, when a program needs to interact with a MongoDB
    instance, they need to use the respective client APIs for their specific platforms.
    The trouble with doing this is that we need to write a lot of boilerplate code
    and it is not necessarily object-oriented. For instance, we have a class called
    `Person` with various attributes such as `name`, `age`, `address`, and so on.
    The corresponding JSON document shares a similar structure to this `person` class
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发人员的角度来看，当程序需要与MongoDB实例交互时，他们需要使用特定平台的相应客户端API。这样做的麻烦在于我们需要编写大量的样板代码，而且不一定是面向对象的。例如，我们有一个名为`Person`的类，具有各种属性，如`name`、`age`、`address`等。相应的JSON文档与这个`person`类的结构类似。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, to store this document, we need to convert the `Person` class to DBObject,
    which is a map with key and value pairs. What is really needed is to let us persist
    this `Person` class itself as an object in the database without having to convert
    it to DBObject.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了存储这个文档，我们需要将`Person`类转换为DBObject，这是一个具有键值对的映射。真正需要的是让我们将这个`Person`类本身作为一个对象持久化到数据库中，而不必将其转换为DBObject。
- en: Additionally, some of the operations such as searching by a particular field
    of a document, saving an entity, deleting an entity, searching by the ID, and
    so on are pretty common operations, and we tend to repeatedly write similar boilerplate
    code. In this recipe, we will see how spring-data-mongodb relieves us of these
    laborious and cumbersome tasks to reduce, not only the development effort, but
    also the possibility of introducing bugs in these commonly written functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些操作，如按文档的特定字段搜索、保存实体、删除实体、按ID搜索等，都是非常常见的操作，我们往往会反复编写类似的样板代码。在这个配方中，我们将看到spring-data-mongodb如何解除我们这些繁琐和繁重的任务，以减少不仅开发工作量，还减少引入这些常见写函数中的错误的可能性。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `SpringDataMongoTest` project, present in the bundle with the chapter, is
    a Maven project and has to be imported to any IDE of your choice. The required
    maven artifacts will automatically be downloaded. A single MongoDB instance is
    required to be up and running and listening to port `27017`. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, for instructions
    on how to start a standalone instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringDataMongoTest`项目，存在于本章的捆绑包中，是一个Maven项目，必须导入到您选择的任何IDE中。所需的maven构件将自动下载。需要一个单独的MongoDB实例正在运行并监听端口`27017`。有关如何启动独立实例的说明，请参阅[第1章](ch01.html
    "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，*安装和启动服务器*。'
- en: For the aggregation example, we will use the postal codes data. Refer to the
    *Creating test data* recipe in [Chapter 2](ch02.html "Chapter 2. Command-line
    Operations and Indexes"), *Command-line Operations and Indexes*, for the creation
    of the test data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于聚合示例，我们将使用邮政编码数据。有关如何创建测试数据，请参阅[第2章](ch02.html "第2章。命令行操作和索引")中的*创建测试数据*配方，*命令行操作和索引*。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will explore the spring-data-mongodb's repository feature first. Open the
    test case's `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest` class from your
    IDE and execute it. If all goes well and the MongoDB server instance is reachable,
    the test case will get executed successfully.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先探索spring-data-mongodb的存储库功能。从您的IDE中打开测试用例的`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`类并执行它。如果一切顺利，MongoDB服务器实例是可达的，测试用例将成功执行。
- en: Another test case, `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest2`, is
    used to explore more features of the repository support provided by spring-data-mongodb.
    This test case too should get executed successfully.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个测试用例`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest2`，用于探索spring-data-mongodb提供的存储库支持的更多功能。这个测试用例也应该成功执行。
- en: We will see how spring-data-mongodb's `MongoTemplate` can be used to perform
    CRUD operations and other common operations on MongoDB. Open the `com.packtpub.mongo.cookbook.MongoTemplateTest`
    class and execute it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到如何使用spring-data-mongodb的`MongoTemplate`执行CRUD操作和其他常见操作。打开`com.packtpub.mongo.cookbook.MongoTemplateTest`类并执行它。
- en: 'Alternatively, if an IDE is not used, all the tests can be executed using maven
    from the command prompt with the current directory being in the root of the `SpringDataMongoTest`
    project:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果不使用IDE，可以在命令提示符中使用maven执行所有测试，当前目录在`SpringDataMongoTest`项目的根目录中：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will first look at what we did in `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`,
    where we saw the repository support provided by spring-data-mongodb. Just in case
    you didn't notice, we haven't written a single line of code for the repository.
    The magic of implementing the required code for us is done by the spring data
    project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下在`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`中做了什么，我们在那里看到了spring-data-mongodb提供的存储库支持。以防你没有注意到，我们没有为存储库编写一行代码。实现所需代码的魔力是由spring
    data项目完成的。
- en: 'Let''s start by looking at the relevant portions of the XML configuration file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下XML配置文件的相关部分：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first look at the last three lines, which are the spring-data-mongodb namespace
    declarations to instantiate `com.mongodb.Mongo`, a factory for the `com.mongodb.DB`
    instances from the client, and `template` instance, which is used to perform various
    operations on MongoDB, respectively. We will see `org.springframework.data.mongodb.core.MongoTemplate`
    in more detail later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下最后三行，这些是spring-data-mongodb命名空间声明，用于实例化`com.mongodb.Mongo`，客户端的`com.mongodb.DB`实例的工厂，以及`template`实例，用于在MongoDB上执行各种操作。稍后我们将更详细地看一下`org.springframework.data.mongodb.core.MongoTemplate`。
- en: 'The first line is a namespace declaration for the base package of all the CRUD
    repositories that we have. In this package, we have an interface with the following
    body:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是所有CRUD存储库的基本包的命名空间声明。在这个包中，我们有一个接口，具有以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PagingAndSortingRepository` interface is from the `org.springframework.data.repository`
    package of the spring data core project and extends from `CrudRepository` in the
    same project. These interfaces give us some of the most common methods such as
    searching by the ID/primary key, deleting an entity, and inserting and updating
    an entity. The repository needs an object that it maps to the underlying data
    store. The spring data project supports a large number of data stores not just
    limited to SQL (using JDBC and JPA) or MongoDB, but also to other NoSQL stores
    such as Redis and Hadoop and search engines such as Solr and Elasticsearch. In
    case of spring-data-mongodb, the object is mapped to a document in the collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingAndSortingRepository`接口来自spring data核心项目的`org.springframework.data.repository`包，并在同一项目中扩展自`CrudRepository`。这些接口为我们提供了一些最常见的方法，例如按ID/主键搜索、删除实体以及插入和更新实体。存储库需要一个对象，它将其映射到底层数据存储。spring
    data项目支持大量的数据存储，不仅限于SQL（使用JDBC和JPA）或MongoDB，还包括其他NoSQL存储，如Redis和Hadoop，以及Solr和Elasticsearch等搜索引擎。在spring-data-mongodb的情况下，对象被映射到集合中的文档。'
- en: The `PagingAndSortingRepository<Person, Integer>` signature indicates that the
    first one is the entity that the CRUD repository is built for and the second is
    the type of the primary key/ID field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingAndSortingRepository<Person, Integer>`的签名表示第一个是CRUD存储库构建的实体，第二个是主键/ID字段的类型。'
- en: We added just one `findByLastName` method, which accepts one string value for
    the last name as a parameter. This is an interesting operation that is specific
    to our repository and not even implemented by us, but it will still work just
    as expected. Person is a POJO where we annotated the `id` field with the `org.springframework.data.annotation.Id`
    annotation. Nothing else is really special about this class; it just has some
    plain getters and setters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只添加了一个`findByLastName`方法，它接受一个字符串值作为姓氏的参数。这是一个特定于我们的存储库的有趣操作，甚至不是我们实现的，但它仍然会按预期工作。Person是一个POJO，我们用`org.springframework.data.annotation.Id`注解标记了`id`字段。这个类没有什么特别之处；它只有一些普通的getter和setter。
- en: 'With all these small details, let''s join these dots together by answering
    some questions that you''ll have in mind. First, we will see which server, database,
    and collection our data goes to. If we look at the XML definition, `mongo:mongo`,
    for the configuration file, we can see that we instantiated the `com.mongodb.Mongo`
    class by connecting to localhost and port `27017`. The `mongo:db-factory` declaration
    is used to denote that the database to be used is `test`. One final question is:
    which collection? The simple name of our class is `Person`. The name of the collection
    is the simple name with the first character in lowercase, and thus, `Person` goes
    to person and something like `BillingAddress` would go to the `billingAddress`
    collection. These are the default values. However, if you need to override this
    value, you can annotate your class with the `org.springframework.data.mongodb.core.mapping.Document`
    annotation and use its collection attribute to give any name of your choice, as
    we will see in a later example.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些细节，让我们通过回答一些你心中的问题来把这些点连接起来。首先，我们将看到我们的数据去了哪个服务器、数据库和集合。如果我们查看配置文件的XML定义，`mongo:mongo`，我们可以看到我们通过连接到localhost和端口`27017`来实例化`com.mongodb.Mongo`类。`mongo:db-factory`声明用于表示要使用的数据库是`test`。最后一个问题是：哪个集合？我们类的简单名称是`Person`。集合的名称是简单名称的第一个字符小写，因此`Person`对应到`person`，而`BillingAddress`之类的东西将对应到`billingAddress`集合。这些是默认值。但是，如果您需要覆盖此值，可以使用`org.springframework.data.mongodb.core.mapping.Document`注解注释您的类，并使用其collection属性来给出您选择的任何名称，正如我们将在后面的示例中看到的。
- en: 'To view the document in the collection, execute just one test case `saveAndQueryPerson`
    method from the `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest` class. Now,
    connect to the MongoDB instance in the mongo shell and execute the following query:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 查看集合中的文档，只需执行`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`类中的一个测试用例`saveAndQueryPerson`方法。现在，连接到mongo
    shell中的MongoDB实例并执行以下查询：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see in the preceding result, the contents of the document are similar
    to the object that we persisted using the CRUD repository. The names of the field
    in the document are the same as the names of the respective attributes in the
    Java object with two exceptions. The field annotated with `@Id` is now `_id`,
    irrespective of the name of the field in the Java class and an additional `_class`
    attribute is added to the document whose value is the fully qualified name of
    the Java class itself. This is not of any use to the application but is used by
    spring-data-mongodb as metadata.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的结果中所看到的，文档的内容与我们使用CRUD存储库持久化的对象相似。文档中字段的名称与Java对象中相应属性的名称相同，有两个例外。使用`@Id`注释的字段现在是`_id`，与Java类中字段的名称无关，并且在文档中添加了一个额外的`_class`属性，其值是Java类本身的完全限定名称。这对应用程序没有任何用处，但是spring-data-mongodb用作元数据。
- en: Now it makes more sense and gives us an idea what spring-data-mongodb must be
    doing for all the basic CRUD methods. All the operations that we perform will
    use the `MongoTemplate` (`MongoOperations`, which is an interface that `MongoTemplate`
    implements) class from the spring-data-mongodb project. Using the primary key,
    it will invoke a find by the `_id` field on the collection derived using the `Person`
    entity class. The `save` method simply calls the `save` method on `MongoOperations`,
    which, in turn, calls the `save` method on the `com.mongodb.DBCollection` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更有意义了，并且让我们了解spring-data-mongodb必须为所有基本的CRUD方法做些什么。我们执行的所有操作都将使用spring-data-mongodb项目中的`MongoTemplate`（`MongoOperations`，这是`MongoTemplate`实现的接口）类。它将使用主键，在使用`Person`实体类派生的集合上的`_id`字段上调用find。`save`方法简单地调用`MongoOperations`上的`save`方法，而`MongoOperations`又调用`com.mongodb.DBCollection`类上的`save`方法。
- en: 'We still haven''t answered how the `findByLastName` method worked. How does
    spring know what query to invoke in order to return the data? These are the special
    types of methods that begin with `find`, `findBy`, `get`, or `getBy`. There are
    some rules that one needs to follow while naming a method, and the proxy object
    on the repository interface is able to correctly convert this method into an appropriate
    query on the collection. For instance, the `findByLastName` method in the repository
    for the `Person` class will execute a query on the `lastName` field in person''s
    document. Hence, the `findByLastName(String lastName)` method will fire the `db.person.find({''lastName'':
    lastName })` query on the database. Based on the return type of the method defined,
    it will return either `List` or the first result in the returned result from the
    database. We used `findBy` in our queries; however, anything that begins with
    find, has any text in between, and ends with `By`, works. For instance, `findPersonBy`
    is also the same as `findBy`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '我们仍然没有回答`findByLastName`方法是如何工作的。spring如何知道要调用什么查询以返回数据？这些是以`find`、`findBy`、`get`或`getBy`开头的特殊类型的方法。在命名方法时需要遵循一些规则，存储库接口上的代理对象能够正确地将此方法转换为集合上的适当查询。例如，`Person`类的存储库中的`findByLastName`方法将在person文档的`lastName`字段上执行查询。因此，`findByLastName(String
    lastName)`方法将在数据库上触发`db.person.find({''lastName'': lastName })`查询。根据方法定义的返回类型，它将返回来自数据库的结果中的`List`或第一个结果。我们在我们的查询中使用了`findBy`，但是任何以`find`开头，中间有任何文本，并以`By`结尾的都可以工作。例如，`findPersonBy`也与`findBy`相同。'
- en: 'To see more on these `findBy` methods, we have another test `MongoCrudRepositoryTest2`
    class. Open this class in your IDE where it can be read along with this text.
    We already executed this test case; now, let''s see these `findBy` methods used
    and their behavior. This interface has seven `findBy` methods in it, with one
    of the methods being a variant of another method in the same interface. To get
    a clear idea of the queries, we will first look at one of the documents in the
    `personTwo` collection in the test database. Execute the following in the mongo
    shell connected to the MongoDB server running on localhost:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些`findBy`方法，我们有另一个测试`MongoCrudRepositoryTest2`类。在您的IDE中打开这个类，可以与本文一起阅读。我们已经执行了这个测试用例；现在，让我们看看这些`findBy`方法的使用和它们的行为。这个接口中有七个`findBy`方法，其中一个方法是同一接口中另一个方法的变体。为了清楚地了解查询，我们将首先查看测试数据库中`personTwo`集合中的一个文档。在连接到运行在localhost上的MongoDB服务器的mongo
    shell中执行以下操作：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the repository uses the `Person2` class; however, the name of the
    collection used is `personTwo`. This was possible because we used the `@Document(collection="personTwo")`
    annotation on the top of the `Person2` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存储库使用`Person2`类；但是使用的集合的名称是`personTwo`。这是可能的，因为我们在`Person2`类的顶部使用了`@Document(collection="personTwo")`注解。
- en: 'Getting back to the seven methods in the `com.packtpub.mongo.cookbook.PersonRepositoryTwo`
    repository class, let''s look at them one by one:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`com.packtpub.mongo.cookbook.PersonRepositoryTwo`存储库类中的七种方法，让我们逐一看看它们：
- en: '| Method | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `findByAgeGreaterThanEqual` | This method will fire a query on the `personTwo`
    collection, `{''age'':{''$gte'':<age>}}`.The secret lies in the name of the method.
    If we break it up, what we have after `findBy` tells us what we want. The `age`
    property (with the first character in lowercase) is the field that would be queried
    on the document with the `$gte` operator because we have `GreaterThanEqual` in
    the name of the method. The value that would be used for the comparison would
    be the value of the parameter passed. The result is a collection of the `Person2`
    entities as we will have multiple matches. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `findByAgeGreaterThanEqual` | 这个方法将在`personTwo`集合上触发一个查询，`{''age'':{''$gte'':<age>}}`。秘密在于方法的名称。如果我们把它分开，`findBy`后面告诉我们我们想要什么。`age`属性（首字母小写）是将在具有`$gte`运算符的文档上查询的字段，因为方法的名称中有`GreaterThanEqual`。用于比较的值将是传递的参数的值。结果是`Person2`实体的集合，因为我们会有多个匹配项。
    |'
- en: '| `findByAgeBetween` | This method will again be queried on age but will be
    using a combination of `$gt` and `$lt` to find the matching result. The query,
    in this case, would be `{''age'' : {''$gt'' : from, ''$lt'' : to}}`. It is important
    to note that both the values from and to are exclusive in the range. There are
    two methods in the test case, `findByAgeBetween` and `findByAgeBetween2`. These
    methods demonstrate the behavior of the between query for different input values.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `findByAgeBetween` | 这个方法将再次在年龄上进行查询，但将使用`$gt`和`$lt`的组合来找到匹配的结果。在这种情况下，查询将是`{''age''
    : {''$gt'' : from, ''$lt'' : to}}`。重要的是要注意from和to两个值在范围内都是排他的。测试用例中有两种方法，`findByAgeBetween`和`findByAgeBetween2`。这些方法展示了对不同输入值的between查询的行为。
    |'
- en: '| `findByAgeGreaterThan` | This method is a special method that also sorts
    the result because there are two parameters to the method: the first parameter
    is the value against which the age will be compared and the second parameter is
    the field of the `org.springframework.data.domain.So` `rt` type. For more details,
    refer to the Javadocs for spring-data-mongodb. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `findByAgeGreaterThan` | 这个方法是一个特殊的方法，它还会对结果进行排序，因为该方法有两个参数：第一个参数是年龄将要进行比较的值，第二个参数是`org.springframework.data.domain.Sort`类型的字段。有关更多详细信息，请参考spring-data-mongodb的Javadocs。
    |'
- en: '| `findPeopleByLastNameLike` | This method is used to find results by the last
    name matching a pattern. Regular expressions are used for the matching purpose.
    For instance, in this case, the query fired will be `{''lastName'' : <lastName
    as regex>}`. This method''s name begins with `findPeopleBy` instead of `findBy`,
    which works the same as `findBy`. Thus, when we say `findBy` in all the descriptions,
    we actually mean `find…By`.The value provided as the parameter will be used to
    match the last name. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `findPeopleByLastNameLike` | 这个方法用于通过匹配模式查找姓氏匹配的结果。用于匹配目的的是正则表达式。例如，在这种情况下，触发的查询将是`{''lastName''
    : <lastName as regex>}`。这个方法的名称以`findPeopleBy`开头，而不是`findBy`，它的工作方式与`findBy`相同。因此，当我们在所有描述中说`findBy`时，实际上是指`find…By`。提供的值作为参数将用于匹配姓氏。
    |'
- en: '| `findByResidentialAddressCountry` | This is an interesting method to look
    at. Here, we are searching by the country of the residential address. This is,
    in fact, a field in the `Address` class in the `residentialAddress` field of the
    person. Take a look at the document from the `personTwo` collection for how the
    query should be.When spring data finds the name as `ResidentialAddressCountry`,
    it will try to find various combinations using this string. For instance, it can
    look at the `residentialAddressCountry` field in the `Person` class or `residential.addressCountry`,
    `residentialAddress.country`, or `residential.address.country`. If there are no
    conflicting values as in our case the `residentialAddress`.The field ''country''
    is a part of the ''Person2'' document and thus that would be used in the query.However,
    if there are conflicts, then underscores can be used to clearly specify what we
    are looking at. In this case, the method can be renamed `findByResidentialAddress_country`
    to clearly specify what we expect as the result. The test case `findByCountry2`
    method demonstrates this. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `findByFirstNameAndCountry` | This is an interesting method. We are not always
    able to use the method names to implement what we actually want to. The name of
    the method required for spring to automatically implement the query might be a
    bit awkward to use as is. For instance, `findByCountryOfResidence` sounds better
    than `findByResidentialAddressCountry`. However, we are stuck with the latter
    as that is how spring-data-mongodb would construct the query. Using `findByCountryOfResidence`
    gives no details on how to construct the query to spring data.There is a solution
    for this. You can choose to use the `@Query` annotation and specify the query
    to be executed when the method is invoked. The following is the annotation that
    we used:`@Query("{''firstName'':?0, ''residentialAddress.country'': ?1}")`We write
    the value as a query that would get executed and bind the parameters of the functions
    to the query as numbered parameters starting from zero. Thus, the first parameter
    of the method will be bound to `?0`, the second to `?1`, and so on. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: We saw how the `findBy` or `getBy` methods are automatically translated to the
    queries for MongoDB. Similarly, we have the following prefixes for the methods.
    The `countBy` method returns the long number for the count for a given condition,
    which is derived from the rest of the method name similar to `findBy`. We can
    have `deleteBy` or `removeBy` to delete the documents by the derived condition.
    One thing to note about the `com.packtpub.mongo.cookbook.domain.Person2` class
    is that it does not have a no argument constructor or setter to set the values.
    Instead, spring will use reflection to instantiate this object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the `findBy` methods are supported by spring-data-mongodb and all are
    not covered here. Refer to the spring-data-mongodb reference manual for more details.
    A lot of XML-based or Java-based configuration options are available and can be
    found in the reference manual. The URLs are given in the *See also* section later
    in this recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet; we have another test case, `com.packtpub.mongo.cookbook.MongoTemplateTest`,
    which uses `org.springframework.data.mongodb.core.MongoTemplate` to perform various
    operations. You can open the test case class and see what operations are performed
    and which methods of MongoTemplate are invoked.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the important and frequently used methods of the MongoTemplate
    class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `save` | This method is used to save (insert, if new; or else, update) an
    entity in MongoDB. The method takes one parameter, the entity, and finds the target
    collection based on its name or the `@Document` annotation present on it.There
    is an overloaded version of the save method that also accepts the second parameter,
    the name of the collection to which the data entity passed needs to be persisted.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `remove` | This method will be used to remove documents from the collection.
    It has some overloaded methods in this class. All of them accept either an entity
    to be deleted or the `org.springframework.data.mongodb.core.query.Query` instance,
    which is used to determine the document(s) to be deleted. The second parameter
    is the name of the collection from which the document has to be deleted. When
    an entity is provided, the name of the collection can be derived. With a `Query`
    instance provided, we have to give either the name of the collection or the entity
    class name, which, in turn, will be used to derive the name of the collection.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 这个方法用于从集合中删除文档。在这个类中有一些重载的方法。所有这些方法都接受要删除的实体或`org.springframework.data.mongodb.core.query.Query`实例，用于确定要删除的文档。第二个参数是要从中删除文档的集合的名称。当提供实体时，可以推导出集合的名称。如果提供了`Query`实例，我们必须给出集合的名称或实体类的名称，然后将用于推导集合的名称。'
- en: '| `updateMulti` | This is the function invoked to update multiple documents
    with one update call. The first parameter is the query that would be used to match
    the documents. The second parameter is the `org.springframework.data.mongodb.core.query.Updat`
    `e` instance. This is the update that would be executed on the documents selected
    using the first `Query` object. The next parameters are the entity class or collection
    name to execute the update on. Refer to the Javadocs for more details on the method
    and its various overloaded versions. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `updateMulti` | 这是用于一次更新多个文档的函数。第一个参数是用于匹配文档的查询。第二个参数是`org.springframework.data.mongodb.core.query.Updat`
    `e`实例。这是将在使用第一个`Query`对象选择的文档上执行的更新。下一个参数是实体类或集合名称，用于执行更新。有关该方法及其各种重载版本的更多详细信息，请参阅Javadocs。'
- en: '| `updateFirst` | It is the opposite of the `updateMulti` method. This operation
    will update just the first matching document. We have not covered this method
    in our unit test case. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `updateFirst` | 这是`updateMulti`方法的相反操作。此操作将仅更新第一个匹配的文档。我们在单元测试用例中没有涵盖这个方法。'
- en: '| `insert` | We mentioned that the save method can perform insertion and updates.
    The insert method in the template calls the `insert` method of the underlying
    mongo client. If one entity or document is to be inserted, there is no difference
    in calling the `insert` or `save` method.However, as we can see in the `insertMultiple`
    method in the test case, we created a list of three `Person` instances and passed
    them to the insert method. All the three documents for the three `Person` instances
    will go to the server as part of one call. The behavior on what happens whenever
    an insert fails is determined by the continue on error parameter of the Write
    Concern. It will determine whether the bulk insert fails at the first failure
    or continues even after errors while reporting the last error. The URL, [http://docs.mongodb.org/manual/core/bulk-inserts/](http://docs.mongodb.org/manual/core/bulk-inserts/),
    gives more details on bulk inserts and various write concern parameters that can
    alter the behavior. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `insert` | 我们提到save方法可以执行插入和更新。模板中的insert方法调用底层mongo客户端的insert方法。如果要插入一个实体或文档，调用insert或save方法没有区别。然而，如我们在测试用例中看到的insertMultiple方法，我们创建了一个包含三个`Person`实例的列表，并将它们传递给insert方法。三个`Person`实例的所有三个文档将作为一个调用的一部分发送到服务器。无论何时插入失败的行为是由Write
    Concern的continue on error参数确定的。它将确定批量插入在第一次失败时是否失败，或者即使在报告最后一个错误时也会继续。URL [http://docs.mongodb.org/manual/core/bulk-inserts/](http://docs.mongodb.org/manual/core/bulk-inserts/)
    提供了有关批量插入和各种写关注参数的更多详细信息，可以改变行为。'
- en: '| `findAndRemove`/`findAllAndRemove` | Both these operations are used to find
    and then remove the document(s). The first one finds one and then returns the
    deleted document. This operation is atomic. The latter, however, finds all the
    documents and removes them before returning the list of all the entities of all
    the documents deleted. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `findAndRemove`/`findAllAndRemove` | 这两个操作都用于查找然后删除文档。第一个找到一个文档，然后返回被删除的文档。这个操作是原子的。然而，后者在返回所有被删除文档的实体列表之前找到并删除所有文档。'
- en: '| `findAndModify` | This method is functionally similar to `findAndModify`
    that we have with the mongo client library. It will atomically find and modify
    the document. If the query matches more than one document, only the first match
    will be updated. The first two parameters of this method are the query and update
    to execute. The next few parameters are either the entity class or collection
    name to execute the operation on. Additionally, there is a special `org.springframework.data.mongodb.core.FindAndModifyOptions`
    class, which makes sense only for the `findAndModify` operation. This instance
    tells us whether we are looking for the new instance or old instance after the
    operation is performed and whether upsert is to be performed. It is relevant only
    if the document with the matching query doesn''t exist. There is an additional
    Boolean flag to tell the client whether this is a `findAndRemove` operation. In
    fact, the `findAndRemove` operation that we saw earlier is just a convenient function
    that delegates `findAndModify` with this remove flag set. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `findAndModify` | 这个方法在功能上类似于我们在mongo客户端库中拥有的`findAndModify`。它将原子地查找并修改文档。如果查询匹配多个文档，只有第一个匹配项将被更新。该方法的前两个参数是要执行的查询和更新。接下来的几个参数是要在其上执行操作的实体类或集合名称。此外，还有一个特殊的`org.springframework.data.mongodb.core.FindAndModifyOptions`类，它只对`findAndModify`操作有意义。这个实例告诉我们在操作执行后是否要查找新实例或旧实例，以及是否要执行upsert。只有在不存在与匹配查询的文档时才相关。还有一个额外的布尔标志，告诉客户端这是否是一个`findAndRemove`操作。实际上，我们之前看到的`findAndRemove`操作只是一个方便的函数，它使用了这个删除标志来委托`findAndModify`。|'
- en: 'In the preceding table, we mentioned the `Query` and `Update` classes when
    talking about update. These are special convenient classes in spring-data-mongodb,
    which let us build MongoDB queries using a syntax that is easy to understand with
    improved readability. For instance, the query to check whether `lastName` is `Johnson`
    in mongo is `{''lastName'':''Johnson''}`. The same query can be constructed in
    spring-data-mongodb as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，当谈到更新时，我们提到了`Query`和`Update`类。这些是spring-data-mongodb中的特殊便捷类，它们让我们使用易于理解且具有改进可读性的语法构建MongoDB查询。例如，在mongo中检查`lastName`是否为`Johnson`的查询是`{'lastName':'Johnson'}`。在spring-data-mongodb中，可以按照以下方式构建相同的查询：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This syntax looks neat compared to giving the query in JSON. Let''s take another
    example where we want to find all the females under 30 years in our database.
    The query would now be built as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与以JSON形式给出查询相比，这种语法看起来更整洁。让我们举另一个例子，我们想要在我们的数据库中找到所有30岁以下的女性。现在查询将构建如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, for update, we want to set a Boolean flag, `youngCustomer`, to `true`
    for some of the customers based on some conditions. To set this flag in the document,
    the MongoDB format would be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于更新，我们希望根据一些条件为一些客户设置一个布尔标志`youngCustomer`为`true`。要在文档中设置此标志，MongoDB格式如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In spring-data-mongodb, this would be achieved in the following way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在spring-data-mongodb中，可以通过以下方式实现：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Refer to the Javadocs for all the possible methods that are available to build
    the query and updates in spring-data-mongodb to be used with `MongoTemplate`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Javadocs，了解在spring-data-mongodb中可用于构建查询和更新的所有可能方法。
- en: These methods are by no means the only ones available in the `MongoTemplate`
    class. There are a lot of other methods for geospatial indexes, convenient methods
    to get the count of the documents in a collection, aggregation and MapReduce support,
    and so on. Refer to the Javadocs of `MongoTemplate` for more details and methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法绝不是`MongoTemplate`类中唯一可用的方法。还有许多其他方法用于地理空间索引、获取集合中文档数量的便捷方法、聚合和MapReduce支持等。有关更多详细信息和方法，请参考`MongoTemplate`的Javadocs。
- en: 'Speaking of aggregation, we also have a test case `aggregationTest` method
    to perform the aggregation operation on the collection. We have a `postalCodes`
    collection in MongoDB that contains the postal code details of various cities.
    An example document in the collection is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 说到聚合，我们还有一个名为`aggregationTest`的测试用例方法，用于对集合执行聚合操作。我们在MongoDB中有一个`postalCodes`集合，其中包含各个城市的邮政编码详细信息。集合中的一个示例文档如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our aggregation operation intends to find the top five states by the number
    of documents in the collection. In mongo, the aggregation pipeline would look
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聚合操作意图是找到集合中文档数量前五名的州。在mongo中，聚合管道如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In spring-data-mongodb, we invoked the aggregation operation using `MongoTemplate`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在spring-data-mongodb中，我们使用`MongoTemplate`调用了聚合操作：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The key is in creating the instance of the `org.springframework.data.mongodb.core.aggregation.Aggregation`
    class. The `newAggregation` method is statically imported from the same class
    and accepts `varargs` for different instances of the `org.springframework.data.mongodb.core.aggregation.AggregationOperation`
    instances corresponding to the one operation in the chain. The `Aggregation` class
    has various static methods to create the instances of `AggregationOperation`.
    We have used a few of them such as `project`, `group`, `sort`, and `limit`. Refer
    to the Javadocs for more details and available methods. The `aggregate` method
    in `MongoTemplate` takes three arguments. The first one is the instance of the
    `Aggregation` class, the second one is the name of the collection, and the third
    one is the return type of the aggregation result. Refer to the aggregation operation
    test case for more details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于创建`org.springframework.data.mongodb.core.aggregation.Aggregation`类的实例。`newAggregation`方法是从同一类中静态导入的，并接受`varargs`，用于不同的`org.springframework.data.mongodb.core.aggregation.AggregationOperation`实例，对应于链中的一个操作。`Aggregation`类有各种静态方法来创建`AggregationOperation`的实例。我们使用了其中一些，比如`project`、`group`、`sort`和`limit`。有关更多详细信息和可用方法，请参考Javadocs。`MongoTemplate`中的`aggregate`方法接受三个参数。第一个是`Aggregation`类的实例，第二个是集合的名称，第三个是聚合结果的返回类型。有关更多详细信息，请参考聚合操作测试用例。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the Javadocs at [http://docs.spring.io/spring-data/mongodb/docs/current/api/](http://docs.spring.io/spring-data/mongodb/docs/current/api/)
    for more details and API documentation
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更多详细信息和API文档，请参考[http://docs.spring.io/spring-data/mongodb/docs/current/api/](http://docs.spring.io/spring-data/mongodb/docs/current/api/)的Javadocs。
- en: The reference manual for the spring-data-mongodb project can be found at [http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/](http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-data-mongodb项目的参考手册可以在[http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/](http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/)找到
- en: Accessing MongoDB using JPA
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA访问MongoDB
- en: In this recipe, we will use a JPA provider that allows us to use JPA entities
    to achieve object-to-document mapping with MongoDB.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个JPA提供程序，它允许我们使用JPA实体来实现与MongoDB的对象到文档映射。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start the standalone server instance listening to port `27017`. This is a Java
    project using JPA. Familiarity with JPA and its annotations is expected, though
    what we will be looking at is fairly basic. Refer to the *Connecting to the single
    node using a Java client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, to see how to
    set up maven if you are not aware of it. Download the `DataNucleusMongoJPA` project
    from the bundle provided with this book. Though we will be executing the test
    cases from the command prompt, you can import the project to your favorite IDE
    to view the source code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 启动独立的服务器实例，监听端口`27017`。这是一个使用JPA的Java项目。我们期望熟悉JPA及其注解，尽管我们将要查看的内容相当基础。如果您不熟悉maven，可以参考[第1章](ch01.html
    "第1章 安装和启动服务器")中的*使用Java客户端连接单节点*部分来设置maven。从提供的捆绑包中下载`DataNucleusMongoJPA`项目。虽然我们将从命令提示符中执行测试用例，但您也可以将项目导入到您喜欢的IDE中查看源代码。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Go to the root directory of the `DataNucleusMongoJPA` project and execute the
    following in the shell:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`DataNucleusMongoJPA`项目的根目录，并在shell中执行以下操作：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should download the necessary artifacts needed to build and run the project
    and execute the test cases successfully.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会下载构建和运行项目所需的必要工件，并成功执行测试用例。
- en: Once the test cases get executed, open a mongo shell and connect to the local
    instance.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试用例执行完毕，打开mongo shell并连接到本地实例。
- en: 'Execute the following query in the shell:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中执行以下查询：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'First, let''s look at a sample document that was created in the `personJPA`
    collection:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下在`personJPA`集合中创建的示例文档：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The steps that we executed are pretty simple; let''s look at the classes that
    are used one by one. We start with the `com.packtpub.mongo.cookbook.domain.Person`
    class. On the top of the class (after the package and imports), we have the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的步骤非常简单；让我们逐个查看使用的类。我们从`com.packtpub.mongo.cookbook.domain.Person`类开始。在类的顶部（包和导入之后），我们有以下内容：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This denotes that the `Person` class is an entity and the collection to which
    it would persist is `personJPA`. Note that JPA was designed primarily as an **Object
    Relational Mapping** (**ORM**) tool and, so, the terminologies used are more for
    a relational database. A table in RDBMS is synonymous to a collection in MongoDB.
    The rest of the class contains the attributes of person and the columns annotated
    with `@Column` and `@Id` for a primary key. These are simple JPA annotations.
    What is interesting to look at is the `com.packtpub.mongo.cookbook.domain.ResidentialAddress`
    class, which is stored as a `residentialAddress` variable in the `Person` class.
    If we look at the person document that we gave earlier, all the values given in
    the `@Column` annotation are the names of the keys for person; also notice how
    `Enum` gets converted to a string value as well. The `residentialAddress` field
    is the name of the variable in the `Person` class against which the address instance
    is stored. If we look at the `ResidentialAddress` class, we can see the `@Embeddable`
    annotation at the top above the class name. This is again a JPA annotation that
    denotes that this instance is not an entity itself, but is embedded in another
    `Entity` or `Embeddable` class. Note the names of the fields in the document;
    in this case, they have the following format: `<name of the variable in person
    class>_<value of the variable name in ResidentialAddress class>`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`Person`类是一个实体，它将持久化到`personJPA`集合中。请注意，JPA主要设计为**对象关系映射**（**ORM**）工具，因此使用的术语更多地是针对关系数据库。在RDBMS中，表与MongoDB中的集合是同义词。类的其余部分包含了人的属性，以及用`@Column`和`@Id`注释的列作为主键。这些都是简单的JPA注释。有趣的是看一下`com.packtpub.mongo.cookbook.domain.ResidentialAddress`类，它存储为`Person`类中的`residentialAddress`变量。如果我们看一下之前给出的人员文档，`@Column`注释中给出的所有值都是人员键的名称；还要注意`Enum`如何转换为字符串值。`residentialAddress`字段是`Person`类中的变量名，存储地址实例。如果我们看`ResidentialAddress`类，我们可以看到类名上方的`@Embeddable`注解。这再次是一个JPA注解，表示这个实例本身不是一个实体，而是嵌入在另一个`Entity`或`Embeddable`类中。请注意文档中字段的名称；在这种情况下，它们的格式如下：`<person类中的变量名>_<ResidentialAddress类中的变量名的值>`。
- en: 'There is one problem here. The names of the fields are too long, consuming
    unnecessary space. The solution is to have a shorter value in the `@Column` annotation.
    For instance, the `@Column(name="ln")` annotation instead of `@Column(name="lastName")`,
    will create the key with a `ln` name in the document. Unfortunately, this doesn''t
    work with the embedded `ResidentialAddress` class; in which case, you will have
    to deal with shorter variable names. Now that we have seen the entity classes,
    let''s see `persistence.xml`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题。字段的名称太长，占用了不必要的空间。解决方案是在`@Column`注解中使用较短的值。例如，`@Column(name="ln")`注解代替`@Column(name="lastName")`，将在文档中创建一个名为`ln`的键。不幸的是，这在嵌入的`ResidentialAddress`类中不起作用；在这种情况下，您将不得不处理较短的变量名。现在我们已经看到了实体类，让我们看看`persistence.xml`：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have got just the persistence-unit definition here with the name as `DataNucleusMongo`.
    There is one class node that is the entity that we will use. Note that the embedded
    address class is not mentioned here as it is not an independent entity. In the
    properties, we mentioned the URL of the data store to connect to. In this case,
    we connect to the instance on localhost, port `27017`, and database test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个名为`DataNucleusMongo`的持久性单元定义。有一个类节点，即我们将使用的实体。请注意，嵌入式地址类在这里没有提到，因为它不是一个独立的实体。在属性中，我们提到了要连接的数据存储的URL。在这种情况下，我们连接到本地主机上的实例，端口`27017`，数据库为test。
- en: Now, let's look at the class that queries and inserts the data. This is our
    `com.packtpub.mongo.cookbook.DataNucleusJPATest` test class. We create `javax.persistence.EntityManagerFactory`
    as `Persistence.createEntityManagerFactory("DataNucleusMongo")`. This is a thread-safe
    class and its instance is shared across threads; the string argument is also the
    same as the name of the persistence unit that we used in `persistence.xml`. All
    the other invocations on `javax.persistence.EntityManager` to persist or query
    the collection require us to create an instance using `EntityManagerFactory`—use
    it and then close it once the operation is completed. All the operations performed
    are as per the JPA specifications. The test case class persists entities and also
    queries them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we look at `pom.xml`, particularly the enhancer plugin that we used,
    which is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The entities that we have written need to be enhanced in order to be used as
    JPA entities using data nucleus. The preceding plugin will be attached to the
    process-class phase and then call the plugin's enhance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways to enhance JPA entities using a data nucleus enhancer.
    Refer to [http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html](http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html)
    for possible options. There is even a plugin for Eclipse to allow entity classes
    to be enhanced/instrumented for data nucleus.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JPA 2.1 specification can be found at [https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html](https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing MongoDB over REST
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to access MongoDB and perform CRUD operations
    using REST APIs. We will use spring-data-rest for REST access and spring-data-mongodb
    to perform the CRUD operations. Before you continue with this recipe, it is important
    to know how to implement the CRUD repositories using spring-data-mongodb. Refer
    to the *Developing using spring-data-mongodb* recipe in this chapter to know how
    to use this framework.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The question one must be having is, why is a REST API needed? There are scenarios
    where there is a database that is being shared by many applications and is possibly
    written in different languages. Writing JPA DAO or using spring-data-mongodb is
    good enough for Java clients but not for clients in other languages. Having APIs
    locally with the application doesn't even give us a centralized way to access
    the database. This is where REST APIs come into play. We can develop the server-side
    data access layer and the CRUD repository in Java—spring-data-mongodb to be precise—and
    then expose it over a REST interface for a client written in any language to invoke
    them. We not only invoke our API in a platform-independent way, but also provide
    a single point of entry into our database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the prerequisites of the spring-data-mongodb recipe, we have a few
    more requirements for this recipe. The first thing is to download the `SpringDataRestTest`
    project from the Packt website and import it to your IDE as a maven project. Alternatively,
    if you do not wish to import to the IDE, you can run the server servicing the
    requests from the command prompt, which we will see in the next section. There
    is no specific client application used to perform the CRUD operations over REST.
    I will be demonstrating the concepts using the Chrome browser and a special plugin
    of the Advanced REST Client browser to send HTTP POST requests to the server.
    The tools can be found under the **Developer Tools** section of the Chrome web
    store.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have imported the project in your IDE as a maven project, execute the
    `com.packtpub.mongo.cookbook.rest.RestServer` class, which is the bootstrap class
    and starts the server locally that would accept client connections.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the project is to be executed from the command prompt as a maven project,
    go to the root directory of the project and run the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following line on the command will be seen on the command prompt if all
    goes well and the server has been started:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After starting the server in either way, enter `http://localhost:8080/people`
    in the browser's address bar and we should see the following JSON response. This
    response is seen because the underlying person collection is empty.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will now insert a new document in the person collection using an HTTP POST
    request to `http://localhost:8080/people`. We will be sending a POST request to
    the server using the Advanced REST Client Chrome extension. The document posted
    is:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The request's content type is `application`/`json`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the POST request sent to the server and the response
    from the server:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_09_01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: We will now query this document from the browser using the `_id` field, which
    is `1` in this case. Enter `http://localhost:8080/people/1` in the browser's address
    bar. You should see the document that we inserted in step 3.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have one document in the collection, (you can try to insert more
    documents for people with different names and, more importantly, a unique ID.)
    we will query the document using the last name. First, type the following URL
    in the browser''s address bar to view the entire search options available: `http://localhost:8080/people/search`.
    We should see one `search` method, `findByLastName`, that accepts a command line
    parameter, `lastName`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To search by the last name, Cruise in our case, enter the following URL in
    the browser''s address bar: `http://localhost:8080/people/search/findByLastName?lastName=Cruise`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now update the last name and age of the person with the ID `1`, Tom
    Cruise for now. Let's update the last name to Hanks and the age to `58`. To do
    this, we will be using the HTTP PATCH request and the request will be sent to
    `http://localhost:8080/people/1`, which uniquely identifies the document to update.
    The body of the HTTP PATCH request is `{"lastName":"Hanks", "age":58}`. Refer
    to the following image for the request that we sent out for an update:![How to
    do it…](img/B04831_09_02.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To validate whether our update went through successfully or not (we know it
    did as we got a response status 204 after the PATCH request), enter `http://localhost:8080/people/1`
    again in the browser's address bar.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we delete the document. This is straightforward, and we simply send
    a DELETE request to `http://localhost:8080/people/1`. Once the DELETE request
    is successful, send an HTTP GET request from the browser to `http://localhost:8080/people/1`
    and we should not get any document in return.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not be reiterating the spring-data-mongodb concepts again in this recipe,
    but will look at some of the annotations that we added specifically for the REST
    interface to the repository class. The first one is on the top of the class name,
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is used to instruct the server that this CRUD repository can be accessed
    using the people resource. This is the reason why we always make HTTP GET and
    POST requests on `http://localhost:8080/people/`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The second annotation is in the `findByLastName` method. We have the following
    method signature:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the method's `lastName` parameter is annotated with the `@Param` annotation,
    which is used to annotate the name of the parameter that will have the value of
    the `lastName` parameter that will be passed while invoking this method on the
    repository. If we look at step 6 in the previous section, we can see that `findByLastName`
    is invoked using an HTTP GET request, and the value of the URL `lastName` parameter
    is used as the string value passed while invoking the repository method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Our example here is pretty simple with just one parameter used for the search
    operation. We can have multiple parameters for the repository method and an equal
    number of parameters in the HTTP request that will be mapped to these parameters
    for the method to be invoked on the CRUD repository. For some types, such as dates
    to be sent out, use the `@DateTimeFormat` annotation, which will be used to specify
    the date and time format. Refer to the spring Javadocs at [http://docs.spring.io/spring/docs/current/javadoc-api/](http://docs.spring.io/spring/docs/current/javadoc-api/)
    for more information on this annotation and its usage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This was all about the GET request that we made to the REST interface to query
    and search data. We initially created a document data sending an HTTP POST request
    to the server. To create new documents, we would always be sending a POST request—with
    the document to be created as the body of the request—to the URL identifying the
    REST endpoint, in our case, `http://localhost:8080/people/`. All documents posted
    to this collection would be making use of `PersonRepository` to persist `Person`
    in the corresponding collection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Our final two steps were to update person and delete person. The HTTP request
    types to perform these operations are PATCH and DELETE, respectively. In step
    7, we updated the document for the person Tom Cruise and updated his last name
    and age. To achieve this, our PATCH request is sent to a URL identifying a specific
    person instance, which is `http://localhost:8080/people/1`. Note that in case
    of creating a new person, our POST request was always sent to `http://localhost:8080/people`,
    as against the PATCH and DELETE requests, where we sent the HTTP request to a
    URL representing the specific person that we want to update or delete. In the
    case of update, the body of the PATCH request is JSON whose provided fields would
    replace the corresponding fields in the target document to update. All the other
    fields would be left as is. In our case, `lastName` and the age of the target
    document were updated and `firstName` was left untouched. In case of delete, the
    message body was not empty, and the DELETE request itself indicates that the target
    to which the request was sent should be deleted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: You can also send a PUT request instead of PATCH to a URL, identifying a specific
    person; in which case, the entire document in the collection would get updated
    or replaced with the document provided as part of the PUT request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spring-data-rest home is at [http://projects.spring.io/spring-data-rest/](http://projects.spring.io/spring-data-rest/),
    where you can find links to its Git repository, reference manual, and Javadocs
    URL.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Installing a GUI-based client, MongoVUE, for MongoDB
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at a GUI-based client for MongoDB. Throughout
    the book, we have used the mongo shell to perform various operations that we need.
    Its advantages are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: It comes packaged with the MongoDB installation
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being lightweight, you don't need to worry about it taking up your system's
    resources
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On servers where GUI-based interfaces are not present, shell is the only option
    to connect, query, and administer the server instance
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having said this, if you are not on a server and want to connect to a database
    instance to query, view the plan of a query, administer, and so on, it is nice
    to have a GUI with these features to let you do things in the click of a button.
    As a developer, we always query our relational database with a GUI-based thick
    client, so why not for MongoDB?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to install some features of a MongoDB client,
    MongoVUE. This client is available only for Windows machines. This product has
    both a paid version (with various levels of licensing per number of users) and
    free version that has some limitations. For this recipe, we'll be looking at the
    free version.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are necessary:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Start a single instance of MongoDB server. The port on which the connections
    are accepted will be the default one, `27017`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following two collections from the command prompt after the mongod
    server has started:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the installer ZIP for the MongoVUE from [http://www.mongovue.com/downloads/](http://www.mongovue.com/downloads/).
    Once downloaded, it is a matter of a few clicks and the software gets installed.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the installed application; as this is a free version, we will have all
    the features available for the first 14 days, after which, some of the features
    will not be available. The details of this can be seen at [http://www.mongovue.com/purchase/](http://www.mongovue.com/purchase/).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing that we will do is add a database connection:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the following window has opened, click on the (**+**) button to add a new
    connection:![How to do it…](img/B04831_09_03.jpg)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once opened, we will get another window in which we will fill in the server
    connection details. Fill in the following details in the new window and click
    on **Test**. This should succeed if the connection works; finally, click on **Save**.![How
    to do it…](img/B04831_09_04.jpg)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once added, connect to the instance.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the left navigation panel, we will see the instances added and the databases
    in them, as shown in the following image:![How to do it…](img/B04831_09_05.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see in the preceding image, hovering the mouse over the name of the
    collection shows us the size and count of the documents in the collection.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to query a collection and get all the documents. We will use the
    `postalCodes` collection for our `test`. Right-click on the collection name, and
    click on **View**. We will see the contents of the collection shown as either
    a Tree View, where we can expand and see the contents, Table View, which shows
    the contents in a tabular grid, and Text View, which shows the contents as normal
    JSON text.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we query a collection with nested documents; `personTwo`
    is a collection with the following sample document in it:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we query to see all the documents in the collection, we see the following
    image:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_09_06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: The `residentialAddress` column shows that the value is a nested document with
    the given number of fields present in it. Hovering your mouse over it shows the
    nested document; alternatively, you can click on the column to show the contents
    in this document again as a grid. Once the nested documents are shown, you can
    click on the top of the grid to come back one level.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to write queries to retrieve selected documents:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **postalCodes** collection, and click on **Find**. We will
    type the following query in the **{Find}** textbox and the **{Sort}** field, and
    click on the **Find** button to the right:![How to do it…](img/B04831_09_07.jpg)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can choose the type of view that we want from the tab, which is a **Tree
    View**, **Table View**, or **Text View**. The plan of the query is also shown.
    Whenever any operation is run, the Learn shell at the bottom shows the actual
    Mongo query executed. In this case, we see the following:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The plan of a query is also shown every time, and, as of the current version
    1.6.9.0, there is no way to disable the showing of the query plan with the query.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Tree View**, right-clicking on a document will give you more options, such
    as expand it, copy the JSON contents, add keys to this document, remove the document,
    and so on. Try to remove a document from this collection using a right-click,
    and try adding any additional keys to the document. You can choose to restore
    the documents by reimporting the data from the `postalCodes` collection.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To insert a document in the collection, perform the following. We will be inserting
    a document in the `personTwo` collection:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **personTwo** collection name, and click on **Insert/Import
    Documents…**, as shown in the following screenshot:![How to do it…](img/B04831_09_08.jpg)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another pop-up window will appear, where you can choose to enter a single JSON
    document or valid text file with the JSON documents to be imported. We imported
    the following document by importing a single document:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Query the collection once the document has been imported successfully; we will
    view the newly imported document along with the old ones.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to update the document:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can either right-click on the collection name to the left and click **Update**,
    or select the **Update** option at the top. In either case, we will see the following
    window. Here, we will be updating the age of the person that we inserted in the
    previous step:![How to do it…](img/B04831_09_09.jpg)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some things to note in this GUI are the query textbox on the left-hand side
    to find the document to be updated and the update JSON on the right-hand side,
    which will be applied to the selected document(s).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you update, you can choose to hit the **Count** button to see the number
    of documents that can be updated (in this case, one). Clicking on **Find** will
    show you the documents in the Tree form. On the right-hand side, below the update
    JSON text, we have the option to update one document and multiple documents by
    clicking on **Update 1** or **Update All**.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose an **Upsert** operation in case the documents for the given **Find**
    condition are not found.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The radio buttons on the bottom right of the preceding screen shows either the
    output of the `getLastError` operation or the result after the update, in which
    case, a query will be executed to find the document(s) updated.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The find query, however, is not foolproof and might return different results
    than those truly updated as a separate query, the same as in the **Find** textbox.
    The update and find operations are not atomic.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have queried on small collections so far. As the size of the collection
    increases, queries performing full collection scans are not acceptable and we
    need to create indexes as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create an index by `lastName` in ascending order and age in descending order,
    we will invoke `db.personTwo.ensureIndex({'lastName':1, 'age':-1})`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MongoVUE, there is a way to visually create the same index by right-clicking
    on the collection name on the left-hand side of the screen and selecting **Add
    Index….**
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the new pop-up window, enter the name of the index and select the **Visual**
    tab as shown. Select the **lastName** and **age** fields with ascending and descending
    values, respectively:![How to do it…](img/B04831_09_10.jpg)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once these details are filled in, click on **Create**. This should create the
    index for us by firing the `ensureIndex` command.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose the index to be **Unique** and **Drop Duplicates** (which will
    be enabled when unique is selected), or even create big, long, and running index
    creations in the background.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the **Json** tab next to the **Visual** tab. This is the place where you
    can type the `ensureIndex` command as you do in the shell in order to create the
    index.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will see how to drop an index:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply expand the tree on the left-hand side (as shown in the screen shot in
    step 9)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On expanding the collection, we will see all the indexes created on it
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for the default index on the `_id` field, all the other indexes can be
    dropped
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply right-click on the name and select **Drop index** to drop or click on
    **Properties** to view its properties
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After seeing how to do the basic CRUD operations and creating an index, let''s
    look at how to execute the aggregation operations:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no visual tools as in the index creation for aggregation but simply
    a text area where we enter our aggregation pipeline
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sample, we perform aggregation on the `postalCodes` collection
    to find the top five states by the number of times they appear in the collection
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will have the following aggregation pipeline entered:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![How to do it…](img/B04831_09_11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Once the pipeline is entered, hit the **Aggregate** button to get the aggregation
    results
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executing MapReduce is even cooler. The use case that we will be executing
    is similar to the preceding one, but we will see how to implement a MapReduce
    operation using MongoVUE:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To execute a map reduce job, right-click on the collection name in the left-hand
    side menu, and click on **Map Reduce**.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This option is right above the **Aggregation** option that we saw in the previous
    image. This gives us a pretty neat GUI to enter the **Map**, **Reduce**, **Finalize**
    and the **In & Out**, as shown in the following image:![How to do it…](img/B04831_09_12.jpg)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Map` function is simply the following:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Reduce` function is the following:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Leave the `Finalize` method unimplemented, and in the **In & Out** section,
    fill in the following details:![How to do it…](img/B04831_09_13.jpg)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Go** to start executing the MapReduce job.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will print the output to the `mongoVue_mr` collection. Query the `mongoVue_mr`
    collection using the following query:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Check the results against those that we got using aggregation.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of map reduce was chosen as **Reduce**. For more options and their
    behavior, visit [http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd](http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring the server instances is now possible using `MongoVUE`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To monitor an instance, click on **Tools** | **Monitoring** in the top menu.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, no server will be added, and we will have to click on **+ Add Server**
    to add a server instance.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the Local Instance added or any server that you want to monitor, and
    click on **Connect**.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will see quite a lot of monitoring details. MongoVUE uses the `db.serverStatus`
    command to serve these stats and limit the frequency at which we execute this
    command on busy server instances, we can choose the **Refresh Interval** at the
    top of the screen, as shown in the following image:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_09_14.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we covered in the previous sections was pretty straightforward for us to
    perform the majority of our activities as a developer and administrator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 4](ch04.html "Chapter 4. Administration"), *Administration*
    and [Chapter 6](ch06.html "Chapter 6. Monitoring and Backups"), *Monitoring and
    Backups*, for recipes on the administration and monitoring of the MongoDB instances.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [http://www.mongovue.com/tutorials/](http://www.mongovue.com/tutorials/)
    for various tutorials on MongoVUE
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While writing this book, MongoDB was planning to release a similar data visualisation
    and manipulation product called **Compass**. You should check it out [https://www.mongodb.com/products/compass](https://www.mongodb.com/products/compass).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
