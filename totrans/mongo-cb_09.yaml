- en: Chapter 9. Open Source and Proprietary Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover some open source and proprietary tools. The
    following are the recipes that we will go through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing using spring-data-mongodb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing MongoDB using JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing MongoDB over REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a GUI-based client, MongoVUE, for MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a vast array of tools/frameworks available to ease the development/administration
    process for software that uses MongoDB. We will look at some of these available
    frameworks and tools. For a developer's productivity (Java developers, in this
    case), we will look at spring-data-mongodb, which is a part of the popular spring
    data suite.
  prefs: []
  type: TYPE_NORMAL
- en: JPA is an ORM specification that is widely used, particularly with relational
    databases. (This was the objective of the ORM frameworks.) However, there are
    a few implementations that let us use it with NoSQL stores—MongoDB, in this case.
    We will look at a provider who provides this implementation and put it to the
    test with a simple use case.
  prefs: []
  type: TYPE_NORMAL
- en: We will use spring-data-rest to expose the CRUD repositories for MongoDB over
    a REST interface for clients to invoke various operations supported by the underlying
    spring-data-mongo repository.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the database in the shell is okay, but it would be nice to have a good
    GUI to enable us to do all the administrative-related/development-related tasks
    from the GUI rather than execute the commands in the shell to perform these activities.
    We will look at one such tool in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing using spring-data-mongodb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a developer''s perspective, when a program needs to interact with a MongoDB
    instance, they need to use the respective client APIs for their specific platforms.
    The trouble with doing this is that we need to write a lot of boilerplate code
    and it is not necessarily object-oriented. For instance, we have a class called
    `Person` with various attributes such as `name`, `age`, `address`, and so on.
    The corresponding JSON document shares a similar structure to this `person` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, to store this document, we need to convert the `Person` class to DBObject,
    which is a map with key and value pairs. What is really needed is to let us persist
    this `Person` class itself as an object in the database without having to convert
    it to DBObject.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, some of the operations such as searching by a particular field
    of a document, saving an entity, deleting an entity, searching by the ID, and
    so on are pretty common operations, and we tend to repeatedly write similar boilerplate
    code. In this recipe, we will see how spring-data-mongodb relieves us of these
    laborious and cumbersome tasks to reduce, not only the development effort, but
    also the possibility of introducing bugs in these commonly written functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SpringDataMongoTest` project, present in the bundle with the chapter, is
    a Maven project and has to be imported to any IDE of your choice. The required
    maven artifacts will automatically be downloaded. A single MongoDB instance is
    required to be up and running and listening to port `27017`. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, for instructions
    on how to start a standalone instance.
  prefs: []
  type: TYPE_NORMAL
- en: For the aggregation example, we will use the postal codes data. Refer to the
    *Creating test data* recipe in [Chapter 2](ch02.html "Chapter 2. Command-line
    Operations and Indexes"), *Command-line Operations and Indexes*, for the creation
    of the test data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will explore the spring-data-mongodb's repository feature first. Open the
    test case's `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest` class from your
    IDE and execute it. If all goes well and the MongoDB server instance is reachable,
    the test case will get executed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another test case, `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest2`, is
    used to explore more features of the repository support provided by spring-data-mongodb.
    This test case too should get executed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see how spring-data-mongodb's `MongoTemplate` can be used to perform
    CRUD operations and other common operations on MongoDB. Open the `com.packtpub.mongo.cookbook.MongoTemplateTest`
    class and execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, if an IDE is not used, all the tests can be executed using maven
    from the command prompt with the current directory being in the root of the `SpringDataMongoTest`
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first look at what we did in `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`,
    where we saw the repository support provided by spring-data-mongodb. Just in case
    you didn't notice, we haven't written a single line of code for the repository.
    The magic of implementing the required code for us is done by the spring data
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the relevant portions of the XML configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We first look at the last three lines, which are the spring-data-mongodb namespace
    declarations to instantiate `com.mongodb.Mongo`, a factory for the `com.mongodb.DB`
    instances from the client, and `template` instance, which is used to perform various
    operations on MongoDB, respectively. We will see `org.springframework.data.mongodb.core.MongoTemplate`
    in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is a namespace declaration for the base package of all the CRUD
    repositories that we have. In this package, we have an interface with the following
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `PagingAndSortingRepository` interface is from the `org.springframework.data.repository`
    package of the spring data core project and extends from `CrudRepository` in the
    same project. These interfaces give us some of the most common methods such as
    searching by the ID/primary key, deleting an entity, and inserting and updating
    an entity. The repository needs an object that it maps to the underlying data
    store. The spring data project supports a large number of data stores not just
    limited to SQL (using JDBC and JPA) or MongoDB, but also to other NoSQL stores
    such as Redis and Hadoop and search engines such as Solr and Elasticsearch. In
    case of spring-data-mongodb, the object is mapped to a document in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `PagingAndSortingRepository<Person, Integer>` signature indicates that the
    first one is the entity that the CRUD repository is built for and the second is
    the type of the primary key/ID field.
  prefs: []
  type: TYPE_NORMAL
- en: We added just one `findByLastName` method, which accepts one string value for
    the last name as a parameter. This is an interesting operation that is specific
    to our repository and not even implemented by us, but it will still work just
    as expected. Person is a POJO where we annotated the `id` field with the `org.springframework.data.annotation.Id`
    annotation. Nothing else is really special about this class; it just has some
    plain getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these small details, let''s join these dots together by answering
    some questions that you''ll have in mind. First, we will see which server, database,
    and collection our data goes to. If we look at the XML definition, `mongo:mongo`,
    for the configuration file, we can see that we instantiated the `com.mongodb.Mongo`
    class by connecting to localhost and port `27017`. The `mongo:db-factory` declaration
    is used to denote that the database to be used is `test`. One final question is:
    which collection? The simple name of our class is `Person`. The name of the collection
    is the simple name with the first character in lowercase, and thus, `Person` goes
    to person and something like `BillingAddress` would go to the `billingAddress`
    collection. These are the default values. However, if you need to override this
    value, you can annotate your class with the `org.springframework.data.mongodb.core.mapping.Document`
    annotation and use its collection attribute to give any name of your choice, as
    we will see in a later example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the document in the collection, execute just one test case `saveAndQueryPerson`
    method from the `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest` class. Now,
    connect to the MongoDB instance in the mongo shell and execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding result, the contents of the document are similar
    to the object that we persisted using the CRUD repository. The names of the field
    in the document are the same as the names of the respective attributes in the
    Java object with two exceptions. The field annotated with `@Id` is now `_id`,
    irrespective of the name of the field in the Java class and an additional `_class`
    attribute is added to the document whose value is the fully qualified name of
    the Java class itself. This is not of any use to the application but is used by
    spring-data-mongodb as metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Now it makes more sense and gives us an idea what spring-data-mongodb must be
    doing for all the basic CRUD methods. All the operations that we perform will
    use the `MongoTemplate` (`MongoOperations`, which is an interface that `MongoTemplate`
    implements) class from the spring-data-mongodb project. Using the primary key,
    it will invoke a find by the `_id` field on the collection derived using the `Person`
    entity class. The `save` method simply calls the `save` method on `MongoOperations`,
    which, in turn, calls the `save` method on the `com.mongodb.DBCollection` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still haven''t answered how the `findByLastName` method worked. How does
    spring know what query to invoke in order to return the data? These are the special
    types of methods that begin with `find`, `findBy`, `get`, or `getBy`. There are
    some rules that one needs to follow while naming a method, and the proxy object
    on the repository interface is able to correctly convert this method into an appropriate
    query on the collection. For instance, the `findByLastName` method in the repository
    for the `Person` class will execute a query on the `lastName` field in person''s
    document. Hence, the `findByLastName(String lastName)` method will fire the `db.person.find({''lastName'':
    lastName })` query on the database. Based on the return type of the method defined,
    it will return either `List` or the first result in the returned result from the
    database. We used `findBy` in our queries; however, anything that begins with
    find, has any text in between, and ends with `By`, works. For instance, `findPersonBy`
    is also the same as `findBy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see more on these `findBy` methods, we have another test `MongoCrudRepositoryTest2`
    class. Open this class in your IDE where it can be read along with this text.
    We already executed this test case; now, let''s see these `findBy` methods used
    and their behavior. This interface has seven `findBy` methods in it, with one
    of the methods being a variant of another method in the same interface. To get
    a clear idea of the queries, we will first look at one of the documents in the
    `personTwo` collection in the test database. Execute the following in the mongo
    shell connected to the MongoDB server running on localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the repository uses the `Person2` class; however, the name of the
    collection used is `personTwo`. This was possible because we used the `@Document(collection="personTwo")`
    annotation on the top of the `Person2` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to the seven methods in the `com.packtpub.mongo.cookbook.PersonRepositoryTwo`
    repository class, let''s look at them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `findByAgeGreaterThanEqual` | This method will fire a query on the `personTwo`
    collection, `{''age'':{''$gte'':<age>}}`.The secret lies in the name of the method.
    If we break it up, what we have after `findBy` tells us what we want. The `age`
    property (with the first character in lowercase) is the field that would be queried
    on the document with the `$gte` operator because we have `GreaterThanEqual` in
    the name of the method. The value that would be used for the comparison would
    be the value of the parameter passed. The result is a collection of the `Person2`
    entities as we will have multiple matches. |'
  prefs: []
  type: TYPE_TB
- en: '| `findByAgeBetween` | This method will again be queried on age but will be
    using a combination of `$gt` and `$lt` to find the matching result. The query,
    in this case, would be `{''age'' : {''$gt'' : from, ''$lt'' : to}}`. It is important
    to note that both the values from and to are exclusive in the range. There are
    two methods in the test case, `findByAgeBetween` and `findByAgeBetween2`. These
    methods demonstrate the behavior of the between query for different input values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `findByAgeGreaterThan` | This method is a special method that also sorts
    the result because there are two parameters to the method: the first parameter
    is the value against which the age will be compared and the second parameter is
    the field of the `org.springframework.data.domain.So` `rt` type. For more details,
    refer to the Javadocs for spring-data-mongodb. |'
  prefs: []
  type: TYPE_TB
- en: '| `findPeopleByLastNameLike` | This method is used to find results by the last
    name matching a pattern. Regular expressions are used for the matching purpose.
    For instance, in this case, the query fired will be `{''lastName'' : <lastName
    as regex>}`. This method''s name begins with `findPeopleBy` instead of `findBy`,
    which works the same as `findBy`. Thus, when we say `findBy` in all the descriptions,
    we actually mean `find…By`.The value provided as the parameter will be used to
    match the last name. |'
  prefs: []
  type: TYPE_TB
- en: '| `findByResidentialAddressCountry` | This is an interesting method to look
    at. Here, we are searching by the country of the residential address. This is,
    in fact, a field in the `Address` class in the `residentialAddress` field of the
    person. Take a look at the document from the `personTwo` collection for how the
    query should be.When spring data finds the name as `ResidentialAddressCountry`,
    it will try to find various combinations using this string. For instance, it can
    look at the `residentialAddressCountry` field in the `Person` class or `residential.addressCountry`,
    `residentialAddress.country`, or `residential.address.country`. If there are no
    conflicting values as in our case the `residentialAddress`.The field ''country''
    is a part of the ''Person2'' document and thus that would be used in the query.However,
    if there are conflicts, then underscores can be used to clearly specify what we
    are looking at. In this case, the method can be renamed `findByResidentialAddress_country`
    to clearly specify what we expect as the result. The test case `findByCountry2`
    method demonstrates this. |'
  prefs: []
  type: TYPE_TB
- en: '| `findByFirstNameAndCountry` | This is an interesting method. We are not always
    able to use the method names to implement what we actually want to. The name of
    the method required for spring to automatically implement the query might be a
    bit awkward to use as is. For instance, `findByCountryOfResidence` sounds better
    than `findByResidentialAddressCountry`. However, we are stuck with the latter
    as that is how spring-data-mongodb would construct the query. Using `findByCountryOfResidence`
    gives no details on how to construct the query to spring data.There is a solution
    for this. You can choose to use the `@Query` annotation and specify the query
    to be executed when the method is invoked. The following is the annotation that
    we used:`@Query("{''firstName'':?0, ''residentialAddress.country'': ?1}")`We write
    the value as a query that would get executed and bind the parameters of the functions
    to the query as numbered parameters starting from zero. Thus, the first parameter
    of the method will be bound to `?0`, the second to `?1`, and so on. |'
  prefs: []
  type: TYPE_TB
- en: We saw how the `findBy` or `getBy` methods are automatically translated to the
    queries for MongoDB. Similarly, we have the following prefixes for the methods.
    The `countBy` method returns the long number for the count for a given condition,
    which is derived from the rest of the method name similar to `findBy`. We can
    have `deleteBy` or `removeBy` to delete the documents by the derived condition.
    One thing to note about the `com.packtpub.mongo.cookbook.domain.Person2` class
    is that it does not have a no argument constructor or setter to set the values.
    Instead, spring will use reflection to instantiate this object.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the `findBy` methods are supported by spring-data-mongodb and all are
    not covered here. Refer to the spring-data-mongodb reference manual for more details.
    A lot of XML-based or Java-based configuration options are available and can be
    found in the reference manual. The URLs are given in the *See also* section later
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet; we have another test case, `com.packtpub.mongo.cookbook.MongoTemplateTest`,
    which uses `org.springframework.data.mongodb.core.MongoTemplate` to perform various
    operations. You can open the test case class and see what operations are performed
    and which methods of MongoTemplate are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the important and frequently used methods of the MongoTemplate
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `save` | This method is used to save (insert, if new; or else, update) an
    entity in MongoDB. The method takes one parameter, the entity, and finds the target
    collection based on its name or the `@Document` annotation present on it.There
    is an overloaded version of the save method that also accepts the second parameter,
    the name of the collection to which the data entity passed needs to be persisted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | This method will be used to remove documents from the collection.
    It has some overloaded methods in this class. All of them accept either an entity
    to be deleted or the `org.springframework.data.mongodb.core.query.Query` instance,
    which is used to determine the document(s) to be deleted. The second parameter
    is the name of the collection from which the document has to be deleted. When
    an entity is provided, the name of the collection can be derived. With a `Query`
    instance provided, we have to give either the name of the collection or the entity
    class name, which, in turn, will be used to derive the name of the collection.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `updateMulti` | This is the function invoked to update multiple documents
    with one update call. The first parameter is the query that would be used to match
    the documents. The second parameter is the `org.springframework.data.mongodb.core.query.Updat`
    `e` instance. This is the update that would be executed on the documents selected
    using the first `Query` object. The next parameters are the entity class or collection
    name to execute the update on. Refer to the Javadocs for more details on the method
    and its various overloaded versions. |'
  prefs: []
  type: TYPE_TB
- en: '| `updateFirst` | It is the opposite of the `updateMulti` method. This operation
    will update just the first matching document. We have not covered this method
    in our unit test case. |'
  prefs: []
  type: TYPE_TB
- en: '| `insert` | We mentioned that the save method can perform insertion and updates.
    The insert method in the template calls the `insert` method of the underlying
    mongo client. If one entity or document is to be inserted, there is no difference
    in calling the `insert` or `save` method.However, as we can see in the `insertMultiple`
    method in the test case, we created a list of three `Person` instances and passed
    them to the insert method. All the three documents for the three `Person` instances
    will go to the server as part of one call. The behavior on what happens whenever
    an insert fails is determined by the continue on error parameter of the Write
    Concern. It will determine whether the bulk insert fails at the first failure
    or continues even after errors while reporting the last error. The URL, [http://docs.mongodb.org/manual/core/bulk-inserts/](http://docs.mongodb.org/manual/core/bulk-inserts/),
    gives more details on bulk inserts and various write concern parameters that can
    alter the behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| `findAndRemove`/`findAllAndRemove` | Both these operations are used to find
    and then remove the document(s). The first one finds one and then returns the
    deleted document. This operation is atomic. The latter, however, finds all the
    documents and removes them before returning the list of all the entities of all
    the documents deleted. |'
  prefs: []
  type: TYPE_TB
- en: '| `findAndModify` | This method is functionally similar to `findAndModify`
    that we have with the mongo client library. It will atomically find and modify
    the document. If the query matches more than one document, only the first match
    will be updated. The first two parameters of this method are the query and update
    to execute. The next few parameters are either the entity class or collection
    name to execute the operation on. Additionally, there is a special `org.springframework.data.mongodb.core.FindAndModifyOptions`
    class, which makes sense only for the `findAndModify` operation. This instance
    tells us whether we are looking for the new instance or old instance after the
    operation is performed and whether upsert is to be performed. It is relevant only
    if the document with the matching query doesn''t exist. There is an additional
    Boolean flag to tell the client whether this is a `findAndRemove` operation. In
    fact, the `findAndRemove` operation that we saw earlier is just a convenient function
    that delegates `findAndModify` with this remove flag set. |'
  prefs: []
  type: TYPE_TB
- en: 'In the preceding table, we mentioned the `Query` and `Update` classes when
    talking about update. These are special convenient classes in spring-data-mongodb,
    which let us build MongoDB queries using a syntax that is easy to understand with
    improved readability. For instance, the query to check whether `lastName` is `Johnson`
    in mongo is `{''lastName'':''Johnson''}`. The same query can be constructed in
    spring-data-mongodb as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax looks neat compared to giving the query in JSON. Let''s take another
    example where we want to find all the females under 30 years in our database.
    The query would now be built as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for update, we want to set a Boolean flag, `youngCustomer`, to `true`
    for some of the customers based on some conditions. To set this flag in the document,
    the MongoDB format would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In spring-data-mongodb, this would be achieved in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the Javadocs for all the possible methods that are available to build
    the query and updates in spring-data-mongodb to be used with `MongoTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are by no means the only ones available in the `MongoTemplate`
    class. There are a lot of other methods for geospatial indexes, convenient methods
    to get the count of the documents in a collection, aggregation and MapReduce support,
    and so on. Refer to the Javadocs of `MongoTemplate` for more details and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of aggregation, we also have a test case `aggregationTest` method
    to perform the aggregation operation on the collection. We have a `postalCodes`
    collection in MongoDB that contains the postal code details of various cities.
    An example document in the collection is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our aggregation operation intends to find the top five states by the number
    of documents in the collection. In mongo, the aggregation pipeline would look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In spring-data-mongodb, we invoked the aggregation operation using `MongoTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The key is in creating the instance of the `org.springframework.data.mongodb.core.aggregation.Aggregation`
    class. The `newAggregation` method is statically imported from the same class
    and accepts `varargs` for different instances of the `org.springframework.data.mongodb.core.aggregation.AggregationOperation`
    instances corresponding to the one operation in the chain. The `Aggregation` class
    has various static methods to create the instances of `AggregationOperation`.
    We have used a few of them such as `project`, `group`, `sort`, and `limit`. Refer
    to the Javadocs for more details and available methods. The `aggregate` method
    in `MongoTemplate` takes three arguments. The first one is the instance of the
    `Aggregation` class, the second one is the name of the collection, and the third
    one is the return type of the aggregation result. Refer to the aggregation operation
    test case for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the Javadocs at [http://docs.spring.io/spring-data/mongodb/docs/current/api/](http://docs.spring.io/spring-data/mongodb/docs/current/api/)
    for more details and API documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference manual for the spring-data-mongodb project can be found at [http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/](http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing MongoDB using JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use a JPA provider that allows us to use JPA entities
    to achieve object-to-document mapping with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start the standalone server instance listening to port `27017`. This is a Java
    project using JPA. Familiarity with JPA and its annotations is expected, though
    what we will be looking at is fairly basic. Refer to the *Connecting to the single
    node using a Java client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, to see how to
    set up maven if you are not aware of it. Download the `DataNucleusMongoJPA` project
    from the bundle provided with this book. Though we will be executing the test
    cases from the command prompt, you can import the project to your favorite IDE
    to view the source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to the root directory of the `DataNucleusMongoJPA` project and execute the
    following in the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This should download the necessary artifacts needed to build and run the project
    and execute the test cases successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the test cases get executed, open a mongo shell and connect to the local
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following query in the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at a sample document that was created in the `personJPA`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps that we executed are pretty simple; let''s look at the classes that
    are used one by one. We start with the `com.packtpub.mongo.cookbook.domain.Person`
    class. On the top of the class (after the package and imports), we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This denotes that the `Person` class is an entity and the collection to which
    it would persist is `personJPA`. Note that JPA was designed primarily as an **Object
    Relational Mapping** (**ORM**) tool and, so, the terminologies used are more for
    a relational database. A table in RDBMS is synonymous to a collection in MongoDB.
    The rest of the class contains the attributes of person and the columns annotated
    with `@Column` and `@Id` for a primary key. These are simple JPA annotations.
    What is interesting to look at is the `com.packtpub.mongo.cookbook.domain.ResidentialAddress`
    class, which is stored as a `residentialAddress` variable in the `Person` class.
    If we look at the person document that we gave earlier, all the values given in
    the `@Column` annotation are the names of the keys for person; also notice how
    `Enum` gets converted to a string value as well. The `residentialAddress` field
    is the name of the variable in the `Person` class against which the address instance
    is stored. If we look at the `ResidentialAddress` class, we can see the `@Embeddable`
    annotation at the top above the class name. This is again a JPA annotation that
    denotes that this instance is not an entity itself, but is embedded in another
    `Entity` or `Embeddable` class. Note the names of the fields in the document;
    in this case, they have the following format: `<name of the variable in person
    class>_<value of the variable name in ResidentialAddress class>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one problem here. The names of the fields are too long, consuming
    unnecessary space. The solution is to have a shorter value in the `@Column` annotation.
    For instance, the `@Column(name="ln")` annotation instead of `@Column(name="lastName")`,
    will create the key with a `ln` name in the document. Unfortunately, this doesn''t
    work with the embedded `ResidentialAddress` class; in which case, you will have
    to deal with shorter variable names. Now that we have seen the entity classes,
    let''s see `persistence.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have got just the persistence-unit definition here with the name as `DataNucleusMongo`.
    There is one class node that is the entity that we will use. Note that the embedded
    address class is not mentioned here as it is not an independent entity. In the
    properties, we mentioned the URL of the data store to connect to. In this case,
    we connect to the instance on localhost, port `27017`, and database test.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the class that queries and inserts the data. This is our
    `com.packtpub.mongo.cookbook.DataNucleusJPATest` test class. We create `javax.persistence.EntityManagerFactory`
    as `Persistence.createEntityManagerFactory("DataNucleusMongo")`. This is a thread-safe
    class and its instance is shared across threads; the string argument is also the
    same as the name of the persistence unit that we used in `persistence.xml`. All
    the other invocations on `javax.persistence.EntityManager` to persist or query
    the collection require us to create an instance using `EntityManagerFactory`—use
    it and then close it once the operation is completed. All the operations performed
    are as per the JPA specifications. The test case class persists entities and also
    queries them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we look at `pom.xml`, particularly the enhancer plugin that we used,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The entities that we have written need to be enhanced in order to be used as
    JPA entities using data nucleus. The preceding plugin will be attached to the
    process-class phase and then call the plugin's enhance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways to enhance JPA entities using a data nucleus enhancer.
    Refer to [http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html](http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html)
    for possible options. There is even a plugin for Eclipse to allow entity classes
    to be enhanced/instrumented for data nucleus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JPA 2.1 specification can be found at [https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html](https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing MongoDB over REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to access MongoDB and perform CRUD operations
    using REST APIs. We will use spring-data-rest for REST access and spring-data-mongodb
    to perform the CRUD operations. Before you continue with this recipe, it is important
    to know how to implement the CRUD repositories using spring-data-mongodb. Refer
    to the *Developing using spring-data-mongodb* recipe in this chapter to know how
    to use this framework.
  prefs: []
  type: TYPE_NORMAL
- en: The question one must be having is, why is a REST API needed? There are scenarios
    where there is a database that is being shared by many applications and is possibly
    written in different languages. Writing JPA DAO or using spring-data-mongodb is
    good enough for Java clients but not for clients in other languages. Having APIs
    locally with the application doesn't even give us a centralized way to access
    the database. This is where REST APIs come into play. We can develop the server-side
    data access layer and the CRUD repository in Java—spring-data-mongodb to be precise—and
    then expose it over a REST interface for a client written in any language to invoke
    them. We not only invoke our API in a platform-independent way, but also provide
    a single point of entry into our database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the prerequisites of the spring-data-mongodb recipe, we have a few
    more requirements for this recipe. The first thing is to download the `SpringDataRestTest`
    project from the Packt website and import it to your IDE as a maven project. Alternatively,
    if you do not wish to import to the IDE, you can run the server servicing the
    requests from the command prompt, which we will see in the next section. There
    is no specific client application used to perform the CRUD operations over REST.
    I will be demonstrating the concepts using the Chrome browser and a special plugin
    of the Advanced REST Client browser to send HTTP POST requests to the server.
    The tools can be found under the **Developer Tools** section of the Chrome web
    store.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have imported the project in your IDE as a maven project, execute the
    `com.packtpub.mongo.cookbook.rest.RestServer` class, which is the bootstrap class
    and starts the server locally that would accept client connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the project is to be executed from the command prompt as a maven project,
    go to the root directory of the project and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line on the command will be seen on the command prompt if all
    goes well and the server has been started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After starting the server in either way, enter `http://localhost:8080/people`
    in the browser's address bar and we should see the following JSON response. This
    response is seen because the underlying person collection is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now insert a new document in the person collection using an HTTP POST
    request to `http://localhost:8080/people`. We will be sending a POST request to
    the server using the Advanced REST Client Chrome extension. The document posted
    is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The request's content type is `application`/`json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the POST request sent to the server and the response
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will now query this document from the browser using the `_id` field, which
    is `1` in this case. Enter `http://localhost:8080/people/1` in the browser's address
    bar. You should see the document that we inserted in step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have one document in the collection, (you can try to insert more
    documents for people with different names and, more importantly, a unique ID.)
    we will query the document using the last name. First, type the following URL
    in the browser''s address bar to view the entire search options available: `http://localhost:8080/people/search`.
    We should see one `search` method, `findByLastName`, that accepts a command line
    parameter, `lastName`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To search by the last name, Cruise in our case, enter the following URL in
    the browser''s address bar: `http://localhost:8080/people/search/findByLastName?lastName=Cruise`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now update the last name and age of the person with the ID `1`, Tom
    Cruise for now. Let's update the last name to Hanks and the age to `58`. To do
    this, we will be using the HTTP PATCH request and the request will be sent to
    `http://localhost:8080/people/1`, which uniquely identifies the document to update.
    The body of the HTTP PATCH request is `{"lastName":"Hanks", "age":58}`. Refer
    to the following image for the request that we sent out for an update:![How to
    do it…](img/B04831_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To validate whether our update went through successfully or not (we know it
    did as we got a response status 204 after the PATCH request), enter `http://localhost:8080/people/1`
    again in the browser's address bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we delete the document. This is straightforward, and we simply send
    a DELETE request to `http://localhost:8080/people/1`. Once the DELETE request
    is successful, send an HTTP GET request from the browser to `http://localhost:8080/people/1`
    and we should not get any document in return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not be reiterating the spring-data-mongodb concepts again in this recipe,
    but will look at some of the annotations that we added specifically for the REST
    interface to the repository class. The first one is on the top of the class name,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is used to instruct the server that this CRUD repository can be accessed
    using the people resource. This is the reason why we always make HTTP GET and
    POST requests on `http://localhost:8080/people/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second annotation is in the `findByLastName` method. We have the following
    method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, the method's `lastName` parameter is annotated with the `@Param` annotation,
    which is used to annotate the name of the parameter that will have the value of
    the `lastName` parameter that will be passed while invoking this method on the
    repository. If we look at step 6 in the previous section, we can see that `findByLastName`
    is invoked using an HTTP GET request, and the value of the URL `lastName` parameter
    is used as the string value passed while invoking the repository method.
  prefs: []
  type: TYPE_NORMAL
- en: Our example here is pretty simple with just one parameter used for the search
    operation. We can have multiple parameters for the repository method and an equal
    number of parameters in the HTTP request that will be mapped to these parameters
    for the method to be invoked on the CRUD repository. For some types, such as dates
    to be sent out, use the `@DateTimeFormat` annotation, which will be used to specify
    the date and time format. Refer to the spring Javadocs at [http://docs.spring.io/spring/docs/current/javadoc-api/](http://docs.spring.io/spring/docs/current/javadoc-api/)
    for more information on this annotation and its usage.
  prefs: []
  type: TYPE_NORMAL
- en: This was all about the GET request that we made to the REST interface to query
    and search data. We initially created a document data sending an HTTP POST request
    to the server. To create new documents, we would always be sending a POST request—with
    the document to be created as the body of the request—to the URL identifying the
    REST endpoint, in our case, `http://localhost:8080/people/`. All documents posted
    to this collection would be making use of `PersonRepository` to persist `Person`
    in the corresponding collection.
  prefs: []
  type: TYPE_NORMAL
- en: Our final two steps were to update person and delete person. The HTTP request
    types to perform these operations are PATCH and DELETE, respectively. In step
    7, we updated the document for the person Tom Cruise and updated his last name
    and age. To achieve this, our PATCH request is sent to a URL identifying a specific
    person instance, which is `http://localhost:8080/people/1`. Note that in case
    of creating a new person, our POST request was always sent to `http://localhost:8080/people`,
    as against the PATCH and DELETE requests, where we sent the HTTP request to a
    URL representing the specific person that we want to update or delete. In the
    case of update, the body of the PATCH request is JSON whose provided fields would
    replace the corresponding fields in the target document to update. All the other
    fields would be left as is. In our case, `lastName` and the age of the target
    document were updated and `firstName` was left untouched. In case of delete, the
    message body was not empty, and the DELETE request itself indicates that the target
    to which the request was sent should be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: You can also send a PUT request instead of PATCH to a URL, identifying a specific
    person; in which case, the entire document in the collection would get updated
    or replaced with the document provided as part of the PUT request.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spring-data-rest home is at [http://projects.spring.io/spring-data-rest/](http://projects.spring.io/spring-data-rest/),
    where you can find links to its Git repository, reference manual, and Javadocs
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a GUI-based client, MongoVUE, for MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at a GUI-based client for MongoDB. Throughout
    the book, we have used the mongo shell to perform various operations that we need.
    Its advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It comes packaged with the MongoDB installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being lightweight, you don't need to worry about it taking up your system's
    resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On servers where GUI-based interfaces are not present, shell is the only option
    to connect, query, and administer the server instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having said this, if you are not on a server and want to connect to a database
    instance to query, view the plan of a query, administer, and so on, it is nice
    to have a GUI with these features to let you do things in the click of a button.
    As a developer, we always query our relational database with a GUI-based thick
    client, so why not for MongoDB?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to install some features of a MongoDB client,
    MongoVUE. This client is available only for Windows machines. This product has
    both a paid version (with various levels of licensing per number of users) and
    free version that has some limitations. For this recipe, we'll be looking at the
    free version.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a single instance of MongoDB server. The port on which the connections
    are accepted will be the default one, `27017`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following two collections from the command prompt after the mongod
    server has started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the installer ZIP for the MongoVUE from [http://www.mongovue.com/downloads/](http://www.mongovue.com/downloads/).
    Once downloaded, it is a matter of a few clicks and the software gets installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the installed application; as this is a free version, we will have all
    the features available for the first 14 days, after which, some of the features
    will not be available. The details of this can be seen at [http://www.mongovue.com/purchase/](http://www.mongovue.com/purchase/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing that we will do is add a database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the following window has opened, click on the (**+**) button to add a new
    connection:![How to do it…](img/B04831_09_03.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once opened, we will get another window in which we will fill in the server
    connection details. Fill in the following details in the new window and click
    on **Test**. This should succeed if the connection works; finally, click on **Save**.![How
    to do it…](img/B04831_09_04.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once added, connect to the instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the left navigation panel, we will see the instances added and the databases
    in them, as shown in the following image:![How to do it…](img/B04831_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see in the preceding image, hovering the mouse over the name of the
    collection shows us the size and count of the documents in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to query a collection and get all the documents. We will use the
    `postalCodes` collection for our `test`. Right-click on the collection name, and
    click on **View**. We will see the contents of the collection shown as either
    a Tree View, where we can expand and see the contents, Table View, which shows
    the contents in a tabular grid, and Text View, which shows the contents as normal
    JSON text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we query a collection with nested documents; `personTwo`
    is a collection with the following sample document in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we query to see all the documents in the collection, we see the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `residentialAddress` column shows that the value is a nested document with
    the given number of fields present in it. Hovering your mouse over it shows the
    nested document; alternatively, you can click on the column to show the contents
    in this document again as a grid. Once the nested documents are shown, you can
    click on the top of the grid to come back one level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to write queries to retrieve selected documents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **postalCodes** collection, and click on **Find**. We will
    type the following query in the **{Find}** textbox and the **{Sort}** field, and
    click on the **Find** button to the right:![How to do it…](img/B04831_09_07.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can choose the type of view that we want from the tab, which is a **Tree
    View**, **Table View**, or **Text View**. The plan of the query is also shown.
    Whenever any operation is run, the Learn shell at the bottom shows the actual
    Mongo query executed. In this case, we see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The plan of a query is also shown every time, and, as of the current version
    1.6.9.0, there is no way to disable the showing of the query plan with the query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Tree View**, right-clicking on a document will give you more options, such
    as expand it, copy the JSON contents, add keys to this document, remove the document,
    and so on. Try to remove a document from this collection using a right-click,
    and try adding any additional keys to the document. You can choose to restore
    the documents by reimporting the data from the `postalCodes` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To insert a document in the collection, perform the following. We will be inserting
    a document in the `personTwo` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **personTwo** collection name, and click on **Insert/Import
    Documents…**, as shown in the following screenshot:![How to do it…](img/B04831_09_08.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another pop-up window will appear, where you can choose to enter a single JSON
    document or valid text file with the JSON documents to be imported. We imported
    the following document by importing a single document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Query the collection once the document has been imported successfully; we will
    view the newly imported document along with the old ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to update the document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can either right-click on the collection name to the left and click **Update**,
    or select the **Update** option at the top. In either case, we will see the following
    window. Here, we will be updating the age of the person that we inserted in the
    previous step:![How to do it…](img/B04831_09_09.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some things to note in this GUI are the query textbox on the left-hand side
    to find the document to be updated and the update JSON on the right-hand side,
    which will be applied to the selected document(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you update, you can choose to hit the **Count** button to see the number
    of documents that can be updated (in this case, one). Clicking on **Find** will
    show you the documents in the Tree form. On the right-hand side, below the update
    JSON text, we have the option to update one document and multiple documents by
    clicking on **Update 1** or **Update All**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose an **Upsert** operation in case the documents for the given **Find**
    condition are not found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The radio buttons on the bottom right of the preceding screen shows either the
    output of the `getLastError` operation or the result after the update, in which
    case, a query will be executed to find the document(s) updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The find query, however, is not foolproof and might return different results
    than those truly updated as a separate query, the same as in the **Find** textbox.
    The update and find operations are not atomic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have queried on small collections so far. As the size of the collection
    increases, queries performing full collection scans are not acceptable and we
    need to create indexes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create an index by `lastName` in ascending order and age in descending order,
    we will invoke `db.personTwo.ensureIndex({'lastName':1, 'age':-1})`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MongoVUE, there is a way to visually create the same index by right-clicking
    on the collection name on the left-hand side of the screen and selecting **Add
    Index….**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the new pop-up window, enter the name of the index and select the **Visual**
    tab as shown. Select the **lastName** and **age** fields with ascending and descending
    values, respectively:![How to do it…](img/B04831_09_10.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once these details are filled in, click on **Create**. This should create the
    index for us by firing the `ensureIndex` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose the index to be **Unique** and **Drop Duplicates** (which will
    be enabled when unique is selected), or even create big, long, and running index
    creations in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the **Json** tab next to the **Visual** tab. This is the place where you
    can type the `ensureIndex` command as you do in the shell in order to create the
    index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will see how to drop an index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply expand the tree on the left-hand side (as shown in the screen shot in
    step 9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On expanding the collection, we will see all the indexes created on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for the default index on the `_id` field, all the other indexes can be
    dropped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply right-click on the name and select **Drop index** to drop or click on
    **Properties** to view its properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After seeing how to do the basic CRUD operations and creating an index, let''s
    look at how to execute the aggregation operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no visual tools as in the index creation for aggregation but simply
    a text area where we enter our aggregation pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sample, we perform aggregation on the `postalCodes` collection
    to find the top five states by the number of times they appear in the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will have the following aggregation pipeline entered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](img/B04831_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the pipeline is entered, hit the **Aggregate** button to get the aggregation
    results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executing MapReduce is even cooler. The use case that we will be executing
    is similar to the preceding one, but we will see how to implement a MapReduce
    operation using MongoVUE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To execute a map reduce job, right-click on the collection name in the left-hand
    side menu, and click on **Map Reduce**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This option is right above the **Aggregation** option that we saw in the previous
    image. This gives us a pretty neat GUI to enter the **Map**, **Reduce**, **Finalize**
    and the **In & Out**, as shown in the following image:![How to do it…](img/B04831_09_12.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Map` function is simply the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Reduce` function is the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Leave the `Finalize` method unimplemented, and in the **In & Out** section,
    fill in the following details:![How to do it…](img/B04831_09_13.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Go** to start executing the MapReduce job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will print the output to the `mongoVue_mr` collection. Query the `mongoVue_mr`
    collection using the following query:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Check the results against those that we got using aggregation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of map reduce was chosen as **Reduce**. For more options and their
    behavior, visit [http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd](http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring the server instances is now possible using `MongoVUE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To monitor an instance, click on **Tools** | **Monitoring** in the top menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, no server will be added, and we will have to click on **+ Add Server**
    to add a server instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the Local Instance added or any server that you want to monitor, and
    click on **Connect**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will see quite a lot of monitoring details. MongoVUE uses the `db.serverStatus`
    command to serve these stats and limit the frequency at which we execute this
    command on busy server instances, we can choose the **Refresh Interval** at the
    top of the screen, as shown in the following image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we covered in the previous sections was pretty straightforward for us to
    perform the majority of our activities as a developer and administrator.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 4](ch04.html "Chapter 4. Administration"), *Administration*
    and [Chapter 6](ch06.html "Chapter 6. Monitoring and Backups"), *Monitoring and
    Backups*, for recipes on the administration and monitoring of the MongoDB instances.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [http://www.mongovue.com/tutorials/](http://www.mongovue.com/tutorials/)
    for various tutorials on MongoVUE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While writing this book, MongoDB was planning to release a similar data visualisation
    and manipulation product called **Compass**. You should check it out [https://www.mongodb.com/products/compass](https://www.mongodb.com/products/compass).
  prefs: []
  type: TYPE_NORMAL
