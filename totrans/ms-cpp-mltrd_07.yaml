- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most things, it's best to avoid making mistakes rather than correcting
    them afterwards. This chapter looks at a number of common mistakes and design
    issues with multithreaded applications, and shows ways to avoid the common - and
    less common - issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Common multithreading issues, such as deadlocks and data races.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proper use of mutexes, locks, and pitfalls.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential issues when using static initialization.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper multithreading
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we have seen a variety of potential issues which
    can occur when writing multithreaded code. These range from the obvious ones,
    such as two threads not being able to write to the same location at the same time,
    to the more subtle, such as incorrect usage of a mutex.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: There are also many issues with elements which aren't directly part of multithreaded
    code, yet which can nevertheless cause seemingly random crashes and other frustrating
    issues. One example of this is static initialization of variables. In the following
    sections, we'll be looking at all of these issues and many more, as well as ways
    to prevent ever having to deal with them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: As with many things in life, they are interesting experiences, but you generally
    do not care to repeat them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Wrongful expectations - deadlocks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A deadlock is described pretty succinctly by its name already. It occurs when
    two or more processes attempt to gain access to a resource which the other is
    holding, while that other thread is simultaneously waiting to gain access to a
    resource which it is holding.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Thread 1 gains access to resource A
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread 1 and 2 both want to gain access to resource B
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread 2 wins and now owns B, with thread 1 still waiting on B
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread 2 wants to use A now, and waits for access
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both thread 1 and 2 wait forever for a resource
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this situation, we assume that the thread will be able to gain access to
    each resource at some point, while the opposite is true, thanks to each thread
    holding on to the resource which the other thread needs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualized, this deadlock process would look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'This makes it clear that two basic rules when it comes to preventing deadlocks
    are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Try to never hold more than one lock at any time.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release any held locks as soon as you can.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We saw a real-life example of this in [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24),
    *Thread Synchronization and Communication*, when we looked at the dispatcher demonstration
    code. This code involves two mutexes, to safe-guard access to two data structures:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mutexes here are the `workersMutex` and `requestsMutex` variables. We can
    clearly see how at no point do we hold onto a mutex before trying to obtain access
    to the other one. We explicitly lock the `workersMutex` at the beginning of the
    method, so that we can safely check whether the workers data structure is empty
    or not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: If it's not empty, we hand the new request to a worker. Then, as we are done
    with the workers, data structure, we release the mutex. At this point, we retain
    zero mutexes. Nothing too complex here, as we just use a single mutex.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing is in the else statement, for when there is no waiting
    worker and we need to obtain the second mutex. As we enter this scope, we retain
    one mutex. We could just attempt to obtain the `requestsMutex` and assume that
    it will work, yet this may deadlock, for this simple reason:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The accompanying function to the earlier preceding function we see also uses
    these two mutexes. Worse, this function runs in a separate thread. As a result,
    when the first function holds the `workersMutex` as it tries to obtain the `requestsMutex`,
    with this second function simultaneously holding the latter, while trying to obtain
    the former, we hit a deadlock.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the functions, as we see them here, however, both rules have been implemented
    successfully; we never hold more than one lock at a time, and we release any locks
    we hold as soon as we can. This can be seen in both else cases, where as we enter
    them, we first release any locks we do not need any more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'As in either case, we do not need to check respectively, the workers or requests
    data structures any more; we can release the relevant lock before we do anything
    else. This results in the following visualization:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: It is of course possible that we may need to use data contained in two or more
    data structures or variables; data which is used by other threads simultaneously.
    It may be difficult to ensure that there is no chance of a deadlock in the resulting
    code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Here, one may want to consider using temporary variables or similar. By locking
    the mutex, copying the relevant data, and immediately releasing the lock, there
    is no chance of deadlock with that mutex. Even if one has to write back results
    to the data structure, this can be done in a separate action.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'This adds two more rules in preventing deadlocks:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Try to never hold more than one lock at a time.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release any held locks as soon as you can.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never hold a lock any longer than is absolutely necessary.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When holding multiple locks, mind their order.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being careless - data races
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data race, also known as a race condition, occurs when two or more threads
    attempt to write to the same shared memory simultaneously. As a result, the state
    of the shared memory during and at the end of the sequence of instructions executed
    by each thread is by definition, non-deterministic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 6](part0129.html#3R0OI0-1ab5991b318547348fc444437bdacb24),
    *Debugging Multithreaded Code*, data races are reported quite often by tools used
    to debug multi-threaded applications. For example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code which generated the preceding warning was the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Consider this code in the `Worker` instance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also have:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, `running` is a Boolean variable that is being set to `false` (writing
    to it from one thread), signaling the worker thread that it should terminate its
    waiting loop, where reading the Boolean variable is done from a different process,
    the main thread versus the worker thread:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: This particular example's warning was due to a Boolean variable being simultaneously
    written and read. Naturally, the reason why this specific situation is safe has
    to do with atomics, as explained in detail in [Chapter 8](part0169.html#515F20-1ab5991b318547348fc444437bdacb24),
    *Atomic Operations - Working with the Hardware*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why even an operation like this is potentially risky is because
    the reading operation may occur while the variable is still in the process of
    being updated. In the case of, for example, a 32-bit integer, depending on the
    hardware architecture, updating this variable might be done in one operation,
    or multiple. In the latter case, the reading operation might read an intermediate
    value with unpredictable results:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'A more comical situation occurs when multiple threads write to a standard with
    out using, for example, `cout`. As this stream is not thread-safe, the resulting
    output stream will contain bits and pieces of the input streams, from whenever
    either of the threads got a chance to write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'The basic rules to prevent data races thus are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Never write to an unlocked, non-atomic, shared resource
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never read from an unlocked, non-atomic, shared resource
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This essentially means that any write or read has to be thread-safe. If one
    writes to shared memory, no other thread should be able to write to it at the
    same time. Similarly, when we read from a shared resource, we need to ensure that,
    at most, only other threads are also reading the shared resource.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This level of mutual exclusion is naturally accomplished by mutexes as we have
    seen in the preceding chapters, with a refinement offered in read-write locks,
    which allows for simultaneous readers while having writes as fully mutually exclusive
    events.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are also gotchas with mutexes, as we will see in the following
    section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes aren't magic
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutexes form the basis of practically all forms of mutual exclusion APIs. At
    their core, they seem extremely simple, only one thread can own a mutex, with
    other threads neatly waiting in a queue until they can obtain the lock on the
    mutex.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'One might even picture this process as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.gif)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: The reality is of course less pretty, mostly owing to the practical limitations
    imposed on us by the hardware. One obvious limitation is that synchronization
    primitives aren't free. Even though they are implemented in the hardware, it takes
    multiple calls to make them work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The two most common ways to implement mutexes in the hardware is to use either
    the **test-and-set** (**TAS**) or **compare-and-swap** (**CAS**) CPU features.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Test-and-set is usually implemented as two assembly-level instructions, which
    are executed autonomously, meaning that they cannot be interrupted. The first
    instruction tests whether a certain memory area is set to a 1 or zero. The second
    instruction is executed only when the value is a zero (`false`). This means that
    the mutex was not locked yet. The second instruction thus sets the memory area
    to a 1, locking the mutex.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'In pseudo-code, this would look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compare-and-swap is a lesser used variation on this, which performs a comparison
    operation on a memory location and a given value, only replacing the contents
    of that memory location if the first two match:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In either case, one would have to actively repeat either function until a positive
    value is returned:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a simple while loop is used to constantly poll the memory area (marked
    as volatile to prevent possibly problematic compiler optimizations). Generally,
    an algorithm is used for this which slowly reduces the rate at which it is being
    polled. This is to reduce the amount of pressure on the processor and memory systems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it clear that the use of a mutex is not free, but that each thread
    which waits for a mutex lock actively uses resources. As a result, the general
    rules here are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that threads wait for mutexes and similar locks as briefly as possible.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use condition variables or timers for longer waiting periods.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locks are fancy mutexes
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier in the section on mutexes, there are some issues to keep in
    mind when using mutexes. Naturally these also apply when using locks and other
    mechanisms based on mutexes, even if some of these issues are smoothed over by
    these APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: One of the things one may get confused about when first using multithreading
    APIs is what the actual difference is between the different synchronization types.
    As we covered earlier in this chapter, mutexes underlie virtually all synchronization
    mechanisms, merely differing in the way that they use mutexes to implement the
    provided functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is that they are not distinct synchronization mechanisms,
    but merely specializations of the basic mutex type. Whether one would use a regular
    mutex, a read/write lock, a semaphore - or even something as esoteric as a reentrant
    (recursive) mutex or lock - depends fully on the particular problem which one
    is trying to solve.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: For the scheduler, we first encountered in [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24),
    *Thread Aynchronization and Communication*, we used regular mutexes to protect
    the data structures containing the queued worker threads and requests. Since any
    access of either data structure would likely not only involve reading actions,
    but also the manipulation of the structure, it would not make sense there to use
    read/write locks. Similarly, recursive locks would not serve any purpose over
    the humble mutex.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'For each synchronization problem, one therefore has to ask the following questions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Which requirements do I have?
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which synchronization mechanism best fits these requirements?
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's therefore attractive to go for a complex type, but generally it's best
    to stick with the simpler type which fulfills all the requirements. When it comes
    to debugging one's implementation, precious time can be saved over a fancier implementation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Threads versus the future
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently it has become popular to advise against the use of threads, instead
    advocating the use of other asynchronous processing mechanisms, such as `promise`.
    The reasons behind this are that the use of threads and the synchronization involved
    is complex and error-prone. Often one just wants to run a task in parallel and
    not concern oneself with how the result is obtained.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: For simple tasks which would run only briefly, this can certainly make sense.
    The main advantage of a thread-based implementation will always be that one can
    fully customize its behavior. With a `promise`, one sends in a task to run and
    at the end, one gets the result out of a `future` instance. This is convenient
    for simple tasks, but obviously does not cover a lot of situations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The best approach here is to first learn threads and synchronization mechanisms
    well, along with their limitations. Only after that does it really make sense
    to consider whether one wishes to use a promise, `packaged_task`, or a full-blown
    thread.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Another major consideration with these fancier, future-based APIs is that they
    are heavily template-based, which can make the debugging and troubleshooting of
    any issues which may occur significantly less easy than when using the more straightforward
    and low-level APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Static order of initialization
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Static variables are variables which are declared only once, essentially existing
    in a global scope, though potentially only shared between instances of a particular
    class. It''s also possible to have classes which are completely static:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see here, static variables along with static functions seem like a
    very simple, yet powerful concept. While at its core this is true, there's a major
    issue which will catch the unwary when it comes to static variables and the initialization
    of classes. This is in the form of initialization order.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine what happens if we wish to use the preceding class from another class''
    static initialization, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While this may seem like it would work fine, adding the first string to the
    class' map structure with the integer as key means there is a very good chance
    that this code will crash. The reason for this is simple, there is no guarantee
    that `Foo::string` is initialized at the point when we call `Foo::init()`. Trying
    to use an uninitialized map structure will thus lead to an exception.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In short, the initialization order of static variables is basically random,
    leading to non-deterministic behavior if this is not taken into account.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is fairly simple. Basically, the goal is to make
    the initialization of more complex static variables explicit instead of implicit
    like in the preceding example. For this we modify the Foo class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Starting at the top, we see that we no longer define the static map directly.
    Instead, we have a private function with the same name. This function's implementation
    is found at the bottom of this sample code. In it, we have a static pointer to
    a map structure with the familiar map definition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们看到我们不再直接定义静态地图。相反，我们有一个同名的私有函数。这个函数的实现可以在这个示例代码的底部找到。在其中，我们有一个指向具有熟悉地图定义的地图结构的静态指针。
- en: When this function is called, a new map is created when there's no instance
    yet, due to it being a static variable. In the modified `init()` function, we
    see that we call the `strings()` function to obtain a reference to this instance.
    This is the explicit initialization part, as calling the function will always
    ensure that the map structure is initialized before we use it, solving the earlier
    problem we had.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用这个函数时，如果还没有实例，就会创建一个新的地图，因为它是一个静态变量。在修改后的`init()`函数中，我们看到我们调用`strings()`函数来获得对这个实例的引用。这是显式初始化的部分，因为调用函数将始终确保在我们使用它之前初始化地图结构，解决了我们之前遇到的问题。
- en: 'We also see a small optimization here: the `stringsStatic` variable we create
    is also static, meaning that we will only ever call the `strings()` function once.
    This makes repeated function calls unnecessary and regains the speed we would
    have had with the previous simple--but unstable--implementation.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里看到了一个小优化：我们创建的`stringsStatic`变量也是静态的，这意味着我们只会调用一次`strings()`函数。这样做可以避免重复的函数调用，并恢复我们在先前简单但不稳定的实现中所拥有的速度。
- en: The essential rule with static variable initialization is thus, always use explicit
    initialization for non-trivial static variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，静态变量初始化的基本规则是，对于非平凡的静态变量，始终使用显式初始化。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a number of good practices and rules to keep in
    mind when writing multithreaded code, along with some general advice. At this
    point, one should be able to avoid some of the bigger pitfalls and major sources
    of confusion when writing such code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些编写多线程代码时需要牢记的良好实践和规则，以及一些建议。到目前为止，人们应该能够避免一些编写此类代码时的重大陷阱和主要混淆源。
- en: In the next chapter, we will be looking at how to use the underlying hardware
    to our advantage with atomic operations, along with the `<atomics>` header that
    was also introduced with C++11.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何利用原子操作和C++11引入的`<atomics>`头文件来利用底层硬件。
