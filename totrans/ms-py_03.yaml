- en: Chapter 3. Containers and Collections – Storing Data the Right Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes bundled with several very useful collections, a few of which are
    basic Python collection data types. The rest are advanced combinations of these
    types. In this chapter, we will explain some of these collections, how to use
    them, and the pros and cons of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can properly discuss data structures and the related performance,
    a basic understanding of time complexity (and specifically the big O notation)
    is required. No need to worry! The concept is really simple, but without it, we
    cannot easily explain the performance characteristics of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the big O notation is clear, we will discuss the basic data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tuple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Building on the basic data structures, we will continue with more advanced
    collections, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary-like types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChainMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Defaultdict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderedDict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'List types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deque`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Heapq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuple types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NamedTuple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enum`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time complexity – the big O notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin with this chapter, there is a simple notation that you need
    to understand. This chapter heavily uses the big O notation to indicate the time
    complexity for an operation. Feel free to skip this paragraph if you are already
    familiar with this notation. While this notation sounds really complicated, the
    concept is actually quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: When we say that a function takes `O(1)` time, it means that it generally only
    takes `1` step to execute. Similarly, a function with `O(n)` would take `n` steps
    to execute, where `n` is generally the size of the object. This time complexity
    is just a basic indication of what to expect when executing the code, as it is
    generally what matters most.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this system is to indicate the approximate performance of an
    operation; this is separate from code speed but it is still relevant. A piece
    of code that executes a single step `1000` times faster but needs `O(2**n)` steps
    to execute will still be slower than another version of it that takes only `O(n)`
    steps for a value of n equal to `10` or more. This is because `2**n` for `n=10`
    is `2**10=1024`, that is, 1,024 steps to execute the same code. This makes choosing
    the right algorithm very important. Even though `C` code is generally faster than
    Python, if it uses the wrong algorithm, it won't help at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have a list of `1000` items and you walk through them.
    This will take `O(n)` time because there are `n=1000` items. Checking whether
    or not an item exists in the list takes `O(n)`, so that''s 1,000 steps. Doing
    this 100 times will take you `100*O(n) = 100 * 1000 = 100,000` steps. When you
    compare this to a `dict`, where checking whether the item exists or not takes
    `only O(1)` time the difference is huge. With a `dict`, it would be `100*O(1)
    = 100 * 1 = 100` steps. So, using a `dict` instead of a `list` will be roughly
    1,000 times faster for an object with 1,000 items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate `O(1)`, `O(n)`, and `O(n**2)` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that the big O in this chapter is about the average case
    and not the worst case. In some cases, they can be much worse, but those are rare
    enough to be ignored for the general case.
  prefs: []
  type: TYPE_NORMAL
- en: Core collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can look at the more advanced combined collections later in this chapter,
    you need to understand the workings of the core Python collections. This is not
    just about the usage, however; it is also about the time complexities involved,
    which can strongly affect how your application will behave as it grows. If you
    are well versed with the time complexities of these objects and know the possibilities
    of Python 3's tuple packing and unpacking by heart, then feel free to jump to
    the *Advanced collections* section.
  prefs: []
  type: TYPE_NORMAL
- en: list – a mutable list of items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `list` is most likely the container structure that you've used most in Python.
    It is simple in its usage, and for most cases, it exhibits great performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you may already be well versed with the usage of list, you might not
    be aware of the time complexities of the `list` object. Luckily, many of the time
    complexities of `list` are very low; `append`, `get`, `set`, and `len` all take
    `O(1)` time—the best possible. However, you might not be aware of the fact that
    `remove` and `insert` have `O(n)` time complexity. So, to delete a single item
    out of 1,000 items, Python will have to walk-through 1,000 items. Internally,
    the `remove` and `insert` operations execute something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove or insert a single item from/into the list, Python needs to copy
    the entire list, which is especially heavy with larger lists. When executing this
    only once, it is of course not all that bad. But when executing a large number
    of deletions, a `filter` or `list` comprehension is a much faster solution because,
    if properly structured, it needs to copy the list only once. For example, suppose
    we wish to remove a specific set of numbers from the list. We have quite a few
    options for this. The first is a solution using `remove`, followed by a list comprehension,
    and then comes a `filter` statement. [Chapter 4](ch04.html "Chapter 4. Functional
    Programming – Readability Versus Brevity"), *Functional Programming – Readability
    Versus Brevity*, will explain `list` comprehensions and the `filter` statement
    in more detail. But first, let''s check out the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The latter two are much faster for large lists of items. This is because the
    operations are much faster. To compare using `n=len(items)` and `m=len(primes)`,
    the first takes `O(m*n)=5*10=50` operations, whereas the latter two take `O(n*1)=10*1=10`
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first method is actually slightly better than that since `n` decreases during
    the loop. So, it's effectively `10+9+8+7+6=40`, but this is an effect that is
    negligible enough to ignore. In the case of `n=1000`, that would be the difference
    between `1000+999+998+997+996=4990` and `5*1000=5000`, which is negligible in
    most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `min`, `max`, and `in` all take `O(n)` as well, but that is expected
    for a structure that is not optimized for these types of lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With these examples, it's obvious as well that the `in` operator could work
    `O(1)` if you're lucky, but we count it as `O(n)` because it might not exist,
    in which case all values need to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: dict – unsorted but a fast map of items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dict` has to be at least among the top three container structures you use
    in Python. It's fast, simple to use, and very effective. The average time complexity
    is exactly as you would expect—`O(1)` for `get`, `set`, and `del`—but there are
    cases where this is not true. The way a `dict` works is by converting the key
    to a hash using the `hash` function (calls the `__hash__` function of an object)
    and storing it in a hash table. There are two problems with hash tables, however.
    The first and the most obvious is that the items will be sorted by hash, which
    appears at random in most cases. The second problem with hash tables is that they
    can have hash collisions, and the result of a hash collision is that in the worst
    case, all the former operations can take `O(n)` instead. Hash collisions are not
    all that likely to occur, but they can occur, and if a large `dict` performs subpar,
    that's the place to look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this actually works in practice. For the sake of this example,
    I will use the simplest hashing algorithm I can think of, which is the most significant
    digit of a number. So, for the case of `12345`, it will return `1`, and for `56789`,
    it will return `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will emulate a `dict` using a `list` of lists with this hashing method.
    We know that our hashing method can only return numbers from `0` to `9`, so we
    need only 10 buckets in our list. Now we will add a few values and show how the
    spam in eggs might work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code is obviously not identical to the `dict` implementation, but it is
    actually quite similar internally. Because we can just get item `1` for a value
    of `123` by simple indexing, we have only `O(1)` lookup costs in the general case.
    However, since both keys, `123` and `101`, are within the `1` bucket, the runtime
    can actually increase to `O(n)` in the worst case where all keys have the same
    hash. That is what we call a hash collision.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To debug hash collisions, you can use the `hash()` function paired with the
    counter collection, discussed in the *counter – keeping track of the most occurring
    elements* section.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the hash collision performance problem, there is another behavior
    that might surprise you. When deleting items from a dictionary, it won't actually
    resize the dictionary in memory yet. The result is that both copying and iterating
    the entire dictionary take `O(m)` time (where m is the maximum size of the dictionary);
    `n`, the current number of items is not used. So, if you add 1,000 items to a
    `dict` and remove 999, iterating and copying will still take 1,000 steps. The
    only way to work around this issue is by recreating the dictionary, which is something
    that both the `copy` and `insert` operations will perform internally. Note that
    recreation during an `insert` operation is not guaranteed and depends on the number
    of free slots available internally.
  prefs: []
  type: TYPE_NORMAL
- en: set – like a dict without values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `set` is a structure that uses the hash method to get a unique collection
    of values. Internally, it is very similar to a `dict`, with the same hash collision
    problem, but there are a few handy features of set that need to be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first few are pretty much as expected. At the operators, it gets interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Output | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `spam` | `amps` | All unique items. A `set` doesn''t allow for duplicates.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `eggs` | `egs` |'
  prefs: []
  type: TYPE_TB
- en: '| `spam & eggs` | `s` | Every item in both. |'
  prefs: []
  type: TYPE_TB
- en: '| `spam &#124; eggs` | `aegmps` | Every item in either or both. |'
  prefs: []
  type: TYPE_TB
- en: '| `spam ^ eggs` | `aegmp` | Every item in either but not in both. |'
  prefs: []
  type: TYPE_TB
- en: '| `spam - eggs` | `amp` | Every item in the first but not the latter. |'
  prefs: []
  type: TYPE_TB
- en: '| `eggs - spam` | `eg` |'
  prefs: []
  type: TYPE_TB
- en: '| `spam > eggs` | `False` | True if every item in the latter is in the first.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `eggs > spam` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `spam > sp` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `spam < sp` | `False` | True if every item in the first is contained in the
    latter. |'
  prefs: []
  type: TYPE_TB
- en: 'One useful example for `set` operations is calculating the differences between
    two objects. For example, let''s assume we have two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current_users`: The current users in a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new_users`: The new list of users in a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In permission systems, this is a very common scenario—mass adding and/or removing
    users from a group. Within many permission databases, it''s not easily possible
    to set the entire list at once, so you need a list to insert and a list to delete.
    This is where `set` comes in really handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we have lists of all users who were added, removed, and unchanged. Note
    that `sorted` is only needed for consistent output, since a `set`, similar to
    a `dict`, has no predefined sort order.
  prefs: []
  type: TYPE_NORMAL
- en: tuple – the immutable list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `tuple` is an object that you use very often without even noticing it. When
    you look at it initially, it seems like a useless data structure. It's like a
    list that you can't modify, so why not just use a `list`? There are a few cases
    where a `tuple` offers some really useful functionalities that a `list` does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, they are hashaable. This means that you can use a `tuple` as a key
    in a `dict`, which is something a `list` can''t do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it can actually be more than simple numbers. As long as all elements
    of a `tuple` are hashable, it will work. This means that you can use nested tuples,
    strings, numbers, and anything else for which the `hash()` function returns a
    consistent result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can make these as complex as you need. As long as all the parts are hashable,
    it will function as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, even more useful is the fact that tuples also support tuple packing
    and unpacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to regular packing and unpacking, from Python 3 onwards, we can
    actually pack and unpack objects with a variable number of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This very method can be applied in many cases, even for function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And its equally useful to return multiple arguments from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Advanced collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following collections are mostly just extensions of base collections, some
    of them fairly simple and others a bit more advanced. For all of them though,
    it is important to know the characteristics of the underlying structures. Without
    understanding them, it will be difficult to comprehend the characteristics of
    these collections.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few collections that are implemented in native C code for performance
    reasons, but all of them can easily be implemented in pure Python as well.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap – the list of dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in Python 3.3, `ChainMap` allows you to combine multiple mappings
    (dictionaries for example) into one. This is especially useful when combining
    multiple contexts. For example, when looking for a variable in your current scope,
    by default, Python will search in `locals()`, `globals()`, and lastly `builtins`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but it''s ugly to say the least. We can make it prettier, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot better! Moreover, this can actually be considered a nice solution. But
    since Python 3.3, it''s even easier. Now we can simply use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChainMap` collection is very useful for command-line applications. The
    most important configuration happens through command-line arguments, followed
    by directory local config files, followed by global config files, followed by
    defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that accessing specific mappings is still possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: counter – keeping track of the most occurring elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `counter` is a class for keeping track of the number of occurrences of
    an element. Its basic usage is as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `counter` can do more than simply return the count. It also has a
    few very useful and fast (it uses `heapq`) methods for getting the most common
    elements. Even with a million elements added to the counter, it still executes
    within a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait, there''s more! In addition to getting the most frequent elements,
    it''s also possible to add, subtract, intersect, and "union" counters very similarly
    to the `set` operations that we saw earlier. So what is the difference between
    adding two counters and making a union of them? As you would expect, they are
    similar, but there is a small difference. Let''s look at its workings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first two are obvious. The `eggs` string is just a sequence of characters
    with two "`g`"s, one "`s`", and one "`e`", and spam is almost the same but with
    different letters.
  prefs: []
  type: TYPE_NORMAL
- en: The result of `spam & eggs` (and the reverse) is also quite predictable. The
    only letter that's shared between spam and eggs is `s`, so that's the result.
    When it comes to counts, it simply does a `min(element_a, element_b)` per shared
    element from both and gets the lowest.
  prefs: []
  type: TYPE_NORMAL
- en: When subtracting the letters `s`, `p`, `a`, and `m` from eggs, you are left
    with `e` and `g`. Similarly, when removing `e`, `g`, and `s` from spam, you are
    left with `p`, `a`, and `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, adding is as you would expect—just an element-by-element addition of both
    counters.
  prefs: []
  type: TYPE_NORMAL
- en: So how is the union (OR) any different? It gets the `max(element_a, element_b)`
    per element in either of the counters instead of adding them; regardless as is
    the case with the addition.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, as is demonstrated in the preceding code, the elements method returns
    an expanded list of all elements repeated by the count.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Counter` object will automatically remove elements that are zero or less
    during the execution of mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: deque – the double ended queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `deque` (short for Double Ended Queue) object is one of the oldest collections.
    It was introduced in Python 2.4, so it has been available for over 10 years by
    now. Generally, this object will be too low-level for most purposes these days,
    as many operations that would otherwise use it have well-supported libraries available,
    but that doesn't make it less useful.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `deque` is created as a doubly linked list, which means that every
    item points to the next and the previous item. Since `deque` is double-ended,
    the list itself points to both the first and the last element. This makes both
    adding and removing items from either the beginning or the end a very light `O(1)`
    operation, since only the pointer to the beginning/end of the list needs to change
    and a pointer needs to be added to the first/last item, depending on whether an
    item is added at the beginning or the end.
  prefs: []
  type: TYPE_NORMAL
- en: For simple stack/queue purposes, it seems wasteful to use a double-ended queue,
    but the performance is good enough for us not to care about the overhead incurred.
    The `deque` class is fully implemented in C (with CPython).
  prefs: []
  type: TYPE_NORMAL
- en: 'Its usage as a queue is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the items are followed by an `IndexError` since there are only
    two items and we are trying to get three.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage as a stack is almost identical, but we have to use `pop` instead
    of `popleft` (or `appendleft` instead of `append`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very useful feature is that `deque` can be used as a circular queue
    with the `maxlen` parameter. By using this, it can be used to keep the last `n`
    status messages or something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you require a queue or stack class within a single-threaded application,
    `deque` is a very convenient option. If you require the object to be synchronized
    for multithreading operations, then the `queue.Queue` class would be better suited.
    Internally, it wraps `deque`, but it's a thread-safe alternative. In the same
    category, there is also an `asyncio.Queue` for asynchronous operations and `multiprocessing.Queue`
    for multiprocessing operations. Examples of `asyncio` and multiprocessing can
    be found in [Chapter 7](ch07.html "Chapter 7. Async IO – Multithreading without
    Threads"), *Async IO – Multithreading without Threads* and [Chapter 13](ch13.html
    "Chapter 13. Multiprocessing – When a Single CPU Core Is Not Enough"), *Multiprocessing
    – When a Single CPU Core Is Not Enough* respectively.
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict – dictionary with a default value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `defaultdict` is by far my favorite object in the collections package. I
    still remember writing my own versions of it before it was added to the core.
    While it's a fairly simple object, it is extremely useful for all sorts of design
    patterns. Instead of having to check for the existence of a key and adding a value
    every time, you can just declare the default from the beginning, and there is
    no need to worry about the rest.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say we are building a very basic graph structure from a list
    of connected nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our list of connected nodes (one way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s put this graph into a normal dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Some variations are possible, of course, using `setdefault` for example. But
    they remain more complex than they need to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The truly Pythonic version uses `defaultdict` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Isn''t that a beautiful bit of code? The `defaultdict` can actually be seen
    as the precursor of the `counter` object. It''s not as fancy and doesn''t have
    all the bells and whistles that `counter` has, but it does the job in many cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The default value for `defaultdict` needs to be a callable object. In the previous
    cases, these were `int` and `list`, but you can easily define your own functions
    to use as a default value. That's what the following example uses, although I
    won't recommend production usage since it lacks a bit of readability. I do believe,
    however, that it is a beautiful example of the power of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we create a `tree` in a single line of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Brilliant, isn''t it? Here''s how we can actually use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing is that you can make it go as deep as you'd like. Because of
    the `defaultdict` base, it generates itself recursively.
  prefs: []
  type: TYPE_NORMAL
- en: namedtuple – tuples with field names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `namedtuple` object is exactly what the name implies—a tuple with a name.
    It has a few useful use cases, though I must admit that I haven''t found too many
    in the wild, except for some Python modules such as inspect and `urllib.parse`.
    Points in 2D or 3D space are a nice example of where it is definitely useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Not too much can be said about `namedtuple`; it does what you would expect,
    and the greatest advantage is that the properties can be executed both by name
    and by index, which makes tuple unpacking quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: enum – a group of constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `enum` package is quite similar to `namedtuple` but has a completely different
    goal and interface. The basic `enum` object makes it really easy to have constants
    in your modules while still avoiding magic numbers. This is a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A few of the handy features of the `enum` package are that the objects are iterable,
    accessible through both numeric and textual representation of the values, and,
    with proper inheritance, even comparable to other classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the usage of a basic API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There is more though. One of the lesser known possibilities from the `enum`
    package is that you can make value comparisons work through inheritance of specific
    types, and this works for every type—not just integers but (your own) custom types
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the regular `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is `enum` with `str` inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: OrderedDict – a dictionary where the insertion order matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OrderdDict` is a `dict` that keeps track of the order in which the items were
    inserted. Whereas a normal `dict` will return your keys in the order of hash,
    `OrderedDict` will return your keys by the order of insertion. So, it''s not ordered
    by key or value, but that is easily possible too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: While you can probably guess how this works, the internals might surprise you
    a little. I know I was expecting a different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `OrderedDict` uses a normal `dict` for key/value storage, and in
    addition to that, it uses a doubly linked list to keep track of the next/previous
    items. To keep track of the reverse relation (from the doubly linked list back
    to the keys), there is an extra `dict` stored internally.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, `OrderedDict` can be a very handy tool for keeping your `dict` sorted,
    but it does come at a cost. The system is structured in such a way that `set`
    and `get` are really fast `O(1)`, but the object is still a lot heavier (double
    or more memory usage) when compared to a regular `dict`. In many cases, the memory
    usage of the objects inside will outweigh the memory usage of the `dict` itself,
    of course, but this is something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: heapq – the ordered list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `heapq` module is a great little module that makes it very easy to create
    a priority queue in Python. A structure that will always make the smallest (or
    largest, depending on the implementation) item available with minimum effort.
    The API is quite simple, and one of the best examples of its usage can be seen
    in the `OrderedDict` object. You probably don't want to use `heapq` directly,
    but understanding the inner workings is important in order to analyze how classes
    such as `OrderedDict` work.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking for a structure to keep your list always sorted, try the
    `bisect` module instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic usage is quite simple though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing to note here—something that you have probably already understood
    from the preceding example—is that the `heapq` module does not create a special
    object. It is simply a bunch of methods for treating a regular list as a `heap`.
    That doesn''t make it less useful, but it is something to take into consideration.
    You may also wonder why the `heap` isn''t sorted. Actually, it is sorted but not
    the way you expect it to be. If you view the `heap` as a tree, it becomes much
    more obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The smallest number is always at the top and the biggest numbers are always
    at the bottom of the tree. Because of that, it's really easy to find the smallest
    number, but finding the largest is not so easy. To get the sorted version of the
    heap, we simply need to keep removing the top of the tree until all items are
    gone.
  prefs: []
  type: TYPE_NORMAL
- en: bisect – the sorted list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the `heapq` module in the previous paragraph, which makes it really
    simple to always get the smallest number from a list, and therefore makes it easy
    to sort a list of objects. While the `heapq` module appends items to form a tree-like
    structure, the `bisect` module inserts items in such a way that they stay sorted.
    A big difference is that adding/removing items with the `heapq` module is very
    light whereas finding items is really light with the `bisect` module. If your
    primary purpose is searching, then `bisect` should be your choice.
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with `heapq`, `bisect` does not really create a special data
    structure. It just works on a standard `list` and expects that `list` to always
    be sorted. It is important to understand the performance implications of this;
    simply adding items to the list using the `bisect` algorithm can be very slow
    because an insert on a list takes `O(n)`. Effectively, creating a sorted list
    using bisect takes `O(n*n)`, which is quite slow, especially because creating
    the same sorted list using `heapq` or sorted takes `O(n * log(n))` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `log(n)` refers to the base 2 logarithm function. To calculate this value,
    the `math.log2()` function can be used. This results in an increase of 1 every
    time the number doubles in size. For `n=2`, the value of `log(n)` is `1`, and
    consequently for `n=4` and `n=8`, the log values are `2` and `3`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a 32-bit number, which is `2**32 = 4294967296`, has a log of
    `32`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a sorted structure and you only need to add a single item, then
    the `bisect` algorithm can be used for insertion. Otherwise, it's generally faster
    to simply append the items and call a `.sort()` afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, we have these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For a small number of items, the difference is negligible, but it quickly grows
    to a point where the difference will be large. For `n=4`, the difference is just
    between `4 * 1 + 8 = 12` and `1 + 2 + 3 + 4 = 10` making the bisect solution faster.
    But if we were to insert 1,000 items, it would be `1000 + 1000 * log(1000) = 10966`
    versus `1 + 2 + … 1000 = 1000 * (1000 + 1) / 2 = 500500`. So, be very careful
    while inserting many items.
  prefs: []
  type: TYPE_NORMAL
- en: Searching within the list is very fast though; because it is sorted, we can
    use a very simple binary search algorithm. For example, what if we want to check
    whether a few numbers exist within the list?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `bisect_left` function finds the position at which the number
    is supposed to be. This is actually what the `insort` function does as well; it
    inserts the number at the correct position by searching for the location of the
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how is this different from a regular value in `sorted_list`? The biggest
    difference is that `bisect` does a binary search internally, which means that
    it starts in the middle and jumps left or right depending on whether the value
    is bigger or smaller than the value. To illustrate, we will search for `4` in
    a list of numbers from `0` to `14`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after only four steps (actually three; the fourth is just for
    illustration), we have found the number we searched for. Depending on the number
    (`7`, for example), it may go faster, but it will never take more than `O(log(n))`
    steps to find a number.
  prefs: []
  type: TYPE_NORMAL
- en: With a regular list, a search would simply walk through all items until it finds
    the desired item. If you're lucky, it could be the first number you encounter,
    but if you're unlucky, it could be the last item. In the case of 1,000 items,
    that would be the difference between 1,000 steps and `log(1000) = 10` steps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has quite a few very useful collections built in. Since more and more
    collections are added regularly, the best thing to do is simply keep track of
    the collections manual. And do you ever wonder how or why any of the structures
    works? Just look at the source here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hg.python.org/cpython/file/default/Lib/collections/__init__.py](https://hg.python.org/cpython/file/default/Lib/collections/__init__.py)'
  prefs: []
  type: TYPE_NORMAL
- en: After finishing this chapter, you should be aware of both the core collections
    and the most important collections from the collections module, but more importantly
    the performance characteristics of these collections in several scenarios. Selecting
    the correct data structure within your applications is by far the most important
    performance factor that your code will ever experience, making this essential
    knowledge for any programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will continue with functional programming which covers `lambda` functions,
    `list` comprehensions, `dict` comprehensions, `set` comprehensions and an array
    of related topics. This includes some background information on the mathematics
    involved which could be interesting but can safely be skipped.
  prefs: []
  type: TYPE_NORMAL
