- en: Chapter 3. Containers and Collections – Storing Data the Right Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。容器和集合-正确存储数据
- en: Python comes bundled with several very useful collections, a few of which are
    basic Python collection data types. The rest are advanced combinations of these
    types. In this chapter, we will explain some of these collections, how to use
    them, and the pros and cons of each of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python捆绑了几个非常有用的集合，其中一些是基本的Python集合数据类型。其余的是这些类型的高级组合。在本章中，我们将解释其中一些集合的使用方法，以及它们各自的优缺点。
- en: Before we can properly discuss data structures and the related performance,
    a basic understanding of time complexity (and specifically the big O notation)
    is required. No need to worry! The concept is really simple, but without it, we
    cannot easily explain the performance characteristics of operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正式讨论数据结构和相关性能之前，需要对时间复杂度（特别是大O符号）有基本的了解。不用担心！这个概念非常简单，但没有它，我们无法轻松地解释操作的性能特征。
- en: 'Once the big O notation is clear, we will discuss the basic data structures:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦大O符号清晰，我们将讨论基本数据结构：
- en: '`list`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`'
- en: '`dict`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`'
- en: '`set`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`'
- en: '`tuple`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple`'
- en: 'Building on the basic data structures, we will continue with more advanced
    collections, such as the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本数据结构的基础上，我们将继续介绍更高级的集合，例如以下内容：
- en: 'Dictionary-like types:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似字典的类型：
- en: '`ChainMap`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`'
- en: '`Counter`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`'
- en: '`Defaultdict`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Defaultdict`'
- en: '`OrderedDict`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`'
- en: 'List types:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表类型：
- en: '`Deque`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deque`'
- en: '`Heapq`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Heapq`'
- en: 'Tuple types:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组类型：
- en: '`NamedTuple`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamedTuple`'
- en: 'Other types:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型：
- en: '`Enum`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enum`'
- en: Time complexity – the big O notation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间复杂度-大O符号
- en: Before we can begin with this chapter, there is a simple notation that you need
    to understand. This chapter heavily uses the big O notation to indicate the time
    complexity for an operation. Feel free to skip this paragraph if you are already
    familiar with this notation. While this notation sounds really complicated, the
    concept is actually quite simple.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，您需要了解一个简单的符号。本章大量使用大O符号来指示操作的时间复杂度。如果您已经熟悉这个符号，可以跳过这一段。虽然这个符号听起来很复杂，但实际概念非常简单。
- en: When we say that a function takes `O(1)` time, it means that it generally only
    takes `1` step to execute. Similarly, a function with `O(n)` would take `n` steps
    to execute, where `n` is generally the size of the object. This time complexity
    is just a basic indication of what to expect when executing the code, as it is
    generally what matters most.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个函数需要`O(1)`的时间时，这意味着通常只需要`1`步来执行。同样，一个具有`O(n)`的函数将需要`n`步来执行，其中`n`通常是对象的大小。这种时间复杂度只是对执行代码时可以预期的基本指示，因为这通常是最重要的。
- en: The purpose of this system is to indicate the approximate performance of an
    operation; this is separate from code speed but it is still relevant. A piece
    of code that executes a single step `1000` times faster but needs `O(2**n)` steps
    to execute will still be slower than another version of it that takes only `O(n)`
    steps for a value of n equal to `10` or more. This is because `2**n` for `n=10`
    is `2**10=1024`, that is, 1,024 steps to execute the same code. This makes choosing
    the right algorithm very important. Even though `C` code is generally faster than
    Python, if it uses the wrong algorithm, it won't help at all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的目的是指示操作的大致性能；这与代码速度无关，但仍然相关。执行单个步骤的代码`1000`次更快，但需要执行`O(2**n)`步骤的代码仍然比另一个版本慢，因为对于n等于`10`或更高的值，它只需要`O(n)`步骤。这是因为`n=10`时`2**n`为`2**10=1024`，也就是说，执行相同代码需要1,024步。这使得选择正确的算法非常重要。即使`C`代码通常比Python快，如果使用错误的算法，也毫无帮助。
- en: 'For example, suppose you have a list of `1000` items and you walk through them.
    This will take `O(n)` time because there are `n=1000` items. Checking whether
    or not an item exists in the list takes `O(n)`, so that''s 1,000 steps. Doing
    this 100 times will take you `100*O(n) = 100 * 1000 = 100,000` steps. When you
    compare this to a `dict`, where checking whether the item exists or not takes
    `only O(1)` time the difference is huge. With a `dict`, it would be `100*O(1)
    = 100 * 1 = 100` steps. So, using a `dict` instead of a `list` will be roughly
    1,000 times faster for an object with 1,000 items:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个包含`1000`个项目的列表，并且您遍历它们。这将花费`O(n)`的时间，因为有`n=1000`个项目。检查项目是否存在于列表中需要`O(n)`的时间，因此需要1,000步。这样做100次将花费`100*O(n)
    = 100 * 1000 = 100,000`步。当您将其与`dict`进行比较时，检查项目是否存在只需要`O(1)`的时间，差异是巨大的。使用`dict`，将是`100*O(1)
    = 100 * 1 = 100`步。因此，对于包含1000个项目的对象，使用`dict`而不是`list`将大约快1,000倍：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To illustrate `O(1)`, `O(n)`, and `O(n**2)` functions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`O(1)`，`O(n)`和`O(n**2)`函数：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It should be noted that the big O in this chapter is about the average case
    and not the worst case. In some cases, they can be much worse, but those are rare
    enough to be ignored for the general case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，本章中的大O是关于平均情况，而不是最坏情况。在某些情况下，它们可能更糟，但这些情况很少，可以忽略不计。
- en: Core collections
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心集合
- en: Before we can look at the more advanced combined collections later in this chapter,
    you need to understand the workings of the core Python collections. This is not
    just about the usage, however; it is also about the time complexities involved,
    which can strongly affect how your application will behave as it grows. If you
    are well versed with the time complexities of these objects and know the possibilities
    of Python 3's tuple packing and unpacking by heart, then feel free to jump to
    the *Advanced collections* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后讨论更高级的组合集合之前，您需要了解核心Python集合的工作原理。这不仅仅是关于使用，还涉及到时间复杂度，这会对应用程序随着增长而产生强烈影响。如果您熟悉这些对象的时间复杂度，并且熟记Python
    3的元组打包和解包的可能性，那么可以直接跳到*高级集合*部分。
- en: list – a mutable list of items
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: list - 一个可变的项目列表
- en: The `list` is most likely the container structure that you've used most in Python.
    It is simple in its usage, and for most cases, it exhibits great performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`很可能是您在Python中最常用的容器结构。它的使用简单，对于大多数情况，性能很好。'
- en: 'While you may already be well versed with the usage of list, you might not
    be aware of the time complexities of the `list` object. Luckily, many of the time
    complexities of `list` are very low; `append`, `get`, `set`, and `len` all take
    `O(1)` time—the best possible. However, you might not be aware of the fact that
    `remove` and `insert` have `O(n)` time complexity. So, to delete a single item
    out of 1,000 items, Python will have to walk-through 1,000 items. Internally,
    the `remove` and `insert` operations execute something along these lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能已经熟悉了列表的使用，但你可能不知道`list`对象的时间复杂度。幸运的是，`list`的许多时间复杂度非常低；`append`，`get`，`set`和`len`都需要`O(1)`的时间-这是最好的可能性。但是，你可能不知道`remove`和`insert`的时间复杂度是`O(n)`。因此，要从1000个项目中删除一个项目，Python将不得不遍历1000个项目。在内部，`remove`和`insert`操作执行类似于这样的操作：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To remove or insert a single item from/into the list, Python needs to copy
    the entire list, which is especially heavy with larger lists. When executing this
    only once, it is of course not all that bad. But when executing a large number
    of deletions, a `filter` or `list` comprehension is a much faster solution because,
    if properly structured, it needs to copy the list only once. For example, suppose
    we wish to remove a specific set of numbers from the list. We have quite a few
    options for this. The first is a solution using `remove`, followed by a list comprehension,
    and then comes a `filter` statement. [Chapter 4](ch04.html "Chapter 4. Functional
    Programming – Readability Versus Brevity"), *Functional Programming – Readability
    Versus Brevity*, will explain `list` comprehensions and the `filter` statement
    in more detail. But first, let''s check out the example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中删除或插入单个项目，Python需要复制整个列表，这在列表较大时特别耗费资源。当执行一次时，当然不是那么糟糕。但是当执行大量删除时，`filter`或`list`推导是一个更快的解决方案，因为如果结构良好，它只需要复制列表一次。例如，假设我们希望从列表中删除一组特定的数字。我们有很多选项。第一个是使用`remove`，然后是列表推导，然后是`filter`语句。[第4章](ch04.html
    "第4章。功能编程-可读性与简洁性"), *功能编程-可读性与简洁性*，将更详细地解释`list`推导和`filter`语句。但首先，让我们看看这个例子：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The latter two are much faster for large lists of items. This is because the
    operations are much faster. To compare using `n=len(items)` and `m=len(primes)`,
    the first takes `O(m*n)=5*10=50` operations, whereas the latter two take `O(n*1)=10*1=10`
    operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 后两种对于大量项目的列表要快得多。这是因为操作要快得多。比较使用`n=len(items)`和`m=len(primes)`，第一个需要`O(m*n)=5*10=50`次操作，而后两个需要`O(n*1)=10*1=10`次操作。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first method is actually slightly better than that since `n` decreases during
    the loop. So, it's effectively `10+9+8+7+6=40`, but this is an effect that is
    negligible enough to ignore. In the case of `n=1000`, that would be the difference
    between `1000+999+998+997+996=4990` and `5*1000=5000`, which is negligible in
    most cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法实际上比这更好一些，因为`n`在循环过程中减少。所以，实际上是`10+9+8+7+6=40`，但这是一个可以忽略的效果。在`n=1000`的情况下，这将是`1000+999+998+997+996=4990`和`5*1000=5000`之间的差异，在大多数情况下是可以忽略的。
- en: Of course, `min`, `max`, and `in` all take `O(n)` as well, but that is expected
    for a structure that is not optimized for these types of lookups.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`min`，`max`和`in`都需要`O(n)`，但这对于一个不是为这些类型的查找进行优化的结构来说是可以预料的。
- en: 'They can be implemented like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以这样实现：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With these examples, it's obvious as well that the `in` operator could work
    `O(1)` if you're lucky, but we count it as `O(n)` because it might not exist,
    in which case all values need to be checked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些例子，很明显`in`运算符如果你幸运的话可以工作`O(1)`，但我们将其视为`O(n)`，因为它可能不存在，如果不存在，那么所有的值都需要被检查。
- en: dict – unsorted but a fast map of items
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dict-无序但快速的项目映射
- en: The `dict` has to be at least among the top three container structures you use
    in Python. It's fast, simple to use, and very effective. The average time complexity
    is exactly as you would expect—`O(1)` for `get`, `set`, and `del`—but there are
    cases where this is not true. The way a `dict` works is by converting the key
    to a hash using the `hash` function (calls the `__hash__` function of an object)
    and storing it in a hash table. There are two problems with hash tables, however.
    The first and the most obvious is that the items will be sorted by hash, which
    appears at random in most cases. The second problem with hash tables is that they
    can have hash collisions, and the result of a hash collision is that in the worst
    case, all the former operations can take `O(n)` instead. Hash collisions are not
    all that likely to occur, but they can occur, and if a large `dict` performs subpar,
    that's the place to look.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`必须至少是你在Python中使用的前三种容器结构之一。它快速，易于使用，非常有效。平均时间复杂度正如你所期望的那样-`O(1)`对于`get`，`set`和`del`-但也有一些例外。`dict`的工作方式是通过使用`hash`函数（调用对象的`__hash__`函数）将键转换为哈希并将其存储在哈希表中。然而，哈希表有两个问题。第一个和最明显的问题是，项目将按哈希排序，这在大多数情况下是随机的。哈希表的第二个问题是它们可能会发生哈希冲突，哈希冲突的结果是在最坏的情况下，所有先前的操作可能需要`O(n)`。哈希冲突并不太可能发生，但它们可能发生，如果一个大的`dict`表现不佳，那就是需要查看的地方。'
- en: 'Let''s see how this actually works in practice. For the sake of this example,
    I will use the simplest hashing algorithm I can think of, which is the most significant
    digit of a number. So, for the case of `12345`, it will return `1`, and for `56789`,
    it will return `5`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是如何工作的。为了举例说明，我将使用我能想到的最简单的哈希算法，即数字的最高位。所以，对于`12345`，它将返回`1`，对于`56789`，它将返回`5`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we will emulate a `dict` using a `list` of lists with this hashing method.
    We know that our hashing method can only return numbers from `0` to `9`, so we
    need only 10 buckets in our list. Now we will add a few values and show how the
    spam in eggs might work:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用这种哈希方法使用一个列表的列表来模拟一个`dict`。我们知道我们的哈希方法只能返回`0`到`9`之间的数字，所以我们在列表中只需要10个桶。现在我们将添加一些值，并展示spam
    in eggs可能如何工作：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is obviously not identical to the `dict` implementation, but it is
    actually quite similar internally. Because we can just get item `1` for a value
    of `123` by simple indexing, we have only `O(1)` lookup costs in the general case.
    However, since both keys, `123` and `101`, are within the `1` bucket, the runtime
    can actually increase to `O(n)` in the worst case where all keys have the same
    hash. That is what we call a hash collision.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To debug hash collisions, you can use the `hash()` function paired with the
    counter collection, discussed in the *counter – keeping track of the most occurring
    elements* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the hash collision performance problem, there is another behavior
    that might surprise you. When deleting items from a dictionary, it won't actually
    resize the dictionary in memory yet. The result is that both copying and iterating
    the entire dictionary take `O(m)` time (where m is the maximum size of the dictionary);
    `n`, the current number of items is not used. So, if you add 1,000 items to a
    `dict` and remove 999, iterating and copying will still take 1,000 steps. The
    only way to work around this issue is by recreating the dictionary, which is something
    that both the `copy` and `insert` operations will perform internally. Note that
    recreation during an `insert` operation is not guaranteed and depends on the number
    of free slots available internally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: set – like a dict without values
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `set` is a structure that uses the hash method to get a unique collection
    of values. Internally, it is very similar to a `dict`, with the same hash collision
    problem, but there are a few handy features of set that need to be shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first few are pretty much as expected. At the operators, it gets interesting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Output | Explanation |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `spam` | `amps` | All unique items. A `set` doesn''t allow for duplicates.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `eggs` | `egs` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `spam & eggs` | `s` | Every item in both. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `spam &#124; eggs` | `aegmps` | Every item in either or both. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `spam ^ eggs` | `aegmp` | Every item in either but not in both. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `spam - eggs` | `amp` | Every item in the first but not the latter. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `eggs - spam` | `eg` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `spam > eggs` | `False` | True if every item in the latter is in the first.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `eggs > spam` | `False` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `spam > sp` | `True` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `spam < sp` | `False` | True if every item in the first is contained in the
    latter. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: 'One useful example for `set` operations is calculating the differences between
    two objects. For example, let''s assume we have two lists:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`current_users`: The current users in a group'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new_users`: The new list of users in a group'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In permission systems, this is a very common scenario—mass adding and/or removing
    users from a group. Within many permission databases, it''s not easily possible
    to set the entire list at once, so you need a list to insert and a list to delete.
    This is where `set` comes in really handy:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have lists of all users who were added, removed, and unchanged. Note
    that `sorted` is only needed for consistent output, since a `set`, similar to
    a `dict`, has no predefined sort order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: tuple – the immutable list
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `tuple` is an object that you use very often without even noticing it. When
    you look at it initially, it seems like a useless data structure. It's like a
    list that you can't modify, so why not just use a `list`? There are a few cases
    where a `tuple` offers some really useful functionalities that a `list` does not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, they are hashaable. This means that you can use a `tuple` as a key
    in a `dict`, which is something a `list` can''t do:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, it can actually be more than simple numbers. As long as all elements
    of a `tuple` are hashable, it will work. This means that you can use nested tuples,
    strings, numbers, and anything else for which the `hash()` function returns a
    consistent result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can make these as complex as you need. As long as all the parts are hashable,
    it will function as expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, even more useful is the fact that tuples also support tuple packing
    and unpacking:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In addition to regular packing and unpacking, from Python 3 onwards, we can
    actually pack and unpack objects with a variable number of items:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This very method can be applied in many cases, even for function arguments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And its equally useful to return multiple arguments from a function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Advanced collections
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following collections are mostly just extensions of base collections, some
    of them fairly simple and others a bit more advanced. For all of them though,
    it is important to know the characteristics of the underlying structures. Without
    understanding them, it will be difficult to comprehend the characteristics of
    these collections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: There are a few collections that are implemented in native C code for performance
    reasons, but all of them can easily be implemented in pure Python as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap – the list of dictionaries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in Python 3.3, `ChainMap` allows you to combine multiple mappings
    (dictionaries for example) into one. This is especially useful when combining
    multiple contexts. For example, when looking for a variable in your current scope,
    by default, Python will search in `locals()`, `globals()`, and lastly `builtins`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would do something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This works, but it''s ugly to say the least. We can make it prettier, of course:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A lot better! Moreover, this can actually be considered a nice solution. But
    since Python 3.3, it''s even easier. Now we can simply use the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `ChainMap` collection is very useful for command-line applications. The
    most important configuration happens through command-line arguments, followed
    by directory local config files, followed by global config files, followed by
    defaults:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that accessing specific mappings is still possible:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: counter – keeping track of the most occurring elements
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `counter` is a class for keeping track of the number of occurrences of
    an element. Its basic usage is as you would expect:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, `counter` can do more than simply return the count. It also has a
    few very useful and fast (it uses `heapq`) methods for getting the most common
    elements. Even with a million elements added to the counter, it still executes
    within a second:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But wait, there''s more! In addition to getting the most frequent elements,
    it''s also possible to add, subtract, intersect, and "union" counters very similarly
    to the `set` operations that we saw earlier. So what is the difference between
    adding two counters and making a union of them? As you would expect, they are
    similar, but there is a small difference. Let''s look at its workings:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two are obvious. The `eggs` string is just a sequence of characters
    with two "`g`"s, one "`s`", and one "`e`", and spam is almost the same but with
    different letters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The result of `spam & eggs` (and the reverse) is also quite predictable. The
    only letter that's shared between spam and eggs is `s`, so that's the result.
    When it comes to counts, it simply does a `min(element_a, element_b)` per shared
    element from both and gets the lowest.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: When subtracting the letters `s`, `p`, `a`, and `m` from eggs, you are left
    with `e` and `g`. Similarly, when removing `e`, `g`, and `s` from spam, you are
    left with `p`, `a`, and `m`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Now, adding is as you would expect—just an element-by-element addition of both
    counters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: So how is the union (OR) any different? It gets the `max(element_a, element_b)`
    per element in either of the counters instead of adding them; regardless as is
    the case with the addition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, as is demonstrated in the preceding code, the elements method returns
    an expanded list of all elements repeated by the count.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Counter` object will automatically remove elements that are zero or less
    during the execution of mathematical operations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: deque – the double ended queue
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `deque` (short for Double Ended Queue) object is one of the oldest collections.
    It was introduced in Python 2.4, so it has been available for over 10 years by
    now. Generally, this object will be too low-level for most purposes these days,
    as many operations that would otherwise use it have well-supported libraries available,
    but that doesn't make it less useful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `deque` is created as a doubly linked list, which means that every
    item points to the next and the previous item. Since `deque` is double-ended,
    the list itself points to both the first and the last element. This makes both
    adding and removing items from either the beginning or the end a very light `O(1)`
    operation, since only the pointer to the beginning/end of the list needs to change
    and a pointer needs to be added to the first/last item, depending on whether an
    item is added at the beginning or the end.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: For simple stack/queue purposes, it seems wasteful to use a double-ended queue,
    but the performance is good enough for us not to care about the overhead incurred.
    The `deque` class is fully implemented in C (with CPython).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Its usage as a queue is very straightforward:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, the items are followed by an `IndexError` since there are only
    two items and we are trying to get three.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage as a stack is almost identical, but we have to use `pop` instead
    of `popleft` (or `appendleft` instead of `append`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another very useful feature is that `deque` can be used as a circular queue
    with the `maxlen` parameter. By using this, it can be used to keep the last `n`
    status messages or something similar:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever you require a queue or stack class within a single-threaded application,
    `deque` is a very convenient option. If you require the object to be synchronized
    for multithreading operations, then the `queue.Queue` class would be better suited.
    Internally, it wraps `deque`, but it's a thread-safe alternative. In the same
    category, there is also an `asyncio.Queue` for asynchronous operations and `multiprocessing.Queue`
    for multiprocessing operations. Examples of `asyncio` and multiprocessing can
    be found in [Chapter 7](ch07.html "Chapter 7. Async IO – Multithreading without
    Threads"), *Async IO – Multithreading without Threads* and [Chapter 13](ch13.html
    "Chapter 13. Multiprocessing – When a Single CPU Core Is Not Enough"), *Multiprocessing
    – When a Single CPU Core Is Not Enough* respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict – dictionary with a default value
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `defaultdict` is by far my favorite object in the collections package. I
    still remember writing my own versions of it before it was added to the core.
    While it's a fairly simple object, it is extremely useful for all sorts of design
    patterns. Instead of having to check for the existence of a key and adding a value
    every time, you can just declare the default from the beginning, and there is
    no need to worry about the rest.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say we are building a very basic graph structure from a list
    of connected nodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our list of connected nodes (one way):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s put this graph into a normal dictionary:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Some variations are possible, of course, using `setdefault` for example. But
    they remain more complex than they need to be.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The truly Pythonic version uses `defaultdict` instead:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Isn''t that a beautiful bit of code? The `defaultdict` can actually be seen
    as the precursor of the `counter` object. It''s not as fancy and doesn''t have
    all the bells and whistles that `counter` has, but it does the job in many cases:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The default value for `defaultdict` needs to be a callable object. In the previous
    cases, these were `int` and `list`, but you can easily define your own functions
    to use as a default value. That's what the following example uses, although I
    won't recommend production usage since it lacks a bit of readability. I do believe,
    however, that it is a beautiful example of the power of Python.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we create a `tree` in a single line of Python:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Brilliant, isn''t it? Here''s how we can actually use it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The nice thing is that you can make it go as deep as you'd like. Because of
    the `defaultdict` base, it generates itself recursively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: namedtuple – tuples with field names
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `namedtuple` object is exactly what the name implies—a tuple with a name.
    It has a few useful use cases, though I must admit that I haven''t found too many
    in the wild, except for some Python modules such as inspect and `urllib.parse`.
    Points in 2D or 3D space are a nice example of where it is definitely useful:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Not too much can be said about `namedtuple`; it does what you would expect,
    and the greatest advantage is that the properties can be executed both by name
    and by index, which makes tuple unpacking quite easy:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: enum – a group of constants
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `enum` package is quite similar to `namedtuple` but has a completely different
    goal and interface. The basic `enum` object makes it really easy to have constants
    in your modules while still avoiding magic numbers. This is a basic example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A few of the handy features of the `enum` package are that the objects are iterable,
    accessible through both numeric and textual representation of the values, and,
    with proper inheritance, even comparable to other classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the usage of a basic API:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is more though. One of the lesser known possibilities from the `enum`
    package is that you can make value comparisons work through inheritance of specific
    types, and this works for every type—not just integers but (your own) custom types
    as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the regular `enum`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is `enum` with `str` inheritance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: OrderedDict – a dictionary where the insertion order matters
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OrderdDict` is a `dict` that keeps track of the order in which the items were
    inserted. Whereas a normal `dict` will return your keys in the order of hash,
    `OrderedDict` will return your keys by the order of insertion. So, it''s not ordered
    by key or value, but that is easily possible too:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While you can probably guess how this works, the internals might surprise you
    a little. I know I was expecting a different implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `OrderedDict` uses a normal `dict` for key/value storage, and in
    addition to that, it uses a doubly linked list to keep track of the next/previous
    items. To keep track of the reverse relation (from the doubly linked list back
    to the keys), there is an extra `dict` stored internally.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, `OrderedDict` can be a very handy tool for keeping your `dict` sorted,
    but it does come at a cost. The system is structured in such a way that `set`
    and `get` are really fast `O(1)`, but the object is still a lot heavier (double
    or more memory usage) when compared to a regular `dict`. In many cases, the memory
    usage of the objects inside will outweigh the memory usage of the `dict` itself,
    of course, but this is something to keep in mind.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: heapq – the ordered list
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `heapq` module is a great little module that makes it very easy to create
    a priority queue in Python. A structure that will always make the smallest (or
    largest, depending on the implementation) item available with minimum effort.
    The API is quite simple, and one of the best examples of its usage can be seen
    in the `OrderedDict` object. You probably don't want to use `heapq` directly,
    but understanding the inner workings is important in order to analyze how classes
    such as `OrderedDict` work.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking for a structure to keep your list always sorted, try the
    `bisect` module instead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic usage is quite simple though:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'One important thing to note here—something that you have probably already understood
    from the preceding example—is that the `heapq` module does not create a special
    object. It is simply a bunch of methods for treating a regular list as a `heap`.
    That doesn''t make it less useful, but it is something to take into consideration.
    You may also wonder why the `heap` isn''t sorted. Actually, it is sorted but not
    the way you expect it to be. If you view the `heap` as a tree, it becomes much
    more obvious:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The smallest number is always at the top and the biggest numbers are always
    at the bottom of the tree. Because of that, it's really easy to find the smallest
    number, but finding the largest is not so easy. To get the sorted version of the
    heap, we simply need to keep removing the top of the tree until all items are
    gone.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: bisect – the sorted list
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the `heapq` module in the previous paragraph, which makes it really
    simple to always get the smallest number from a list, and therefore makes it easy
    to sort a list of objects. While the `heapq` module appends items to form a tree-like
    structure, the `bisect` module inserts items in such a way that they stay sorted.
    A big difference is that adding/removing items with the `heapq` module is very
    light whereas finding items is really light with the `bisect` module. If your
    primary purpose is searching, then `bisect` should be your choice.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with `heapq`, `bisect` does not really create a special data
    structure. It just works on a standard `list` and expects that `list` to always
    be sorted. It is important to understand the performance implications of this;
    simply adding items to the list using the `bisect` algorithm can be very slow
    because an insert on a list takes `O(n)`. Effectively, creating a sorted list
    using bisect takes `O(n*n)`, which is quite slow, especially because creating
    the same sorted list using `heapq` or sorted takes `O(n * log(n))` instead.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `log(n)` refers to the base 2 logarithm function. To calculate this value,
    the `math.log2()` function can be used. This results in an increase of 1 every
    time the number doubles in size. For `n=2`, the value of `log(n)` is `1`, and
    consequently for `n=4` and `n=8`, the log values are `2` and `3`, respectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: This means that a 32-bit number, which is `2**32 = 4294967296`, has a log of
    `32`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: If you have a sorted structure and you only need to add a single item, then
    the `bisect` algorithm can be used for insertion. Otherwise, it's generally faster
    to simply append the items and call a `.sort()` afterwards.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, we have these lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For a small number of items, the difference is negligible, but it quickly grows
    to a point where the difference will be large. For `n=4`, the difference is just
    between `4 * 1 + 8 = 12` and `1 + 2 + 3 + 4 = 10` making the bisect solution faster.
    But if we were to insert 1,000 items, it would be `1000 + 1000 * log(1000) = 10966`
    versus `1 + 2 + … 1000 = 1000 * (1000 + 1) / 2 = 500500`. So, be very careful
    while inserting many items.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Searching within the list is very fast though; because it is sorted, we can
    use a very simple binary search algorithm. For example, what if we want to check
    whether a few numbers exist within the list?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the `bisect_left` function finds the position at which the number
    is supposed to be. This is actually what the `insort` function does as well; it
    inserts the number at the correct position by searching for the location of the
    number.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'So how is this different from a regular value in `sorted_list`? The biggest
    difference is that `bisect` does a binary search internally, which means that
    it starts in the middle and jumps left or right depending on whether the value
    is bigger or smaller than the value. To illustrate, we will search for `4` in
    a list of numbers from `0` to `14`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, after only four steps (actually three; the fourth is just for
    illustration), we have found the number we searched for. Depending on the number
    (`7`, for example), it may go faster, but it will never take more than `O(log(n))`
    steps to find a number.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: With a regular list, a search would simply walk through all items until it finds
    the desired item. If you're lucky, it could be the first number you encounter,
    but if you're unlucky, it could be the last item. In the case of 1,000 items,
    that would be the difference between 1,000 steps and `log(1000) = 10` steps.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has quite a few very useful collections built in. Since more and more
    collections are added regularly, the best thing to do is simply keep track of
    the collections manual. And do you ever wonder how or why any of the structures
    works? Just look at the source here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置了一些非常有用的集合。由于越来越多的集合定期添加，最好的做法就是简单地跟踪集合手册。你是否曾经想过任何结构是如何工作的，或者为什么会这样？只需在这里查看源代码：
- en: '[https://hg.python.org/cpython/file/default/Lib/collections/__init__.py](https://hg.python.org/cpython/file/default/Lib/collections/__init__.py)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hg.python.org/cpython/file/default/Lib/collections/__init__.py](https://hg.python.org/cpython/file/default/Lib/collections/__init__.py)'
- en: After finishing this chapter, you should be aware of both the core collections
    and the most important collections from the collections module, but more importantly
    the performance characteristics of these collections in several scenarios. Selecting
    the correct data structure within your applications is by far the most important
    performance factor that your code will ever experience, making this essential
    knowledge for any programmer.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该了解核心集合和集合模块中最重要的集合，更重要的是这些集合在几种情景下的性能特征。在应用程序中选择正确的数据结构是你的代码将经历的最重要的性能因素，这对于任何程序员来说都是必不可少的知识。
- en: Next, we will continue with functional programming which covers `lambda` functions,
    `list` comprehensions, `dict` comprehensions, `set` comprehensions and an array
    of related topics. This includes some background information on the mathematics
    involved which could be interesting but can safely be skipped.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论函数式编程，其中包括`lambda`函数、`list`推导、`dict`推导、`set`推导以及一系列相关主题。这包括一些涉及的数学背景信息，可能会很有趣，但可以安全地跳过。
