- en: Introducing Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The common problem faced by most developers is how to release the implemented
    code quickly and safely. The delivery process used traditionally is, however,
    a source of pitfalls and usually leads to the disappointment of both developers
    and clients. This chapter presents the idea of the Continuous Delivery approach
    and provides the context for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the traditional delivery process and its drawbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the idea of Continuous Delivery and the benefits it brings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing how different companies deliver their software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the automated deployment pipeline and its phases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classifying different types of tests and their place in the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointing out the prerequisites to the successful Continuous Delivery process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting tools that will be used throughout the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the complete system that will be built throughout the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Continuous Delivery?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most accurate definition of the Continuous Delivery is stated by Jez Humble
    and reads as follows: "Continuous Delivery is the ability to get changes of all
    types—including new features, configuration changes, bug fixes, and experiments—into
    production, or into the hands of users, safely and quickly in a sustainable way."
    That definition covers the key points.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand it better, let's imagine a scenario. You are responsible for the
    product, let's say, the email client application. Users come to you with a new
    requirement—they want to sort emails by size. You decide that the development
    will take around one week. When can the user expect to use the feature? Usually,
    after the development is done, you hand over the completed feature first to the
    QA team and then to the operations team, which takes additional time ranging from
    days to months. Therefore, even though the development took only one week, the
    user receives it in a couple of months! The Continuous Delivery approach addresses
    that issue by automating manual tasks so that the user could receive a new feature
    as soon as it's implemented.
  prefs: []
  type: TYPE_NORMAL
- en: To present better what to automate and how, let's start by describing the delivery
    process that is currently used for most software systems.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional delivery process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional delivery process, as the name suggests, has been in place for
    many years now and is implemented in most IT companies. Let's define how it works
    and comment on its shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the traditional delivery process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any delivery process begins with the requirements defined by a customer and
    ends up with the release on the production. The differences are in between. Traditionally,
    it looks as presented in the following release cycle diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/08f78945-6823-4b83-990b-109618b5dbbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The release cycle starts with the requirements provided by the **Product Owner**,
    who represents the **Customer** (stakeholders). Then there are three phases, during
    which the work is passed between different teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development**: Here, the developers (sometimes together with business analysts)
    work on the product. They often use Agile techniques (Scrum or Kanban) to increase
    the development velocity and to improve the communication with the client. Demo
    sessions are organized to obtain a customer''s quick feedback. All good development
    techniques (like test-driven development or extreme programming practices) are
    welcome. After the implementation is completed, the code is passed to the QA team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality Assurance**: This phase is usually called **User Acceptance Testing**
    (**UAT**) and it requires a code freeze on the trunk codebase, so that no new
    development would break the tests. The QA team performs a suite of **Integration
    Testing**, **Acceptance Testing**, and **Non-functional Testing** (performance,
    recovery, security, and so on). Any bug that is detected goes back to the development
    team, so developers usually also have their hands full of work. After the UAT
    phase is completed, the QA team approves the features that are planned for the
    next release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations**: The last phase, usually the shortest one, means passing the
    code to the **Operations** team, so that they can perform the release and monitor
    the production. If anything goes wrong, they contact developers to help with the
    production system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The length of the release cycle depends on the system and the organization,
    but it usually ranges from a week to a few months. The longest I''ve heard about
    was one year.The longest I worked with was quarterly-based and each part took
    as follows: development-1.5 months, UAT-1 month and 3 weeks, release (and strict
    production monitoring)-1 week.'
  prefs: []
  type: TYPE_NORMAL
- en: The traditional delivery process is widely used in the IT industry and it's
    probably not the first time you've read about such an approach. Nevertheless,
    it has a number of drawbacks. Let's look at them explicity to understand why we
    need to strive for something better.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcomings of the traditional delivery process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most significant shortcomings of the traditional delivery process include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slow delivery**: Here, the customer receives the product long after the requirements
    were specified. It results in the unsatisfactory time to market and delays of
    the customer''s feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long feedback cycle**: The feedback cycle is not only related to customers,
    but also to developers. Imagine that you accidentally created a bug and you learn
    about it during the UAT phase. How long does it take to fix something you worked
    on two months ago? Even minor bugs can consume weeks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of automation**: Rare releases don''t encourage the automation, which
    leads to unpredictable releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risky hotfixes**: Hotfixes can''t usually wait for the full UAT phase, so
    they tend to be tested differently (the UAT phase is shortened) or not tested
    at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress**: Unpredictable releases are stressful for the operations team. What''s
    more, the release cycle is usually tightly scheduled which imposes an additional
    stress on developers and testers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poor communication**: Work passed from one team to another represents the
    waterfall approach, in which people start to care only about their part, rather
    than the complete product. In case anything goes wrong, that usually leads to
    the blaming game instead of cooperation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared responsibility**: No team takes the responsibility for the product
    from A to Z. For developers: "done" means that requirements are implemented. For
    testers: "done" means that the code is tested. For operations: "done" means that
    the code is released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower job satisfaction**: Each phase is interesting for a different team,
    but other teams need to support the process. For example, the development phase
    is interesting for developers but, during two other phases, they still need to
    fix bugs and support the release, which usually is not interesting for them at
    all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These drawbacks represent just a tip of the iceberg of the challenges related
    to the traditional delivery process. You may already feel that there must be a
    better way to develop the software and this better way is, obviously, the Continuous
    Delivery approach.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “How long would it take your organization to deploy a change that involves just
    one single line of code? Do you do this on a repeatable, reliable basis?" These
    are the famous questions from Mary and Tom Poppendieck (authors of *Implementing
    Lean Software Development*), which have been quoted many times by Jez Humble and
    other authors. Actually, the answer to these questions is the only valid measurement
    of the health of your delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to deliver continuously, and not to spend a fortune on the army of
    operations teams working 24/7, we need automation. That is why, in short, Continuous
    Delivery is all about changing each phase of the traditional delivery process
    into a sequence of scripts, called the automated deployment pipeline or the Continuous
    Delivery pipeline. Then, if no manual steps are required, we can run the process
    after every code change and, therefore, deliver the product continuously to the
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous Delivery lets us get rid of the tedious release cycle and, therefore,
    brings the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast delivery**: Time to market is significantly reduced as customers can
    use the product as soon as the development is completed. Remember, the software
    delivers no revenue until it is in the hands of its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast feedback cycle**: Imagine you created a bug in the code, which goes
    into the production the same day. How much time does it take to fix something
    you worked on the same day? Probably not much. This, together with the quick rollback
    strategy, is the best way to keep the production stable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-risk releases**: If you release on a daily basis, then the process becomes
    repeatable and therefore much safer. As the saying goes, "If it hurts, do it more
    often."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible release options**: In case you need to release immediately, everything
    is already prepared, so there is no additional time/cost associated with the release
    decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needless to say, we could achieve all the benefits simply by eliminating all
    delivery phases and proceeding with the development directly on the production.
    It would, however, cause the quality to decline. Actually, the whole difficulty
    of introducing Continuous Delivery is the concern that the quality would decrease
    together with eliminating manual steps. In this book, we will show how to approach
    it in a safe manner and explain why, contrary to common beliefs, the products
    delivered continuously have fewer bugs and are better adjusted to the customer's
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Success stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My favorite story on Continuous Delivery was told by Rolf Russell at one of
    his talks. It goes as follows. In 2005, Yahoo acquired Flickr and it was a clash
    of two cultures in the developer's world. Flickr, by that time, was a company
    with the start-up approach in mind. Yahoo, on the contrary, was a huge corporation
    with strict rules and the safety-first attitude. Their release processes differed
    a lot. While Yahoo used the traditional delivery process, Flickr released many
    times a day. Every change implemented by developers went on the production the
    same day. They even had a footer at the bottom of their page showing the time
    of the last release and the avatars of the developers who did the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yahoo deployed rarely and each release brought a lot of changes well tested
    and prepared. Flickr worked in very small chunks, each feature was divided into
    small incremental parts and each part was deployed quickly to the production.
    The difference is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/10797d6c-4806-4dcf-b5f2-4f3cfdc41eae.png)'
  prefs: []
  type: TYPE_IMG
- en: You can imagine what happened when the developers from two companies met. Yahoo
    obviously treated Flickr's colleagues as junior irresponsible developers, "a bunch
    of software cowboys who don't know what they are doing." So, the first thing they
    wanted to change was to add a QA team and the UAT phase into Flickr's delivery
    process. Before they applied the change, however, Flickr's developers had only
    one wish. They asked to evaluate the most reliable products in the whole Yahoo
    company. What a surprise when it happened that of all the software in Yahoo, Flickr
    had the lowest downtime. The Yahoo team didn't understand it at first, but let
    Flickr stay with their current process anyway. After all, they were engineers,
    so the evaluation result was conclusive. Only after some time, they realized that
    the Continuous Delivery process can be beneficial for all products in Yahoo and
    they started to gradually introduce it everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important question of the story remains-how was it possible that Flickr
    was the most reliable system? Actually, the reason for that fact was what we already
    mentioned in the previous sections. A release is less risky if:'
  prefs: []
  type: TYPE_NORMAL
- en: The delta of code changes is small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process is repeatable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why, even though the release itself is a difficult activity, it is much
    safer when done frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The story of Yahoo and Flickr is only an example of many successful companies
    for which the Continuous Delivery process proved to be right. Some of them even
    proudly share details from their systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon**: In 2011, they announced reaching 11.6 seconds (on average) between
    deployments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook**: In 2013, they announced deployment of code changes twice a day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HubSpot**: In 2013, they announced deployment 300 times a day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atlassian**: In 2016, they published a survey stating that 65% of their customers
    practice continuous delivery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about the research on the Continuous Delivery process and
    individual case studies at [https://continuousdelivery.com/evidence-case-studies/](https://continuousdelivery.com/evidence-case-studies/).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the statistics get better every day. However, even without
    any numbers, just imagine a world in which every line of code you implement goes
    safely into the production. Clients can react quickly and adjust their requirements,
    developers are happy because they don't have to solve that many bugs, managers
    are satisfied because they always know what is the current state of work. After
    all, remember, the only true measure of progress is the released software.
  prefs: []
  type: TYPE_NORMAL
- en: The automated deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know what the Continuous Delivery process is and why we use it. In
    this section, we describe how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by emphasizing that each phase in the traditional delivery process
    is important. Otherwise, it would never have been created in the first place.
    No one wants to deliver software without testing it first! The role of the UAT
    phase is to detect bugs and to ensure that what developers created is what the
    customer wanted. The same applies to the operations team—the software must be
    configured, deployed to the production, and monitored. That''s out of the question.
    So, how do we automate the process so that we preserve all the phases? That is
    the role of the automated deployment pipeline, which consists of three stages
    as presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/afeccaf6-be79-485d-bba8-beb5f782b675.png)'
  prefs: []
  type: TYPE_IMG
- en: The automated deployment pipeline is a sequence of scripts that is executed
    after every code change committed to the repository. If the process is successful,
    it ends up with the deployment to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each step corresponds to a phase in the traditional delivery process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration**: This checks to make sure that the code written
    by different developers integrates together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated Acceptance Testing**: This replaces the manual QA phase and checks
    if the features implemented by developers meet the client''s requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration Management**: This replaces the manual operations phase-configures
    the environment and deploys the software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a deeper look at each phase to understand what is its responsibility
    and what steps it includes.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Continuous Integration phase provides the first feedback to developers.
    It checks out the code from the repository, compiles it, runs unit tests, and
    verifies the code quality. If any step fails, the pipeline execution is stopped
    and the first thing the developers should do is fix the Continuous Integration
    build. The essential aspect of the phase is time; it must be executed in a timely
    manner. For example, if this phase took an hour to complete then the developers
    would commit the code faster, which would result in the constantly failing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The Continuous Integration pipeline is usually the starting point. Setting it
    up is simple because everything is done within the development team and no agreement
    with the QA and operations teams is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automated acceptance testing phase is a suite of tests written together
    with the client (and QAs) that is supposed to replace the manual UAT stage. It
    acts as a quality gate to decide whether a product is ready for the release or
    not. If any of the acceptance tests fail, then the pipeline execution is stopped
    and no further steps are run. It prevents movement to the Configuration Management
    phase and therefore the release.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea of automating the acceptance phase is to build the quality into
    the product instead of verifying it later. In other words, when a developer completes
    the implementation, the software is delivered already together with acceptance
    tests which verify that the software is what the client wanted. That is a large
    shift in thinking about testing software. There is no longer a single person (or
    team) who approves the release, but everything depends on passing the acceptance
    test suite. That is why creating this phase is usually the most difficult part
    of the Continuous Delivery process. It requires a close cooperation with the client
    and creating tests at the beginning (not at the end) of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing automated acceptance tests is especially challenging in the case
    of legacy systems. We describe more on that topic in [Chapter 9](f45afa10-c8a5-4252-bc14-8bc8bbcda5c9.xhtml),
    *Advanced Continuous Delivery*.
  prefs: []
  type: TYPE_NORMAL
- en: There is usually a lot of confusion about the types of tests and their place
    in the Continuous Delivery process. It's also often unclear how to automate each
    type, what should be the coverage, and what should be the role of the QA team
    in the whole development process. Let's clarify it using the Agile testing matrix
    and the testing pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: The Agile testing matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Brian Marick, in a series of his blog posts, made a classification of software
    tests in a form of the so-called agile testing matrix. It places tests in two
    dimensions: business or technology facing and support programmers or critique
    the product. Let''s have a look at that classification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8f120904-9296-452a-a8dd-75dc8059ff6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s comment briefly on each type of test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceptance Testing (automated)**: These are tests that represent functional
    requirements seen from the business perspective. They are written in the form
    of stories or examples by clients and developers to agree on how the software
    should work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Testing (automated)**: These are tests that help developers to provide
    the high-quality software and minimize the number of bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploratory Testing (manual)**: This is the manual black-box testing, which
    tries to break or improve the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional Testing (automated)**: These are tests that represent system
    properties related to the performance, scalability, security, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This classification answers one of the most important questions about the Continuous
    Delivery process: what is the role of a QA in the process?'
  prefs: []
  type: TYPE_NORMAL
- en: Manual QAs perform the exploratory testing, so they play with the system, try
    to break it, ask questions, think about improvements. Automation QAs help with
    nonfunctional and acceptance testing, for example, they write code to support
    load testing. In general, QAs don't have their special place in the delivery process,
    but rather a role in the development team.
  prefs: []
  type: TYPE_NORMAL
- en: In the automated Continuous Delivery process, there is no longer a place for
    manual QAs who perform repetitive tasks.
  prefs: []
  type: TYPE_NORMAL
- en: You may look at the classification and wonder why you see no integration tests
    there. Where are they up to Brian Marick and where to put them in the Continuous
    Delivery pipeline?
  prefs: []
  type: TYPE_NORMAL
- en: To explain it well, we first need to mention that the meaning of an integration
    test differs depending on the context. For (micro) service architecture, they
    usually mean exactly the same as the acceptance testing, as services are small
    and need nothing more than unit and acceptance tests. If you build a modular application,
    then by integration tests we usually mean component tests that bind multiple modules
    (but not the whole application) and test them together. In that case, integration
    tests place themselves somewhere between acceptance and unit tests. They are written
    in a similar way as acceptance tests, but are usually more technical and require
    mocking not only external services, but also internal modules. Integration tests,
    similar to unit tests, represent the "code" point of view, while acceptance tests
    represent the "user" point of view. Concerning the Continuous Delivery pipeline,
    integration tests are simply implemented as a separate phase in the process.
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section explained what each test type represents in the process,
    but mentioned nothing about how many tests we should develop. So, what should
    be the code coverage in case of unit testing? What about acceptance testing?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer these questions, Mike Cohn, in his book *Succeeding with Agile: Software
    Development Using Scrum*, created a so-called testing pyramid. Let''s look at
    the diagram to understand it well.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f7a6cd1f-e677-49d1-8646-bca9f764282f.png)'
  prefs: []
  type: TYPE_IMG
- en: When we move up the pyramid, the tests become slower and more expensive to create.
    They often require touching user interface and hiring a separate test automation
    team. That is why acceptance tests should not target 100% coverage. On the contrary,
    they should be feature-oriented and verify only selected test scenarios. Otherwise,
    we would spend a fortune on the test development and maintenance, and our Continuous
    Delivery pipeline build would take ages to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The case is different at the bottom of the pyramid. Unit tests are cheap and
    fast, so we should strive for 100% code coverage. They are written by developers
    and providing them should be a standard procedure for any mature team.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that the agile testing matrix and the testing pyramid clarified the role
    and the importance of acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to the last phase of the Continuous Delivery process, configuration
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration management phase is responsible for tracking and controlling
    changes in the software and its environment. It concerns taking care of preparing
    and installing the necessary tools, scaling the number of service instances and
    their distribution, infrastructure inventory, and all tasks related to the application
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management is a solution to the problems posed by manually deploying
    and configuring applications on the production. Such common practice results in
    an issue whereby we no longer knows where each service is running and with what
    properties. Configuration management tools (such as Ansible, Chef, or Puppet)
    enable storing configuration files in the version control system and tracking
    every change that was made on the production servers.
  prefs: []
  type: TYPE_NORMAL
- en: An additional effort to replace manual tasks of the operations team is to take
    care of application monitoring. That is usually done by streaming logs and metrics
    of the running systems to a common dashboard, which is monitored by developers
    (or the DevOps team, as explained in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites to Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rest of the book is dedicated to technical details on how to implement
    a successful Continuous Delivery pipeline. The success of the process, however,
    depends not only on the tools we present throughout the book. In this section,
    we take a holistic look at the whole process and define the Continuous Delivery
    requirements in three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Your organization's structure and its impact on the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your products and their technical details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your development team and the practices you use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizational prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way your organization works has a high impact on the success of introducing
    the Continuous Delivery process. It''s a bit similar to introducing Scrum. Many
    organizations would like to use the Agile process, but they don''t change their
    culture. You can''t use Scrum in your development team unless the organization''s
    structure is adjusted to that. For example, you need a product owner, stakeholders,
    and management that understands that no requirement changes are possible during
    the sprint. Otherwise, even with good will, you won''t make it. The same applies
    to the Continuous Delivery process; it requires an adjustment of how the organization
    is structured. Let''s have a look at three aspects: the DevOps culture, a client
    in the process, and business decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: DevOps culture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A long time ago, when software was written by individuals or microteams, there
    was no clear separation between the development, quality assurance, and operations.
    A person developed the code, tested it, and then put it into the production. If
    anything went wrong, the same person investigated the issue, fixed it, and redeployed
    to the production. The way the development is organized now changed gradually,
    when systems became larger and development teams grew. Then, engineers started
    to become specialized in one area. That made perfect sense, because specialization
    caused a boost in the productivity. However, the side effect was the communication
    overhead. It is especially visible if developers, QAs, and operations are under
    separate departments in the organization, sit in different buildings, or are outsourced
    to different countries. Such organization structure is no good for the Continuous
    Delivery process. We need something better, we need to adapt the so-called DevOps
    culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevOps culture means, in a sense, coming back to the roots. A single person
    or a team is responsible for all three areas, as presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2121ef45-ffa9-46d9-adb9-94c98b8b4d1b.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason why it's possible to move to the DevOps model without losing on the
    productivity is the automation. Most of the tasks related to the quality assurance
    and operations are moved to the automated delivery pipeline and can be therefore
    managed by the development team.
  prefs: []
  type: TYPE_NORMAL
- en: A DevOps team doesn't necessarily need to consist only of developers. A very
    common scenario in many organization's under transformation is to create teams
    with four developers, one QA, and one person from operations. They need, however,
    to work closely together (sit in one area, have stand-ups together, work on the
    same product).
  prefs: []
  type: TYPE_NORMAL
- en: The culture of small DevOps teams affects the software architecture. Functional
    requirements have to be well separated into (micro) services or modules, so that
    each team can take care of an independent part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The impact of the organization''s structure on the software architecture was
    already observed in 1967 and formulated as Conway''s Law: "Any organization that
    designs a system (defined broadly) will produce a design whose structure is a
    copy of the organization''s communication structure."'
  prefs: []
  type: TYPE_NORMAL
- en: Client in the process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The role of a client (or a product owner) slightly changes during the Continuous
    Delivery adoption. Traditionally, clients are involved in defining requirements,
    answering questions from developers, attending demos, and taking part in the UAT
    phase to agree if what was built is what they had in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In Continuous Delivery, there is no UAT, and a client is essential in the process
    of writing acceptance tests. For some clients, who already wrote their requirements
    in a testable manner, it is not a big shift. For the others, it means a change
    in a way of thinking to make requirements more technical-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: In the Agile environment, some teams don't even accept user stories (requirements)
    without acceptance tests attached. Such techniques, even though they may sound
    too strict, often lead to better development productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Business decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most companies, the business has an impact on the release schedule. After
    all, the decision what features are delivered, and when, is related to different
    departments of the company (for example, marketing) and can be strategic for the
    enterprise. That is why the release scheduling has to be reapproached and discussed
    between the business and the development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there are techniques such as feature toggles or manual pipeline steps,
    which help with releasing features at the specified time. We will describe them
    later in the book. To be precise, the term Continuous Delivery is not the same
    as Continuous Deployment. The former means that each commit to the repository
    is automatically released to the production. Continuous Delivery is less strict
    and means that each commit ends up with a release candidate, so it allows the
    last step (release to the production) to be manual.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the book, we will use the terms Continuous Delivery and Continuous
    Deployment interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Technical and development prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the technical side, there are a few requirements to keep in mind. We will
    discuss them throughout the book, so let''s only mention them here without going
    into detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated build, test, package, and deploy operations**: All operations need
    to be possible to automate. If we deal with the system that is non-automatable,
    for example, due to security reasons or its complexity, then it''s impossible
    to create a fully automated delivery pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick pipeline execution**: The pipeline must be executed in a timely manner,
    preferably in 5-15 minutes. If our pipeline execution takes hours or days, then
    it won''t be possible to run it after every commit to the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick failure recovery**: A possibility of the quick rollback or system recovery
    is a must. Otherwise, we risk the production health due to frequent releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero-downtime deployment**: The deployment cannot have any downtime since
    we release many times a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trunk-based development**: Developers must check in regularly into one master
    branch. Otherwise, if everyone develops in their own branches, the integration
    is rare and therefore the releases are rare, which is exactly the opposite of
    what we want to achieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write more on these prerequisites and how to address them throughout
    the book. Keeping that in mind, let's move to the last section of this chapter
    and introduce what system we plan to build in this book and what tools we will
    use for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Continuous Delivery process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced the idea, benefits, and prerequisites with regards to the Continuous
    Delivery process. In this section, we describe the tools that will be used throughout
    the book and their place in the complete system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re interested more in the idea of the Continuous Delivery process,
    then have a look at an excellent book by Jez Humble and David Farley, *Continuous
    Delivery: Reliable Software Releases through Build, Test, and Deployment Automation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, the specific tool is always less important than understanding
    its role in the process. In other words, any tool can be replaced with another
    one which plays the same role. For example, Jenkins can be replaced with Atlassian
    Bamboo and Chief can be used instead of Ansible. That is why each chapter begins
    with the general description of why such a tool is necessary and what its role
    is in the whole process. Then, the exact tool is described with comparison to
    its substitutes. That form gives you the flexibility to choose the right one for
    your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach could be to describe the Continuous Delivery process on the
    level of ideas; however, I strongly believe that giving an exact example with
    the code extract, something that readers can run by themselves, results in a much
    better understanding of the concept.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to read this book. The first is to read and understand the
    concepts of the Continuous Delivery process. The second is to create your own
    environment and execute all scripts while reading to understand the details.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a quick look at the tools we will use throughout the book. In this
    section, however, it is only a brief introduction of each technology and much
    more detail is presented as this book goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker, as the clear leader of the containerization movement, has dominated
    the software industry in the recent years. It allows the packaging of an application
    in the environment-agnostic image and therefore treats servers as a farm of resources,
    rather than machines that must be configured for each application. Docker was
    a clear choice for this book because it perfectly fits the (micro) service world
    and the Continuous Delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together with Docker comes additional technologies, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is a registry for Docker images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Compose**: This is a tool to define multicontainer Docker applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Swarm**: This is a clustering and scheduling tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is by far the most popular automation server on the market. It helps
    to create Continuous Integration and Continuous Delivery pipelines and, in general,
    any other automated sequence of scripts. Highly plugin-oriented, it has a great
    community which constantly extends it with new features. What's more, it allows
    to write the pipeline as code and supports distributed build environments.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is an automation tool that helps with software provisioning, configuration
    management, and application deployment. It is trending faster than any other configuration
    management engine and can soon overtake its two main competitors: Chef and Puppet.
    It uses agentless architecture and integrates smoothly with Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub is definitely the number one of all hosted version control systems. It
    provides a very stable system, a great web-based UI, and a free service for public
    repositories. Having said that, any source control management service or tool
    will work with Continuous Delivery, no matter if it's in the cloud or self-hosted
    and if it's based on Git, SVN, Mercurial, or any other tool.
  prefs: []
  type: TYPE_NORMAL
- en: Java/Spring Boot/Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java has been the most popular programming language for years. That is why it
    is being used for most code examples in this book. Together with Java, most companies
    develop with the Spring framework, so we used it to create a simple web service
    needed to explain some concepts. Gradle is used as a build tool. It's still less
    popular than Maven, however, trending much faster. As always, any programming
    language, framework, or build tool can be exchanged and the Continuous Delivery
    process would stay the same, so don't worry if your technology stack is different.
  prefs: []
  type: TYPE_NORMAL
- en: The other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber was chosen arbitrarily as the acceptance testing framework. Other similar
    solutions are Fitnesse and JBehave. For the database migration we use Flyway,
    but any other tool would do, for example, Liquibase.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a complete Continuous Delivery system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can look at how this book is organized from two perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is based on the steps of the automated deployment pipeline. Each
    chapter takes you closer to the complete Continuous Delivery process. If you look
    at the names of the chapters, some of them are even named like the pipeline phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the chapters give the introduction, summary, or additional information
    complementary to the process.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a second perspective to the content of this book. Each chapter describes
    one piece of the environment, which in turn is well prepared for the Continuous
    Delivery process. In other words, the book presents, step by step, technology
    by technology, how to build a complete system. To help you get the feeling of
    what we plan to build throughout the book, let's now have a look at how the system
    will evolve in each chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't understand the concepts and the terminology at this
    point. We explain everything from scratch in the corresponding chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml), *Introducing Docker*,
    we start from the center of our system and build a working application packaged
    as a Docker image. The output of this chapter is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/360f4181-be46-4ca6-b481-53ba5e352a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: A dockerized application (web service) is run as a container on a **Docker Host**
    and is reachable as it would run directly on the host machine. That is possible
    thanks to port forwarding (port publishing in the Docker's terminology).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](f46b0c80-7f67-476c-9a17-8f1238f0b359.xhtml), *Configuring Jenkins*,
    we prepare the Jenkins environment. Thanks to the support of multiple agent (slave)
    nodes, it is able to handle the heavy concurrent load. The result is presented
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1098463d-b149-49b8-b80d-b08a6df6e053.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Jenkins** master accepts a build request, but the execution is started
    at one of the **Jenkins Slave** (agent) machines. Such an approach provides horizontal
    scaling of the Jenkins environment.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](a07d252d-3812-45ad-a567-1c70dae74d9d.xhtml), *Continuous Integration
    Pipeline*, we show how to create the first phase of the Continuous Delivery pipeline,
    the commit stage. The output of this chapter is the system presented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47bc7bc5-8cf0-4d4e-bdc9-f3b7e6b48221.png)'
  prefs: []
  type: TYPE_IMG
- en: The application is a simple web service written in Java with the Spring Boot
    framework. Gradle is used as a build tool and GitHub as the source code repository.
    Every commit to GitHub automatically triggers the Jenkins build, which uses Gradle
    to compile Java code, run unit tests, and perform additional checks (code coverage,
    static code analysis, and so on). After the Jenkins build is completed, a notification
    is sent to the developers.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you will be able to create a complete Continuous Integration
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](881f1493-1456-4c5b-bdc0-b87595433366.xhtml), *Automated Acceptance
    Testing*, we finally merge the two technologies from the book title: *Docker*
    and *Jenkins*. It results in the system presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ca2ff1f-0162-4b35-9b90-06f686b53022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The additional elements in the diagram are related to the automated acceptance
    testing stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Registry**: After the Continuous Integration phase, the application
    is packaged first into a JAR file and then as a Docker image. That image is then
    pushed to the **Docker Registry**, which acts as a storage for dockerized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Host**: Before performing the acceptance test suite, the application
    has to be started. Jenkins triggers a **Docker Host** machine to pull the dockerized
    application from the **Docker Registry** and starts it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Compose**: If the complete application consists of more than one Docker
    container (for example, two web services: Application 1 using Application 2),
    then **Docker Compose** helps to run them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cucumber**: After the application is started on the **Docker Host**, Jenkins
    runs a suite of acceptance tests written in the **Cucumber** framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management with Ansible/Continuous Delivery pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next two chapters, that is, [Chapter 6](75a4971b-4eb7-45cb-a3ac-81a7d5ca79b2.xhtml),
    *Configuration Management with Ansible* and Chapter 7, *Continuous Delivery Pipeline*,
    we complete the Continuous Delivery pipeline. The output is the environment presented
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6b7eeee2-d286-4b43-a91c-d2066e375a83.png)'
  prefs: []
  type: TYPE_IMG
- en: Ansible takes care of the environments and enables the deployment of the same
    applications on multiple machines. As a result, we deploy the application to the
    staging environment, run the acceptance testing suite, and finally release the
    application to the production environment, usually in many instances (on multiple
    Docker Host machines).
  prefs: []
  type: TYPE_NORMAL
- en: Clustering with Docker Swarm/Advanced Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml), *Clustering with
    Docker Swarm*, we replace single hosts in each of the environments with clusters
    of machines. [Chapter 9](f45afa10-c8a5-4252-bc14-8bc8bbcda5c9.xhtml), *Advanced
    Continuous Delivery*, additionally adds databases to the Continuous Delivery process.
    The final environment created in this book is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4e76ac56-d89b-4e6f-8ea0-47a7bc1083ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Staging and production environments are equipped with Docker Swarm clusters
    and therefore multiple instances of the application are run on the cluster. We
    don't have to think anymore on which exact machine our applications are deployed.
    All we care about is the number of their instances. The same applies to Jenkins
    slaves, they are also run on a cluster. The last improvement is the automatic
    management of the database schemas using Flyway migrations integrated into the
    delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are already excited by what we plan to build throughout this book.
    We will approach it step by step, explaining every detail and all the possible
    options in order to help you understand the procedures and tools. After reading
    this book, you will be able to introduce or improve the Continuous Delivery process
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have introduced the Continuous Delivery process starting
    from the idea, discussing the prerequisites, to end up with tools that are used
    in the rest of the book. The key takeaway from this chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The delivery process used currently in most companies has significant shortcomings
    and can be improved using modern tools for automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Continuous Delivery approach provides a number of benefits, of which the
    most significant ones are: fast delivery, fast feedback cycle, and low-risk releases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Continuous Delivery pipeline consists of three stages: Continuous Integration,
    automated acceptance testing, and configuration management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Continuous Delivery usually requires a change in the organization's
    culture and structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important tools in the context of Continuous Delivery are Docker, Jenkins,
    and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we introduce Docker and present how to build a dockerized
    application.
  prefs: []
  type: TYPE_NORMAL
