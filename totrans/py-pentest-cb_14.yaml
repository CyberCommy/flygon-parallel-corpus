- en: Linux Exploit Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Format string exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing exploits for vulnerabilities in the applications developed for the
    Linux environment can be done with the Python tools. We have to use debuggers
    such as `pwndbg` to debug the applications. Then, we can use Python scripts to
    exploit the vulnerabilities. In this chapter, we will go through some basic vulnerabilities
    and methods to develop an exploit script for it with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Format string exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A format string is an ASCIIZ string that contains text and format parameters.
    The format string vulnerability occurs when the submitted data of an input string
    is evaluated as a command by the application. With the help of this method, the
    attacker could execute code, read the stack, and may cause a segmentation fault.
    Format string vulnerability exist in most of the `printf` family functions, such
    as `printf`, `sprintf`, and `fprintf`. These are the common parameters that can
    be used in format string vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"%x"`: It reads data from the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"%s"`: It reads character strings from the process memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"%n"`: It writes an integer to locations in the process memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"%p"`: It''s external representation of a pointer to void'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a 32-bit x86 Linux real or virtual environment for creating the vulnerable
    application and getting the basic idea about the process involved in it. It is
    also a prerequisite to have a basic idea about some concepts in Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to install the `pwndbg` debugger in the Linux environment. To check,
    open up the Terminal and type `gdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open up the `pwndbg` console if installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use `q` to quit from this console. We also need a vulnerable application
    for our work. For better understanding we can create a simple vulnerable application
    in C.
  prefs: []
  type: TYPE_NORMAL
- en: Global offset table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A global offset table is used by the program during its compile time. It helps
    to get the location of the function used from external libraries. To view this
    we have to depend on the `objdump` command. The `objdump` command is the Linux
    environment used to get the detailed information of an object file. This is very
    helpful while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Generating shell code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To generate shell code for injecting we have to use Metasploit shell code generation
    functionality, so make sure you have Metasploit installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to create an exploit script for exploiting format string
    in Linux environment:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to create a vulnerable application. So, we can write a C file
    with format string vulnerability. Create an `fmt.c` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in it and Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to compile this code with format security disabled. For that run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will create an executable named `fmt`. We can use this as our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to disable **Address Space Layout Randomization** (**ASLR**) in your
    test machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the application for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will print the parameter passed to the application
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we will test the application with the format string inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here the first test prints some hexadecimal values from the stack, but the second
    writes values to locations in the memory where the stack values points to and
    finally end up in segmentation fault. So, from the results of the tests it is
    pretty clear that we can read from the RAM and also we can write to RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can change the input and try to control the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The characters `AAAA` and `BBBB` that we passed appear as the fourth parameter
    on the stack in hex values, as `41414141` for `AAAA` and `42424242` for `BBBB`.
    From this it's clear that we can now control the fourth parameter on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are planning to control the code execution, we need to change a function''s
    address. So let''s try to find a RAM location to write. For that we can use `pwndbg`
    to view the assembly code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the assembly code. From this we can identify that the application
    calls `printf@plt` on `59` and `putchar@plt` on `72`. So we can set the break
    point at `59` for debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we know, global offset tables hold the current addresses of library functions.
    So we can use `objdump` to view the entries in the GOT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From this we will get the location for the `putchar` in the dynamic relocation
    record. Here it is, `08049748`, and it may be different for you. So make sure
    to update your scripts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try to write to the `putchar` PLT entry. We can make use of `pwndbg`
    for this. Open the app in `pwndbg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the first breakpoint before the `printf` and after the `printf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the app with our payload to write to the address location of `putchar`
    that we got from `objdump`. In my case it is `08049748`. We have to convert the
    address to Little Endian format to work with the Intel architecture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run up to our first breakpoint, which is before the `printf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can examine the value at the memory location for its current value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then forward to the next break point by typing `c`. Then check the memory location
    again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From this we know that the value changed to `0x00000018`. When `printf` executes
    with a format sting value `%n` as the parameter, it prints out a 32-bit length
    value equal to the bytes printed so far. Here the program has printed 18 bytes
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write our exploit code to craft the payload. For that, create an
    `exploit.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then add the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a payload for our application. This will be submitted as the
    input to write to the memory location. So the best way to generate a 32-bit word
    is to perform four writes, with each targeting the one byte, and combining them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the exploit code has execute permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the application in debugger with this payload. This is exactly
    what we did before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the memory location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then the value changed to `0x4c443c34`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try changing one byte in the payload then. For that, change the third
    format string parameter, `%x` to `%16x`. This will add 16 leading zeros to it
    and make it 16 bytes long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the app in debug mode and examine the value in the memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The value changed to `0x564e46` from its previous value of `0x4c443c`. So all
    bytes increased by 16\. Now it is 16 bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try to write a specific address to that address location. Here we
    can try to write `ddccbbaa`. For that, update our `exploit.py` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have added enough leading zeros before each `%n` to match the
    total number of printed characters and match the desired value we plan to write.
    Also, the total number of bytes increases with each write; we have to add 256
    to each value to make the last bytes clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute the application with our crafted payload and examine the memory
    location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the `putchar@got.plt` pointer has the value `0xddccbbaa`, which is the value
    we planned to write in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a pattern and insert it in the exploit. This will help to
    identify the location we can insert our shell code in. So, update our exploit
    with the pattern. This will update the script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application in debugger with the payload, and examine the `200`
    bytes after the ESP register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can see the NOP sled on the stack. And we can select an address in the
    middle of the NOP sled for adding shell code. Here we can select `0xbffff110`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to replace the address, `0xddccbbaa`, with the real address we
    selected from the NOP sled. For that, update the `exploit.py` with correct bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application with debugger and examine the memory location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can generate a shell code with Metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now update the exploit code with the shell code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have added a postfix to make the total number of injected characters constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the application with the payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try connecting with `nc` as the shell code and open port `4444`, and try
    running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see these details in the debugger as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffer overflow can cause the program to crash or leak private information.
    A buffer in case of a running program, can be considered as a section in a computer's
    main memory with specific boundaries, so basically accessing any buffer outside
    this allocated region of memory space.
  prefs: []
  type: TYPE_NORMAL
- en: As the variables are stored together in stack/heap, accessing anything outside
    this boundary may cause read/write of some bytes of some other variables. But
    with a better understanding we can execute some attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to generate an exploit code for buffer overflow attacks in
    Linux environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create a vulnerable application for the test. Create a `bof.c` file
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the following application test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can run `objdumb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'From that we can get the memory location of the secret function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here it is, `0804848b`. And 28 bytes are reserved for local variables of the
    `echo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can design the payload--as we know, 28 bytes are reserved for the buffer,
    and it's next to the EBP pointer. So, the next four bytes will store EIP. Now
    we can set the first 28+ 4 =32 bytes with any random characters, and then the
    next four bytes will be the address to `secretfunction()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the payload will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Save this to an `exploit_bof.py` file and load it as a payload for the application
  prefs: []
  type: TYPE_NORMAL
- en: This will crash the application and provide access to the `secretfunction()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
