- en: '*Chapter 9*: Understanding Input and Output to Design a Solution Algorithm'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a deeper look at problems in order to identify
    the input and output necessary to design an algorithm for the problems. We will
    use concepts we learned in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*, where we discussed object-oriented programming, dictionaries,
    lists, and more. As you practice getting input and using it in your algorithm,
    you'll be able to see that the output of an algorithm is dependent on the input
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding input and output in computational thinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will focus on understanding different types of input and
    how output is used in programming using the **Python** programming language. To
    be able to get a better understanding of these topics, we have to first look at
    their definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have the latest Python version installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter09](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter09)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will begin this section by studying input and its definition, which, in turn,
    is used to provide a result, or output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input** is what is put into a system or machine. In computers, we have input
    devices that the computer then interprets to provide a result, or **output**.
    As we look at the types of inputs and how we use input in algorithms, you''ll
    see the output we get from those algorithms. Let''s take a look at some examples
    of input devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keyboard**: When we use a keyboard, the computer interprets the keys and
    uses that interpretation in various programs, such as document writing and search
    bars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mouse**: The mouse is used to navigate our physical screens, helping us click
    through content and scroll through pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Joystick**: A joystick can be used to play computer games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microphone**: In more modern machines, microphones are not only used to communicate
    through phone and video apps, but also to take verbal commands for **Artificial
    Intelligence** (**AI**) assistants such as **Cortana** and **Siri**, as well as
    voice-to-text commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the aforementioned inputs are programmed into our computers in order
    to be useable. In Python, we write algorithms that use inputs such as these. **User**
    input is when a program asks the user for information that will then be used to
    produce the output. Keep in mind that input and output can happen at any time
    within the algorithm. We can also provide output feedback that requires additional
    input from the user, and so on. Let's take a look at how we can get user input
    from Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python has one main prompt for users, the `input()` function. This function
    is used to take user input, and then it automatically converts the input into
    the user expected output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used these main prompts before in multiple programs, such as the store
    example in [*Chapter 5*](B15413_05_Final_SK_ePub.xhtml#_idTextAnchor082), *Exploring
    Problem Analysis*. Let''s take a look at what some input commands look like in
    algorithms. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_input1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The snippet asks the user for their name, and then prints a statement using
    the information from the input. The result of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we could just ask for input without using any prompting questions, but
    the user will not know what is being asked or how it will be used. Take a look
    at the snippet without the prompts, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_input2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding program, nothing prints out in our shell. However,
    I knew there was something I needed to type, so take a look at what happened when
    I just typed a letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the user wouldn't have known what to do because the window doesn't
    ask anything; it just gives a blank space and the user has to assume that's where
    you type the input. But that can cause a lot of confusion, since there's nothing
    telling the user whether it needs input or what kind of thing they have to enter.
  prefs: []
  type: TYPE_NORMAL
- en: We can alleviate some of that confusion by using `print` statements, for example,
    by providing the user with information about what input we'll be asking for. We
    can also include a statement as part of the `input()` function. For example, we
    could use a line of code such as `name = input('What is your name?')`, which would
    show the statement in quotations first so that the user knows what we are asking.
    Either way, providing a statement so that the user knows what is needed is really
    important when we design our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the preceding example, the `input()` function took a string,
    and then used the string in a `print()` statement. Let''s look at what a list
    would look like using the `input` command:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_input3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we first create the list, which is not shown to the
    user. The user is then asked how many names will be added to the list. After that,
    we iterate through the list so that the user can input each name separately. Finally,
    the names are appended and the list printed. Take a look at the output for this
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the names don''t have a prompt, so the algorithm assumes the user
    will know what to do after inputting the value `4`. That can be alleviated with
    a simple addition within the iteration. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_input4.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each name will now have a prompt that asks to type the next
    name, which looks like the following output when the algorithm is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows the completed list and the prompts for each of the
    names that were added to that list. Simple additions for those prompts within
    the algorithm can alleviate confusion on the part of users when entering the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the previous snippets in this section, the inputs were read
    as integers, strings, and lists. Python automatically converted the information
    so it could be used by the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, there''s also a way to define multiple variables with separate inputs
    from one line of code. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_input5.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, the quotations (`" "`) in the middle
    of the `print()` command are used to separate the inputs. Take a look at the output
    for this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program asks for the first and last names, which were called
    in the first line of the algorithm. This is by no means the only way that we can
    use for getting inputs from users, nor the only input we'll use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at some of the ways in which we can define input
    within an algorithm. We also learned how we can get input from a user to use later
    in the algorithm. Now let's move to the next section, where we'll look at input
    and output within some computational thinking problems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding input and output in computational thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to better understand input and output, we will take a look at computational
    thinking problems in this section. As we go through the design process of the
    algorithms, we will focus on identifying the inputs needed and what output we
    require from our algorithms. Let's take a look at our first problem.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1 â€“ Building a Caesar cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Caesar cipher** is a system of cryptography used to code messages. Cryptography
    is used to secure information so that only the intended users can read the messages.
    The Caesar cipher uses a shift in the letters to encode the messages. For example,
    the letter *a* shifted 3 places would be *d*. To build an algorithm that does
    this for us, we''ll need a few things on hand:'
  prefs: []
  type: TYPE_NORMAL
- en: A message that will be coded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much we'll shift each letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A printed coded message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s think about what the aforementioned points mean. The message will need
    to be an input from the user. The shift will also be an input, as we don''t want
    the program to always use the same code. Otherwise, it will be easy to figure
    out the original message once you know the shift. The printed coded message is
    our output. Here are some of the steps to help create the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to input the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we need to define the input shift.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need to iterate through each letter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After iteration, we adjust each letter with the shift we defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we print out the new, coded message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will exemplify the preceding steps with the help of the following cipher
    algorithm snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_problem1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the iteration, we're doing some math to figure out the value
    for each letter in the alphabet. We use some conditional statements to define
    what each letter's value is after using the user-defined shift value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the output that results when we run this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, notice the first word in the *message*
    and the *coded message* â€“ `Code`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `C`, moved two letters, is now an `E`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `o` is now `q`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each letter in the message, the letters have shifted two places. The output
    is our `print()` statement plus the coded message, which is given by the line
    `print(msgCipher)`. Our output includes both statements for clarity. *Is the first
    message necessary?* No. However, in some algorithms, it's best to have some lines
    that allow the user to know what is happening with the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at another problem.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2 â€“ Finding maximums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are asked to create a program that finds the maximum value from a list of
    numbers. The list of numbers is provided by the user. So, create an algorithm
    for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to identify the inputs and output for this particular problem.
    They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of items in the list (input)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Numbers in the list (input)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximum value in the list (output)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recall from earlier in this chapter, in the *Defining input and output* section,
    that we can define an empty list, and then ask the user to let the program know
    how many items will be entered into the list. The following program exemplifies
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_problem2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice from the preceding code that we used the `max()` function to find the
    maximum value within the list. In addition, we had to add `int()` types in order
    to have the algorithm correctly identify the values as numbers. The code goes
    through each number from `0` to the number of data points we received from the
    user input, which we defined as the `quant` variable. As the algorithm iterates
    through the numbers, it compares them and finds the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, the user stated that `6` numbers would
    be entered. The algorithm then prompted the user for each of the values. Finally,
    the maximum value was identified.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at how we can build a guessing game.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3 â€“ Building a guessing game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've been asked to build a game where a user gets as many chances as needed
    to identify the digits of a four-digit number in the correct order. When a user
    inputs a guess, the algorithm will state whether any numbers are correct.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm will identify whether the numbers are in the correct location,
    but will not identify which of the numbers are correct or which are in the correct
    location. If the player guesses the correct number, the game ends. You may find
    this game similar to a popular game called **Mastermind**, where a player sets
    four color pins into the game and a second player guesses.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're using numbers rather than colors, and the computer program
    will help us identify whether we have any numbers correct and whether they are
    in the correct location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this game, let''s look at the inputs and outputs that we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: A randomly generated 4-digit number (input)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's guesses (input)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feedback about numbers and locations from the algorithm (output)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message finalizing the game after the number is guessed (output)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we generate the number, we''ll need to find a way to compare the digits
    of that number to the digits that the user inputs. Note that we need to import
    the `random` library for this particular algorithm so we can generate the random
    four-digit number. Let''s take a look at the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch9_problem3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is one instance where we''ll need input from the user.
    However, this is only the first guess, so we''ll need to get more input from the
    user and provide some output that provides feedback. Take a look at the following
    code snippet from the same algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we need to ask for each guess after a failed attempt. The algorithm
    needs to know what the next guess is in order to continue running if the user
    hasn't identified the correct four-digit number. That's why the guess input value
    happens in multiple places within the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user guesses correctly, the program needs to print a final statement,
    and in this case, we''ll let the user know how many attempts it took to guess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this algorithm has input at multiple places based on conditions
    met, as well as output. The outputs include `print` statements and feedback on
    correct or incorrect digits. Let''s take a look at what the output looks like
    when the program is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the third attempt, we had one correct digit, which was denoted
    as `3` `N N N`. That means that the first digit is 3\. We had to then guess the
    rest of the numbers. Providing feedback within the program, or output, allows
    the user to continue this game.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, understanding input and output allows us to create programs
    that can provide feedback, iterate based on conditions, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use input and output when solving problems.
    We were provided with scenarios that allowed us to explore some of the types of
    inputs, such as user-defined inputs and algorithm-defined inputs. We also learned
    how to write algorithms that provide clear output for the users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed input and output in Python algorithms. Input is
    how we get information for the algorithm to respond to. For example, a user can
    provide input to an algorithm that has prompts for that information, as we saw
    in the sample problems. Python and other programming languages can also get input
    from a mouse, scanners, cameras, and other devices that the program interacts
    with.
  prefs: []
  type: TYPE_NORMAL
- en: In order to write our algorithms, it is important to identify what inputs we
    need, when we need them in the design, and what we need as output from the program.
    In [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056), *Understanding
    Algorithms and Algorithmic Thinking*, we used user input to find the cost of lunches.
    We had created a dictionary to help us find that information. Similarly, after
    reading this chapter, you now have the skills required to build algorithms to
    solve some additional problems, such as our digit guessing game and our maximum
    finder.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying input and output is critical before we design algorithms, as the
    conditions and decisions we make in our algorithms depend on what is entered as
    input and what we need the program to provide as output.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss control flow, which is critical in understanding
    how an algorithm is read and how the instructions are performed. We will also
    look more closely at functions while exploring control flow in algorithms.
  prefs: []
  type: TYPE_NORMAL
