- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explain a very practical concept of Bash scripting:
    functions. We''ll show what they are, how we can use them, and why we would want
    to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: After the basics of functions have been introduced, we're taking it a step further
    and we'll show how functions can have their own input and output.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a function library will be described and we will start to build
    our own personal function library that will contain various utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `top`, `free`, `declare`,
    `case`, `rev`, and `return`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions explained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting functions with parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter13).
    Apart from your Ubuntu Linux virtual machine, no other resources are needed to
    complete the examples in this chapter. For the argument-checker.sh, functions-and-variables.sh, library-redirect-to-file.sh
    scripts only the final version is found online. Be sure to verify the script version
    in the header before executing it on your system.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to look at functions, and how these can enhance
    your scripts. The theory of functions is not too complicated: a function is a
    set of commands grouped together that can be called (executed) multiple times
    without having to write the whole set of commands again. As always, a good example
    is worth a thousand words, so let''s dive right in with one of our favorite examples:
    printing `Hello world!`.'
  prefs: []
  type: TYPE_NORMAL
- en: Hello world!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now know it''s relatively easy to get the words `Hello world!` to appear
    on our terminal. A simple `echo "Hello world!"` does just the trick. However,
    if we wanted to do this multiple times, how would we go about it? You could suggest
    using any kind of loop, which would indeed allow us to print multiple times. However,
    that loop also requires some extra code and planning up front. As you will notice,
    in practice loops are great for iterating over items, but not exactly suitable
    for reusing code in a predictable manner. Let''s see how we can use a function
    to do this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you see, we first defined the function, which is nothing more than writing
    the commands that should be executed once the function is called. At the end of
    the script, you can see we execute the function by just entering the function
    name, as we would any other command. It is important to note that you can only
    call a function *if you have previously defined it*. This means that the entire
    function definition needs to be higher in the script than its call. For now, we'll
    place all functions as the first items in our scripts. Later on in this chapter,
    we'll show you how we can be more efficient with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you saw in the previous example was the first of two possible syntaxes
    for function definition in Bash. If we extract just the function, the syntax is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second possible syntax, which we like less than the previous one, is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two syntaxes is the absence of either the word `function` at
    the beginning or `()` after the function name. We prefer the first syntax, which
    uses the `()` notation, as it is much closer to the notation of other scripting/programming
    languages and should thus be much more recognizable for most. And, as an added
    bonus, it is shorter and simpler than the second notation. As you might expect,
    we'll continue using only the first notation in the rest of the book; the other
    was presented for completeness (and it is always convenient to understand it if
    you come across it online when researching for your scripting!).
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we use indentation to relay information about where commands are nested
    to the reader of a script. In this case, since all commands within a function
    are only run when the function is called, we indent them with two spaces so it's
    clear we're inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: More complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function can have as many commands as needed. In our simple example, we only
    added a single `echo`, which we then only called once. While this is nice for
    abstraction, it does not really warrant creating a function (yet). Let''s look
    at a more complex example that will give you a better idea why abstraction of
    commands in functions is a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re talking! This function has five commands, three of which include
    command substitution with chained pipes. Now, our scripts are starting to become
    complex yet powerful. As you can see, we define the function using the `()` notation.
    We then call this function in a C-style `for` loop, which causes the script to
    print the system status five times with a five-second pause in between (due to
    `sleep`, which we saw earlier in [Chapter 11](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml),* Conditional
    Testing and Scripting Loops*). When you run this, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the date, the chance of the other output changing significantly
    is slim, unless you have other processes running. However, the purpose of functions
    should be clear: define and abstract a set of functionalities in a transparent
    manner.'
  prefs: []
  type: TYPE_NORMAL
- en: While not the topic of this chapter, we used a few new commands here. The `top`
    and `free` commands are often used to check how the system is performing, and
    can be used without any arguments (`top` opens full screen, which you can exit
    with *Ctrl *+ *C*). In the *Further reading* section of this chapter, you can
    find more on these (and other) performance monitoring tools in Linux. We've also
    included a primer on `awk` there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many advantages to using functions; these include but are not limited
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to reuse code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows sharing of code (via libraries, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract confusing code to a simple function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important thing in functions is naming. A function name should be as concise
    as possible, but still needs to tell the user what it does. For example, if you
    call a function something non-descriptive such as `function1`, how will anyone
    know what it does? Compare this to a name like we saw in the example: `print_system_status`.
    While perhaps not perfect (what is system status?), it at least points us in the
    right direction (if you agree that CPU, memory, and disk usage are considered
    part of system status, that is). Perhaps a better name for the function would
    be `print_cpu_mem_disk`. It is up to you to decide! Make sure you consider who
    the target audience is when making this choice; this often has the greatest impact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While descriptiveness is very important in function naming, so is adhering
    to a naming convention. We''ve already presented this same consideration in [Chapter
    8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User Input*, when
    we dealt with variable naming. To reiterate: the most important rule is to *be
    consistent*. If you want our advice for a function naming convention, stick with
    the one we laid out for variables: lowercase, separated by underscores. This is
    what we used in the previous examples, and is what we will continue to show in
    the rest of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While functions are great, there are some things we have previously learned
    that we''ll need to reconsider in the scope of functions, most notably variables.
    We know that variables store information that can be accessed or mutated multiple
    times and at multiple points in our scripts. However, something we have not yet
    learned is that a variable always has a *scope.* By default, variables are scoped
    *globally*, which means they can be used throughout the script at any point. With
    the introduction of functions also comes a new scope: *local*. Local variables
    are defined within a function and live and die with the function call. Let''s
    see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. We can use our *global* constants in a function. This is not
    surprising, since it is not called a global variable lightly; it can be used anywhere
    in the script. Now, let''s see what happens when we add some extra variables in
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What do you think happens now? Give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to what you might have suspected, the variable we defined inside the
    function is actually still a global variable (sorry for tricking you!). If we
    wanted to use locally scoped variables, we need to add the built-in local shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we execute it this time, we''ll actually see the script misbehaving
    at the final command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the local addition, we can now only use the variable and its content
    inside of the function. So, when we call the `hello_variable` function, we see
    the content of the variable, but when we try to print it outside of the function
    in `echo "Function variable outside function: ${FUNCTION_VARIABLE}"`, we see it
    is empty. This is the expected and desirable behavior. What you can actually do,
    and is sometimes really convenient, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ve defined a locally scoped variable *with the same name* as a globally
    scoped one we have already initialized! You might have an idea about what happens
    next, but be sure to run the script and understand why this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we used the `CONSTANT_VARIABLE` variable (remember, constants are
    still considered variables, albeit special ones) within the function, it printed
    the value of the locally scoped one: `maybe not so constant?`. When outside the
    function, in the main body of the script, we printed the value for the variable
    again, and we were presented with the value as we had originally defined it: `constant`.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be having a hard time imagining a use case for this. While we agree
    that you will probably not use this often, it does have its place. For example,
    imagine a complex script where a global variable is used by multiple functions
    and commands sequentially. Now, you might come across a situation where you need
    the value of the variable, but slightly modified to use it correctly in a function.
    You also know that functions/commands further on need the original value. Now,
    you could copy the contents to a new variable and use that, but by *overriding*
    the variable within a function you make it much clearer to the reader/user that
    you have a purpose for this; that it is a well-informed decision and you're aware
    you need that exception *for just that function*. Using a locally scoped variable
    (preferably with a comment, as always) will ensure readability!
  prefs: []
  type: TYPE_NORMAL
- en: Variables can be set read-only by using the `declare` built-in shell. If you
    check the help, with `help declare`, you'll see it described as `'Set variable
    values and attributes'`. A read-only variable such as a constant can be created
    by replacing `CONSTANT=VALUE` with `declare -r CONSTANT=VALUE`. If you do this,
    you can no longer (temporarily) override a variable with a local instance; Bash
    will give you an error. In practice, the `declare` command is not used too much
    as far as we have encountered, but it can serve useful purposes besides read-only
    declarations, so be sure to give it a look!
  prefs: []
  type: TYPE_NORMAL
- en: Practical examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we introduce function parameters in the next part of this chapter, we''ll
    first look into a practical example of functions that do not need parameters.
    We''ll go back to previous scripts we''ve created, and see if there is some functionality
    we can abstract as a function. Spoiler alert: there is a great one, which deals
    with a little something called error handling!'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml), *Error Checking
    and Handling*, we created the following construction: `command || { echo "Something
    went wrong."; exit 1; }`. As you (hopefully) remember, the `||` syntax means that
    everything on the right-hand side will only be executed if the command on the
    left-hand side has an exit status that is not `0`. While this setup worked fine,
    it did not exactly increase readability. It would be much better if we could abstract
    our error handling to a function, and call that function instead! Let''s do just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This script defines two functions: `handle_minor_error` and `handle_fatal_error`.
    For a minor error, we will print a message but the script execution does not stop.
    A fatal error, however, is considered so severe that the flow of the script is
    expected to be disrupted; in this case, it is of no use to continue the script
    so we''ll make sure the function stops it. By using the functions combined with
    the `||` construct, we do not need to check for exit codes inside the functions;
    we only end up inside the functions if the exit code was not `0`, so we already
    know we''re in an error situation. Before we execute this script, take a moment
    to reflect *how much we improved the readability* with these functions. When you''re
    done with that, run this script with debug output, so you can follow the entire
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, the first command, `ls -l /tmp/`, succeeds and we see its output;
    we do not enter the `handle_minor_error` function. The next command, which we
    do expect to fail, does indeed. We see that we now go into the function and the
    error message we specified there is printed. But, since it is only a minor error,
    we continue the script. However, when we get to `cat /etc/shadow`, which we consider
    a vital component, we encounter a `Permission denied` message that causes the
    script to execute `handle_fatal_error`. Because this function has an `exit 1`,
    the script is terminated and the fourth command is never executed. This should
    illustrate another point: an `exit`, even from inside a function, is global and
    terminates the script (not just the function). If you wish to see this script
    succeed, run it with `sudo bash error-functions.sh`. You will see that neither
    of the error functions is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting functions with parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as a script can accept input in the form of arguments, so can a function.
    In reality, most functions will use parameters. Static functions, such as the
    error handling example from earlier, are not as powerful or flexible as their
    counterparts to accept arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Colorful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next example, we''ll create a script that allows us to print text to
    our terminals in a few different colors. It does this based on a function that
    has two parameters: `string` and `color`. Take a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot is happening in this script. To help with your understanding, we''ll
    go through it piece by piece, starting with the first part of the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do within the function body is check the number of arguments.
    The syntax is the same as the checks we normally do for arguments passed to the
    entire script, which might be helpful or perhaps confusing. A good thing to realize
    is that the `$#` construct applies to the scope in which it is used; if it is
    used within the main script, it checks the arguments passed there. If it is used,
    like it is here, within a function, it checks the number of arguments passed to
    the function. The same goes for `$1`, `$2`, and so on: if used within a function,
    they refer to the ordered arguments passed to the function, and not the script
    in general. When we grab the arguments, we write them to *local* variables; we
    don''t strictly need to do that in this simple script, but it is always good practice
    to mark variableses local when you only use them in the local scope. You might
    imagine that in larger, more complex scripts many functions use variables that
    might accidentally be called the same thing (in this case, `string` is a very
    common word). By marking them local, you''re not only improving readability, but
    also preventing errors caused by variables that have the same name; all in all,
    a very good idea. Let''s get back to the next part of our script, the case-statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now is an excellent time to introduce `case`. A case-statement is basically
    a very long `if-then-elif-then-elif-then...` chain. The more options there are
    for a variable, the longer the chain would become. With `case`, you can just say
    `for certain values in ${variable}, do <something>`. In our example, that means
    that if the `${color}` variable is `red`, we'll set another `color_code` variable
    to `\e[31m` (more on that in a bit). If it is `blue`, we'll do something else,
    and the same goes for `green`. Finally, we'll define a wildcard; any value for
    the variable that was not specified will go through there, as a sort of catch-all
    construction. If the color specified is something incompatible, such as **dog**,
    we'll just set the default color. The alternative would be breaking off the script,
    which is a bit of an overreaction to a wrong color. To terminate a `case`, you'll
    use the `esac` keyword (which is the reverse of `case`), in a similar manner to
    `if`, which is terminated by its reverse, `fi`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on to the technical aspect of *colors on your terminal*. While most things
    we've been learning about are Bash or Linux specific, printed colors are actually
    defined by your terminal emulator. The color codes we're using are pretty standard
    and should be interpreted by your terminal as *do not print this character literally,
    but instead change the `color` to `<color>`*. The terminal sees an *escape sequence*,
    `\e`, followed by a *color code*, `[31m`, and knows you're instructing it to print
    a different color than previously defined (often defaults for that terminal emulator,
    unless you've changed the color scheme yourself). You can do many more things
    (as long as your terminal emulator supports this, of course) with escape sequences,
    such as creating bold text, blinking text, and another background color for your
    text. For now, remember *the \e[31m sequence is not printed but interpreted.* For
    the catch-all in `case`, you do not want to explicitly set a color, but instead
    signal the terminal to print in the *default* color. This means that for every
    compatible terminal emulator, the text is printed in the color the user has chosen
    (or got assigned by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the final part of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the `print_colored` function actually prints the colored text.
    It does this by using the good old `echo` with the `-e` flag. `man echo` reveals
    that `-e` *enables interpretation of backslash escapes*. If you do not specify
    this option, your output will just be something like `\e[31mHello world!\e[39m`.
    A good thing to know in this situation is that as soon as your terminal encounters
    a color code escape sequence, *all subsequent text will be printed in that color!*
    Because of this, we end the echo with `"\e[39m"`, which resets the color for all
    following text back to default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the function multiple times, with the same first argument,
    but a different second argument (the color). If you run the script, the output
    should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82d06db9-52c7-4555-b8e5-f4e4ce7763d7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, my color scheme is set to green-on-black, which
    is why the last `Hello world!` is bright green. You can see it is the same color
    as `bash colorful.sh`, which should be all the confirmation you need to be sure
    the `[39m` color code is actually default.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some functions follow the *processor* archetype: they take input, do something
    with it, and return the result back to the caller. This is something of a classic
    function: depending on the input, different output is generated. We''ll show this
    with an example that reverses the input the user specifies to the script. This
    is normally done with the `rev` command (and will actually be accomplished with
    `rev` in our function as well), but we''re creating a wrapper function around
    this with a little extra functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is again a longer, more complex script, we''re going to look at it
    bit by bit to make sure you understand it all. We even sneaked a little surprise
    in there that proves one of our earlier statements, but we''ll get to that in
    a bit. We''ll skip the header and input check and move to capturing the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In most of the earlier examples, we''ve always directly mapped input to a variable.
    However, this time we''re showing that you can actually also add some extra text.
    In this case, we''re taking the input by the user and we add an underscore before
    and after. If the user inputs `rain`, the variable will actually contain `_rain_`.
    This will prove insightful later. Now, for the function definition, we use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reverser` function requires a single argument: the input to be reversed.
    As always, we first check if the input is correct, before we actually do anything.
    Next, we use `rev` to reverse the input. However, `rev` normally expects input
    from a file or `stdin`, not a variable as an argument. Because we do not want
    to add an extra echo and pipe, we use a here string (as explained in [Chapter
    12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),* Using Pipes and Redirection
    in Scripts*), which allows us to directly use the variable content as `stdin`.
    Since `rev` already outputs the result to `stdout`, we do not need to provide
    anything, such as an echo, at that point.'
  prefs: []
  type: TYPE_NORMAL
- en: We told you we'd prove a previous statement, which in this case relates to `$1`
    in the previous snippet. If `$1` within the function related to the first argument
    *of the script* and not the first argument *of the function*, we would not see
    the underscores we added when we wrote the `user_input` variable. For the script,
    `$1` could equal `rain`, where in the function, `$1` equals `_rain_`. When you
    run the script, you'll definitely see the underscores, which means that each function
    really has its own set of arguments!
  prefs: []
  type: TYPE_NORMAL
- en: 'Tying it all together is the final piece of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `reverser` function sends the reversed input to `stdout`, we''ll
    use command substitution to capture it in a variable. Finally, we print some clarifying
    text and the reversed input to the user with `echo`. The result will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Underscores and all, we get the reverse of `rain: _nair_`. Nice!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid too much complexity, we split the final part of this script in two
    lines. However, once you feel comfortable with command substitutions, you could
    save yourself the intermediate variable and use the command substitution directly
    within the echo, like so: `echo "Your reversed input is: $(reverser ${user_input})"`.
    We would recommend not making it much more complex than this, however, since that
    will start to affect the readability.'
  prefs: []
  type: TYPE_NORMAL
- en: Function libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you get to this part of the book, you''ll have seen well over 50 example
    scripts. Many of these scripts have some shared components: input checking, error
    handling, and setting the current working directory have been used in multiple
    scripts. This code doesn''t really change; perhaps the comments or echoes were
    slightly different, but in reality it''s just duplicated code. Pair this with
    the problem of having to define functions at the top of your script (or, at the
    very least, before you start using them) and your maintainability is beginning
    to suffer. Luckily for us all, there is a great solution for this: **creating
    your own function library!**'
  prefs: []
  type: TYPE_NORMAL
- en: Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of a function library is that you define functions that are *shared*
    between different scripts. These are repeatable, generic functions that do not
    care too much about the specific script to work. When you create a new script,
    the first thing you''ll do, right after the header, is *include the function definitions
    from the library.* The library is nothing more than another shell script: however,
    it is only used to define functions, so it never calls anything. If you were to
    run it, the end result would be the same as if you had run an empty script. We''ll
    start creating our very own function library first, before we look at how we can
    include it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one real consideration when creating a function library: where
    to put it. You want to have it present just once in your filesystem, preferably
    in a predictable location. Personally, we prefer the `/opt/` directory. However,
    by default `/opt/` is only writable to the `root` user. In a multiuser system,
    it''s probably not a bad idea to place it there, owned by `root` and readable
    by everyone, but since this is a single-user situation, we''ll place it directly
    in our home directory. Let''s make a humble beginning with our library there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is a generic function, we need to first supply the number of arguments
    we''re expecting, followed by the actual arguments. After we save the expected
    number of arguments, we use `shift` to *shift* all arguments one place to the
    left: `$2` becomes `$1`, `$3` becomes `$2`, and `$1` is removed entirely. Doing
    this, only the number of arguments to check remains, with the expected number
    safely stored inside a variable. We then compare the two values, and if they''re
    not the same, we return an exit code of `1`. `return` is similar to `exit`, but
    it does not stop the script execution: if we want to do that, the script calling
    the function should take care of this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this library function within another script, we''ll need to include
    it. In Bash, this is called *sourcing*. Sourcing is achieved with the `source`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is simple. As soon as you `source` a file, all its contents will
    be processed. In our library case, when we only define functions, nothing will
    be executed but we''ll have the functions available. If you''re sourcing a file
    that contains actual commands, such as `echo`, `cat`, or `mkdir`, these commands
    *will be executed.* As always, an example is worth a thousand words, so let''s
    see how we can use `source` to include the library functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty simple right? We source the file using a fully qualified path (yes,
    even though `~` is shorthand, this is still fully qualified!) and go right on
    with using the function that was defined in the other script. If you run this
    with debug, you''ll see that the function works as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first and third function call are expected to be correct, whereas the second
    should fail. Because we used `return` and not `exit` in our function, the script
    continues even after the second function call returns an exit status of `1`. As
    the debug output shows, the second time we call the function, the evaluation `2
    not equals 3` is performed and succeeds, which results in `return 1`. For the
    other calls, the arguments are correct and the default return code of `0` is returned
    (not shown from output, but this is really what happens; add `echo $?` if you
    want to verify for yourself).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to use this in an actual script, we''ll need to pass all arguments the
    user gives us to our function. This can be done using the `$@` syntax: where `$#`
    corresponds to the number of arguments, `$@` simply prints all arguments. We''ll
    update `argument-checker.sh` to check arguments to the script as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the expected amount of arguments, `2`, and all arguments received by
    the script, `$@`, to our sourced function. Run it with a few different inputs
    and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent, everything seems to be working! The most interesting tries are probably
    the last two, since they illustrate the problem often posed by *word splitting*.
    By default, Bash will interpret every piece of whitespace as a separator. In the
    fourth example, we pass the `"1 2"` string, which is actually *a single argument
    because of the quotes*. If we did not use double quotes around `$@`, this would
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Bash passes the arguments to the function without preserving
    the quotes. The function would then receive `"1"` and `"2"`, instead of `"1 2"`.
    Something to watch out for, always!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use a predefined function to check if the number of arguments is
    correct. However, currently we do not use our return code for anything. We''re
    going to make one final adjustment to our `argument-checker.sh` script, which
    will stop script execution if the number of arguments is not correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the page width of this book, we''ve broken the line with `check_arguments`
    in two by using `\`: this signals to Bash to continue on the next line. You can
    omit this and have the full command on a single line, if you prefer. If we run
    the script now, we''ll see desirable script execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, we have begun the creation of a function library and have successfully
    used it in one of our scripts!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a somewhat confusing shorthand syntax for source: a single dot (`.`).
    If we wanted to use that shorthand in our scripts, it would simply be `. ~/bash-function-library.sh`.
    We are, however, not big fans of this syntax: the `source` command is not long
    or complicated, while a single `.` can easily be missed or misused if you forget
    a space after it (which can be hard to see!). Our advice: know the shorthand exists
    if you encounter it somewhere in the wild, but use the full built-in source when
    writing scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: More practical examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to spend the last part of this chapter expanding your function library
    with commonly used actions from earlier scripts. We'll copy a script from one
    of the earlier chapters and use our function library to replace functionality
    that can then be handled with a function from our library.
  prefs: []
  type: TYPE_NORMAL
- en: Current working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first candidate for inclusion in our own private function library is correctly
    setting the current working directory. This is a pretty simple function, so we''ll
    add it without too much explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because a function library is something that is potentially updated quite frequently,
    correctly updating the information in the header is very important. Preferably
    (and most likely in an enterprise environment), you will commit new versions of
    your function library to a version control system. Using proper Semantic Version
    in the header will help you keep a clean history. Particularly, if you combine
    this with configuration management tooling such as Chef.io, Puppet, and Ansible,
    you will keep a good overview of what you've changed and deployed to where.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll update our script from the previous chapter, `redirect-to-file.sh`,
    with our library inclusion and function call. The end result should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For teaching purposes, we''ve copied the file to the directory of the current
    chapter; normally, we would just update our original file. We''ve only added the
    inclusion of our function library and replaced the magical `cd $(dirname $0)`
    with our `set_cwd` function call. Let''s run it from a location where the script
    is not and see if the directory is correctly set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, even though we used the `$0` syntax (which, as you remember, prints the
    fully qualified path of the script), we see here that it refers to the path of
    `library-redirect-to-file.sh` and not, as you might have reasonably assumed, to
    the location of the `bash-function-library.sh` script. This should confirm our
    explanation that only function definitions are included, and when the functions
    are called at runtime they take on the environment of the script that includes
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Something we''ve done in many of our scripts is checking arguments. We started
    our library with a function that allowed checking the number of arguments the
    user gave as input. Another action we frequently performed on user input was validating
    the input type. If our script requires a number, for example, we''d like the user
    to actually enter a number and not a word (or a written out number, such as ''eleven'').
    You might remember the approximate syntax, but I''m sure that by now if you needed
    it again, you would look through our older scripts to find it. Doesn''t that sound
    like the ideal candidate for a library function? We create and thoroughly test
    our function once, and then we can feel safe just sourcing and using it! Let''s
    create a function that checks if a passed argument is actually an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Because we're dealing with a library function, we can be a little more verbose
    for the sake of readability. Too much verbosity in a regular script will reduce
    readability, but as soon as someone is looking at the function library for understanding,
    you can assume they'll like some more verbose scripting. After all, when we call
    the function in a script we'll only see `check_integer ${variable}`.
  prefs: []
  type: TYPE_NORMAL
- en: On to the function. We first check if we've received a single argument. If we
    did not receive that, we exit instead of return. Why would we do this? The script
    that calls should not be confused about what a return code of `1` means; if it
    can mean that we either did not check anything, but also that the check itself
    failed, we're bringing ambiguity where we don't want it. So simply said, return
    always tells the caller something about the passed argument, and if the script
    calls the function wrong, it will see the full script exit with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the regular expression we constructed in [Chapter 10](d3b18cbd-f152-498a-b7b8-79da604e66b4.xhtml),
    *Regular Expressions*, to check if the argument is in fact an integer. If it is,
    we return `0`. If it is not, we'll hit the `else` block and `1` will be returned.
    To emphasize this point to someone reading the library, we included the `# Is
    an integer` and `# Is not an integer` comments. Why not make it easy on them?
    Remember, you do not always write it for someone else, but if you look at your
    own code a year later, you will definitely also feel like *someone else* (again,
    you can trust us on this!).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do another search-replace from one of our earlier scripts. A suitable
    one from the previous chapter, `password-generator.sh`, will serve this purpose
    nicely. Copy it to a new file, load the function library with source, and replace
    the argument checks (yes, both!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re replaced both the number of arguments check and the integer check with
    our library functions. We''ve also removed the variable declaration and used `$1`
    directly in the functional part of the script; this is not always the best thing
    to do. However, when input is only used once, first storing it in a named variable
    creates some overhead which we might skip. Even with all the whitespace and comments,
    we still managed to reduce the script lines from 31 to 26 by using function calls.
    When we call our new and improved script, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Great, our checks are working as expected. Looks much better too, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Yes-no check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll show one more check before we finish this chapter. Halfway through the
    book, in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml), *Error Checking
    and* *Handling*,we presented a script that dealt with a user that could supply
    either a 'yes' or a 'no'. But, as we explained there, the user might also use
    'y' or 'n', and perhaps even a capital letter in there somewhere. By secretly
    using a little Bash expansion, which you will see properly explained in [Chapter
    16](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml), *Bash Parameter Substitution
    and Expansion*, we were able to make a relatively clear check for user input.
    Let's get that thing in our library!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve got a little advanced scripting cooked up for you with this example.
    Instead of a binary return, we now have four possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Function incorrectly called: `exit 1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function found a yes: `return 0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function found a no: `return 1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function found neither: `exit 2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our new library function, we''ll take the `yes-no-optimized.sh` script
    and replace the complex logic with (almost) a single function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a minute to look at the preceding script. It will probably be a little
    confusing at first, but try to remember what `&&` and `||` do. Because of some
    smart ordering we applied, we can use `&&` and `||` in sequence to achieve our
    result. Look at it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: If `check_yes_no` returns an exit status of 0 (when a **yes** is found), the
    command after && is executed. Since that echoes the success, and `echo` has an
    exit code of 0, the failure `echo` after the next `||` is not executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `check_yes_no` returns an exit status of 1 (when a **no** is found), the
    command after && is not executed. However, it continues until it reaches `||`,
    which goes on to the failure echo since the return code was still *not* 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `check_yes_no` exits on either the lack of argument or lack of yes/no, the
    commands after both `&&` and `||` are not executed (because the script is given
    an `exit` instead of `return`, so code execution is stopped immediately).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pretty clever right? However, we must admit, it''s a little against most things
    we''ve been teaching you with regards to readability. Consider this a teaching
    exercise for chaining `&&` and `||` instead. If you''d want to implement the yes-no
    check yourself, it would probably be better to create dedicated `check_yes()`
    and `check_no()` functions. In any case, let''s see if our tricked out script
    actually works as we hope it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All scenarios as we've defined them in the check work out. Great success!
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you do not want to mix exit and return codes too much. Also, using
    a return code to convey anything other than pass or fail is also pretty uncommon.
    However, since you can return 256 different codes (from 0 up to 255), this is
    at least possible by design. Our yes-no example was a good candidate for showing
    how this could be used. However, as a general tip, you're probably better off
    by using it in a pass/fail way, as currently you place the burden of knowing the
    different return codes on the caller. Which is, to say the least, not always a
    fair thing to ask of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like to end this chapter with a small exercise for you. In this chapter,
    before we introduced the function library, we already created a few functions:
    two for error handling, one for colored printing, and one for reversing text.
    Your exercise is simple: grab those functions and add them to your personal function
    library. Make sure to keep the following things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Are the functions verbose enough to be included in the library as is, or could
    they use more?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we call the functions and deal with the output as is, or would an edit be
    preferable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are returns and exits properly implemented, or do they need to be adjusted to
    work as a generic library function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no right or wrong answers here, just things to consider. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have presented Bash functions. Functions are generic chains
    of commands that can be defined once, before being called multiple times. Functions
    are reusable and can be shared between multiple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable scopes were introduced. The variables we''ve seen thus far were always
    *globally* scoped: they were available to the entire script. However, with the
    introduction of functions, we encounter *locally* scoped variables. These are
    only accessible within a function and marked with the `local` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned that functions can have their own independent set of parameters,
    which can be passed as arguments when the function is called. We proved that these
    are in fact different from the global arguments passed to the script (unless all
    arguments are passed through to the function, of course). We gave an example about
    returning output from a function using `stdout`, which we could capture by encapsulating
    the function call in a command substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second half of this chapter, we turned our attention to creating a function
    library: an independent script without actual commands, which can be included
    (via the `source` command) in another script. As soon as the library is sourced
    in another script, all functions defined in the library can then be used by the
    script. We spent the remainder of this chapter showing how this was done, while
    simultaneously expanding our function library with some practical utility functions.'
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with an exercise for the reader, to make sure all functions
    defined in this chapter are included in their own personal function library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `top`, `free`, `declare`,
    `case`, `rev`, and `return`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In which two ways can we define a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some advantages of functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a globally scoped variable and a locally scoped
    one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we set values and attributes to variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a function use arguments passed to it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we return a value from a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `source` command do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we want to create a function library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Linux performance monitoring**: [https://linoxide.com/monitoring-2/linux-performance-monitoring-tools/](https://linoxide.com/monitoring-2/linux-performance-monitoring-tools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWK basic tutorial**: [https://mistonline.in/wp/awk-basic-tutorial-with-examples/](https://mistonline.in/wp/awk-basic-tutorial-with-examples/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Bash variables**: [https://www.thegeekstuff.com/2010/05/bash-variables/](https://www.thegeekstuff.com/2010/05/bash-variables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sourcing**: [https://bash.cyberciti.biz/guide/Source_command](https://bash.cyberciti.biz/guide/Source_command)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
