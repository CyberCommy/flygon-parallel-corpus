- en: Chapter 5. Web Application Information Gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up API keys for recon-ng
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using recon-ng for reconnaissance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering information using theharvester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using DNS protocol for information gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application firewall detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP and DNS load balancer detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering hidden files/directories using DirBuster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMS and plugins detection using WhatWeb and p0f
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding SSL cipher vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important phases of an attack is information gathering.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to launch a successful attack, we need to gather as much as information
    as possible about our target. So, the more information we get, the higher the
    probability of a successful attack.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that not only gathering information but documenting
    it with clarity is of utmost importance. The Kali Linux release has several tools
    for documenting, collating and organizing information from various target machines,
    enabling a better reconnaissance. Tools such as **Dradis**, **CaseFile**, and
    **KeepNote** are some examples of it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up API keys for recon-ng
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how we need to set up API keys before starting to
    use recon-ng. Recon-ng is one of the most powerful information gathering tools;
    if used properly, it can help pentesters gather a fairly good amount of information
    from public sources. With the latest version available, recon-ng provides the
    flexibility to set it up as your own app/clients in various social networking
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection and a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set up recon-ng API Keys, open the terminal, launch recon-ng, and type the
    commands shown in the following screenshot:![How to do it...](img/image_05_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, type `keys list`, as shown in the following screenshot:![How to do it...](img/image_05_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by adding `twitter_api` and `twitter_secret`. Log in to Twitter,
    go to [https://apps.twitter.com/](https://apps.twitter.com/) , and create a new
    application, as shown in the following screenshot:![How to do it...](img/image_05_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create Application**; once the application is created, navigate to
    the **Keys and Access Tokens** tab and copy the secret key and API key, as shown
    in the following screenshot:![How to do it...](img/image_05_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the API key, re-open the terminal window, and run the following command
    to add the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use the following command to enter the `twitter_secret` in recon-ng:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have added the keys, you can see the keys added in the recon-ng tool
    by entering the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add the Shodan API key. Adding the Shodan API key is fairly simple;
    all you need to do is create an account at [https://shodan.io](https://shodan.io)
    and click on **My Account** in the top-right corner. You will see the **Account
    Overview** page, where you can see a QR code image and API key, as shown in the
    following screenshot:![How to do it...](img/image_05_005.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the API key shown in your account and add that in recon-ng using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have learned how we can add API keys into the recon-ng tool.
    Here, to demonstrate this, we have created a Twitter application, used `twitter_api`
    and `twitter_secret`, and added them into the recon-ng tool. The result is as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, you will need to include all the API keys here in recon-ng if you
    want to gather information from these sources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how to use recon-ng for information gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Using recon-ng for reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use recon-ng for reconnaissance. Recon-ng is
    a full-featured web reconnaissance framework written in Python. Complete with
    independent modules, database interaction, built-in convenience functions, interactive
    help, and command completion, recon-ng provides a powerful environment in which
    open source web-based reconnaissance can be conducted quickly and thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before installing Kali Linux, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a terminal and start the recon-ng framework, as shown in the following
    screenshot:![How to do it...](img/image_05_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recon-ng has a look and feel like Metasploit. To see all the available modules,
    enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Recon-ng will list all the available modules, as shown in the following screenshot:![How
    to do it...](img/image_05_008.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and use our first module for information gathering; enter the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, enter the commands shown in the following screenshot:![How to do it...](img/image_05_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, there have been some vulnerabilities discovered and they are
    available publically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s use another module that fetches any known and reported vulnerabilities
    from [xssed.com](http://xssed.com/) . The XSSed project was created in early February
    2007 by KF and DP. It provides information on all things related to cross-site
    scripting vulnerabilities and is the largest online archive of XSS vulnerable
    websites. It''s a good repository of XSS to gather information. To begin with,
    enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, recon-ng has aggregated publically available vulnerabilities
    from XSSed, as shown in the following screenshot:![How to do it...](img/image_05_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you can keep using the different modules until and unless you get
    the required information regarding your target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gathering information using theharvester
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use theharvester. The objective of this program
    is to gather e-mails, subdomains, hosts, employee names, open ports, and banners
    from different public sources, such as search engines, PGP key servers, and the
    Shodan computer database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the terminal and start theharvester, as shown in the following screenshot:![How
    to do it...](img/image_05_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Theharvester help shows the example syntax also. For the purpose of our demonstration,
    we will be using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Successful execution of the preceding command gives the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, theharvester searches different sources such as search engines,
    PGP key servers, and the Shodan computer database for information. It is also
    useful for anyone who wants to know what an attacker can see about their organization.
    You can visit [http://tools.kali.org/information-gathering/theharvester](http://tools.kali.org/information-gathering/theharvester)
    for more information, such as the project home page and GitHub code repository.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, `-d` stands for domain, `-l` limits the number of results, and `-b`
    stands for data source. In our case, we have `-b` as a means to look for e-mails
    and public hosts available in data sources.
  prefs: []
  type: TYPE_NORMAL
- en: Using DNS protocol for information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use the various tools/scripts available to
    gather information regarding your web application domain. **DNS** stands for **Domain
    Name System** and can provide you with a great deal of information if you are
    performing black-box testing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use DNSenum for DNS enumeration. To start DNS enumeration, open the
    terminal and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We should get an output with information such as host, name server(s), e-mail
    server(s), and if we are lucky, a zone transfer:![How to do it...](img/image_05_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the DNSRecon tool is also available in Kali Linux. DNSRecon is usually
    the preferred choice over any other tool as it is more reliable, results are properly
    parsed, and it can be easily imported into other vulnerability assessment and
    exploitation tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use DNSRecon, open the terminal and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The enumeration results output is as follows:![How to do it...](img/image_05_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have used DNSenum to enumerate various DNS records, such
    as NS, MX, SOA, and PTR records. DNSenum also tries to perform DNS zone transfer,
    if vulnerable. However, DNSRecon is a more powerful DNS tool. It has highly reliable,
    better result parsing and better integration of results in other VA/exploitation
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, command `-d` is used for scan domain switch, capital `-D` is used
    to perform dictionary brute force on hostnames, parameters of the `-D` should
    point to a wordlist, for example `/usr/share/wordlists/dnsmap.txt`, to specify
    this is a standard scan we used the (`-t std`) switch and saved the output to
    a file (`-xml dnsrecon.xml`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple scripts available in Kali Linux, some of them more or less
    do the same thing. Based on your assessment type and time available, you should
    consider using the following DNS tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNSMap**: DNSmap is mainly meant to be used by pen testers during the information
    gathering/enumeration phase of infrastructure security assessments. During the
    enumeration stage, the security consultant would typically discover the target
    company''s IP netblocks, domain names, phone numbers, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DNSTracer**: This determines where a given DNS gets its information from
    and follows the chain of DNS servers back to the servers which know the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fierce**: This is meant specifically to locate likely targets, both inside
    and outside a corporate network. Only those targets are listed (unless the `-nopattern`
    switch is used). No exploitation is performed (unless you do something intentionally
    malicious with the `-connect` switch). Fierce is a reconnaissance tool. Fierce
    is a Perl script that quickly scans domains (usually in just a few minutes, assuming
    no network lag) using several tactics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application firewall detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use a tool called **WAFW00F**. WAFW00F identifies
    and fingerprints **web application firewall** (**WAF**) products.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WAFW00F is fairly simple and easy to use. Just open the terminal and enter
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_05_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, you can just keep changing the target domain to find the existence
    of the web application firewall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have used WAFW00F to identify if we do have any web application
    firewall running. Detecting a web application firewall accurately can help you
    save a lot of hours later, during penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'WAFW00F works in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: It sends a normal HTTP request and analyzes the response; this identifies a
    number of WAF solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that is not successful, it sends a number of (potentially malicious) HTTP
    requests and uses simple logic to deduce which WAF it is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that is also unsuccessful, it analyzes the responses previously returned
    and uses another simple algorithm to guess whether a WAF or security solution
    is actively responding to our attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further details, check out the source code on the main site, [github.com/sandrogauci/wafw00f](http://github.com/sandrogauci/wafw00f)
    .
  prefs: []
  type: TYPE_NORMAL
- en: HTTP and DNS load balancer detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to detect HTTP and DNS load balancer using
    lbd. **Lbd** (**load balancing detector**) detects whether a given domain uses
    DNS and/or HTTP load-balancing (via server and date: header and diffs between
    server answers).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the terminal and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Successful detection of HTTP and DNS load balancer results in the following
    output:![How to do it...](img/image_05_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another example where DNS load balancer was detected and HTTP load balancing
    was detected is shown in the following screenshot:![How to do it...](img/image_05_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing that needs to be understood here is that lbd is not completely reliable;
    it is just a proof of concept to check whether load balancing is done. One can
    read on the terminal that it may generate false positives, but it is a great tool
    to have.![How to do it...](img/image_05_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another tool that can help us understand whether a DNS-based load balancer
    is actually present or not is the dig tool. Let''s look at it in more detail;
    enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ANSWER SECTION` shows the different DNS-based load balancers available
    for [microsoft.com](http://microsoft.com). A tool for testing a HTTP-based load
    balancer is Halberd. In order to check how Halberd works, type the following in
    the Kali terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have used lbd to find DNS and HTTP load balancers. Having
    this information in the early stages of a pen test can save many hours, as you
    would choose your tools and methodology appropriately, finding web application
    security issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command `lbd kali.org` is very simple. Ldb is the tool name and it takes
    one parameter, that is, the domain or IP name which needs to be checked. The workings
    of the preceding tools are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lbd**: This tool performs load balancing based on two parameters: DNS and
    HTTP. For DNS, it generally works on the round-robin technique to determine whether
    there are multiple load balancers. For HTTP, load balancing is checked via cookies;
    it checks via the session state whether different requests are sent and received
    by the actual servers residing behind the load balancer. The other HTTP method
    is the timestamp; it tries to detect differences in the timestamp to help us detect
    whether there is a presence of load balancer. In the preceding example, we see
    that the load balancer is differentiated on the basis of content length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DIG**: This stands for **Domain Information Groper**, which is a Linux command
    that enumerates details of the given domain. We make use of the A record to check
    the available DNS servers on the groper to determine whether there is a presence
    of DNS-based load balancer. Multiple entries of A records generally suggest that
    there is a presence of DNS load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Halberd**: This is an HTTP-based load balancer detector. It checks for differences
    in the HTTP response headers, cookies, timestamps, and so on. Any difference in
    the mentioned parameters will prove that there is an HTTP-based load balancer
    present. In the preceding example, we check whether there is an HTTP-based load
    balancer on VMware and, if we see there are two different instances detected,
    one having an Akamai header and the other not having the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering hidden files/directories using DirBuster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use the DirBuster tool. The DirBuster tool
    looks for hidden directories and files on the web server. Sometimes, developers
    will leave a page accessible but unlinked; DirBuster is meant to find these files,
    which might have potential vulnerabilities. This is a Java-based application developed
    by awesome contributors at OWASP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch DirBuster from the **Kali Linux** | **Web Application Analysis** | **Web
    Crawlers and Directory Brute** | **Dirbuster**, as shown in the following screenshot:![How
    to do it...](img/image_05_021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open DirBuster and enter your target URL; in our case, we will enter `http://demo.testfire.net`
    for the purpose of demonstration, as shown in the following screenshot:![How to
    do it...](img/image_05_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select list based brute force. Browse and navigate to `/usr/share/dirbuster/wordlists`
    and select `directory_list_medium.txt`, as shown in the following screenshot:![How
    to do it...](img/image_05_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Select List** and enter `php` (based on the technology used by target)
    in the file extension column, as shown in the following screenshot:![How to do
    it...](img/image_05_024.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Start** and DirBuster will start brute forcing directories and files,
    as shown in the following screenshot:![How to do it...](img/image_05_025.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, DirBuster has started brute forcing files and directories. You
    can click on the **Response** column to sort all files/folders with **200** HTTP
    code, as shown in the following screenshot:![How to do it...](img/image_05_026.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can spend some time going to each of these links and investigating which
    ones look interesting and could be used for further attacks. For example, in our
    case file, the `/pr/docs.xml` file seems to be the standalone file sitting on
    the server which isn't being mentioned in sitemap or `robots.txt` file. Right-click
    on that entry and select **Open In Browser**, as shown in the following screenshot:![How
    to do it...](img/image_05_027.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file has been opened in the browser; as you can see, this is an XML file,
    which wasn't supposed to be a public file and it's not linked anywhere in the
    application but is accessible, as shown in the following screenshot:![How to do
    it...](img/image_05_028.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you can keep investigating other files and folders which can divulge
    a good amount of information, or some backup files or development pages, which
    may have vulnerabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have used DirBuster to locate hidden directories and files
    available on the web server. DirBuster has a dictionary file generated of the
    most common web server directories and it reads values from the dictionary and
    makes a request to the webserver to check its existence. If the server returns
    200 HTTP header code, it means the directory exists; if the server returns a 404
    HTTP header code, it means the directory does not exist. However, it is important
    to note that HTTP status codes of 401 and 403 may also point to a file or directory
    being present, but not allowed to be opened unless authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, a few applications which have been architected well also return
    200 OK for unknown files and folders, just to mess with tools such as DirBuster.
    Therefore, it is important to understand how the application is behaving, based
    on which you could further tune your scans policies and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we were able to locate certain files and folders which were not linked
    within the application but were available on the web server.
  prefs: []
  type: TYPE_NORMAL
- en: CMS and plugins detection using WhatWeb and p0f
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use different tools available in Kali, which
    we can use to determine the plugins that are installed. If applications are built
    based on CMSes, it is very likely that they would be using certain plugins. Major
    vulnerabilities that exist are usually in third-party plugins that developers
    use in these CMSes. Finding out the installed plugins and their versions can help
    you to look for exploits available for vulnerable plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with our first tool in Kali Linux which is **WhatWeb**. WhatWeb
    identifies websites. Its goal is to answer the question, "What is that Website?"
    WhatWeb recognizes web technologies, including **content management systems**
    (**CMS**), blogging platforms, statistic/analytics packages, JavaScript libraries,
    web servers, and embedded devices. WhatWeb has over 900 plugins, each to recognize
    something different. WhatWeb also identifies version numbers, e-mail addresses,
    account IDs, web framework modules, SQL errors, and more. WhatWeb is very easy
    to use. Open the terminal and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_05_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it has been very accurate in finding that it is a WordPress
    installation. It has also detected common plugins used by DNS and HTTP load balancer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's say you have figured out that one of your targets is using WordPress or
    Drupal as a CMS and you want to go a step ahead and look for the installed plugins,
    their version, and the latest available version of that plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plecost is another popular tool in Kali for detecting CMS plugins and a WordPress
    fingerprinting tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal and enter the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This syntax means use 100 plugins (`-n 100`), sleep for 10 seconds between probes
    (`-s 10`), but no more than 15 (`-M 15`), and use the plugin list (`-i /usr/share/plecost/wp_plugin_list.txt`)
    to scan the given URL (`ishangirdhar.com`).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned to use WhatWeb, which very accurately fingerprints
    the server and provides detailed information of CMS, plugins, web server version,
    and programming languages used, and HTTP and DNS load balancers. Later in this
    recipe, we also learned to use plecost to scan WordPress installations to fingerprint
    the installed WordPress plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Most WhatWeb plugins are thorough and recognize a range of cues from the subtle
    to the obvious. For example, most WordPress websites can be identified by the
    meta HTML tag, but a minority of WordPress websites remove this identifying tag,
    although this does not thwart WhatWeb. The WordPress WhatWeb plugin has over 15
    tests, which include checking the favicon, default installation files, login pages,
    and checking for `/wp-content/` within relative links.
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress fingerprinting tool called **plecost**, searches and retrieves
    information about the plugins and their version on a WordPress running server..
    It can analyze a single URL or perform an analysis based on the results indexed
    by Google. Additionally, it displays CVE code associated with each plugin, if
    there is any. Plecost retrieves the information contained on websites supported
    by WordPress and also allows a search on the results indexed by Google.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other than what we have just seen, there are other tools available as well.
    For example, for scanning WordPress, Drupal, and Joomla, there are tools available
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WpScan**: [http://wpscan.org/](http://wpscan.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DrupalScan**: [https://github.com/rverton/DrupalScan](https://github.com/rverton/DrupalScan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Joomscan**: [http://sourceforge.net/projects/joomscan/](http://sourceforge.net/projects/joomscan/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding SSL cipher vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to use tools to scan for vulnerable SSL ciphers
    and SSL-related vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will require an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the terminal and launch the SSLScan tool, as shown in the following screenshot:![How
    to do it...](img/image_05_030.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To scan your target using SSLScan, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'SSLScan will test the SSL certificate for the all the ciphers it supports.
    Weak ciphers will be shown in red and yellow. Strong ciphers will be shown in
    green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our next tool is SSLyze, which is developed by iSEC Partners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and invoke SSLyze help, as shown in the following screenshot:![How
    to do it...](img/image_05_031.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test a domain for a comprehensive list of supported ciphers, enter the following
    command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the server is running SSL on port `443`, the output should be like this:![How
    to do it...](img/image_05_032.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last tool in this recipe is TLSSLed. Open a terminal and invoke the tool,
    as shown in the following screenshot:![How to do it...](img/image_05_033.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now start TLSSLed using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: TLSSEled also shows all the cookies, which have secure and HttpOnly flags set
    or not, which can be useful information later while exploiting the application
    using XSS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have used three tools for scanning SSL certificates on target
    domains for weak ciphers and SSL vulnerabilities, such as Heartbleed. Each of
    these tools has their unique way of representing information. SSLScan looks to
    check whether the target is vulnerable to Heartbleed or not, in addition to scanning
    it for weak ciphers. SSLyze specializes in speed and it supports StartTLS handshake
    on SMTP, XMPP, LDAP, POP, IMAP, RDP, and FTP protocols also. TLSSLed is a tool
    created to use SSLScan, but it provides more information.
  prefs: []
  type: TYPE_NORMAL
- en: SSLyze is a Python tool that can analyze the SSL configuration of a server by
    connecting to it. It is designed to be fast and comprehensive, and should help
    organizations and testers identify misconfigurations affecting their SSL servers.
    SSLyze is developed by iSEC Partners.
  prefs: []
  type: TYPE_NORMAL
- en: TLSSLed is a Linux shell script whose purpose is to evaluate the security of
    a target SSL/TLS (HTTPS) web server implementation. It is based on SSLScan, a
    thorough SSL/TLS scanner that is based on the OpenSSL library, and on the `openssl
    s_client` command-line tool. The current tests include checking whether the target
    supports the SSLv2 protocol, the null cipher, and weak ciphers based on their
    key length (40 or 56 bits), the availability of strong ciphers (such as AES),
    whether the digital certificate is MD5 signed, and the current SSL/TLS renegotiation
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, you should also thoroughly look out for certificate errors. You
    could also discover associated domains and subdomains belonging to the same organization
    based on certificate errors as, at times, organizations buy SSL certificates for
    different domains but reuse them, which would also cause an invalid certificate
    name error.
  prefs: []
  type: TYPE_NORMAL
