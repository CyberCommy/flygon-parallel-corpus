- en: Chapter 8. 3D Model Viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three-dimensional models are everywhere, from mechanical engineering of machine
    parts to medical imaging; from video game design to 3D printing. 3D models are
    as prolific as photos, videos, music, and other media. Yet, while browsers and
    apps have native support for other media types, 3D models do not have so much.
    One day 3D viewing standards will be integrated into the browser (such as WebGL
    and WebVR). Until then, we'll have to rely on plugins and sister apps to view
    our models. Free 3D file models in the OBJ format, for example, can be found online,
    including TF3DM ([http://tf3dm.com/](http://tf3dm.com/)), TurboSquid ([http://www.turbosquid.com/](http://www.turbosquid.com/)),
    and many others ([http://www.hongkiat.com/blog/60-excellent-free-3d-model-websites/](http://www.hongkiat.com/blog/60-excellent-free-3d-model-websites/)).
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we will build an Android 3D model viewer app that lets you
    open and view models in 3D using a Cardboard VR headset. The file format that
    we'll use is OBJ, an open format first developed by Wavefront Technologies for
    cinematic 3D animation. OBJs can be created and exported by many 3D design applications,
    including open source ones, such as Blender and MeshLab, as well as commercial
    ones, such as 3D Studio Max and Maya. An OBJ is a noncompressed plain text file
    that stores a description of the surface mesh of a 3D object composed of triangles
    (or higher degree polygons).
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the viewer, we will read and parse OBJ file models and display
    them in 3D for viewing with Cardboard. We will accomplish this by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an OBJ file parser to import the geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the 3D model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating the view of the object using the user's head motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/modelviewer](https://github.com/cardbookvr/modelviewer)
    (with each topic as a separate commit).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build this project, we''re going to use our `RenderBox` library created
    in [Chapter 5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*. You
    can use yours, or grab a copy from the downloadable files provided with this book
    or from our GitHub repository (use the commit tagged `after-ch7`—[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch7](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch7)).
    For a more detailed description of how to import the `RenderBox` library, refer
    to the final section, *Using RenderBox in future projects*, of [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine*. To create a new project, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With Android Studio opened, create a new project. Let's name it `Gallery360`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create new modules for the `renderbox`, `common` and `core` packages, using
    **File** | **New Module** | **Import .JAR/.AAR Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the modules as dependencies for the app, using **File** | **Project Structure.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as explained
    in the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `MainActivity` as `class MainActivity extends CardboardActivity implements
    IRenderBox`, and implement the interface method stubs (*Ctrl* + *I*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can go ahead and define the `onCreate` method in `MainActivity`. The class
    now has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a cube to the scene, temporarily, to help ensure that everything
    is set up properly. Add it to the `setup` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you remember, a `Cube` is a `Component` that's added to a `Transform`. The
    `Cube` defines its geometry (for example, vertices). The `Transform` defines its
    position, rotation, and scale in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to click on **Run 'app'** with no compile errors and see
    the cube and Cardboard split screen view on your Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OBJ file format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this project is to view 3D models in the Wavefront OBJ format. Before
    we begin coding, let's take a look at the file format. A reference can be found
    at [http://www.fileformat.info/format/wavefrontobj/egff.htm](http://www.fileformat.info/format/wavefrontobj/egff.htm).
  prefs: []
  type: TYPE_NORMAL
- en: As we know, 3D models can be represented as a mesh of X, Y, and Z vertices.
    Sets of vertices are connected to define a face of the mesh surface. A full mesh
    surface is a collection of these faces.
  prefs: []
  type: TYPE_NORMAL
- en: Each vertex can also be assigned a normal vector and/or a texture coordinate.
    The normal vector defines the outward facing direction at that vertex, used in
    lighting calculations. The UV texture coordinate can be used to map texture images
    onto the mesh surface. There are other features of the format, including free-form
    curves and materials, which we will not support in this project.
  prefs: []
  type: TYPE_NORMAL
- en: As a plain text file, an OBJ is organized as separate lines of text. Each nonblank
    line begins with a keyword and data for that keyword separated by spaces. Comments
    begin with `#` and are ignored by the parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OBJ data keywords include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v`: Geometric vertices (for example, `v 0.0 1.0 0.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vt`: Texture vertices (for example, `vt 0.0 1.0 0.0`) [not supported in our
    project]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vn`: Vertex normals (for example, `vn 0.0 1.0 0.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: Polygonal face indexes (for example, `f 1 2 3`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The face values are indices pointing into the vertices list into the vertices
    (starting at 1 for the first one).
  prefs: []
  type: TYPE_NORMAL
- en: As for the `f` command specifying face indices, they're integer values that
    index into the vertex list. When there are three indices, it describes a triangle;
    four describes a quad, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When texture vertices exist, they are referenced as the second number after
    a slash, for example, `f 1/1 2/2 3/3`. We're not supporting them now, but we might
    need to parse them in an `f` command. When vertex normals exist, they are referenced
    as the third number after a slash, for example, `f 1//1 2//2 3//3` or `f 1/1/1
    2/2/2 3/3/3`.
  prefs: []
  type: TYPE_NORMAL
- en: Indices can be negative, in which case they reference the last (most recently
    encountered) item as -1, the previous one as -2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Other lines, including data that we are not supporting here, will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following data represents a simple triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our OBJ implementation is limited. It safely handles the example models included
    with this book, and perhaps others that you'll find on the Internet or make yourself.
    However, this is an example code and a demonstration project. Writing a robust
    data importer and supporting the many features of OBJ in our `RenderBox` engine
    is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ModelObject class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, we will define a `ModelObject` class that extends `RenderObject`.
    It will load model data from OBJ files and set up buffers needed by its material
    (and OpenGL ES shaders to be rendered in the VR scene).
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `app/java/com.cardboardvr.modelviewer/` folder, go to **New**
    | **Java Class**, and name it `ModelObject`. Define it so that it `extends RenderObject`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we''ve done in the previous chapters, when introducing new kinds
    of `RenderObjects`, we''ll have one or more constructors that can instantiate
    a `Material` and set up buffers. For `ModelObject`, we''ll pass in a file resource
    handle, parse the file (refer to the next topic), and create a solid color material
    (initially, without lighting), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the material as follows. First, declare variables for the buffers (as
    we have done for other `RenderObjects` in the previous projects). These can be
    private, but our convention is to keep them public if we want to define new materials
    outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `createMaterial` method (which is called from the constructor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we implement the `parseObj` method.
  prefs: []
  type: TYPE_NORMAL
- en: Parse OBJ models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `parseObj` method will open the resource file as an `InputStream`. It reads
    one line at a time, parsing the command and data, building the model's list of
    vertices, normals, and indexes. Then, we build the buffers from the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, at the top of the `ModelObject` class, declare variables for the data
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write `parseObj` with placeholders for helper methods. We open the file,
    process each line, build the buffers, and handle potential IO errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseLine` code is pretty straightforward. The first token of the line
    is the one-or-two character command (such as `v`, `vn`, or `f`), followed by data
    values (either float coordinates or integer indexes). Here''s the code for `parseLine`
    and the parsers for the `v` and `vn` vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `f` line needs to handle various value cases.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `f` command that specifies face indices, they're integer values that
    index into the vertex list. When there are three indices, it describes a triangle,
    four describes a quad, and so on. Anything with more than three sides will need
    to be subdivided into triangles for our rendering with OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there can be any combination of index values, including formats such as
    `v` or `v/vt` or `v/vt/vn`, or even `v//vn`, `/vt/vn`, or `//vn`. (Remember that
    since we're not mapping textures, we will only use the first and third.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tackle the simplest case first, a triangle face:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider that there are more than three indices on the face. We need a
    method to triangulate the polygon. Let''s write that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it in `processFLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is applied to the face value `v` and also `v/vt` since we are skipping
    textures. I''ve also commented out the other two permutations of the face index
    values. The rest of this is mostly just brute force string parsing. The `v//vn`
    case is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `v/vt/vn` case is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, in the OBJ file format description, indices can be negative;
    in which case they need to be referenced from the end of the vertex list backward.
    This can be implemented by adding the index value to the size of the index list.
    To support this, in the preceding code, replace all `s--`; lines with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: buildBuffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step for the `parseObj` method is to build our shader buffers from
    the model data, that is, the `vertexBuffer`, `normalBuffer`, and `indexBuffer`
    variables. We can add that now to a `buildBuffers` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One caveat. We noticed that for the `RenderBox` coordinate system and shaders,
    it is necessary to invert the normals from the OBJ data (using `-f` rather than
    `f`). Actually, this depends on OBJ exporters (3Ds Max, Blender, and Maya). Some
    of them do and some don't flip normals. Unfortunately, there's no way to determine
    whether or not normals are flipped other than by viewing the model. For this reason,
    some OBJ importer/viewers provide (optional) functions to calculate normals from
    the face geometry rather than rely on the import data itself.
  prefs: []
  type: TYPE_NORMAL
- en: Model extents, scaling, and center
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D models come in all shapes and sizes. To view them in our app, we need to
    know the minimum and maximum boundaries of the model and its geometric center
    to scale and position it properly. Let's add this to `ModelObject` now.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `ModelObject` class, add the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the extents in the parser, before we parse the model data. The minimum
    extents are initialized to the maximum possible values; the maximum extents are
    initialized to the minimum possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than calculating the extents after the model is loaded, we''ll do it
    during the import process. As we add a new vertex to the vertex list, we''ll calculate
    the current extents. Add a call to `setExtents` in the `processVLine` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `setExtents` method can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s add a scalar method that will be useful when we add the model to
    the scene (as you''ll see in the next topic), to scale it to a normalized size
    with extents `-1` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try it out!
  prefs: []
  type: TYPE_NORMAL
- en: I'm a little teapot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For decades, 3D computer graphics researchers and developers have used this
    cute model of a teapot. It's a classic! The back story is that Martin Newell,
    the famous computer graphics pioneer and researcher, needed a model for his work,
    and his wife suggested that he model their teapot at home. The original is now
    on display at the Boston Computer Museum. We have included an OBJ version of this
    classic model with the downloadable files for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can choose your own OBJ file, but if you want to use the teapot,
    locate the `teapot.obj` file, and copy it to the `res/raw` folder (create the
    folder if necessary).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now load the model and try it. In `MainActivity`, add a variable at the top
    of the `MainActivity` class to hold the current model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `setup` method. Notice that we''re scaling it
    to a fraction of the original size and placing it 3 units in front of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project, and it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![I''m a little teapot](img/B05144_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the model was successfully loaded and rendered. Unfortunately,
    the shading is difficult to discern. To get a better view of the shaded teapot,
    let''s shift it down a bit. Modify the `setLocalPosition` method in setup, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is cropped and enlarged, so you can see the shaded
    teapot here similar to the way you''d see it in the Cardboard viewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![I''m a little teapot](img/B05144_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I'm a little rotating teapot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's enhance the viewing experience by rotating the model as the user rotates
    his head. The effect will be different than a "normal" virtual reality experience.
    Ordinarily, moving one's head in VR rotates the subjective view of the camera
    in the scene to look around in unison with your head movement. In this project,
    the head movement will be like an input control rotating the model. The model
    is at a fixed position in front of you at all times.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature is quite simple. The `RenderBox preDraw` interface
    method is called at the start of each frame. We'll get the current head angles
    and rotate the model accordingly, converting the head post-Euler angles into a
    Quaternion. (Combining multiple Euler angles can result in an unexpected final
    rotational orientation). We will also conjugate (that is, invert or reverse) the
    rotation, so that when you look up, you see the bottom of the object and so on.
    It feels more natural this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity`, add the following code to `preDraw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In `setup`, ensure that the `setLocalPosition` method positions the teapot
    straight in front of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Try and run it. We're almost there! The model rotates with the head, but we're
    still looking around the VR space as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To lock the head position, we just need to disable head tracking in `RenderBox`.
    If your version of `RenderBox` (as built in [Chapter 5](ch05.html "Chapter 5. RenderBox
    Engine"), *RenderBox Engine*) does not yet have this feature, add it to your separate
    `RenderBoxLib` lib project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Camera.java` file, first add a new public variable for `headTracking`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `onDrawEye` method to conditionally update the view transform, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you copy the updated `.aar` file to the `ModelViewer` project's
    `RenderBox` module folder after you rebuild it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `MainActivity` class''s `setup()`, add the following setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run it now, and as you move your head, the model remains relatively stationary
    but rotates as you turn your head. Neato! Much better.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.html "Chapter 7. 360-Degree Gallery"), *360-Degree Gallery*,
    we explained the need for worker threads to offload processing from the render
    thread. In this project, we''ll add threading to the `ModelObject` constructor
    where we read and parse the model files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have to declare the file handle, `objFile`, as `final` to be able to access
    it from within the inner class. You may have also noticed that we added a call
    to the material's `setup` program before starting the thread to ensure that it's
    properly set up in time and avoid crashing the app. This avoids the need to call
    `createMaterial` within a `queueEvent` procedure, since the shader compiler makes
    use of the graphics context. Similarly, we disable the object until it has completed
    loading its data. Finally, since the load is asynchronous, it's necessary to set
    the scale at the end of this procedure. Our previous method set the scale in `setup()`,
    which now completes before the model is done loading.
  prefs: []
  type: TYPE_NORMAL
- en: Launch with intent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. 360-Degree Gallery"), *360-Degree Gallery*,
    we introduced the use of Android intents to associate an app with a specific file
    type in order to launch our app as a viewer of those files. We'll do the same
    for OBJ files here.
  prefs: []
  type: TYPE_NORMAL
- en: An **intent** is a message that any app can send to the Android system that
    declares its intent to use another app for a certain purpose. The intent object
    contains a number of members to describe what type of action needs to be done,
    and, if any, the data on which it needs to be done. For the image gallery, we
    associated the intent filter with an image mime type. For this project, we'll
    associate an intent filter with a filename extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `AndroidManifest.xml` file, add an intent filter to the activity block.
    This lets Android know that the app can be used as an OBJ file viewer. We need
    to specify it as a file scheme and the filename pattern. The wildcard mime type
    and host are also required by Android. Add the following XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle the situation, we''ll add a new constructor to `ModelObject` that
    takes a URI string instead of a resource ID, as we did earlier. Like the other
    constructor, we need to open an input stream and pass it to `parseObj`. Here''s
    the constructor, including the worker thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `MainActivity` class''s `setup`, we''ll check whether the app is
    launched from an intent and use the intent URI. Otherwise, we''ll view the default
    model, as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now with the project built and installed on the phone, let's try some web integration.
    Open the web browser and visit a 3D model download site.
  prefs: []
  type: TYPE_NORMAL
- en: Find the **Download** link for the interesting model to download it into the
    phone, and then when prompted, use the `ModelViewer` app to view it!
  prefs: []
  type: TYPE_NORMAL
- en: Practical and production ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that, as mentioned earlier, we've created a limited implementation of the
    OBJ model format, so not every model that you find will view correctly (if at
    all) at this point. Then again, it might be sufficient, depending on the requirements
    of your own projects, for example, if you include specific models in the resource
    folder that can be viewed in the released version of your app. When you have complete
    control of the input data, you can cut corners.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the basic structure of the OBJ file format is not very complicated, as
    we''ve demonstrated here, like many things in software (and in life) "the devil
    is in the details." Using this project as a starting point, and then building
    your own practical and production-ready OBJ file parser and renderer will require
    a considerable amount of additional work. You might also do some research on pre-existing
    packages, other model formats, or maybe even lifting some code from an open-source
    game engine like LibGDX. The features of OBJ that we omitted but are worth considering
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Texture vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curve elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping of geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color and other vertex attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we wrote a simple viewer for 3D models in the open OBJ file
    format. We implemented a `ModelObject` class that parses the model file and builds
    the vector and normal buffers needed by `RenderBox` to render the object in the
    scene. We then enabled shading. We then made the viewer interactive so that the
    model rotates as you move your head.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we explore another type of media, your music. The music
    visualizer responds to the current music player to display dancing geometry in
    the VR world.
  prefs: []
  type: TYPE_NORMAL
