- en: Programming Linux/Unix Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter is to explain the foundations of programming on Linux/Unix-based
    systems. This will provide a more complete picture of how a program executes on
    a Unix/Linux system, how to write more efficient code, and where to look when
    hard-to-find bugs arise.
  prefs: []
  type: TYPE_NORMAL
- en: To that end, this chapter starts by taking a comprehensive look at the Linux
    ABI, or more specifically, the System V ABI. In this section, we will review everything
    from the register and stack layout, to the System V calling conventions and ELF
    binary object specification.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will briefly cover the Linux filesystem, including the standard
    layout and permissions. We will then provide a comprehensive review of Unix processes
    and how to program them, including considerations such as forking new processes
    and interprocess communication.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter will conclude with a brief overview of Unix-based signals
    and how to work with them (both sending them and receiving them).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will address the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux ABI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unix filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix process APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix signal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow the examples in this chapter, you must have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all the code in this chapter, including the examples and code snippets,
    go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: The Linux ABI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the Linux ABI (which is actually called the
    **System V ABI**), as well as the ELF standard and its use in Linux/Unix.
  prefs: []
  type: TYPE_NORMAL
- en: We will also dive into some of the details associated with ELF files, how to
    read and interpret them, and some of the implications of specific components within
    an ELF file.
  prefs: []
  type: TYPE_NORMAL
- en: The System V ABI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix System V was one of the first versions of Unix available, and largely defined
    Unix for years. Under the hood, System V leveraged the System V ABI. As Linux
    and BSD (Unix-like operating systems) became more widely used, the popularity
    of System V declined. However, the System V ABI remained popular, as operating
    systems such as Linux adopted this specification for Intel-based PCs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the System V ABI for Intel platforms on the
    Linux operating system. It should be noted, however, that other architectures
    and operating systems might use different ABIs. For example, ARM has its own ABI,
    which is largely based on System V (and, oddly, the Itanium 64 specification),
    but has several key differences.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this section is to expose the inner workings of a single Unix ABI,
    which in turn should make learning other ABIs easier, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the specifications discussed in this chapter can be found at the following
    link: [https://refspecs.linuxfoundation.org/](https://refspecs.linuxfoundation.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The System V ABI defines most of the low-level details of a program (which
    in turn define the interfaces for system programming), including:'
  prefs: []
  type: TYPE_NORMAL
- en: The register layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function prologs and epilogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calling convention (that is, parameter passing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual memory layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary object format (in this case, ELF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program loading and linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 2](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml), *Learning the C,
    C++17, and POSIX Standards*, we discussed the details of program linking and dynamic
    loading, and we devoted an entire section to the binary object format (ELF).
  prefs: []
  type: TYPE_NORMAL
- en: The following is a brief description of the remaining details of the System
    V specification, with respect to the Intel 64-bit architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The register layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of keeping this topic simple, we will focus on Intel 64-bit.
    A whole book could be written on the different register layouts for each ABI,
    operating system, and architecture combination.
  prefs: []
  type: TYPE_NORMAL
- en: The Intel 64-bit architecture (which is usually referred to as AMD64, as AMD
    actually wrote it) defines several registers, of which a few have defined meanings
    within the instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction pointer `rip` defines a program's current location in executable
    memory. Specifically, as a program executes, it executes from the location stored
    in `rip`, and each time an instruction is retired, `rip` advances to the next
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The stack pointer and the base pointer (`rsp` and `rbp` respectively) are used
    to define the current location in the stack, as well as the location of the beginning
    of a stack frame (we will provide more information on this later).
  prefs: []
  type: TYPE_NORMAL
- en: The following are the remaining general-purpose registers. These have different
    meanings, which will be discussed in the rest of this section: `rax`, `rbx`, `rcx`,
    `rdx`, `rdi`, `rsi`, `r8`, `r9`, `r10`, `r11`, `r12`, `r13`, `r14`, and `r15`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted before we continue that there are several other registers
    defined on the system that have very specific purposes, including floating-point
    registers and wide registers (which are used by special instructions designed
    to speed up certain types of calculations; for example, SSE and AVX). These are
    out of scope for the purpose of this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some of the registers end with letters, while others end with numbers,
    because versions of Intel's x86 processors only had letter-based registers, and
    the only true, general-purpose registers were AX, BX, CX, and DX.
  prefs: []
  type: TYPE_NORMAL
- en: When 64-bit was introduced by AMD, the number of general-purpose registers doubled,
    and to keep things simple, the register names were given numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The stack frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stack frame is used to store the return address of each function, and to
    store function parameters and stack-based variables. It is a resource used heavily
    by all program, and it takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The stack frame is nothing more than an array of memory that grows from top
    to bottom. That is to say, on an Intel PC, pushing to the stack *subtracts* from
    the stack pointer, while popping from the stack *adds* to the stack pointer—which
    means that memory actually grows down (assuming your view is that memory grows
    upward as an address increases, as in the previous diagram).
  prefs: []
  type: TYPE_NORMAL
- en: 'The System V ABI states that the stack is made up of stack *frames*. Each frame
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each frame represents a function call, and starts with any arguments to a function
    beyond the first six being called (the first six arguments are passed as registers—this will
    be discussed in more detail later). Finally, the return address is pushed to the
    stack, and the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Memory after the return address belongs to variables that are scoped to the
    function itself. This is why we call variables defined in a function *stack-based
    variables*. The remaining stack is used by functions that will be called in the
    future. Each time one function calls another, the stack grows, while each time
    a function returns, the stack shrinks.
  prefs: []
  type: TYPE_NORMAL
- en: It is the job of the operating system to manage the size of the stack, ensuring
    that it always has enough memory. For example, if an application is trying to
    use too much memory, the operating system will kill the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it should be noted that on most CPU architectures, special instructions
    are provided that return from a function call and automatically pop the return
    address of the stack. In the case of Intel, the `call` instruction will jump to
    a function and push the current `rip` to the stack as the return address, and
    then `ret` will pop the return address from the stack and jump the address that
    was popped.
  prefs: []
  type: TYPE_NORMAL
- en: Function prologs and epilogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each function comes with a stack frame that, as stated previously, stores function
    parameters, function variables, and return addresses. The code that manages these
    resources is called the function's *prolog* (beginning) and *epilog* (ending).
  prefs: []
  type: TYPE_NORMAL
- en: 'To better explain this, let''s create a simple example and examine the resulting
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we disassemble the resulting binary, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our test function, the first two instructions are the function's prolog.
    The prolog is pushing the current stack frame (which is the previous function's
    stack frame), and then setting the current stack pointer to `rbp`, which is in
    turn creating a new stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: From there, the next two instructions are using the unused portion of the stack
    to create the variables `i` and `j`. Finally, the resulting stack-based variables
    are loaded into registers, and the result is added and returned in `rax` (which
    is the return register for most ABIs defined for Intel).
  prefs: []
  type: TYPE_NORMAL
- en: The function's epilog is the final two instructions in this example. Specifically,
    the location of the previous stack frame (which was pushed to the stack in the
    prolog) is popped from the stack and stored in `rbp`, effectively changing to
    the previous stack frame, and then the `ret` instruction is used to return to
    the previous function (just after the function call).
  prefs: []
  type: TYPE_NORMAL
- en: A keen eye might have noticed that space was not reserved on the stack by moving
    `rsp` for the variables `i` and `j`. This is because the 64-bit version of the
    System V ABI defines what is called the **red zone**. The red zone only applies
    to leaf functions (in our case, the test function is a leaf function, meaning
    it doesn't call any other functions).
  prefs: []
  type: TYPE_NORMAL
- en: Leaf functions will never grow the stack any further, which means that the remaining
    stack can be used by the function without having to advance the stack pointer,
    as all remaining memory is fair game.
  prefs: []
  type: TYPE_NORMAL
- en: When system programming, this can sometimes be a problem if you are programming
    in the kernel. Specifically, if an interrupt fires (using the current stack pointer
    as its stack), corruption can occur if the stack was not properly reserved, therefore
    the interrupt would corrupt a leaf function's stack-based variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, the red zone must be turned off using the `-mno-red-zone` flag
    with GCC. For example, if we compile the previous example with this flag, we get
    the following binary output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the resulting binary is very similar to the original. There are two
    major differences, however. The first is the `sub` instruction, which is used
    to move the stack pointer, which in turn reserves stack space instead of using
    the red zone.
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is the use of the `leave` instruction. This instruction
    pops `rbp` just as in the previous example, but also restores the stack pointer,
    which has been moved to make space for stack-based variables. In this example,
    the `leave` and `ret` instructions are the new epilog.
  prefs: []
  type: TYPE_NORMAL
- en: The calling convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A calling convention dictates which registers are *volatile*, which registers
    are *non-volatile*, which registers are used for parameter passing and in which
    order, and which register is used to return the result of a function.
  prefs: []
  type: TYPE_NORMAL
- en: A non-volatile register is a register that is restored to its original value
    just prior to a function leave (that is, in its epilog). The System V ABI defines
    `rbx`, `rbp`, `r12`, `r13`, `r14`, and `r15` as non-volatile. By contrast, a volatile register
    is one that a called function can change at will, without having to restore its
    value on return.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the previous example, the `__libc_csu_init()` function (which is
    used by `libc` to initialize) touches `r12`, `r13`,`r14`, and `r15`. As such,
    it must push the original values of these registers to the stack before performing
    its initialization procedure.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, in the middle of this code, the compiler stores `rdx` in `r15`. As
    will be shown later, the compiler is preserving the third argument to the function.
    Just based on this code, we know that this function takes at least three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick Google search will reveal that this function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this function touches *non-volatile *registers, it must restore these
    registers to their original values before leaving. Let''s look at the function''s
    epilog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown previously, the `__libc_csu_init()` function restores all the non-volatile registers
    before leaving. This means that, somewhere in the middle of the function, `rbx`
    was also clobbered (with its original value being pushed to the stack beforehand).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to volatile and non-volatile registers being defined, System V's
    calling convention also defines which registers are used to pass function parameters.
    Specifically, the registers `rdi`, `rsi`, `rdx`, `rcx`, `r8`, and `r9` are used
    to pass parameters (in the order provided).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we created a test function that takes two arguments,
    adds them together, and returns the result. Let''s now look at the resulting binary
    for the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the `main()` function does is provide its prolog (as described
    in previous chapters, the `main()` function is not the first function to execute,
    and thus, a prolog and epilog are needed just like any other function).
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function then reserves space on the stack for the return value
    of the `test()` function, and fills in `esi` and `edi` with the parameters being
    passed to `test()` just before calling `test()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `call` instruction, as previously stated, pushes the return address onto
    the stack and then jumps to the `test()` function. The result of the `test()`
    function is stored on the stack (an operation that would be removed if optimization
    were enabled), and then `0` is placed in `eax` just before returning.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we did not provide our `main` function with a return value. This
    is because, if no return value is provided, the compiler will automatically insert
    a return `0` for us, which is what we see in this code, as `rax` is the return
    register for System V.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the test function binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `test` function sets up a prolog, and then stores the function's parameters
    on the stack (an operation that would be removed with optimizations turned on).
    The stack variables are then placed into volatile registers (to prevent them from
    having to be saved and restored), the registers are added together, and the result
    is stored in `eax`. Finally, the function returns with an epilog.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated previously, the return register for System V is `rax`, which means
    that every function that returns a value will do so using `rax`. To return more
    than one value, `rdx` can also be used. For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create a `test` function that returns a structure
    that has two 64-bit integers. We choose two 64-bit integers because if we used
    regular ints, the compiler would attempt to store the contents of the struct in
    a single 64-bit register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting binary for the `test()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As previously shown, the `test` function stores the results in `rax` and `rdx`
    before returning. If more than 128 bits of data are returned, both the `main()`
    function and the `test()` function get way more complicated. This is because stack
    space must be reserved by the `main()` function, and then the `test()` function
    must leverage this stack space to return the results of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The specific details of how this works are beyond the scope of this book, but,
    in short, the address of the stack space reserved for the return value actually
    becomes the first argument to the function, all of which is defined by the System
    V ABI.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the examples make heavy use of registers that are prefixed
    with `e` rather than `r`. This is because `e` denotes a 32-bit register, while `r` denotes
    a 64-bit register. The reason `e` versions are used so much is that we leverage
    integer-based literals such as `1`, `2`, and `42`. These are all of type `int`, as
    defined by the C and C++ specifications (as stated in previous chapters), which,
    by default on an Intel 64 bit CPU, is a 32-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ exceptions provide a way to return an error to a `catch` handler somewhere
    in the call stack. We will cover C++ exceptions in great detail in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will work with the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create a simple `test()` function that takes an
    input. If the input is equal to `42`, we throw an exception. This will cause the
    function to return (and every calling function to continue to return) until a
    `try` or `catch` block is encountered. Any code executed in the `try` portion
    of the block will execute the `catch` portion of the block if an exception is
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the return value of the called function is not considered
    or used. This provides a means to throw an error at any point in the execution
    of a call stack of functions, and catch possible errors at any point (most likely
    when the error can be safely handled or the program can be safely aborted).
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding example, the first attempt to execute the `test()`
    function succeeds, and the `attempt #1: passed` string is output to `stdout`.
    The second attempt to execute the `test()` function fails when the function throws
    an exception, and as a result, the `attempt #2: passed` string is not output to
    `stdout` as this code is never executed. Instead, the `catch` block is executed,
    which handles the error (by ignoring it).'
  prefs: []
  type: TYPE_NORMAL
- en: The details of exception handling (and debugging) are exceptionally difficult
    (pun intended), and therefore the goal of this section is to explain how the System
    V specification dictates the ABI associated with exception (and debugging) support.
  prefs: []
  type: TYPE_NORMAL
- en: I provide more detail about the inner workings of C++ exceptions in the following
    video, recorded at CppCon: [https://www.youtube.com/watch?v=uQSQy-7lveQ](https://www.youtube.com/watch?v=uQSQy-7lveQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this section, the following should be clear:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ exceptions are expensive to execute, and therefore should never be used
    for control flow (only error handling).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ exceptions consume a lot of space in the executable and if they are not
    used, the `-fno-exceptions` flag should be passed to GCC to reduce the overall
    size of the resulting code. This also means that no library facilities that could
    possibly throw an exception should be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To support the previous example, the stack has to be *unwound*. That is, for
    the program to jump to the `catch` block, the non-volatile registers need to be
    set to appear as though the `test()` function was never executed in the first
    place. To do this, we, in a way, execute the `test()` function in reverse, using
    a set of instructions provided by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the details of this information, let''s first look at the
    assembly code associated with our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To keep this easy to understand, the previous code has been simplified. Let's
    start at the top. The first thing this function does is set up the function prolog
    (that is, the stack frame), and then reserve some space on the stack. Once this
    is done, the code moves `0x1` into `edi`, which passes a `1` to the `test()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `test()` function is called. Next, some stuff happens (the details
    are not important), and then `std::cout` is called (which attempts to output the `attempt
    #1: passed` string to `stdout`). This process is repeated for `test(42)` as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The next bit of code is where the `main()` function gets interesting. `mov $0x0,%eax` sets
    `eax` to `0`, which, as we know, is the return register. This code sets up the
    return value for the `main()` function, but what is interesting is that the next
    instruction does a relative jumps to `c90` in the `main()` function, which is
    the `add $0x8,%rsp` code. This is the beginning of the epilog of the function,
    which cleans up the stack and restores the non-volatile registers.
  prefs: []
  type: TYPE_NORMAL
- en: The code in between is our `catch` block. This is the code that is executed
    if an exception is thrown. If an exception is not thrown, the `jmp c90` code is
    executed, which skips the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test` function is far more simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `test` function, the function prolog is set up, and stack space is reserved
    (which would likely be removed if optimizations were enabled). The input is then
    compared to `42`, and if they are not equal (as shown by the use of `jne`), the
    function jumps to the epilog and returns. If they are equal, a C++ exception is
    allocated and thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that the `__cxa_throw()` function does not
    return, which means that the function's epilog is never executed. The reason for
    this is that, when an exception is thrown, the programmer is stating that the
    remaining portion of the function cannot execute, and instead, `__cxa_throw()`
    needs to jump to a `catch` block in the call stack (in this case, in the `main()`
    function), or terminate the program if a `catch` block cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: Since the function's epilog is never executed, the non-volatile registers need
    to be restored to their original state somehow. This brings us to the DWARF specification,
    and the `.eh_frame` table that is embedded in the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: As will be shown later on in this chapter, most Unix-based applications are
    compiled to a binary format called **ELF**. Any ELF application that was compiled
    with C++ exception support contains a special table called the `.eh_frame` table
    (this stands for exception handling framework).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you run `readelf` on the previous application, you will see
    the `.eh_frame` table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The DWARF specification (which doesn't officially stand for anything) provides
    all the information needed to debug an application. When debugging is enabled
    by GCC, several debugging tables are added to the application to assist GDB.
  prefs: []
  type: TYPE_NORMAL
- en: The DWARF specification is also used to define the instructions needed to reverse
    the stack; in other words, to execute a function in reverse with respect to the
    contents of the non-volatile registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the contents of the `.eh_frame` table using `readelf`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An entire book could be written on what this code does, but the goal here is
    to keep this simple. For every single function in the program (which could be
    hundreds of thousands of functions for programs with a lot of code), a block like
    the previous one is provided in `.eh_frame`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding block (which was located by matching addresses found using `objdump`)
    is the **Frame Description Entry** (**FDE**) for our `test()` function. This FDE
    describes how to reverse the stack using DWARF instructions, which are compressed
    instructions designed to be as small as possible (to reduce the size of the `.eh_frame` table).
  prefs: []
  type: TYPE_NORMAL
- en: The FDE provides the stack reversal instructions based on the location of the
    throw. That is to say, as a function executes, it continues to touch the stack.
    If more than one throw is present in a function, it is possible that more of the
    stack has been touched in between each throw, which means that more stack reversal
    instructions are needed to properly return the stack back to normal.
  prefs: []
  type: TYPE_NORMAL
- en: Once a function's stack has been reversed, the next function in the call stack
    needs to be reversed. This process continues until a `catch` block is located.
    The problem is that the `.eh_frame` table is a list of these FDEs, which means
    that reversing the stack is an `O(N^2)` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimizations have been carried out, including the use of a hash table, but
    two things remain true:'
  prefs: []
  type: TYPE_NORMAL
- en: Reversing the stack is a slow process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++ exceptions takes up a lot of space. This is because each function
    defined in the code not only has to contain the code for that function, it must
    also contain an FDE that tells the code how to unwind the stack in the event that
    an exception is fired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual memory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual memory layout is also provided by the System V specification. In the
    next section, we will discuss the details of the ELF format, which will provide
    more information about the virtual memory layout and how it can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Executable and Linkable Format (ELF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Executable and Linkable Format** (**ELF**) is the main format used in
    most Unix-based operating systems, including Linux. Every ELF file begins with
    the hex number `0x7F`, and continues with the `ELF` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at a `hexdump` of the resulting `a.out` ELF file, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the `ELF` string is at the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every ELF file contains an ELF header, which describes some of the critical
    components of the ELF file itself. The following can be used to view an ELF file''s
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the ELF file that we compiled was linked to an ELF-64 file that adheres
    to the Unix System V ABI for Intel 64-bit. Near the bottom of the header, you
    might notice the mention of program headers and section headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every ELF file can be viewed in terms of either its segments or its sections.
    To visualize this, let''s look at an ELF file from both points of view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As previously shown, each ELF file is composed of sections. The sections are
    then grouped into segments, which are used to define which sections need to be
    loaded, and how (for example, some sections need to be loaded as read-write, others
    as read-execute, or, in some sub-optimal cases, read-write-execute).
  prefs: []
  type: TYPE_NORMAL
- en: ELF sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see a list of all of the sections, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67f0afe1-ea22-4452-8757-fa904e0870b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown, even in a simple example, there are several sections. Some of these
    sections contain information that has already been talked about in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eh_frame/.eh_frame_hdr`: These contain the FDE information for reversing the
    stack when dealing with exceptions, as just discussed. The `eh_frame_hdr` section
    contains additional information for improving the performance of C++ exceptions,
    including a hash table that can be used to locate an FDE instead of looping through
    the list of FDEs (which would be an `O(n^2)` operation otherwise).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.init_array/.fini_array/.init/.fini`: These contain the constructors and destructors
    that are executed by the code, including any libraries that are linked to your
    code (as discussed, there could be many libraries linked to your application under
    the hood). It should also be noted that these sections contain code capable of
    performing runtime relocations, which must be executed at the very beginning of
    any application to ensure that code is properly linked and relocated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.dynsym`: This contains all the symbols used for dynamic linking. As discussed
    earlier, if GCC is used, these symbols will all contain C runtime linking names,
    whereas if G++ is used, they will also contain mangled names. We will explore
    this section in more detail shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot can be learned from the output of the sections in `readelf`. For example,
    the addresses all start with `0`, and not some address in higher memory. This
    means the application was compiled using the `-pie` flag during linking, which
    means that the application is relocatable. Specifically, **Position Independent
    Executable** (**PIE**) (and as such, the ELF file) contains the `.plt` and `.got` sections
    that are used to relocate the executable in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can also be seen from the inclusion of the `.rela.xxx` sections, which
    contain the actual relocation commands used by the ELF loader to relocate the
    executable in memory. To prove that this application was compiled using the `-pie` flag,
    let''s look at the application''s compilation flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As previously shown, the `-pie` flag was provided.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that the sections start at address `0` and progress,
    but, at some point, the address jumps to `0x200000` and continues from there.
    This means that the application is 2 MB aligned, which is typical for 64-bit applications
    as they have a much larger address space to work with.
  prefs: []
  type: TYPE_NORMAL
- en: As will be shown, the point at which the jump to `0x200000` starts is the beginning
    of a new program segment in the ELF file, and denotes a change in the permissions
    of the sections being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some notable sections that should also be pointed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.text`: This contains most, if not all, of the code associated with the program.
    This section is usually located in a segment marked as read-execute, and, ideally,
    is not given write permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data`: This contains global variables that are initialized to a value other
    than `0`. As shown, this section exists in the ELF file itself, and, for this
    reason, these types of variables should be used sparingly as they increase the
    size of the resulting ELF file (which reduces the load time of the application
    and consumes additional space on the disk). It should also be noted that some
    compilers will place uninitialized variables in this section—so, if a variable
    should be `0`, initialize it as such.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bss`: This section contains all the global variables that should be initialized
    to `0` (assuming C and C++ is used). This section is always the last section to
    be loaded (that is to say, it is the last section marked by a segment), and does
    not actually exist in the ELF file itself. Instead, when an ELF file is loaded
    into memory, the size of the ELF file is extended to include the total size of
    this section, and the extra memory is initialized to `0` by the ELF loader (or
    the C runtime).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.dynstr/.strtab`: These tables contain the strings that are used for symbol
    names (that is, variable and function names). The `.dynstr` table contains all
    the strings that are needed during dynamic linking, while the `.strtab` section
    contains all the symbols in the program. The key point here is that the strings
    show up twice. The use of `static` in front of a variable or function prevents
    the variable''s symbol from showing up in the `.dynsym` section, which in turn
    means it will not show up in the `.dynstr` section. The downside of this is that
    the variable cannot be seen during dynamic linking, which means that, if another
    library attempts to use `extern` on that variable, it will fail. By default, all
    variables and functions should be labeled `static` unless you intend them to be
    externally assessable, reducing the total size of the file on disk and in memory.
    This also speeds up linking time, as it reduces the size of the `.dynsym` section,
    which is used for dynamic linking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To further examine how strings are stored in an ELF file, let''s create a simple
    example with a string that is easy to look up, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously shown, this example outputs `The answer is: 42` to `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look for this string in the ELF file itself, using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously shown, the string exists in our program and is located at `0x905`.
    Now let''s look at the ELF sections for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcc4439a-6d77-4f9a-bcec-68eef8587dee.png)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the addresses within the sections, we can see that the string
    exists in a section called `.rodata`, which contains *constant* data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the assembly for this application using `objdump`, which
    disassembles the code in the `.text` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d337e6cc-1f27-4d30-ad68-91757a0181bf.png)'
  prefs: []
  type: TYPE_IMG
- en: As previously shown, the code loads `rsi` with the address of the string (at
    `0x905`), which is the second parameter, just prior to calling `std::cout`. It
    should be noted that, as before, this application was compiled using the `-pie` command,
    which means that the application itself will be relocated. This ultimately means
    that the address of the string will not be at `0x905`, but instead will be at `#
    + 0x905`.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the need for a relocation entry (that is, an entry in the **Global
    Offset Table** (**GOT**)), the program uses an instruction pointer relative offset.
    In this case, the instruction to load `rsi` is at `0x805`, and the offset `0x100`
    is used, which in turn returns `0x905 + rip`. This means that, no matter where
    in memory the application is loaded, the code can locate the string without a
    relocation entry being needed.
  prefs: []
  type: TYPE_NORMAL
- en: ELF segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously stated, ELF segments group the sections into loadable components,
    and describe how and where to load the ELF file in memory. The ideal ELF loader
    would only have to read ELF segments to load an ELF file, and (in the case of
    a relocatable ELF file) also have to load the dynamic sections and relocation
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an ELF''s segments, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e2653f5-0f64-41f8-a955-a58831c7612a.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown previously, the simple example has several program segments. The first
    segment describes the program header (which defines the segments) and, for the
    most part, can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The second segment tells the ELF loader which relocator it is expecting to use.
    Specifically, the program that is described in this segment is used for lazy relocations.
    When a program is dynamically linked, the symbols in the GOT and **Procedure Linkage
    Table** (**PLT**) contain the actual address in memory for each symbol, and the
    code references the entries in this table instead of directly referencing a symbol.
  prefs: []
  type: TYPE_NORMAL
- en: This is necessary, as the compiler has no way of knowing the location of a symbol
    in another library, so the ELF loader fills in the location of each symbol by
    loading the GOT and PLT for symbols that exist in other libraries (or symbols
    that are not marked as static).
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that a large program can have hundreds or thousands of these
    GOT or PLT entries and, as a result, loading a program could take a long time.
    What makes this problem even worse is that a lot of symbols from external libraries
    may never be called, which means the ELF loader would need to fill in an entry
    in the GOT or PLT with a symbol location that is not even needed.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these issues, the ELF loader loads the GOT and PLT with the location
    of a lazy loader, instead of the symbol itself. The lazy loader (which is the
    program you see in the second segment) loads the location of a symbol once it
    is used for the first time, reducing program load times.
  prefs: []
  type: TYPE_NORMAL
- en: The third segment, marked as `LOAD`, tells the ELF loader to load the following
    portion of the ELF file into memory. As shown in the previous output, this segment
    contains several sections, all of which are marked as read-execute. For example,
    the `.text` section exists in this section.
  prefs: []
  type: TYPE_NORMAL
- en: All the ELF loader has to do is follow the instructions by loading the portion
    of the ELF file marked by the segment into the virtual address provided (with
    the memory size provided).
  prefs: []
  type: TYPE_NORMAL
- en: The fourth segment is the same as the third, but instead of the read-execute
    sections being marked, the read-write sections are marked, including sections
    such as `.data`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the offset in memory to load the fourth segment increases
    by `0x200000`. As previously stated, this is because the program is 2 MB aligned.
    More specifically, Intel 64-bit CPUs support 4 KB, 2 MB, and 1 GB pages.
  prefs: []
  type: TYPE_NORMAL
- en: Since the first loadable segment is marked read-execute, the second loadable
    segment cannot be on the same page as the first (otherwise, it too would have
    to be marked read-execute). As a result, the second loadable segment is designed
    to start on the next available page, which in this case, is 2 MB in memory. This
    allows the operating system to mark the first loadable segment as read-execute
    and the second loadable segment as read-write, and the CPU can enforce these permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The next segment defines the location of the dynamic section, which is used
    by the ELF loader to perform dynamic relocations. This is necessary because the
    executable was compiled using `-pie`. It should be noted that the ELF loader could
    scan the ELF sections to find this data, but the goal of the program segments
    is to define all of the information needed to load an ELF file without the need
    for scanning the sections. Sadly, in practice, this is not always true, but, ideally,
    this should be the case.
  prefs: []
  type: TYPE_NORMAL
- en: The *notes* segment can safely be ignored. The following segments provide the
    ELF loader with the location of the exception information (as described); the
    permissions for the stack that the executable expects; which, ideally, would always
    be read-write and not read-write-execute, and the location of the read-only section,
    which can have its permissions changed to read-only once loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The Unix filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unix filesystem, which is used by most Unix-based operating systems, including
    Linux, consists of a virtual filesystem tree, which is the frontend to the user
    and applications. The tree starts with the root (that is, `/`), and all files,
    devices, and other resources are located within this single root directory.
  prefs: []
  type: TYPE_NORMAL
- en: From there, a physical filesystem is usually mapped onto the virtual filesystem,
    providing a mechanism by which files are stored and retrieved. It should be noted
    that this physical filesystem does not have to be a disk; it could also be RAM
    or some other type of storage device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this mapping, the operating system has a mechanism for instructing
    the OS to perform this mapping. On Linux, this is done using `/etc/fstab`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, the root filesystem maps to a specific physical device
    (denoted with a UUID), which contains an `ext4` filesystem. In addition, within
    this root filesystem, another physical partition is mapped to `/boot/efi` and
    contains a VFAT filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that all access to the virtual filesystem defaults to the
    `ext4` partition, while access to anything below `/boot/efi` is redirected to
    a separate VFAT partition that contains files specific to UEFI (which is the specific
    BIOS being used in the textbox used to write this book).
  prefs: []
  type: TYPE_NORMAL
- en: Any node within the virtual filesystem can be remapped to any device or resource.
    The brilliance behind this design is that applications do not need to be concerned
    with what type of device the virtual filesystem is currently mapping, as long
    as the application has permissions for the portion of the filesystem it is trying
    to access, and has the ability to open a file and read and write to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On most Linux-based systems, a file called `/dev/null` exists. This file doesn''t
    actually map to a real file. Instead, the virtual filesystem maps this file to
    a device driver that ignores all writes and returns nothing when read. For example,
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Most Linux-based systems also provide a `/dev/zero`, which returns all zeros
    when read, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also `/dev/random`, which returns a random number when read, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed previously, in [Chapter 2](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml),
    *Learning the C, C++17, and POSIX Standards*, the layout of the filesystem that
    POSIX defines is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: for binaries used by all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot`: for files needed to boot the operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: for physical and virtual devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: for configuration files needed by the operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: for user-specific files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: for libraries needed by executables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt` and `/media`: used as temporary mount points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: for system-specific binaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: for files that are deleted on reboot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: for user-specific versions of the preceding folders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, the files under `/boot` point to a physical partition that is different
    to the root partition, the `/dev` folder contains files that are mapped to devices
    (rather than files that are stored and retrieved on a disk), and `/mnt` or `/media`
    is used to mount temporary devices such as USB storage devices and CD-ROMs.
  prefs: []
  type: TYPE_NORMAL
- en: On some systems, `/home` could be mapped to a completely separate hard drive,
    allowing the user to completely format and reinstall the root filesystem (that
    is, to reinstall the OS), without losing any personal files or configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unix filesystem also maintains an entire set of permissions that define
    who is allowed to read, write, and execute files. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The filesystem defines the permissions for the file's owner, the file's group,
    and others (users who are neither the owner nor part of the file's group).
  prefs: []
  type: TYPE_NORMAL
- en: The first column in the preceding example defines a file's permissions. The
    `d` defines whether or not a node is a directory or a file. The first of the three
    characters define the read/write/execute permissions for a file's owner, while
    the second defines the permissions for a file's group, and finally, the third
    defines the permissions for others.
  prefs: []
  type: TYPE_NORMAL
- en: The third column in the preceding example defines the name of the owner, while
    the second column defines the name of the group (which, in most cases, is also
    the owner).
  prefs: []
  type: TYPE_NORMAL
- en: Using this permission model, the Unix filesystem can control access to any file
    or directory for any given user, a group of users, and everyone else.
  prefs: []
  type: TYPE_NORMAL
- en: Unix processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A process on a Unix-based system is a userspace application executed and scheduled
    by the operating system. In this book, we will refer to processes and userspace
    applications interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: As will be shown, most Unix-based processes that are running at any given time
    are children of some other parent process, and each kernel implements processes
    under the hood differently, but the same basic commands for creating and managing
    processes are provided by all Unix operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss how to create and manage Unix-based processes
    using commonly-seen POSIX interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The fork() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a Unix-based system, the `fork()` function is used to create processes. The
    `fork()` function is a relatively simple system call provided by the operating
    system that takes the current process, and creates a duplicate child version of
    the process. Everything about the parent and child processes is the same, including
    opened file handles, memory, and so on, with the key difference being that the
    child process has a new process ID.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml), *Learning to Program
    POSIX and C++ Threads*, we will discuss threads (which are more commonly used
    for system programming than processes). Both threads and processes are scheduled
    by the operating system; the main difference between a thread and a process is
    that a child and parent process do not have access to one another's memory, while
    threads do.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `fork()` creates a new process with the same resources and memory
    layout, the memory that is shared between the parent and child processes are marked
    as copy-on-write. This means that, as the parent and child process executes, any
    attempt to write to memory that might have been shared causes the child process
    to create its own copies of memory that only it can write to. As a result, the
    parent process is unable to see modifications to the memory made by the child.
  prefs: []
  type: TYPE_NORMAL
- en: This is not true for threads, as threads maintain the same memory layout and
    are not marked as copy-on-write. As a result, a thread is capable of seeing the
    changes made to the memory by another thread (or parent process).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `fork()` system call to create a duplicate process.
    The duplicate, child, process outputs `Hello World` to `stdout` using `std::cout`.
    As shown, the result of this example is that `Hello World` is output twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fork()` system call returns the process ID in the parent process for the
    child, and in the child `0`, is returned. If an error occurs, `-1` is returned
    and `errno` is set to the appropriate error code. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the parent process outputs `Hello` while the child process
    outputs `World`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine how shared memory is handled between the parent and child process,
    as described, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we output the `The answer is:` string for both the parent and
    child processes. Both processes have access to a global variable called `data`, which
    is initialized to `0`. The difference is that the parent process sets the `data`
    variable to `42` and the child does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent process completes its job before the operating system schedules
    the child process, and, as a result, `The answer is: 42` is output to `stdout`
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the child process has a chance to execute, it too outputs this string,
    but the answer is `0` and not `42`. This is because, as far as the child is concerned,
    the data variable was never set. Both the child process and the parent process
    have access to their own memory (at least, the memory that is written), and as
    such, `42` was set in the memory for the parent, not the child.
  prefs: []
  type: TYPE_NORMAL
- en: On most Unix-based operating systems, the first process to execute is `init`,
    which starts the rest of the processes on the system using `fork()`. This means
    the `init` process is the root-level parent for userspace applications (sometimes
    referred to as the grandparent). As such, the `fork()` system call can be used
    to create complex trees of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we execute the `fork()` system call twice, which
    generates three additional processes. To understand why three processes are created
    instead of two, let''s make a simple modification to the example, to highlight
    the tree structure that is created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we execute `fork()` twice, as previously, with the main difference
    being that we output the ID for each process that is created. The parent process
    executes `fork()`, outputs the ID, executes `fork()` again, and then outputs the
    ID again before executing.
  prefs: []
  type: TYPE_NORMAL
- en: Since the IDs are not `0` (in fact, they are `14181` and `14182`), we know that
    this is the parent process, and, as expected, it creates two child processes.
    The next IDs that are shown are `0` and `14183`. This is the first child process
    (`14181`), which occurs at the first call to `fork()` by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: This child process then continues to create its own child process (which has
    the ID `14183`, as stated). The parent process and the child process each created
    an additional process (`14182` and `14183`) when the second `fork()` was executed,
    which both output `0` for `id2`. This accounts for the last two outputs.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this example might need to be executed several times
    to get a clean result, as each additional child process increases the chance that
    one child process will execute at the same time as the other child processes,
    corrupting the output. As processes do not share memory, implementing methods
    to synchronize the output in an example like this is non-trivial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `fork()` creates *n*^2 processes, with *n* being the total number
    of times `fork()` is called. For example, if `fork()` were called three times
    instead of two, as in the simplified preceding example, we would expect `Hello
    World` to output eight times instead of four, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the exponential growth of processes shown, some processes might
    choose to create a child while others might not, resulting in a complex process
    tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the parent process creates child processes, while each child
    process does nothing. This results in the `The answer is 42` string being output
    to `stdout` solely by the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: The wait() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated, each process is executed by the operating system in whatever order
    the operating system chooses. As a result, it is possible that the parent process
    could finish its execution prior to the child process completing. On some operating
    systems, this could result in corruption, as some operating systems require the
    parent process to be alive for the child process to successfully complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this, POSIX provides the `wait()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a child process that outputs `child` to `stdout`.
    Meanwhile, the parent outputs `parent` to `stdout` and then executes the `wait()`
    function, which tells the parent to wait for a child to complete its execution.
  prefs: []
  type: TYPE_NORMAL
- en: We pass `nullptr` to the `wait()` function, as that tells the `wait()` function
    that we are not interested in an error code.
  prefs: []
  type: TYPE_NORMAL
- en: The `wait()` function waits for *any* child process to complete. It doesn't
    wait for a *specific* child process to complete. As a result, if more than one
    child process has been created, `wait()` must be executed more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create eight child processes. As previously stated,
    the total number of processes created is 2^(the number of times `fork` is called).
    In this example, however, we are interested in making sure that the grandparent,
    which is the root parent process, is the last process to finish executing.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, when we call `fork()` like this, the first call creates the first
    child. The second call to `fork()` makes another child, but the first child now
    becomes a parent as it calls `fork()`. The same happens (but even more so) when
    we call `fork()` a third time. The grandparent is the root parent process.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which process is the grandparent process, we want to ensure that
    all child processes finish before their parents do. To accomplish this, we record
    the process ID each time `fork()` is executed. For child processes, this ID is
    set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do is enter a `while(1)` loop, and then call `wait()`. The
    `wait()` function will exit as soon as a child process is complete. Once the process
    is complete, we output which child process exited to `stdout`. If the process
    ID that we get from `wait()` is `-1`, we know that no more child processes exist,
    and we can exit the `while(1)` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if none of the process IDs are equal to `0`, we know that the process
    is the grandparent, and we output when it exits just to show that it is the last
    process to exit.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `wait()` function will not return `0`, we know that when a child process
    exits, we will only ever output the child process that exited within our `while(1)`
    loop. As shown, we see that one child with `id1` exits, two children with `id2`
    exit, and four children with `id3` exit. This is as expected, based on the math
    that we performed previously.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that this example ensures that all child processes are
    completed before the parent completes. This means that the grandparent must wait
    for its children to complete. Since the child processes of the grandparent also
    create their own processes, the grandparent must first wait for the parent process
    to complete, which must wait in turn for its children to complete.
  prefs: []
  type: TYPE_NORMAL
- en: This results in a cascading effect of child processes completing before their
    parents, all the way until the grandparent process finally completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it should also be noted that, although parents have to wait for their
    children to complete, it doesn''t mean that all children with `id3` will exit
    before children with `id2` exit. This is because one half of the child tree could
    complete without issue before the other half completes, or in any order. As a
    result, it''s possible to get outputs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the last `child #3` to complete was the process that was created
    by the last call to `fork()` by the grandparent process.'
  prefs: []
  type: TYPE_NORMAL
- en: Interprocess communication (IPC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In one of our preceding examples, we demonstrated how `fork()` can be used
    to create a child process from a parent process, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The reason we see `parent` output before `child` in this example is merely the
    result of the operating system taking longer to start the child process than it
    takes to output from the child process. If the parent process were to take longer,
    `child` would output first.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is identical to the previous example, with the exception that a `sleep()`
    command was added to the parent process, which tells the operating system to yield
    the execution of the parent for one second. As a result, the child process has
    plenty of time to execute, resulting in `child` being output first.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the child from executing first, we need to set up a communication
    channel between the parent and child process so that the child process knows to
    wait for the parent to finish outputting to `stdout` before the child does. This
    is called **synchronization**.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about synchronization, how to handle it, and the issues
    that arise from synchronization, such as deadlock and race conditions, please
    see the *Further reading* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, the mechanism we will use to synchronize the parent and child
    process is called **Interprocess communication** (**IPC**). It should be noted
    before we continue that creating multiple processes and using IPC to synchronize
    them is a heavy-handed way of creating and coordinating more than one task on
    the operating system. Unless separate processes are absolutely needed, a better
    approach is to use threading, a topic that we cover in great detail in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),
    *Learning to Program POSIX and C++ Threads*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of IPC that can be leveraged in a Unix system.
    Here, we will cover two of the most popular methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Unix pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pipe is a mechanism for sending information from one process to another. In
    its simplest form, a pipe is a file (in RAM) that one process can write to, and
    the other can read from. The file starts out empty, and no bytes can be read from
    the pipe until bytes are written to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example is similar to the previous example, with the addition of a Unix
    pipe. This is used to ensure that even if the parent takes a while to execute,
    the parent outputs to `stdout` before the child executes. To accomplish this,
    we create a class that leverages **Resource Acquisition Is Initialization** (**RAII**)
    to encapsulate the Unix pipe, ensuring that the details of the C APIs are properly
    abstracted and the handles that are opened to support Unix pipes are closed when
    the `mypipe` class loses scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do in the class is to open the pipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The pipe itself is an array of two file handles. The first handle is used to
    read from the pipe, while the second handle is used to write to the pipe. The
    `pipe()` function will return `-1` if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that if the `pipe()` function succeeds, the result is two
    file handles that should be closed when they are no longer used. To support this,
    we close the file handles that were opened in the destructor of the class, so
    that when the pipe loses scope, the pipe is closed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We then provide a `read()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `read()` function creates a buffer that can be read to, and we read from
    the pipe and place the results in the buffer. Notice how we read from the first
    file handle, as stated.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the `read()` and `write()` functions that we leverage
    here will be covered in detail in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output*. For now, it is important to note that the `read()`
    function, in this case, is a blocking function, and will not return until data
    is read from the pipe. If an error occurs (for example, the pipe is closed), `-1`
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: To account for this, we only return the data that is read from the pipe if actual
    bytes are read; otherwise, we return a null string, which can be used by the user
    of this class to detect an error (or we could use a C++ exception, as covered
    in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error - Handling
    with Exceptions*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also add a `write()` function to the pipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `write()` function is far simpler, writing to the write side of the pipe
    using the `write()` Unix function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parent process we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is sleep for one second, which ensures that the parent
    takes a long time to execute. If synchronization were not used, the child process
    would output to `stdout` before the parent process as a result of the use of this
    `sleep()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do is to output to `stdout` and then write the `done` message to
    the pipe. Finally, we wait for the child process to finish before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The child process does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As stated, the `read()` function is a blocking function, which means that it
    will not return until data is read from the file handle (or an error occurs).
    We assume that no errors will occur, and store the resulting string in a variable
    called `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `read()` function is blocking, the child process will wait until the
    parent process outputs to `stdout`, and then writes to the pipe. No matter what
    the parent process does before the write to the pipe, the child process will wait.
  prefs: []
  type: TYPE_NORMAL
- en: Once the call to `read()` returns, we output to `stdout` *child* and the message
    that was sent by the parent, and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Using this simple example, we are able to send information from one process
    to another. In this case, we use this communication to synchronize the parent
    and child processes.
  prefs: []
  type: TYPE_NORMAL
- en: Unix shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix shared memory is another popular form of IPC. Unlike Unix pipes, Unix shared
    memory provides a buffer that can be read and written to by both processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create the following function which is responsible
    for opening the shared memory between the parent and child processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This function starts by creating a unique key, which is used by the operating
    system to associate the shared memory between the parent and child processes.
    Once this key is generated, `shmget()` is used to open the shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: '`0x1000` tells `shmget()` that we would like to open 4 KB of memory, and `0666
    | IPC_CREATE` is used to tell `shmget()` that we would like to open the memory
    with read and write permissions, and create the shared memory file if it doesn''t
    exist.'
  prefs: []
  type: TYPE_NORMAL
- en: The result of `shmget()` is a handle that can be used by `shmat()` to return
    a pointer to the shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that a more complete example would wrap this shared memory
    in a class so that RAII can be used as well as leveraging the GSL to properly
    protect the buffer that is shared between both processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parent process, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, the parent sleeps for one second before outputting
    to `stdout`. Next, the parent gets the shared memory region, and writes `42` to
    the buffer. Finally, the parent waits for the child to complete before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The child process does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the child process gets the shared memory buffer and waits for the
    buffer to have the value `42`. Once it does, which means the parent process has
    finished outputting to `stdout`, the child outputs to `stdout` and exits.
  prefs: []
  type: TYPE_NORMAL
- en: The exec() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, all the child processes that we have created were copies
    of the parent process, with the same code and memory structure. Although this
    can be done, it is far less likely, as POSIX threads provide the same functionality
    without the issues with shared memory and IPC. POSIX threads will be discussed
    in more detail in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml), *Learning
    to Program POSIX and C++ Threads*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it is more likely that calls to `fork()` will be followed by calls
    to `exec()`. The `exec()` system call is used to override the existing process
    with a completely new process. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we make a call to `execl()`, which is a specific version
    of the `exec()` family of system calls. The `execl()` system call executes the
    first argument to the function, and passes the remaining arguments to the process
    as `argv[]`. The last argument always has to be `nullptr`, just as the last argument
    in `argv[]` is always `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `exec()` (and friends) replaces the current process with the new
    process being executed. As a result, the call to output `Hello World` to `stdout`
    is not called. This is because this call is part of the `a.out` program, not the
    `ls` program, and since `exec()` replaces the current process with the new executable,
    the output never occurs.
  prefs: []
  type: TYPE_NORMAL
- en: This is why `fork()` and `exec()` are usually called together. The call to `fork()`
    creates a new process, while the call to `exec()` takes that new process and executes
    the desired program as that new process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `system()` system call works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When calling `system()`, the `ls` executable is run, and the `system()` function
    waits until the executable is complete. Once it is complete, the execution continues
    and the call to output `Hello World` to `stdout` is made.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the `system()` call forks a new process and runs `exec()` from
    that new process. The parent process runs `wait()` and returns when the child
    process is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we can make our own version of the system call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the `mysystem()` function, we execute `fork()` to create a new child process
    and then execute `execlp()` to execute `ls`. (The call to `execlp()` will be explained
    later.)
  prefs: []
  type: TYPE_NORMAL
- en: The parent process calls `wait()`, and waits for the newly-created child process
    to complete. Once it is complete, the call to `mysystem()` finishes, allowing
    the output of `Hello World` to execute.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that there are a couple of improvements that would make this
    function more complete. The actual `system()` function passes arguments to the
    `exec()` call, which our version does not.
  prefs: []
  type: TYPE_NORMAL
- en: The `wait()` call doesn't check to make sure that the child process that completed
    was the process that was forked either. Instead, the call to `wait()` should loop
    until the child process that was forked actually completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass arguments to the child process, we can do the following using `execl()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we execute `/bin/ls` and pass `-al` to the process.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument, which is `ls`, is the same as `argv[0]`, which is always
    the name of the process. And just as with `argv[argc] == nullptr`, our last argument
    is `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are different versions of `exec()`. See the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `execle()` version does the same thing as `execl()`, but also provides the
    ability to pass in environment variables. In this case, we provide `ls` with the
    process-specific environment variables `ENV1` and `ENV2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `execl()` function so far have taken an absolute path to `ls`. Instead
    of using the absolute path, the `PATH` environment variable can be used to locate
    the executable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The call to `execlp()` locates `ls` using `PATH`, instead of using an absolute
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the `exec()` family also provides the ability to detail the
    `argv[]` arguments using a variable, instead of directly as a function argument
    to `exec()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, the `execv()` calls allow you to define `argv[]` as a separate
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: One issue with the `execv()` family of calls is that `argv[]` is technically
    an array of pointers to C-style strings, which take the form `const char *` in
    C++. However, calls to `execv()` and friends take `char**`, not `const char**`,
    which means that `const_cast` is needed to convert the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `execv()` family also provides the ability to pass in environment variables,
    just like `execl()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we pass in the `argv[]` arguments and the environment
    variables using `execve()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is also possible to use the path to locate the executable, instead
    of using an absolute value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `PATH` environment variable is used to locate `ls`.
  prefs: []
  type: TYPE_NORMAL
- en: Output redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have outlined all the system calls that are needed to write
    your own shell. You can now create your own processes, load an arbitrary executable,
    and wait for the process to complete.
  prefs: []
  type: TYPE_NORMAL
- en: There are still a couple of things needed to create a complete shell. One of
    these is Unix signals, which will be discussed shortly; the other is capturing
    the output of a child process.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will leverage a Unix pipe for IPC and tell the child process
    to redirect its output to this pipe so that the parent process can receive it.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the same Unix pipe class that we created in
    the previous example. The difference, however, is that the child process will
    not write to the Unix pipe, but will output to `stdout`. So, we need to redirect
    the output of `stdout` to our Unix pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we replace the `write()` function with `redirect()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this `redirect()` function, we tell the operating system to redirect all
    writes to `stdout` that are made to our pipe (the write side of the pipe). As
    a result, when the child process writes to `stdout`, the writes are redirected
    to the read side of the pipe for the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the pipe handles for the child process are no longer needed (and
    are closed before executing the child process).
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the example is similar to our call to our custom `mysystem()` call,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: A child process is created. Before we execute the `ls` command, we redirect
    the output of the child process. The parent process, just like `mysystem()`, waits
    for the child process to complete, and then reads the contents of the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: To create your own complete shell, a lot more functionality would be needed,
    including providing asynchronous access to a child process's output for both `stdout`
    and `stderr`, the ability to execute processes in the foreground and background,
    parsing arguments, and so on. However, the bulk of the concepts that are needed
    have been provided here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how Unix signals work.
  prefs: []
  type: TYPE_NORMAL
- en: Unix signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix signals provide the ability to interrupt a given process, and allow a child
    to receive this interruption and handle it any way they wish.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, Unix signals provide the user with the ability to handle specific
    types of control flow and errors that might occur, such as a Terminal attempting
    to close your program, or a segmentation fault that might be recoverable.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a process that executes forever, outputting
    `Hello World` every second. To stop this application, we must use the `CTRL+C`
    command, which tells the shell to terminate the process. This is done using a
    Unix signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can trap this signal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a loop that outputs `Hello World` to `stdout` every
    second, and does so 10 times. We then install a signal handler using the `signal()`
    function. This signal handler tells the operating system that we would like to
    call the `handler()` function any time `SIGINT` is called.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, now, if we use `CTRL+C`, the signal handler is called instead,
    and we see `handler called` output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that, since we successfully handled `SIGINT`, using `CTRL+C`
    no longer kills the process, which is why we used a `for()` loop instead of a
    `while(1)` loop. You could also use `CTRL+/` to send `SIGSTOP` instead of `SIGINT`,
    which would also kill the application in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to overcome this would be to use a global variable capable of stopping
    the loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This example is identical to our previous example, except that we use a `while()`
    loop, which loops until the `loop` variable is `false`. In our signal handler,
    we set the `loop` variable to `true`, which stops the loop. This works because
    the signal handler is not executed in the same thread as the `while()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: This is important to understand, as deadlock, corruption, and race conditions
    can occur when using signal handlers if these types of issues are not addressed.
    For more information on threading, see [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),* Learning
    to Program POSIX and C++ Threads*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, before we conclude, the `kill()` function can be used to send a signal
    to a child process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created our `mysystem()` function call again, but this time,
    in the parent, we killed the child process after two seconds instead of waiting
    for it to complete. We then compiled our `while(1)` example and renamed it `b.out`.
  prefs: []
  type: TYPE_NORMAL
- en: We then executed the child process, which will execute forever, or until the
    parent sends the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a comprehensive overview of the Linux (System V)
    ABI. We discussed the register and stack layout, the System V calling convention,
    and the ELF specification.
  prefs: []
  type: TYPE_NORMAL
- en: We then reviewed the Unix filesystem, including the standard filesystem layout
    and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we reviewed how to work with Unix processes, including common functions
    such as `fork()`, `exec()`, and `wait()`, as well as IPC.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter concluded with a brief overview of Unix-based signals
    and how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will provide a comprehensive look at console input and
    output using C++.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the first return register for the System V architecture (64-bit) on
    Intel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the first argument register for the System V architecture (64-bit) on
    Intel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When pushing to the stack on Intel, do you add or subtract the stack pointer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between segments and sections in ELF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is stored in the `.eh_frame` section in an ELF file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `fork()` and `exec()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating a Unix pipe, which file handle is the write file handle? The first,
    or the second?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the return value of the `wait()` system call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c-multithreading-cookbook](https://www.packtpub.com/application-development/c-multithreading-cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
