- en: Working with Trees and Networks
  prefs: []
  type: TYPE_NORMAL
- en: Networks are objects that contain *n**odes*and *edges* between pairs of nodes.
    They can be used to represent a wide variety of real-world situations, such as
    distribution and scheduling. Mathematically, networks are useful for visualizing
    combinatorial problems and make for a rich and fascinating theory.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, several different kinds of networks. We will mostly deal
    with simple networks, where edges connect two distinct nodes (so there are no
    self-loops), there is, at most, one edge between any two nodes, and all the edges
    are bidirectional. A *tree*is a special kind of network in which there are no
    cycles; that is, there are no lists of nodes in which each node is connected to
    the following node by an edge, and the final node is connected to the first. Trees
    are especially simple in terms of their theory because they connect a number of
    nodes with the fewest possible edges. A *complete network*is a network in which
    every node is connected to every other node by an edge.
  prefs: []
  type: TYPE_NORMAL
- en: Networks can be directed, where each edge has a source and a destination node
    or can carry additional attributes such as weights. Weighted networks are especially
    useful in certain applications. There are also networks in which we allow multiple
    edges between two given nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create, manipulate, and analyze networks,
    and then apply network algorithms to solve various problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the literature, especially in mathematical texts, networks are more commonly
    called *graphs*. Nodes are sometimes called *vertices*. We favor the term network
    to avoid confusion with the more common usage of graph to mean a plot of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating networks in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the basic characteristics of networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the adjacency matrix for a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating directed and weighted networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the shortest paths in a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantifying clustering in a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding minimal spanning trees and dominating sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will primarily use the NetworkX package for working with
    trees and networks. This package can be installed using your favorite package
    manager, such as `pip:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We usually import this under the alias `nx`, following the conventions established
    in the official NetworkX documentation, using the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code for this chapter can be found in the `Chapter 05` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2WJQt4p](https://bit.ly/2WJQt4p).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating networks in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to solve the multitude of problems that can be expressed as network
    problems, we first need a way of creating networks in Python. For this, we will
    make use of the NetworkX package and the routines and classes it provides to create,
    manipulate, and analyze networks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create an object in Python that represents a network and
    add nodes and edges to this object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the *Technical requirements* section, we need the NetworkX
    package to be imported under the alias `nx` by using the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Python representation of a simple graph:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new `Graph`object that will store the nodes and edges that
    constitute the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the nodes for the network using the `add_node` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid calling this method repetitively, we can use the `add_nodes_from`
    method to add nodes from an iterable such as a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add edges between the nodes that we''ve added using either
    the `add_edge` method or the `add_edges_from` method, which add either a single
    edge or a list of edges (as tuples), respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we retrieve a view of the current nodes and edges in a graph by accessing
    the `nodes` and `edges` attributes, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NetworkX package adds several classes and routines for creating, manipulating,
    and analyzing networks using Python. The `Graph` class is the most basic class
    for representing networks that do not contain multiple edges between any given
    nodes and where their edges are undirected (bidirectional).
  prefs: []
  type: TYPE_NORMAL
- en: Once a blank `Graph` object has been created, we can add new nodes and edges
    using the methods described in this recipe. In this recipe, we created nodes that
    hold integer values. However, a node can hold any hashable Python object except
    `None.` Moreover, associated data can be added to a node via keyword arguments
    passed to the `add_node` method. Attributes can also be added when using the `add_nodes_from`
    method by supplying a list of tuples containing the node object and a dictionary
    of attributes. The `add_nodes_from` method is useful for adding nodes in bulk,
    while `add_node` is useful for attaching individual nodes to an existing network.
  prefs: []
  type: TYPE_NORMAL
- en: An edge in a network is a tuple containing two (distinct) nodes. In a simple
    network, such as the one represented by the basic `Graph` class, there can be,
    at most, one edge between any two given nodes. The edges are added via the `add_edge`
    or `add_edges_from` methods, which add either a single edge or a list of edges
    to the network, respectively. As for the nodes, edges can hold arbitrary associated
    data via an attributes dictionary. In particular, weights can be added by supplying
    the `weight` attribute when adding edges. We will provide more details about weighted
    graphs in the *Creating directed and weighted networks* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `nodes` and `edges` attributes hold the nodes and edges that constitute
    the network, respectively. The `nodes` attribute returns a `NodesView` object,
    which is a dictionary-like interface to the nodes and their associated data. Similarly,
    the `edges` attribute returns an `EdgeView` object. This can be used to inspect
    individual edges and their associated data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Graph` class represents *simple networks*, which are networks in which
    nodes are joined by, at most, one edge, and the edges are not directed. We will
    discuss directed networks in the *Creating directed and weighted networks* recipe.
    There is a separate class for representing networks in which there can be multiple
    edges between a pair of nodes called `MultiGraph`. All of the network types allow
    self-loops, which are sometimes not allowed in a "simple network" in the literature,
    where a simple network typically refers to an undirected network with no self-loops.
  prefs: []
  type: TYPE_NORMAL
- en: All network types offer various methods for adding nodes and edges, as well
    as inspecting the current nodes and edges. There are also methods for copying
    networks into some other kind of network or extracting subnetworks. There are
    also several utility routines in the NetworkX package for generating standard
    networks and adding subnetworks to an existing network.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX also provides various routines for reading and writing networks to
    different file formats, such as GraphML, JSON, and YAML. For example, we can write
    a network to a GraphML file using the `nx.write_graphml` routine and read it using
    the `nx.read_graphml` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common first step in analyzing a network is to draw the network, which can
    help us identify some of the prominent features of a network. (Of course, drawings
    can be misleading, so we should not rely on them too heavily in our analysis.)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll describe how to use the network drawing facilities in
    the NetworkX package to visualize a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need to import the NetworkX package under the name
    `nx`, as described in the *Technical requirements* section. We will also need
    the Matplotlib package. For this, as usual, we import the `pyplot` module as `plt`
    using the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to draw a simple network object using the drawing
    routines from NetworkX:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a simple example network to draw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create new Matplotlib `Figure` and `Axes` objects for it, ready to
    plot the network using the `subplots` routine from `plt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a layout that will be used to position the nodes on the
    figure. For this figure, we shall use a shell layout using the `shell_layout`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `draw` routine to draw the network on the figure. Since we have
    already created a Matplotlib `Figure` and `Axes`, we will supply the `ax` keyword
    argument. We will also add labels to the nodes using the `with_labels` keyword
    argument and specify the layout that we just created using the `pos` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting drawing can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b625495-d1f5-44db-9a3e-dbb369a33298.png)Figure 5.1: A drawing of
    a simple network arranged using a shell layout'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `draw` routine is a specialized plotting routine specifically for drawing
    networks. The layout we created specifies the coordinates at which each of the
    nodes will be placed. We used a *shell layout*, which arranges the nodes in a
    concentric circle arrangement, which is determined by the nodes and edges of the
    network. By default, the `draw` routine creates a randomized layout.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` routine has numerous keyword arguments for customizing the appearance
    of the plotted network. In this recipe, we added the `with_labels` keyword argument
    to label the nodes in the figure according to the objects they hold. The nodes
    hold integers, which is why the nodes in the preceding figure are labeled by integers.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a set of axes separately using the `plt.subplots` routine. This
    isn't strictly necessary since the `draw` routine will automatically create a
    new figure and axes if they're not provided.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NetworkX package provides several layout-generating routines, similar to
    the `shell_layout` routine that we used in this recipe. The layout is simply a
    dictionary, indexed by the nodes, whose elements are the *x* and *y* coordinates
    of the position where the node should be plotted. The NetworkX routines for creating
    layouts represent common arrangements that will be useful for most cases, but
    you can also create custom layouts, should you need them. A full list of the different
    layout creation routines is provided in the NetworkX documentation. There are
    also shortcut drawing routines that will use a specific layout with the need to
    create the layout separately; for example, the `draw_shell` routine will draw
    the network with the shell layout that is equivalent to the `draw` call given
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` routine takes a number of keyword arguments to customize the appearance
    of the figure. For example, there are keyword arguments to control the node's
    size, color, shape, and transparency. We can also add arrows (for directed edges)
    and/or only draw a specific set of nodes and edges from the network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the basic characteristics of networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks have various basic characteristics beyond the number of nodes and edges
    that are useful for analyzing a graph. For example, the*degree*of a node is the
    number of edges that start (or end) at that node. A higher degree indicates that
    the node is better connected to the rest of the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to access the basic attributes and compute
    various basic measures associated with a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we need to import the NetworkX package under the name `nx`. We also
    need to import the Matplotlib `pyplot` module under the name `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to access the various basic characteristics of a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a sample network that we will analyze in this recipe, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it is good practice to draw the network and arrange the nodes in a circular
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure. As we can see, the
    network is split into two distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c4e518ea-19a9-4785-bb2c-00494cf4da5a.png)Figure 5.2: Simple network
    drawn in a circular arrangement. There are two distinct components visible in
    this network'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `nx.info` routine to display some basic information about
    the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use the `degree` property of the `Graph` object to retrieve the degree
    of a specific node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the connected components of the network using the `connected_components`
    routine, which returns a generator that we make into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We compute the *density* of a network using the `density` routine, which returns
    a float between 0 and 1\. This represents the proportion of edges meeting the
    node to the total number of possible edges at the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can determine whether a network is *planar*– meaning that no two
    edges need to be drawn crossing one another – by using the `check_planarity` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `info` routine generates a small summary of the network, including the type
    of the network (which is a simple `Graph` type in this recipe), the number of
    nodes and edges, and the average degrees of the nodes in the network. The actual
    degree of a node in the network can be accessed using the `degree` property, which
    offers a dictionary-like interface for finding the degree of each node.
  prefs: []
  type: TYPE_NORMAL
- en: A set of nodes is said to be connected if every node in the set is joined to
    the others by an edge or sequence of edges. The *connected components* of a network
    are the largest sets of nodes that are connected. Any two distinct connected components
    are obviously disjointed. Every network can be decomposed into one or more connected
    components. The network we defined in this recipe has two connected components,
    `{0, 1, 2, 3, 4, 5}` and `{8, 9, 6, 7}`. These are clearly visible in the preceding
    figure, where the first connected component is drawn above the second connected
    component. In this figure, we can trace a path along the edges of the network
    from any node in a component to any other; for example, from 0 to 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The *density* of a network measures the ratio of the number of edges in the
    network to the total possible number of edges given by the number of nodes in
    a network. The density of a complete network is 1, but in general, the density
    will be less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: A network is *planar* if it can be drawn on a flat surface without crossing
    edges. The easiest example of a non-planar network is a complete network with
    five nodes. Complete networks with, at most, four nodes are planar. A little experimentation
    with the way you draw these networks on paper will reveal a drawing that doesn't
    contain crossing edges. In addition, any network that contains a complete graph
    with at least five nodes is not planar. Planar networks are important in theory
    due to their relative simplicity, but they are less common in networks that arise
    in applications.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the methods on the network classes, there are a number of other
    routines in the NetworkX package that can be used to access the attributes of
    the nodes and edges in a network. For example, `nx.get_node_attributes` gets a
    named attribute from each node in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the adjacency matrix for a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One potent tool in the analysis of graphs is the adjacency matrix, which has
    entries *a[ij]* = 1 if there is an edge from node *i* to node *j*,*and 0 otherwise.
    For most networks, the adjacency matrix will be sparse (most of the entries are
    0). For networks that are not directed, the matrix will also be symmetric (*a[ij]*
    =**a**[ji]*). There are numerous other matrices that can be associated with a
    network. We will briefly discuss these in the *There's more...* section of this
    recipe.**
  prefs: []
  type: TYPE_NORMAL
- en: '**In this recipe, we will generate the adjacency matrix for a network and learn
    how to get some basic properties of the network from this matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the NetworkX package imported under the name `nx`,
    and the NumPy module imported under the name `np`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to generate the adjacency matrix for a network
    and derive some simple properties of the network from this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will generate a network to work with throughout this recipe. We''ll
    generate a random network with five nodes and five edges while using a seed for
    reproducibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate the adjacency matrix, we use the `adjacency_matrix` routine from
    NetworkX. This returns a sparse matrix by default, so we will also convert this
    into a full NumPy array for this demonstration using the `todense` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the *n*th power of the adjacency matrix gives us the number of paths
    of length *n* from one node to another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dense_gnm_random_graph` routine generates a (dense) random network, chosen
    uniformly from the family of all networks with *n* nodes and *m* edges. In the
    recipe, *n=5* and *m=5*. The dense prefix indicates that this routine uses an
    algorithm that should be faster than the alternative `gnm_random_graph` for dense
    networks with a relatively large number of edges compared to nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The adjacency matrix of a network is easy to generate, especially in sparse
    form, when the graph is relatively small. For larger networks, this can be an
    expensive operation, so it might not be practical, particularly if you convert
    it into a full matrix, as we saw in this recipe. You don't need to do this in
    general, since we can simply use the sparse matrix generated by the `adjacency_matrix`
    routine and the sparse linear algebra tools in the SciPy `sparse` module instead.
  prefs: []
  type: TYPE_NORMAL
- en: The matrix powers provide information about the number of paths of a given length.
    This can easily be seen by tracing through the definitions of matrix multiplication.
    Remember that the entries of the adjacency matrix are 1 when there is an edge
    (path of length 1) between two given nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Eigenvalues of the adjacency matrix for a network provide some additional
    information about the structure of the network, such as the bounds for the chromatic
    number of the network. (See the *Coloring a network* recipe for more information
    about coloring a network.) There is a separate routine for computing the Eigenvalues
    of the adjacency matrix. For example, we can use the `adjacency_spectrum` routine
    to generate the Eigenvalues of the adjacency matrix of a network. Methods involving
    the Eigenvalues of a matrix associated with a network are usually called *spectral
    methods*.
  prefs: []
  type: TYPE_NORMAL
- en: There are other matrices associated with networks, such as the *incidence matrix*
    and the *Laplacian matrix*. The incidence matrix of a network is an *M × N* matrix,
    where *M* is the number of nodes and *N* is the number of edges. This has an *i-j*th
    entry of 1 if node *i* appears in edge *j* and 0 otherwise. The Laplacian matrix
    of a network is defined to be the *L = D - A* matrix, where *D* is the diagonal
    matrix containing the degrees of the nodes in the network and *A* is the adjacency
    matrix of the network. Both of these matrices are useful for analyzing networks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating directed and weighted networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple networks, such as those described in the previous recipes, are useful
    for describing networks where the direction of an edge is unimportant and where
    the edges carry equal weight. In practice, most networks carry additional information,
    such as weights or direction.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a directed and weighted network and explore some
    of the basic properties of such networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the NetworkX package, imported under the name
    `nx` (as usual), the Matplotlib `pyplot` module imported as `plt`, and the NumPy
    package imported as `np`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to create a directed network with weights,
    as well as how to explore some of the properties and techniques we discussed in
    the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a directed network, we use the `DiGraph` class from NetworkX rather
    than the simple `Graph` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we add nodes to the network using the `add_node` or `add_nodes_from`
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To add weighted edges, we can use either the `add_edge` method and provide
    the `weight` keyword argument, or use the `add_weighted_edges_from` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we draw the network with arrows to indicate the direction of each edge.
    We also provide our own positions for this plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6fc068a8-7008-4108-935e-59128098ca32.png)Figure 5.3: A weighted,
    directed network'
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency matrix of a directed matrix is created in the same way as a simple
    network, but the resulting matrix will not be symmetric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DiGraph` class represents a directed network, where the order of the nodes
    when adding an edge is important. In this recipe, we added two edges for connecting
    nodes 2 and 3, one in each direction. In a simple network (the `Graph` class),
    the addition of the second edge would not add an additional edge. However, for
    a directed network (the `DiGraph` class), the order that the nodes are given in
    when adding the edge determines the direction.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing special about weighted edges except for the addition of the
    `weight` attribute that's attached to the edge. (Arbitrary data can be attached
    to an edge or node in a network via keyword arguments.) The `add_weighted_edges_from`
    method simply adds the corresponding weight value (the third value in the tuple)
    to the edge in question. Weights can be added to any edge in any network, not
    just the directed networks shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` routine automatically adds arrows to edges when drawing a directed
    network. This behavior can be turned off by passing the `arrows=False` keyword
    argument. The adjacency matrix for a directed or weighted network also differs
    from that of a simple network. In a directed network, the matrix is not generally
    symmetrical, because edges may exist in one direction but not the other. For a
    weighted network, the entries can be different from 1 or 0, and will instead be
    the weight of the corresponding edge.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weighted networks appear in lots of applications, such as when describing transportation
    networks with distances or speeds. You can also use networks to examine flow through
    a network by providing a "capacity" for edges in the network (as a weight or as
    another attribute). NetworkX has several tools for analyzing flow through a network,
    such as finding the maximum flow through a network via the `nx.maximum_flow` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Directed networks add directional information to a network. Many real-world
    applications give rise to networks that have unidirectional edges, such as those
    in industrial processes or supply chain networks. This additional directional
    information has consequences for many of the algorithms for working with networks,
    as we'll see throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the shortest paths in a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem where networks make an appearance is in the problem of finding
    the shortest – or perhaps more precisely, the highest reward – route between two
    nodes in a network. For instance, this could be the shortest distance between
    two cities, where the nodes represent the cities and the edges are roads connecting
    pairs of cities. In this case, the weights of the edges would be their lengths.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will find the shortest path between two nodes in a network
    with weights.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NetworkX package imported, as usual, under
    the name `nx`, the Matplotlib `pyplot` module imported as `plt`, and a random
    number generator object from NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to find the shortest path between two nodes in a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a random network using `gnm_random_graph` and a `seed`
    for this demonstration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll draw the network with a circular arrangement to see how the nodes
    connect to each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following image. Here, we can see that
    there is no direct edge from node 7 to node 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fd59d73-0edf-44a2-b3bc-ad06f989d549.png)Figure 5.4: A randomly
    generated network with 10 nodes and 17 edges'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a weight to each of the edges so that some routes are preferable
    to others in terms of the shortest path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will compute the shortest path from node 7 to node 9 using the `nx.shortest_path`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can find the length of this shortest path using the `nx.shortest_path_
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'length` routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shortest_path` routine computes the shortest path between each pair of
    nodes. Alternatively, when supplied with the source and destination node, which
    is what we did in this recipe, it computes the shortest path between the two specified
    nodes. We supplied the optional `weight` keyword argument, which makes the algorithm
    find the shortest path according to the "weight" attribute of the edge. This argument
    changes the meaning of "shortest", with the default being "fewest edges".
  prefs: []
  type: TYPE_NORMAL
- en: The default algorithm for finding the shortest path between two nodes is Dijkstra's
    algorithm, which is a staple of computer science and mathematics courses. It is
    a good general-purpose algorithm but is not particularly efficient. Other route-finding
    algorithms include the A* algorithm. Greater efficiency can be obtained by using
    the A* algorithm with additional heuristic information to guide node selection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many algorithms for finding the shortest path between two nodes in
    a network. There are also variants for finding the maximum weighted path.
  prefs: []
  type: TYPE_NORMAL
- en: There are several related problems regarding finding the paths in a network,
    such as the *traveling salesperson problem* and the *route inspection problem*.
    In the traveling salesperson problem, we find a cycle (a path starting and ending
    at the same node) that visits every node in the network, with the smallest (or
    largest) total weight. In the route inspection problem, we seek the shortest cycle
    (by weight) that traverses every edge in the network and returns to the starting
    point. The traveling salesperson problem is known to be NP-hard, but the route
    inspection problem can be solved in polynomial time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A famous problem in graph theory is the bridges at Königsberg, which asks to
    find a path in a network that traverses every edge in the network exactly once.
    It turns out, as proved by Euler, that finding such a path in the Königsberg bridges
    problem is impossible. A path that traverses every edge exactly once is called
    an *Eulerian circuit*. A network that admits an Eulerian circuit is called *Eulerian*.
    In fact, a network is Eulerian if and only if every node has an even degree. The
    network representation of the Königsberg bridge problem can be seen in the following
    image. The edges in this represent the different bridges over the rivers, while
    the nodes represent the different landmasses. We can see that all four of the
    nodes have an odd degree, which means that there cannot be a path that crosses
    every edge exactly once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7112954f-14cd-4a8f-bd16-4b169cb53854.png)Figure 5.5: A network representing
    the Königsberg bridge problem'
  prefs: []
  type: TYPE_NORMAL
- en: The edges represent the bridges between the different landmasses represented
    by the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifying clustering in a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various quantities associated with networks that measure the characteristics
    of the network. For example, the clustering coefficient of a node measures the
    interconnectivity between the nodes nearby (here, nearby means connected by an
    edge). In effect, it measures how close the neighboring nodes are to forming a
    complete network or *clique*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The clustering coefficient of a node measures the proportion of the adjacent
    nodes that are connected by an edge; that is, two adjacent nodes form a triangle
    with the given node. We count the number of triangles and divide this by the total
    number of possible triangles that could be formed, given the degree of the node.
    Numerically, the clustering coefficient at a node, *u*, in a simple unweighted
    network is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7175e9d6-ae3e-4e69-8065-dd93d7cc68a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *T[u]* is the number of triangles at *u* and the denominator is the total
    possible number of triangles at *u*. If the degree of *u (*the number of edges
    from *u)* is 0 or 1, then we set *c[u]* to 0.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to compute the clustering coefficient of a
    node in a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the NetworkX package imported as `nx` and the
    Matplotlib `pyplot` module imported as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you how to compute the clustering coefficient of a
    node in a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a sample network to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will draw the network so that we can compare the clustering coefficients
    that we''ll be calculating. This will allow us to see how these nodes appear in
    the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d9a21b9-1aff-4fe9-aef8-c38936faeb8f.png)Figure 5.6: Sample network
    for testing clustering'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can compute the clustering coefficients of the nodes in the network
    using the `nx.clustering` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `nx.clustering` routine is a dictionary over the nodes in
    the network. So, we can print some selected nodes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The average clustering coefficient for all the nodes in the network can be
    computed using the `nx.average_clustering` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The clustering coefficient of a node measures how close the neighborhood of
    that node is to being a complete network (all the nodes are connected to one another).
    In this recipe, we can see that we have three different computed values: 0 has
    a clustering coefficient of 0.5, 2 has a clustering coefficient of 1.0, and 6
    has a clustering coefficient of 0\. This means that the nodes connected to node
    2 form a complete network, which is because we designed our network in this way.
    (Nodes 0-4 form a complete network by design.) The neighborhood of node 6 is very
    far from being complete since there are no interconnecting edges between either
    of its neighbors.'
  prefs: []
  type: TYPE_NORMAL
- en: The average clustering value is a simple average of the clustering coefficients
    over all the nodes in the network. It is not quite the same as the global clustering
    coefficient (computed using the `nx.transitivity` routine in NetworkX), but it
    does give us an idea of how close the network as a whole is to being a complete
    network. The global clustering coefficient measures the ratio of the number of
    triangles to the number of triplets – a collection of three nodes that are connected
    by at least two edges – over the whole network.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between average clustering is quite subtle. The global clustering
    coefficient measures the clustering of the network as a whole, but the average
    clustering coefficient measures how much, on average, the network is locally clustered.
    The difference is best seen in a windmill network, which consists of a single
    node surrounded by a circle of an even number of nodes. All the nodes are connected
    to the center, but the nodes on the circle are only connected in an alternating
    pattern. The outer nodes have a local clustering coefficient of 1, while the center
    node has a local clustering coefficient of 1/(2*N - 1*), where *N*denotes the
    number of triangles joining to the center node.However, the global clustering
    coefficient is 3/(2*N*- 1).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clustering coefficients are related to *cliques* in a network. A clique is a
    subnetwork that is complete (all the nodes are connected by an edge). An important
    problem in network theory is finding the maximal cliques in a network, which is
    a very difficult problem in general (here, maximal means "cannot be made larger").
  prefs: []
  type: TYPE_NORMAL
- en: Coloring a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks are also useful in scheduling problems, where you need to arrange activities
    into different slots so that there are no conflicts. For example, we could use
    networks to schedule classes to make sure that students who are taking different
    options do not have to be in two classes at once. In this scenario, the nodes
    will represent the different classes and the edges will indicate that there are
    students taking both classes. The process we use to solve these kinds of problems
    is called *network coloring*. This process involves assigning the fewest possible
    colors to the nodes in a network so that no two adjacent nodes have the same color.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to color a network to solve a simple scheduling
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need the NetworkX package imported as `nx` and the Matplotlib
    `pyplot` module imported as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to solve a network coloring problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a sample network to use in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will draw the network so that we can understand the coloring when
    it is generated. For this, we will use the `draw_circular` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fa56224e-7a2e-46d1-9e84-914d97c8c558.png)Figure 5.7: Example network
    for a simple scheduling problem'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will generate the coloring using the `nx.greedy_color` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the actual colors that were used in this coloring, we will generate
    a set of values from the `coloring` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nx.greedy_color` routine colors the network using one of a number of possible
    strategies. By default, it works in order of degree from largest to smallest.
    In our case, it started by assigning color 0 to node 2, which has a degree of
    6, then color 1 to node 0, which has a degree of 4, and so on. The first available
    color is chosen for each node in this sequence. This is not necessarily the most
    efficient algorithm for coloring a network.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, any network can be colored by assigning every node a different color,
    but in most cases, fewer colors are necessary. In the recipe, the network has
    seven nodes, but only four colors are required. The smallest number of colors
    necessary is called the *chromatic number* of the network.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several variations of the coloring problem for networks. One such
    variation is the *list coloring problem*, in which we seek a coloring for a network
    where each node is given a color from a predefined list of possible colors. This
    problem is obviously more difficult than the general coloring problem.
  prefs: []
  type: TYPE_NORMAL
- en: The general coloring problem has surprising results. For example, every planar
    network can be colored by, at most, four different colors. This is a famous theorem
    from graph theory called the *four-color theorem*, and was proved by Appel and
    Haken in 1977\.
  prefs: []
  type: TYPE_NORMAL
- en: Finding minimal spanning trees and dominating sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks have applications for a wide variety of problems. Two obvious areas
    that see many applications are communication and distribution. For example, we
    might wish to find a way of distributing goods to a number of cities (nodes) in
    a road network that covers the smallest distance from a particular point. For
    problems like this, we need to look at minimal spanning trees and dominating sets.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will find a minimal spanning tree and a dominating set in
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to import the NetworkX package under the name `nx`
    and the Matplotlib `pyplot` module as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to find a minimum spanning tree and dominating set for a
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a sample network to analyze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as usual, we will draw the network before doing any analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The minimum spanning tree can be computed using the `nx.minimum_
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'spanning_tree` routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will overlay the edges of the minimum spanning tree onto the plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will find a dominating set – a set where every node in the network
    is adjacent to at least one node from the set – for the network using the `nx.dominating_set`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A plot of the network with the minimum spanning tree overlaid can be seen in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e8ca1be-4fd3-4ce2-9121-76182b51937e.png)Figure 5.8: The network
    drawn with the minimum spanning tree overlaid'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *spanning tree* of a network is a tree contained in the network that contains
    all the nodes. A *minimum* spanning tree is a spanning tree that contains the
    fewest edges possible – or, alternatively, has the lowest total weight. Minimum
    spanning trees are useful for distribution problems over a network. A simple algorithm
    for finding minimum spanning trees is to simply select edges (of smallest weight
    first, if the network is weighted) in such a way that it does not create cycles
    until this is no longer possible.
  prefs: []
  type: TYPE_NORMAL
- en: A *dominating set* for a network is a set of vertices where every node in the
    network is adjacent to at least one node in the dominating set. Dominating sets
    have applications in communication networks. We are often interested in finding
    minimal dominating sets, but this is computationally difficult. In fact, testing
    whether there is a dominating set that's smaller than a given size is NP-complete.
    However, there are some efficient algorithms for finding the smallest dominating
    sets for certain classes of graphs. Informally speaking, the problem is that once
    you've identified a candidate for a minimum size dominating set, you have to verify
    that there are no dominating sets that are smaller in size. This is obviously
    very difficult if you do not know all the possible dominating sets in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several classical texts on graph theory, including books by Bollobás
    and Diestel:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Diestel, R., 2010\. Graph Theory. 3rd ed. Berlin: Springer.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bollobás, B., 2010\. Modern Graph Theory. New York, NY: Springer.***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
