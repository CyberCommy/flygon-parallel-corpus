- en: Chapter 2 – Strings and collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python includes a rich selection of built-in collection types which are often
    completely sufficient for even quite intricate programs without resorting to defining
    our own data structures. We’ll give an overview of some of these fundamental collection
    types now – enough to allow us to write some interesting code – although we’ll
    be revisiting each of these collection types, together with a few additional ones,
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`str` – immutable strings of Unicode code points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes` – immutable strings of bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` – mutable sequences of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict` – mutable mappings from keys to values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we’ll also cover Python’s for-loops.
  prefs: []
  type: TYPE_NORMAL
- en: '`str` – an immutable sequence of Unicode code points'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings in Python have the datatype `str` and we’ve been using them extensively
    already. A string is a sequence of Unicode code-points, and for the most part
    you can think of code-points as being like characters, although they aren’t strictly
    equivalent. The sequence of code-points in a Python string is immutable, so once
    you’ve constructed a string, you can’t modify its contents.
  prefs: []
  type: TYPE_NORMAL
- en: String quoting styles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Literal strings in Python are delimited by quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use single quotation marks, as we have above. Or you can use double
    quotation marks, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You must, however, be consistent. For example, you can’t use a double quotation
    mark paired with a single quotation mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Supporting both quoting styles allows you to easily incorporate the other quote
    character into the literal string without resorting to ugly escape character gymnastics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the REPL exploits the same quoting flexibility when echoing the
    strings back to us.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m02----zen-practicality-beats-purity.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first sight support for both quoting styles seems to violate an important
    principle of Pythonic style. From the Zen of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: “There should be one – and preferably only one – obvious way to do it.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this case, however, another aphorism from the same source takes precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: ”…practicality beats purity,”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The utility of supporting two quoting styles is valued more highly than the
    alternative: a single quoting style combined with more frequent use of ugly escape
    sequences, which we’ll encounter shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation of adjacent strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adjacent literal strings are concatenated by the Python compiler into a single
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although at first this seems rather pointless, it can be useful for nicely formatting
    code as we’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline strings and newlines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want a literal string containing newlines, you have two options: Use
    multiline strings, or use escape sequences. First, let’s look at multiline strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline strings are delimited by three quote characters rather than one.
    Here’s an example using three double-quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, when the string is echoed back to us, the newlines are represented
    by the `\n` escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use three single-quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative to using multiline quoting, we can just embed the control
    characters ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a better sense of what we’re representing in this case, we can use the
    built-in `print()` function to see the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you’re working on Windows, you might be thinking that newlines should be
    represented by the carriage-return, newline couplet `\r\n` rather than just the
    newline character, `\n`. There’s no need to do that with Python, since Python
    3 has a feature called *universal newline support* which translates from the simple
    `\n` to the native newline sequence for your platform on input and output. You
    can read more about Universal Newline Support in [PEP 278](http://www.python.org/dev/peps/pep-0278/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the escape sequences for other purposes, too, such as incorporating
    tabs with `\t` or using quote characters inside strings with `\"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'or the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Python is smarter than we are at using the most convenient
    quote delimiters, although Python will also resort to escape sequences when we
    use both types of quotes in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the backslash has special meaning, to place a backslash in a string
    we must escape the backslash with itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To reassure ourselves that there really is only one backslash in that string,
    we can `print()` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about [escape sequences in the Python documentation](http://docs.python.org/3/reference/lexical_analysis.html#strings)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Raw strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, particularly when dealing with strings such as Windows filesystem
    paths or regular expression patterns ^([2](chap21.xhtml#fn-regex)) which use backslashes
    extensively, the requirement to double-up on backslashes can be ugly and error
    prone. Python comes to the rescue with its raw strings. Raw strings don’t support
    any escape sequences and are very much what-you-see-is-what-you-get. To create
    a raw string, precede the opening quote with a lower-case `r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `str` constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the `str` constructor to create strings representations of other
    types, such as integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'or floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Strings as sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strings in Python are what are called *sequence* types, which means they support
    certain common operations for querying ordered series of elements. For example,
    we can access individual characters using square brackets with an zero-based integer
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to many other programming languages, there is no separate character
    type distinct from the string type. The indexing operation returns a full-blown
    string that just contains a single code point element, a fact we can demonstrate
    using Python’s built-in `type()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ll be looking at types and classes much more later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: String methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'String objects also support a wide variety of operations implemented as methods.
    We can list those methods by using `help()` on the string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you press enter, you should see a display like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On any platform you can browse through the help page by pressing the spacebar
    to advance one page at a time until you see the documentation for the `capitalize()`
    method, skipping over all the methods that begin and end with double underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Press ‘q’ to quit the help browser, and we’ll try to use `capitalize()`. Let’s
    make a string that deserves capitalization – the name of a capital city no less!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To call methods on objects in Python we use the dot after the object name and
    before the method name. Methods are functions, so we must use the parentheses
    to indicate that the method should be called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that strings are immutable, so the `capitalize()` method didn’t modify
    `c` in place. Rather, it returned a new string. We can verify this, by displaying
    `c`, which remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You might like to spend a little time familiarizing yourself with the various
    useful methods provided by the string type by browsing the help.
  prefs: []
  type: TYPE_NORMAL
- en: Strings with Unicode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strings are fully Unicode capable, so you can use them with international characters
    easily, even in literals, because the default source code encoding for Python
    3 is UTF-8\. For example, if you have access to Norwegian characters, you can
    simply enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the hexadecimal representations of Unicode code
    points as an escape sequence prefixed by `\u`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We’re sure you’ll agree, though, that this is somewhat more unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can use the `\x` escape sequence followed by a 2-character hexadecimal
    string to include one-byte Unicode code points in a string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even an use an escaped octal string using a single backlash followed
    by three digits in the range zero to seven, although we confess we’ve never seen
    this used in practice, except inadvertently as a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are no such Unicode capabilities in the otherwise similar `bytes` type,
    which we’ll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: '`bytes` – an immutable sequence of bytes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `bytes` type is similar to the `str` type, except that rather than each
    instance being a sequence of Unicode code points, each instance is a sequence
    of, well, bytes. As such, `bytes` objects are used for raw binary data and fixed-width,
    single-byte character encodings, such as ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: Literal `bytes`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with strings they have a simple, literal form delimited by either single
    or double quotes, although for literal `bytes` the opening quote must be preceded
    by a lower-case `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `bytes` constructor, but it has fairly complex behavior and
    we defer coverage of it to the second book in this series, *The Python Journeyman*.
    At this point in our journey, it’s sufficient for us to recognize `bytes` literals
    and understand that they support many of the same operations as `str`, such as
    indexing and splitting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see that the `split()` method returns a `list` of of `bytes` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between `bytes` and `str`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To convert between `bytes` and `str` we must know the encoding of the byte sequence
    used to represent the string’s Unicode code points as bytes. Python supports a
    wide-variety of so-called *codecs* such as UTF-8, UTF-16, ASCII, Latin-1, Windows-1251,
    and so on – consult the Python documentation for a [current list of codecs](http://docs.python.org/3/library/codecs.html#standard-encodings)
  prefs: []
  type: TYPE_NORMAL
- en: In Python we can *encode* a Unicode `str` into a `bytes` object, and going the
    other way we can *decode* a `bytes` object into a Unicode `str`. In either direction
    it’s up to us to specify the encoding. Python won’t — and generally speaking can’t
    –– do anything to prevent you erroneously decoding UTF-16 data stored in a `bytes`
    object using, say, a CP037 codec for handling strings on legacy IBM mainframes.
    If you’re lucky the decoding will fail with a `UnicodeError` at runtime; if you’re
    unlucky you’ll wind up with a `str` full of garbage that will go undetected by
    your program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Encoding and decoding strings.](images/m02----encoding-decoding.png)'
  prefs: []
  type: TYPE_IMG
- en: Encoding and decoding strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s kick off an interactive session looking at strings, with an interesting
    Unicode string which contains all the characters of the 29 letter Norwegian alphabet
    – a pangram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll now encode that using the UTF-8 codec into a `bytes` object using the
    `encode()` method of the `str` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: See how each of the Norwegian letters has been rendered as a pair of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reverse the process using the `decode()` method of the `bytes` object.
    Again, it is up to us to supply the correct encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that the encoding/decoding round-trip gives us a result equal
    to what we started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'and display it for good measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All this messing about with encodings may seem like unnecessary detail at this
    juncture – especially if you operate in an anglophone environment – but it’s crucial
    to understand since files and network resources such as HTTP responses are transmitted
    as byte streams, whereas we prefer to work with the convenience of Unicode strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`list` – a sequence of objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python `list`s, such as those returned by the string `split()` method, are sequences
    of objects. Unlike strings `list`s are mutable, insofar as the elements within
    them can be replaced or removed, and new elements can be inserted or appended.
    `list`s are the workhorse of Python data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal lists are delimited by square brackets, and the items within the `list`
    are separated by commas. Here is a `list` of three numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a `list` of three strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve elements by using square brackets with a zero-based index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace elements by assigning to a specific element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See how `list`s can be heterogeneous with respect to the type of the contained
    objects. We now have a `list` containing an `str`, an `int`, and another `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s often useful to create an empty list, which we can do using empty square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can modify the `list` in other ways. Let’s add some `float`s to the end
    of the `list` using the `append()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are many other useful methods for manipulating `list`s, which we’ll cover
    in a later chapter. Right now, we just need to be able to perform rudimentary
    `list` operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a `list` constructor, which can be used to create lists from
    other collections, such as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the significant whitespace rules in Python can, at first, seem very
    rigid, there is a lot of flexibility. For example, if you have unclosed brackets,
    braces, or parentheses at the end of a line, you can continue on the next line.
    This can be very useful for representing long literal collections, or improving
    the readability of even short collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also how we’re allowed to use an additional comma after the last element,
    an handy feature that improves the maintainability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '`dict` – associating keys with values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries – embodied in the `dict` type – are completely fundamental to the
    way the Python language works, and are very widely used. A dictionary maps keys
    to values, and in some languages it is known as a map or associative array. Let’s
    look at how to create and use dictionaries in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal dictionaries are created using curly braces containing key-value pairs.
    Each pair is separated by a comma, and each key is separated from its corresponding
    value by a colon. Here we use a dictionary to create a simple telephone directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve items by key using the square brackets operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can update the value associated with a particular key by assigning through
    the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we assign to a key that has not yet been added, a new entry is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that the entries in the dictionary can’t be relied upon to be stored
    in any particular order, and in fact the order that Python chooses may even change
    between runs of the same program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to lists, empty dictionaries can be created using empty curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This has been a *very* cursory look at dictionaries, but we’ll be revisiting
    them in much more detail in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: For-loops – iterating over series of items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the tools to make some interesting data structures, we’ll
    look at Python’s other type of loop construct, the for-loop. For-loops in Python
    correspond to what are called for-each loops in many other programming languages.
    They request items one-by-one from a collection – or more strictly from an iterable
    series (but more of that later) – and assign them in turn to the a variable we
    specify. Let’s create a `list` collection, and use a for-loop to iterate over
    it, remembering to indent the code within the for-loop by four spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'So iterating over a `list` yields the items one-by-one. If you iterate over
    a dictionary, you get just the keys in seemingly random order, which can then
    be used within the for-loop body to retrieve the corresponding values. Let’s define
    a dictionary which maps color name strings to hexadecimal integer color codes
    stored as integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the ability of the built-in `print()` function to accept multiple
    arguments, passing the key and the value for each color separately. See also how
    the color codes returned to us are in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we put some of what we’ve learned together into a useful program,
    practice exiting the Python REPL with `Ctrl-Z` on Windows or `Ctrl-D` on Mac or
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a short detour to try out some of the tools we’ve introduced on a
    slightly larger example. Textbooks typically avoid such pragmatism, especially
    in the early chapters, but we think it’s fun to apply new ideas to practical situations.
    To avoid getting off the the wrong stylistic foot, we’ll need to introduce a few
    “black-box” components to get the job done, but you’ll learn about them in detail
    later, so don’t worry.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to write a longer snippet at the REPL, and briefly introduce the
    `with` statement. Our code will fetch some text data for some classic literature
    from the web using a Python standard library function called `urlopen()`. Here’s
    the code entered at the REPL in full. We’ve annotated this code snippet with line
    numbers to facilitate referring to lines from the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We’ll work through this code, explaining each line in turn.
  prefs: []
  type: TYPE_NORMAL
- en: To get access to `urlopen()` we need to import the function from the `request`
    module, which itself resides within the standard library `urllib` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re going to call `urlopen()` with the URL to the story text. We use a Python
    construct called a with-block to manage the resource obtained from the URL, since
    fetching the resource from the web requires operating system sockets and suchlike.
    We’ll be talking more about `with` statements in a later chapter, but for now
    it’s enough to know that using a `with` statement with objects which use external
    resources is good practice to avoid so-called *resource leaks*. The `with` statement
    calls the `urlopen()` function and binds the response object to a variable named
    `story`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the `with` statement is terminated by a colon, which introduces
    a new block, so within the block we must indent four spaces. We create an empty
    `list` which ultimately will hold all of the words from the retrieved text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We open a for-loop which will iterate through the story. Recall that for-loops
    request items one-by-one from the expression on the right of the `in` keyword
    — in this case `story` — and assign them in turn to the the name on the left —
    in this case `line`. It so happens that that type of HTTP response object referred
    to by `story` yields successive lines of text from the response body when iterated
    over in this way, so the for-loop retrieves one line of text at a time from the
    story. The `for` statement is also terminated by a colon because it introduces
    the body of the for-loop, which is a new block and hence a further level of indentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each line of text, we use the `split()` method to divide it into words on
    whitespace boundaries, resulting in a list of words we call `line_words`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we use a second for-loop nested inside the first to iterate over this list
    of words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We `append()` each word in turn to the accumulating `story_words` list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we enter a blank line at the three dots prompt to close all open blocks
    — in this case the inner for-loop , the outer for-loop, and the with-block will
    all be terminated. The block will be executed, and after a short delay, Python
    now returns us to the regular triple-arrow prompt. At this point if Python gives
    you an error, such as a `SyntaxError` or `IndentationError`, you should go back,
    review what you entered, and carefully re-enter the code until Python accepts
    the whole block without complaint. If you get an `HTTPError`, then you were unable
    to fetch the resource over the Internet, and you should check your network connection
    or try again later, although it’s worth checking that you typed the URL correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can look at the words we’ve collected by asking Python to evaluate the value
    of `story_words`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This sort of exploratory programming at the REPL is very common for Python,
    as it allows us to figure out what bits of code do before we decide to use them.
    In this case notice that each of the single-quoted words is prefixed by a lower-case
    letter `b` meaning that we have a list of `bytes` objects where we would have
    preferred a list of `str` objects. This is because the HTTP request transferred
    raw bytes to us over the network. To get a list of strings we should decode the
    byte stream in each line from UTF-8 into Unicode strings. We can do this by inserting
    a call to the `decode()` method of the bytes object, and then operating on the
    resulting Unicode string. The Python REPL supports a simple command history, and
    by careful use of the up and down arrow keys, we can re-enter our snippet, although
    there’s no need to re-import `urlopen`, so we can skip the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the fourth line here we have changed – you can just edit it using the
    left and right arrow keys to insert the requisite call to `decode()` when you
    get to that part of the command history. When we re-run the block and take a fresh
    look at `story_words`, we should see we have a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We’ve just about reached the limit of what’s comfortable to enter and revise
    at the Python REPL, so in the next chapter we’ll look at how to move this code
    into a file where it can be more easily worked with in a text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`str` Unicode strings and `bytes` strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked at the various forms of quotes (single or double quotation marks)
    for quoting strings, useful for incorporating quote marks themselves into strings.
    Python is flexible over which quoting style you use, but you must be consistent
    when delimiting a particular string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We demonstrated that so-called triple quotes, consisting of three consecutive
    quotation mark characters can be used to delimit a multi-line string. Traditionally,
    each quote character is itself a double-quotation mark, although single quotation
    marks can also be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw how adjacent string literals are implicitly concatenated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has support for universal newlines, so no matter what platform you’re
    using it’s sufficient to use a single `\n` character, safe in the knowledge that
    is will be appropriately translated from and to the native newline during I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escape sequences provide an alternative means of incorporating newlines and
    other control characters into literal strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backslashes used for escaping can be a hindrance for Windows filesystem
    paths or regular expressions, so raw strings with an `r` prefix can be used to
    suppress the escaping mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other types, such as integers, can be converted to strings using the `str()`
    constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual characters, returned as one character strings, can be retrieved using
    square brackets with integer zero-based indices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings support a rich variety of operations, such as splitting, through their
    methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python 3, literal strings can contain any Unicode character directly in the
    source, which is interpreted as UTF-8 by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bytes` type has many of the capabilities of strings, but it is a sequence
    as bytes rather than a sequence of Unicode code points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes` literals are prefixed with a lowercase `b`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert between string and bytes instances we use the `encode()` method of
    `str` or the `decode()` method of `bytes`, in both cases passing the name of the
    codec, which we must know in advance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are mutable, heterogeneous sequences of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List literals are delimited by square brackets and the items are separated by
    commas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual elements can be retrieved by indexing into a list with square brackets
    containing a zero-based integer index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast to strings individual list elements can be replaced by assigning
    to the indexed item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists can be grown by `append()`-ing to them, and can be constructed from other
    sequences using the `list()` constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries associate keys with values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal dictionaries are delimited by curly braces. The key-value pairs are
    separated from each other by commas, and each key is associated with its corresponding
    value with a colon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For-loops take items one-by-one from an iterable object such as a `list`, and
    bind the same name to the current item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They correspond to what are called for-each loops in other languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
