- en: Graphical User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Alerts—showing alert dialogs on graphical systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialog boxes—how to ask simple questions with a dialog box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ProgressBar dialog—how to provide a graphical progress dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists—how to implement a scrollable list of elements to pick from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus—how to create menus in a GUI application to allow multiple actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python comes with a feature that is rarely shipped with a programming language:
    a built-in **graphical user interface** (**GUI**) library.'
  prefs: []
  type: TYPE_NORMAL
- en: Python ships with a working version of the `Tk` widgets toolkit, which can be
    controlled through the `tkinter` module provided by the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The `Tk` toolkit actually is used through a simple language called `Tcl`. All
    `Tk` widgets can be controlled through the `Tcl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of these commands are very simple, and take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, something such as the following would lead to a button (identified
    as `mybutton`) with a red `"click here"` text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As those commands are usually relatively simple, Python ships with a built-in
    `Tcl` interpreter and uses it to drive the `Tk` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, nearly everyone, even the more hardcore computer users, are used to
    relying on GUIs for many of their tasks, especially for simple applications that
    require basic interactions, such as picking a choice, confirming an entry, or
    showing some progress. The usage of a GUI can therefore be pretty convenient.
  prefs: []
  type: TYPE_NORMAL
- en: With graphical applications, the user frequently has no need to go through the
    help page of the application, read the documentation, and get through the options
    provided by the application to learn their specific syntax. GUIs have been providing
    a consistent interaction language for decades and are a good way to keep the entry
    barrier to your software low, if used properly.
  prefs: []
  type: TYPE_NORMAL
- en: As Python ships with what you need to create powerful console applications and
    also good GUIs, the next time you need to create a new tool it might be a good
    idea to stop thinking for a moment about what your users will find more convenient
    and head to `tkinter` if your choice is for a graphical application.
  prefs: []
  type: TYPE_NORMAL
- en: While `tkinter` can be limited compared to powerful toolkits, such as Qt or
    GTK, it surely is a fully platform-independent solution that is good enough for
    most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most simple type of GUI is the alert. Just print something to inform the
    user of a result or event in a graphical box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca5ecdd4-5d78-49d5-a9d8-50c84ff5b921.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alerts in `tkinter` are managed by the `messagebox` object and we can create
    one simply by asking `messagebox` to show one for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our `alert` helper in place, we can initialize a `Tk` interpreter
    and show as many alerts as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked as expected, we should see a pop-up dialog and, once dismissed,
    a new one should come up with `Hello Again`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `alert` function itself is just a thin wrapper over what `tkinter.messagebox`
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of message boxes we can show: `error`, `warning`, and
    `info`. If an unsupported kind of dialog box is requested, we just reject it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each kind of dialog box is shown by relying on a different method of the `messagebox`.
    The information boxes are shown using `messagebox.showinfo`, while errors are
    shown using `messagebox.showerror`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we grab the relevant method of `messagebox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call it to display our box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `alert` function is very simple, but there is one more thing that we need
    to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The `tkinter` library works by interacting with `Tk` through its own interpreter
    and environment, and this has to be created and started.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't start one ourselves, `tkinter` will start one for us as soon as
    it needs to send some commands. But, this leads to an empty main window always
    being created.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you use `alert` as it is, you will get your alert, but you will also
    get empty windows in the corner of your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, we need to initialize the `Tk` environment ourselves and disable
    the main window, as we don''t have any use for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then we can show as many alerts as we want, without the risk of leaking empty
    unwanted windows around the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Dialog boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dialog boxes are the most simple and common interaction a user interface can
    provide. Asking for one simple input, such as a number, text, or yes/no, handles
    many needs of interaction with a user in simple applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`tkinter` comes with dialogs for most cases, but it might be hard to spot them
    all if you don''t already know the library. As a pointer, all dialog boxes provided
    by `tkinter` share a very similar signature, so it''s easy to make a `dialog`
    function that allows us to show them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0d43442-8643-4db8-a0bc-86a03b14bcdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The dialog box will look as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28197129-73c7-41d8-ab0b-85af9edb584b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The window to open a file appears as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04fb7778-7b6f-42c7-8c77-b323c93b81e0.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a `dialog` function to hide the minor differences between dialog
    types and call the appropriate dialog depending on the kind of request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then test our `dialog` method to show all the possible dialog types,
    and show back the user choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kinds of dialog provided by `tkinter` are divided between the `messagebox`,
    `simpledialog`, and `filedialog` modules (you might consider `colorchooser` too,
    but it's rarely needed).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, depending on the kind of dialog that the user wants, we need to pick the
    right module and call the function required to show it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If none of the modules expose a function to show the requested kind of dialog
    (all the functions are named `ask*`), the loop will finish without ever breaking
    and thus will enter the `else` clause, raising an exception to notify the caller
    that the requested type is unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: If the loop instead exited with `break`, the `widget` variable will point to
    the module that is able to show the requested dialog and the `show` variable will
    lead to the function actually being able to show it.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the right function in place, we need to account for the minor differences
    between the various dialog functions.
  prefs: []
  type: TYPE_NORMAL
- en: The major one is related to `messagebox` dialogs that have a `message` argument,
    while the `simpledialog` dialog has a prompt argument to show the message for
    the user. The `filedialog` doesn't require any message at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by creating a basic dictionary of options with the custom-provided
    options and the `title` option, as it is always available in all kinds of dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then the `message` option is replaced with the right name (or skipped) by looking
    up in the `dialog._argsmap` dictionary the mapping from the name of the `dialog` argument
    to the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the case of `simpledialog`, the `{''message'': ''prompt''}`
    mapping is used. The `message` variable is looked up in function local variables
    (`locals()[arg]`) and it''s then assigned to the options dictionary with the `prompt`
    name as specified by `replacement`. Then, the function assigned to `show` is finally
    called to display the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ProgressBar dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing a long-running operation, the most frequent way to inform a user
    of progress is through a progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'While running an operation in a thread, we can update a progress bar to show
    that the operation is moving forward and give the user a hint about the time it
    might take to complete the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0ec92d1-34a2-46f5-92e1-6616f7d96c3f.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `simpledialog.SimpleDialog` widget is used to create simple dialogs with
    some text and buttons. We are going to leverage it to display a progress bar instead
    of the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `ProgressDialog` can be created and we can use a background thread to
    let the operation progress (like a download), and then update the progress bar
    whenever our operation moves forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our dialog itself is mostly based on the `simpledialog.SimpleDialog` widget.
    We create it and then set `self.default = None` to prevent the user from being
    able to close the dialog by pressing the `<Return>` key, and we also set `self.default
    = None` to prevent the user from closing the dialog by pressing the button on
    the window. We want the dialog to stay open until it has been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we actually need the progress bar itself, which will be shown below the
    text message, and we also move the dialog in front, because we want the user to
    be aware that something is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last part, we need to schedule `self._update`, which will continue to
    loop until the dialog quits updating the progress bar if there is a new progress
    value available. The progress value can be provided through `self._queue`, where
    we will insert new progress values whenever they are provided through the `set_progress`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We need to go through `Queue` because the dialog with the progress bar update
    would block the whole program.
  prefs: []
  type: TYPE_NORMAL
- en: While the `Tkinter mainloop` function is running (which is called by `simpledialog.SimpleDialog.go()`), nothing
    else can move forward.
  prefs: []
  type: TYPE_NORMAL
- en: So the UI and the download must proceed in two different threads, and as we
    can't update the UI from a different thread, we must send the progress values
    from the thread that produces them to the UI thread that will consume them to
    update the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thread performing the operation and producing the progress updates can
    then send those progress updates to the UI thread through the `set_progress` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other side, the UI thread will be calling the `self._update` method
    continuously (every 200 ms), to check if there is an update request in `self._queue`,
    and then applying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the update, the method will reschedule itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way, we will go on forever checking if there is an update for the progress
    bar every 200 ms until `self.root mainloop` is quit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `ProgressDialog`, we simulated a download taking 5 seconds. This was
    done by creating the dialog itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we started a background thread that goes on for 5 seconds, updating
    the progress every half a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The update happens because the thread calls `p.set_progress`, which will set
    a new progress value in the queue, signaling to the UI thread that there is a
    new progress value to set.
  prefs: []
  type: TYPE_NORMAL
- en: Once the download is completed, the progress dialog will be exited through `p.done(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our download thread in place, we can actually display the progress
    dialog and wait for it to quit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When more than two choices are available to the user, the best way to list them
    is through lists. The `tkinter` module provides a `ListBox`, which allows us to
    show a set of entries in a scrollable widget for the user to pick from.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this to implement a dialog where the user can pick one of many options
    and grab the chosen one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d954334-8b5f-4610-b619-ac1f212250db.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `simpledialog.Dialog` class can be used to implement simple OK/cancel dialogs,
    and allows us to provide any body of the dialog with custom content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it to add a message and a list to a dialog and let the user make
    a selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `ChoiceDialog`, we can display it with a list of items and have
    the user pick one or cancel the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `ChoiceDialog.selection` attribute will always contain the selected item,
    or `None` if the dialog was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`simpledialog.Dialog` creates a dialog with `Ok` and `Cancel` buttons by default
    and only provides a title.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, apart from creating the dialog itself, we also want to keep the
    message of the dialog and the items available for selection, so that we can show
    them to the user. Also, by default, we want to set that no item was selected yet.
    Finally, we can call `simpledialog.Dialog.__init__`, as once it''s called, the
    main thread will block and we can''t do anything else until the dialog is dismissed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add any additional content by overriding the `simpledialog.Dialog.body`
    method. This method can add more widgets as children of the dialog main body and
    can return a specific widget that should have focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `body` method is created within `simpledialog.Dialog.__init__`, so it's
    called before blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: After the content of the dialog is in place, the dialog will block waiting for
    a button to be clicked by the user.
  prefs: []
  type: TYPE_NORMAL
- en: If the `cancel` button is clicked, the dialog is dismissed automatically and
    the `ChoiceDialog.selection` will remain `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `Ok` is clicked, instead, the `ChoiceDialog.validate` method is called to
    check that the choice is valid. Our `validate` implementation will check if the
    user actually selected an entry before clicking `Ok` or not, and will only let
    the user dismiss the dialog if there was a selected item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the validation passes, the `ChoiceDialog.apply` method is called to confirm
    the choice and we just set in `self.selection` the name of the selected item,
    so that it''s accessible for the caller once the dialog is not visible anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it possible to show the dialog and read back the selected value
    from the `selection` attribute once it''s dismissed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your application allows you to perform more than one action, a menu is
    frequently the most common way to allow access to those actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca3d5d42-6626-40f4-925f-c9ef2ff3a557.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tkinter.Menu` class allows us to create menus, submenus, actions, and
    separators. So, it provides everything we might need to create basic menus in
    our GUI-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set_menu` function allows us to create whole menu hierarchies easily out
    of nested dictionaries of actions and submenus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Python 3.6+, you can also avoid `OrderedDict` and use a plain
    dictionary, as the dictionary will already be ordered.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Provided a window, the `set_menu` function creates a `Menu` object and sets
    it as the window menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Then it populates the menu with the choices provided through the `choices` argument.
    That is expected to be a dictionary where the key is the name of the menu entry
    and the value is the callable that should be called when the choice is selected,
    or another dictionary if the choice should lead to a submenu. Finally, it supports
    separators when both the label and the choice are set to `-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu is populated by traversing the tree of options through a recursive
    function that calls `Menu.add_command`, `Menu.add_cascade`, and `Menu.add_separator`, depending
    on the encountered entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
