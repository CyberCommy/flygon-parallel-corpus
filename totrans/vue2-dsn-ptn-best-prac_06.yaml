- en: Creating Better UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitions and animations are great ways of creating a better user experience
    within our applications. As there's so many different options and use cases, they
    can make or break the feel of an application if under or overused. We'll be looking
    at this concept further within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be looking at form validation with a third-party library named `Vuelidate`.
    This will allow us to create forms that scale with the size of our application.
    We'll also gain the power to change the UI depending on form state, as well as
    display helpful validation messages to assist the user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll look at how we can use the `render` function and JSX to compose
    the user interface with Vue. While this is not perfect for every scenario, there
    are times where you'd want to take full advantage of JavaScript within your templates,
    as well as create smart/presentational components with the Functional Component
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned about CSS animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created your own CSS animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used `Animate.css` to create interactive UI with little work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated and created your own Vue transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken advantage of `Vuelidate` to validate forms within Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used the `render` function as an alternative to template-driven UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used JSX to compose UI similar to React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start off by understanding why we should care about animation and transitions
    inside our project(s).
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations can be used to draw focus to specific UI elements and to improve
    the overall experience for the user by bringing it to life. Animations should
    be used when there is no clear start state and end state. An animation can be
    set to play automatically or it can be triggered by user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: CSS animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS animations are not only a powerful tool, but they are also easy to maintain
    with little knowledge needed in order to use them within a project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding them to an interface can be an intuitive method of capturing a user's
    attention and they can also be used in pointing a user to a specific element with
    ease. The animations can be tailored and customized, making them ideal for plenty
    of use cases within a variety of projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dig deep into Vue transitions and other animated possibilities, we
    should have an understanding of how to do basic CSS3 animations. Let''s create
    a simple project that looks at this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `App.vue` we can first create the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, nothing too out of the ordinary. We''re declaring the CSS animation
    with `@keyframes` named `fade`, essentially giving CSS two states that we want
    our element to be in - `opacity: 1` and `opacity: 0`. It says nothing about how
    long or whether these keyframes are repeated; this is all done in the `animated`
    class. We''re applying the `fade` keyframes for `1`s whenever we add the class
    to an element; at the same time, we''re adding `opacity: 1` to ensure that it
    doesn''t disappear after the animation has ended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put this together by taking advantage of `v-bind:class` to dynamically
    add/remove the class depending on the value of `toggle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Cool. We now have the ability to fade in a heading based on a `Boolean` value.
    But what if we could do it better? In this particular circumstance, we could have
    used a transition to achieve similar results. Prior to looking at transitions
    in more detail, let's look at other ways we can use CSS animations inside our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Animate.css
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Animate.css` is a great way of implementing different types of animation easily
    into your project. It''s an open source CSS library created by Daniel Eden ([https://daneden.me/](https://daneden.me/))
    and it gives us access to "plug and play" CSS animations.'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to adding it to any project, head over to [https://daneden.github.io/animate.css/](https://daneden.github.io/animate.css/)
    and preview the different animation styles. There are a lot of different animations
    to choose from, with each offering a different default animation. These can be
    further customized and weâ€™ll talk more about that later on in the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a playground project by running the following in our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the project is set up, go ahead and open it up in the editor of your choice
    and head to the `index.html` file. Inside the `<head>` tag, add the following
    stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the stylesheet reference needed for `Animate.css` to work on the project.
  prefs: []
  type: TYPE_NORMAL
- en: Using Animate.css
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have `Animate.css` inside the project, we can change our `App.vue`
    to have a `template` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Prior to adding any animations, we first need to add the animated class. Next,
    we can select any animation from the `Animate.css` library; we've chosen `fadeIn`
    for this example. This can then be switched out for other animations such as `bounceInLeft`,
    `shake`, `rubberBand`, and many more!
  prefs: []
  type: TYPE_NORMAL
- en: We could take our previous example, and turn this into a bound class value based
    on a Boolean - but transitions may be more exciting to look at.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transitions work by starting off in one particular state and then transitioning
    into another state and interpolating the values in-between. A transition can''t
    have multiple steps involved in an animation. Imagine a pair of curtains going
    from open to closed: the first state would be the open position, while the second
    state would be the closed position.'
  prefs: []
  type: TYPE_NORMAL
- en: Vue has its own tags for dealing with transitions, known as `<transition>` and
    `<transition-group>`. These tags are customizable and can be easily used with
    JavaScript and CSS. There do not necessarily need to be `transition` tags to make
    transitions work, as you simply bind the state variable to a visible property,
    but the tags typically offer more control and potentially better results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `toggle` example that we had before and create a version that
    uses `transition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the moving parts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: We're surrounding the element inside a `<transition>` tag, which is applied
    to `enter-active-class` of `animated fadeIn` whenever `<h1>` enters the DOM. This
    is triggered with the `v-if` directive as the `toggle` variable is initially set
    to `false`. Clicking the button toggles our Boolean, triggering the transition
    and applying the appropriate CSS class.
  prefs: []
  type: TYPE_NORMAL
- en: Transition states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every enter/leave transition applies up to six classes, which are made up of
    transitions upon entering the scene, during, and leaving the scene. Set one `(v-enter-*)`
    refers to Transitions initially entering and then moving out, while set two `(v-leave-*)`
    refers to ending transitions entering and then moving out:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `v-enter` | This is the very starting state for enter. It is removed one
    frame after the element is inserted. |'
  prefs: []
  type: TYPE_TB
- en: '| `v-enter-active` | `enter-active` is `enter`''s active state. It is active
    for the entirety of the active phase and is only removed once the transitions
    or animations have come to an end. This state also manages further instructions
    such as delays, duration, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `v-enter-to` | This is the last state for enter, added one frame after the
    element is inserted, which is the same time `v-enter` is removed. `Enter-to` is
    then removed once the transition/animation ends. |'
  prefs: []
  type: TYPE_TB
- en: '| `v-leave` | This is the starting state for leave. Removed after one frame
    once a leave transition is triggered to take place. |'
  prefs: []
  type: TYPE_TB
- en: '| `v-leave-active` | `leave-active` is `leave`''s active state. It is active
    for the entirety of the leaving phase and is only removed once the transition
    or animation have come to an end. |'
  prefs: []
  type: TYPE_TB
- en: '| `v-leave-to` | The last state for leave, added one frame after a leave is
    triggered, which is the same time `v-leave` is removed. `Leave-to` is then removed
    when the transition/animation ends. |'
  prefs: []
  type: TYPE_TB
- en: 'Each `enter` and `leave` transition features a prefix, which in the table is
    shown as the default value of `v` because the transition itself has no name. When
    adding the enter or leave transitions into a project, ideally proper naming conventions
    should apply to act as unique identifiers. This can help if you plan on using
    multiple transitions within a project and can be done through a simple assignment
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book, we''ve looked at various different ways that we can capture
    user input with the likes of `v-model`. We''ll be using a third-party library
    named **Vuelidate** to perform model validation depending on a particular ruleset.
    Let''s create a playground project by running the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What is Vuelidate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Vuelidate` is an open source, lightweight library that helps us perform model
    validation with a variety of validation contexts. Validation can be functionally
    composed and it also works well with other libraries such as `Moment`, `Vuex`,
    and more. As we''ve installed it in our project with `npm install vuelidate`,
    we now need to register it as a plugin within `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding the empty validations object to our main Vue instance bootstraps Vuelidate's
    `$v` throughout the project. This then allows us to use the `$v` object to gain
    information about the current state of our form within our Vue instance across
    all components.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuelidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a basic form that allows us to input a `firstName`, `lastName`,
    `email`, and `password`. This will allow us to add validation rules with `Vuelidate`
    and visualize them on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot going on here, so let''s break it down step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: We're creating a new form with the `@submit.prevent` directive so that the page
    doesn't reload when the form is submitted, which is the same as calling the submit
    on this form and having `preventDefault` on the event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're adding `v-model.trim` to each form input element so that we trim
    any white space and capture the input as a variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're defining these variables inside of our data function so that they're reactive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `submit` button is defined with the `type="submit"` so that when it's clicked
    the form's `submit` function is ran
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're stubbing out a blank `onSubmit` function, which we'll be creating soon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the `@input` event and call the `touch` event on each one
    of our `input` elements, binding to the data property `v-model`, and providing
    validation to the field like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can then add the validations to our Vue instance by importing them from `Vuelidate`
    and adding a `validations` object that corresponds to the form elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`Vuelidate` will bind the same name set here with our `data` variable like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re simply importing the required email validators and applying them to
    each model item. This essentially makes sure that all of our items are required
    and that the email input matches an email regular expression. We can then visualize
    the current state of the form and each field by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add some styling to show the validation on the right and the form
    on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything has gone as planned, we should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6747ab00-f573-40a4-b9cf-d8a5e3ea85b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying form errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `$invalid` Boolean inside of the `$v.model_name` object (where
    `model_name` is equal to `email`, `firstName`, `lastName`, or `password`) to display
    messages or change the look and feel of our form field(s). Let''s start off by
    adding a new class named `error` that adds a `red` `border` around the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then conditionally apply this class whenever the field is invalid and
    touched using `v-bind:class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This then gives us the following results whenever the field is invalid or valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9736943a-4ffe-449b-a97e-648983eacdd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Subsequently, we can then display an error message if this is the case. This
    can be done in numerous ways depending on the type of message you want to show.
    Let''s use the `email` input as an example, and show an error message when the
    `email` field has an invalid email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the representation of our `$v` object, the email Boolean
    is true when the field has a valid email address, and if not, is false. While
    this checks to see if email is correct, it doesn''t check to see whether the field
    is empty. Let''s add another error message that checks this based on the `required`
    validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to, we could even take this a step further and create our own
    wrapper component that would render the various error messages of each field.
    Let''s fill in the rest of our error messages along with a check to see whether
    the form element has been touched (is `$dirty`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Password validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating user accounts, passwords tend to be entered twice and conform
    to a minimum length. Let''s add another field and some more validation rules to
    enforce this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Added the `repeatPassword` field to our data object so that it can hold the
    repeated password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imported both the `minLength` and `sameAs` validators from `Vuelidate`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added the `minLength` of `6` characters to the `password` validator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added the `sameAs` validator to enforce the fact that `repeatPassword` should
    follow the same validation rules as `password`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we now have appropriate password validation, we can add the new field and
    display any error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we can disable our `Submit` button if the form is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also get this value inside of our JavaScript with `this.$v.$invalid`.
    Here''s an example of how we can check to see whether the form is invalid and
    then create a user object based on our form elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to use your data in this fashion, you may prefer to set up your
    data object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have now created a form with appropriate validation!
  prefs: []
  type: TYPE_NORMAL
- en: Render/functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to take a detour and pivot away from validation and animations to
    consider the use of functional components and render functions to improve application
    performance. You may also hear these being referred to as "presentational components"
    as they're stateless and only receive data as an input prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve only declared the markup for our components with the `template`
    tag, but it''s also possible to use the `render` function (as seen in `src/main.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `h` comes from hyperscript that allows us to create/describe DOM nodes with
    our JavaScript. In the `render` function, we're simply rendering the `App` component
    and in the future, we'll be looking at this in more detail. Vue creates a Virtual
    DOM to make working with the actual DOM much simpler (as well as for improved
    performance when dealing with a vast amount of elements).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can replace our `App.vue` component with the following object that takes
    a `render` object and `hyperscript` instead of using `template`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This then renders a new `h1` tag with the text node of `''Hello render!''`
    and this is then known as a **VNode** (**Virtual Node**) and the plural **VNodes**
    (**Virtual DOM Nodes**), which describes the entire tree. Let''s now look at how
    we can display a list of items inside of a `ul`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8b05f288-e17e-427c-ae97-8e2b22d23db7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s important to realize that we can only render one root node with hyperscript.
    This restriction is the same for our template, so it''s expected that we wrap
    our items inside of a `div` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also pass style elements and a variety of other attributes to our rendered
    items. Here''s an example that uses the `style` object to change the color of
    each item `red`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine, we can add as many `style` attributes as we want, as well
    as extra options that we would expect, such as `props`, `directives`, `on` (click
    handlers), and so on. Let's look at how we can map over elements to render a component
    with `props`.
  prefs: []
  type: TYPE_NORMAL
- en: Components and props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create ourselves a `ListItem` component under `components/ListItem.vue`
    with one prop, `name`. We''ll render this component in place of our `li` and map
    over an array that contains various `names`. Notice how we''re also adding the
    `functional: true` option to our Vue instance; this tells Vue that this is purely
    a presentational component and it will not have any state of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With our `render` function, `h` is often also referred to as `createElement`,
    and because we''re in the JavaScript context, we''re able to take advantage of
    array operators such as `map`, `filter`, `reduce`, and so on. Let''s replace the
    static names for dynamically generated components with `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we need to do is add a `render` function to our component.
    As a second parameter, we''re able to gain access to the context object, which
    allows us to access `options` such as our `props`. For this example, we''ll assume
    that the `name` prop is always present and isn''t `null` or `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we now have a list of elements that includes items passed as a
    `prop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9982a92b-38a0-4b0f-aaca-ae5e0e436865.png)'
  prefs: []
  type: TYPE_IMG
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this is a great thought exercise, templates are superior in most cases.
    There may be times where you want to use the render function inside of your components
    and, in these circumstances, it may be simpler to use JSX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the babel plugin for JSX into our project by running the following
    in our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update our `.babelrc` to use the new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to rewrite our `render` function to take advantage of a simpler
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is much more declarative and is also easier to maintain. Under the hood,
    it's being transpiled down to the previous `hyperscript` format with Babel.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to take advantage of CSS animations and transitions
    within our Vue projects. This allows us to make the user experience more fluid
    and improve the look and feel of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about how we can construct our UI with the `render` method;
    this involved looking at creating VNodes with HyperScript and then using JSX for
    cleaner abstraction. While you may not want to use JSX in your project, you may
    find it more comfortable if you come from a React background.
  prefs: []
  type: TYPE_NORMAL
