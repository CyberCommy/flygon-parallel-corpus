- en: Creating Better UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更好的UI
- en: Transitions and animations are great ways of creating a better user experience
    within our applications. As there's so many different options and use cases, they
    can make or break the feel of an application if under or overused. We'll be looking
    at this concept further within this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡和动画是在我们的应用程序中创建更好用户体验的好方法。由于有很多不同的选项和用例，它们可以使应用程序的感觉得以或败。我们将在本章中进一步探讨这个概念。
- en: We'll also be looking at form validation with a third-party library named `Vuelidate`.
    This will allow us to create forms that scale with the size of our application.
    We'll also gain the power to change the UI depending on form state, as well as
    display helpful validation messages to assist the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用名为`Vuelidate`的第三方库来进行表单验证。这将允许我们创建随着应用程序规模而扩展的表单。我们还将获得根据表单状态更改UI的能力，以及显示有用的验证消息来帮助用户。
- en: Finally, we'll look at how we can use the `render` function and JSX to compose
    the user interface with Vue. While this is not perfect for every scenario, there
    are times where you'd want to take full advantage of JavaScript within your templates,
    as well as create smart/presentational components with the Functional Component
    model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看如何使用`render`函数和JSX来使用Vue组合用户界面。虽然这并不适用于每种情况，但在某些情况下，您可能希望充分利用模板中的JavaScript，并使用功能组件模型创建智能/表现组件。
- en: 'By the end of this chapter, you will have:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有：
- en: Learned about CSS animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了CSS动画
- en: Created your own CSS animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的CSS动画
- en: Used `Animate.css` to create interactive UI with little work
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Animate.css`创建交互式UI，工作量很小
- en: Investigated and created your own Vue transitions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查并创建自己的Vue过渡
- en: Taken advantage of `Vuelidate` to validate forms within Vue
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`Vuelidate`在Vue中验证表单
- en: Used the `render` function as an alternative to template-driven UI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`render`函数作为模板驱动UI的替代方案
- en: Used JSX to compose UI similar to React
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX来组合类似于React的UI
- en: Let's start off by understanding why we should care about animation and transitions
    inside our project(s).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解为什么我们应该关心项目中的动画和过渡。
- en: Animations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: Animations can be used to draw focus to specific UI elements and to improve
    the overall experience for the user by bringing it to life. Animations should
    be used when there is no clear start state and end state. An animation can be
    set to play automatically or it can be triggered by user interaction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 动画可以用来吸引特定UI元素的注意，并通过使其生动起来来改善用户的整体体验。当没有明确的开始状态和结束状态时，应该使用动画。动画可以自动播放，也可以由用户交互触发。
- en: CSS animations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS动画
- en: CSS animations are not only a powerful tool, but they are also easy to maintain
    with little knowledge needed in order to use them within a project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CSS动画不仅是强大的工具，而且在项目中使用它们只需要很少的知识就可以轻松维护。
- en: Adding them to an interface can be an intuitive method of capturing a user's
    attention and they can also be used in pointing a user to a specific element with
    ease. The animations can be tailored and customized, making them ideal for plenty
    of use cases within a variety of projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们添加到界面中可以是捕获用户注意力的直观方法，它们也可以用于轻松指向用户特定的元素。动画可以定制和自定义，使它们成为各种项目中许多用例的理想选择。
- en: 'Before we dig deep into Vue transitions and other animated possibilities, we
    should have an understanding of how to do basic CSS3 animations. Let''s create
    a simple project that looks at this in more detail:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Vue过渡和其他动画可能性之前，我们应该了解如何进行基本的CSS3动画。让我们创建一个更详细地查看这一点的简单项目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside `App.vue` we can first create the following styles:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.vue`中，我们可以首先创建以下样式：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, nothing too out of the ordinary. We''re declaring the CSS animation
    with `@keyframes` named `fade`, essentially giving CSS two states that we want
    our element to be in - `opacity: 1` and `opacity: 0`. It says nothing about how
    long or whether these keyframes are repeated; this is all done in the `animated`
    class. We''re applying the `fade` keyframes for `1`s whenever we add the class
    to an element; at the same time, we''re adding `opacity: 1` to ensure that it
    doesn''t disappear after the animation has ended.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put this together by taking advantage of `v-bind:class` to dynamically
    add/remove the class depending on the value of `toggle`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Cool. We now have the ability to fade in a heading based on a `Boolean` value.
    But what if we could do it better? In this particular circumstance, we could have
    used a transition to achieve similar results. Prior to looking at transitions
    in more detail, let's look at other ways we can use CSS animations inside our
    project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Animate.css
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Animate.css` is a great way of implementing different types of animation easily
    into your project. It''s an open source CSS library created by Daniel Eden ([https://daneden.me/](https://daneden.me/))
    and it gives us access to "plug and play" CSS animations.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Prior to adding it to any project, head over to [https://daneden.github.io/animate.css/](https://daneden.github.io/animate.css/)
    and preview the different animation styles. There are a lot of different animations
    to choose from, with each offering a different default animation. These can be
    further customized and we’ll talk more about that later on in the section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a playground project by running the following in our Terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the project is set up, go ahead and open it up in the editor of your choice
    and head to the `index.html` file. Inside the `<head>` tag, add the following
    stylesheet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the stylesheet reference needed for `Animate.css` to work on the project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Using Animate.css
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have `Animate.css` inside the project, we can change our `App.vue`
    to have a `template` with the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prior to adding any animations, we first need to add the animated class. Next,
    we can select any animation from the `Animate.css` library; we've chosen `fadeIn`
    for this example. This can then be switched out for other animations such as `bounceInLeft`,
    `shake`, `rubberBand`, and many more!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We could take our previous example, and turn this into a bound class value based
    on a Boolean - but transitions may be more exciting to look at.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transitions work by starting off in one particular state and then transitioning
    into another state and interpolating the values in-between. A transition can''t
    have multiple steps involved in an animation. Imagine a pair of curtains going
    from open to closed: the first state would be the open position, while the second
    state would be the closed position.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Vue has its own tags for dealing with transitions, known as `<transition>` and
    `<transition-group>`. These tags are customizable and can be easily used with
    JavaScript and CSS. There do not necessarily need to be `transition` tags to make
    transitions work, as you simply bind the state variable to a visible property,
    but the tags typically offer more control and potentially better results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `toggle` example that we had before and create a version that
    uses `transition`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's take a look at the moving parts in more detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We're surrounding the element inside a `<transition>` tag, which is applied
    to `enter-active-class` of `animated fadeIn` whenever `<h1>` enters the DOM. This
    is triggered with the `v-if` directive as the `toggle` variable is initially set
    to `false`. Clicking the button toggles our Boolean, triggering the transition
    and applying the appropriate CSS class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Transition states
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every enter/leave transition applies up to six classes, which are made up of
    transitions upon entering the scene, during, and leaving the scene. Set one `(v-enter-*)`
    refers to Transitions initially entering and then moving out, while set two `(v-leave-*)`
    refers to ending transitions entering and then moving out:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `v-enter` | This is the very starting state for enter. It is removed one
    frame after the element is inserted. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `v-enter-active` | `enter-active` is `enter`''s active state. It is active
    for the entirety of the active phase and is only removed once the transitions
    or animations have come to an end. This state also manages further instructions
    such as delays, duration, and so on. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `v-enter-to` | This is the last state for enter, added one frame after the
    element is inserted, which is the same time `v-enter` is removed. `Enter-to` is
    then removed once the transition/animation ends. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `v-leave` | This is the starting state for leave. Removed after one frame
    once a leave transition is triggered to take place. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `v-leave-active` | `leave-active` is `leave`''s active state. It is active
    for the entirety of the leaving phase and is only removed once the transition
    or animation have come to an end. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `v-leave-to` | The last state for leave, added one frame after a leave is
    triggered, which is the same time `v-leave` is removed. `Leave-to` is then removed
    when the transition/animation ends. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: 'Each `enter` and `leave` transition features a prefix, which in the table is
    shown as the default value of `v` because the transition itself has no name. When
    adding the enter or leave transitions into a project, ideally proper naming conventions
    should apply to act as unique identifiers. This can help if you plan on using
    multiple transitions within a project and can be done through a simple assignment
    operation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Form validation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book, we''ve looked at various different ways that we can capture
    user input with the likes of `v-model`. We''ll be using a third-party library
    named **Vuelidate** to perform model validation depending on a particular ruleset.
    Let''s create a playground project by running the following in your Terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What is Vuelidate?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Vuelidate` is an open source, lightweight library that helps us perform model
    validation with a variety of validation contexts. Validation can be functionally
    composed and it also works well with other libraries such as `Moment`, `Vuex`,
    and more. As we''ve installed it in our project with `npm install vuelidate`,
    we now need to register it as a plugin within `main.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding the empty validations object to our main Vue instance bootstraps Vuelidate's
    `$v` throughout the project. This then allows us to use the `$v` object to gain
    information about the current state of our form within our Vue instance across
    all components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuelidate
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a basic form that allows us to input a `firstName`, `lastName`,
    `email`, and `password`. This will allow us to add validation rules with `Vuelidate`
    and visualize them on screen:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There''s a lot going on here, so let''s break it down step by step:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: We're creating a new form with the `@submit.prevent` directive so that the page
    doesn't reload when the form is submitted, which is the same as calling the submit
    on this form and having `preventDefault` on the event
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're adding `v-model.trim` to each form input element so that we trim
    any white space and capture the input as a variable
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're defining these variables inside of our data function so that they're reactive
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `submit` button is defined with the `type="submit"` so that when it's clicked
    the form's `submit` function is ran
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're stubbing out a blank `onSubmit` function, which we'll be creating soon
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the `@input` event and call the `touch` event on each one
    of our `input` elements, binding to the data property `v-model`, and providing
    validation to the field like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can then add the validations to our Vue instance by importing them from `Vuelidate`
    and adding a `validations` object that corresponds to the form elements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`Vuelidate` will bind the same name set here with our `data` variable like
    so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''re simply importing the required email validators and applying them to
    each model item. This essentially makes sure that all of our items are required
    and that the email input matches an email regular expression. We can then visualize
    the current state of the form and each field by adding the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then add some styling to show the validation on the right and the form
    on the left:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If everything has gone as planned, we should get the following result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6747ab00-f573-40a4-b9cf-d8a5e3ea85b6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Displaying form errors
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `$invalid` Boolean inside of the `$v.model_name` object (where
    `model_name` is equal to `email`, `firstName`, `lastName`, or `password`) to display
    messages or change the look and feel of our form field(s). Let''s start off by
    adding a new class named `error` that adds a `red` `border` around the input field:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then conditionally apply this class whenever the field is invalid and
    touched using `v-bind:class`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This then gives us the following results whenever the field is invalid or valid:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9736943a-4ffe-449b-a97e-648983eacdd7.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Subsequently, we can then display an error message if this is the case. This
    can be done in numerous ways depending on the type of message you want to show.
    Let''s use the `email` input as an example, and show an error message when the
    `email` field has an invalid email address:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see from the representation of our `$v` object, the email Boolean
    is true when the field has a valid email address, and if not, is false. While
    this checks to see if email is correct, it doesn''t check to see whether the field
    is empty. Let''s add another error message that checks this based on the `required`
    validator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we wanted to, we could even take this a step further and create our own
    wrapper component that would render the various error messages of each field.
    Let''s fill in the rest of our error messages along with a check to see whether
    the form element has been touched (is `$dirty`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Password validation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating user accounts, passwords tend to be entered twice and conform
    to a minimum length. Let''s add another field and some more validation rules to
    enforce this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ve done the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Added the `repeatPassword` field to our data object so that it can hold the
    repeated password
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imported both the `minLength` and `sameAs` validators from `Vuelidate`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added the `minLength` of `6` characters to the `password` validator
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added the `sameAs` validator to enforce the fact that `repeatPassword` should
    follow the same validation rules as `password`
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we now have appropriate password validation, we can add the new field and
    display any error messages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Form submission
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we can disable our `Submit` button if the form is not valid:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also get this value inside of our JavaScript with `this.$v.$invalid`.
    Here''s an example of how we can check to see whether the form is invalid and
    then create a user object based on our form elements:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you''d like to use your data in this fashion, you may prefer to set up your
    data object like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have now created a form with appropriate validation!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Render/functional components
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to take a detour and pivot away from validation and animations to
    consider the use of functional components and render functions to improve application
    performance. You may also hear these being referred to as "presentational components"
    as they're stateless and only receive data as an input prop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve only declared the markup for our components with the `template`
    tag, but it''s also possible to use the `render` function (as seen in `src/main.js`):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `h` comes from hyperscript that allows us to create/describe DOM nodes with
    our JavaScript. In the `render` function, we're simply rendering the `App` component
    and in the future, we'll be looking at this in more detail. Vue creates a Virtual
    DOM to make working with the actual DOM much simpler (as well as for improved
    performance when dealing with a vast amount of elements).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Rendering elements
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can replace our `App.vue` component with the following object that takes
    a `render` object and `hyperscript` instead of using `template`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This then renders a new `h1` tag with the text node of `''Hello render!''`
    and this is then known as a **VNode** (**Virtual Node**) and the plural **VNodes**
    (**Virtual DOM Nodes**), which describes the entire tree. Let''s now look at how
    we can display a list of items inside of a `ul`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](assets/8b05f288-e17e-427c-ae97-8e2b22d23db7.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'It''s important to realize that we can only render one root node with hyperscript.
    This restriction is the same for our template, so it''s expected that we wrap
    our items inside of a `div` like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Attributes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also pass style elements and a variety of other attributes to our rendered
    items. Here''s an example that uses the `style` object to change the color of
    each item `red`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can imagine, we can add as many `style` attributes as we want, as well
    as extra options that we would expect, such as `props`, `directives`, `on` (click
    handlers), and so on. Let's look at how we can map over elements to render a component
    with `props`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Components and props
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create ourselves a `ListItem` component under `components/ListItem.vue`
    with one prop, `name`. We''ll render this component in place of our `li` and map
    over an array that contains various `names`. Notice how we''re also adding the
    `functional: true` option to our Vue instance; this tells Vue that this is purely
    a presentational component and it will not have any state of its own:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With our `render` function, `h` is often also referred to as `createElement`,
    and because we''re in the JavaScript context, we''re able to take advantage of
    array operators such as `map`, `filter`, `reduce`, and so on. Let''s replace the
    static names for dynamically generated components with `map`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final thing we need to do is add a `render` function to our component.
    As a second parameter, we''re able to gain access to the context object, which
    allows us to access `options` such as our `props`. For this example, we''ll assume
    that the `name` prop is always present and isn''t `null` or `undefined`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once again, we now have a list of elements that includes items passed as a
    `prop`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9982a92b-38a0-4b0f-aaca-ae5e0e436865.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: JSX
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this is a great thought exercise, templates are superior in most cases.
    There may be times where you want to use the render function inside of your components
    and, in these circumstances, it may be simpler to use JSX.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the babel plugin for JSX into our project by running the following
    in our Terminal:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then update our `.babelrc` to use the new plugin:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This allows us to rewrite our `render` function to take advantage of a simpler
    syntax:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is much more declarative and is also easier to maintain. Under the hood,
    it's being transpiled down to the previous `hyperscript` format with Babel.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to take advantage of CSS animations and transitions
    within our Vue projects. This allows us to make the user experience more fluid
    and improve the look and feel of our applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about how we can construct our UI with the `render` method;
    this involved looking at creating VNodes with HyperScript and then using JSX for
    cleaner abstraction. While you may not want to use JSX in your project, you may
    find it more comfortable if you come from a React background.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
