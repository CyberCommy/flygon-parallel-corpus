- en: CRUD Operations in Spring REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through basic **Create**, **Read**, **Update**,
    and **Delete** (**CRUD**) APIs in Spring 5 Reactive REST. After this chapter,
    you will be able to do a simple CRUD operations in Spring 5 with Reactor support.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping CRUD operations to HTTP methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading (selecting) a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations in Spring REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through User management in Spring 5 (with Reactive
    support). We will implement CRUD operations in User management.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on HTTP 1.1 specifications, the following are method definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This method gets the information mentioned in the URI. The `GET` method
    can be used for single or multiple items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This method creates the item mentioned in the URI. Generally, the `POST`
    method will be used for item creation and more secured options. As the parameters
    are hidden in `POST`, it will be secure compared to the `GET` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This methods deletes the item in the requested URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This method updates the item in the requested URI. According to the
    HTTP specifications, the server can create the item if the item is not available.
    However, this will be decided by the developer who designed the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced HTTP methods**: Though we may not use advanced methods all the time,
    it will be good to know these methods, as they might be useful:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: This method gets meta information about the resource, not the resource
    itself, as a response. It will be used for caching purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`: This method is mostly used for debugging purposes where the contents
    of an HTTP request will be sent back to the requester.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONNECT`: This is used to open a tunnel and can be used for proxy purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This method is used to describe communication options for the target
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are HTTP method recommendations for our CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **HTTP method** |'
  prefs: []
  type: TYPE_TB
- en: '| Create | `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| Read | `GET` |'
  prefs: []
  type: TYPE_TB
- en: '| Update | `PUT` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete | `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: In the rest of the chapter, we will show how to build CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive server initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before jumping in to the endpoint, we will explore the structure of our files,
    including the initializer, handler, and repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Server` class for initializing our port `8081` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding method, we created a `main` class. Inside the `main` method,
    we will initialize the server and start the server with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method will start the Reactor server. The Reactor server implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through this code later, as the concept is Reactive-based. Let's assume
    that this code works fine and we will move on, focusing on the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the method for mapping all REST endpoints for our CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You might get errors on `UserRepository` and `UserHandler`. Let''s fill these
    up now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have just added the `UserRepository` interface in
    our existing package `com.packtpub.reactive`. Later, we will introduce abstract
    methods for our business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a `UserHandler` class, and add the necessary things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `UserHandler` initializes the `UserRepository` instance
    in its constructor. If someone gets an instance of `UserHandler`, they will have
    to pass the `UserRepository` type to the `UserHandler` constructor. By doing this,
    `UserRepository` will always be forwarded to `UserHandler` to fulfill the business
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Sample values in the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the repository, we will have to create a concrete class and
    fill in some values to test the `GET` operation. In the following method, we can
    do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class, we just implemented `UserRepository` and filled in some
    sample values.
  prefs: []
  type: TYPE_NORMAL
- en: In order to simplify our code, we have used only application-based data storage,
    which means that once the application is restarted, our data will be reinitialized.
    In this case, we can't store any new data in our application. However, this will
    help us to focus on our main topics, such as Reactive and Spring 5, which are
    not related to persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this sample repository in the `routing` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines will insert dummy values in our repository. This will be
    enough for testing the `GET` operation.
  prefs: []
  type: TYPE_NORMAL
- en: getAllUsers – mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `routingFunction`, we will add our first endpoint for `getAllUsers`.
    At first, we will keep the `null` values in the handler to avoid errors in the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `nest` method will be used to route to the right function, and
    it will also be used to group other routers. In the preceding method, we use `/user`
    in our path and we use `GET("/")` method as a router. Also, we use `MediaType.ALL`
    to accept all media ranges to simplify the code.
  prefs: []
  type: TYPE_NORMAL
- en: getAllUsers – implementation in the handler and repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will define and implement the `getAllUsers` method in our repository.
    Also, we will call the `getAllUsers` method in the `main` class through `UserHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add an abstract method for the `getAllUsers` method in the `UserRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Like any other interface and concrete class implementation, we will have to
    add the abstract method in our interface, in our case, `UserRespository`. The
    preceding code just adds `getAllUsers` in the `UserRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `UserRepositorySample` (the concrete class for `UserRepository`), we will
    implement the abstract method `getAllUsers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added the method `getAllUsers` and implemented
    the business logic. As we have already defined the users in the `UserRepositorySample`
    constructor, we just need to return the users. The `Flux` class has a method called
    `fromIterable`, which is used to get all users from our `UserRepositorySample`.
  prefs: []
  type: TYPE_NORMAL
- en: The `fromIterable` method will return a Flux that emits the items contained
    in our Java Collection interface. As Collection implements iterable interface,
    `fromIterable` will be the perfect method to return `Flux` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UserHandler.java` file, we will add the code to get all users in Reactive.
    The following code will walk us through the  necessary details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we will get all users from the repository in `Flux` and
    we will send them in the response in the JSON type. The server response content
    type is updated with `APPLICATION_JSON`.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to add our first method, `getAllUsers`, in our routing method.
    Here, we will use only one routing method to map all REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our routing function will look as follows in `Server.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a `UserRepository` and forwarded it to our
    `UserHandler`. `UserHandler` will automatically call the `getAllUsers` method
    in `UserSampleRepository`. By calling the `getAllUsers` method of `UserHandler`,
    we will get all users from the sample repository class that we have implemented
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are using the `nest` method and supplying parameters, such as the
    API path `GET("/")` and the media type. As the `nest` method accepts `RoutingFunction`
    as the second parameter, we can use more `nest` methods inside our basic `nest`
    methods. By using inner nesting methods, we have achieved the business requirement:
    our basic REST API starts from `"/user"` and basic get users API routing by `"/"`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the basic API path `/user` will automatically call the `getAllUsers` method
    as it's implemented in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the endpoint – getAllUsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have finished out first API implementation, we can now test it by calling
    the following URI in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can also check the API in any REST client, like Postman/SoapUI or any other
    REST client.
  prefs: []
  type: TYPE_NORMAL
- en: getUser – implementation in the handler and repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will define and implement the `getUser` method in our repository. Also,
    we will call the `getUser` method in the `main` class through `UserHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add an abstract method for the `getUser` method in the `UserRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will add the code for the `getUser` method. You can see that we have
    used the `Mono` return type for single-resource access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UserRepositorySample` class (the concrete class for `UserRepository`),
    we will implement the abstract method `getUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have retrieved the specific user by `id`. Also, we
    have mentioned that if the user is not available, the method should be asked to
    return an empty Mono.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UserHandler` method, we will talk about how to handle the request and
    apply our business logic to get the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have just converted the string `id` to an integer
    in order to supply it to our `Repository` method (`getUser`). Once we receive
    the result from the `Repository`, we are just mapping it in to `Mono<ServerResponse>`
    with the `JSON` content type. Also, we use `switchIfEmpty` to send the proper
    response if no item is available. If the searching item is not available, it will
    simply return the empty `Mono` object as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add `getUser` in our routing path, which is in `Server.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have just added a new entry, `.andRoute(GET("/{id}"),
    handler::getUser)`, in our existing routing path. By doing so, we have added the `getUser`
    method and the corresponding REST API part to access a single user. After restarting
    the server, we should be able to use the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the endpoint – getUser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have finished out first API implementation, we can now test it by calling
    the following URI in the browser using the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: createUser – implementation in the handler and repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will define and implement the `createUser` method in our repository.
    Also, we will call the `createUser` method in the `main` class through `UserHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add an abstract method for the `createUser` method in the `UserRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will talk about how to save the user by using the sample repository
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `UserRepositorySample` (the concrete class for `UserRepository`), we will
    implement the abstract method `createUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used `doOnNext` to save the user on the repository.
    Also, the method will return the empty `Mono` in the case of failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have added the `createUser` method in the repository, here we will follow
    up on our handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the `UserHandler` class, we have created the `createUser` method to add a
    user through a handler. In the method, we extract the request into `Mono` by the `bodyToMono`
    method. Once the `user` is created, it will be forwarded to `UserRepository` to
    save the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add the REST API path to save the `user` in our existing routing
    function in `Server.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Testing the endpoint – createUser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have finished out first API implementation, we can now test it by calling
    the following URI in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can''t use the `POST` method in a browser, we will test it in a REST
    API client, called Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82cd10d5-7c5a-445d-9586-4ad49159212a.png)'
  prefs: []
  type: TYPE_IMG
- en: After adding the new user, you can check the results by calling the `getAllUsers`
    URI (`http://localhost:8081/user`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Postman** is a REST client that can be used to build, test, and share REST
    API calls. Tools like these will be very helpful when we test our REST API without
    having to write code for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SoapUI** is another REST client and can be used as an alternative to Postman.'
  prefs: []
  type: TYPE_NORMAL
- en: updateUser – implementation in the handler and repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will define and implement the `updateUser` method in our repository.
    Also, we will call the `updateUser` method in the main class through `UserHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add an abstract method for the `updateUser` method in the `UserRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `UserRepositorySample` class, we will add the logic to update the code.
    Here, we will use the `userid` as the key and the `User` object as the value to
    store in our map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have updated the user by adding the specified user
    (from the request). Once the user is added in the list, the method will return
    `Mono<Void>`; otherwise, it will return the `Mono.empty` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have added the `updateUser` method in the repository, here we will follow
    up on our handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have converting the user request to `Mono<User>` by
    calling the `bodyToMono` method. The `bodyToMono` method will extract the body
    into a `Mono` object, so it can be used for the saving option.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with other API paths, we add the `updateUser` API in `Server.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Testing the endpoint – updateUser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have finished out first API implementation, we can now test it by calling
    the URI `http://localhost:8081/user` in Postman or SoapUI, using the `PUT` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/523cfdae-1c96-4847-bd10-03d5528e29b8.png)'
  prefs: []
  type: TYPE_IMG
- en: After updating the new user, you can check the results by calling the `getAllUsers`
    URI (`http://localhost:8081/user`).
  prefs: []
  type: TYPE_NORMAL
- en: deleteUser – implementation in the handler and repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will define and implement the `deleteUser` method in our repository.
    Also, we will call the `deleteUser` method in the `main` class through `UserHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we will add an abstract method for the `deleteUser` method in the
    `UserRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `UserRepositorySample.java` file, we will add the `deleteUser` method
    to remove the specified user from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we simply remove the element from users and return
    an empty `Mono` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have added the `deleteUser` method in the repository, here we will follow
    up on our handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add the REST API path to save the `user` in our existing routing
    function in `Server.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Testing the endpoint – deleteUser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have finished out first API implementation, we can now test it by calling
    the URI `http://localhost:8081/user/100` in our client (Postman or SoapUI) using
    the `DELETE` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df51fdd2-5775-4372-b8a4-8db654b3a0ff.png)'
  prefs: []
  type: TYPE_IMG
- en: After deleting the new user, you can check the results by calling the `getAllUsers`
    URI (`http://localhost:8081/user`).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use Reactive support (Flux and Mono)
    and how to integrate our APIs with Reactive components. We have learned basic
    CRUD operations on Reactive-based REST APIs with the help of the Reactor server.
    Also, we have covered how to add routing options for our CRUD operations and talked
    a little bit about Flux and Mono implementations in our CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, we will be focusing on Spring 5 REST (without Reactor
    support), as Spring Reactive libraries/APIs are still in unstable mode and haven't
    been used much in mainstream applications. Though the Spring team officially released
    support for Reactive, most business requirements are not clearly implemented and
    documented. Considering this situation, in upcoming chapters we will talk about
    Spring 5 without Reactive-related topics.
  prefs: []
  type: TYPE_NORMAL
