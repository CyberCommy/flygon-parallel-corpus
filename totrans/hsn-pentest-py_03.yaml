- en: Concept Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will allow us to get familiar with various object-oriented concepts
    in Python. We will see that Python can not only be used as a scripting language,
    but that it also supports a wide range of object-oriented principles and can therefore
    be used to design reusable and scalable software components. As well as this,
    we will explore regular expressions, files, and other I/O-based access including
    JSON, CSV, and XML. Finally, we will discuss exception handling. We will be covering
    the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files, directories, and other types of I/O-based access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data manipulation and parsing with XML, JSON, and CSV data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The object-oriented features of any programming language teach us how to deal
    with classes and objects. The same is the case for Python. The general object-oriented
    features that we shall be covering are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class relationships: inheritance, composition, association, and aggregation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static, instance, and class methods and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **class** can be thought of as a template or a blueprint that contains the
    definition of the method and the variables that are to be used with objects of
    that class. An **object** is nothing but an instance of the class, which contains
    actual values rather than variables. A class can also be defined as a collection
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this in simple terms, a class is a collection of variables and methods.
    The methods actually define the behavior or the operations that the class performs
    and the variables are the entities upon which the operations are performed. In
    Python, a class is declared with the class keyword, followed by the class name.
    The following example shows how to declare a basic employee class, along with
    some methods and operations. Let''s create a Python script called `Classes.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88a7d85c-8830-450b-8ebc-e800e20456cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following bullet points explain the preceding code and its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`class Id_Generator()`**: In order to declare a class in Python, we need
    to associate it with the class keyword, which is what we did in line 2 of the
    code. Whatever proceeds at an equal indentation forms part of the `Id_Generator`
    class. The purpose of this class is to generate an employee ID for every new employee
    created. It does this with the `generate()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`def __init__(self)`**: Every class in Python or any other programming language
    has got a constructor. This is either explicitly declared or it is not declared
    and the default constructor is taken implicitly. If you come from a background
    of using Java or C++, you might be used to the name of the constructor being the
    same as the class name, but this is not always the case. In Python, the class
    constructor method is defined using the `__init__` word, and it always takes `self`
    as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`self`**: The `self` is similar to a keyword. The `self` in Python represents
    the current instance of the class, and in Python every class method which is an
    instance method must have self as its first argument. This also applies to the
    constructor. It should be noted that while invoking the instance method, we don''t
    need to explicitly pass the instance of a class as an argument; Python implicitly
    takes care of this for us. Any instance-level variable has to be declared with
    the `self` keyword. This can be seen in the constructor—we have declared an instance
    variable ID as `self.id` and initialized it to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`def generate(self)`**: The `generate` is an instance method that increments
    the ID and returns the incremented ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`class Employee()`**: The `employee` class is a class that is used to create
    employees with its constructor. It prints the details of the employees with the
    `printDetails` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`def __init__(self,Name,id_gen)`**: There can be two kinds of constructor
    – parameterized and unparameterized. Any constructor that takes parameters is
    a parameterized constructor. Here, the constructor of the `employee` class is
    parameterized, because it takes two parameters: the name of the employee to be
    created and the instance of the `Id_Generator` class. In this method, we just
    call the generate method of the `Id_Generator` class, which returns us the employee
    ID. The constructor also initializes the employee name that was passed to the `self` class
    instance variable, which is `name`. It also initializes the other variables, `D_id`
    and `Salary`, to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`def printDetails(self)`**: This is the method that will print the details
    of the employee.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 24–32: In this section of the code, we first create the instance of the
    `Id_Generator` class and name it `Id_gen`. Then, we create an instance of the
    `Employee` class. Remember that the constructor of the class is invoked at the
    moment in which we create the instance of the class. Since in this case the constructor
    is parameterized, we have to create an instance that takes two parameters, with
    the first being the employee name and the second being the instance of the `Id_Generator`
    class. This is what we did in line 25: `emp1=Employee(''Emp1'',Id_gen)`. As mentioned
    earlier, we don''t need to pass `self` explicitly; Python takes care of this implicitly.
    After that, we assign some values to the `Salary` and `D_id` instance variables
    of the employee class for the `Emp1` instance. We also create another employee
    called `Emp2`, as shown in line 28\. Finally, we print the details of both the
    employees by invoking `emp1.printDetails()` and `emp2.printDetails()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the strongest advantages of object-oriented programming languages is
    code reuse. This reusability is powered by the relationship that exists between
    the classes. Object-oriented programming generally supports four types of relationships:
    inheritance, association, composition, and aggregation. All these relationships
    are based on **is-a**, **has-a**, and **part-of** relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Class inheritance** is a feature that we can use to extend the functionality
    of a class, by reusing the capability of another class. Inheritance strongly promotes
    code reuse. To take a simple example of inheritance, let''s say we have a `Car`
    class. The general attributes of the vehicle class would be `category` (such as
    SUV, sports, sedan, or hatchback), `mileage`, `capacity`, and `brand`. Let''s
    now say that we have another class called `Ferrari`, which, in addition to the
    normal car characteristics, has additional characteristics specific to a sports
    car, such as `Horsepower`, `Topspeed`, `Acceleration`, and `PowerOutput`. In this
    situation, we have use an inheritance relationship between the two classes. This
    type of relationship is an **is-a** relationship between the child and the base
    class. We know that a Ferrari is a car. In this case, the car is the base class,
    and the Ferrari is the child class that inherits common car attributes from the
    parent class and has extended characteristics of its own. Let''s expand the example
    we discussed previously, where we created an `Employee` class. We will now create
    another class called `Programmer` and see how can we establish an inheritance
    relation between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba8e64e6-daad-48cb-9f20-f5361846cbc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following bullet points explain the preceding code and its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Class Programmer(Employee)`: In the preceding case, we have created another
    class called `Programmer` that inherits from the `Employee` base class. There
    is an **is a** relationship between `Programmer` and `Employee`. As well as all
    the variables and methods of the `Employee` class, the `Programmer` class defines
    a few of its own, such as languages, databases, projects, and additional skills.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`def __init__(self,name,id_gen,lang,db,projects,**add_skills)`**: The `init`
    method of the `Programmer` class takes a few arguments that are self explanatory.
    Notice the invocation to the (`Employee` class) `super().__init__()` super class
    constructor, which is at line 32\. In other high-level languages such as Java
    and C++, we know that the base class or the super class constructor is automatically
    called from the child class constructor and that this is the first statement to
    be executed implicitly from the child class constructor when this is not specified.
    This is not the case with Python. The base class constructor would not be called
    implicitly from the child class constructor and we have to explicitly invoke it
    using the super keyword, as can be seen in line 32.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`def printSkillDetails(self)`**: This is the method that helps us explore
    the power of inheritance. We are using the base class variables in this method
    (`iD`, `name`, and `salary`), along with some variables specific to the `Programmer`
    class. This shows how inheritance can be used for reusing code and deriving an
    **is a** relation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines 52–62: Finally, we create an instance of the `Programmer` class and invoke
    the `printSkillDetails` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access modifiers in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, we don''t have access modifiers in the same way as we do in Java
    and C++. There is a partial workaround however, which  can be used to indicate
    which variables are `public`, `protected`, and `private`. The word **indicate** is
    important here; Python doesn''t prevent the usage of protected or private members,
    it just indicates which members are which. Let''s take a look at an example. Create 
    a class called `AccessSpecifiers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9df90c1-868b-4c3a-8195-4fc53ec92820.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding example shows us how access specifiers can be used in Python.
    Any variable that would be simply declared within a class is public by default,
    as we declared `self.public`. Protected variables in Python are declared by prefixing
    them with an underscore (`_`)  as seen in line 5, `self._protected`. But it must
    be noted that this does not prevent anyone from using them, as can be seen at
    line 23, in which we are using a protected member outside of the class. Private
    members in Python are declared by prefixing them with double underscore (`__`),
    as can be seen at line 6, `self.__private`. Again, however, there is nothing to
    prevent this member from being used outside the class. The way to access them
    is a little different, however; for private members, a specific convention is
    followed if they are to be accessed outside the class: `instance._<className><memberName>`.
    This is called **name mangling.**'
  prefs: []
  type: TYPE_NORMAL
- en: What we have learnt here about access modifiers in Python is that Python does
    have notations to denote public, private, and protected members of a class, but
    it doesn't have any way for the members to be used outside their scope, so it's
    merely for identification purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Composition** in OOP represents the **part of** relationship between classes.
    In this relationship, one class is a part of another class. Let''s consider the
    following example, `Composition.py`, to understand the composition relationship
    between classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de3e8ad9-955c-4e15-ab91-a7a3579209c9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the relation between the Ferrari car and the engine
    is of composition type. This is because the engine is **part of** the car, which
    is of the Ferrari type.
  prefs: []
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The association relationship maintains a **has a** kind of relationship between
    the objects of the classes. The **has a** relation can either be one-to-one or
    one-to-many. In the following example, we can see that there is a one-to-one association
    relationship between the `Employee` and `Manager` classes, as an `Employee` would
    only have one `Manager` class. We also have a one-to-one association relation
    between `Employee` and `Department`. The reverse of these relationships would
    be one-to-many relationships as one `Department` class might have many employees
    and one manager might have many employees reporting to them. The following code
    snippet depicts the association relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/beea7cf0-1d8d-4bbe-9cda-18414b49672a.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aggregation relationship is a special kind of **has a** relationship that
    is always one way. It''s also known as a one-way association relationship. For
    example, the relationship between `Employee` and `Address` is a one-way association,
    because an employee will always have an address, but the reverse of this won''t
    always be the case. The following example depicts the aggregation relationship
    between `Employee` and `Address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/994d4a59-bbb2-46e8-9235-d904530cc5c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many occasions in which we may want to have partial implementation
    of a class such that the class defines its objective with a template and it also
    defines how it must obtain a portion of its objective with the help of a few implemented
    methods. The remaining portion of the class objective can be left out to be implemented
    by the subclass, which is mandatory. To implement use cases such as this, we make
    use of abstract classes. An abstract base class, popularly known as an `abc` class,
    is a class that contains abstract methods. An abstract method is a method that
    does not have an implementation. It simply contains the deceleration and is meant
    to be implemented in the class that would implement or inherit from the abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important pointers about abstract classes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract method in Python is declared with the `@abstractmethod` decorator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While an abstract class can contain abstract methods, nothing prevents an abstract
    class from having normal or non-abstract methods as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class cannot be instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subclass of the abstract class must implement all the abstract methods of
    the base class. Failing this, it can't be instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the subclass of an abstract class doesn't implement the abstract methods,
    it automatically becomes an abstract class, which can be then further extended
    by another class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes in Python are implemented using the `abc` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a class called `Abstract.py` and take a look at how abstract
    classes can be used in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e68c2ad-439d-46e2-91d2-94023f36707a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we created an abstract class called `QueueAbs` that
    inherits from the `Abstract` base class, called `ABC`. The class has got two abstract
    methods, `enqueue` and `dequeue`, and also one concrete method called `printItems()`.
    Then, we created a class called `Queue` that is a subclass of the `QueueAbs` abstract
    base class and that implements the `enqueue` and `dequeue` methods. Finally, we
    make the instance of the `Queue` class and invoke the methods, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: One thing worth remembering here is that in Java and C#, an abstract class can't
    implement the abstract method. This is not the case with Python. In Python, an
    abstract method may or may not have a default implementation, but this does not
    prevent the subclass from overriding it. Irrespective of whether the abstract
    class method has an implementation or not, it is mandatory for the subclass to
    override it.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** refers to the property of an entity whereby it can exist in
    multiple forms. In terms of programming, it refers to the creation of a structure
    or method that can then be used with multiple objects or entities. In Python,
    polymorphism can be implemented in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism with functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism with classes (abstract classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s think about two classes, `Ferrari` and `McLaren`. Let''s assume that
    both have a `Speed()` method that returns the top speed of the cars. Let''s think
    about how can we use function polymorphism in this scenario. Let''s create a file
    called `Poly_functions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d69fa450-747f-44ce-9130-f010f91b2cea.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we have two classes, `Ferrari` and `McLaren`. Both have a common
    speed method that prints the speed of the two cars. One approach would be to create
    instances of both the classes and invoke the print speed method with each instance.
    Another approach could be to create a common method that takes the instance of
    the classes and that invokes the speed method on the instances it receives. This
    is the polymorphic `printSpeed(carType)` function that we defined at line 10.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism with classes (abstract classes)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be occasions in which we would want to define a template of a class
    in terms of what that class must do, but not in terms of how it should do it –
    we would want to leave that to the implementation of the class. This is where
    we can make use of abstract classes. Let''s create a script called `Poly_class.py`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ced77fe9-81c9-462f-bd46-c25fc2873fdb.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen that we have an abstract class called `Shape`, which has an `area`
    method. The `area` method is not implemented in this class, but it would be implemented
    in the child class. The `Square` and `Circle` child classes override the `area`
    method. The `area` method is polymorphic, which means that if a square overrides
    it, it implements the area of a square and when a `Circle` class overrides it,
    it implements the area of a circle.
  prefs: []
  type: TYPE_NORMAL
- en: Static, instance, and class methods in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three kinds of methods that can be defined within a Python class.
    Up until now, we have mostly been dealing with instance methods, which we have
    invoked with our Python class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance methods and variables:** Any method defined within a Python class
    that is invoked with the instance of the class, taking the self as its first positional
    argument, is said to be instance method. An instance method is able to access
    the  instance variables and the other instance methods of the class. With the
    `self.__class__` construct, it is also able to access the class level variables
    and the methods as well. An instance variable, on the other hand, is any variable
    that is declared within the Python class with the `self` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class methods and variables:** Any method that is declared with the `@classmethod`
    Python decorator invoked with the class name is said to be a class method. A class
    method may also be declared without the `@classmethod` decorator. If this is the
    case, it must be invoked with the class name. A class method will have access
    only to the variables that are marked or declared at the class level and will
    not have access to object or instance level class variables. A class variable,
    on the other hand, can be declared outside any method. Within the class, we have
    to declare the variable without using the self keyword. For this reason, class
    variables and methods to some extent resemble static methods and variables that
    we studied in Java, but there is a catch, as mentioned here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java and C#, we know that a static variable cannot be accessed with an instance
    of the class. In Python, static variables are class-level variables and they can
    actually be accessed by the instance of the class. But the access is read-only
    access, such that whenever a class-level variable is accessed with an instance
    of the class and the instance tries to modify or update it, Python automatically
    creates a new copy of the variable with the same name and assigns it to this instance
    of the class. This means that the next time the variable is accessed with the
    same instance, it will hide the class-level variable and it will provide access
    to the newly created instance-level copy of it instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static methods:** Any method in a Python class that is declared with the `@staticmethod` decorator is
    said to be a static method. Static methods in Python are different from what we
    saw in Java and C#. A static level method doesn''t have access to the instance 
    or the object-level variables, nor to the class-level variables of the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take an example called `Class_methods.py` to explain this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8c50950-2aae-4a6e-be1c-75f27fbe8e39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A continuation of the preceding code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8a6e8d2-3dbd-44e0-85c0-8c6346735d93.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code snippet explains the use of static, instance, and class methods.
    Whenever a class method is invoked by the instance of the class, Python automatically
    translates the instance type to class type internally, which can be seen in line
    42.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b7fefc-0f6d-44e8-8bf2-6c63bb93ff62.png)'
  prefs: []
  type: TYPE_IMG
- en: Files, directories, and I/O access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other programming language, Python provides a strong and easy interface
    to work with I/O, files, and directories. We will explore these in more detail
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: File access and manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can read, write, and update files in Python. Python has got an open construct
    that can be used to provide file manipulation operations. When we open a file,
    there are various modes in which that file can be opened, as shown follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: Read mode, this reads the file in text mode (Default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rb`: This reads the file in binary mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r+`: This reads the file in both read and write mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rb`: This opens the file for reading and writing in binary mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: This opens the file in write mode only. It overwrites the existing file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wb`: This opens the file for writing in binary mode. It overwrites the existing
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w+`: This opens the file in both write and read mode. It overwrites the existing
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wb+`: This opens the file for both reading and writing in binary mode. It
    overwrites the existing file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: This opens the file in append mode and creates a file if it doesn''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ab`: This opens the file in append binary mode and creates a file if it doesn''t
    exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`: This opens the file in both append and read mode and creates a file if
    it doesn''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ab+`: This opens the file in append read binary mode and creates a file if
    it doesn''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following code block, the first argument to the `open` method call is
    the path of the file to be opened. The second is the `mode` in which the file
    has to be opened, and the third is the optional buffering argument that specifies
    the file's desired `buffer` size: `0` means unbuffered, `1` means line-buffered,
    and any other positive value means use a buffer of (approximately) that size (in
    bytes). A negative buffering means that the system default should be used. This
    is usually line-buffered for tty devices and fully buffered for other files. If
    omitted, the system default is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With buffering, instead of reading directly from the operating system representation
    of the raw file (which would have high latency), the file is instead read into
    a OS buffer and read from there from then on. The advantage of this is that if
    we have a file present on the shared network and our objective is to read the
    file every 10 ms. We can load it once in the buffer and then read it from there,
    instead of reading it from the network each time, which would be expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following snippet from the `File_access.py` file to understand
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72c27a66-405c-4bff-8007-6fce75c0dea8.png)'
  prefs: []
  type: TYPE_IMG
- en: The code snippet in the preceding screenshots from the `File_access.py` file
    explains how to use files in Python. The `read()` method of the `File` class takes
    the file path and if the whole path is not given, then the current working directory
    is assumed to be the starting path. The `read()` method invoked on the file instance
    reads the whole file into the program variable. `read(20)` will load 20 bytes
    from the file in the current file pointer position. This is very handy when we
    are dealing with large files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readlines()` method returns a list, with each entry referring to each
    line of the file. The `readline()` method returns the current line from the file.
    The `seek()` method will take the file pointer to the position specified in the
    argument. Therefore, whenever we execute `seek(0)`, the file pointer points towards
    the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d982737e-10d6-4d76-9cf5-750bcf84a5c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Renaming and deleting files and accessing directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, system-level access to file directories and various other operating
    system commands is provided by the `os` module. The `os` module is a very powerful
    utility. In this section, we will see a few of its uses with respect to renaming,
    deleting, creating, and accessing directories with the help of the following snippet
    from the `os_directories.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/510246cb-685b-46a6-8e83-c58199e98da4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code snippet in the preceding screenshot shows the various ways in which
    the `os` module is used with files and directories in Python, in order to rename
    and delete files and create and change directories. It also showed us how we can
    rename and traverse all the files (including nested files) from a subfolder. It
    should be noted that if we wish to delete a folder, we can use the `os.rmdir()` method,
    but all the files of the folder should be explicitly deleted in order for this
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows what happens with the file before and after its
    creation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d27dec94-d550-47f0-a800-82356b636b19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following output shows the change in the file name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d00304ad-2c46-4020-908e-aeaf748b38af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following output shows the change after the file is removed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ac7c3bda-3308-4ea5-8b4f-2da84ba8b947.png)'
  prefs: []
  type: TYPE_IMG
- en: Console I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have dealt with Python programs that mostly have hardcoded data
    as an input. Let''s see how can we take input from the user in Python and use
    that in our code instead. We will create a file called `user_input.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2737bd23-9fff-48d2-a9ef-9f03d0d1a749.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is fairly self-explanatory. In order to take the user input, we use the
    `input()` method, which halts the screen until the user provides an input. It
    always returns a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee4a3968-eabd-4d31-a6aa-36744383f1ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Regular expressions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular expressions** are very powerful and are widely used for pattern matching
    in the cyber security domain, be it dealing with parsing log files, Qualys or
    Nessus reports, or outputs produced by Metasploit, NSE or any other service scanning
    or exploit script. The module that provides support for regular expressions in
    Python is `re`. There are a few important methods that we will be using with Python
    regular expressions (the `re` module), which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `match()` | This determines if the regular expression finds a match at the
    beginning of the string `re.match(pattern,string,Flag=0)`. The flags can be specified
    with the `&#124;` or operator. The most commonly used flags are `re.Ignore-Case`,
    `re.Multiline`, and `re.DOTALL`. These flags can be specified with the or operator
    as (`re.M&#124; re.I`). |'
  prefs: []
  type: TYPE_TB
- en: '| `search()` | Unlike match, search doesn''t look for a match just at the beginning
    of the string, but instead searches or traverses throughout the string to look
    for the given search string/regex that can be specified as `re.search(pattern,string,Flag=0)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `findall()` | This searches the string for the regex matches and returns
    all the substrings as a list wherever it finds a match. |'
  prefs: []
  type: TYPE_TB
- en: '| `group()` | If a match is found, then `group()` returns the string matched
    by the RE. |'
  prefs: []
  type: TYPE_TB
- en: '| `start()` | If a match is found, then `start()` returns the starting position
    of the match. |'
  prefs: []
  type: TYPE_TB
- en: '| `end()` | If a match is found, then `end()` returns the end position of the
    match. |'
  prefs: []
  type: TYPE_TB
- en: '| `span()` | If a match is found, then `span()` returns a tuple containing
    the start and end positions of the match. |'
  prefs: []
  type: TYPE_TB
- en: '| `split()` | This splits a string on the basis of a regex match and returns
    us a list. |'
  prefs: []
  type: TYPE_TB
- en: '| `sub()` | This is used for string replacement. It replaces all the substrings
    wherever it finds a match. It returns a new string if the match is not found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `subn()` | This is used for string replacement. It replaces all the substrings
    wherever it finds a match. The return type is a tuple with the new string at index
    0 and the number of replacements at index 1. |'
  prefs: []
  type: TYPE_TB
- en: 'We will now try to understand regular expressions with the help of the following
    snippet from the `regular_expressions.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8004fd3-a4ef-4d0e-900a-174774490875.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The difference between `match` and `search` is that `match` only searches for
    the pattern at the beginning of the string, whereas `search` looks throughout
    the entire input string. The output produced with code lines 42 and 50 will illustrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5febd3bf-641a-4918-9857-f09a0961ee8f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screen, it can be seen that when the `Hello` input is passed,
    both `match` and `search` were able to locate the string. However, when the input
    passed was `\d`, which means any decimal, `match` was not able to locate it but
    `search` was. This is because the `search` method searches throughout the string
    and not just the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it can be seen from the following screenshot that `match` did not return
    the grouping of digits and non-digits, but `search` did:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/103f9502-7e14-446b-9540-612b790ee6d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following output, the `Reg` keyword is searched, so both `match` and
    `search` return results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d53c255f-370b-4e6a-bba4-133b4012e11c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how `findall()`, in the following screenshot, is different from `match`
    and `search`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcb6ea48-da84-4f3c-9bfe-ed19b1fdbca4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These examples have shown how `match()` and `search()` operate differently
    and how `search()` is more powerful for carrying out search operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fac2b11-551e-472e-af98-da7102068a6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at a few important regular expressions in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Regex expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | This matches digits from zero to nine to a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `(\D\d)` | This matches the `\D` non-digits and the `\d`  digits that are
    grouped together. Parentheses (`()`) are used for grouping. |'
  prefs: []
  type: TYPE_TB
- en: '| `.*string.*` | This returns a match if a word is found in the string, irrespective
    of what is before and after it. The `.*` notation means anything and everything.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | The cap symbol means it matches a pattern at the start of the string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-zA-Z0-9]` | `[...]` is used to match anything that is placed inside the
    braces. `[12345]`, for example, means that a match should be found for any number
    between one and five. `[a-zA-Z0-9]` means that all alphanumeric characters should
    be considered matches. |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | `\w` is identical to `[a-zA-Z0-9_]` and matches all the alphanumeric characters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | `\W` is the negation of `\w` and matches all non-alphanumeric characters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | `\D` is the negation of `\d` and matches all characters that aren''t
    digits. |'
  prefs: []
  type: TYPE_TB
- en: '| `[^a-z]` | `^`, when placed inside `[]`, acts as a negation. In this case,
    it means match anything besides letters from `a` to `z`.  |'
  prefs: []
  type: TYPE_TB
- en: '| `re{n}` | This means match exactly `n` occurrences of the preceding expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `re{n ,}` | This means match `n` or more  occurrences of the preceding expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `re {n,m}` | This means match a minimum of `n` and a maximum of `m` occurrences
    of the preceding expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | This means match the space characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `[T&#124;t]est` | This means match both `Test` and `test`. |'
  prefs: []
  type: TYPE_TB
- en: '| `re*` | This means match any occurrence of the expression following `*`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `re?` | This means match any occurrence of the expression following `?`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `re+` | This means match any occurrence of the expression following `+`.
    |'
  prefs: []
  type: TYPE_TB
- en: Data manipulation and parsing with XML, JSON, and CSV data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first look at how we can manipulate XML data in Python
    followed by how we can manipulate JSON data. After that, we will look at the pandas
    Python utility with a focus on CSV.
  prefs: []
  type: TYPE_NORMAL
- en: XML data manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how can we manipulate XML data in Python.
    While there are many ways to parse XML documents in Python, the simple and the
    most widely used method is using the `XML.etree` module. Let''s see the following
    example, which will illustrate how easy and simple it is to parse XML documents
    and strings in Python. Create a script called `xml_parser.py`. We will use an
    XML document called `exmployees.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2af0e0e4-8682-4da6-bbda-ce278188c0b1.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding example, we simply use the `xml.etree.ElementTree`
    module and alias it as ET. In the parse method of the class, we extract the root
    of the XML document or the XML string by invoking the `parse` method, in the former
    case, and the `fromstring` method, in the latter case. This will return us an
    instance of the `<class 'xml.etree.ElementTree.Element'>` ET element class. We
    can iterate over this to get all the child nodes, as seen from line 21 to line
    26\. If we do not know the names of the attributes of a node, the `attrib` property
    of the class returns a dictionary that has a key value mapping for the attribute
    names and their values. If we do know the name of the subnodes, we can follow
    a second method, which is shown from line 29 to line 36, where we specify the
    names of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass an XML string instead of a file, the only change is in the way we
    initialize the root element; the rest remains the same. Another thing to note
    about this script is that we are using command-line arguments. `sys.argv[]` is
    used to access these command-line arguments, with the 0^(th) index of the file having
    the name of the script itself and the arguments from index 1 onwards. In our example,
    the name of the XML file is passed as a command-line argument to the script and
    is accessed with the `sys.argv[1]` property. This is shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1c97fa6-d348-4d0b-ae92-e7cedbf8724a.png)'
  prefs: []
  type: TYPE_IMG
- en: JSON data manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now look at how to use Python to manipulate JSON data. JSON (Java Script
    Object Notation) is a very widely used data storage and exchange format. It gained
    popularity as the internet matured, and it became the standard for information
    exchange in REST-based APIs or services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides us with a JSON module for JSON data manipulation. Let''s create
    a JSON file called `employees.json` and look at how we can use the JSON module
    to access the JSON content. Let''s say that our objective is to read the employees''
    data, then to find the employees whose salary is over 30,000, and mark them with
    slab `A`. We''ll then mark those whose salary is less than 30,000 with slab `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4eaf8647-2b2b-441e-8317-7bc715e5cce7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The obtained output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b699e6c9-04e1-45ef-b33e-598ac06ead4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be deduced from the previous code, the JSON file is loaded as a Python
    dictionary, which can be achieved with the help of the `json.load()` command.  The
    `load ()` method expects the JSON file path to be provided as an argument. If
    the JSON data is not present as an external file but as a Python string instead,
    we can use the `json.loads()` method and pass the JSON string as an argument.
    This will again convert the string into a Python native type, which would either
    be a list or a dictionary. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `json_parse.py` file, lines 10 to 20 simply iterate over the Python
    dictionaries and inner lists and display the employee details. This is something
    we have seen before. The objective of the script was actually to update the employee
    slab, which is achieved in the `process()` method. We open and load the JSON file again in
    the Python native type (line 23). Then, we iterate over the Python dictionary.
    In line 27, we check if the salary of the employee is greater than or equal to
    30,000\. If it is, we modify the employee''s slab, by modifying the original `json_data`
    object that loaded all details. The `json_data["employees"]["data"][index]["slab"]` statement
    will point towards the slab of the current employee, decide whether their salary
    is more or less than 30,000 and set it to `A` or `B` as appropriate. Finally,
    we will have the modified details of the employees in the `json_data` object and
    we will overwrite the contents of the original JSON file using the file object
    with `json.dump() method.json.dump()`. This will take a Python native object (list,
    dictionary, or tuple) and convert it to its JSON equivalent. It takes the `file_object`
    as its second argument to indicate where the JSON data must go. It also takes
    formatting options such as `indent`, `sort_keys`, and so on. Likewise, we also
    have a `json.dumps()` method, which translates a Python native type to its JSON
    string equivalent. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It should be remembered that external JSON files can not be modified in place.
    In other words, we cannot modify a part of the external JSON file and keep the
    rest the same. In this case, we need to overwrite the whole file with the new
    content.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CSV data** is very widely used in the cyber security and data science domain,
    whether in the form of log files, as an output of Nessus or Qualys reports (in
    Excel format), or large datasets for machine learning. Python provides excellent
    support for CSV files with the built-in CSV module. In this section, we shall
    explore this module and look at the pandas Python utility with a focus on CSV.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the built-in CSV module offered by Python. The following
    code snippet, called `csv_parser.py`, demonstrates this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4749f061-9e48-4237-bae7-4b9f61412218.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code helps us understand how we can use the CSV module to read
    CSV files in Python. It's always recommended to use the CSV module, as this takes
    care of delimiters, new lines, and characters internally. There are two ways of
    reading from a CSV file, the first of which is to use the `csv.reader()` method
    (lines 10-25), which returns us a list of CSV strings. Each row or item of the
    list will be a string list representing a row of the CSV file, where each item
    can be accessed with the index. The other way to read CSV files is with the help
    of `csv.DictReader()` (lines 29-38), which returns a list of dictionaries. Each
    dictionary will have a key value pair with a key that represents the CSV column
    and a value, which is the actual row value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output produced is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b9cd6c3-59ac-4e64-b0a5-91f72d0db0c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to write to a CSV file, there are again two different ways. One way
    is to make use of the `csv.DictWriter()` directive, which returns a writer object
    and has the capability to push a Python list or dictionary directly to a CSV file.
    This would transform a Python list or dictionary to CSV format internally, when
    we invoke the `writerows()` method on the list or dictionary. This is shown from
    lines (40-53): we check the salary of an employee, associate the appropriate slab
    to it, and finally use the `writerows()` method to overwrite the modified CSV
    file. The `csv.DictWriter()` supports both `writerows()` and the `write row()`
    method. The `writerows()` method would simply take a dictionary and write it to
    the CSV file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to write to a CSV file is by using the `csv.Writer()` method.
    This returns a writer object, which takes a list of lists (strings) as an argument on
    the `writerows()` method and writes the structure to the external CSV file. The
    examples for both of these methods as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcffdd28-fda0-48fa-ad18-cc52eb3bf1e6.png)'
  prefs: []
  type: TYPE_IMG
- en: While the preceding ways of accessing and dealing with CSV files are good, they
    won't help if the CSV file is very large. If the CSV file is 10 GB and the RAM
    of the system is just 4 GB, neither `csv.reader()` or `csv.DictReader()` will
    work well. This is because both `reader()` and `DictReader()` read the external
    CSV file completely in the variable program memory, which is the RAM. For a huge
    file, it's not advisable to use the CSV module directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach could be to read the file with the help of iterator,
    or in byte chunks, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/422f0beb-263e-4baa-b4bf-36c2b024054b.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code snippet will not load the entire file in the memory but would
    read one line at a time. This way, we can process and store that line in the database
    or carry out any relevant action. Because the file is read line by line, this
    would cause trouble if we have multiline CSV data. As we can see in the preceding
    example, the first record for `Emp1` is not read completely; it is split across
    two lines with the second line containing only part of the `Description` field.
    This means the previous approach would not work for large or multiline CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to read in terms of chunks or bytes, as we saw earlier, we would not
    know how many chunks or bytes would correspond to one row, so this would also
    give inconsistent results. To get around this issue, we will use Pandas, a powerful
    Python data analysis toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed information on Pandas, please go through the following: [http://pandas.pydata.org/pandas-docs/stable/](http://pandas.pydata.org/pandas-docs/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install pandas, which can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet explains how to use pandas to read a huge CSV file
    in small chunks and thus reduce the memory usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a040bd-0403-468a-929c-b1b11e816f89.png)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the preceding code snippet, we declare the chunk size to be 100,000
    records, assuming we have a very large CSV file to process. The chunk size is
    the upper limit; if the actual records are less than the chunk size, the program
    will just fetch the lowest of the two. Then, we load the CSV file with `pd.read_csv()`,
    specifying the chunk size as one of the arguments. The `chunk.rename()` methods
    would actually remove the newline characters from the column names (if there are
    any) and `chunk.fillna('')` will take up the empty values returned by the CSV
    file. Instead of NA, it will fill them with empty string. Finally, we iterate
    over the rows with the `iterrows()` method, which returns a tuple, and we print
    the values as shown. It should be noted that `pd.read_csv()` returns a pandas
    DataFrame, which can be thought of as an in-memory relational table.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions, as we are all aware, are conditions that are unforeseen. They may
    arise at run time and cause a program to crash. For this reason, it is recommended
    to put suspect code (that may lead to an exception) in an exception handling code
    block. Then, even if an exception occurs, our code will handle it appropriately
    and take the required actions. Like Java and C#, Python also supports the legacy
    try and catch blocks for handling exceptions. There is a slight change, however,
    which is that the catch block in Python is called except.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can do basic exception handling in
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a860a901-891c-44c5-949d-287fa7267489.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is self explanatory. Instead of `try` and `catch`, Python
    uses `try` and `except`. We use the `raise` command in order to manually throw
    the exceptions. The final block works as it does in every other language with
    the core condition that irrespective of whether the exception occurs or not, the
    final block should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that in the previous example, we used a general Exception
    class when handling exceptions in the except block. If we are sure what kind of
    exception the code may raise, we can use specific exception handlers such as `IOError`,
    `ImportError`, `ValueError`,`KeyboardINterupt`, and `EOFError`. Finally, it should
    also be remembered that in Python we can use an else block alongside a `try` block
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed OOP, Files, directories, IO, XML, JSON, CSV, and
    exception handling with respect to Python. These are the core constructs of Python
    and are very widely used. We will be using all these structures and concepts frequently
    when we move on to the section on implementing penetration testing and cyber security
    with Python, so it's important that we have a good understanding of them all.
    In the next chapter, we will discuss more advanced concepts such as multithreading,
    multiprocessing, sub processes in Python, and socket programming. With that chapter,
    we will finish exploring the prerequisites of Python, which will in turn lead
    us onto learning about penetration testing and cyber security ecosystems with
    regard to Python.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often hear of Python as a scripting language. What is the typical advantage
    of using it as an object-oriented language? Can you think of any particular products
    or use cases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some ways in which can we parse XML and CSV files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we detect all the attributes of a class without seeing the class structure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are method decorators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pandas: [https://pandas.pydata.org/](https://pandas.pydata.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NumPy: [http://www.numpy.org/](http://www.numpy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python GUI programming: [https://www.python-course.eu/python_tkinter.php](https://www.python-course.eu/python_tkinter.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
