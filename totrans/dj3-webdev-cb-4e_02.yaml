- en: Models and Database Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using model mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin with URL-related methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle creation and modification dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to take care of meta tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle generic relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multilingual fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with model translation tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding circular dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding database constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a foreign key to the many-to-many field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start a new app, the first thing that you do is create the models that
    represent your database structure. We are assuming that you have already created
    Django apps, or, at the very least, have read and understood the official Django
    tutorial. In this chapter, you will see a few interesting techniques that will
    make your database structure consistent across the different apps in your project.
    Then, you will see how to handle the internationalization of the data in your
    database. After that, you will learn how to avoid circular dependencies in your
    models and how to set database constraints. At the end of the chapter, you will
    see how to use migrations to change your database structure during the process
    of development.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code in this book, you will need the latest stable version
    of Python, the MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the code for this chapter in the `ch02` directory in the GitHub
    repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Using model mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented languages, such as Python, a mixin class can be viewed as
    an interface with implemented features. When a model extends a mixin, it implements
    the interface and includes all of its fields, attributes, properties, and methods.
    The mixins in Django models can be used when you want to reuse the generic functionalities
    in different models multiple times. The model mixins in Django are abstract base
    model classes. We will explore them in the next few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you will need to create reusable mixins. A good place to keep your model
    mixins is in a `myproject.apps.core` app. If you create a reusable app that you
    will share with others, keep the model mixins in the reusable app itself, possibly
    in a `base.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `models.py` file of any Django app that you want to use mixins with,
    and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django''s model inheritance supports three types of inheritance: abstract base
    classes, multi-table inheritance, and proxy models. Model mixins are abstract
    model classes, in that we define them by using an abstract `Meta` class, with
    specified fields, properties, and methods. When you create a model such as `Idea`,
    as shown in the preceding example, it inherits all of the features from `CreationModificationDateMixin`,
    `MetaTagsMixin`, and `UrlMixin`. All of the fields of these abstract classes are
    saved in the same database table as the fields of the extending model. In the
    following recipes, you will learn how to define your model mixins.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In normal Python class inheritance, if there is more than one base class, and
    all of them implement a specific method, and you call that method on the instance
    of a child class, only the method from the first parent class will be called,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for Django model base classes; however, there is one special
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: The Django framework does some magic with metaclasses that calls the `save()`
    and `delete()` methods from each of the base classes.
  prefs: []
  type: TYPE_NORMAL
- en: That means that you can confidently do pre-save, post-save, pre-delete, and
    post-delete manipulations for specific fields defined specifically in the mixin
    by overwriting the `save()` and `delete()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the different types of model inheritance, refer to the official
    Django documentation, available at [https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance](https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin with URL-related methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For every model that has its own distinct detail page, it is good practice to
    define the `get_absolute_url()` method. This method can be used in templates and
    also in the Django admin site to preview the saved object. However, `get_absolute_url()`
    is ambiguous, as it returns the URL path instead of the full URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at how to create a model mixin that provides simplified
    support for model-specific URLs. This mixin will enable you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow you to define either the URL path or the full URL in your model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate the other URL automatically, based on the one that you defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `get_absolute_url()` method behind the scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't yet done so, create the `myproject.apps.core` app where you will
    store your model mixins. Then, create a `models.py` file in the core package.
    Alternatively, if you create a reusable app, put the mixins in a `base.py` file
    in that app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the following steps, one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `models.py` file of your `core` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `WEBSITE_URL` setting without a trailing slash to the `dev`, `test`,
    `staging`, and `production` settings. For example, for the development environment
    this will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the mixin in your app, import the mixin from the `core` app, inherit
    the mixin in your model class, and define the `get_url_path()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UrlBase` class is an abstract model that has three methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_url()` retrieves the full URL of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_url_path()` retrieves the absolute path of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_absolute_url()` mimics the `get_url_path()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get_url()` and `get_url_path()` methods are expected to be overwritten
    in the extended model class, for example, `Idea`. You can define `get_url()`,
    and `get_url_path()` will strip it to the path. Alternatively, you can define
    `get_url_path()`, and `get_url()` will prepend the website URL to the beginning
    of the path.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb is to always overwrite the `get_url_path()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the templates, use `get_url_path()` when you need a link to an object on
    the same website, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `get_url()` for links in external communication, such as in emails, RSS
    feeds, or APIs; an example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The default `get_absolute_url()` method will be used in the Django model administration
    for the View on site functionality, and might also be used by some third-party
    Django apps.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, don''t use incremental primary keys in the URLs, because it is
    not safe to expose them to the end user: the total amount of items would be visible,
    and it would be too easy to navigate through different items by just changing
    the URL path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the primary keys in the URLs for the detail pages only if they
    are **Universal Unique Identifiers** (**UUIDs**) or generated random strings.
    Otherwise, create and use a slug field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring settings for development, testing, staging, and production
    environments* recipe, in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle creation and modification dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common to include timestamps in your models for the creation and modification
    of your model instances. In this recipe, you will learn how to create a simple
    model mixin that saves the creation and modification dates and times for your
    model. Using such a mixin will ensure that all of the models use the same field
    names for the timestamps, and have the same behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't yet done so, create the `myproject.apps.core` package to save
    your mixins. Then, create the `models.py` file in the core package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `models.py` file in your `myprojects.apps.core` package, and insert
    the following content there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CreationModificationDateMixin` class is an abstract model, which means
    that extending model classes will create all of the fields in the same database
    table—that is, there will be no one-to-one relationships that make the table more
    complex to handle.
  prefs: []
  type: TYPE_NORMAL
- en: This mixin has two date-time fields, `created` and `modified`. With the `auto_now_add`
    and `auto_now` attributes, the timestamps will be saved automatically when saving
    a model instance. The fields will automatically get the `editable=False` attribute,
    and thus will be hidden in administration forms. If `USE_TZ` is set to `True`
    in the settings (which is the default and recommended), time-zone-aware timestamps
    will be used. Otherwise, time-zone-naive timestamps will be used. Timezone-aware
    timestamps are saved in the **Coordinated Universal Time** (**UTC**) time zone
    in the database and converted to the default time zone of the project when reading
    or writing them. Time-zone-naive timestamps are saved in the local time zone of
    the project in the database; they are not practical to use in general, because
    they make time management between time zones more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this mixin, we just have to import it and extend our model,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to take care of meta tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you optimize your site for search engines, you not only have to use semantic
    markup for each page, but you also have to include appropriate meta tags. For
    maximum flexibility, it helps to have a way to define content for common meta
    tags, specific to objects that have their own detail pages on your website. In
    this recipe, we will look at how to create a model mixin for the fields and methods
    related to the keyword, description, author, and copyright meta tags.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As detailed in the previous recipes, make sure that you have the `myproject.apps.core`
    package for your mixins. Also, create a directory structure, `templates/utils/includes/`,
    under the package, and inside of that, create a `meta.html` file to store the
    basic meta tag markup.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our model mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to add `"myproject.apps.core"` to `INSTALLED_APPS` in the settings,
    because we want to take the `templates` directory into account for this module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following basic meta tag markup to `meta_field.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `models.py` file from the core package in your favorite editor, and
    add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This mixin adds four fields to the model that extends from it: `meta_keywords`,
    `meta_description`, `meta_author`, and `meta_copyright`. The corresponding `get_*()`
    methods, used to render the associated meta tags, are also added. Each of these
    passes the name and appropriate field content to the core `get_meta_field()` method,
    which uses this input to return rendered markup based on the `meta_field.html`
    template. Finally, a shortcut `get_meta_tags()` method is provided to generate
    the combined markup for all of the available metadata at once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use this mixin in a model, such as `Idea`, which is shown in the *Using
    model mixins* recipe at the start of this chapter, you can put the following in
    the `HEAD` section of your `detail` page template to render all of the meta tags
    at once, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a `meta_tags` block has been defined in a parent template, and this snippet
    shows how the child template redefines the block, including the content from the
    parent first as `block.super`, and extending it with our additional tags from
    the `idea` object. You could also render only a specific meta tag by using something
    like the following: `{{ idea.get_meta_description }}`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed from the `models.py` code, the rendered meta tags are
    marked as safe – that is, they are not escaped, and we don't need to use the `safe`
    template filter. Only the values that come from the database are escaped, in order
    to guarantee that the final HTML is well formed. The database data in `meta_keywords`
    and other fields will automatically be escaped when we call `render_to_string()`
    for the `meta_field.html` template, because that template does not specify `{%
    autoescape off %}` in its content.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle generic relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from normal database relationships, such as a foreign-key relationship
    or a many-to-many relationship, Django has a mechanism to relate a model to an
    instance of any other model. This concept is called generic relations. For each
    generic relation, we save the content type of the related model as well as the
    ID of the instance of that model.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to abstract the creation of generic relations
    in the model mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe to work, you will need to have the `contenttypes` app installed.
    It should be in the `INSTALLED_APPS` list in the settings, by default, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, make sure that you have already created the `myproject.apps.core` app
    for your model mixins.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create and use a mixin for generic relations follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file in the core package in a text editor, and insert
    the following content there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is an example of how to use two generic relationships
    in your app (put this code in `ideas/models.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, this snippet is more complex than the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: The `object_relation_base_factory` function, which we have aliased to `generic_relation`,
    for short, in our import, is not a mixin itself; it is a function that generates
    a model mixin – that is, an abstract model class to extend from. The dynamically
    created mixin adds the `content_type` and `object_id` fields and the `content_object`
    generic foreign key that points to the related instance.
  prefs: []
  type: TYPE_NORMAL
- en: Why can't we just define a simple model mixin with these three attributes? A
    dynamically generated abstract class allows us to have prefixes for each field
    name; therefore, we can have more than one generic relation in the same model.
    For example, the `Like` model, which was shown previously, will have the `content_type`,
    `object_id`, and `content_object` fields for the favorite object, and `owner_content_type`,
    `owner_object_id`, and `owner_content_object` for the one (user or group) that
    liked the object.
  prefs: []
  type: TYPE_NORMAL
- en: The `object_relation_base_factory` function, which we have aliased
  prefs: []
  type: TYPE_NORMAL
- en: to `generic_relation` for short, adds the possibility to limit the content type
    choices by the `limit_content_type_choices_to` parameter. The preceding example
    limits the choices for `owner_content_type` to only the content types of the `User`
    and `Group` models.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe in [Ch](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)[apter](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)
    [4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multilingual fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses the internationalization mechanism to translate verbose strings
    in the code and templates. But it's up to the developer to decide how to implement
    the multilingual content in the models. We'll show you a couple of ways for how
    to implement multilingual models directly in your project. The first approach
    will be using language-specific fields in your model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It is straightforward to define multilingual fields in the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simple to use the multilingual fields in database queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use contributed administration to edit models with the multilingual
    fields, without additional modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to, you can effortlessly show all of the translations of an object
    in the same template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After changing the amount of languages in the settings, you will need to create
    and run migrations for all multilingual models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you created the `myproject.apps.core` package used in the preceding recipes
    of this chapter? You will now need a new `model_fields.py` file within the `core`
    app, for the custom model fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the following steps to define the multilingual character field and
    multilingual text field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `model_fields.py` file, and create the base multilingual field, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, subclass the base field for character and text field forms,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `admin.py` file in the core app, and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll consider an example of how to use the multilingual fields in your
    app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set multiple languages in the settings for your project. Let''s say,
    our website will support all official languages of the European Union, with English
    being the default language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `models.py` file from the `myproject.apps.ideas` app, and create
    the multilingual fields for the `Idea` model, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `admin.py` file for the `ideas` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example of `Idea` will generate a model that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If there were any language codes with a dash, like "de-ch" for Swiss German,
    the fields for those languages would be replaced with underscores, like `title_de_ch`
    and `content_de_ch`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the generated language-specific fields, there will be two properties
    – `title` and `content` – that will return the corresponding field in the currently
    active language. These will fall back to the default language if no localized
    field content is available.
  prefs: []
  type: TYPE_NORMAL
- en: The `MultilingualCharField` and `MultilingualTextField` fields will juggle the
    model fields dynamically, depending on your `LANGUAGES` setting. They will overwrite
    the `contribute_to_class()` method that is used when the Django framework creates
    the model classes. The multilingual fields dynamically add character or text fields
    for each language of the project. You'll need to create a database migration to
    add the appropriate fields in the database. Also, the properties are created to
    return the translated value of the currently active language or the main language,
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the administration, `get_multilingual_field_names()` will return a list of
    language-specific field names, starting with one of the default languages and
    then proceeding with the other languages from the `LANGUAGES` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a couple of examples of how you might use the multilingual fields in
    templates and views.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the following code in the template, it will show the text in the
    currently active language, let''s say Lithuanian, and will fall back to English
    if the translation doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to have your `QuerySet` ordered by the translated titles, you can
    define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with model translation tables* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using migrations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6](8b8138c4-c364-4616-8a81-b2f369cf870b.xhtml)*, Model Administration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with model translation tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second approach to handling multilingual content in the database involves
    using model translation tables for each multilingual model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The features of this approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use contributed administration to edit translations as inlines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After changing the amount of languages in the settings, no migrations or other
    further actions are necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can effortlessly show the translation of the current language in the template,
    but it would be more difficult to show several translations in specific languages
    on the same page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to know and use a specific pattern described in this recipe for creating
    model translations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not that simple to use this approach for database queries, but, as you
    will see, it's still possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we will start with the `myprojects.apps.core` app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the following steps to prepare for multilingual models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `core` app, create `model_fields.py` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `admin.py` file to the `core` app with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s implement the multilingual models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set multiple languages in the settings for your project. Let''s say,
    our website will support all official languages of European Union with English
    being the default language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create the `Idea` and `IdeaTranslations` models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, create the `admin.py` for the `ideas` app as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We keep the language-specific fields of the default language in the `Idea` model
    itself. The translations for each language are in the `IdeaTranslations` model,
    which will be listed in the administration as an inline translation. `IdeaTranslations`
    don't have the language choices at the model for a reason – we don't want to create
    migrations every time a new language is added or some language is removed. Instead,
    the language choices are set in the administration form, also making sure that
    the default language is skipped or not available for selection in the list. The
    language choices are restricted using the `LanguageChoicesForm` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a specific field in the current language, you would use the fields defined
    as `TranslatedField`. In the template, that would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To order items by a translated title in a specific language, you would use
    the `annotate()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we prompt for a language code in the Django shell. If the language
    is the default one, we store the `title` and `content` as the `title_translation` and
    the `content_translation` from the `Idea` model. If there is another language
    chosen, we read the `title` and `content` as `title_translation` and `content_translation` from
    the `IdeaTranslations` model  with the chosen language.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we can filter or order `QuerySet` by `title_translation` or `content_translation`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Handling multilingual fields* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6](8b8138c4-c364-4616-8a81-b2f369cf870b.xhtml)*, Model Administration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding circular dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing Django models, it is very important to avoid circular dependencies
    especially in the `models.py` files. Circular dependencies are imports in different
    Python modules from each other. You should never cross-import from the different
    `models.py` files, because that causes serious stability issues. Instead, if you
    have interdependencies, you should use the actions described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work with `categories` and `ideas` apps to illustrate how to deal with
    cross dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these practices when working with models that use models from other
    apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For foreign keys and many-to-many relationships with models from other apps,
    use the `"<app_label>.<model>"` declaration instead of importing the model. In
    Django this works with `ForeignKey`, `OneToOneField`, and `ManyToManyField`, for
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `settings.AUTH_USER_MODEL` is a setting with a value such as `"auth.User"`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to access a model from another app in a method, import that model
    inside the method instead of at the module level, for example, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use model inheritance, for example, for model mixins, keep the base
    classes in a separate app and place them before other apps that would use them
    in `INSTALLED_APPS`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `ideas` app will use the model mixins from the `core` app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Configuring settings for development, testing, staging, and production
    environments* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Respecting the import order in Python files* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)**,
    Getting Started with Django 3.0**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Changing the foreign key to the many-to-many field* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding database constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For better database integrity, it's common to define database constraints, telling
    some fields to be bound to fields of other database tables, making some fields
    unique or not null. For advanced database constraints, such as making the fields
    unique with a condition or setting specific conditions for the values of some
    fields, Django has special classes: `UniqueConstraint` and `CheckConstraint`.
    In this recipe, you will see a practical example of how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the `ideas` app and the `Idea` model that will have at least `title`
    and `author` fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set the database constraints in the `Meta` class of the `Idea` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define two constraints in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one, `UniqueConstraint`, tells the titles to be unique for each author.
    If the author is not set, the titles can be repeated. To check if the author is
    set we use the negated lookup: `~models.Q(author=None)`. Note that in Django,
    the `~` operator for lookups is equivalent to the `exclude()` method of a QuerySet,
    so these QuerySets are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The second constraint, `CheckConstraint`, checks if the title doesn't start
    and end with a whitespace. For that, we use a regular expression lookup.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database constraints don't affect form validation. They will just raise `django.db.utils.IntegrityError`
    if any data doesn't pass its conditions when saving entries to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to have data validated at the forms, you have to implement the
    validation in addition yourself, for example, in the `clean()` method of the model.
    That would look like this for the `Idea` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*, Forms and Views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using database query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Agile software development, requirements for the project evolve and get updated
    from time to time in the process of development. As development happens iteratively,
    you will have to perform database schema changes along the way. With Django migrations,
    you don't have to change the database tables and fields manually, as most of it
    is done automatically, using the command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activate your virtual environment in the command-line tool, and change the active
    directory to your project's directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the database migrations, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create models in your new `categories` or `ideas` app, you have to
    create an initial migration that will create the database tables for your app.
    This can be done by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time that you want to create all of the tables for your project,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Run this command when you want to execute the new migrations for all of your
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to execute the migrations for a specific app, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you make some changes in the database schema, you will have to create a
    migration for that schema. For example, if we add a new subtitle field to the
    idea model, we can create the migration by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: However, the `--name=subtitle_added` field can be skipped because in most cases
    Django generates fairly self-explanatory default names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may have to add to or change data in the existing schema in
    bulk, which can be done with a data migration, instead of a schema migration.
    To create a data migration that modifies the data in the database table, we can
    use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `--empty` parameter tells Django to create a skeleton data migration, which
    you have to modify to perform the necessary data manipulation before applying
    it. For data migrations, setting the name is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all of the available applied and unapplied migrations, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The applied migrations will be listed with an [X] prefix. The unapplied ones
    will be listed with a [ ] prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all of the available migrations for a specific app, run the same command,
    but pass the app name, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django migrations are instruction files for the database migration mechanism.
    The instruction files inform us about which database tables to create or remove,
    which fields to add or remove, and which data to insert, update, or delete. Also
    they define which migrations are dependent on which other migrations.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of migrations in Django. One is schema migration, and the
    other is data migration. Schema migration should be created when you add new models,
    or add or remove fields. Data migration should be used when you want to fill the
    database with some values or massively delete values from the database. Data migrations
    should be created by using a command in the command-line tool, and then coded
    in the migration file.
  prefs: []
  type: TYPE_NORMAL
- en: The migrations for each app are saved in their `migrations` directories. The
    first migration will usually be called `0001_initial.py`, and the other migrations
    in our example app will be called `0002_subtitle_added.py` and `0003_populate_subtitle.py`.
    Each migration gets a number prefix that is automatically incremented. For each
    migration that is executed, there is an entry that is saved in the `django_migrations`
    database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to migrate back and forth by specifying the number of the migration
    to which we want to migrate, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To unmigrate all migrations of the app including the initial migration, run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Unmigrating requires each migration to have both a forward and a backward action.
    Ideally, the backward action would undo exactly the changes made by the forward
    action. However, in some cases such a change would be unrecoverable, such as when
    the forward action has removed a column from the schema, because it will have
    destroyed data. In such a case, the backward action might restore the schema,
    but the data would remain lost forever, or else there might not be a backward
    action at all.
  prefs: []
  type: TYPE_NORMAL
- en: Do not commit your migrations to version control until you have tested the forward
    and backward migration process and you are sure that they will work well in other
    developments and public website environments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learn more about writing database migrations in the official *How To* guide,
    found at [https://docs.djangoproject.com/en/2.2/howto/writing-migrations/](https://docs.djangoproject.com/en/2.2/howto/writing-migrations/)​.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with a virtual environment* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with Docker containers for Django, Gunicorn, Nginx, and PostgreSQL*
    recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*, Getting Started
    with Django 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Handling project dependencies with pip* receipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Including external dependencies in your project* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Changing a foreign key to the many-to-many field* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a foreign key to the many-to-many field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is a practical example of how to change a many-to-one relation to
    a many-to-many relation, while preserving the already existing data. We will use
    both schema and data migrations in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that you have the `Idea` model, with a foreign key pointing to
    the `Category` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the `Category` model in the `categories` app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `Idea` model in the `ideas` app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and execute initial migrations by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show you how to switch from a foreign key relation
    to a many-to-many relation, while preserving the already existing data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new many-to-many field, called `categories`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and run a schema migration, in order to add the new relationship to
    the database, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a data migration to copy the categories from the foreign key to the
    many-to-many field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the newly created migration file (`0003_copy_categories.py`), and define
    the forward migration instructions, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the new data migration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the foreign key `category` field in the `models.py` file, leaving only
    the new `categories` many-to-many field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and run a schema migration, in order to delete the `Categories` field
    from the database table, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first, we add a new many-to-many field to the `Idea` model, and a migration
    is generated to update the database accordingly. Then, we create a data migration
    that will copy the existing relations from the foreign key `category` to the new
    many-to-many `categories`. Lastly, we remove the foreign key field from the model,
    and update the database once more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our data migration currently includes only the forward action, copying the foreign
  prefs: []
  type: TYPE_NORMAL
- en: key category as the first related item in the new categories relationship. Although
    we did not elaborate here, in a real-world scenario it would be best to include
    the reverse operation as well. This could be accomplished by copying the first
    related item back to the `category` foreign key. Unfortunately, any `Idea` object
    with multiple categories would lose extra data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using migrations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Handling multilingual fields* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with model translation tables* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Avoiding circular dependencies* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
