- en: Chapter 3. Adding Graphics to the Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics are points, lines, or polygons that are drawn on top of your map in
    a layer that is independent of any other data layer associated with a map service.
    Most people associate a graphic object with the symbol that is displayed on a
    map to represent the graphic. However, each graphic in ArcGIS Server can be composed
    of up to four objects, including the geometry of the graphic, the symbology associated
    with the graphic, attributes that describe the graphic, and an info template that
    defines the format of the info window that appears when a graphic is clicked on.
    Although a graphic can be composed of up to four objects, it is not always necessary
    for this to happen. The objects you choose to associate with your graphic will
    be dependent on the needs of the application that you are building. For example,
    in an application that displays GPS coordinates on a map, you may not need to
    associate attributes or display info window for the graphic. However, in most
    cases, you will be defining the geometry and symbology for a graphic.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics are temporary objects stored in a separate layer on the map. They are
    displayed while an application is in use and are removed when the session is complete.
    The separate layer, called the graphics layer, stores all the graphics associated
    with your map. In [Chapter 2](ch02.html "Chapter 2. Creating Maps and Adding Layers"),
    *Creating Maps and Adding Layers*, we discussed the various types of layers, including
    dynamic map service layers and tiled map service layers. Just as with the other
    types of layers, `GraphicsLayer` also inherits from the `Layer` class. Therefore,
    all the properties, methods, and events found in the `Layer` class will also be
    present in `GraphicsLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics are displayed on top of any other layers that are present in your application.
    An example of point and polygon graphics is provided in the following screenshot.
    These graphics can be created by users or drawn by the application in response
    to the tasks that have been submitted. For example, a business analysis application
    might provide a tool that allows the user to draw a freehand polygon to represent
    a potential trade area.
  prefs: []
  type: TYPE_NORMAL
- en: The polygon graphic would be displayed on top of the map, and could then be
    used as an input to a geoprocessing task that pulls demographic information pertaining
    to the potential trade area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Graphics to the Map](graphics/7965_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many ArcGIS Server tasks return their results as graphics. The `QueryTask` object
    can perform both attribute and spatial queries. The results of a query are then
    returned to the application in the form of a `FeatureSet` object, which is simply
    an array of features. You can then access each of these features as graphics and
    plot them on the map using a looping structure. Perhaps you'd like to find and
    display all land parcels that intersect the 100 year flood plain. A `QueryTask`
    object could perform the spatial query and then return the results to your application,
    where they would then be displayed as polygon graphics on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The four parts of a graphic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating geometry for graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolizing graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning attributes to graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying graphic attributes in an info window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding graphics to the graphics layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The four parts of a graphic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A graphic is composed of four items: **Geometry**, **Symbol**, **Attributes**,
    and **InfoTemplate**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The four parts of a graphic](graphics/7965_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A graphic has a geometric representation that describes where it is located.
    The geometry, along with a symbol, defines how the graphic is displayed. A graphic
    can also have attributes that provide descriptive information about the graphic.
    Attributes are defined as a set of name-value pairs. For example, a graphic depicting
    a wildfire location could have attributes that describe the name of the fire along
    with the number of acres burned. The info template defines what attributes should
    be displayed in the info window that appears when the graphic appears, along with
    how they should be displayed. After their creation, the graphic objects must be
    stored inside a `GraphicsLayer` object, before they can be displayed on the map.
    This `GraphicsLayer` object functions as a container for all the graphics that
    will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: All the elements of a graphic are optional. However, the geometry and symbology
    of a graphic are almost always assigned. Without these two items, there would
    be nothing to display on the map, and there isn't much point in having a graphic
    unless you're going to display it.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the typical process of creating a graphic and adding
    it to the graphics layer. In this case, we are applying the geometry of the graphic
    as well as a symbol to depict the graphic. However, we haven't specifically assigned
    attributes or an info template to this graphic.
  prefs: []
  type: TYPE_NORMAL
- en: '![The four parts of a graphic](graphics/7965_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating geometry for graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics will almost always have a geometry component, which is necessary for
    their placement on the map. These geometry objects can be points, multipoints,
    polylines, polygons, or extents and can be created programmatically through a
    constructor for these objects or can be returned as an output from a task such
    as a query.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating any of these geometry types, the `esri/geometry` resource needs
    to be imported. This geometry resource contains classes for `Geometry`, `Point`,
    `Multipoint`, `Polyline`, `Polygon`, and `Extent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Geometry` is the base class that is inherited by `Point`, `MultiPoint`, `Polyline`,
    `Polygon`, and `Extent`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from the following code line, the `Point` class defines a location
    by an X and Y coordinate, and can be defined in either map units or screen units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Symbolizing graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each graphic that you create can be symbolized through one of the various symbol
    classes found in the API. Point graphics are symbolized by the `SimpleMarkerSymbol`
    class and the available shapes include circle, cross, diamond, square, and X.
    It is also possible to symbolize your points through the `PictureMarkerSymbol`
    class, which uses an image to display the graphic. Linear features are symbolized
    through the `SimpleLineSymbol` class and can include solid lines, dashes, dots,
    or a combination. Polygons are symbolized through the `SimpleFillSymbol` class
    and can be solid, transparent, or crosshatch. In the event that you'd prefer to
    use an image in a repeated pattern for your polygons, the `PictureFillSymbol`
    class is available. Text can also be added to the graphics layer and is symbolized
    through the `TextSymbol` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Points or multipoints can be symbolized through the `SimpleMarkerSymbol` class,
    which has various properties that can be set, including style, size, outline,
    and color. Style is set through the `SimpleMarkerSymbol.setStyle()` method that
    takes one of the following constants, which corresponds to the type of symbol
    that is drawn (circle, cross, diamond, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '`STYLE_CIRCLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_CROSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_DIAMOND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_PATH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_SQUARE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STYLE_X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Point graphics can also have an outline color, which is created through the
    `SimpleLineSymbol` class. The size and color of the graphics can also be set.
    Examine the following code example to get an idea on how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Symbolizing graphics](graphics/7965_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Linear features are symbolized with the `SimpleLineSymbol` class and can be
    a solid line or a combination of dots and dashes. Other properties include color,
    as defined with `dojo/Color`, and a width property `setWidth` to set the thickness
    of your line. The following code example explains the process in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is obtained when the preceding code is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolizing graphics](graphics/7965_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Polygons are symbolized through the `SimpleFillSymbol` class, which allows
    the drawing of polygons in solid, transparent, or crosshatch patterns. Polygons
    can also have an outline specified by a `SimpleLineSymbol` object. The following
    code example explains the process in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is obtained when the preceding code is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolizing graphics](graphics/7965_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assigning attributes to graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The attributes of a graphic are the name-value pairs that describe that object.
    In many cases, graphics are generated as the result of a task operation such as
    `QueryTask`. In such cases, each graphic is composed of both geometry and attributes,
    and you would then need to symbolize each graphic accordingly. The field attributes
    associated with the layer become the attributes for the graphic. In some cases,
    the attributes can be limited through properties such as `outFields`. If your
    graphics are being created programmatically, you will need to assign the attributes
    in your code using the `Graphic.setAttributes()` method as seen in the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Displaying graphic attributes in an info template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to attributes, a graphic can also have an info template that defines
    how the attribute data is displayed in a pop-up window. A point attribute variable
    has been defined in the following code example and contains key-value pairs. In
    this particular case, we have keys that include the address, city, and state.
    Each of these names or keys has a value. This variable is the third parameter
    in the constructor for a new point graphic. An info template defines the format
    of the pop-up window that appears, and contains a title and an optional content
    template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying graphic attributes in an info template](graphics/7965_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have defined the geometry, symbology, and attributes for your graphic,
    a new graphic object can be created with these parameters used as an input to
    the constructor for the `Graphic` object. In the following code example, we will
    create variables for the geometry (`pointESRI`), symbology (`markerSymbol`), point
    attributes (`pointAttributes`), and info template (`pointInfoTemplate`), and then
    apply these variables as an input to the constructor for our new graphic called
    `pointGraphic`. Finally, this graphic is added to the graphics layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding graphics to the graphics layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before any of your graphics are displayed on the map, you must add them to the
    graphics layer. Each map has a graphics layer, which contains an array of graphics
    that is initially empty until you add the graphics. This layer can contain any
    type of graphic object. This means that you can mix-in points, lines, and polygons
    at the same time. Graphics are added to the layer through the `add()` method and
    can also be removed individually through the `remove()` method. In the event that
    you need to remove all the graphics simultaneously, the `clear()` method can be
    used. The graphics layer also has a number of events that can be registered, including
    `click`, `mouse-down`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple graphics layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple graphics layers are supported by the API, making it much easier to
    organize different types of graphics. Layers can be easily removed or added, as
    required. For example, you can put polygon graphics that represent counties in
    one graphics layer and point graphics that represent traffic incidents in another
    graphics layer. Then you can easily add or remove either layer as required.
  prefs: []
  type: TYPE_NORMAL
- en: Time to practice with graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to create and display graphics on a map.
    We are going to create a thematic map, that shows population density by county
    for the state of Colorado. You will also be introduced to query tasks. As you
    will learn in a later chapter, tasks can be executed in ArcGIS Server and include
    things such as spatial and attribute queries, identification of features, and
    geocoding. Finally, you will learn how to attach attributes to your graphic features
    and display them in an info window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the JavaScript Sandbox at [http://developers.arcgis.com/en/javascript/sandbox/sandbox.html](http://developers.arcgis.com/en/javascript/sandbox/sandbox.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the JavaScript content from the `<script>` tag that I have highlighted
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Create the variables that you'll use in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `require()` function as seen in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We covered the `esri/map` resource in a past exercise, so no additional explanation
    should be necessary. The `esri/tasks/query` and `esri/tasks/QueryTask` resources
    are new and we won't cover them until a later chapter. However, in order to complete
    this exercise, it is necessary for me to introduce these to you at this point.
    These resources enable you to perform spatial and attribute queries on a data
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `require()` function, you will need to create a `Map` object and
    add a `basemap: streets` layer by adding the following highlighted code. You will
    set the initial map extent to display the state of Colorado:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `require()` function, just below the code block that creates the
    `Map` object, add the highlighted line of code to create a new polygon symbol
    that is transparent. This creates a new `SimpleFillSymbol` object and assigns
    it to the `defPopSymbol` variable. We use RGB values of `255,255,255,and 0` to
    ensure that the filled color will be completely transparent. This is accomplished
    through the value `0`, which ensures that our coloring will be fully transparent.
    Later, we will add additional symbol objects so that we can display a color-coded
    map of county population density. For now though, we simply want to create a symbol
    so that you can understand the basic procedure of creating and displaying graphics
    on a map. The following code explains the process in detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, you are going to get a preview of how the `Query` task can
    be used in an application. We'll cover this task in detail in a later chapter
    but for now, here is an introduction. The `Query` task can be used to perform
    spatial and attribute queries on a data layer in a map service. In this exercise,
    we are going to use a `Query` task to perform an attribute query against a county
    boundary layer provided through an ESRI service.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first examine the map service and layer that we will use in our query.
    Open a web browser and go to [http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer](http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer).
    This map service provides census information for U.S. states and counties and
    also includes a highway layer. In this exercise, we are interested in the county
    layer that has an index number of two. Click on the **counties** option to get
    detailed information about this layer. There are a lot of fields in this layer,
    but we are really only interested in the field that will allow us to query by
    state name and the field that gives us information on the population density.
    The `STATE_NAME` field gives us the state name of each county and the `POP90_SQMI`
    field gives us the population density of each county.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to the Sandbox. Below the line of code where we created our symbol,
    initialize a new `QueryTask` object by adding the following line of code just
    below the line that created the `defPopSymbol` variable. What this line does is
    create a new `QueryTask` object that points to the `ESRI_StateCityHighway_USA`
    map service that we just examined in our browser and specifically points to layer
    index `2`, which is our county layer. The following code explains the process
    in detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All `QueryTask` objects need input parameters so that they know what to execute
    against the layer. This is accomplished through a `Query` object. Add the following
    line of code right below the line you just entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will define some of the properties on our new `Query` object that will
    enable us to perform an attribute query. Add the following three highlighted lines
    of code just below the line that created the `query` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `where` property is used to create a SQL statement that will be executed
    against the layer. In this case, we're stating that we'd like to return only those
    county records that have a state name of `Colorado`. Setting the `returnGeometry`
    property to `true` indicates that we would like ArcGIS Server to return the geometric
    definition of all the features that matched our query. This is necessary because
    we need to plot these features as graphics on top of the map. Finally, the `outFields`
    property is used to define which fields we would like to be returned along with
    the geometry. This information will be used later when we create the color-coded
    map of a county's population density.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will use the `execute` method on `queryTask` to perform the query
    against the layer that we have indicated (counties), using the parameters defined
    on our `query` object. Add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In addition to passing the `query` object into ArcGIS Server, we have also indicated
    that `addPolysToMap` will serve as the callback function. This function will be
    executed after ArcGIS Server has performed the query and returned the results.
    It is up to the `addPolysToMap` function to plot the records using the `featureSet`
    object returned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned in the previous step, the callback function `addPolysToMap`
    will be executed when ArcGIS Server returns the `featureSet` object, which contains
    the records that matched our attribute query. Before creating the callback function,
    let''s first discuss what the code will accomplish. The `addPolysToMap` function
    will take a single parameter `featureSet`. When a `queryTask` object is executed,
    ArcGIS Server returns a `featureSet` object to your code. A `featureSet` object
    contains the graphic objects returned by the query. Inside the `addPolysToMap`
    function, you will see the line `var features = featureSet.features;`. The `features`
    property returns an array with all the graphics contained within it. After defining
    a new feature variable, we create a `for` loop that we will use to loop through
    each of these graphics and plot the graphics to the map. Create the callback function
    by adding the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned earlier, you have to add each graphic that you create to the
    `GraphicsLayer` object. This is done through the `add()` method as you saw in
    the preceding code block. You will also notice that we are attaching the symbol
    we created earlier to each of the graphics (county boundaries).
  prefs: []
  type: TYPE_NORMAL
- en: Execute the code by clicking on the **Run** button and you should see the following
    screenshot as the output if everything has been coded correctly. Notice that each
    of the counties has been outlined with the symbol that we defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time to practice with graphics](graphics/7965_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we are going to add additional code to the application that will color-code
    each of the counties based on population. Comment out the `defPopSymbol` variable
    inside the `require()` function and add five new symbols as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing here is basically creating a color ramp of symbols that will
    be assigned to each county, based on the population density. We are also applying
    a transparency value of .85 to each symbol so that we will be able to see through
    each of the counties. This will enable us to see the base map placed below the
    layer that contains the city names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that earlier in the exercise, we created `queryTask` and `Query` objects
    and defined an `outFields` property on `Query` to return the `POP90_SQMI` field.
    This will now come into play as we will use the values returned in this field
    to determine the symbol applied to each county based on the population density
    of that county. Update the `addPolysToMap` function to appear as seen in the following
    code block, and then we will discuss what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What we have done with the preceding code block is obtain the population density
    information from each graphic and save it to a variable called `pop`. An `if/else`
    code block is then used to assign a symbol to the graphic, based on the population
    density of that county. For example, a county with a population density (as defined
    in the `POP90_SQMI` field) of `400` would be assigned the symbol defined by `fourPopSymbol`.
    Because we are in a `for` loop that examines every county in Colorado, each county
    graphic will be assigned a symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the code by clicking on the **Run** button and you should see the following
    screenshot as the output if everything has been coded correctly. Notice that each
    of the counties has been color-coded with one of the symbols that we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time to practice with graphics](graphics/7965_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you will learn how to attach attributes to a graphic and display them in
    an info window when the graphic is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'An info window is an HTML pop-up window that gets displayed when you click
    on a graphic. Normally, it contains the attributes of the clicked graphic but
    it can also contain custom content that you specify as a developer. The content
    of these windows is specified through an `InfoTemplate` object that specifies
    a title for the window and the content to be displayed in the window. The easiest
    way to create an `InfoTemplate` object is to use a wildcard for the content that
    will automatically insert all the fields of a dataset into the info window. We
    are going to add some additional output fields so that more content can be displayed
    in the info window. Alter the `query.outFields` line to include the fields highlighted
    in the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following line of code just below the `queryTask.execute` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter passed into the constructor (`"County Attributes"`) is the
    title for the window. The second parameter is a wildcard indicating that all the
    name-value pairs of the attribute should be printed in the window. Therefore,
    the new fields that we added to `query.outFields` should all be included in the
    info window when a graphic is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use the `Graphic.setInfoTemplate()` method to assign the newly
    created `InfoTemplate` object to a graphic. Alter your `if/else` statement by
    adding the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code by clicking on the **Run** button. Click on any of the counties
    in the map and you should see an info window similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time to practice with graphics](graphics/7965_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can view the solution code for this exercise in the `graphicexercise.html`
    file of your `ArcGISJavaScriptAPI` folder to verify that your code has been written
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that graphics are often used to represent information
    that is generated as the result of actions performed within a working application.
    Frequently, these graphics are returned as the result of a task that has been
    performed, such as an attribute or spatial query. This can include points, lines,
    polygon, and text. These are temporary objects, only displayed during the current
    browser session. Each graphic can be composed of geometry, symbology, attributes,
    and an info template, and is added to the map through the use of a graphics layer,
    which is always the topmost layer in an application. This ensures that the contents
    of the layer will always be visible. In the next chapter, we'll introduce you
    to the feature layer, which can do everything that a graphics layer can do and
    more!
  prefs: []
  type: TYPE_NORMAL
