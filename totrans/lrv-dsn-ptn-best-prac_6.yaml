- en: Chapter 6. Best Practices in Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see examples of various previously-described design
    patterns used in Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be discussed in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic and advanced practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-life examples of design patterns used in Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reasons why these design patterns are used in the examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, when you are working on an application, there should be a systematic
    order to things to prevent confusion and allow flexibility. For example, in an
    MVC architecture, Controller should only hold the logic and Model should only
    hold dataflow-related stuff. You should not write database queries in View files.
    This way, anyone working on the project can find what they are looking for easily
    and can change, fork, or improve it with greater ease. If this is not followed,
    the project will turn into a mess as it gets bigger and bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic good practice would be to avoid repeating yourself. If you''re using
    a code snippet or a condition a number of times, it''d be better for you to prepare
    a method or a scope for that action. This way, you wouldn''t have to repeat yourself
    over and over. For example, let''s say we have an imaginary Controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `where()` condition checks if `active` is repeated twice.
    In real-world examples, it would be used even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this, in Laravel, you can use query scopes. Query scopes are single
    functions that help you reuse the logic in Models. Let''s define a query scope
    in Model and change the Controller method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've defined a method called `scopeActive()` in Model, which
    is prefixed with the word `scope` and CamelCased. This way, Laravel can understand
    that it's a query scope, and you can use that scope directly. As you can see,
    the conditions in the Controller have also changed. They have changed from `where('active',
    1)` to `active()` .
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are advanced practices and can be used to keep the code tidy
    and systematic using various approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will see various design patterns' usage in Laravel. If
    you test the custom classes that include the design patterns, which are provided
    within the book, they should be autoloaded in your application. This can be done
    either by adding them to the `ClassLoader::addDirectories()` array of the `global.php`
    file (which can be found by navigating to `app/start` ) or the `start.php` file
    in the `bootstrap` folder. Alternatively, we can add a `psr-0` autoload in `composer.json`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To add directories from `app/start/global.php` , first find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add your folders below. The resulting code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to autoload classes or files from the `composer.json` file using
    the `psr-0` autoload, you have to add the namespace and directory into `composer.json`
    . The key will be the namespace and the value will be the path of the folder that
    holds the files and classes to be autoloaded. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if our `composer.json` file doesn't have a `psr-0` object,
    first we'll create it and then add the namespace and the path values inside. You
    can see we have a namespace called `Acme` , which is under the folder `app/lib`
    .
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to autoload a whole folder but only a few single files, you
    can also use the `files` object in `composer.json` . It's a single object that
    only holds the paths of files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding these values, you need to dump the autoload files and make Laravel
    understand them. To do this, after editing the `composer.json` file, simply run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run the following command if the composer is not installed in
    your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After this, the classes or files that you've just added will be autoloaded and
    available for your project.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might recollect from [Chapter 5](text00032.html#page "Chapter 5. Design
    Patterns in Laravel") , *Design Patterns in Laravel* , the Factory pattern is
    based on creating template method objects to implement an algorithm. Let''s assume
    we are developing the following application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Factory pattern](Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s assume the **Toyota** brand only produces C-class red cars, and the
    **Suzuki** brand only produces B-class green cars. Let''s assume we have a Model
    for this purpose that is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in this approach, the same `carFactory()` class is called for
    both `Suzuki` and `Toyota` because in this example both brands would have the
    same processes to create the core of the car. The quality-class and color are
    set after the core of the car is produced. After this is set, for the color and
    quality-class choices, we can directly call the corresponding class with its brand.
    Let''s say we are going to buy a B-class car. Now, because the code knows which
    brand produces B-class cars, it will directly call `Suzuki` . This Model can have
    a Controller like the one seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The three different routes of this approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In such situations, in addition to the Factory pattern, having an approach like
    these three routes would be a good practice for URL richness, ease of use, and
    improved search engine optimization of the website.
  prefs: []
  type: TYPE_NORMAL
- en: The Builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed in [Chapter 5](text00032.html#page "Chapter 5. Design Patterns
    in Laravel") , *Design Patterns in Laravel* , that, in a way, the Builder pattern
    is an approach to separate bigger objects into smaller ones and make them available
    for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this subsection, as in the example in [Chapter 5](text00032.html#page "Chapter 5. Design
    Patterns in Laravel") , *Design Patterns in Laravel* , let''s assume we are baking
    a pizza that has certain properties, such as Italian and small/big:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Builder pattern](Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s assume we have an autoloaded class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have injected a builder, the `PizzaBuilder` class, which
    includes two chefs: one is an Italian pizza maker and the other is an Asian pizza
    maker. The `PizzaBuilder` class in this approach can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it holds all the basic stuff to bake a pizza, but the properties
    are defined outside the class, through the Model using methods such as `setType()`
    and `setSize()` . With this approach, by only defining the properties and without
    thinking about the rest, we can build and get our pizza directly from the waiter
    (`PizzaDelivery` ). If we need to get an Asian pizza, we''d call the following
    code anywhere in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might recall from [Chapter 5](text00032.html#page "Chapter 5. Design
    Patterns in Laravel") , *Design Patterns in Laravel* , the Strategy pattern is
    used to divide the logic into smaller parts according to their tasks so that these
    parts can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sample application we''ll code for this approach, we will make a package
    shipment calculation application for different package carriers. Let''s assume
    we have a class like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code, in the `Shipping` class, we have injected `ShippingPriceStrategy`
    . This Strategy pattern has features for each carrier (`shipmentPrice()` in our
    case). With this approach, for different shipping carriers, we can show different
    delivery prices and include them in our shipping process, which will be defined
    in our `Shipping` class. This way, we've used the prices set in the Strategy pattern
    both when showing the shipping price and counting a sum total for the shipping
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'By assuming that the class is autoloaded, we can use the class that has the
    Strategy pattern in an example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for the same shipping process (the `Shipping` class), by injecting
    different shipping strategies for the two brands, we've managed to gain different
    shipping prices due to the difference in their strategies.
  prefs: []
  type: TYPE_NORMAL
- en: The Repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason to use a Repository pattern is to provide abstraction and flexibility.
    For example, let's say you are fetching a product from the database. By default,
    in Laravel, the usual way is to use Eloquent ORM in Controller and to pass it
    to the View. This way, your Controller knows that you are using Eloquent ORM to
    fetch data from the data source / database. For small applications, this should
    be no problem, but in bigger applications, an issue might occur. In future, for
    some reason, you might want to drop MySQL using Eloquent ORM and might need to
    use another ORM in MongoDB. When this happens, because the Controller knows that
    you are using Eloquent ORM, you'll have to dig each Controller (or any other layer)
    one by one and change them. Another limitation is that you cannot unit test this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This would not happen if you had used repositories. If you do this, the Controller
    would connect only with the repository, and the repository would handle the other
    regarding layers. Therefore, the Controller wouldn't know how the data was fetched
    (abstraction). This way, on bigger applications, managing stuff or testing stuff
    should be much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this approach, first let''s assume we have the `ProductsController`
    and `Product` models, and we want to fetch a product with a given ID and another
    method to dump all products. The Controller would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is a flaw in this approach. If you are testing code that is written like
    this and there is an error, you can't directly detect what the source of the error
    is unless `Whoops` (the error handler library used in Laravel) is active. Repositories
    are helpful in situations like this because they extract the logic. To inject
    a repository, one way is to define and set it in a constructor method of the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s name this repository `EloquentProductRepository` , which is part of
    the `\Acme\Repositories` namespace. Our Controller would change into something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that instead of making `orderBy(''id'', ''desc'')->get()` , we have given
    a new method name, `getNewest()` . Now let''s create this repository. Let''s assume
    we have a file called `EloquentProductRepository.php` inside the `namespace Acme\Repositories`
    folder. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For each method that is used, you need to define functions once you are in the
    repositories. A major advantage of this approach is that it brings flexibility.
    Let's say you will be using mocks, or you'll switch from Eloquent ORM to another
    one in future that has totally different method names. To switch your application's
    database layer from Eloquent to MongoDB, if you've used repositories, you only
    need to change the used repository in your Controllers, nothing else. You won't
    need to dig all of your Controllers, Models, or other components.
  prefs: []
  type: TYPE_NORMAL
- en: There is still a feature lacking here. Our Controller still knows that we are
    using an Eloquent-specific repository. For a better approach and abstraction,
    our Controller should not know what kind of repository we are using. To ensure
    this, we will have to code an interface for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create an interface in the same namespace path (it is not forced;
    you may create it anywhere as long as it''s loaded) as `ProductInterface` . Our
    Controller would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the repository, the interface is injected and used. Now let''s code
    the `ProductInterface` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the interface holds the method names, which are actually the
    methods available to the implemented repository. Now let''s implement this interface
    to our repository to connect them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This implementation has an advantage. Let's assume that you've implemented an
    interface in the repository and it is missing the `getNewest()` custom method.
    Thanks to this implementation, the interface will directly let you know that it
    needs that specific method and it's missing.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to bind the interface to the repository. One of the ways to
    do this is to use Laravel's built-in `App:bind();` method. To bind the repository
    that we've just created to the interface, add this line into your `app/routes.php`
    file or any other file that's autoloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to bind these two is to create a service provider. Let''s write
    a service provider as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've assumed that this provider is in the `namespace Acme\Repositories` folder.
    We've also used `Illuminate\Support\ServiceProvider` to extend our class from
    it. In the public method register, we've binded the interface to our product repository.
  prefs: []
  type: TYPE_NORMAL
- en: In future, if you want to switch to MongoDB or any other interface that you've
    coded, all you have to do is switch `EloquentRepositoryInterface` to the new one.
    It will be updated everywhere in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw examples of basic and advanced practices of design patterns
    and architectures that are used both in Laravel and in general development processes.
    We have learned the advantages of various design patterns while citing real-world
    examples for each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are there to make your life easier. If development is done without
    following any pattern or architecture, as the application grows, both refactoring
    and implementing features would be harder after each refactoring. Also, if another
    developer joins the project, he or she first needs to understand what's where.
    This will possibly cause bloating, bad performance, inflexibility, and a variety
    of errors that are hard to fix. The application would be a time-bomb ready to
    explode. Design and architectural patterns are there to help you prevent these
    issues. Not only in your Laravel application, but in anything that you're developing,
    as the application grows, to keep everything under control, you must use a design
    pattern or a combination of them. In the end, there will be a day you'll thank
    yourself for using these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
