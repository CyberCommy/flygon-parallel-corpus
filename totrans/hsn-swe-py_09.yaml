- en: Testing Business Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the core business objects have been defined and tested, they can be used
    in other packages as foundations for classes to provide concrete class functionality.
    There are at least two advantages to taking this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: The core classes keep all of the code that deals with data types, data structure,
    and data validation in a single place, which reduces the complexity of the other
    code bases that rely upon them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once unit tests have been created that pass for the core objects, none of the
    functionality that they provide will have to be tested elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those tests, written so that they can be executed on demand, can be integrated
    into a final build process, providing a complete set of regression tests that
    ensure that changes made in the future don't break existing functionality before
    executing a build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of building out those unit tests, using the test extensions noted
    earlier, while not difficult, will be time consuming at first. The entire process
    will be examined in this chapter, establishing some testing patterns that we'll
    reuse in later chapters, before integrating them into the package build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing business objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution and installation considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality assurance and acceptance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation/use, maintenance, and decommissioning considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the unit testing process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the standard unit testing structure/framework that we defined in the
    chapter before last allows us to start the unit testing of any code base very
    quickly and easily. It also lends itself well to an iterative test development
    process. The starting point test module, once the configuration items have been
    set within it by the couple of search and replace operations, immediately starts
    reporting on what test cases and methods are reporting. Our initial test module
    is little more than the following (with some comments removed to keep the listing
    short):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the test module yields the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fdda75b1-6beb-4c27-b077-a5e6635de534.png)'
  prefs: []
  type: TYPE_IMG
- en: That test run output informs us, then, that we need to generate test case classes
    for each of the six classes defined in the module being tested; specifically,
    we need to create `testAddress`, `testBaseArtisan`, `testBaseCustomer`, `testBaseOrder`, `testBaseProduct`,
    and `testHasProducts` test case classes. 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those should, in order to leverage the property and method coverage
    tests that the standard unit testing structure provides, be decorated with the `AddMethodTesting` and `AddPropertyTesting` decorators
    that `testhms_coreCodeCoverage` provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once those are in place, rerunning the test module will generate a (long!)
    list of items that need to be addressed before the test policy tests will pass. The
    full list of requirements was long enough that including it in the book directly
    would''ve just ended up with 2-3 pages of a bulleted list. The full results, however,
    are included in the `hms_core` code base, in `miscellany/initial-test-run.txt`.
    The entire initial output was far too long to reproduce in its entirety here,
    but the start and end of the output is reproduced as follows, and specifies a
    total of 105 test methods that need to be implemented across the six test case
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b23808a-ce7e-43e8-bae3-fb0017a96bf4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From that point on, the test writing process is just a matter of repeating
    the following cycle until all tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick a missing test method or set of test methods that need to be written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the test method(s) to the applicable test case class, set up to fail because
    they aren't implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the test module to verify that the tests fail as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each test method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write real test code in the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the test module and ensure that the only failure in that method is the
    explicit one added, correcting any issues that arise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the explicit failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with the guidance that is provided by the standard unit testing process,
    there is no denying that writing out all of the unit tests for a module, even
    one as relatively short as `hms_core`, can be incredibly tedious. There are a
    few things that can be done to make the process go at least somewhat faster, though—especially
    since we know that there are some common value types and formats that we're expecting.
    We'll start by writing out tests for the `Address` class, which has one of the
    largest collections of properties that we're going to be dealing with. As many
    of those tests get built out, some common (and re usable) test values will start
    to surface.
  prefs: []
  type: TYPE_NORMAL
- en: This run through of the unit testing process will also yield a test case class
    template file (`test-case-class.py`) that will be included in the book's code
    in the code templates directory.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing the Address class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Address` class tests initially report that the following test methods
    need to be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods:** `test__init__`, `test_del_building_address`, `test_del_city`, `test_del_country`, `test_del_postal_code`, `test_del_region`, `test_del_street_address`, `test_get_building_address`, `test_get_city`, `test_get_country`, `test_get_postal_code`, `test_get_region`, `test_get_street_address`, `test_set_building_address`, `test_set_city`, `test_set_country`, `test_set_postal_code`, `test_set_region`, `test_set_street_address`,
    and `test_standard_address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties:** `testbuilding_address`, `testcity`, `testcountry`, `testpostal_code`, `testregion`,
    and `teststreet_address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The primary concern of the test methods for the properties of the class being
    tested are, arguably, to make sure that the properties use the appropriate methods
    for their getter, setter, and deleter functionalities. If that is established
    as being correct, then the actual processes for handling the properties and their
    values can be tested solely in the test methods for those methods. With that in
    mind, the bulk of the property tests for `Address` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By switching the templated `property_name` in that code block out for the actual property
    name, the individual property tests can be created quite quickly, for example,
    implementing `testbuilding_address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter and deleter method tests will usually also be quite simple—all they
    need to do, ultimately, is ensure that they are retrieving data from the correct
    internal storage attribute and setting the value of that attribute to the expected
    default value, respectively. The `test_del_building_address` test method serves
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that in order to test the deleter method (as well as the getter
    and setter methods later on), we actually have to create an instance of the object
    being tested—that's what the third line of the test method is doing (`test_object
    = Address…`). Once that instance is created, if the property whose deleter method
    is being tested isn't required or supplied as part of that test object's creation,
    we can (and should) also test the default/deleted value of the instance. Even
    if there is a value supplied for the test object, testing the deletion process
    by setting a value in the underlying storage attribute, calling the deleter method,
    and verifying the results afterwards will remain constant in almost all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the corresponding getter method is going to be similar; again, all
    it really has to do is provide that the property is retrieving data from the correct
    storage attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's often useful to set `expected` and `actual` values that can be passed to
    the core assertion of the test, particularly if retrieving those values involves
    using a method or function. It won't make a functional difference, but it can
    be a lot easier to read later on, and keeping things easily understood and readable
    is, if anything, more important than keeping the code being tested readable and
    understandable—test code is a quality assurance effort, after all, and would not
    be well served by having errors creep in because of a cryptic structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth noting that the test methods for `city` and `street_address` properties
    vary slightly, because they are both properties that are set during the creation
    of an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that since the test object being created is expected to provide
    a value because it was initialized with one, we're setting up the expected value
    to test against before the test object is created, creating it using that expected value,
    then testing to ensure that the deleter doesn't delete that initially set value
    during object creation. The test that it does getting deleted when explicitly
    told to is essentially the same, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the getter and deleter method tests have been established using
    those patterns, the test module run starts to show progress. One of the 29 tests
    being run (and that is one of the failures) is the code coverage test that is
    picking up the missing test case classes for `BaseArtisan` and the other `hms_core` classes,
    which have been commented out to make working with the results output of the `testAddress` test
    methods easier. Of the remaining eight failures, six are the setter method tests
    for `testAddress`, which we''ll implement next, and the other two are `test__init__` and `teststandard_address`,
    which we''ll look at last:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7ceabc3-6f66-44b3-a371-19e7187bb245.png)'
  prefs: []
  type: TYPE_IMG
- en: The test methods corresponding to the getter and deleter methods are simple
    because the methods being tested are, themselves, quite simple. They (thus far)
    make no decisions, and neither do they do any manipulation of the values themselves;
    they simply return the current value, or replace it without having to make any
    decisions about what it's being replaced with. On top of that, they also have
    no arguments to contend with.
  prefs: []
  type: TYPE_NORMAL
- en: The setter methods are more complicated; they will make decisions, will have
    arguments (if only one), and might be expected to behave differently depending
    on the types and values of those arguments. Their corresponding test methods,
    then, might be expected to be more complex too as a result, and that expectation
    would be well founded. Test complexity will grow as the complexity of the input
    grows for well designed tests, because those tests must check all of the logical
    variants of the input. That will start to become apparent as we test the setter
    methods of our properties, starting with `Address.building_address` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well designed unit tests need to do several things, not all of which may be
    obvious at first. The most obvious item is probably testing all of the happy path
    input possibilities: inputs that are of expected types and with expected and valid
    values, which should execute without errors and yield the expected results, whatever
    those results may be. Less obviously perhaps, unit tests should also test with
    a representative sample set of known bad values—values that are expected to raise
    errors and prevent the process being tested from completing with erroneous data.
    Let''s take another look at the `_set_building_address` method of `Address` with
    that in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The good values that can be reasonably tested include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`None`—If `None` is passed as the value, then it simply passes through and
    is set in the inner storage attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any single line, non-empty string that doesn't contain tabs or other whitespace
    characters other than spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Viable bad values would include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any value that isn't a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string that contains any line breaking characters, or any whitespace that
    isn't a space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string that is nothing but space characters; this item is less obvious, but
    the code will raise a `ValueError` because such an input would be caught by the
    `if not value.strip()` that's part of the value checking code. The results of
    a `.strip()` called against a string that is nothing but whitespace is an empty
    string, and that would evaluate as `False` (-ish), thus raising the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_set_building_address` method doesn't try to do any content validation,
    so we don't currently have to worry about that; we're implicitly assuming that
    if someone took the effort to enter a well formed `building_address` value then
    the value entered is going to be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, the `business_address` property was classified as a standard optional
    text line property. If that classification holds true, then it would be both possible
    and advantageous to generate a single list of good standard optional text line
    property values, so that those values can be reused for all of the property tests
    that they''d logically apply to. That list, set up as a constant in the test module,
    might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the good values in `test_set_business_address` then becomes a simple
    matter of iterating over that list of values, calling the setter method, and asserting
    that the results of the getter method after the value''s been set match the expected
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It would also be valid to perform the assertion against the property instead
    of the getter method, since we've tested that the property is associated with
    the getter method elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'A corresponding bad values list would have to include all of the bad items
    listed previously, and would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding bad value tests are a similar iteration to the good value
    iteration shown previously, except that they will specifically look for cases
    where the execution is expected to fail, and fail if those don''t happen or happen
    in an unexpected fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This test process, by using the `try` … `except` blocks, will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly fail if the setter method allows a bad value to be set without raising
    an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass if a bad value raises an expected error (`TypeError` or `ValueError` in
    most cases) while trying to set a bad value in the test object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail if any error other than the two types expected is raised by the setter
    method during execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This same test method structure can be used for all of the `Address` properties
    that are also standard optional text line values/types with no more effort than
    changing the setter method names. Basically, all of the property setters of an `Address`, except
    the ones for `city` and `street_address`, which are standard required text line
    items, are identical, except for those names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference between the optional and required text line properties,
    though, is that optional items can allow `None` as a valid argument, while required
    ones cannot. If we create separate test value lists that account for those differences,
    and change which list the test method is using, the same structure, just with
    different good and bad values, will still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of the setter method tests in place, rerunning the test module shows
    that there are only three tests failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/edd082df-d88b-4ac3-bd39-5d47d0818650.png)'
  prefs: []
  type: TYPE_IMG
- en: Discounting the coverage test for the other test case classes, that leaves only
    the `__init__` and `standard_address` methods to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the `__init__` method is not going to be difficult. All it really needs
    to establish is that the initialization process that is part of creating a new
    object instance is calling the various property setters in an appropriate fashion.
    Other tests have already established that the properties connect to their intended
    getter/setter/deleter methods, and that those methods are doing what they''re
    supposed to. Since we have predefined lists of good values that we can iterate
    over, it''s a simple matter to set up a (large) set of nested loops to check all the
    possible combinations of those values as they apply to each property. The nesting
    level of the loops gets pretty deep (enough so that the following code is indented
    only two spaces per line in order to fit on the page), but it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The same approach works just as well in implementing `teststandard_address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That, then, completes the tests for the `Address` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8386b3e-09ed-4860-a4fd-a8cfb1a261fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The balance of the unit testing process for the module really consists of reactivating
    the other test case classes, creating the baseline failing test methods for all
    of them and then just running the test module and writing and correcting tests,
    as noted earlier. Because of the way that the test process executes, the output
    generated will be for each test method of each test case class, in alphabetical
    order. So, the test case class for `HasProducts` will execute last, and within,
    that the `testproducts` method, preceded by `test_del_products`, `test_get_products`, and `test_set_products`.
    It takes less time to simply deal with the last failing test case(s) in the output,
    rather than scrolling through the entire output looking for a single, specific
    test method that's being worked on, so the remaining tests will be worked on and
    discussed in that order.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing HasProducts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test method for the `products` property, `testproducts`, has to account
    for the read only nature of the property—remember that the products property is
    set up to prevent, or at least minimize, the possibility of casual manipulation
    of the underlying list value. Apart from the changes to the tests of setter and
    deleter method assignment, it''s pretty much the same as previous property test
    methods, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the methods of an ABC like `HasProducts` is, at one level, the same
    sort of process as for a concrete class like `Address`: a test object that is
    an instance of the ABC has to be created, then relevant test values are passed
    to the methods and their results asserted. An ABC, if it has abstract members,
    cannot be instantiated, however, so a throwaway derived class that has minimal
    implementations of the abstract members has to be defined and used in place of
    the concrete class to create test objects. For the purposes of testing the member
    methods of `HasProducts` , that class is `HasProductsDerived`, and it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With that class defined, the tests for `_get_products`, `_set_products`, and `_del_products` can
    be created as straightforward variations of the test strategies used so far, though
    they require `GoodProducts` and `BadProducts` definitions that make use of the
    `throwaway` class first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once those are also in place, the test methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for `HasProducts.__init__` uses much the same sort of approach
    as `test_set_products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since `HasProducts` has concrete functionality hidden behind its `add_product` and `remove_product` methods,
    it would also be possible to test that functionality in the same fashion, but
    any derived class methods that call those methods would still have to be individually
    tested anyway, according to our test policy, so there's not much point in making
    the additional effort at this time.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing BaseProduct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test methods for the properties of `BaseProduct` don't require anything
    new; they follow the same approaches shown for properties with full get/set/delete
    capabilities, except for the test of the metadata property, which tests as a read-only
    property like the test for `HasProducts.products` we have just shown.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the test methods for `BaseProduct` will also follow previously established
    patterns—testing for good and bad value variants of standard required and optional
    text lines—but there are a few that require new, or at least variant, approaches
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set_metadata` and `remove_metadata` method tests are just different enough
    from previous tests that they are worth a closer examination. In order to test
    the addition of new metadata key/value items, it''s necessary to keep track of
    an expected value that the same addition of keys and values can be performed against.
    That is achieved in the test method by creating an empty dictionary (`expected
    = {}`) that is modified in the iteration that calls the `set_metadata` method
    on the test object. As each iteration progresses, the expected value is altered
    accordingly, and is compared to the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Tests for bad key and value sets use a single good value for whichever item
    is not being tested, and iterate over the bad values, making sure that appropriate
    errors are raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for the `remove_metadata` method of `BaseProduct` uses a similar
    strategy for keeping track of an expected value to compare test results against.
    The only significant difference is that the expected value (and the test object''s metadata too)
    need to be populated before trying to remove any `metadata` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests for the setter methods of the Boolean value properties of `BaseProduct`, `available`, and `store_available` still
    use the same good and bad value iteration approach that''s been used elsewhere,
    they just need a different list of good and bad values to test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the test method for `_set_shipping_weight` needs yet another set
    of value lists, as does the test method for `_set_metadata`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The initial test run against `_set_shipping_weight` also prompted a review of
    the assumptions around what constitutes a valid shipping weight. On reflection,
    and without knowing what the measurement units are at this point, it's quite possible
    that those values will need to allow floating point values, especially if the
    units of measure need to eventually allow for pounds, kilograms, or even tons
    of shipping, as unlikely as that might be.
  prefs: []
  type: TYPE_NORMAL
- en: The system shouldn't place any constraints on what a valid shipping weight is,
    other than ensuring that it's a number (because it always will be) and isn't negative.
    Products might, after all, include something like a piece of calligraphy, or an
    illustration on a single sheet of paper, and that's not going to weigh much at
    all. On the other end of the spectrum, a marble bust or even a large metal sculpture
    in the dozens of pounds to one or more tons weight range is just as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of these considerations in mind, `_set_shipping_weight` was altered
    to allow a broader range of value types, and to allow a zero value as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing `_set_description` also requires one additional new value list to test
    bad values with; a description can be any string value, as it''s currently implemented,
    and there are no bad value lists that adequately capture bad values for that yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing BaseOrder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing `BaseOrder`, according to the coverage test, is only going to
    be concerned with testing the `customer` property and whatever methods interact
    with that property. This is because `BaseOrder` inherits from `HasProducts`. Since
    none of the members of `HasProducts` have been overridden in `BaseOrder`, they
    are still owned by `HasProducts`, and have been tested accordingly already:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7178970e-6fc8-45a0-8238-871b45c6975d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like the testing processes for `BaseProduct` and `HasProducts`, testing `BaseOrder` requires
    the creation of a throwaway derived class that can be used to test method members.
    Since `BaseOrder` also expects a customer instance to be provided during object
    construction, we''ll also need to create a `BaseCustomer` derived class to provide
    such an object, and good and bad customer values to test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BaseCustomerDerived` class doesn''t have to implement anything, since `BaseCustomer` itself
    has no abstract members, which raises an interesting thought: if it doesn''t have
    any abstract members, why did we define it as an abstract class to begin with?
    The original thought behind that decision was that Customer objects are expected
    to vary significantly in what they can do, and perhaps what data access is allowed
    across the different components of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That expectation hasn''t changed since our initial implementation, so it still
    feels valid. At the same time, it would be possible to create an actual instance
    of `BaseCustomer`, simply because it has no abstract members defined, and that
    has at least some potential to introduce bugs somewhere down the line; if we believe
    that `BaseCustomer` really is abstract, even though it provides no abstract members,
    creating a concrete instance of it shouldn''t be allowed. That, at least, can
    be managed, though doing so may feel a bit awkward, by adding a few lines to the `__init__` method
    of `BaseCustomer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That, essentially, checks the class type of the object being created, and raises
    a `NotImplementedError` if the object being created is an instance of the abstract
    class itself. We''ll have to remember to test that when we write the `test__init__` method
    for that class, so it''s worth noting that in the test method now, so that it
    doesn''t get lost later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That aside, the creation of a `BaseCustomerDerived` class and `GoodCustomers` and `BadCustomers` value
    lists to test with allows the test-structures for all of the `testBaseOrder` test
    case class to follow the usual patterns that have been in play so far.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing BaseCustomer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the property getter, setter, and deleter method tests for `BaseCustomer` follow
    the typical pattern, though the `test_object` created is usually better handled
    by creating individual instances in each test. Doing otherwise leads, pretty quickly,
    to one test making changes to a common object that made other tests fail, and
    creating individual test objects for each test solves that neatly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for `__init__`, which needed to explicitly test whether a `BaseCustomer` object
    could be created, as noted earlier, is still pretty typical of the test structure
    established in previous test case classes, even with that addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The balance of the test method is what would be expected from previous tests,
    iterating over a relevant set of good values and asserting that they carry through
    to the properties as expected upon instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing BaseArtisan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we''ve got established patterns that should be used for all
    of the tests to execute against `BaseArtisan`:'
  prefs: []
  type: TYPE_NORMAL
- en: It's an abstract class, so we need to create a derived class for testing purposes
    (`BaseArtisanDerived`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the property getter, setter, and deleter methods follow one of the patterns
    already established:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the getter and deleter method tests are standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address` is almost a direct copy of the tests for billing and shipping address
    properties in `BaseCustomer`, and uses the same `GoodAddresses`/`BadAddresses` value
    lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company_name` is a standard optional text line test, like many of the other
    properties we''ve tested already'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `contact_email` and `website` setter methods are also follow the standard
    pattern, though they need new good and bad value lists to test against
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact_name` is a standard required text line property, and is tested like
    all of the other such properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following demonstrates examples of good and bad value lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The testing of `BaseArtisan`, however, revealed that there was no `website` argument
    provided in the `__init__` method, nor any support for passing a `website` along
    to an object during construction, so that was altered accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And that, finally, completes all of the 118 tests for the first module of the
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a273aadd-b13d-40ea-ba1b-3dbfd0afa0ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing patterns established so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's been a lot of exploration of the unit testing of the first module in
    the system, and that exploration has established some patterns that will appear
    frequently in unit testing of the other system code as it is written, so they
    will not be re-examined in any significant detail from this point on unless there's
    a significant new aspect to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration over good and bad value lists that are meaningful as values for the
    member being tested:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard optional text line values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard required text line values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean (and numeric equivalent) values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-negative numeric values (for weight values, in this case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying property method associations—getter methods in every case so far,
    and setter and deleter methods where they are expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that getter methods retrieve their underlying storage attribute values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that deleter methods reset their underlying storage attribute values
    as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that setter methods enforce type and value checks as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that initialization methods (`__init__`) call all of the deleter and
    setter methods as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution and installation considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default `setup.py`, with the package name for `hms_core` added and comments
    removed, is very basic but still provides all that''s needed to build a deployable
    Python package of the `hms_core` code base so far. It also provides the ability
    to execute all of the unit tests that''ve been created for the package, given
    the path that they reside in, and the ability to find the unit testing extensions
    that were put in play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the entire test suite living in the `tests/test_hms_core` directory
    of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59708536-a496-4faa-a9b3-f0e4d73c5b74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a source distribution of the package, which can then be installed
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This can be done from a Terminal session in the directory that the package file
    lives in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setup.py` build process will, at this point, raise a few errors, but none
    of them will prevent the package from being built, or from being installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`warning: sdist: standard file not found: should have one of README, README.rst,
    README.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning: check: missing required meta-data: url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning: check: missing meta-data: if ''author'' supplied, ''author_email''
    must be supplied too`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once installed, the `hms_core` package can be used just like any other Python
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64790796-2e0b-4549-afa9-b5147ba1816d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Three of the original stories in this iteration, focused on how the build and
    deploy processes would interact between `hms_core` and the other component project
    libraries, have not yet been addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need the business objects library to be installed with my application
    so that the application will work as needed without me having to install dependent
    components of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Central Office user, I need the business objects library to be installed
    with my application so that the application will work as needed without me having
    to install dependent components of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a System Administrator I need the business objects library to be installed
    with the Artisan gateway service so that it will work as needed without me having
    to install dependent components of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, because we don't have any other libraries to test with, they
    realistically cannot be executed against—we'll have to wait for the actual implementation
    of at least one of the installables' packages before these can be addressed, so
    they'll go back into the backlog and be picked up when they can actually be worked
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Quality assurance and acceptance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the functionality this library provides is foundational—intended to be
    consumed by other libraries—there isn't really much in the way of public facing
    capabilities that could be usefully tested in a formal **Quality Assurance** (**QA**)
    process. If such a formal QA process were involved in this iteration, about the
    most that could be done would be to execute the unit test suite and verify that
    those tests execute without failures or errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, since the bulk of the stories involved in the iteration were for
    the benefit of developers, there would be little external acceptance needed; the
    fact that the various classes in the library exist and function as expected should
    be sufficient for acceptance of those stories:'
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, I need a common definition and functional structure to represent
    addresses in the system, so that I can incorporate them into the parts of the
    system that need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a developer, I need a common definition and functional structure to represent
    artisans in the system, so that I can incorporate them into the parts of the system
    that need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a developer, I need a common definition and functional structure to represent
    customers in the system, so that I can incorporate them into the parts of the
    system that need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a developer, I need a common definition and functional structure to represent
    orders in the system, so that I can incorporate them into the parts of the system
    that need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a developer, I need a common definition and functional structure to represent
    products in the system, so that I can incorporate them into the parts of the system
    that need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The stories focused on installation are in something of an odd state at this
    point—they were specifically concerned with a single installable package for all
    the various end users, which is currently the case, but there will be more functionality
    in other libraries as development progresses. As things stand right now, an argument
    could be made that these stories meet all the stated requirements, if only because
    there is only one component installation:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need the business objects library to be installed with my application
    so that the application will work as needed without me having to install dependent
    components of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Central Office user, I need the business objects library to be installed
    with my application so that the application will work as needed without me having
    to install dependent components of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a System Administrator, I need the business objects library to be installed
    with the Artisan Gateway service so that it will work as needed without me having
    to install the dependent components of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could also be argued that these stories, though they are complete here and
    now, will have to be repeated in the development cycles for the various application
    and service components that are still to be built. Until those components have
    their own code, builds, and packages, there are no dependencies that need to be
    dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: Operation/use, maintenance, and decommissioning considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given how simple this package is, and that it has no external dependencies,
    there are no obvious considerations or items of even potential concern with regards
    to the operation and use of the package, or of decommissioning it. In the latter
    case, decommissioning would be nothing more than uninstalling the package (`pip
    uninstall HMS-Core`). Maintenance considerations would be similarly limited to
    updates of the package itself, which would be managed by simply rerunning the
    original installation process with a new package file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This iteration has defined basic business objects representing significant functional
    aspects of the system, which represent the data elements of the final system.
    None of them do any more than provide the basic structure and some business rules around
    what constitutes a valid structure of those elements, though—There is, as yet,
    no mechanism for storing those elements, retrieving them or interacting with them,
    except through their properties, directly in code.
  prefs: []
  type: TYPE_NORMAL
- en: The next iteration chapter will start looking in depth at what is required to
    provide the storage and state data persistence that the system's applications
    and service layer will require.
  prefs: []
  type: TYPE_NORMAL
