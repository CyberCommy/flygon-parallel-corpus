- en: Partitioning in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, replication in MySQL 8 was explained. This included
    detailed explanations of replication, configuration, and implementation. The chapter
    also explained group replication versus clustering, and covered the replication
    approach as a solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will do partitioning in MySQL 8\. Partitioning is the concept
    of managing and maintaining data with specific operations with several operators,
    and defining rules to control over partitioning. Basically, it provides a configuration
    hook for managing the underlying data files in a specified way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics on partitioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition pruning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restriction and limitation in partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of partitioning relates to the physical aspects of data storage
    in the database. If you look at the `SQL` standards, they do not give much information
    on the concept, and the `SQL` language itself intends to work independently of
    which media or data structure is used for storing information or data specific
    to different schemas, tables, rows, or columns. Advanced database management systems
    have added means of specifying the physical location used for data storage as
    hardware, the file system, or as both. In MySQL, the `InnoDB` storage engine provides
    support for these purposes with the notion of `tablespace`.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning enables us to distribute parts of individual tables to be stored
    as separate tables at different locations in the file system. Additionally, the
    distribution is accomplished with user specified rules provided, such as in the
    form of modulus, a hashing function, or matching with simple value or range, and
    the user provided expression acts as a parameter that is commonly known as a partitioning
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL 8, currently `InnoDB` is the only storage engine that supports partitioning.
    No extra specification is required to enable partitioning in the `InnoDB` storage
    engine. Partitioning can not be used with the storage engines `MyISAM`, `CSV`,
    `FEDERATED`, `MERGE`. For all examples given in this chapter we assume that the
    default storage engine is `InnoDB`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a partition table is created, the default storage engine is used, same
    as creating a table, and can be overridden just as we would do for any table by
    specifying the `STORAGE ENGINE` option. The following example demonstrates creating
    a table partitioned by hash into four partitions, all of which use the `InnoDB`
    storage engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning is applicable on all indexes and all data of the table. It is not
    applicable on either indexes or data, and vice versa is also not applicable. It
    can be applicable on both indexes and data together and it cannot be applied on
    part of the table.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table `tp` has no unique or primary keys defined but in general
    practice we usually have primary keys, unique keys, or both as part of the table,
    and partitioning column choice depends upon these keys if any of them is present.
    The partitioning column choice is given in detail in the *partitioning keys, primary
    keys, and unique keys* section. To simplify the concept of partitioning the examples
    given may not include these keys.
  prefs: []
  type: TYPE_NORMAL
- en: Types of partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several types of partitioning are supported in MySQL 8, listed as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '`RANGE Partitioning`: Assigns rows to partitions from the column values that
    come between the given range of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIST Partitioning`: Assigns rows to partitions from the column values that
    matches with one of the given set of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLUMNS Partitioning`: Assigns rows to partitions with multiple column values
    with either `RANGE` or `LIST` partitioning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HASH Partitioning`: Assigns partition based on user specified expressions
    evaluated on column values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY Partitioning`: In addition to `HASH` partitioning, allows the use of multiple
    column values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subpartitioning`: In addition to partitioning, allows further division in
    partitioned tables, also known as composite partitioning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different rows of the table can be assigned to different physical partitions;
    this is known as horizontal partitioning. Different columns of the table can be
    assigned to different physical partitions; this is known as vertical partitioning.
    MySQL 8 currently supports horizontal partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: For the `LIST`, `RANGE`, and `LINEAR HASH` types of partitioning, the value
    of partitioning columns is given to the partitioning function. The partitioning
    function returns an integer value that is the partition number in which the record
    should be stored. The `partition` function must be nonrandom and nonconstant.
    The `partition` function cannot contain queries and can use the SQL expression
    which returns either an integer or `NULL`, where the integer as `intval` must
    follow the expression `-MAXVALUE <= intval <= MAXVALUE`. Here, `-MAXVALUE` represents
    the lower limit and `MAXVALUE` is the upper limit for the integer type value.
  prefs: []
  type: TYPE_NORMAL
- en: The storage engine must be the same for all partitions of the same table, however
    there is no restriction on using different storage engines for different partitioned
    tables in the same database or MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to use `SQL` statements to modify partitioned tables
    and perform operations such as add, redefine, merge, drop, or split existing partitioned
    tables. Information about partitioned tables and partitions can also be obtained
    with `SQL` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '`MIN_ROWS` and `MAX_ROWS` can be used to configure the maximum and minimum
    number of rows and can be stored in the partition table.'
  prefs: []
  type: TYPE_NORMAL
- en: Partition selection and pruning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explicit selection of partition and subpartition is also provided. It enables
    row matching to the conditions given in the where clause. In partition, the pruning
    concepts described do not scan partitions where no possible matching values can
    be present, and are applied using queries, whereas partition selection is applicable
    for both queries and many of the `DML` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions and limitations in partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stored procedures or functions, user defined functions or plugins, and user
    variables or declared variables are restricted in partitioning expressions. There
    are also several restrictions and limitations applicable to partitioning given
    in the detailed section.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following list for some of the advantages of partitioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning facilitates storing more data in one table than can be held on
    a file system partition or single disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data that has become useless can be removed easily by dropping a partition or
    partitions that only contain the useless data. In some cases where specific data
    is required to be added separately, this can be done easily with partitioning
    in single or multiple partitions based on the specified rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query optimization that occurs automatically based on partitioned data by not searching
    for data in partitions that are not applicable as per the where condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to partition pruning, partition selection is supported explicitly
    by which where clause is applied on a specified partition or multiple partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater query throughput is achieved by separating data search into multiple
    disks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will understand different types of partitioning and also
    the purpose of using specific partitioning. The following is a list of the partitioning
    types that are available in MySQL 8 :'
  prefs: []
  type: TYPE_NORMAL
- en: '`RANGE partitioning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIST partitioning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLUMNS partitioning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HASH partitioning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY partitioning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subpartitioning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the above list, we will also see `NULL`handling in MySQL 8 Partitioning
    in detailed section.
  prefs: []
  type: TYPE_NORMAL
- en: A very common use case for database partitioning is segregating data by date.
    MySQL 8 does not support date partitioning, which some database systems provide
    explicitly, but it is easy to create partitioning schemes with date, time, or
    datetime columns, or that are based on date/time related expressions that evaluate
    values from these column types.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the date, time, or datetime types as column values for partition
    columns without any modifications if using `KEY` or `LINEAR KEY` partitioning,
    whereas in other partitioning types an expression giving back an integer or `NULL`
    value is required.
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of which type of partitioning you use, partitions always get numbered
    automatically with an integer number in sequence of the partitions created. If,
    for example, the table uses four partitions, they are numbered as 0,1,2, and 3
    for each of the partitions as per creation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: When you specify numbers of partitions, it must be evaluated to a positive,
    non zero integer without any leading zeros. Decimal fractions are not allowed
    as partition numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Names of partitions are not case-sensitive and should follow conventions or
    rules just like other MySQL identifiers such as tables. The options used in partition
    definition are already provided by the `CREATE TABLE` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at partition in detail and examine each of the types to learn
    how they are different to each other.
  prefs: []
  type: TYPE_NORMAL
- en: RANGE partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this type of partitioning, as the name states, `RANGE` is given in an expression
    that evaluates whether a value lies in the given range or not. Ranges are defined
    with the `VALUES LESS THAN` operator and they should not be overlapping and contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next few examples, suppose we are creating a table holding employee
    personal records for 25 food stores. The stores are numbered from 1 to 25 and
    is a chain of 25 food stores, as shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s do partitioning of the table, so you can partition the table by
    range as per your need. Suppose you consider using division to split the data
    five ways with the `store_id` range for partitioning. For this, the table creation
    definition will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, as per the above partitioning scheme, all inserted rows that contain the
    employees working at stores 1 to 5 are stored in the `p0` partition, employees
    working at stores 6 to 10 are stored in the `p1` partition, and so on. If you
    take a look at the partition definition, partitions are ordered from the lowest
    to highest `store_id` column values, and the `PARTITION BY RANGE` syntax looks
    similar to programming statements `if… elseif …` statements, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you are thinking about what will happen if a record comes with `store_id` `26`;
    this would result in an error as the server does not know where to place the record.
    There are two ways to keep this error from occurring:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `IGNORE` key word with the `INSERT` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using `MAXVALUE` instead of a specified range (`26`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And yes, of course, you can extend the limits by using the `ALTER TABLE` statement
    to add new partitions for stores 26-30, 30-35, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `store_id`, you could also partition the table based on the job
    codes - based on the range of column values. Suppose if 5 digit codes are used
    for management positions, 4 digit codes are used for office and support personnel,
    and 3 digit codes are used for regular workers, then the partition table creation
    definition would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify partitioning with one of the two columns of date type
    values. Suppose you wish to partition based on the year each of the employee joined
    - so by the value of `YEAR(hired_date)`. Now the table definition will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: According to this scheme, all employees recorded hired before `1996` will be
    stored in the partition `p0`, then records with a hire date before `2001` will
    be stored in the partition `p1`, records between `2001` and `2006` in `p2`, and
    the rest of the records will be stored in partition `p3`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition schemes based on time intervals** can be implemented using the
    following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Partition the table by `RANGE` and use a function operating on the date, time
    or datetime column values to return an integer value for the partitioning expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partition the table by `RANGE COLUMN` and use the date, time, or datetime columns
    as the partition column
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RANGE COLUMN` is supported in MySQL 8 and is described in detail in the `COLUMN
    PARTITIONING` section.'
  prefs: []
  type: TYPE_NORMAL
- en: LIST partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name states, `LIST` partitioning uses lists for table partitioning. The
    list is comma separated integer values defined while partitioning with `VALUES
    IN (value_list)`; here, `value_list` refers to comma separated integer literals.
  prefs: []
  type: TYPE_NORMAL
- en: '`LIST` partitioning is similar to `RANGE` partitioning in many ways, but there
    are differences. The operator used in each partitioning is different. The operator
    uses a list of comma separated values to be matched with the column value or the
    partition expression evaluating to integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the employee table as an example, the basic definition for the
    table using the create table syntax will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you wish to distribute these 25 food stores among five zones—North,
    South, East, West, and Central, with the store ID numbers (1,2,11,12,21,22), (3,4,13,14,23,24),
    (5,6,15,16,25), (7,8,17,18), and (9,10,19,20) respectively for the zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partitioning the table with the zones list will provide the following definition
    for table partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding statement, partitioning per zones means it will
    be easy to update records for stores based on zones within particular partitions.
    Suppose the organization sold the west zone to another company; then you might
    need to remove all employee records from the west zone using the `pWest` partition
    in query. Executing `ALTER TABLE` employee `TRUNCATE PARTITION pWest` would be
    much easier and efficient than the `DELETE` statement `DELETE from employee where
    store_id IN (7,8,17,18)`; also, you can use the `DROP` statement for employee
    records removal - `ALTER TABLE employee DROP PARTITION pWest`. Along with the
    previous statement execution you will also remove the `pWest PARTITION` from the
    table partition definition, and will need to use the `ALTER` statement again to
    add the `pWest PARTITION` and restore the partition table scheme you had earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `RANGE` partitioning, you can also use `LIST` partitioning using
    hash or key to produce composite partitioning, which is also known as `subpartitioning`.
    You will get to know more details on `subpartitioning` as a dedicated section
    for `subpartitioning` follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LIST` partitioning there is no catch-all mechanism such as `MAXVALUE` that
    can contain all possible values. Instead, you have to manage the expected values
    list in the `values_list` itself, otherwise the `INSERT` statement will result
    in an error where the table has no partition for value 9, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding `INSERT` statement, value 9 is not part of
    the list given during partition schema and so there is an error. If you use multiple
    value insert statements, the same error can result in failure for all inserts
    and no records will be inserted; instead use the `IGNORE` keyword to avoid such
    errors, as in the following `INSERT` statement example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: COLUMNS partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, this type of partitioning uses columns themselves. We
    can use two versions of column partitioning. One is `RANGE COLUMN` and the other
    is `LIST COLUMN`. In addition to both `RANGE COLUMN` and `LIST COLUMN` partitioning,
    MySQL 8 supports using non-integer types of column that can be used to define
    value ranges or list values. The list of permitted data types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All column types of `INT`, `BIGINT`, `MEDIUMINT`, `SMALLINT`, and `TINYINT`
    are supported for the `RANGE` and `LIST` partitioning columns, but other numeric
    column types such as `FLOAT` or `DECIMAL` are not supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATE` and `DATETIME` are supported but other column types relating to date
    and time are not supported as partitioning columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string column types `BINARY`, `VARBINARY`, `CHAR` and `VARCHAR` are supported
    but the `TEXT` and `BLOB` column types are not supported as partitioning columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see `RANGE COLUMN` partitioning and `LIST COLUMN` partitioning in
    detail one by one.
  prefs: []
  type: TYPE_NORMAL
- en: RANGE COLUMN partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, you can define range using columns with `RANGE` partitioning
    and `RANGE COLUMN` partitioning, but the difference is that you can define multiple
    columns providing range, and additionally you are able to select column types
    other than integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, `RANGE COLUMN` partitioning is different to `RANGE` partitioning in the
    following listed ways :'
  prefs: []
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` can use one or multiple columns and the comparison occurs between
    list of column values and not between scalar values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` can use only names of columns and not any expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` partitioning column types are not restricted to `INTEGER` column
    types only but can use the string, date, and datetime column types as partitioning
    columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table partitioning by `RANGE COLUMNS` has the following basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding syntax, `column_list` stands for partitioning column list and
    `value_list` stands for partition definition value list, and `value_list` must
    be given for each of the partition definitions, along with the same number of
    values defined in `column_list`. To say it straight, the number of columns (`column_list`)
    in the `COLUMNS` clause must be the same as the number of values (`value_list`)
    in the `VALUES LESS THAN` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example makes clear what it is and how it goes with the table
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you go and insert records into the table `trc` with the following statement
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: LIST COLUMN partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this type of partitioning, lists of columns are used in the table partitioning
    definition, and similar to the `RANGE COLUMN` the value list for the respective
    columns must be provided. Similar to `RANGE COLUMN`, column types other than integer
    types can be used—that is, the string, date, and datetime column types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have the requirement that a business has spread over 12 cities,
    and for marketing purposes you manage them with four zones of three cities as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone 1 with cities**: Ahmedabad, Surat, Mumbai'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone 2 with cities**: Delhi, Gurgaon, Punjab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone 3 with cities**: Kolkata, Mizoram, Hyderabad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone 4 with cities**: Bangalore, Chennai, Kochi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, create a table for the customer data that has four partitions of the corresponding
    zones, and list them with the name of the city where the customer resides. The
    table partition definition will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `RANGE COLUMN` partitioning, it is not required to provide any expression
    in the `COLUMNS()` clause that converts the column value to an integer literal,
    and nothing other than the list of column names itself is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: HASH partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary intention behind introducing `HASH` partitioning is to ensure an
    even distribution of date among the number of partitions defined. So, with `HASH`
    partitioning you need to specify the column value or the expression evaluating
    the column value being hashed, and the number of partitions into which the partitioned
    table is to be divided.
  prefs: []
  type: TYPE_NORMAL
- en: For defining `HASH` partitioning in table you need to specify the `PARTITION
    BY HASH (expr)` clause in the table definition, where `expr` is the expression
    that will return the integer, and additionally you need to specify the number
    of partitions with `PARTITIONS n`, where `n` is a positive integer number that
    stands for the number of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following definition creates a table with `HASH` partitioning on the `store_id`
    column, dividing into five partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above statement, if you exclude the `PARTITIONS` clause, the number of
    partitions automatically defaults to one.
  prefs: []
  type: TYPE_NORMAL
- en: LINEAR HASH partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 supports linear hashing, which is based on a linear power-of-two algorithm
    instead of regular hashing, which is based on the modulus of the hashing function''s
    value. `LINEAR HASH` partitioning requires the `LINEAR` keyword in the `PARTITION
    BY` clause, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: An advantage of using linear hashing is faster partitioning operations, and
    a disadvantage is less even data distribution compared to regular hashing partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: KEY partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of partitioning is similar to `HASH` partitioning, with the change
    of the use of a user-defined expression instead of the hashing function. `KEY
    PARTITIONING` uses the `PARTITION BY KEY` clause in the `CREATE TABLE` statement
    for the partitioning definition. The syntax rules for `KEY` partitioning are similar
    to that of `HASH` partitioning, so let''s list out the differences so as to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `HASH`, `KEY` is used for partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One or more column names list is taken in `KEY()`, and if there is no column
    defined in `KEY` but the table has a defined primary key or unique key with the `NOT
    NULL` constrain, the column is automatically taken as partitioning column for
    `KEY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike other partitioning types, the column type is not only limited to `NULL`
    or integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example statement, similar to `HASH` partitioning,
    `KEY` partitioning also supports `LINEAR KEY` partitioning and has the same effect
    as `LINEAR HASH` partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Subpartitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Subpartitioning is also known as composite partitioning, and as the name suggests
    it is only a division of each partition into a partitioned table itself. See the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example statement, table `trs` has three `RANGE`
    partitions and each of the partitions `p0, p1, p2` is further divided into two
    more subpartitions. Effectively, the entire table is divided into six partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Subpartitioning is possible on tables partitioned using `RANGE` or `LIST` partitioning,
    and subpartitioning can use the `KEY` or `HASH` partitioning types. The syntax
    rules for subpartitioning are the same as in regular partitioning, with the exception
    to specify the default column in `KEY` partitioning as it does not take the column
    automatically for subpartitioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of points to consider when using subpartitioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of partitions must be same for each of the partitions defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name must be specified with the `SUBPARTITIONING` clause or specify a default
    option instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names specified for subpartitioning must be unique across the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling NULL in partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing specific to MySQL 8 that disallows `NULL` in partitioning as
    a column value, partitioning expression, or the value from the user-defined expression.
    Even if `NULL` is permitted as a value ,the value returned from the expression
    must be an integer and so MySQL 8 has implementation for partitioning such that
    it treats `NULL` as less than any non-`NULL` value as done in the `ORDER BY` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behavior for `NULL` handling varies among different types of partitioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling `NULL` in `RANGE` partitioning**: If a `NULL` value contained in
    the column is inserted, the row will be inserted in the lowest partition specified
    in range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling `NULL` with `LIST` partitioning**: If the table has a partitioning
    definition with `LIST` partitioning and its partitions are defined with a value
    list that explicitly specifies `NULL` as a value in `value_list`, then insertion
    will be successful; otherwise, it will give an error table that has no partition
    specified for `NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling `NULL` with `HASH` and `KEY` partitioning**: `NULL` is handled differently
    when table partitioning is defined with `HASH` or `KEY` partitioning, and if a
    partition expression returns `NULL` it is wrapped with zero value. So that based
    on partitioning the insertion operation will successfully insert the record to
    partition being zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are plenty of ways to use `SQL` statements in order to modify partitioned
    tables—you can drop, add, merge, split, or redefine partitions with the `ALTER
    TABLE` statement. There are also ways to retrieve partitioned tables and partition
    information. We will see each of these in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RANGE` and `LIST` partition management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HASH` and `KEY` partition management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain partition information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RANGE and LIST partition management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partition adding and dropping is handled in a similar way for the `RANGE` and
    `LIST` partition types. A table partitioned by `RANGE` or `LIST` partitioning
    can be dropped using the `ALTER TABLE` statement with the `DROP PARTITION` option
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have the `DROP` privilege before executing the `ALTER TABLE ...
    DROP PARTITION` statement. `DROP PARTITION` will delete all the data and also
    remove the partition from the table partition definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates the `DROP PARTITION` option with the `ALTER
    TABLE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding statement, after executing the `ALTER TABLE employee DROP PARTITION
    p2;` statement, you can see that all data is removed from partition `p2`. In case
    you want to remove all the data but also need to keep the table definition and
    the partitioning scheme, you can use the `TRUNCATE PARTITION` option to achieve
    a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: In order to add new `LIST` or `RANGE` partitions to existing partitioned tables
    you can use the `ALTER TABLE ... ADD PARTITION` statement.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `SHOW CREATE TABLE` statement you can verify and see if the `ALTER
    TABLE` statement has the desired effect on the table definition and the partitioning
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: HASH and KEY partition management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Table partitions of the `HASH` or `KEY` types are similar compared to table
    partitioning by the `RANGE` or `LIST` types of partitioning. Dropping a partition
    is not applicable if a table is partitioned by the `HASH` or `KEY` type of partitioning,
    but there is option for merging `HASH` or `KEY` partitions, using `ALTER TABLE
    ... COALESCE PARTITION`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider if you have client table data partitioned by `HASH` partitioning,
    divided in twelve partitions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding table partitioning schema, if you want to reduce the number
    of partitions to eight instead of twelve, use the following `ALTER TABLE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding statement the number 8 represents the number of partitions
    to be removed from the table. You cannot remove more partitions than already exist
    in the table partitioning schema. Similarly, you can add more partitions using
    the `ALTER TABLE... ADD PARTITION` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Partition maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many maintenance tasks that can be done with several statements on
    a number of tables and partitions. They can be done using statements such as `ANALYSE
    TABLE`, `CHECK TABLE`, `REPAIR TABLE`, and `OPTIMIZE TABLE` , which are supported
    specifically for partitioned tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of extensions of `ALTER TABLE` available for such operations
    on single or multiple partitioned tables, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rebuilding partitions**: This option drops all records from the partitions
    and reinserts them, so this is considered helpful in the defragmentation process.
    The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Optimizing partitions**: If many rows are deleted from a partition or partitions
    of the table, or there are many row changes in a huge amount of data in variable
    length column types such as `VARCHAR`, `BLOB`, `TEXT`, and so on, you can perform
    `OPTIMIZE PARTITION` to reclaim unused space in the partition data file. The following
    is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`ALTER TABLE ... OPTIMIZE PARTITION` does not work correctly with the `InnoDB`
    storage engine, so instead use `ALTER TABLE ... REBUILD PARTITION` and `ALTER
    TABLE ... ANALYZE PARTITION` for such tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing partitions**: In this option key distributions of the partitions
    are read and stored. The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Repairing partitions**: This option is only used when there are corrupt partitions
    found to be repaired. The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Checking partitions**: This option is used to check for any errors in partitions
    such as the `CHECK TABLE` option used in nonpartitioned tables. The following
    is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There is an option to use `ALL` instead of a specific partition, specified in
    all above options, in order to perform the operation on all the partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Obtain partition information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Information about partitions can be obtained in a number of ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SHOW CREATE TABLE` statement can be used to view the partition's schema
    information containing all partitioning clauses in the partitioned tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SHOW TABLE STATUS` statement can be used to check if the table is partitioned
    or not by viewing its status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXPLAIN SELECT` statement can be used to see partitions used by given `SELECT`
    option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `INFORMATION_SCHEMA.PARTITIONS` table for querying partition table
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example with the `SHOW CREATE TABLE` statement option to
    see partition information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The output from the preceding statement has separate information for partitioning
    schema, including common information for the table schema.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can retrieve information about partitioning from the `INFORMATION_SCHEMA.PARTITIONS`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The `EXPLAIN` option gives a lot of information on partitioning with column.
    For example it gives number of rows obtained from the query specific to partitions.
    The partition would be searched as per the query statement. It also gives information
    about keys.
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPLAIN` is also used to get information from nonpartitioned tables. It does
    not give any error if there are no partitions, but gives a `NULL` value in the
    partitions column.'
  prefs: []
  type: TYPE_NORMAL
- en: Partition selection and pruning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will see how partitioning can optimize `SQL` statements clause
    execution with the optimizer known as partition pruning, and the use of `SQL`
    statements to effectively use partition data for selection and perform modification
    operations on the partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Partition pruning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partition pruning is related to the optimization concept in partition. In partition
    pruning the concept described as *Do not scan partitions where no possible matching
    values can be present* is applied based on the query statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose there is a partitioned table, `tp1`, created with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example table `tp1`, suppose you want to retrieve a result
    from the following `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can see from the preceding statement that there are no rows that have
    data in partitions `p0` or `p3` as per the statement, so we only need to search
    the data in `p1` or `p2` for matching criteria. So, by limiting the search, it
    is possible to spend less time and effort matching and searching for the data
    through all the partitions in the table. This cutting away of the unmatched partitions
    is known as pruning.
  prefs: []
  type: TYPE_NORMAL
- en: The optimizer can make use of partition pruning for performing the query execution
    much faster compared to nonpartitioned tables that have the same schema, data,
    and query statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optimizer can do pruning in the following cases based on the `WHERE` condition
    reduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`partition_column IN (constant1, constant2, ..., contantN)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partition_column =  constant`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, the optimizer evaluates the partitioning expression for each
    of the values in the list and creates a list of partitions that are matched during
    evaluation, and then scanning or searching is performed only on the partitions
    in this partition list.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, the optimizer only evaluates the partitioning expression
    based on the given constant or specific value and determines which partition contains
    the value, and searching or scanning is performed only on this partition. There
    can be use of another arithmetic comparison instead of equals for this type of
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, pruning is not supported on `INSERT` statements but is supported
    in `SELECT`, `UPDATE`, and `DELETE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Pruning is also applicable to short ranges where the optimizer can convert the
    ranges into an equivalent list of values. The optimizer can be applied when the
    partitioning expression consists of equality or range that can be reduced to equalities
    set or if an increasing or decreasing relationship is represented by the partitioning
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Pruning can also applicable to the column types of `DATE` or `DATETIME` if the
    partitioning uses the `TO_DAYS()` or `YEAR()` function, and also applicable if
    such tables use the `TO_SECONDS()` function in their partitioning expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a table, `tp2`, as per the following statement :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the preceding statement the following statements can benefit from partition
    pruning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last statement, the optimizer can act as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the partition that has the low end of the range as `YEAR('1984-06-22')`
    gives the value 1984, found in the `p3` partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the partition that has the high end of the range as `YEAR('1999-06-22')`
    gives the value 1999, found in the `p5` partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan only the above two identified partitions and any partitions that lie between
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in the above mentioned case the partitions to be scanned are `p3`, `p4`,
    and `p5` only, and the rest of the partitions can be ignored while matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples use `RANGE` partitioning but partition pruning is also
    applicable on other types of partitioning as well. Suppose you have the table
    `tp3` schema as per the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For the preceding table schema, consider if this statement `SELECT * FROM tp3
    WHERE zone_code BETWEEN 1 AND 3` is to be executed. The optimizer determines which
    of the partitions can have the values `1`, `2`, and `3` and finds `p1` and `p0`,
    so it skips the rest of the partitions `p3` and `p2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Column values with a constant can be pruned, as in the following example statement :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The optimization is performed only when the size of the range is smaller than
    the number of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Partition selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Explicit selection of partition and subpartition is also supported and this
    enables row matching to conditions given in the where clause - this is known as
    partition selection. It is very similar to partition pruning as only specific
    partitions are scanned for matching, but differs in the following two key aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The partitions to be scanned are specified by the issuer of the statement and
    are not automatic such as with partition pruning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The partition pruning is limited to queries, whereas partition selection supports
    both queries and a number of `DML` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL statements supported for explicit partition selection are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPLACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOAD DATA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOAD XML`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following syntax with the `PARTITION` option is used for explicit partition
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding option is always followed by the table structure or table schema
    it belongs to. `partition_names` stands for the list of comma separated names
    of partitions or subpartitions that will be used in partitioning. Partition and
    subpartition names in `partition_names` can be in any order or even overlap but
    each name from the list must be the existing partition or subpartition name of
    the specific table, otherwise the statement will fail with the error message `partition_name` doesn't
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: If the `PARTITION` option is used, only listed partitions and subpartitions
    are checked for matching rows. `PARTITION` option can also be used in the `SELECT`
    statement to retrieve rows belonging to any given partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have the table `employee` created with the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you check with partition `p1`, you see the following output as rows
    added in partition `p1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you use this statement `SELECT * FROM employee WHERE id BETWEEN 5 AND 9;`,
    it will give the same output.
  prefs: []
  type: TYPE_NORMAL
- en: In order to retrieve rows from multiple partitions you can use a comma separated
    list of partition names. For example, `SELECT * FROM employee PARTITION (p1,p2)`,
    will result in all the rows from partitions `p1` and `p2` and exclude the remaining
    partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Any supported partitioning types can be used using partitioning selection statements.
    MySQL 8 automatically adds partition names when a table is created with the `LINEAR
    HASH` or `LINEAR KEY` partitioning types specified without any names, and this
    is also applicable to subpartitions as well. While executing the `SELECT` statement
    on this table you can specify partition names generated by MySQL 8 for partition
    specific data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: The `PARTITION` option is also applicable on the `SELECT` statement for the
    `INSERT ... SELECT` statement, by which we can insert data retrieved from specific
    partitions or subpartitions as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `PARTITION` option is also applicable on the `SELECT` statement with join
    queries on tables with specific partition or subpartition data.
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions and limitations in partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will see the restrictions and limitations in MySQL 8 partitioning,
    covering prohibited constructs, performance considerations, and limitation aspects
    related to storage engines and functions in detail, to gain optimum benefits from
    the table partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning keys, primary keys, and unique keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relationship between partitioning keys with primary keys and unique keys
    is very important for partition schema structure design. To say the rule in one
    line it will be that `All` the columns used in the partitioning in the partition
    table must include every unique key of the table. So every unique key, including
    the primary key column on the table, must be part of the partitioning expression.
    Take a look at the following example for the `CREATE TABLE` statement using a
    unique key that does not adhere to the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In each of the preceding statements for the creation of table `tk1` and `tk2` the
    proposed table can have at least one unique key that does not include all columns
    in the partition expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at the following modified table creation statements, which are made
    to work and are turned from invalid to valid statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at the following table structure, it cannot be partitioned
    at all because there is no way to include both the unique key columns that can
    be part of partitioning key columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the definition, every primary key is a unique key. The restriction is
    also applicable on a table''s primary key, if any. The following are two examples
    for table `tk5` and `tk6` that are invalid statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the preceding statements, the corresponding primary key is not included
    in all the columns referenced as in the partitioning expression. The following
    statements are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If the table does not have a unique key or primary key then the restriction
    is not applicable, and any column or columns can be used in the partitioning expression
    as per compatible column types for the partitioning type. All above restrictions
    are also applicable to the `ALTER TABLE` statements as well.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning limitations relating to storage engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partitioning support is not provided by MySQL server but from the storage engine's
    own or native partitioning handler in MySQL 8\. In MySQL 8, the `InnoDB` storage
    engine only provides a native partitioning handler and so the partitioned table
    creation is not applicable with any other storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: '`ALTER TABLE ... OPTIMIZE PARTITION` does not work correctly with the `InnoDB` storage
    engine, so instead use the `ALTER TABLE ... REBUILD PARTITION` and `ALTER TABLE
    ... ANALYZE PARTITION` operations for such tables.'
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning limitations relating to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In partitioning expressions only the following listed MySQL functions are allowed
    in MySQL 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABS()`: It provides an absolute value for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CEILING()`: It provides the smallest integer number possible for the given
    argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAY()`: It provides the day of the month for the given date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAYOFMONTH()`: It provides the day of the month for the given date same as
    `DAY()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAYOFWEEK()`: It provides the weekday number for the given date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAYOFYEAR()`: It provides the day of the year for the given date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEDIFF()`: It provides the number of days between two given dates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXTRACT()`: It provides part of the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLOOR()`: It provides the largest integer value possible for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HOUR()`: It provides the hour from the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MICROSECOND()`: It provides the microseconds from the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MINUTE()`: It provides the minute from the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOD()`: It performs the Modulo operation and provides the remainder of `N`
    divided by `M` where `MOD(N,M)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MONTH()`: It provides the month from the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUARTER()`: It provides the quarter from the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECOND()`: It provides the second from the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME_TO_SEC()`: It provides the second from the given time value argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TO_DAYS()`: It provides the number of days from year 0 for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TO_SECONDS()`: It provides the number of seconds from the year 0 for the given
    argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNIX_TIMESTAMP() (with TIMESTAMP columns)`: It provides the seconds since
    ''1970-01-01 00:00:00'' UTC for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WEEKDAY()`: It provides the weekday index for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YEAR()`: It provides the year for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YEARWEEK()`: It provides the year and week for the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition pruning supports the `TO_DAYS()`, `TO_SECONDS()`, `TO_YEAR()`, and
    `UNIX_TIMESTAMP()` functions in MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different types of partitioning and the need
    for partitions. We also covered detailed information on managing all types of
    partitions. We learned about partition pruning and selection of partitions which
    is used by the optimizer. We also discussed applicable limitations and restrictions
    to consider while using partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to do scaling in MySQL 8, and discover
    common challenges faced when providing scalability in MySQL 8\. You will also
    learn how to make the MySQL server highly available and achieve high availability.
  prefs: []
  type: TYPE_NORMAL
