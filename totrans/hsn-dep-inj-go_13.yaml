- en: Assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the questions at the ends of the chapters are intentionally thought-provoking,
    and as with many things in programming, the answers often depend on the programmer's
    situation or worldview.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the answers following are likely to differ from yours, and that's
    alright. These are my answers and not necessarily the *right* answers for you.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1, Never Stop Aiming for Better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. What is dependency injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: During this chapter, I defined dependency injection as coding in such a way
    that those resources (that is, functions or structs) we depend on are abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to say that because these dependencies are abstract, changes to them
    do not necessitate changes to our code. The fancy word for this is **decoupling**.
  prefs: []
  type: TYPE_NORMAL
- en: For me, decoupling is really the essential attribute and goal here. When objects
    are decoupled, they are just easier to work with. Easier to extend, refactor,
    reuse, and test. While these are all fantastically important, I also try to be
    pragmatic. In the end, the software will work just the same if it is not decoupled
    and does not use dependency injection. But it will become progressively harder
    to work with and extend.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. What are the four highlighted advantages of dependency injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection reduces the knowledge required when working on a piece
    of code by expressing dependencies in an abstract or generic manner.** This, for
    me, is about speed. When I jump into a piece of code, especially in a large project,
    it''s easier to understand what a particular section (such as a struct) is doing
    when its dependencies are abstract. Typically, this is because the relationship
    is well described and the interactions clean (in other words, there is no object
    envy).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection enables us to test our code in isolation of our dependencies.**
    Similar to the first point, when the dependency is abstract and interactions clean,
    testing the current piece of code by manipulating its interactions with dependencies
    is easy to understand and therefore faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection enables us to quickly and reliably test situations that
    are otherwise difficult or impossible.** I know, I focus a lot on testing. I am
    not actually zealot on this; it''s purely self-protection and my idea of professionalism.
    When I am writing code for someone else, I want it to be as good as possible (within
    resource constraints). Furthermore, I want it to continue to work the way I intended
    it to. Tests help me to both clarify and document my intent during construction
    and in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection reduces the impact of extensions or changes.** Sure,
    if a method signature changes, its usages will change. When we rely on our own
    code (such as local interfaces), we at least have a choice in how to react to
    changes.  We can switch to other dependencies; we can add an adapter in between. 
    Regardless of how we deal with it, when our code and tests rely on the unchanged,
    we can be confident that any problems that arise are in the changed portion or
    in the features that it provides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3\. What sorts of issues does it address?**'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this is essentially the entire section on *code smells,* which
    include code bloat, resistance to change, wasted effort, and tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. Why is it important to be skeptical?**'
  prefs: []
  type: TYPE_NORMAL
- en: In our industry, there is almost always more than one way to solve the problem
    at hand. Similarly, there are almost always many people selling you a *magic bullet* to
    solve all of your problems. Personally, my answer when asked whether a solution
    will work is often *it depends*. It might infuriate those that come to me for
    a simple answer and receive a bunch of questions instead, but there really is
    seldom a definitive answer. In truth, this is likely what keeps me coming back
    for more. There is always something new to learn, some new idea to try, some old
    notion to rediscover. So, I implore you, always listen, always question, and don't
    be afraid to experiment and fail.
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. What does *idiomatic Go* mean to you?**'
  prefs: []
  type: TYPE_NORMAL
- en: There is absolutely no correct answer to this. Please don't let anyone tell
    you otherwise. If you are consistent among the team you are working on, that is
    enough. If you don't like this style, propose and debate for a better one. While
    many people are resistant to change, far fewer are against better code.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2, SOLID Design Principles for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. How does the single responsibility principle improve Go code?**'
  prefs: []
  type: TYPE_NORMAL
- en: By applying the single responsibility principle, the complexity of our code
    is reduced as it is decomposed code into smaller, more concise pieces.
  prefs: []
  type: TYPE_NORMAL
- en: With the smaller, more concise pieces, we gain increases in the potential usability
    of that same code. These smaller pieces are easier to compose into larger systems,
    due to their lighter requirements and more generic nature.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle also makes tests simpler to write and maintain
    because when a piece of code has only one purpose, there is only much less scope
    (and therefore complexity) required to test.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. How does the open/closed principle improve Go code?**'
  prefs: []
  type: TYPE_NORMAL
- en: The open/closed principle helps reduce the risk of additions and extensions
    by encouraging us not to change existing code, particularly exported APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The open/closed principle also helps reduce the number of changes needed to
    add or remove a feature. This is particularly prevalent when moving away from
    certain code patterns, such as switch statements. Switch statements are great,
    but they tend to exist in more than one place, and it's easy to miss one instance
    when adding new features.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when problems do arise, they are easier to find, given that they
    are either in the newly added code or the interactions between it and its usages.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. How does the Liskov substitution principle improve Go code?**'
  prefs: []
  type: TYPE_NORMAL
- en: By following the Liskov substitution principle, our code performs consistently
    regardless of the dependencies we are injecting. Violating the Liskov substitution
    principle, on the other hand, leads us to violate the open/closed principle. These
    violations cause our code to have too much knowledge of the implementations, which
    in turn breaks the abstraction of the injected dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing interfaces, we can use the Liskov substitution principle's
    focus on *consistent *behavior as a way of detecting code smells related to incorrect
    abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. How does the interface segregation principle improve Go code?**'
  prefs: []
  type: TYPE_NORMAL
- en: The interface segregation principle requires us to define thin interfaces and
    explicit inputs. These features allow us to decouple our code from the implementations
    that are fulfilling our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: All of this leads to dependency definitions that are concise, easy to understand,
    and convenient to use, particularly when using them with mocks and stubs during
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. How does the dependency inversion principle improve Go code?**'
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle forces us to focus on the ownership of the
    abstractions and change their focus from *uses* to *requires*.
  prefs: []
  type: TYPE_NORMAL
- en: It also further decouples our dependency definitions from their implementations.
    As with the interface segregation principle, the result is code that is more straightforward
    and separate, particularly from its users.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3, Coding for User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. Why is the usability of code important?**'
  prefs: []
  type: TYPE_NORMAL
- en: Good UX is not nearly as apparent as bad UX. This is because when UX is good,
    it *just works*.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the more complicated, obfuscated, or unusual a piece code is, the
    harder it is to understand. The harder code is to follow, the harder it is to
    maintain or extend and the higher the chance of mistakes being made.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Who benefits the most from code with great UX?**'
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we are both the creators and greatest users of our code; it
    is, therefore, our colleagues and ourselves that benefit most.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. How do you construct good UX?**'
  prefs: []
  type: TYPE_NORMAL
- en: The best UXes are intuitive and natural to their users. The key, therefore,
    is to try to think as your users do. Chances are that the code you write will
    make sense and hopefully be natural to you, but can you say the same for the rest
    of your team?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we defined some aspects to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Start simple, and get complicated only when you must.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply just enough abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow industry, team, and language conventions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export only what you must.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggressively apply the single responsibility principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also introduced the *UX Discovery Survey* as a way to *get into the minds* of
    your users. The survey consisted of four questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Who is the user?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are your users capable of?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do users want to use your code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do your users expect to use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4\. What can unit testing do for you?**'
  prefs: []
  type: TYPE_NORMAL
- en: In short, many things. It does differ from person to person. Primarily, I use
    tests to give me the confidence to either *go fast* or *take on the big jobs,* depending
    on what is needed.
  prefs: []
  type: TYPE_NORMAL
- en: I also find that tests do an excellent job of documenting the intent of the
    author and are less likely to go stale as comments can.
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. What kind of test scenarios should you consider?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You always want to consider at least three scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The happy path:** Does your function do what you expect it to do?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input errors:** Predictable errors in usage (particularly inputs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency issues:** Does your code behave when the dependencies fail?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**6\. How do Table-Driven Tests** (**TDTs**) **help?**'
  prefs: []
  type: TYPE_NORMAL
- en: TDTs are great for reducing the duplication caused by multiple test scenarios
    for the same function.
  prefs: []
  type: TYPE_NORMAL
- en: They are typically more efficient to create than copy/pasting a lot of tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**7\. How can testing damage your software design?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways that this could happen, and some are quite subjective/personal;
    but, in this chapter, we outlined a few common causes:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters, config options, or outputs that only exist because of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters that cause or a caused by leaky abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing mocks in production code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 4, Introduction to the ACME Registration Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. Which of the goals defined for our service is most important to you personally?**'
  prefs: []
  type: TYPE_NORMAL
- en: This is subjective, and as such, there is no right answer. Personally, it would
    have to be readability or testability. If the code is easy to read, then I can
    figure it out easier and probably remember more about it as well. On the other
    hand, if it's more testable, then I can leverage that fact to write more tests.
    With more tests in place, I won't have to remember as much and can let the tests
    make sure everything performs as I need it.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Which of the issues outlined seems to be most urgent or important?**'
  prefs: []
  type: TYPE_NORMAL
- en: This is also subjective. It might surprise you, but I would say *lack of isolation
    in tests*. With the tests as they are, every test is somewhat akin to an end-to-end
    test. This means that the test setup is lengthy and when something goes wrong,
    it will be time-consuming to figure out where the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5, Dependency Injection with Monkey Patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. How does monkey patching work?**'
  prefs: []
  type: TYPE_NORMAL
- en: At its most basic level, monkey patching in Go involves swapping out one variable
    for another at runtime. This variable can be an instance of the dependency (in
    the form of a struct) or a function that wraps access to the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: At a higher level, monkey patching is about replacing or intercepting access
    to a dependency to replace it with another implementation, typically a stub or
    a mock, to make testing simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. What are the ideal use cases for monkey patching?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monkey patching can be used in a variety of situations, but the most notable
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With code that relies on a singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With code that currently has no tests, no dependency injection, and where you
    want to add tests with a minimum of changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To decouple two packages without having to change the dependent package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3\. How can you use monkey patching to decouple two packages without changing
    the dependent package?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can introduce a variable of type function that calls the dependency package.
    We can then monkey patch our local variable instead of having to change the dependency.
    In this chapter, we saw that is especially useful for decoupling from code that
    we cannot change (such as the standard library).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6, Dependency Injection with Constructor Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. What are the steps we used to adopt constructor injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: We identified the dependency we wanted to extract and eventually inject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We removed the creation of that dependency and promoted it to a member variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then defined the abstraction of the dependency as a local interface and changed
    the member variable to use that instead of the real dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then added a constructor with the abstraction of the dependency as a parameter
    so that we could ensure the dependency was always available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**2\. What is a guard clause and when would you use it?**'
  prefs: []
  type: TYPE_NORMAL
- en: We defined guard clauses as a piece of code the ensured the dependency was supplied
    (in other words, not nil). In some cases, we used them in our constructors so
    that we could be 100% sure the dependency was provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. How does constructor injection affect the life cycle of the dependency?**'
  prefs: []
  type: TYPE_NORMAL
- en: When dependencies are passed into via the constructor, we are sure that they
    are always available to other methods. As such, there is no risk of nil-pointer
    crashes related to the use of the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we do not need to litter our methods with guard clauses or other
    sanity checks as any such validation only needs to exist in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '**4. What are the ideal use cases for constructor injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor injection is useful for many situations, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Where the dependencies that are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the dependencies that are used by most or all of the methods of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where there are multiple implementations of a dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the dependencies do not change between requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 7, Dependency Injection with Method Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. What are the ideal use cases for method injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method injection is great for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions, frameworks, and shared libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting scoped dependencies, such as context or user credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies that provide context or data in the request and as such are expected
    to vary between calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2\. Why is it important not to save dependencies injected with method injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: Because the dependency is a parameter of the function or method, every call
    will supply a new dependency. While saving the dependency before calling other
    internal methods might seem more straightforward than passing the parameter around
    as a dependency, such practice will cause data races between multiple concurrent
    usages.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. What happens if we use method injection too much?**'
  prefs: []
  type: TYPE_NORMAL
- en: This question is somewhat subjective and depends on your opinion of both test-induced
    damage and code UX. Personally, I care about UX quite a lot. As such, making a
    function easier to use by reducing parameters is always on my mind (except for
    constructors).
  prefs: []
  type: TYPE_NORMAL
- en: From a testing perspective, it's far more flexible to have some form of dependency
    injection than to have none. Be pragmatic; you will find a balance that works
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. Why is *stopping short* useful to the system as a whole?**'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to stop processing a request when no-one is listening for the response
    is extremely useful. Not only does it bring the system closer to the user's expectations,
    but it reduces the load on the system as a whole. Many resources of the resources
    we are working with are finite, especially databases, and anything we can do to
    complete the processing of a request quicker, even when it ends in failure, is
    advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. How can latency budgets improve UX?**'
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, latency budgets are a topic I have not heard discussed that often.
    Given the prevalence of APIs in our industry today, perhaps we should discuss
    them more. Their importance is twofold—for triggering *stop short* and for setting
    some bounds or expectations for our users.
  prefs: []
  type: TYPE_NORMAL
- en: When we publish our *maximum execution time* along with our API documentation,
    users will have clear expectations of our *worst-case* performance. Additionally,
    we can use the errors generated by the latency budget to return more informative
    error messages, further enabling the user to make more informed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8, Dependency Injection by Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. How does config injection differ from method or constructor injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: Config injection is an extended form of method and constructor injection. It
    intends to improve the UX of the code by hiding common and environmental concerns.
    This reduction in parameters makes the methods easier to understand, extend, and
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. How do we decide what parameters to move to config injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: The key point to consider is how the parameter relates to the method or constructor.
    If the dependency is insignificant but necessary, such as loggers and instrumentation,
    then hiding it in the config improves the clarity of the function signature rather
    than detracting from it. Similarly, configuration coming from a config file is
    often necessary but not informative.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Why don''t we inject all dependencies via config injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: There are two significant issues with merging all the dependencies into one.
    The first is readability. Users of the method/function would have to open the
    definition of the config every time they wished to understand what parameters
    were available. Secondly, as an interface, users would be forced to create and
    maintain an implementation of the interface that could provide all of the parameters.
    While all config may come from the same place, other dependencies likely do not.
    The inclusion of the environmental dependencies is a little cheeky but their existence
    is almost ubiquitous, and their duplication across every constructor would be
    really annoying.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. Why do we want to inject environmental dependencies (such as loggers)
    instead of using a global public variable?**'
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we like the **Don't Repeat Yourself** (**DRY**) principle. Injecting
    environmental dependencies everywhere is a lot of repeating.
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. Why are boundary tests important?**'
  prefs: []
  type: TYPE_NORMAL
- en: I hope we can all agree that it's important to test. Part of the value of testing
    is through running the tests repeatedly and detecting regression as soon as possible.
    To minimize the cost of running the tests often, we need the tests to be reasonably
    fast and absolutely reliable. When tests depend on an external system, particularly
    one that we are not responsible for, then we are putting the value of our tests
    at risk.
  prefs: []
  type: TYPE_NORMAL
- en: Anything can happen to an external system. The owner could break it; the internet/network
    could go down. Internal-facing boundary tests are similar to our unit tests. They
    protect our code from regression. External-facing boundary tests are our automated
    way of documenting and ensuring that the external system does what we need it
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**6\. What are the ideal use cases for config injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: Config injection can be used in the same situations as constructor or method
    injection. The key deciding factor is whether the dependencies themselves should
    be combined and somewhat hidden by config injection and how that improves or detracts
    from the UX of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9, Just-in-Time Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. How does Just-in-Time** (**JIT**) **dependency injection differ from
    constructor injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: This depends a lot on how the constructor injection is being used; in particular,
    how many different implementations of the dependency exist. If there is only one
    production implementation of a dependency, then they are functionally equivalent.
    The only difference is UX (that is, whether there is one less dependency to inject
    into the constructor).
  prefs: []
  type: TYPE_NORMAL
- en: If, however, there is more than one production implementation, then JIT dependency
    injection cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. When working with optional dependencies, why is using a NO-OP implementation
    important?**'
  prefs: []
  type: TYPE_NORMAL
- en: When a member variable is not set by the constructor, then it is effectively
    optional. We cannot, therefore, be sure that the value has been set and not nil.
    By adding a NO-OP implementation of the optional dependency and automatically
    setting it to the member variable, we are able to assume that the dependency is
    always non-nil and we can forgo the need for guard clauses.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. What are the ideal use cases for JIT injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'JIT injection is ideal for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a dependency that would otherwise have been injected into the constructor
    and of which there is only one production implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a layer of indirection or abstraction between an object and a global
    singleton, particularly when we want to swap out the global singleton during testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing dependencies to be optionally provided by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 10, Off-the-Shelf Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. When adopting a dependency injection framework, what can you expect to
    gain?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This, of course, differs significantly between frameworks, but typically, you
    can expect to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A reduction in boilerplate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less complexity in setting up and maintaining the dependency creation order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2\. When evaluating a dependency injection framework, what kind of issues
    should you being looking out for?**'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the gains mentioned previously, my primary criterion is the effect it
    has on the code; putting it a different way, whether I like how the code looks
    after adopting the framework.
  prefs: []
  type: TYPE_NORMAL
- en: I would also consider the configurability of the framework itself. Some configuration
    is expected, but too much can lead to a complicated UX.
  prefs: []
  type: TYPE_NORMAL
- en: The last aspect to consider is the health of the framework project. Is it being
    actively maintained? Are reported bugs being responded to? Switching between frameworks
    may not be cheap; it is a good idea to spend a little bit of time ensuring the
    one you choose is right for you in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. What the ideal use cases for adopting off-the-shelf injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, frameworks only support constructor injection. Off-the-shelf injection
    can, therefore, be used in projects that already use constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: '** 4\. Why is it important to protect your service from accidental API changes?**'
  prefs: []
  type: TYPE_NORMAL
- en: The API of a service is sometimes described as a contract. The word *contract*
    has been carefully chosen as it intends to convey how significant and binding
    the relationship is between the API and its users.
  prefs: []
  type: TYPE_NORMAL
- en: When we publish an API, we do not have control over how our users use our API
    and, perhaps more importantly, we have no control over how their software reacts
    to changes in our API. For us to deliver on our contract, it is imperative that
    we do everything we can to ensure we do not break their software by making unplanned
    changes to our API.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11, Curbing Your Enthusiasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. What form of dependency injection-induced damage do you see most often?**'
  prefs: []
  type: TYPE_NORMAL
- en: For me, this is absolutely *excessive parameters*. After learning dependency
    injection and getting excited about it, it's easy to want to abstract and inject
    everything. It tends to make testing a lot easier as the *responsibility* of each
    object decreases. The downside is a lot of objects and too much injection.
  prefs: []
  type: TYPE_NORMAL
- en: If I find myself with too many dependencies, I will try to step back and check
    my object design, looking for single responsibility principle issues in particular.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Why is it important not to blindly apply dependency injection all the
    time?**'
  prefs: []
  type: TYPE_NORMAL
- en: Just because something is *cool* or new, doesn't mean it's the best tool for
    the job. We should always strive to fix the solution to the problem and avoid
    *c**argo cult* programming when we can.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Does adopting a framework, such as Google Wire, eliminate all forms of
    dependency injection-induced damage?**'
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, no. Given that it only supports constructor injection, it cannot even
    be applied in all situations. Beyond that, it can make the management of *excessive
    parameters* significantly less painful.
  prefs: []
  type: TYPE_NORMAL
- en: While that is a good thing, the fact that it alleviates the pain makes it less
    likely that we will feel the need to address the underlying issue.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12, Reviewing Our Progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. What was the most important improvement made to our sample service?**'
  prefs: []
  type: TYPE_NORMAL
- en: This is subjective, and as such, there is no right answer. For me, it's either
    the decoupling or the removal of the globals. When the code becomes decoupled,
    it becomes easier for me test and each piece becomes a bite-sized chunk, which
    means it's easy to work on. Basically, I don't have to think too hard or remember
    too much context.
  prefs: []
  type: TYPE_NORMAL
- en: As to the globals, I've been bitten by this in the past, particularly the data
    races that happen during testing. I can't stand it when my tests are not reliable.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. In our dependency graph, why isn''t the data package under main?**'
  prefs: []
  type: TYPE_NORMAL
- en: We could refactor to make it this way, but at the moment we are using JIT injection
    between the model and data layers. This means the UX of the code is improved,
    but the dependency graph is not as flat as it could be. The data layer is also
    outputting DTOs instead of base data types, so any users will also be using the
    data package.
  prefs: []
  type: TYPE_NORMAL
- en: If we were determined to remove this as well, we could make a special package
    for the DTO and then exclude that package from the dependency graph, but that's
    extra work that does not gain us much as this point.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. What would you do differently if you were starting a new service?**'
  prefs: []
  type: TYPE_NORMAL
- en: This is subjective, and as such, there is no right answer. After doing the UX
    survey, I would first write enough code to get a web server started, even if this
    was not yet using dependency. I would then design all of the endpoints and implement
    them with hard-coded responses. This would give me the ability to discuss, with
    examples, my deliverables with the users. I would also be able to put in some
    end-to-end tests to prevent any API regression.
  prefs: []
  type: TYPE_NORMAL
- en: My users would then be able to go ahead, with confidence and clarity about my
    API, and I would be able to *fill in the details*.
  prefs: []
  type: TYPE_NORMAL
