- en: '*Chapter 15*: Arrays, Maps, and Random Numbers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Java arrays, which allow us to manipulate
    a potentially huge amount of data in an organized and efficient manner. We will
    also use a close Java relation to arrays, `ArrayList`, and look at the differences
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are comfortable handling substantial amounts of data, we will see what
    the Android API has to offer to help us easily connect our newfound data-handling
    skills to the user interface without breaking a sweat.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Random` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays mini-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic arrays including a mini-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional arrays including a mini-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ArrayList` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enhanced `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java HashMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's learn about the `Random` class.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2015](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2015).
  prefs: []
  type: TYPE_NORMAL
- en: A random diversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in our apps we will want a random number, and Java provides us with
    the `Random` class for these occasions. There are many possible uses for this
    class. For instance, maybe our app wants to show a random tip of the day, or is
    a game that has to choose between scenarios, or is a quiz that asks random questions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Random` class is part of the Java API and is fully compatible with our
    Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we can create random numbers, and later in the chapter
    we will put it to practical use. All the hard work is done for us by the `Random`
    class. First, we need to create an object of type `Random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use our new object''s `nextInt` method to generate a random number
    in a certain range. This next line of code generates the random number using our
    `Random` object and stores the result in the `ourRandomNumber` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The number that we enter for the range starts from zero. So, the preceding
    line will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `Random` object to get other types of random numbers using
    the `nextLong`, `nextFloat`, and `nextDouble` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will put the `Random` class to practical use later in the chapter with a
    quick geography quiz app.
  prefs: []
  type: TYPE_NORMAL
- en: Handling large amounts of data with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering what happens when we have an app with lots of variables
    to keep track of. What about our Note to Self app with 100 notes or a high score
    table in a game with the top 100 scores? We could declare and initialize 100 separate
    variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Straight away, this might seem unwieldy, but what about when someone gets a
    new top score or we want to let our users sort the order that their notes are
    displayed in? Using the high scores scenario, we must shift the scores in every
    variable down one place. A nightmare begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There must be a better way. When we have a whole array of variables, what we
    need is a Java array. An array is a reference variable that holds up to a pre-determined,
    fixed maximum number of elements. Each element is a variable with a consistent
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code declares an array that can hold `int` type variables, perhaps
    a high score table or a series of exam grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also declare arrays of other types, including classes such as `Note`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these arrays would need to have a fixed maximum amount of storage space
    allocated before it was used. Just like other objects, we must initialize arrays
    before we use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allocates up to a maximum of 100 `int`-sized storage spaces.
    Think of a long aisle of 100 consecutive storage spaces in our memory warehouse
    analogy. The spaces would probably be labeled `intArray[0]`, `intArray[1]`, `intArray[2]`,
    and so on, with each space holding a single `int` value. Perhaps the slightly
    surprising thing here is that the storage spaces start off at zero, not 1\. Therefore,
    in a 100-*wide* array, the storage spaces would run from 0 to 99\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could initialize the values in some of these storage spaces like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But note that we can only ever put the pre-declared type into an array, and
    the type that an array holds can never change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we have an array of `int` types, what are each of these `int` variables
    called? What are the names of these variables and how do we access the values
    stored in them? The array notation syntax replaces the variable names. And we
    can do anything with a variable in an array that we could do with a regular variable
    with a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code assigns the value `123` into the fourth position of `intArray`.
    Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code subtracts the value in the fifth position of `intArray`
    from the value in the tenth position and stores the answer in the eleventh position.
    We can also assign the value from an array to a regular variable of the same type,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that `myNamedInt` is a separate and distinct primitive variable
    and any changes to it do not affect the value stored in the `intArray` reference.
    It has its own space in the warehouse and is unconnected to the array. To be more
    specific, the array is on the heap and the `int` variable is on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said that arrays are reference variables. Think of an array variable as an
    address to a group of variables of a given type. Perhaps, using the warehouse
    analogy, `someArray` is an aisle number. So, `someArray[0]`, `someArray[1]`, and
    so on are the aisle numbers followed by the position number in the aisle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are also objects; that is, they have methods and properties that we
    can use. See this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we assigned the length of `someArray` to the `int` variable
    called `lengthOfSomeArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even declare an array of arrays. This is an array where in each of its
    elements lurks another array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding array, we could hold a list of cities within each country.
    Let''s not go array crazy just yet, though. Just remember that an array holds
    up to a pre-determined number of variables of any pre-determined type, and those
    values are accessed using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's use some arrays in a real app to try and get an understanding of how to
    use them in real code and what we might use them for.
  prefs: []
  type: TYPE_NORMAL
- en: Simple array example mini-app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make a simple working array example. You can get the completed code for
    this example in the downloadable code bundle. It's at [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Simple
    Array Example/MainActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project using the Empty Activity template and call it `Simple Array
    Example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare our array, allocate five spaces, and initialize values for
    each of the elements. Then we output each of the values to the logcat console.
    Add this code to the `onCreate` method just after the call to `setContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add each of the elements of the array together, just as we could regular
    `int` type variables. Notice that when we add the array elements together, we
    are doing so over multiple lines. This is fine as we have omitted a semicolon
    until the last operation, so the Java compiler treats the lines as one statement.
    Add the code we have just discussed to `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the example and see the output in the logcat window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that nothing will happen on the emulator display as all the output
    will be sent to our logcat console window in Android Studio. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We declared an array called `ourArray` to hold `int` variables, then allocated
    space for up to five of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assigned a value to each of the five spaces in our array. Remember
    that the first space is `ourArray[0]` and the last space is `ourArray[4]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we simply printed the value in each array location to the console, and
    from the output, we can see they hold the values we initialized them to be in
    the previous step. Then we added together each of the elements in `ourArray` and
    initialized their values to the `answer` variable. We then printed `answer` to
    the console and we can see that indeed all the values were added together, just
    as if they were plain old `int` types, which they are, just stored and accessed
    in a different manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting dynamic with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed at the beginning of all this array stuff, if we need to declare
    and initialize each element of an array individually, there isn't a huge amount
    of benefit to an array over regular variables. Let's look at an example of declaring
    and initializing arrays dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic array example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make a simple dynamic array example. You can get the working project for
    this example in the download bundle. It is at [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Dynamic
    Array Example/MainActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project using the Empty Activity template and call it `Dynamic Array
    Example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code just after the call to the `setContentView` method
    in the `onCreate` method. See whether you can work out what the output will be
    before we discuss it and analyze the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the example app, remembering that nothing will happen on the screen as
    all the output will be sent to our logcat console window in Android Studio. Here
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we declared and allocated an array called `ourArray` to hold up to 1,000
    `int` values. Notice that this time we did the two steps in one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we used a `for` loop that was set to loop 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialized the spaces in the array, from 0 through to 999, with the value
    of `i` multiplied by 5, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to demonstrate the value of `i` and the value held in each position of
    the array, we output the value of `i` followed by the value held in the corresponding
    position in the array, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And all this happened 1,000 times, producing the output we have seen. Of course,
    we have yet to use this technique in a real-world app, but we will use it soon
    to make our Note to Self app hold an almost infinite number of notes.
  prefs: []
  type: TYPE_NORMAL
- en: Entering the nth dimension with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We very briefly mentioned that an array can even hold other arrays at each position.
    But if an array holds lots of arrays that hold lots of some other type, how do
    we access the values in the contained arrays? And why would we ever need this
    anyway? Look at this next example of where multidimensional arrays can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional array mini-app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make a simple multidimensional array example. You can get the working
    project for this example in the download bundle. It is in [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Multidimensional
    Array Example/MainActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project using the Empty Activity template and call it `Multidimensional
    Array Example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the call to `setContentView` in `onCreate`, add the following code, including
    declaring and initializing a two-dimensional array (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we output the contents of the array using a `for` loop and our `Random`
    object. Note how we ensure that although the question is random, we can always
    pick the correct answer. Add the following code after the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the example, remembering that nothing will happen on the screen as all
    the output will be sent to our logcat console window in Android Studio. Here is
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What just happened? Let's go through this chunk by chunk so we know exactly
    what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a new object of type `Random` called `randInt`, ready to generate random
    numbers later in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a simple `int` variable to hold a question number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we declare our array of arrays called `countriesAndCities`. The outer
    array holds arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we allocate space within our arrays. The first outer array will now be
    able to hold five arrays and each of the inner arrays will be able to hold two
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we initialize our arrays to hold countries and their corresponding capital
    cities. Notice with each pair of initializations that the outer array number stays
    the same, indicating that each country/capital pair is within one inner array,
    a `String` array. And of course, each of these inner arrays is held in one element
    of the outer array (which holds arrays):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the upcoming `for` loop clearer, we declare and initialize `int` variables
    to represent the country and the capital from our arrays. If you glance back at
    the array initialization, all the countries are held in position `0` of the inner
    array and all the corresponding capital cities are at position `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set up a `for` loop to run three times. Note that this does not simply
    access the first three elements of our array; it just determines the number of
    times we go through the loop. We could make it loop one time or a thousand times;
    the example would still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we determine which question to ask – or more specifically, which element
    of our outer array. Remember that `randInt.nextInt(5)` returns a number between
    0 and 4 – just what we need, as we have an outer array with five elements, 0 through
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can ask a question by outputting the strings held in the inner array,
    which in turn is held by the outer array that was chosen in the previous line
    by the randomly generated number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For the record, we will not be using any multidimensional arrays in the rest
    of this book. So, if there is still a little bit of murkiness around these arrays
    inside arrays, then that doesn't matter. You know they exist, what they can do,
    and you can revisit them if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Array-out-of-bounds exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array-out-of-bounds exception occurs when we attempt to access an element
    of an array that does not exist. Sometimes the compiler will catch it for us to
    prevent the error going into a working app. For example, see this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way we can avoid this problem is to know the rule: the rule that arrays
    start at zero and go up to their length – 1\. We can also use clear, readable
    code where it is easy to evaluate what we have done and spot problems more easily.'
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ArrayList` is like a regular Java array on steroids. It overcomes some of
    the shortfalls of arrays, such as having to predetermine the size. It adds some
    useful methods to make its data easy to manage and it uses an enhanced version
    of a `for` loop that is clearer to use than a regular `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code that uses an `ArrayList` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we declared and initialized a new `ArrayList` called
    `myList`. We can also do this in a single step like this code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing especially interesting so far, so let''s take a look at what we can
    actually do with `ArrayList`. Let''s use a `String ArrayList` instance this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we saw that we can use some really useful methods of
    the `ArrayList` class on our `ArrayList` object; those methods are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can add an item (`myList.add`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add at a specific location (`myList.add(x, value)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether `ArrayList` is empty (`myList.isEmpty`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how many elements it has (`myList.size()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the current position of a given item (`myList.indexOf`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are even more methods in the `ArrayList` class and you can read about
    them here: http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html.
    What we have seen so far is enough to complete this book, however.'
  prefs: []
  type: TYPE_NORMAL
- en: With all this functionality, all we need now is a way to handle `ArrayList`
    instances dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: The enhanced for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is what the condition of an enhanced `for` loop looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The previous example would iterate (step through) all of the items in `myList`
    one at a time. At each step, `s` would hold the current `String` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this code would print to the console all of our eminent programmers from
    the previous section''s `ArrayList` code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the enhanced `for` loop with regular arrays too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's another incoming news flash!
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and ArrayList instances are polymorphic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that we can put objects into arrays and `ArrayList`. But being
    polymorphic means they can handle objects of multiple distinct types as long as
    they have a common parent type all within the same array or `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented
    Programming*, we learned that polymorphism means *different forms*. But what does
    it mean to us in the context of arrays and `ArrayList`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Boiled down to its simplest: any subclass can be used as part of the code that
    uses the superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have an array of `Animal` instances, we could put any object
    that is a type that is a subclass of `Animal` in the `Animal` array – perhaps
    `Cat` and `Dog` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can write code that is simpler and easier to understand, and
    easier to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can write code for the superclass and rely on the fact that no matter
    how many times it is sub-classed, within certain parameters the code will still
    work. Let''s continue our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But when we remove an object from a polymorphic array, we must remember to
    cast it to the type we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: All we have just discussed is true for `ArrayList` as well. Armed with this
    new tool kit of arrays, `ArrayList`, and the fact that they are polymorphic, we
    can move on to learn about some more Android classes that we will soon use to
    enhance our Note to Self app.
  prefs: []
  type: TYPE_NORMAL
- en: More Java collections – meet the Java HashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java `HashMap` is neat. It's part of the Java collections framework and
    a kind of cousin of the `ArrayList` class that we will use in the Note to Self
    project in the next chapter. They basically encapsulate useful data storage techniques
    that would otherwise be quite technical for us to code successfully for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: I thought it would be worth taking a first look at `HashMap` on its own. Suppose
    we want to store the data of lots of characters from a role-playing game and each
    different character is represented by an object of type `Character`.
  prefs: []
  type: TYPE_NORMAL
- en: We could use some of the Java tools we already know about, such as arrays or
    `ArrayList`. The Java `HashMap` is also like these things, but with `HashMap`
    we can give a unique key/identifier to each `Character` object and access any
    such object using that key/identifier.
  prefs: []
  type: TYPE_NORMAL
- en: The term hash comes from the process of turning our chosen key/identifier into
    something used internally by the `HashMap` class. The process is called hashing.
  prefs: []
  type: TYPE_NORMAL
- en: Any of our `Character` instances can then be accessed with our chosen key/identifier.
    A good candidate for a key/identifier in the `Character` class scenario would
    be the character's name.
  prefs: []
  type: TYPE_NORMAL
- en: Each key/identifier has a corresponding object; in this case, it is of type
    `Character`. This is known as a key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: We just give `HashMap` a key and it gives us the corresponding object. No need
    to worry about in which index we stored our characters, whether it's Geralt, Ciri,
    or Triss; just pass the name to `HashMap` and it will do the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples. You don't need to type any of this code – just
    get familiar with how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare a new `HashMap` to hold keys and `Character` instances like
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The previous code assumes we have coded a class called `Character`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize `HashMap` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a new key and its associated object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the example code assumes that we can somehow give the `Character` instances
    their unique properties to reflect their internal differences elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then retrieve an entry from `HashMap` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps we can use the `Character` class''s methods directly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The previous code calls the hypothetical `drawSilverSword` and `openFastTravelPortal`
    methods on the `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HashMap` class also has lots of useful methods, such as `ArrayList`. See
    the official Java page for `HashMap` here: [https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html](https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about the Note to Self app.
  prefs: []
  type: TYPE_NORMAL
- en: The Note to Self app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite all we have learned, we are not quite ready to apply a solution to the
    Note to Self app. We could update our code to store lots of notes in an `ArrayList`
    instance, but before we do, we also need a way to display the contents of `ArrayList`
    in the UI. It wouldn't look good to throw the whole `ArrayList` contents into
    a `TextView` widget, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is adapters and a special UI layout called `RecyclerView`. We will
    get to them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a computer that can only make *real* calculations possibly generate
    a genuinely random number?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In reality, a computer cannot create a number that is truly random, but the
    `Random` class uses a seed that produces a number that would stand up as genuinely
    random under close statistical scrutiny. To find out more about seeds and generating
    random numbers, look at this article: [https://en.wikipedia.org/wiki/Random_number_generation](https://en.wikipedia.org/wiki/Random_number_generation).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to use simple Java arrays to store substantial
    amounts of data provided it is of the same type. We also used the `ArrayList`
    class, which is like an array with loads of extra features. Furthermore, we found
    out that both arrays and `ArrayList` instances are polymorphic, which means that
    a single array (or `ArrayList`) can hold multiple different objects as long as
    they are all derived from the same parent class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned about the `HashMap` class, which is also a data storage
    solution but allows access in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the `Adapter` and `RecyclerView` classes
    to put our theory into practice and enhance the Note to Self app.
  prefs: []
  type: TYPE_NORMAL
