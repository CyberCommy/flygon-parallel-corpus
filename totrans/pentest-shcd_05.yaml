- en: Creating Shellcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get ready to dive deep into this topic where we will be using what we
    have learned so far to create simple, fully customized shellcodes. This will get
    even more adventurous when we face the obstacles that are bad characters and find
    ways of removing them. Moving on, we will see how to create advanced shellcodes
    and also create our shellcodes using the Metasploit Framework automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics and bad characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relative address technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execve syscall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind TCP shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse TCP shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating shellcode using Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, let's begin with what a shellcode is. As we have already seen earlier,
    the shellcode is a machine code that can be used as a payload to be injected in
    stack overflow attacks, which can be obtained from the assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what we have to do is simple: write what we want the shellcode to do as
    assembly, then perform some modifications, and convert it to a machine code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to make a hello world shellcode and convert an executable form to
    machine code. We need to use the `objdump` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Do you see what''s inside that red rectangular box? This is the machine code
    of our hello world example. But we need to convert it to this form: `\xff\xff\xff\xff`,
    where `ff` represents the operation code. You can do that manually line by line,
    but it would be somewhat tedious. We can do that automatically using just one
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try that with our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is our machine language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the following code for testing our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile it and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see from the preceding output that our shellcode didn't work. The reason
    was the bad characters in it. This takes us to the next section, which discusses
    ways to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Bad characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad characters are characters that can break the execution of a shellcode because
    they can be interpreted as something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider `\x00`, which means zero value, but it will be interpreted
    as a null terminator and will be used to terminate a string. Now, to prove that,
    let''s take another look at the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we tried to execute it, we got an error, `Shellcode Length: 14`. If you
    look at the 15^(th) operation code, you will see `\x00`, which is interpreted
    as a null terminator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of bad characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`00`: This is the zero value or null terminator (`\0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0A`: This is the line feed (`\n`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FF`: This is the form feed (`\f`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0D`: This is the carriage return (`\r`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, how to remove these bad characters from our shellcode? Actually, we can
    remove them using what we know so far in assembly, such as choosing which part
    of one register should depend on the size of the moved data. For example, if I
    want to move a small value such as `15` to RAX, we should use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use arithmetic operations, for example, to move `15`
    to the RAX register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at our machine code, one instruction at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first instruction is `mov rax, 1`, and it contains `0` because we were
    trying to move `1` byte (8 bits) to a 64-bit register. So it would fill the rest
    with zeros, which we can fix using `mov al, 1`,  so we moved `1` byte (8 bits)
    to an 8-bit part of the RAX register; let''s confirm that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We managed to remove all the bad characters from the first instruction. Let's
    try another method with the second instruction, which is using arithmetic operations
    such as adding or subtracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to clear the register using the `xor` instruction, `xor rdi,
    rdi`. Now, the RDI register contains zeros; we add `1` to its value, `add rdi,
    1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We fixed that too. Let''s fix all that and leave moving the `hello world` string
    to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.gif)'
  prefs: []
  type: TYPE_IMG
- en: We managed to remove all the bad characters from our shellcode, which leaves
    us with how to deal with addresses when copying strings.
  prefs: []
  type: TYPE_NORMAL
- en: The relative address technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The relative address is the current location relative to the RIP register, and
    relative value is a very good technique to avoid using hardcoded addresses in
    assembly.
  prefs: []
  type: TYPE_NORMAL
- en: How can we do that? Actually, it's made so simple by using `lea <destination>,
    [rel <source>]`, where the  `rel` instruction will compute the address of the
    source relative to the RIP register.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define our variable before the code itself, which in turn has to
    be defined before the RIP current location; otherwise, it will be a short value
    and the rest of the register will be filled with zeros like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s modify our shellcode with this technique to fix the location of
    the `hello world` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'No bad characters at all! Let''s try it as a shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now try to compile this shellcode and run it using our C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00189.gif)'
  prefs: []
  type: TYPE_IMG
- en: It worked! Now, this is our first shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to see more techniques on how to deal with addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The jmp-call technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will talk about a new technique on how to deal with the string's address,
    which is the **jmp-call** technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is simply to first make the `jmp` instruction to the string
    we want to move to a specific register. After that, we call the actual code using
    the `call` instruction, which pushes the string''s address to the stack, then
    we pop the address into that register. Take a look at the next example to fully
    understand this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'No bad characters; let''s now review what we did. First, we executed a `jmp`
    instruction to the string, then we called the actual code using the `call` instruction,
    which will cause the next instruction to be pushed into the stack; let''s see
    that code inside GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction is calling the code using the `call code` instruction.
    Notice what is going to happen in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The address of the `hello world` string is pushed into the stack and the next
    instruction is pop `rsi`, which moves the address of the `hello world` string
    from the stack to the RSI register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use it as a shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementing the same in C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00194.gif)'
  prefs: []
  type: TYPE_IMG
- en: The stack technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are going to learn another technique to deal with addresses using the
    stack. It's very simple, but we have two obstacles. First, we only allow 4 bytes
    to push into the stack in one operation—we will use registers to help us in this.
    Second, we have to push out strings into the stack in reverse—we will use Python
    to do that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to solve the second obstacle. Using Python, I''m going to define
    `string = ''hello world\n''`, then I will reverse my string and encode it to `hex`
    in one line using `string[::-1].encode(''hex'')`. Next, we will have our string
    in reverse and encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00195.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Done! Now, let''s try to solve the first obstacle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we push 8 bytes to the stack. We could push the rest into the stack
    divided by 4 bytes at each operation, but we also can use registers to move 8
    bytes in one operation and then push the content of that register into the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00196.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to use it as a shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That was easy too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to make a useful shellcode using the `execve`
    syscall.
  prefs: []
  type: TYPE_NORMAL
- en: The execve syscall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will learn how to make a useful shellcode using `execve`. Before we
    continue, we must understand what the `execve` syscall is. It's a syscall used
    to execute a program or a script. Let's take an example of how to use `execve`
    to read the `/etc/issue` file using the C language.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `execve` requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00198.gif)'
  prefs: []
  type: TYPE_IMG
- en: As it says, the first argument is the program we want to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument, `argv`, is a pointer to an array of arguments related to
    the program we want to execute. Also, `argv` should contain the program's name.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is `envp`, which contains whatever arguments we want to pass
    to the environment, but we can set this argument to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build C code to execute the `cat /etc/issue` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It gave us the content of the `/etc/issue` file, which is `Kali GNU/Linux Rolling
    \n \l`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to execute `/bin/sh` in assembly using the `execve` syscall.
    Here, I''m going to use the stack technique; let''s do this code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to use `NULL` as a sign of separation in the stack. Then, we
    move the stack pointer to RDX register to get our third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to push our path, which is `/bin/sh`, into the stack, and since
    we only have seven bytes and we don''t want any zeros in our code, let''s push
    `//bin/sh` or `/bin//sh`. Let''s reverse this string and encode it to `hex` using
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our string ready, let''s push it into the stack using any
    register, since it contains 8 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move RSP to the RDI register to get our first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to push another `NULL` as a string separation, then we need a
    pointer to our string by pushing RDI content, which is the address of our string
    to the stack. Then, we move the stack pointer to the RDI register to get the second
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all our arguments are ready; let''s get the `execve` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `execve` syscall number is `59`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put our code together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s convert it to a shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use C code to inject our shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: TCP bind shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's move further to do something really useful, which is building a TCP
    bind shell.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP bind shell is used to set up a server on a machine (victim), and that
    server is waiting for a connection from another machine (attacker), which allows
    the other machine (attacker) to execute commands on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at a bind shell in C language to understand how it
    really works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break it down into pieces to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we created a socket, which takes three arguments. The first argument
    is to define the protocol family, which is `AF_INET`, which represents IPv4 and
    can be represented in numeric form by `2`. The second argument is to specify the
    type of connection, and here, `SOCK_STREAM` represents TCP and can represented
    in numeric form by `1`. The third argument is the protocol and it''s set to `0`,
    which tells the operating system to choose the most appropriate protocol to use.
    Now let''s find the `socket` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the obtained output, the `socket` syscall number is `41`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the first part in assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output value, which is `sockfd`, will be stored in the RAX register; let''s
    move it to the RDI register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to the next part, which is filling the structure, `mysockaddr`, to be an
    input to the `bind` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We need it in the form of a pointer; also, we have to push to the stack in reverse
    order.
  prefs: []
  type: TYPE_NORMAL
- en: First, we push `0` to represent to bind to all interfaces (4 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we push the port in the form of `htons` (2 bytes). To convert our port
    to `htons`, we could use Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here is our port (`1234`) in `htons` form (`0xd204`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, we push the value `2`, which represents `AF_INET` (2 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Having our structure set, let''s prepare the `bind` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bind` function takes three arguments. The first one is `sockfd`, which
    is already stored in the RDI register; the second is our structure in the form
    of a reference; and the third is the length of our structure, which is `16`. Now
    what''s left is to get the `bind` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can see that the `bind` syscall number is
    `49`; let''s create the `bind` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set the `listen` function, which takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is `sockfd`, which we have stored already in the RDI register.
    The second argument is a number, which represents the maximum number of connections
    the server can accept, and here, it allows only one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s get the `listen` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s build the `bind` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll move on to next function, which is `accept`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `accept` function takes three arguments. The first is `sockfd`, and again,
    it is already stored in the RDI register; we can set the second and the third
    arguments to zero. Let''s get the `accept` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `accept` function, which is ; `clientfd`, will be stored
    in the RAX register, so let''s move that to a safer place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `dup2` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will execute it three times to duplicate our file descriptor to `stdin`,
    `stdout`, and `stderr`, which take (`0`, `1`, `1`), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dup2` syscall takes two arguments. The first argument is the old file
    descriptor—in our case, it is `clientfd`. The second argument is our new file
    descriptors (`0`, `1`, `2`). Now, let''s get the `dup2` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s build the `dup2` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add our `execve` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, everything is ready; let''s put all the pieces together in one code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assemble and link it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s convert it to a shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s inject it into our C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile it and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00212.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now our shellcode is working and waiting; let''s confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s listening now on port `1234`; now, from another Terminal window, start
    `nc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00214.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it''s connected and waiting for our commands; let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00215.gif)'
  prefs: []
  type: TYPE_IMG
- en: Now we have our first real shellcode!
  prefs: []
  type: TYPE_NORMAL
- en: Reverse TCP shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create another useful shellcode, which is the reverse
    TCP shell. A reverse TCP shell is the opposite of the bind TCP, as the victim's
    machine establishes a connection to the attacker again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s have a look at it in C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: First, we will compile and execute this on one of our victim machines (Ubuntu).
    We will set up a listener on the attacking machine (Kali), and the shell will
    connect back from Ubuntu to Kali by adding Kali's IP in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a listener on Kali using the `nc` command or the `netcat` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, let''s compile and run our `reverse-tcp` shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Back to my Kali again—I'm connected!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00216.gif)'
  prefs: []
  type: TYPE_IMG
- en: That was simple!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's build up a reverse TCP shell in assembly, and then convert it into
    a shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `socket` function is exactly as we explained in bind TCP. Move the output
    of the `socket` to the RDI register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is filling the `mysockaddr` structure, except that we have to push out
    the attacker''s IP address in 32-bit packed format. We will do that using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00217.gif)'
  prefs: []
  type: TYPE_IMG
- en: So our IP address in 32-bit packed format is `01eea8c0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our structure and move the stack pointer to RSI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build the `connect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00218.gif)'
  prefs: []
  type: TYPE_IMG
- en: The `connect` function also takes three arguments. The first argument is `sockfd`
    (the output from the `socket` function), which is stored in the RDI register.
    The second is a reference to our structure, which is stored in the RSI register.
    The third argument is the size of our structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the `connect` syscall number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00219.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'From the obtained output, we can see that the syscall number is `42`. Now,
    let''s build the `connect` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `dup2` function is the same except that the first argument will be `sockfd`,
    which is already stored in the RDI register; let''s build that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the final part, which is the `execve` syscall for `/bin/sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s pack them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assemble and link it to our victim machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, on our attacker machine run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, back again to our victim machine and run our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, on our attacker machine, we are connected to our victim machine (Ubuntu):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00220.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s convert it to a shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s copy this machine language into our C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile it on our victim machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set up a listener on our attacker machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set up a listener on our victim machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are connected to our attacker machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00223.gif)'
  prefs: []
  type: TYPE_IMG
- en: We did it!
  prefs: []
  type: TYPE_NORMAL
- en: Generating shellcode using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, things are simpler than you think. We will generate shellcodes using Metasploit
    for multiple platforms with multiple architectures, and remove bad characters
    in one command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `msfvenom` command. Let''s show all the options using `msfvenom
    -h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00224.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s list all of its payloads using `msfvenom -l`—and it''s a very big list
    of payloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00225.gif)'
  prefs: []
  type: TYPE_IMG
- en: This is just a small section from that list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our output formats using `msfvenom --help-formats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to create bind TCP shellcode on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have here is simple: `-a` to specify the arch, then we specified the
    platform as Linux, then we selected our payload to be `linux/x64/shell/bind_tcp`,
    then we removed bad characters, `\x00`, using the `-b` option, and finally we
    specified the format to C. Let''s execute to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, copy that shellcode to our C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy it to our victim machine. Now, compile it and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s waiting for the connection. Now, let''s set up our listener on the attacker
    machine using the Metasploit Framework with the `msfconsole` command, and then
    choose the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we select our payload using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we specify our victim machine''s IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we specify the port—the default port for Metasploit is `4444`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run our handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It says that the session is active on `session 1`. Let''s activate this session
    using `session 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It worked!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through how to create simple shellcodes and how to
    remove bad characters. We moved on to use `execve` for system commands. Then,
    we built advanced shellcode, such as bind TCP shell and reverse TCP shell. Finally,
    we saw how to use the Metasploit Framework to build shellcodes in one line and
    how to set up a listener using Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: We now know exactly how to build a payload, so we'll see how to use them. In
    the next chapter, we will talk about buffer overflow attacks.
  prefs: []
  type: TYPE_NORMAL
