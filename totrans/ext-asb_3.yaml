- en: Chapter 3. Digging Deeper into Ansible Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having already learned the basics, this chapter will take you through more
    advanced topics in Ansible such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Making modules support safe execution in dry run mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how arguments are parsed in an Ansible module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling complex arguments and data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real life scenario where you can exploit the power of Ansible by creating
    a custom module to suit your needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dry run (check mode)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you decided to write your own module which makes a few configuration changes
    to the system based on the user input. Considering the code has to be run on production,
    being able to run a simulation of your yet to be published configuration is quite
    important. Not only is it likely that you'll want to know if your configurations
    are actually correct before applying them, but you might also want to understand
    what changes the playbook execution will entail.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible does not know the consequences of a module's execution, it just
    follows instructions from the playbook. In the dry run mode, it will simply print
    out all the modules it will execute and skip the actual execution. If the module
    does not support check mode, the module is simply skipped in check mode during
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: It's useful to show details of any changes a module makes in the state of the
    system or target machine. However, Ansible can only know that by asking the module
    to perform a simulation and return with a confirmation on a state change. There
    may be some tasks in your Ansible playbook that use some modules that return an
    output. These might be stored in variables, and the following module execution
    depends on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to tell Ansible that the module supports check mode and it''s safe
    to run in dry run mode, all that is required is to set a `supports_check_mode`
    flag to true in the Ansible module. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code in a module enables a module to be executed in dry run mode.
    You can run your Ansible playbook in check mode using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will do a dry run for all the modules that support check mode and report
    back any changes that would be made on the target machine without actually making
    the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Loading modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into writing Ansible modules, it is necessary to understand how
    Ansible loads modules during runtime. Understanding how modules are loaded into
    Ansible allows you to understand the code flow and debug issues that might occur
    at runtime. To understand this, you must understand how an Ansible playbook is
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know, Ansible playbooks are executed using the `ansible-playbook`
    binary, which accepts a few arguments such as the inventory file and the Ansible
    play to run. If you take a look at the source code of `ansible-playbook`, you
    will notice the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `constants.py` file is one of the major files that loads configurations
    into Ansible. It contains various configurations such as the default path where
    modules and plugins will be loaded into Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file is responsible for defining the order in which the configurations
    will be loaded by Ansible. The default order in which the configurations are loaded
    into Ansible is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ENV**: Environment variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CWD**: Current working directory (the directory where the Ansible playbook
    is executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**HOME**: Configurations are then loaded from the configuration file in the
    home directory of the user. This configuration file is named `~/.ansible.cfg`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Global configuration file**: Ansible places a global configuration file in
    `/etc/ansible/ansible.cfg`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ansible uses the configuration that is found first in the preceding order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file also sets in a few default configuration values that are required
    for Ansible to execute a playbook. Some of these default configuration values
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forks`: The default number of forks is set to `5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_user`: This is set to active user on the controller node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private_key_file`: Sets the default private key to be used to communicate
    to the target hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timeout`: The default value is set to `10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced you to the `AnsibleModule` boilerplate, which
    allowed you to write your own Ansible modules, accept arguments, and return results.
    Before moving on to developing an Ansible module, this section will explore the
    `AnsibleModule` boilerplate in detail from the code level.
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into the AnsibleModule boilerplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AnsibleModule` boilerplate, as discussed in the previous chapter, can be
    used by simply importing `ansible.module_utils.basic` statement.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you create an object for the `AnsibleModule` class, a few properties
    are set for the object, including the `argument_spec` property as specified while
    creating the `AnsibleModule` object. By default, `supports_check_mode` property
    is set to `false`, and `check_invalid_arguments` is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnsibleModule` class loads the arguments and parameters into the `params`
    variable using the `load_params` method. The following is the source code for
    the `load_params` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `params` is a dictionary. Python allows you to read values corresponding
    to a key in a dictionary by using the `get` method. Thus, if you need to access
    any argument, you can simply use the `get` method on the `params` dictionary variable.
    This is how Ansible reads and accepts arguments in a module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to develop a module, accept arguments, and handle
    errors, let's implement this knowledge in a real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's say you have a huge infrastructure at your dispense, which is working
    great. You have a great configuration management system in place, as well as a
    monitoring system that keeps a track of all the machines and notifies you in case
    of failure. Everything is working fine, when one fine day, you need to audit your
    infrastructure. You need details of each and every machine such as BIOS details,
    system specifications like manufacturer and serial numbers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A simple solution is to run `dmidecode` on each machine and collate the gathered
    data. Well, running `dmidecode` on individual machines and collating the details
    is a pain. Let's exploit the power of Ansible to deal with this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to create a module, you can use the Python library for `dmidecode`
    and write a module of your own, which can then be run on your whole infrastructure.
    The added advantage is you can have the data in machine parsable form, say JSON,
    which can later be used to generate reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s name the module `dmidecode` and place it in the `library` directory
    in the root of the Ansible playbook. The following is the source code for the
    `dmidecode` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are collecting data such as processor specs, BIOS specs,
    and system specs; you can always extend the module based on your personal needs.
  prefs: []
  type: TYPE_NORMAL
- en: The module accepts a Boolean argument, `save`, from the user, which, if set
    to `true`, will write the result to a JSON file on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the module has an import line, `import dmidecode`, at the
    beginning. The statement imports the `dmidecode` Python library. The library is
    provided by the `python-dmidecode` package. Since the module depends on the `dmidecode`
    Python library, this is required to be installed on the target machine. This can
    be handled in the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies can be specified in the `global_vars` file and can be used by
    the variable name in the Ansible playbook. This is done to prevent making changes
    to the Ansible play in case there is a change in the dependency. This can be specified
    in the `global_vars` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`global_vars/all`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, the Ansible module is ready and the dependencies are taken care of. You
    will now have to create the Ansible play, which will execute the `dmidecode` module
    on the target machines. Let's name the Ansible `play dmidecode.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Executing the Ansible playbook will run the `dmidecode` module on the remote
    host group. Since `save` is set to `true`, this will create a `dmidecode.json`
    file on the remote host containing the required information.
  prefs: []
  type: TYPE_NORMAL
- en: Complex arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Ansible module is just another code that can accept and parse arguments,
    there might be a question of whether it's capable of handling complex variable
    sets. Although Ansible is used as a deployment, orchestration, and configuration
    management tool, it is designed to handle simple arguments, and it is still capable
    of handling complex variables. This is an advanced topic, and since this is not
    generally used, this section will cover it in brief.
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned how to pass arguments to an Ansible module. However,
    complex arguments are handled differently.
  prefs: []
  type: TYPE_NORMAL
- en: Reading complex arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take an example of the complex variable, `complex_var`, which, as usual,
    we define in `group_vars/all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding variable is of the dictionary type (that is a key value pair).
    For an Ansible module to parse this kind of argument, we need to make a few changes
    in the way complex variables are passed in the module and the way they are parsed.
    We write a custom module that accepts this complex variable as an argument and
    prints the values for the associated keys. We name the module `complex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `complex.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible Module:** `library/complex.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding module accepts the complex variable and prints their associated
    values for the respective keys. The way complex variables are passed to the Ansible
    module is specified in the Ansible play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Ansible playbook, which takes in complex arguments and
    passes them on to the complex module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible play:** `complex.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible playbook, when executed, prints the values associated with the keys
    `key0` and `key1`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about making your module support dry runs by introducing
    the `supports_check_mode` flag. You also learned how arguments are handled in
    Ansible. The chapter covered a real-life scenario where a custom Ansible module
    was used to perform a hardware audit on the infrastructure. The chapter also covered
    in brief how complex variables are handled with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about Ansible plugins, why are they needed,
    and how they fit in the general Ansible structure. The chapter will also cover
    the Python plugin API.
  prefs: []
  type: TYPE_NORMAL
