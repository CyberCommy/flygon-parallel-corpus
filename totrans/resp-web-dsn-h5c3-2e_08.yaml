- en: Chapter 8. Transitions, Transformations, and Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Historically, whenever elements needed to be moved or animated around the screen,
    it was the sole domain of JavaScript. Nowadays, CSS can handle the majority of
    motion jobs via three principal agents: CSS transitions, CSS transforms, and CSS
    animations. In fact, only transitions and animations are directly related to motion,
    transforms simply allow us to change elements, but as we shall see, they are often
    integral to successful motion effects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To clearly understand what each of these things is responsible for, I will
    offer this, perhaps overly simplistic summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a CSS transition when you already have the beginning and end state of the
    things you want to apply motion to, and need a simple way to 'tween' from one
    state to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a CSS transform if you need to visually transform an item, without affecting
    the layout of the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a CSS animation if you want to perform a series of changes to an element
    at various key points over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right, so we had better crack on and get our heads around how we can wield
    all these capabilities. In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What CSS3 transitions are and how we can use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a CSS3 transition and its shorthand syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS3 transition timing functions (`ease`, `cubic-bezier`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fun transitions for responsive websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What CSS3 transforms are and how we can use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding different 2D transforms (`scale`, `rotate`, `skew`, `translate`,
    and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding 3D transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to animate with CSS3 using `keyframes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What CSS3 transitions are and how we can use them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitions are the simplest way to create some visual 'effect' between one
    state and another with CSS. Let's consider a simple example, an element that transitions
    from one state to another when hovered over.
  prefs: []
  type: TYPE_NORMAL
- en: When styling hyperlinks in CSS, it's common practice to create a hover state;
    an obvious way to make users aware that the item they are hovering over is a link.
    Hover states are of little relevance to the growing number of touch screen devices
    but for mouse users, they're a great and simple interaction between website and
    user. They're also handy for illustrating transitions, so that's what we will
    start with.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, using only CSS, hover states are an on/off affair. There is one
    set of properties and values on an element as the default, and when a pointer
    is hovered over that element, the properties and values are instantly changed.
    However, CSS3 transitions, as the name implies, allow us to transition between
    one or more properties and values to other properties and values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A couple of important things to know up front. Firstly, you can''t transition
    from `display: none;`. When something is set to `display: none;` it isn''t actually
    ''painted'' on the screen so has no existing state you can transition from. In
    order to create the effect of something fading in, you would have to transition
    opacity or position values. Secondly, not all properties can be transitioned.
    To ensure you''re not attempting the impossible, here is the list of transitionable
    (I know, it''s not even a word) properties: [http://www.w3.org/TR/css3-transitions/](http://www.w3.org/TR/css3-transitions/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open up `example_08-01` you''ll see a few links in a `nav`. Here''s
    the relevant markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the relevant CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the two states, first the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What CSS3 transitions are and how we can use them](img/3777_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then here''s the hover state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What CSS3 transitions are and how we can use them](img/3777_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, when the link is hovered over, we add a red box-shadow at
    the bottom (I chose a box-shadow as it won''t affect the layout of the link like
    a border might). Ordinarily, hovering over the link snaps from the first state
    (no red line) to the second (red line); it''s an on/off affair. However, this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adds a transition to the `box-shadow` from the existing state to the hover state
    over 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll notice in the CSS of the preceding example we're using the adjacent sibling
    selector `+`. This means if a selector (an anchor tag in our example) directly
    follows another selector (another anchor tag) then apply the enclosed styles.
    It's useful here as we don't want a left border on the first element.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the transition property is applied in the CSS to the original state
    of the element, not the state the element ends up as. More succinctly, apply the
    transition declaration on the 'from' state, not the 'to' state. This is so that
    different states such as `:active` can also have different styles set and enjoy
    the same transition.
  prefs: []
  type: TYPE_NORMAL
- en: The properties of a transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A transition can be declared using up to four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transition-property`: The name of the CSS property to be transitioned (such
    as `background-color`, `text-shadow`, or `all` to transition every possible property).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transition-duration`: The length of time over which the transition should
    occur (defined in seconds, for example `.3s`, `2s`, or `1.5s`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transition-timing-function`: How the transition changes speed during the duration
    (for example `ease`, `linear`, `ease-in`, `ease-out`, `ease-in-out`, or `cubic-bezier`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transition-delay`: An optional value to determine a delay before the transition
    commences. Alternatively, a negative value can be used to commence a transition
    immediately but part way through its transition ''journey''. It''s defined in
    seconds, for example, `.3s`, `1s`, or `2.5s`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Used separately, the various transition properties can be used to create a
    transition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The transition shorthand property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can roll these individual declarations into a single, shorthand version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One important point to note when writing the shorthand version is that the first
    time related value is given is always taken to be the `transition-duration`. The
    second time related value is taken to be the `transition-delay`. The shorthand
    version is the one I tend to favor as I generally only need to define the duration
    of the transition and the properties that should be transitioned.
  prefs: []
  type: TYPE_NORMAL
- en: It's a minor point, but only define the property or properties you actually
    need to transition. It's really handy to just set `all` but if you only need to
    transition the opacity, then only define the opacity as the transition property.
    Otherwise you're making the browser work harder than necessary. In most cases
    this isn't a big deal but if you're hoping to have the best performing site possible,
    especially on older devices, then every little helps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transitions are very well supported but, as ever, ensure you have a tool like
    Autoprefixer set up to add any vendor prefixes relevant to the browsers you need
    to support. You can also check which browsers support the various capabilities
    at [caniuse.com](http://caniuse.com).
  prefs: []
  type: TYPE_NORMAL
- en: '**The short version:**'
  prefs: []
  type: TYPE_NORMAL
- en: Transitions and 2D transforms work everywhere apart from IE9 and below, 3D transforms
    work everywhere except IE9 and below, Android 2.3 and below, and Safari 3.2 and
    below.
  prefs: []
  type: TYPE_NORMAL
- en: Transition different properties over different periods of time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where a rule has multiple properties declared you don''t have to transition
    all of them in the same way. Consider this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we have specified with the `transition-property` that we'd like to transition
    the `border`, `color`, and `text-shadow`. Then with the `transition-duration`
    declaration, we are stating that the border should transition over 2 seconds,
    the color over 3 seconds, and the text-shadow over 8 seconds. The comma-separated
    durations match the comma-separated order of the transition properties.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding timing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you declare a transition, the properties, durations, and delays are relatively
    simple to understand. However, understanding what each timing function does can
    be a little trickier. Just what do `ease`, `linear`, `ease-in`, `ease-out`, `ease-in-out`,
    and `cubic-bezier` actually do? Each of them is actually a pre-defined cubic-bezier
    curve, essentially the same as an easing function. Or, more simplistically, a
    mathematical description of how the transition should look. It's generally easier
    to visualize these curves so I recommend you head over to [http://cubic-bezier.com/](http://cubic-bezier.com/)
    and [http://easings.net/](http://easings.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Both these sites let you compare timing functions and see the difference each
    one makes. Here is a screenshot of [http://easings.net](http://easings.net)—you
    can hover over each line for a demonstration of the easing function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding timing functions](img/3777_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, even if you can write your own cubic-bezier curves blindfolded, the
    likelihood is, for most practical situations, it makes little difference. The
    reason being that, like any enhancement, it's necessary to employ transition effects
    subtly. For 'real world' implementations, transitions that occur over too great
    a period of time tend to make a site feel slow. For example, navigation links
    that take 5 seconds to transition are going to frustrate, rather than wow your
    users. The perception of speed is incredibly important for our users and you and
    I must concentrate on making websites and applications feel as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, unless there is a compelling reason to do so, using the default transition
    (ease) over a short interval is often best; a maximum of 1 second is my own preference.
  prefs: []
  type: TYPE_NORMAL
- en: Fun transitions for responsive websites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did you ever have one of those occasions growing up when one parent was out
    for the day and the other parent said something to the effect of, "OK, while your
    mom/dad are out we're going to put sugar all over your breakfast cereal but you
    have to promise not to tell them when they come back"? I'm certainly guilty of
    that with my little ankle biters. So here's the thing. While no one is looking,
    let's have a bit of fun. I don't recommend this for production, but try adding
    this to your responsive project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the CSS universal selector `*` to select everything and then
    setting a transition on all properties for 1 second (1s). As we have omitted to
    specify the timing function, ease will be used by default and there will be no
    delay as again, a default of 0 is assumed if an alternative value is not added.
    The effect? Well, try resizing your browser window and most things (links, hover
    states, and the like) behave as you would expect. However, because everything
    transitions, it also includes any rules within media queries, so as the browser
    window is resized, elements sort of flow from one state to the next. Is it essential?
    Absolutely not! Is it fun to watch and play around with? Certainly! Now, remove
    that rule before your mom sees it!
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 2D transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite sounding similar, CSS transforms are entirely different to CSS transitions.
    Think of it like this: transitions smooth the change from one state to another,
    while transforms are defining what the element will actually become. My own (admittedly
    childish) way of remembering the difference is like this: imagine a transformer
    robot such as Optimus Prime. When he has changed into a truck he has transformed.
    However, the period between robot and truck is a transition (he''s transitioning
    from one state to another).'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if you have no idea who or what Optimus Prime even is, feel free
    to mentally discard the last few sentences. Hopefully all will become clear momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two groups of CSS3 transforms available: 2D and 3D. 2D variants are
    far more widely implemented, browser wise, and certainly easier to write so let''s
    look at those first. The CSS3 2D Transforms Module allows us to use the following
    transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scale`: Used to scale an element (larger or smaller)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translate`: Move an element on the screen (up, down, left, and right)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate`: Rotate the element by a specified amount (defined in degrees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skew`: Used to skew an element with its x and y co-ordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`: Allows you to move and shape transformations with pixel precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to remember that transforms occur outside of the document flow.
    Any element that is transformed will not affect the position of an element nearby
    that is not being transformed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try out the various 2D transitions. You can test each of these out by
    opening `example_08-02` in the browser. There's a transition applied to all of
    the transforms so you get a better idea of what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the syntax for `scale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Hovering over the ''scale'' link in our example produces this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scale](img/3777_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've told the browser that when this element is hovered over, we want the element
    to scale to 1.4 times its original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the values we''ve already used to enlarge elements, by using values
    below 1, we can shrink elements; the following will shrink the element to half
    its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Translate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the syntax for `translate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the effect that rule has in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Translate](img/3777_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `translate` property tells the browser to move an element by an amount,
    defined in either pixels or percentages. The first value is the *x* axis and the
    second value is the *y* axis. Positive values given within parentheses move the
    element right or down; negative values move it left or up.
  prefs: []
  type: TYPE_NORMAL
- en: If you only pass one value then it is applied to the *x* axis. If you want to
    specify just one axis to translate an element you can also use `translateX` or
    `translateY`.
  prefs: []
  type: TYPE_NORMAL
- en: Using translate to center absolutely positioned elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `translate` provides a really useful way to center absolutely positioned
    elements within a relatively positioned container. You can view this example at
    `example_08-03`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And then this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You've perhaps done something similar to this yourself. When the dimensions
    of the absolutely positioned element are known (200px x 200px in this case) we
    can use negative margins to 'pull' the item back to the center. However, what
    happens when you want to include content and have no way of knowing how tall it
    will be? Transform to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some random content into the inner box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using translate to center absolutely positioned elements](img/3777_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes, that problem! Right, let's use `transform` to sort this mess out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using translate to center absolutely positioned elements](img/3777_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `top` and `left` are positioning the inner box inside its container so
    that the top left corner of the inner box starts at a point 50% along and 50%
    down the outer. Then the `transform` is working on the inner element and positioning
    it negatively in those axis by half (-50%) of its own width and height. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: Rotate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rotate` transform allows you to rotate an element. Here''s the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, here''s what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotate](img/3777_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The value in parentheses should always be in degrees (for example, 90deg).
    While positive values always apply clockwise, using negative values will rotate
    the element counter-clockwise. You can also go crazy and make elements spin by
    specifying a value like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will rotate the element 10 times in a complete circle. Practical uses for
    this particular value are few and far between but you know, if you ever find yourself
    designing websites for a windmill company, it may come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Skew
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve spent any time working in Photoshop, you''ll have a good idea what
    `skew` will do. It allows an element to be skewed on either or both of its axes.
    Here''s the code for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting this on the hover link produces the following effect on hover:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skew](img/3777_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first value is the `skew` applied to the *x* axis (in our example, 40deg),
    while the second (12deg) is for the *y* axis. Omitting the second value means
    any value will merely be applied to the *x* axis (horizontal). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did somebody mention a completely over-rated film? No? What's that? You want
    to know about the CSS3 matrix, not the film? Oh, okay.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m not going to lie. I think the matrix transform syntax looks scary. Here''s
    our example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It essentially allows you to combine a number of other transforms (`scale`,
    `rotate`, `skew`, and so on) into a single declaration. The preceding declaration
    results in the following effect in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix](img/3777_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, I like a challenge like the best of them (unless, you know, it''s sitting
    through the *Twilight* films) but I''m sure we can agree that syntax is a bit
    testing. For me, things got worse when I looked at the specification and realized
    that it involved mathematics knowledge beyond my rudimentary level to fully understand:
    [http://www.w3.org/TR/css3-2d-transforms/](http://www.w3.org/TR/css3-2d-transforms/)'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you find yourself doing work with animations in JavaScript without the help
    of an animation library, you'll probably need to become a little more acquainted
    with the matrix. It's the syntax all the other transforms get computed into so
    if you're grabbing the current state of an animation with JavaScript, it will
    be the matrix value you will need to inspect and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix transformations for cheats and dunces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'm not a mathematician by any stretch of the imagination, so when faced with
    the need to create a matrix-based transformation, I cheat. If your mathematical
    skills are also found wanting, I'd suggest heading over to [http://www.useragentman.com/matrix/](http://www.useragentman.com/matrix/).
  prefs: []
  type: TYPE_NORMAL
- en: The Matrix Construction Set website allows you to drag and drop the element
    exactly where you want it and then includes good ol' copy and paste code(including
    vendor-prefixes) for your CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: The transform-origin property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notice how with CSS, the default transform origin (the point at which the browser
    uses as the center for the transform) is in the middle: 50% along the *x* axis
    and 50% along the *y* axis of the element. This differs from SVG which defaults
    to top left (or 0 0).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `transform-origin` property we can amend the point from which transforms
    originate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider our earlier matrix transform. The default `transform-origin` is ''50%
    50%'' (the center of the element). The Firefox developer tools show how the `transform`
    is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The transform-origin property](img/3777_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we adjust the `transform-origin` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can see the effect this has:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The transform-origin property](img/3777_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first value is the horizontal offset and the second value is the vertical
    offset. You can use keywords. For example, left is equal to 0% horizontal, right
    is equal to 100% horizontal, top is equal to 0% vertical, and bottom is equal
    to 100% vertical. Alternatively, you can use a length, using any of the CSS length
    units.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a percentage for the `transform-origin` values, then the horizontal/vertical
    offset is relative to the height/width of the elements bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a length, then the values are measured from the top-left corner of
    the elements bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: Full information on the `transform-origin` property can be found at [http://www.w3.org/TR/css3-2d-transforms/](http://www.w3.org/TR/css3-2d-transforms/).
  prefs: []
  type: TYPE_NORMAL
- en: That covers the essentials of 2D transforms. They are far more widely implemented
    than their 3D brethren and provide a far better means to move elements around
    the screen than older methods such as absolute positioning.
  prefs: []
  type: TYPE_NORMAL
- en: Read the full specification on CSS3 2D Transforms Module Level 3 at [http://www.w3.org/TR/css3-2d-transforms/](http://www.w3.org/TR/css3-2d-transforms/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more on the benefits of moving element with `transform`, here's a great
    post by Paul Irish ([http://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/](http://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/))
    that provides some good data.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, for a fantastic overview of how browsers actually deal with transitions
    and animations, and why transforms can be so effective, I highly recommend the
    following blog post: [http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/](http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/)'
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 3D transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at our first example. An element that flips when we hover over it.
    I've used hover here to invoke the change as it's simple for the sake of illustration,
    however the flipping action could just as easily be initiated with a class change
    (via JavaScript) or when an element received focus.
  prefs: []
  type: TYPE_NORMAL
- en: We will have two of these elements; a horizontal flipping element and a vertical
    flipping element. You can view the final example at `example_08-04`. Images fail
    to fully convey this technique but the idea is that the element flips from the
    green 'face' to the red 'face' and gives the illusion of doing so through 3D space
    with the aid of perspective. Here's a grab partway through the transition from
    green to red which hopefully conveys some of the effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS3 3D transformations](img/3777_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's also worth knowing that while positioning an element absolutely with top/left/bottom/right
    values operates pixel by pixel, a transform can interpolate at sub-pixel positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the markup for the flipping element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only difference with the horizontal one, markup wise is the `flipper-horizontal`
    class instead of `flipper-vertical`.
  prefs: []
  type: TYPE_NORMAL
- en: As the majority of the styles relate to aesthetics, we'll merely look at the
    essential ingredients in our styles to make the flipping effect possible. Refer
    to the full style sheet in the example for the aesthetic styles.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to set some perspective for the `.flipper-object` to flip
    within. For that we use the `perspective` property. This takes a length attempting
    to simulate the distance from the viewer's screen to the edge of the elements
    3D space.
  prefs: []
  type: TYPE_NORMAL
- en: If you set a low number like 20px for the perspective value, the 3D space of
    the element will extend right out to only 20px from your screen; the result being
    a very pronounced 3D effect. Setting a high number on the other hand, will mean
    the edge of that imaginary 3D space will be further away, and therefore produce
    a less pronounced 3D effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are positioning the outer element relatively to create a context for the
    `flipper-object` to be positioned within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides positioning the `.flipper-object` absolutely at the top left of its
    closest relatively positioned parent (the default position for absolutely positioned
    elements), we have set a transition for the transform. The key thing here, 3D
    wise, though is the `transform-styles: preserve-3d`. This tells the browser that
    when we transform this element, we want any children elements to preserve the
    3D effect.'
  prefs: []
  type: TYPE_NORMAL
- en: If we didn't set `preserve-3d` on the `.flipper-object`, we would never get
    to see the back (the red part) of the flipping element. You can read the specification
    for this property at [http://www.w3.org/TR/2009/WD-css3-3d-transforms-20090320/](http://www.w3.org/TR/2009/WD-css3-3d-transforms-20090320/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each ''panel'' in our flipping element needs positioning at the top of its
    container but we also want to make sure that if rotated, we don''t see the ''rear''
    of it (otherwise we would never see the green panel as it sits ''behind'' the
    red one). To do that we use the b`ackface-visibility` property. We set this to
    hidden so that the back face of the element is, you guessed it, hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I''ve found that `backface-visibility` actually has a few surprising side effects
    in some browsers. It''s particularly useful for improving the performance of fixed
    position elements on older Android devices. For more on this and why it does what
    it does, take a look at this post: [http://benfrain.com/easy-css-fix-fixed-positioning-android-2-2-2-3/](http://benfrain.com/easy-css-fix-fixed-positioning-android-2-2-2-3/)
    and this one: [http://benfrain.com/improving-css-performance-fixed-position-elements/](http://benfrain.com/improving-css-performance-fixed-position-elements/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we want to make our back panel flipped by default (so that when we flip
    the whole thing it will actually be in the correct position). To do that we apply
    a `rotate` transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now everything is in place, now all we want to do is flip the entire inner
    element when the outer one is hovered over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine there are a bazillion (by the way, that''s definitely not
    a real amount, I just checked) ways you can use these principals. If you''re wondering
    what a fancy navigation effect, or off-canvas menu, might look like with a spot
    of perspective, I highly recommend paying Codrops a visit: [http://tympanus.net/Development/PerspectivePageViewNavigation/index.html](http://tympanus.net/Development/PerspectivePageViewNavigation/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read about the latest W3C developments on CSS Transforms Module Level 1 at [http://dev.w3.org/csswg/css-transforms/](http://dev.w3.org/csswg/css-transforms/).
  prefs: []
  type: TYPE_NORMAL
- en: The transform3d property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using perspective, I've also found great utility in the `transform3d`
    value. With a single property and value, this allows you to move an element in
    the X (left/right), Y (up/down), and Z (forwards/backwards) axis. Let's amend
    our last example and make use of the `translate3d` transform. You can view this
    example at `example_08-06`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides setting the elements in with a little padding, the only changes from
    our previous example can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We're still applying a transform but this time, in addition to our rotate we
    have also added a `translate3d`. The syntax for the comma-separated 'arguments'
    you can pass into `translate3d` are *x* axis movement, *y* axis movement, and
    *z* axis movement.
  prefs: []
  type: TYPE_NORMAL
- en: In our two examples I'm not moving the element in the *x* or *y* axis (left
    to right, and up and down) instead I'm moving towards or further away from you
    as you look at it.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the top example you will see it flip behind the bottom button
    and end 120px closer to the screen (minus values effectively pull it backwards
    towards you).
  prefs: []
  type: TYPE_NORMAL
- en: '![The transform3d property](img/3777_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, the bottom button flips around horizontally and ends with
    the button 120px further away from you.
  prefs: []
  type: TYPE_NORMAL
- en: '![The transform3d property](img/3777_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the specification for `translate3d` at [http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/).
  prefs: []
  type: TYPE_NORMAL
- en: Use transforms with progressive enhancement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The area I have found the greatest utility for `transform3d` is in sliding panels
    on and off the screen, particularly 'off-canvas' navigation patterns. If you open
    `example_08-07` you'll see I have created a basic, progressively enhanced off-canvas
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you create interaction with JavaScript and modern CSS features like
    transforms it makes sense to try and consider things from the lowest possible
    device you want to support. What about the two people that don't have JavaScript
    (yes, those guys) or if there is a problem with the JavaScript loading or executing?
    What if somebody's device doesn't support transform (Opera Mini for example)?
    Don't worry, it's possible, with a little effort, to ensure a working interface
    for every eventuality.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building these kind of interface patterns I find it most useful to start
    with the lowest set of features and enhance from there. So, first establish what
    someone sees if they don''t have JavaScript available. After all, it''s no use
    parking a menu off-screen if the method for displaying the menu relies upon JavaScript.
    In this case, we are relying upon markup to place the navigation area in the normal
    document flow. Worst case, whatever the viewport width, they can merely scroll
    down the page and click a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use transforms with progressive enhancement](img/3777_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If JavaScript is available, for smaller screens we 'pull' the menu off to the
    left. When the menu button is clicked, we add a class onto the `body` tag (with
    JavaScript) and use this class as a hook to move the navigation back into view
    with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Use transforms with progressive enhancement](img/3777_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For larger viewports we hide the menu button and merely position the navigation
    to the left and move the main content over to accommodate.
  prefs: []
  type: TYPE_NORMAL
- en: '![Use transforms with progressive enhancement](img/3777_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We then progressively enhance the navigation show/hide effect. This is where
    a tool like Modernizr really earns its place; adding classes to the HTML tag we
    can use as styling hooks (Modernizr is discussed in greater detail in [Chapter
    5](ch05.html "Chapter 5. CSS3 – Selectors, Typography, Color Modes, and New Features"),
    *CSS3 – Selectors, Typography, Color Modes, and New Features*).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, for browsers that only support translate transforms (old Android for
    example), a simple `translateX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For browsers that support `translate3d` we use `translate3d` instead. This
    will perform far better, where supported, thanks to being offloaded to the graphics
    processors on most devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Embracing a progressive enhancement approach ensures the widest possible audience
    will get a workable experience from your design. Remember, your users don't need
    visual parity but they might appreciate capability parity.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've worked with applications like Flash, Final Cut Pro or After Effects,
    you'll have an instant advantage when working with CSS3 animations. CSS3 employs
    animation keyframing conventions found in timeline-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Animations are widely implemented; supported in Firefox 5+, Chrome, Safari 4+,
    Android (all versions), iOS (all versions), and Internet Explorer 10+. There are
    two components to a CSS3 animation; firstly a `keyframes` declaration and then
    employing that `keyframes` declaration in an `animation` property. Let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: In a previous example, we made a simple flip effect on elements that combined
    transforms and transitions. Let's bring together all the techniques we have learned
    in this chapter and add an animation to that previous example. In this next example,
    `example_08-05`, let's add a pulsing animation effect once the element has flipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly we will create a `keyframes` at-rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after writing at `@keyframes` to define a new `keyframes` at-rule
    we name this particular animation (pulse in this instance).
  prefs: []
  type: TYPE_NORMAL
- en: It's generally best to use a name that represents what the animation does, not
    where you intend to use the animation, as a single `@keyframes` rule can be used
    as many times as you need throughout a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used a single keyframe selector here: 100%. However, you can set as
    many keyframe selectors (defined as percentage points) as you like within a `keyframes`
    rule. Think of these as points along a timeline. For example, at 10%, make the
    background blue, at 30% make the background purple, at 60%, make the element semi-opaque.
    On and on as you need. There is also the keyword from which is equivalent to 0%
    and to which is equivalent to100%. You can use them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Be warned, however, that WebKit browsers (iOS, Safari) don't always play happily
    with from and to values (preferring 0% and 100%) so I'd recommend sticking with
    percentage keyframe selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice here that we haven''t bothered to define a starting point. That''s
    because the starting point is the state each of those properties is already at.
    Here''s the part of the specification that explains that: [http://www.w3.org/TR/css3-animations/](http://www.w3.org/TR/css3-animations/)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a `0%` or `from` keyframe is not specified, then the user agent constructs
    a `0%` keyframe using the computed values of the properties being animated. If
    a `100%` or `to` keyframe is not specified, then the user agent constructs a `100%`
    keyframe using the computed values of the properties being animated. If a keyframe
    selector specifies negative percentage values or values higher than `100%`, then
    the keyframe will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this `keyframes` at-rule we''ve added a text-shadow and box-shadow at 100%.
    We can then expect the `keyframes`, when applied to an element to animate the
    text-shadow and box-shadow to the defined amount. But how long does the animation
    last? How do we make it repeat, reverse, and other eventualities I hope to have
    the answer for? This is how we actually apply a `keyframes` animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `animation` property here is being used as a shorthand for a number of animation
    related properties. In this example, we are actually declaring (in order), the
    name of the `keyframes` declaration to use (pulse), the `animation-duration` (1
    second), the delay before the animation begins (1 second, to allow time for our
    button to first flip), the amount of times the animation will run (infinitely),
    the direction of the animation (alternate, so it animates first one way and then
    back the other) and that we want the `animation-fill-mode` to retain the values
    that are defined in the `keyframes` whether going forwards or backwards (both).
  prefs: []
  type: TYPE_NORMAL
- en: 'The shorthand property can actually accept all seven animation properties.
    In addition to those used in the preceding example, it''s also possible to specify
    `animation-play-state`. This can be set to running or paused to effectively play
    and pause an animation. Of course, you don''t need to use the shorthand property;
    sometimes it can make more sense (and help when you revisit the code in the future)
    to set each property separately. Below are the individual properties and where
    appropriate, alternate values separated with the pipe symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the full definition for each of these animation properties at [http://www.w3.org/TR/css3-animations/](http://www.w3.org/TR/css3-animations/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, it''s simple to reuse a declared `keyframes` on other
    elements and with completely different settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here the `pulse` animation would run over 2 seconds and uses an ease-in-out-back
    timing function (defined as a cubic-bezier curve). It runs five times in both
    directions. This declaration has been applied to the vertically flipping element
    in the example file.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one very simple example of using CSS animations. As virtually anything
    can be key-framed, the possibilities are pretty endless. Read about the latest
    developments on CSS3 animations at [http://dev.w3.org/csswg/css3-animations/](http://dev.w3.org/csswg/css3-animations/).
  prefs: []
  type: TYPE_NORMAL
- en: The animation-fill-mode property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `animation-fill-mode` property is worthy of a special mention. Consider
    an animation that starts with a yellow background and animates to a red background
    over 3 seconds. You can view this in `example_08-08`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We apply the animation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, once the animation completes, the background of the `div` will return
    to nothing. That''s because by default ''what happens outside of animations, stays
    outside of animations''! In order to override this behavior, we have the `animation-fill-mode`
    property. In this instance we could apply this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the item retain any values that have been applied at the animation
    end. In our case, the `div` would retain the red background color that the animation
    ended on. More on the `animation-fill-mode property` here: [http://www.w3.org/TR/css3-animations/#animation-fill-mode-property](http://www.w3.org/TR/css3-animations/#animation-fill-mode-property)'
  prefs: []
  type: TYPE_NORMAL
- en: '![The animation-fill-mode property](img/3777_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be entirely possible to fill multiple books covering the possibilities
    of CSS transforms, transitions, and animations. However, hopefully, by dipping
    your toe in the water with this chapter you'll be able to pick up the basics and
    run with them. Ultimately, by embracing these newer features and techniques of
    CSS, the aim is to make a responsive design even leaner and richer than ever by
    using CSS, rather than JavaScript, for some of the fancier aesthetic enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we've learned what CSS3 transitions are and how to write them.
    We've got a handle on timing functions like ease and linear, and then used them
    to create simple but fun effects. We then learned all about 2D transforms such
    as `scale` and `skew` and then how to use them in tandem with transitions. We
    also looked briefly at 3D transformations before learning all about the power
    and relative simplicity of CSS animations. You'd better believe our CSS3 muscles
    are growing!
  prefs: []
  type: TYPE_NORMAL
- en: However, if there's one area of site design that I always avoid where possible,
    it's making forms. I don't know why, I've just always found making them a tedious
    and largely frustrating task. Imagine my joy when I learned that HTML5 and CSS3
    can make the whole form building, styling, and even validating (yes, validating!),
    process easier than ever before. I was quite joyous. As joyous as you can be about
    building web forms that is. In the next chapter I'd like to share this knowledge
    with you.
  prefs: []
  type: TYPE_NORMAL
