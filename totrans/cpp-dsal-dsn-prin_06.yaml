- en: 6\. Graph Algorithms I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the utility of graphs for solving various real-world problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose and implement the right traversal method to find an element in a graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve the minimum spanning tree (MST) problem using Prim's algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify when to use the Prim's and Kruskal's algorithms to solve the MST problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the shortest path between two vertices/nodes in a graph using Dijkstra's
    algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will study the basic and most commonly used algorithms for
    solving problems that can be represented in the form of graphs, which shall then
    be discussed further in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous two chapters, we discussed two algorithm design paradigms:
    divide and conquer and the greedy approach, which led us to well-known solutions
    to widely used and important computational problems such as sorting, searching,
    and finding the minimum weight spanning tree on a graph. In this chapter, we shall
    discuss some algorithms that are specifically applicable to the graph data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: A **graph** is defined as a set of **vertices** and **edges** that connect a
    pair of vertices. Mathematically, this is often written as *G = < V, E >*, where
    *V* denotes the set of vertices and *E* denotes the set of edges that constitute
    a graph. Edges that point from one node to another are called *directed*, while
    edges that have no direction are called *undirected*. Edges may also be associated
    with a *weight* or be *unweighted*, as we saw in *Chapter 2*, *Trees, Heaps, and
    Graphs*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The terms "node" and "vertex" can be used interchangeably when we talk about
    graphs. In this chapter, we shall stick with "vertex."
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs are some of the most versatile data structures – so much so that other
    linked data structures such as trees and linked lists are known to be just special
    cases of graphs. What makes graphs useful is that they are the general representation
    of *relationships* (represented as **edges**) between *objects* (represented as
    **nodes**). Graphs can have multiple edges between the same pair of nodes, or
    even have multiple edge weights on a single edge, and nodes can also have edges
    from themselves to themselves (also known as self edges). The graph shown in the
    following diagram shows how these features can be present in a graph. Variants
    of graphs, called "hypergraphs," are also allowed to have edges that connect multiple
    nodes, and another set of variants called "mixed graphs" are also allowed to have
    both directed and undirected edges within the same graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: A graph with multiple edge weights, self edges (also called loops),
    and both directed and undirected edges](img/C14498_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: A graph with multiple edge weights, self edges (also called loops),
    and both directed and undirected edges'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As a result of the high degree of generality that graphs offer, they find use
    in several applications. Theoretical computer scientists use graphs to model finite
    state machines and automata, artificial intelligence and machine learning experts
    use graphs to extract information from changes in the structure of different kinds
    of networks over time, and traffic engineers use graphs to study the flow of traffic
    through road networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall restrict ourselves to studying algorithms that use
    weighted, directed graphs, and if needed, positive edge weights. We shall first
    study the **graph traversal problem** and cover two solutions to it: **breadth-first
    search** (**BFS**) and **depth-first search** (**DFS**). Next, we shall revert
    to the minimum spanning tree problem we introduced in the previous chapter and
    provide a different solution to it called Prim''s algorithm. Finally, we shall
    cover the single-source shortest path problem that powers navigation applications
    such as Google Maps and the OSRM route planner.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by taking a look at the basic problem of traversing a graph.
  prefs: []
  type: TYPE_NORMAL
- en: The Graph Traversal Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you have recently moved into an apartment in a new neighborhood.
    As you meet your new neighbors and make new friends, people often recommend restaurants
    to dine at in the vicinity. You wish to visit all the recommended restaurants,
    so you pull out a map of the neighborhood and mark all the restaurants and your
    home on the map, which already has all the roads marked on it. If we represent
    each restaurant and your home as a vertex, and the roads connecting the restaurants
    as edges in a graph, the problem of visiting all the vertices in the graph, when
    starting from a given vertex, is called the graph traversal problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, the numbers in blue are assumed vertex IDs. Vertex
    *1* is *Home*, and the restaurants are labeled from *R1* to *R7*. None of the
    edges have arrows since the edges are assumed to be bidirectional, that is, you
    can travel on the roads in either direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Representing a neighborhood map as a graph](img/C14498_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Representing a neighborhood map as a graph'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In mathematical notation, given a graph, *G = < V, E >*, the graph traversal
    problem is to visit all *v* *∈* *V* starting from a given vertex, *s*. The graph
    traversal problem is also called **the graph search problem** since it can be
    used to "find" a vertex in the graph. Different graph traversal algorithms give
    different orders for visiting the vertices in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-First Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A "breadth-first" search or breadth-first traversal of the graph starts by
    adding the starting vertex to a **frontier** that consists of the set of previously
    visited vertices and then iteratively exploring the vertices adjacent to the current
    frontier. The following illustrated steps should help you understand this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the *Home* vertex, which is the starting point, is visited. *R1* and
    *R2* are the neighbors of the vertices in the current frontier, which is represented
    by a blue dotted line in the following figure:![Figure 6.3: Initialization of
    the BFS frontier](img/C14498_06_03.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.3: Initialization of the BFS frontier'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following figure shows BFS after visiting *R1* and *R1*, either of which
    can be visited before the other. The order of visiting vertices that are at the
    same distance from the source vertex is irrelevant; however, the vertices with
    lower distance from the source are always visited first:![Figure 6.4: The BFS
    frontier after visiting the R1 and R2 vertices](img/C14498_06_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.4: The BFS frontier after visiting the R1 and R2 vertices'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following figure shows the state of BFS after visiting *R3*, *R5*, and
    *R6*. This is essentially the penultimate stage before the entire graph is traversed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5: The BFS frontier after visiting R3, R5, and R6](img/C14498_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The BFS frontier after visiting R3, R5, and R6'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A useful property of BFS is that for every vertex that is visited, all of its
    children vertices are visited before any grandchildren vertices. However, while
    implementing BFS, the frontier is typically not explicitly maintained in a separate
    data structure. Instead, a queue of vertex IDs is used to ensure that the vertices
    that are closer to the source vertex are always visited before the vertices that
    are farther away. In the following exercise, we shall implement BFS in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 28: Implementing BFS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement the breadth-first search algorithm using
    an edge list representation of the graph. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files and declare the graph, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following struct, which represents an edge in our graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since our definition of an edge uses templates, the edges can be easily made
    to have an edge weight of any data type that's needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, overload the `<<` operator for the `Graph` data type in order to display
    the contents of the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a class to define our graph data structure, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For this exercise, we shall test our implementation of BFS on the following
    graph:![Figure 6.6: Graph for implementing BFS traversal in Exercise 28'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14498_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Graph for implementing BFS traversal in Exercise 28'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We need a function to create and return the required graph. Note that while
    edge weights are assigned to each edge in the graph, this is not necessary since
    the BFS algorithm does not need to use edge weights. Implement the function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the breadth-first search like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following test and driver code that creates the reference graph, runs
    BFS starting from vertex *1*, and outputs the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7: Expected output of Exercise 28'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Expected output of Exercise 28'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following figure shows the order of vertices that our BFS implementation
    visits. Notice that the search starts from vertex *1* and then gradually visits
    vertices farther away from the source. In the following figure, the integers in
    red show the order, and the arrows show the direction in which our BFS implementation
    visits the vertices of the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: BFS implementation in Exercise 28'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: BFS implementation in Exercise 28'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The time complexity of the BFS is *O(V + E)*, where *V* is the number of vertices
    and *E* is the number of edges in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-First Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While BFS starts from the source vertex and gradually expands the search outward
    to vertices farther away, DFS starts from the source vertex and iteratively visits
    vertices as far away as possible along a certain path, returning to earlier vertices
    to explore vertices along a different path in the graph. This method of searching
    the graph is also called **backtracking**. The following illustrated steps show
    the working of DFS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we begin our traversal by visiting the *Home* vertex, as shown in
    the following figure:![Figure 6.9: DFS initialization](img/C14498_06_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.9: DFS initialization'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we visit vertex *R2*. Note that *R2* is chosen arbitrarily over *R1*
    since both are adjacent to *Home*, and either could have been chosen without affecting
    the correctness of the algorithm:![Figure 6.10: DFS after visiting R2](img/C14498_06_10.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.10: DFS after visiting R2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we visit vertex *R3*, as shown in the following figure. Again, either
    of *R3* or *R1* could have been chosen arbitrarily, as both are adjacent to *R2*:![Figure
    6.11: DFS after visiting R3](img/C14498_06_11.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.11: DFS after visiting R3'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The search continues by visiting an arbitrary unvisited neighbor vertex at
    each iteration. After *R1* is visited, the search tries to look for the next unvisited
    vertex. Since there are none left, the search terminates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12: DFS after visiting all the vertices in the graph](img/C14498_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: DFS after visiting all the vertices in the graph'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'While implementing the BFS, we used a queue to keep track of unvisited vertices.
    Since a queue is a **First-In, First-Out** (**FIFO**) data structure where vertices
    are removed from the queue in the same order as they are added to the queue, it
    was used by the BFS algorithm to ensure that vertices closer to the starting vertex
    are visited before the vertices farther away. Implementing DFS is remarkably similar
    to implementing BFS, except for one difference: instead of using a queue as a
    container for the list of vertices to be visited, we can now use a stack, while
    the rest of the algorithm remains the same. This approach works because on each
    iteration, DFS visits an unvisited neighbor of the current vertex, which can easily
    be tracked using a stack, which is a **Last-In, First-Out** (**LIFO**) data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 29: Implementing DFS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement the DFS algorithm in C++ and test it on
    the graph shown in *figure 6.2*. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required header files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following struct in order to implement an edge in our graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, since our implementation uses a templatized version of the struct, it
    allows us to assign edge weights of any data type required. However, for the purposes
    of DFS, we shall use null values as placeholders for the edge weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, overload the `<<` operator for the graph so that it can be printed out
    using the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the graph data structure that uses an edge list representation as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a function to perform DFS for our graph. Implement it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall test our implementation of the DFS on the graph shown here:![Figure
    6.13: Graph for implementing DFS traversal in Exercise 29'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14498_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: Graph for implementing DFS traversal in Exercise 29'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use the following function to create and return the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of null values for edge weights since DFS does not require edge
    weights. A simpler implementation of the graph could have omitted the edge weights
    entirely without affecting the behavior of our DFS algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following test and driver code, which runs our DFS implementation
    and prints the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the preceding code. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14: Expected output of Exercise 29'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.14: Expected output of Exercise 29'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following figure shows the order in which the vertices were visited by
    our DFS implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: The order of vertices visited and the direction of DFS](img/C14498_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: The order of vertices visited and the direction of DFS'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The time complexity of both BFS and DFS is *O(V + E)*. However, there are several
    important differences between the two algorithms. The following list summarizes
    the differences between the two and points out some cases where one should be
    preferred over the other:'
  prefs: []
  type: TYPE_NORMAL
- en: BFS is more suited to finding vertices that are closer to the source vertex,
    whereas DFS is often more suited to finding vertices that are farther away from
    the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a vertex is visited in BFS, the path that's found from the source to the
    vertex is guaranteed to be the shortest path, while no such guarantees exist for
    DFS. This is the reason why all single-source and multiple-source shortest path
    algorithms use some variant of BFS. This shall be explored in the upcoming sections
    of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As BFS visits all the vertices adjacent to the current frontier, the search
    trees that are created by BFS are short and wide, and require comparatively more
    memory, whereas the search trees that are created by DFS are long and narrow,
    and require comparatively less memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity 13: Finding out Whether a Graph is Bipartite Using DFS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A bipartite graph is one where the vertices can be divided into two sets so
    that any edges in the graph must connect a vertex from one set to a vertex from
    the other set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bipartite graphs can be used to model several different practical use cases.
    For instance, if we are given a list of students and a list of classes, the relationship
    between students and classes can be modeled as a bipartite graph containing an
    edge between a student and a class if the student is enrolled in that class. As
    you would imagine, edges leading from one student to another, or from one subject
    to another, would not make sense. Therefore, such edges are not allowed in a bipartite
    graph. The following figure illustrates such a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: A sample bipartite graph representing student enrollment in
    different classes](img/C14498_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: A sample bipartite graph representing student enrollment in different
    classes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once a model such as the one shown here has been prepared, it can be used to
    create a schedule of classes so that no two classes that have been enrolled by
    the same student overlap. For example, if Jolene is enrolled in *Math* and *Computer
    Science*, these two classes should not be scheduled at the same time to avoid
    a conflict. Minimizing such conflicts in timetables can be achieved through solving
    a maximum flow problem in graphs. Several standard algorithms are known for the
    maximum flow problem: Ford-Fulkerson''s, Dinic''s, and the push-relabel algorithms
    are some examples. However, such algorithms are often complex and, therefore,
    beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Another use case of modeling relationships between entities using a bipartite
    graph is between the viewers and the list of movies maintained by large video
    streaming platforms such as Netflix and YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting property of bipartite graphs is that some operations such as
    finding a maximum matching and vertex cover, which are *NP-complete* for general
    graphs, can be solved in polynomial time for bipartite graphs. Therefore, it is
    useful to determine whether a given graph is bipartite or not. In this activity,
    you are required to implement a C++ program that checks whether a given graph,
    *G*, is bipartite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bipartite checking algorithm uses a slightly modified version of DFS and
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume that the DFS starts with vertex *1*. Add the vertex ID, *1*, to the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If unvisited vertices remain on the stack, pop a vertex from the stack and set
    it as the current vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the color that was assigned to the parent vertex was blue, assign the current
    vertex red; otherwise, assign the current vertex blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add all the unvisited adjacent vertices of the current vertex to the stack and
    mark the current vertex as visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 2*, *3*, and *4* until all the vertices have been assigned a color.
    If all the vertices are colored when the algorithm terminates, the given graph
    is bipartite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, while running *step 2*, the search encounters a vertex that has already
    been visited and assigned a color that is different from the color that it would
    have been assigned in *step 3* (the inverse of the color assigned to its parent
    vertex in the search tree), the algorithm terminates immediately and the given
    graph is not bipartite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figures illustrate the working of the preceding algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Initialization](img/C14498_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Initialization'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 6.18: Since vertex 1 was assigned blue, we color vertex 2 red](img/C14498_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Since vertex 1 was assigned blue, we color vertex 2 red'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![](img/C14498_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Since vertex 2 was colored red, we color vertex 8 blue.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As can be observed from the preceding set of figures, the algorithm zigzags
    through the graph, assigning alternate colors to each vertex that's visited. If
    all the vertices can be colored this way, the graph is bipartite. If DFS reaches
    two vertices that have already been assigned the same color, the graph can be
    safely declared to be not bipartite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the graph in *figure 6.17* as input, your final output should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: Expected output of Activity 13'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: Expected output of Activity 13'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 524.
  prefs: []
  type: TYPE_NORMAL
- en: Prim's MST Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MST problem was introduced in *Chapter 5*, *Greedy Algorithms*, and is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Given a graph, G = < V, E >, where V is the set of vertices and E is the
    set of edges, each associated with an edge weight, find a tree, T, that spans
    all vertices in V and has the minimum total weight."*'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Greedy Algorithm*, we discussed the practical applications
    of the MST problem and Kruskal's algorithm, which finds an MST in a given graph.
    Kruskal's algorithm adds all the edges of the graph to a min-heap and greedily
    adds minimum-cost edges to MST, checking that no cycles are formed in the tree
    on each addition.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind Prim's algorithm (also known as Jarvik's algorithm) is similar
    to that of BFS. The algorithm starts by adding the starting vertex to a *frontier*,
    which consists of the set of previously visited vertices and then iteratively
    explores the vertices adjacent to the current frontier. However, while choosing
    the vertex to be visited on each iteration, the vertex with the lowest cost edge
    from the frontier is picked.
  prefs: []
  type: TYPE_NORMAL
- en: 'While implementing Prim''s algorithm, we attach a *label* to each vertex of
    the graph, which stores its distance from the starting vertex. The algorithm works
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it initializes the labels on all the vertices and sets all the distances
    to infinity. Since the distance from the starting vertex to itself is *0*, it
    sets the label of the starting vertex to *0*. Then, it adds all the labels to
    a min-heap, *H*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following figure, the numbers shown in red represent the estimated distance
    from the starting vertex, which is assumed to be vertex *1*; the numbers shown
    in black represent edge weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14498_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: Initializing Prim''s MST algorithm'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, it pops a vertex, *U*, from *H*. Naturally, *U* is the vertex with a minimum
    distance from the starting vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For all vertices, *V*, adjacent to *U*, if the label of *V* > edge weight of
    *(U, V)*, set the label of *V* = edge weight of *(U, V)*. This step is called
    *settling* or *visiting* vertex *U*:![Figure 6.22: The status of the graph after
    visiting vertex 1](img/C14498_06_22.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.22: The status of the graph after visiting vertex 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While unvisited vertices remain in the graph, go to *step 2*. The following
    figure shows the state of the graph after visiting vertex *2*, where the edge
    shown in green is the sole edge in our MST so far:![](img/C14498_06_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.23: The status of the graph after visiting vertex 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The final MST after all vertices have been settled is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.24: MST for our graph](img/C14498_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: MST for our graph'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 30: Prim''s Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement Prim''s algorithm to find the MST in the
    graph shown in *figure 6.22*. Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement an edge in the graph by using the following struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following function to overload the `<<` operator for the `Graph` class
    so that we can output the graph to C++ streams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an edge list-based graph implementation, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a function to create and return the graph shown in *figure 6.22* by using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall implement the `Label` structure, an instance of which is assigned
    to each vertex in the graph in order to store its distance from the frontier.
    Use the following code to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a function to implement Prim''s MST algorithm, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following code, which runs our implementation of Prim''s algorithm
    and outputs the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.25: Output of Exercise 30'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.25: Output of Exercise 30'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The time complexity of Prim's algorithm is *O(E log V)* when using a binary
    min-heap and an adjacency list for storing the MST, which can be improved to *O(E
    + V log V)* when using a type of heap called the "Fibonacci min-heap."
  prefs: []
  type: TYPE_NORMAL
- en: 'While both Prim''s and Kruskal''s are examples of greedy algorithms, they differ
    in important ways, some of which are summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: Table comparing Kruskal’s and Prim’s algorithms](img/C14498_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: Table comparing Kruskal''s and Prim''s algorithms'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dijkstra's Shortest Path Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The single-source shortest path problem on a graph is solved every time a user
    requests a route on a route planning application such as Google Maps or in the
    navigation software built into cars. The problem is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Given a directed graph, G - < V, E > where V is the set of vertices and E
    is the set of edges, each of which is associated with an edge weight, a source
    vertex, and a destination vertex, find a minimum-cost path from a source to a
    destination."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dijkstra''s algorithm works for graphs with non-negative edge weights and is
    only a slight modification of Prim''s MST algorithm, with two major changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of setting labels on every vertex equal to the minimum distance from
    the frontier, Dijkstra's algorithm sets the labels on each vertex with the distance
    equal to the total distance of the vertex from the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra's algorithm terminates if the destination vertex is popped from the
    heap, whereas Prim's algorithm terminates only when there are no more vertices
    left to be settled on the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The working of the algorithm is illustrated in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it initializes the labels on all the vertices and sets all the distances
    to infinity. Since the distance from the starting vertex to itself is *0*, it
    sets the label of the starting vertex to *0*. Then, it adds all the labels to
    a min-heap, *H*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following diagram, the numbers shown in red represent the current best-known
    distances from the source (vertex *2*) and the destination (vertex *6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: Initializing Dijkstra’s algorithm](img/C14498_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: Initializing Dijkstra''s algorithm'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Then, it pops a vertex, *U*, from *H*. Naturally, *U* is the vertex with the
    minimum distance from the starting vertex. If *U* is the required destination,
    we have found our shortest path and the algorithm terminates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all vertices, *V*, adjacent to *U*, if the label of *V* > (label of *U*
    + edge weight of *(U, V)*), we have found a path to *V* that is shorter than the
    previously known minimum-cost path. Therefore, set the label of *V* to (label
    of *U* + edge weight of *(U, V)*). This step is called **settling** or **visiting**
    the vertex *U*:![](img/C14498_06_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.28: The state of the algorithm after settling vertex 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While unvisited vertices remain in the graph, go to *step 2*. The following
    figure shows the state of the graph after settling vertex *2*:![](img/C14498_06_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.29: The state of the algorithm after settling vertex 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The algorithm terminates when the destination vertex (vertex ID *6*) is popped
    from *H*. The shortest path that''s found by the algorithm from *1* to *6* is
    shown in the following figure. Also, the labels on other settled vertices show
    the shortest distance from *1* to that vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.30: The shortest path from 1 to 6](img/C14498_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: The shortest path from 1 to 6'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 31: Implementing Dijkstra''s Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall implement Dijkstra''s algorithm to find the shortest
    path in the graph shown in *figure 6.28*. Follow these steps to complete this
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required header files and declare the graph data structure, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following struct to implement an edge in our graph implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Overload the `<<` operator for the `Graph` class so that it can be output using
    streams, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the graph, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a function to create the reference graph shown in *figure 6.28* using
    the `Graph` class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement Dijkstra''s algorithm, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation works in two phases – it searches for the destination vertex
    starting from the source and uses the backtracking phase, where the shortest path
    is found by following the parent pointers from the destination back to the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following code to test our implementation of Dijkstra''s algorithm
    by finding the shortest path between vertices *1* and *6* in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.31: Output of Exercise 31'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.31: Output of Exercise 31'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in the preceding output, our program traces the vertices along
    the shortest path between vertices *1* and *6*. The best known running time of
    Dijkstra's algorithm is *O(E + V log V)* when Fibonacci min-heaps are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14: Shortest Path in New York'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, you are required to implement Dijkstra''s algorithm in C++
    so that it can be used to find the shortest path in the given road network of
    New York. Our road graph consists of 264,326 vertices and 733,846 directed edges,
    and the edge weight is the Euclidean distance between the vertices. The steps
    for this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the road graph file from the following link: [https://raw.githubusercontent.com/TrainingByPackt/CPP-Data-Structures-and-Algorithm-Design-Principles/master/Lesson6/Activity14/USA-road-d.NY.gr](https://raw.githubusercontent.com/TrainingByPackt/CPP-Data-Structures-and-Algorithm-Design-Principles/master/Lesson6/Activity14/USA-road-d.NY.gr).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the file is not automatically downloaded, and instead is opened in your browser,
    download it by right-clicking on any blank space and selecting "**Save as…**"
  prefs: []
  type: TYPE_NORMAL
- en: If you're running Windows, move the downloaded file to `<project directory>/out/x86-Debug/Chapter6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're running Linux, move the downloaded file to `<project directory>/build/Chapter6`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The directory structure may vary based on your IDE. The file needs to be placed
    in the same directory as your compiled binary. Alternatively, you may tweak the
    implementation to accept a path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The road graph is a text file with three different kinds of rows:![Figure 6.32:
    Table describing the road graph file for New York](img/C14498_06_32.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.32: Table describing the road graph file for New York'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implement a weighted edge graph. It is okay to assume that once the graph is
    created, no vertices can be added or deleted from the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a function to parse the road graph file and populate the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement Dijkstra''s algorithm and test your implementation by finding the
    shortest path between vertices `913` and `542`. Your output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.33: Expected output of Activity 14'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_06_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.33: Expected output of Activity 14'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 530.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We covered three major graph problems in this chapter: first, the graph traversal
    problem for which two solutions were introduced, breadth-first search (BFS) and
    depth-first search (DFS). Second, we revisited the minimum spanning tree (MST)
    problem and solved it using Prim''s algorithm. We also compared it with Kruskal''s
    algorithm and discussed the conditions under which one should be preferred over
    the other. Finally, we introduced the single-source shortest path problem, which
    finds a minimum-cost shortest path in graphs, and covered Dijkstra''s shortest
    path algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: However, Dijkstra's algorithm only works for graphs with positive edge weights.
    In the next chapter, we shall seek to relax this constraint and introduce a shortest
    path algorithm that can handle negative edge weights. We shall also generalize
    the shortest path problem to find the shortest paths between all the pairs of
    vertices in graphs.
  prefs: []
  type: TYPE_NORMAL
