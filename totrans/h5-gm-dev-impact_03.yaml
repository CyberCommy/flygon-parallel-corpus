- en: Chapter 3. Let's Build a Role Playing Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we took a look at several key concepts and zoomed in
    on them one by one, largely disregarding their underlying dependencies. Now we
    will build up a game step by step. In this chapter we will take a look at the
    RPG, while in [Chapter 4](ch04.html "Chapter 4. Let's Build a Side Scroller Game"),
    *Let's build a Side Scroller Game*, we will dive into the side scroller game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The RPG game format and its possible sub formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an actual level for your player to explore and connecting it to other
    levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a playable entity, slayable but dangerous foes, and neutral talkative
    characters to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning your player into a force to be reckoned with by adding weapons and helpful
    items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some depth to the player's enemies by bestowing them with basic artificial
    intelligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of some changes in the game such as the collections of coins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ending the game by pitting the player against a more formidable foe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RPG game setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the RPG game setting it would be good to have a look at
    some successful RPGs and see what we can learn from them. There are some great
    examples out there: **Zelda** , **Final Fantasy** , **Pokémon** , **World Of Warcraft**
    , **Tibia** , **Baldur''s Gate** , **Neverwinter Nights** , and so on. The list
    is virtually endless. What made all these games so successful? Well, there is
    always the marketing component, but no game can reap eternal fame on marketing
    alone. So what was their *unique gaming proposition* for the audience they targeted?
    Game reviewers often divide their marks over several categories such as gameplay,
    graphics, sound, and so on. These are valid points, but why not have a look at
    addictiveness for example? Even the simplest game can be addictive. If you have
    ever been to Vegas and witnessed the tons of people playing for hours on slot
    machines that require no skill at all, you will understand that there is something
    special about game psychology.'
  prefs: []
  type: TYPE_NORMAL
- en: Addictiveness is of course great, if you offer a free game and want to make
    money from in-game advertising or recurring subscription fees. Another approach
    is making the game engaging but final. Those are the games you can actually "finish".
    They usually have an interesting story between the games' protagonist and antagonist.
    When the antagonist is defeated, the game ends and as a player you are unlikely
    to pick it up again. An example would be every game within the Final Fantasy series.
  prefs: []
  type: TYPE_NORMAL
- en: Most RPGs apart from **MMORPG**s (**Mass Multiplayer Online Role Playing Game**)
    are in this second category. They often have a fascinating story and mesmerizing
    music. The characters are really interesting and deep. The battle system is very
    intuitive and yet complicated enough for someone to be either good or bad at it.
    The really good ones tend to leave a lasting impression on anyone who played them,
    and they cost a lot of work to put together.
  prefs: []
  type: TYPE_NORMAL
- en: This is the standard way of looking at an RPG. However, this should in no way
    hold you back from refreshing the genre and throwing some elements from other
    genres or totally new ideas into the mix. For example, **Borderlands** is a crossbreed
    of an RPG and a shooter. It has level progression and weapon enhancement like
    most RPGs. It has a story and at the same time it still plays like a shooter.
  prefs: []
  type: TYPE_NORMAL
- en: A game does not need to mix up two computer genres. **Minecraft** is essentially
    the pleasure of playing with Lego brought to a computer.
  prefs: []
  type: TYPE_NORMAL
- en: What it boils down to is finding out for yourself what things you enjoy the
    most or enjoyed greatly as a kid. Find the underlying mechanic at work and try
    to replicate that feeling in a game. This is all easier said than done for sure.
    However, it is necessary to go through this process since it is your time that
    it will take up to build the game, and if it isn't even a game you yourself would
    like to play, why would others want it?
  prefs: []
  type: TYPE_NORMAL
- en: For RPGs, it often gets more complicated than simply finding an original gameplay
    component. RPG video games can be a mix between a great book and a movie with
    the merits of interactivity thrown in. If you are a great story teller, or know
    one, why not do it this way? A game does not need to be difficult or graphically
    perfect for people to play. A good example is Final Fantasy VII, which was a big
    hit in the 1990s. In 2012 it was rereleased with "polished graphics". There is
    not much difference; an untrained eye wouldn't immediately notice the polishing.
    But it's still a great game, regardless of the fact that it can't compete with
    the complexity and graphical splendor of games such as Skyrim or Fable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what you should be aiming at: take the *core pleasure* you want your
    game to have, package it with as little complexity as you possibly can, and add
    happy, pastel-colored graphics. Happy graphics are great. No, seriously, if you
    want your game to radiate darkness and fear, that''s fine too, but otherwise,
    certainly consider smiling clouds and crazy looking animals.'
  prefs: []
  type: TYPE_NORMAL
- en: Building an RPG level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to put our own little RPG together. We will start our journey
    with a clean slate. Following are the steps to build an RPG level:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a copy of the freshly installed `ImpactJS` folder that we kept in
    the `chapter 1` folder and rename it to `RPG`. Copy the `media` folder from the
    `chapter 3` folder to your `RPG/media` folder. This way at least we have some
    graphics to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **it works!** screen you get when you enter `localhost/RPG` in
    your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by opening the Weltmeister (`localhost/Weltmeister.html`) and drawing
    a small level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that there is nothing prepared for you this time around. The
    only available layer is the `entities` layer and it doesn't even contain a single
    entity. However, we can draw ourselves a small playing field to get started once
    we have something to populate the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So let's add another layer (*+-*sign) and call it `grass`. Let's set the tile
    size to `16` and have a 30 x 20 zone at a distance of 1 pixel. Select the tileset
    `grass.png` and click on the **Apply Changes** button before you can start laying
    down the grass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't have your drawbox centered just right for you, hold the *Ctrl*
    key and move your mouse until it is centered. If for some reason it is too big
    to fit on your screen, zoom out with your mouse scroll wheel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have painted this entire layer in green, we can easily add another one
    to sit on top of the grass. But before you do so, save your file as `level1`.
    Saving often is a virtue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When adding layers you can name and use them by what they are supposed to represent.
    For instance, you have a layer for furniture, plants, and miscellaneous objects.
    This is a decent way of working, but you have to keep in mind that some layers
    will visually come in front of your player and monster entities, while others
    will appear behind them. Even something as simple as a single wall is best drawn
    with two layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Weltmeister does not support an endless number of layers. In order to keep
    the number of layers respectable, you can have tilesets for specific levels. For
    instance, you have two level settings: a city and a dungeon. Both can contain
    a chair, so don''t be afraid to have the same chair on a tileset for your city
    and on a different tileset to construct your dungeon. Duplicating information
    will increase your overall game size but can decrease the number of layers necessary
    for a single level.'
  prefs: []
  type: TYPE_NORMAL
- en: Our grass is just called `grass` because we won't have grass that will float
    in front of our player; consequently we don't require a second grass layer. Let's
    make two new layers called `vegetation_back` and `vegetation_front`. `vegetation_back`
    must be positioned underneath the `entities` layer in the layer selection menu.
    `vegetation_front` must be put above the `entities` layer. Together these two
    new layers will make up all the vegetation on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Select the tileset `tree.png` and use the same settings for the `grass` layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw the upper part of a tree with the `vegetation_front` layer and the lower
    part with `vegetation_back`. The following screenshot shows the different layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an RPG level](img/4568_3_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the layers you should currently have in your Weltmeister
    **Layers** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an RPG level](img/4568_3_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you have no idea what the upper part or lower part of anything should be,
    think about how big your player and/or enemies will be. When walking past the
    tree, their heads or feet should not disappear. In order to avoid the player walking
    through the tree altogether, we will need another layer, the collision layer.
  prefs: []
  type: TYPE_NORMAL
- en: Add a layer with the name `collision` to the Weltmeister.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget, you can make a layer visible in Weltmeister by either dragging
    it to the top of the layer stack or switching off the layers that are blocking
    the view. In this case, the `grass` layer will probably block all the view if
    the collision layer is at the bottom of the stack. It's pretty efficient to drag
    the `collision` layer to the top and just turn it on and off when necessary. Settings
    for setting up the layer are the same as always.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `collision` layer, draw a border around the level so no one can escape.
    Also put some collision squares in the tree trunk just underneath or above the
    dividing line between the front and back layers, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an RPG level](img/4568_3_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So we created a viable environment. It''s not much but it''s a start. However,
    for the level to load, we need to make changes to our `main.js` script as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In order to make sure our game finds the level, we need to include it in the
    `.requires` part of our module. We need to point to it in the same way as we would
    to any file, starting from our game root folder. The only difference is that slashes
    (`/`) are replaced by dots (`.`) and the included file itself is always considered
    to have the `.js` extension. For example, `/game/levels/level1.js` becomes `game.levels.level1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to load the level at game startup, so let''s add a `loadlevel()`
    method to the `init()` function. Don''t forget that the parameter to call this
    function always has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Level + Levelname` in capital letters. Anything else will crash the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a loaded level but there is nothing interactive about it; we have
    no player yet. And although having **it works!** on the screen at all times is
    quite motivating, it''s also mildly blocking our vision. So let''s delete the
    following code from `main.js` and move on to our `player` entity using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to start building our game from scratch in this chapter. Therefore we
    need the originally downloaded ImpactJS files. Put them in a separate folder in
    your server working directory. Also test whether you get the **it works!** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `chapter 3` folder's `media` files to the folder you just set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Weltmeister level editor and make a layered level. You need a collision
    layer, an entities layer, and three graphical layers. The bottom graphical layer
    will represent the grass. The other two layers represent all other objects that
    will show up in front of or behind the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the graphical layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the level file in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `it works!` message from the `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a playable character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to build our player from scratch we need a new (and empty) `.js` file.
    Create a new file in your code editor and even though it's empty, save it as `player.js`
    in the `entities` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every module starts out in the same way. It consists of the `ig.module()` ,
    `ig.requires()`, and `ig.defines()` methods. For some modules you will not need
    the `requires()` method but all entities will, because here you need to include
    the `impact` script for entities, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are going to build the player based on the `prototype` entity. This prototype
    has several attributes (such as `health` and `velocity`) and several methods (such
    as `kill()` and `receiveDamage()`) predefined. This way we only need to extend
    the original version with the `extend()` method in order to create our player.
  prefs: []
  type: TYPE_NORMAL
- en: There are some rules here. If your JavaScript file is called `player.js`, your
    entity will be called `Player`. You assign it to an extension of the `entity`
    prototype by adding `Entity` in front of its name, as shown in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any deviation from the naming conventions will remove the entity from the Weltmeister
    **Entities** menu. Adding an entity to the Weltmeister editor when it is correctly
    named, and loading the game with faulty naming will result in a crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also don''t forget to include the `player` entity in the `requires()` method
    within `main.js`. A module can only be used when the `main` module knows about
    its existence. The following code shows that the extension `.player` is assigned
    to the `entities` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add the `player` entity to the game with the Weltmeister right now,
    you would notice that there is nothing to see. The player has no visual representation
    yet, we address this issue in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to get a glimpse of our playable character, we need to add an animation
    sheet, which is located in our `media` folder. The animation sheet needs to be
    assigned with the right dimensions if you don't want to see just pieces of your
    characters walk about. We also gave the entity a size. The animation can actually
    be bigger than the size of an entity. If you do not set a size, you will see that
    you can select the `player` entity in Weltmeister, but its boundaries do not encompass
    the entire image. This is because the default size is 16 x 16\. Size is a relevant
    property for collision detection. We also gave the player some health to get started.
    The default health is 10.
  prefs: []
  type: TYPE_NORMAL
- en: We are also confronted with the `entity` prototype's `init()` method. The `entity`
    prototype already has its own `init()` function, so it's best to include this
    by calling the `parent()` method within the `init()` function. Having an animation
    sheet defined does not make the entity animated. You need to assign an action
    to the animation sheet. Here, *idling* corresponds to the first image on the sheet.
    You can now safely add your player to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Great, we have a player in our game! Too bad it doesn't move. Let's work on
    that right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` script you are to add the following to your `init()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure your arrow keys are bound to an *input state*. From now
    on the game will check automatically whether any of these keys are pressed. Since
    we are building a top-down game here, we need to be able to walk in any direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `player.js` script, four new animation sequences will need to be added
    to the `init()` function as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the animation sequence of `idle` was composed of one image, we now need
    to assign a true sequence for every direction in which our player can walk. Again,
    the `0.1` value is the time in between images.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you will need to call and extend the `entity` prototype's `update()`
    function. Don't forget to have a comma to separate the `init()` and `update()`
    functions or you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `update()` function, like `init()`, is a standard method of the prototype
    `entity`. Therefore we need to call the parent function if we don't want to lose
    its ImpactJS entity core functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: For every input state we need separate behavior, so we have this set of *if-then
    operators*. Remember that since we put this code in the `update()` function, it
    is run every time the game goes through an update loop, which is once per frame.
    The `init()` function is only called once, that is, at the moment of player creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the condition checks, we do two things: allocate a speed on the relevant
    axis and add an animation. If the player does nothing, the velocity in both directions
    is also set to `0`, so continuous input is required for the player to move.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `ig.input.state` we could use `ig.input.pressed` . But that would
    result in our player having to button mash his way through the level. For, every
    time he or she presses one of the move buttons, the player would only move a small
    bit and stop immediately. In case of 60 fps and a velocity of 100, the player
    would move 100/60 = 1.67 pixels for one touch. Although `ig.input.pressed` certainly
    has its merits, moving in this way might annoy even the most patient of gamers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finally have a playable character that moves around gracefully! It can even
    hide behind the tree we created earlier. We still have another problem on our
    hands though, we can''t see our player at all times. Can you imagine the frustration
    of a player getting killed by something because he couldn''t see where he was
    going? I''m sure you can and it has probably even happened to you if you have
    played some games in the past. However, we are in luck because a camera that follows
    the player around is easy to implement, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, two important elements and the player
    are assigned to a local variable. Then the viewport coordinates are set to the
    player's position. If you wanted your camera to put the player in the top-left
    corner of the screen, you wouldn't need your game canvas. But of course, we want
    the player centered, so we adjust its position by half the size of the canvas
    in both dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: On reloading the browser, you will notice that you can finally walk to the bottom
    of your screen and underneath the tree. Great! Just too bad that there is nothing
    to do here, so next we will introduce something hostile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `player.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `player.js` script with the standard ImpactJS module code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `player.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet and sequence to your playable character so that it can
    be found in the Weltmeister. Also provide him with health and a size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add player controls by binding keyboard keys to input states in the `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind these input states to move the character's action by manipulating its velocity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the movement appear as a smooth animation by introducing extra animation
    sequences and calling them when certain input states are active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put in a camera that automatically follows the player around wherever he ventures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introducing a defeatable opponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we will have to start from scratch, so open up a blank JavaScript file
    and save it as `enemy.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The start of entity creation is always the same. Set up your `Entity` file and
    add an `enemy` entity to your `main` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.js.requires` add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In `enemy.js` add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the previous code snippets creates our entity, which we can add to the
    level by use of the Weltmeister. However, it''s still pretty useless so let''s
    first add some graphics using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add our first enemy to the level. It won't do much though, and you
    will even be able to walk right through him as if he isn't there. This is because
    no collision between entities has been specified yet.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following code to the `player` and `enemy` entity as a property. You
    can add them in the `init()` function with the old JavaScript notation or above
    `init()` in literal notation, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for the enemy `entity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now push our enemy around the level like a real bully. You might have
    noticed that there is still some space in between the player and the enemy. This
    is because the boundaries of the entities are rectangles, which more than encompass
    the actual drawings. It''s pretty annoying for a player to get hit by an enemy
    when visually it''s not the case. To rectify the situation we need to introduce
    `offset` as a player property. The `size` property determines the size of the
    collision box around the entity. The `offset` property makes your collision box
    shift a few pixels to the right or down. Of course, you can enter a negative number
    at a point at which it will shift left and/or upward. We will need to combine
    these two properties to make a new collision box for the player, which makes him
    harder to hit. However, before proceeding it''s useful to turn on the ImpactJS
    debugger by adding the following line of code to the `main.js` script in the `requires()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a good habit to have this debugger switched on during development. You
    can delete this code again when preparing it for release. Let''s change the size
    and offset for both player and enemy using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual image size is 32 x 48\. We changed the size of both entities to
    `18` x `40` with an offset of `7` x `4`. If you open the debugger on the **Entities**
    tab and turn on **Show Collision Boxes**, you will notice the difference in size.
    You might also notice static collision, such as the squares of the collision layer
    that we added to the middle of the tree are not visible because it only shows
    collision for entities, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing a defeatable opponent](img/4568_3_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is no perfect rule for setting collision boxes. It all depends on how
    well centered and symmetrical your image is, how lenient you are when it comes
    to collision, and the difference in image size between the frontal and profile
    look. Here we chose to reduce our width by 14 pixels (32 - 18). In order to keep
    the box centered, the offset was set to half the difference ((32 - 18) / 2 = 7).
    The same reasoning applies to the y axis.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an enemy. Let's kill it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `enemy.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `enemy.js` script with the standard ImpactJS module code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `enemy.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet and several animation sequences, taking into account
    every direction in which your enemy might walk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change both the player's and the enemy's `collisions` entities. They need to
    be able to detect each other's presence so the enemy can later on damage the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you haven't already done this, turn on the ImpactJS debugger by including
    it in your `main` script. The aim is to see the entity's collision boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Giving the player some weapons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We do like our player to be armed and ready for some action. Let''s first add
    a new key that will be used to attack. In `main.js` add the following key bind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In any combat situation it is the collision of two bodies that causes damage.
    If an arrow hits the mark, it''s the arrow that damages, not the bow. The same
    is true for a nuclear missile. It''s not the launch facility but the blast wave
    of the nuke that collides with whatever happens to be in the way which does the
    damage. In this respect you could say there are three entities at work here: a
    launch facility, a nuke, and its blast wave. You could even add another one if
    you want to make a difference between air pressure and actual conflagration. All
    of this is just to show how you should think when adding weapons to a game. Which
    impact is relevant? In case of a chicken and a chicken launcher, the chicken will
    become an entity while the launcher is a mere drawing.'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a projectile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our ranged attack we need a new entity, which we will call `projectile`.
    Make a new script, set up the basics, save it as `projectile.js`, and include
    it in `main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following code in `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the following code in `projectile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, the basics don''t seem to be that basic after all. This time around, we
    have two different animation sheets. An arrow tends to be quite a bit longer than
    it is wide. Therefore if the arrow is shot from left to right (or right to left),
    its dimensions differ from an arrow shot up or downwards. When defining an animation
    sheet, we have to define the dimensions that every image will take only once.
    However, in this case we need two different dimensions: `8` x `4` and `4` x `8`.
    Actually in this particular case there is another, probably easier, solution involving
    the angle of the animation. In programming languages there often are different
    ways to get the same or a similar result. However, now we will use multiple animation
    sheets.'
  prefs: []
  type: TYPE_NORMAL
- en: We define two different animation sheets. Instead of initiating them on the
    standard `animSheet` property, we named them `animSheetX` and `animSheetY` to
    indicate the different axes. The `init()` function does not call the `addAnim()`
    method as in the `Player` and `Enemy` entities because it is programmed to take
    the `animSheet` property by default. Instead we directly address `ig.animation`
    to which we can pass our own animation sheets. It's nice to have an image in case
    you would like to add an arrow in Weltmeister, so the `currentAnim` property is
    given the x axis animation sequence as a default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to make the player spawn the arrow. Therefore we need to add
    the following to the player''s `update()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The arrow will be spawned at the player's location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you run the game at this point, the arrow can only fly in one direction:
    to the right. This is because our default velocity was set at `100` pixels per
    second to the right. Also our animation default is an arrow pointed rightwards.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not entirely what we want. Our enemies would at all times have to be
    on our right side in order for us to kill them. So let''s modify the projectile
    code by adding the following code to the `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `velocity` as a property as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What happens now is if the direction of the arrow is right, left, up, or down,
    it will adjust its speed and animation accordingly. There are only two images
    at play here, an arrow pointed upward and one pointed to the right, each in its
    separate animation sheet. We could add one extra image to each sheet, one downward
    pointing arrow, and one aiming to the left. This would be a viable solution but
    here we choose to use the flip property instead. Flip basically makes a mirror
    image of the animation, making the arrow point to the exact opposite direction.
    When using flip, you must make sure it actually makes sense to flip an image instead
    of using a separate one. For instance, if you have a character running from left
    to right and you want to make it run from right to left, flip is pretty ok to
    use. For characters running towards or away from you, this doesn't really work
    since you expect to either see their front or their back.
  prefs: []
  type: TYPE_NORMAL
- en: This is all very nice but where does it get its *direction* from? Let's initiate
    the direction with a default value and then modify the player so it can pass on
    its own direction to the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `projectile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following for `player.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For every direction, add a variable called `lastpressed` with the same value
    as the input state, as shown in the following code snippet, for going to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the `spawnEntity` method pass the direction parameter using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Great! We now have our hero shooting arrows in every direction like a boss.
    At the moment, our arrows are still pretty indestructible and are quite harmless
    to our lucky foe. They just hit the edge of our level and stay there forever or
    until the game gets reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `projectile.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `projectile.js` script. Give it two animation sheets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `projectile` script to the `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the player's `update` function so the player can spawn a projectile when
    the `attack` input state is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the projectile's direction and animation depending on which direction
    the player is facing when firing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the direction of the player is transferred to the `projectile` script
    when spawning it. This is done by filling out the optional parameter of the standard
    ImpactJS entity: the `spawn` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Causing harm with a projectile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make the arrow disappear when hitting an enemy or when in the air for
    some time using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initiating a new property called `lifetime` at `0` and adding a counter with
    the `kill()` function to the `update()` function will make the arrow disappear
    after flying for `100` frames. Again, don't forget to separate the `init()` and
    `update()` functions with a comma (`,`), or the literal notation will not forgive
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to damage the enemy, we will need our arrow to check whether it encountered
    one. We make the arrow a `TYPE A` entity like the `player` entity, and let it
    check for the `TYPE B` entities like the `enemies` entity in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `check()` function we can make the arrow check for every entity
    it needs to check for (as set by the `checkAgainst` property). If it encounters
    an entity of type `B`, that entity receives a damage of `100` as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we still didn't solve the problem of the arrow camping against the edge
    of the level or any other place where map collision is present. So let's make
    some bouncing arrows! No worries, we made sure they couldn't hurt the player since
    they will only check for entities of type `B` and will fly right through our player.
  prefs: []
  type: TYPE_NORMAL
- en: 'First set the `bounciness` to `1`, which means all speed is kept when bouncing
    back, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we only need to check if the speed has inverted (if the arrow has bounced),
    and invert the animation if required. Of course, this needs to be done in the
    `update()` function as shown in the following code snippet since it can happen
    at all times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is a very naive check since it relies on the assumption that the speed
    of the arrow remains the same at all times, even after a bounce. However, for
    the sake of keeping the example simple, it will do.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't even set the `health` value of our enemy and we can already damage
    and kill it. This is because by default the `health` value of an entity is set
    to `10`. Let's change this property so that our enemy can at least survive the
    first hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the change as per the following code in `enemy.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our enemy has become harder to kill but it's not as if he's a challenge for
    us yet. It's time to get into some basic **AI** or **Artificial Intelligence**
    of a non-playable character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a maximum lifespan to your projectile so it can't remain in the game forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add entity collision detection so it can collide with an enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the projectile's `check` function so that when the projectile collides
    with an enemy, the projectile is killed and the enemy is damaged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `bounciness` so it can bounce off walls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `health` property of your enemy so it does not get hit by the very first
    projectile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bringing your NPCs to life with artificial intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Artificial intelligence can be one of the most complicated, if not *the* most
    complicated element of a game. As the name states, AI is artificial or simulated
    intelligence. The entities in your game will need to act and react to the things
    you as a player are doing to them or their environment. When writing AI, you are
    in effect trying to put the human brain or something more powerful, into the computer.
    For strategy games, AI can make or break the gameplay since it is what keeps the
    player engaged when playing skirmish matches offline. For other genres such as
    2D shooters, you might be contented with enemies who do more than just shooting
    at you. The problem with complicated AI is that it needs to take so many parameters
    into account that it can become almost impossible for a single programmer to fathom.
    Let''s make a division in three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-strategy AI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple-strategy AI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven AI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategies** are patterns of behavior that an entity will follow in a specific
    situation. An enemy can charge at you with full ferocity when at full health,
    but retreat and look for a safe place to heal itself when badly injured. This
    is an example of using two different strategies while a *single strategy* enemy
    might just keep on attacking you until it is dead, regardless of its own life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data driven AI* is something else altogether. It is not hardcoded behavior
    but requires tons of player data, which gets uploaded to a single location. There
    the data is processed and statistical procedures such as regressions, decision
    tree modeling, and neural networks are applied to make the AI more competent in
    the future. What you get is a learning entity, which becomes increasingly harder
    to defeat and automatically invents new strategies depending on the models'' predictions.
    To some people, the thought of a computer being able to learn and adapt behavior
    might be rather scary. However, it is today''s reality, and the future is bound
    to bring increasingly smarter AI. Whether computers will eventually take over
    the world, like in the movies Terminator and The Matrix, remains to be seen.'
  prefs: []
  type: TYPE_NORMAL
- en: For now we will forget about all those data-driven statistical solutions and
    just have a look at a single strategy AI.
  prefs: []
  type: TYPE_NORMAL
- en: When writing AI, we want to keep a clear division between the decision and the
    actual behavior. You can see it as the division between the human brain and the
    body. The brain takes the decision and sends impulses to the body to perform the
    action. For this reason we will write our "brain" in a separate module, while
    the actions an enemy is able to perform will stay in the `enemy` entity itself
    as methods.
  prefs: []
  type: TYPE_NORMAL
- en: The NPC's behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script, name it `ai.js`, and save it under the `plugins` folder
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We kick off by defining our brand new module, our first plugin. Let''s not
    forget to require the script in our `main.js` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The AI will need to give orders to the entity. For this to happen they need
    to speak a common tongue. Just like your legs will need to interpret your nerve
    signals, our enemy will need to interpret the actions it needs to perform at any
    given time. We define these commands in our `init()` function, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `action` array holds all the possible actions the `AI` module can send.
    The `init()` function takes in the entity it needs to command as its input. It
    is not necessary to assign an entity to `this.entity` as shown in the previous
    code snippet (`this.entity=entity;`), but it merely confirms that `this` is not
    the entity itself but its AI. The fact that the input parameter `entity` is not
    assigned to `this` but to `this.entity` would make it possible to have a collective
    `ai`, capable of also making decisions for a group of enemies as a whole. This
    collective AI or hive mind will be addressed in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to your
    Game*.
  prefs: []
  type: TYPE_NORMAL
- en: If you would now take a look at your Firebug DOM in Firefox, you can see the
    `AI` class as part of the `ig` object and it currently only holds the `init()`
    function we just wrote. It's always a good idea to keep a track of how your DOM
    evolves while writing code.
  prefs: []
  type: TYPE_NORMAL
- en: '![The NPC''s behavior](img/4568_3_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have defined the signals we will send, let''s have a look at where
    they end up. Open the `enemy.js` script and add the following `update()` function
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We could write all the behavior in separate methods, which would then take the
    `AI` commands to see if they need to do something. These methods can then be put
    in the `update()` function of the entity in order to keep its orders up to date.
    We are not going to make this division in methods in this case. Because things
    aren't too complex in this case, all behavioral code will fit into the `update()`
    function without creating intermediate methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update()` function now consists of two main parts: a *call to the AI module*
    to receive the action it needs to perform and *actually performing the action*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The action is stored in a local variable called `action` by calling the `ai.getAction()`
    method. However, in order to do this we need to add the AI to our enemy''s `requires`
    function next to the `impact` entity code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also give your enemy a speed parameter, as shown in the following code, since
    the case statements use it for setting their movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All actions that we defined in the `AI` module are represented in the `update()`
    function. In order to make the series of case checks more efficient, a break is
    inserted at the end of each action. This way, once an action matches with the
    case it will stop checking if other cases match. We know that we want to give
    only *one order at every given time* so this makes sense. All code within `update()`
    functions should be written as efficiently as possible since it will be called
    60 times per second if the game runs at a frame rate of 60\. Four of our actions
    are geared towards moving in the correct direction, and then we have `attack`
    and `rest`. To make sure every situation is handled, a `default` value is set.
    This way, if the enemy is given a command that he doesn't understand, he will
    just stay put. You could rewrite the `default` part of the code and overwrite
    it with the `attack` case if you like; this way the enemy will always attack if
    he doesn't understand what he needs to do; barbaric but effective.
  prefs: []
  type: TYPE_NORMAL
- en: In case the enemy attacks, he calls the player's `receive damage` function.
    This is interesting since the `receive damage` method of the player can be overwritten
    in `player.js` to incorporate damage reduction from armor and the like.
  prefs: []
  type: TYPE_NORMAL
- en: However, for now let's take a look at the actual brain or decision making itself.
    Therefore we need to return to our `AI` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the conclusions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The AI of an entity is its ability to make decisions based on external input,
    often using several strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code, the decision making should be separated from the actual behavior where
    possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `ai.js`. As an analogy to the human
    body, this file will contain everything about the brain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `ai.js` script so it becomes an ImpactJS class extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `ai.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the language that will bind behavioral decisions to actual behavior.
    As an analogy to the human body, these would be the electrical impulses your nervous
    system transmits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the actual behavioral patterns an enemy will follow for every command
    he can receive. As an analogy to the human body, this would be the body's reaction
    to certain nerve impulses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the function that calls for an AI command. As an analogy to the human
    body, this function call would be the nerves themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The NPC's decision making process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just saw that the AI `getAction()` method was called but not yet fully explained.
    Its main purpose is to return an action when called. The possible actions here
    are moving in a certain direction, attacking, blocking incoming attacks, or not
    moving at all. What action to take is decided by the distance between the player
    and the `enemy` entity that needs to take the decision, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Add this function to the `AI` module. Just like the `init()` function, it takes
    the entity as an input parameter. A series of local variables is calculated to
    decide what path needs to be taken in order to get to the player. The enemy needs
    to know its distance from the player and the angle towards the player. Collision
    is calculated by use of the `collision.trace()` method. The inputs for this method
    are the entities `position`, `size`, and `distance` to its target, in this case,
    the player. Here you shouldn't see collision as a real physical collision but
    rather as a line of sight. `res.x.collision` should be interpreted as "is the
    player in line of sight if I look in a horizontal line across the screen?"
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the line of sight for the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The NPC''s decision making process](img/4568_3_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If this is the case, there is no more need to move up or down. The same reasoning
    works for the y-axis and moving left or right. This is only to show you how this
    function works leaving out the first two `if` statements, and calculation of the
    `res` variable will still give the same result because of the logic in the next
    two `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A check on the distance between the enemy and the player happens after this.
    If the enemy is close enough to attack (this is hardcoded at `30` pixels), the
    enemy attacks. This cut off could be changed by reading the actual range of the
    enemy and using this instead of just using `30`. Also, the enemy has the opportunity
    to attack once per frame; this makes for 60 attacks per second. Have you ever
    been hit with a sword 60 times in one second? It hurts. We could lower that by
    increasing the chance of the enemy doing nothing at all. Changing these two things,
    the code could look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course you would need to change the actual damage done since 2 damages might
    not be that impressive or challenging for a player with 200 hit points. The following
    code snippet shows the change in damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When the distance between the enemy and the player is 300, the enemy will move
    towards the player. As explained earlier it uses the angle to decide what direction
    to go first. In all other cases, the AI advises the entity to rest. So if the
    player is far away, the enemy will not attack. This way you avoid being attacked
    by all enemies at once. If your speed is greater you can even run away.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one small thing left. As you might have noticed, an action is not
    immediately returned but sent through the `doAction()` method. The following code
    snippet shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This method, which is also added to the `AI` module, is only used to store the
    last action that the entity has performed. You could do without this function,
    but it is often handy to keep track of the last move that was performed. Applications
    for this are not shown in this short AI tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to reload the game at this point, you should have an enemy that
    actually tries to kill you instead of just being passive as a stone(r).
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the brain to act is done with our `getAction()` function. This function
    takes the entity for which a decision needs to be made as an input argument, and
    will return a command or an action. The logic inside this function can be as simple
    or complex as you like. In this example, distance to the player is the most important
    determinant for the action that needs to be taken.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `line of sight` ImpactJS function to determine if the enemy will be able
    to see the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What an AI should do is a totally subjective thing; try adding your own commands
    and behavioral patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pickup items to help out your player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our enemy fights back, we might be in need for some extra assistance
    in the form of the `pickup` items and extra weapons.
  prefs: []
  type: TYPE_NORMAL
- en: One useful `pickup` item would be an instant `healthpotion` entity so that we
    can heal from the damage we got.
  prefs: []
  type: TYPE_NORMAL
- en: Healing your player with a potion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build ourselves an entity called `healthpotion` and include it in the
    `main` script `main.js`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the following code in the `healthpotion.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `healthpotion` entity is a very straightforward entity. It has no real behavior
    except for detecting whether a player touches it and then healing the player if
    he or she does.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting to note here is how the `receiveDamage()` method is used with negative
    damage in order to heal the target. This health potion is used on pickup; it does
    not always have to be like this and some things can be counted by use of a `gameinfo`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `healthpotion.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `healthpotion.js` script with the standard ImpactJS module code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the `healthpotion.js` script in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet and a sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `collision` entity so it can detect when the player touches it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `receivedamage()` function with a negative damage; this will heal the
    player instead of dealing with the damage. Make the `healthpotion` entity destroy
    itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Becoming rich with coins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `coin` entity is an example of an item that we might want to keep a count
    of. It is almost the same as the `healthpotion` entity except for its name, animation
    sheet, and the `check` function, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Instead of healing the player, a method called `addCoin()` is applied. This
    function does not work yet so you can put this line of code in a comment until
    we change this in the section, *Keeping score for player feedback*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s address another issue. If you added the `coin` and `healthpotion`
    entities to the game with the Weltmeister, you might have noticed that you can
    actually kill the `healthpotion` and `coin` entities by shooting them. If you
    don''t like this behavior, it can be fixed by giving every entity a unique name,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check for it in the check functions as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now let's get our score system to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `coin.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `coin.js` file with the standard ImpactJS module code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `coin.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet and a sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `collision` entity so it can detect when the player touches it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When touching the `player` entity, the `coin` entity must destroy itself and
    call the `addcoin()` function, which sends feedback to the game info system. The
    function will be defined later this chapter, so turn it on when implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping score for player feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keeping track of a number of things is all about leaving it outside the currently
    loaded game. This way it can be transferred across levels and even across games.
    Add the following to `main.js` above the `MyGame` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`GameInfo.coins` and `GameInfo.score` will now keep track of how many coins
    we have gathered and what is our current score.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we do need two functions, which will actually increase these game
    properties. Therefore let''s add these functions to the `MyGame` definition in
    the `main.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can safely get the `ig.game.addCoin()` method out of the comments without
    fear of game crashes. Also, we can add a call to the `increaseScore` function
    at the death of an enemy. To do this, we need to change the `kill` function of
    our enemies in the `enemy.js` script, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we keep the original function by adding the `this.parent()`
    line of code but add our code for increasing the score just before it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to restrict ourselves to things that can only go up. We could
    put a limit on the number of projectiles our hero has and keep a count of them.
    Add the initial number of projectiles to the `GameInfo` array as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We are in need of two new functions, which we can add to `MyGame` like we did
    for `addCoin()` and `increaseScore()`. The code for adding the two functions is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new attack code for the `player` entity will look like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First we check whether we have enough projectiles and after launching one, a
    `projectile` entity is subtracted from our original stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! But how do we resupply? We could just create another `pickup` item for
    this purpose as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Add some of these to your game and you will be able to shoot your way through
    anything like a real Rambo!
  prefs: []
  type: TYPE_NORMAL
- en: There are many other appliances for this `GameInfo` array out there, but it's
    up to you to make good use of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Some information needs to be kept outside of the actual game so it can be used
    and stored after a game is finished. This overhead information is kept in a `gameinfo`
    array, defined in the `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `gameinfo` array and reserve a place for storing both the number
    of coins that are collected and the overall score a player achieves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `addcoin()` and `increasescore()` functions. `addcoin()` will increase
    the number of coins by one when called. `increasescore()` can take a numeric input
    parameter, which is the score that it needs to add to the total.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the `addcoin()` function in the `coin` entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the enemy's `kill` method to incorporate the `increasescore()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the same logic, create both the `addProjectile()` and `substractprojectile()`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `player` entity code. So it will check how many projectiles a player
    has before it becomes possible to fire. When a projectile is fired, a `projectile`
    entity is subtracted from the remaining ammo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use everything you learned about `pickup` items to make a `pickup` projectile
    that will replenish the player's ammo supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transitioning from one area to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a map transition for an RPG has been thoroughly explained in [Chapter
    2](ch02.html "Chapter 2. Introducing ImpactJS"), *Introducing ImpactJS*. We will
    just have a quick recap and some pointers in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might remember, we have used a combination of three entity files to
    build gateways between levels. Add the `trigger`, `levelchange`, and `void` entities
    to the `entities` folder and include them in the `main` script, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a level to connect to, we need to build one first. The following screenshot
    shows the `endgame` level to which we should connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitioning from one area to another](img/4568_3_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This level is the `endgame` content; it will soon feature the dangerous boss
    of this little RPG. Don''t forget to include it in `main.js`, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now that all necessary components are ready, connect the level in the same way
    as shown in [Chapter 2](ch02.html "Chapter 2. Introducing ImpactJS"), *Introducing
    ImpactJS*.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `trigger` entity to trigger the `levelchange` entity when the player
    walks over it. The `void` entity is used as the `spawn` location.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing needs to be pointed out here. When the player moves from one area
    (level) to another, his health is reset to the default value because the `levelchange`
    script spawns a new player. This can be avoided by either moving the `health`
    value before loading the new level to an independent array of variables, or by
    changing the `levelchange` script itself. The second option is shown in the following
    code snippet. Open `levelchange.js` to find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Before actually loading the `level` entity, the `health` value is stored to
    a local variable`health`, which is then reassigned to the newly spawned player.
    The same can be done to any attribute, or a temporal copy can be made of the `player`
    entity, which then overwrites the freshly spawned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `trigger`, `levelchange`, and `void` entities from the `chapter 2`
    folder and put them in the `entities` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include all three entities in the `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a level transition using these three entities as shown in [Chapter 2](ch02.html
    "Chapter 2. Introducing ImpactJS"), *Introducing ImpactJS*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `levelchange` entity so the player's health is temporarily stored
    in between level loads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NPCs and conversation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many 2D RPGs the epic story is told by the sole use of text. The player interacts
    with various **NPC**s (**Non Playable Characters**) before he or she can beat
    the game. An enemy is also an NPC but in most contexts, the NPC is regarded as
    the non-hostile character who helps the hero reach his goal by giving hints, quests,
    and items. We will introduce such a peaceful creature and make him speak in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: The speech balloon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this we will use a text balloon, which we treat as an entity of its own.
    Let''s prepare a new JavaScript file and call it `textballoon.js` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We will once again need to let our `main` script know of its existence, so add
    `'game.entities.textballoon'` to the `main` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file we will not only define our `textballoon` entity but also an inner
    class, which we will use in the `textballoon` entity: `WordWrap`. `WordWrap` is
    a class invented by a person who goes under the name of Kingsley on the ImpactJS
    forum, and all thanks should go to him. Once again this proves that looking up
    on forums is a good idea. Someone might have already done what you intend to do.
    `WordWrap` organizes the inputted text in such a way that you can fit it on objects
    such as speech balloons. We can define this class in any of our JavaScript files
    but since it''s used exclusively by our `textballoon` entity, it makes sense to
    place the script as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WordWrap` class is an extension of the general Impact class just like
    our `AI` module. It is in fact a function, which takes three arguments: a piece
    of text, a maximum width for a line of text, and whether the function should cut
    off by character or word. When a new `WordWrap` class is created, these three
    things are assigned to local arguments as can be seen in the `init()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the most important thing is the `wrap` method of the `WordWrap` class.
    It only contains two lines of code but does all the work. In the first line, a
    regular expression is built, which is then interpreted and returned in the second
    line. A regular expression is a flexible way to recognize specified strings of
    text. How this text pattern recognition code works is not covered here since it
    is not within the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the most vital function for our `textballoon` entity, we can
    build the `textballoon` entity itself using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `balloon` entity is not much more than an image with text, which is shown
    on top of everything else (`zIndex = 1000`) when spawned. In the `Init()` method
    of our `balloon` entity, the `WordWrap()` function is used to wrap the text to
    the correct dimensions. It is interesting to note here how the font is initialized
    (`font : new ig.Font(''media/font.png'')`).The font that will be used is already
    present in our `media` folder in the `.png` format and in order to assign it to
    our local variable font, a new impact method is used: `ig.Font()`. Unlike the
    font from Word, here it has a predefined color and size. A free font tool is available
    if you want to make your own font for your ImpactJS game on the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://impactjs.com/font-tool/](http://impactjs.com/font-tool/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a variable called `lifeTime`, which will keep track of the remaining
    number of frames until the `balloon` entity is dismissed. This check is done in
    the `update()` function as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In every new frame, the lifetime drops by one. When the `lifeTime` value reaches
    `0`, the `balloon` entity is killed. More intelligent balloon timers could be
    implemented by counting the amount of text that should be read and adjusting the
    time you have to read it, but this is a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we will need is the entity''s `draw()` method. `Draw()` is called
    for every frame just like the `update()` function, but is dedicated to what needs
    to be displayed as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'All entities have a `draw` method and it is called automatically. We will have
    a look at it now because our balloon needs to be adjusted a bit. In the `draw()`
    function, first its parent function is called followed by positioning and drawing
    the text that needs to be shown on top of our balloon. The order of things is
    very important here. If you would first draw the text and put `this.parent();`
    at the end, the text will be written first, followed by the balloon. You can try
    this once we have an entity to spawn our `balloon` entity; for now you should
    get an empty speech balloon. The following screenshot shows a fully functioning
    speech balloon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The speech balloon](img/4568_3_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a fully functioning speech balloon, it is time to introduce
    an entity that wants to talk to us: the `NPC` entity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the conclusions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lots of games have friendly creatures walking about and providing the player
    with hints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A talking character consists of a friendly `NPC` entity and its speech balloon,
    which can be regarded as a separate entity. Additionally, we make use of a `wordwrap()`
    function, which will keep the sentences within the borders of the speech balloon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `textballoon.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `wordwrap()` function as an extension to the `ImpactJS` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `textballoon.js` file with the standard ImpactJS module code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `textballoon.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet, an animation sequence, a size, and a default position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the z-index property to a high number so the speech balloon is always shown
    on top of every other entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `wordwrap()` function to transform a text of your choice and add it
    as a property of the speech balloon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to make your own font for your game, use the ImpactJS font tool
    to convert it into a file that Impact can use. The font tool is located at the
    following URL: [http://impactjs.com/font-tool/](http://impactjs.com/font-tool/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `update` function of the speech balloon so that it will keep track
    of how much time has passed since the speech balloon was spawned. The `update`
    function will also kill off the balloon when a preset number of frames have past.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the default `draw` function so it will draw your text on top of the
    speech balloon itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a talking non-playable character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and save it as `Talkie.js`. `Talkie` will be the name of
    our lovely NPC as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Like for any regular entity, the `Talkie` script properties are defined before
    or in the `init()` function, depending on whether you wish to write them in the
    literal notation or not, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`Talkie` has two states, either he is doing nothing (`idle`) or he is talking
    (`Talk`) and his animation changes accordingly. He should only stay in the `Talk`
    state while the balloon is there, so a timer is set to synchronize the balloon
    with Talkie''s animation using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The animation remains in place for `200` frames; when done Talkie returns to
    his idle state.
  prefs: []
  type: TYPE_NORMAL
- en: '`Talkie` needs to check if the player is in the vicinity so he can start talking.
    When the player is close, the `textballoon` entity is spawned and Talkie will
    not talk again. `ig.game.sortEntitiesDeferred()` resorts the entities in the game
    by its z-value; this way you are sure the balloon is shown on top. The following
    code is used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our Talkie code finished, try adding him to one of the levels
    and get near him. A balloon should pop up saying **Epicness awaits you!**
  prefs: []
  type: TYPE_NORMAL
- en: Talkie is right because we are almost at the end of our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We now need a character capable of delivering the message to the player. We
    will call this character `Talkie`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `Talkie.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `Talkie.js` file with the standard ImpactJS module code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `Talkie.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet, an animation sequence, a size, name, and several other
    properties for the Talkie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property `talked`, which keeps track of whether Talkie already talked
    or not. And a property `times`, which is the number of frames for which the Talkie
    needs to look as if he is actually talking. The time span for which the talk animation
    is shown is best to be equal to the life span of the speech balloon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the `update` function to make the speech animation work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the `check` function and collision detection so that a `textballoon`
    entity is spawned when the player touches the Talkie if he has not yet talked
    before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final battle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually a game ends with a grand finale; a boss of great strength, you need
    to slay in order to reap everlasting fame!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the final `Boss` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Boss` entity is nothing more than a strong enemy. There is
    no need to do an exact copy and paste of the `enemy` entity and adjust code separately
    on the elements they share. It is more efficient to extend the `enemy` class and
    only fill out the differences. Our boss has another name, more health, more speed,
    looks different, and takes less damage from a hit. In order to be able to build
    upon the original `enemy` entity, you need to include it in its `require` function.
    As the enemy is already built upon the ImpactJS `entity` class, there is no more
    need to include `impact.entity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to tell the `projectile` entity that it is also allowed
    to hit the `Boss` entity, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In `projectile.js`, the `if` statement is adjusted to cope with our `Boss` entity.
    You might have noticed that the death of our enemy triggers the end of the game.
    We will look into that and the opening splash screen in [Chapter 5](ch05.html
    "Chapter 5. Adding Some Advanced Features to Your Game"), *Adding Some Advanced
    Features to Your Game*. You can add a `Boss` entity to the `endgame` level and
    fight him for glory!
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the conclusions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A final boss is often the long anticipated antagonist that a player needs to
    defeat in order to finish a game or stage. He often has more health, does more
    damage, and thus is generally harder to defeat than a regular foe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can base our boss's character on a regular enemy by extending the `enemy`
    class when creating the `boss` entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `Boss.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `Boss.js` file by extending the `enemy` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `Boss.js` in your `main` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change all the properties that need to distinguish the boss from a lesser foe.
    This includes health, damage, speed, and even armor. Armor can be implemented
    as a damage reduction by overwriting the `receivedamage()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the `receivedamage()` function to make sure the end of the game is
    called when the boss dies. This GameEnd is explained in [Chapter 5](ch05.html
    "Chapter 5. Adding Some Advanced Features to Your Game"), *Adding Some Advanced
    Features to Your Game* so you can turn it off for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the `projectile` entity so it also damages the `Boss` entity and not just
    the `enemy` entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have been able to build our own top-down game from scratch.
    In order to do this, we have built levels with the ImpactJS Weltmeister and added
    a controllable character known as **player**. The game becomes more challenging
    by adding intelligent enemies and the weapons to defeat them. We were able to
    add some more depth to the game by introducing a friendly NPC. The final element
    was keeping score in order to provide the player with some feedback on how well
    he or she is doing.
  prefs: []
  type: TYPE_NORMAL
