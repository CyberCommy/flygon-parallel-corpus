- en: Chapter 3. Let's Build a Role Playing Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we took a look at several key concepts and zoomed in
    on them one by one, largely disregarding their underlying dependencies. Now we
    will build up a game step by step. In this chapter we will take a look at the
    RPG, while in [Chapter 4](ch04.html "Chapter 4. Let's Build a Side Scroller Game"),
    *Let's build a Side Scroller Game*, we will dive into the side scroller game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The RPG game format and its possible sub formats
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an actual level for your player to explore and connecting it to other
    levels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a playable entity, slayable but dangerous foes, and neutral talkative
    characters to the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning your player into a force to be reckoned with by adding weapons and helpful
    items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some depth to the player's enemies by bestowing them with basic artificial
    intelligence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of some changes in the game such as the collections of coins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ending the game by pitting the player against a more formidable foe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RPG game setting
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the RPG game setting it would be good to have a look at
    some successful RPGs and see what we can learn from them. There are some great
    examples out there: **Zelda** , **Final Fantasy** , **Pokémon** , **World Of Warcraft**
    , **Tibia** , **Baldur''s Gate** , **Neverwinter Nights** , and so on. The list
    is virtually endless. What made all these games so successful? Well, there is
    always the marketing component, but no game can reap eternal fame on marketing
    alone. So what was their *unique gaming proposition* for the audience they targeted?
    Game reviewers often divide their marks over several categories such as gameplay,
    graphics, sound, and so on. These are valid points, but why not have a look at
    addictiveness for example? Even the simplest game can be addictive. If you have
    ever been to Vegas and witnessed the tons of people playing for hours on slot
    machines that require no skill at all, you will understand that there is something
    special about game psychology.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Addictiveness is of course great, if you offer a free game and want to make
    money from in-game advertising or recurring subscription fees. Another approach
    is making the game engaging but final. Those are the games you can actually "finish".
    They usually have an interesting story between the games' protagonist and antagonist.
    When the antagonist is defeated, the game ends and as a player you are unlikely
    to pick it up again. An example would be every game within the Final Fantasy series.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Most RPGs apart from **MMORPG**s (**Mass Multiplayer Online Role Playing Game**)
    are in this second category. They often have a fascinating story and mesmerizing
    music. The characters are really interesting and deep. The battle system is very
    intuitive and yet complicated enough for someone to be either good or bad at it.
    The really good ones tend to leave a lasting impression on anyone who played them,
    and they cost a lot of work to put together.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This is the standard way of looking at an RPG. However, this should in no way
    hold you back from refreshing the genre and throwing some elements from other
    genres or totally new ideas into the mix. For example, **Borderlands** is a crossbreed
    of an RPG and a shooter. It has level progression and weapon enhancement like
    most RPGs. It has a story and at the same time it still plays like a shooter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A game does not need to mix up two computer genres. **Minecraft** is essentially
    the pleasure of playing with Lego brought to a computer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: What it boils down to is finding out for yourself what things you enjoy the
    most or enjoyed greatly as a kid. Find the underlying mechanic at work and try
    to replicate that feeling in a game. This is all easier said than done for sure.
    However, it is necessary to go through this process since it is your time that
    it will take up to build the game, and if it isn't even a game you yourself would
    like to play, why would others want it?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: For RPGs, it often gets more complicated than simply finding an original gameplay
    component. RPG video games can be a mix between a great book and a movie with
    the merits of interactivity thrown in. If you are a great story teller, or know
    one, why not do it this way? A game does not need to be difficult or graphically
    perfect for people to play. A good example is Final Fantasy VII, which was a big
    hit in the 1990s. In 2012 it was rereleased with "polished graphics". There is
    not much difference; an untrained eye wouldn't immediately notice the polishing.
    But it's still a great game, regardless of the fact that it can't compete with
    the complexity and graphical splendor of games such as Skyrim or Fable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RPG游戏来说，通常会比简单找到原创的游戏组件更加复杂。RPG视频游戏可以是一本好书和一部电影的结合，同时具有互动性的优点。如果你是一个很好的故事讲述者，或者认识一个，为什么不这样做呢？游戏并不需要难以或者图形完美才能吸引人们玩。一个很好的例子是《最终幻想VII》，它在1990年代大获成功。2012年，它以“优化图形”的形式重新发行。实际上并没有太大的区别；一个不经训练的眼睛不会立即注意到这种优化。但它仍然是一款很棒的游戏，尽管它无法与《上古卷轴》或《寓言》等游戏的复杂性和图形辉煌相竞争。
- en: 'This is what you should be aiming at: take the *core pleasure* you want your
    game to have, package it with as little complexity as you possibly can, and add
    happy, pastel-colored graphics. Happy graphics are great. No, seriously, if you
    want your game to radiate darkness and fear, that''s fine too, but otherwise,
    certainly consider smiling clouds and crazy looking animals.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你应该追求的目标：以尽可能少的复杂性打包你想要的*核心乐趣*，并添加快乐、柔和的图形。快乐的图形很棒。不，说真的，如果你想让你的游戏散发出黑暗和恐惧，那也可以，但除此之外，一定要考虑一些微笑的云和疯狂的动物。
- en: Building an RPG level
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个RPG关卡
- en: 'Now it is time to put our own little RPG together. We will start our journey
    with a clean slate. Following are the steps to build an RPG level:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始组建我们自己的小型RPG了。我们将从零开始我们的旅程。以下是构建RPG关卡的步骤：
- en: Let's take a copy of the freshly installed `ImpactJS` folder that we kept in
    the `chapter 1` folder and rename it to `RPG`. Copy the `media` folder from the
    `chapter 3` folder to your `RPG/media` folder. This way at least we have some
    graphics to work with.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制我们在`第1章`文件夹中保留的新安装的`ImpactJS`文件夹，并将其重命名为`RPG`。将`第3章`文件夹中的`media`文件夹复制到你的`RPG/media`文件夹中。这样至少我们有一些图形可以使用。
- en: Go back to the **it works!** screen you get when you enter `localhost/RPG` in
    your browser.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到当你在浏览器中输入`localhost/RPG`时得到的**它起作用了！**屏幕。
- en: Let's start by opening the Weltmeister (`localhost/Weltmeister.html`) and drawing
    a small level.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开Weltmeister（`localhost/Weltmeister.html`）并绘制一个小关卡开始。
- en: You will notice that there is nothing prepared for you this time around. The
    only available layer is the `entities` layer and it doesn't even contain a single
    entity. However, we can draw ourselves a small playing field to get started once
    we have something to populate the world.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次你会注意到没有为你准备好任何东西。唯一可用的层是`entities`层，甚至连一个实体都没有。然而，一旦我们有了一些东西来填充世界，我们就可以画一个小的游戏场地来开始。
- en: So let's add another layer (*+-*sign) and call it `grass`. Let's set the tile
    size to `16` and have a 30 x 20 zone at a distance of 1 pixel. Select the tileset
    `grass.png` and click on the **Apply Changes** button before you can start laying
    down the grass.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以让我们添加另一个层（*+-*符号）并将其命名为`grass`。让我们将瓷砖大小设置为`16`，并在距离1像素处有一个30 x 20的区域。选择瓷砖集`grass.png`，然后点击**应用更改**按钮，然后你就可以开始铺设草坪了。
- en: If you don't have your drawbox centered just right for you, hold the *Ctrl*
    key and move your mouse until it is centered. If for some reason it is too big
    to fit on your screen, zoom out with your mouse scroll wheel.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的绘图框没有完全居中，按住*Ctrl*键并移动鼠标直到它居中。如果由于某种原因它太大而无法适应你的屏幕，可以用鼠标滚轮缩小。
- en: Once we have painted this entire layer in green, we can easily add another one
    to sit on top of the grass. But before you do so, save your file as `level1`.
    Saving often is a virtue.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们把整个层都涂成绿色，我们就可以轻松地添加另一个层放在草坪上。但在这样做之前，将你的文件保存为`level1`。经常保存是一种美德。
- en: When adding layers you can name and use them by what they are supposed to represent.
    For instance, you have a layer for furniture, plants, and miscellaneous objects.
    This is a decent way of working, but you have to keep in mind that some layers
    will visually come in front of your player and monster entities, while others
    will appear behind them. Even something as simple as a single wall is best drawn
    with two layers.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加层时，你可以根据它们应该代表的内容进行命名和使用。例如，你可以有一个家具、植物和杂项物品的层。这是一个不错的工作方式，但你必须记住，一些层在视觉上会出现在你的玩家和怪物实体的前面，而其他层则会出现在它们的后面。即使是一个简单的墙最好也用两层来绘制。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Weltmeister does not support an endless number of layers. In order to keep
    the number of layers respectable, you can have tilesets for specific levels. For
    instance, you have two level settings: a city and a dungeon. Both can contain
    a chair, so don''t be afraid to have the same chair on a tileset for your city
    and on a different tileset to construct your dungeon. Duplicating information
    will increase your overall game size but can decrease the number of layers necessary
    for a single level.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Weltmeister不支持无限数量的层。为了保持层的数量可观，你可以为特定的关卡设置瓷砖集。例如，你有两个关卡设置：城市和地牢。两者都可以包含一把椅子，所以不要害怕在城市的瓷砖集上放置相同的椅子，也在不同的瓷砖集上构建你的地牢。重复信息会增加你的整体游戏大小，但可以减少单个关卡所需的层数。
- en: Our grass is just called `grass` because we won't have grass that will float
    in front of our player; consequently we don't require a second grass layer. Let's
    make two new layers called `vegetation_back` and `vegetation_front`. `vegetation_back`
    must be positioned underneath the `entities` layer in the layer selection menu.
    `vegetation_front` must be put above the `entities` layer. Together these two
    new layers will make up all the vegetation on the map.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的草地只叫`grass`，因为我们不会有草地漂浮在玩家面前；因此我们不需要第二层草地。让我们创建两个新图层，分别叫做`vegetation_back`和`vegetation_front`。`vegetation_back`必须在图层选择菜单中的`entities`图层下面。`vegetation_front`必须放在`entities`图层上面。这两个新图层一起将构成地图上的所有植被。
- en: Select the tileset `tree.png` and use the same settings for the `grass` layer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择图块集`tree.png`，并为`grass`图层使用相同的设置。
- en: 'Draw the upper part of a tree with the `vegetation_front` layer and the lower
    part with `vegetation_back`. The following screenshot shows the different layers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vegetation_front`图层绘制树的上部，使用`vegetation_back`绘制下部。以下屏幕截图显示了不同的图层：
- en: '![Building an RPG level](img/4568_3_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Building an RPG level](img/4568_3_1.jpg)'
- en: 'The following are the layers you should currently have in your Weltmeister
    **Layers** menu:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Weltmeister **Layers**菜单中应该有以下图层：
- en: '![Building an RPG level](img/4568_3_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Building an RPG level](img/4568_3_2.jpg)'
- en: If you have no idea what the upper part or lower part of anything should be,
    think about how big your player and/or enemies will be. When walking past the
    tree, their heads or feet should not disappear. In order to avoid the player walking
    through the tree altogether, we will need another layer, the collision layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道任何东西的上部或下部应该是什么，想想你的玩家和/或敌人有多大。当走过树时，他们的头或脚不应该消失。为了避免玩家完全穿过树，我们需要另一个图层，碰撞图层。
- en: Add a layer with the name `collision` to the Weltmeister.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Weltmeister中添加一个名为`collision`的图层。
- en: Don't forget, you can make a layer visible in Weltmeister by either dragging
    it to the top of the layer stack or switching off the layers that are blocking
    the view. In this case, the `grass` layer will probably block all the view if
    the collision layer is at the bottom of the stack. It's pretty efficient to drag
    the `collision` layer to the top and just turn it on and off when necessary. Settings
    for setting up the layer are the same as always.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以通过将图层拖到图层堆栈的顶部或关闭挡住视野的图层来在Weltmeister中使图层可见。在这种情况下，如果碰撞图层在堆栈的底部，`grass`图层可能会挡住所有的视野。将`collision`图层拖到顶部并在必要时打开和关闭它是非常有效的。设置图层的设置与以往一样。
- en: 'With the `collision` layer, draw a border around the level so no one can escape.
    Also put some collision squares in the tree trunk just underneath or above the
    dividing line between the front and back layers, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`collision`图层，在关卡周围绘制边界，这样就没有人可以逃跑了。还在树干下面或上面的分界线附近放一些碰撞方块，如下图所示：
- en: '![Building an RPG level](img/4568_3_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Building an RPG level](img/4568_3_3.jpg)'
- en: 'So we created a viable environment. It''s not much but it''s a start. However,
    for the level to load, we need to make changes to our `main.js` script as shown
    in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们创建了一个可行的环境。虽然不多，但这是一个开始。然而，为了加载关卡，我们需要对我们的`main.js`脚本进行更改，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to make sure our game finds the level, we need to include it in the
    `.requires` part of our module. We need to point to it in the same way as we would
    to any file, starting from our game root folder. The only difference is that slashes
    (`/`) are replaced by dots (`.`) and the included file itself is always considered
    to have the `.js` extension. For example, `/game/levels/level1.js` becomes `game.levels.level1`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的游戏能找到关卡，我们需要在模块的`.requires`部分包含它。我们需要以与任何文件相同的方式指向它，从我们的游戏根文件夹开始。唯一的区别是斜杠(`/`)被点(`.`)替换，而包含的文件本身总是被认为有`.js`扩展名。例如，`/game/levels/level1.js`变成了`game.levels.level1`。
- en: 'We also need to load the level at game startup, so let''s add a `loadlevel()`
    method to the `init()` function. Don''t forget that the parameter to call this
    function always has the following form:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在游戏启动时加载关卡，所以让我们在`init()`函数中添加一个`loadlevel()`方法。不要忘记，调用这个函数的参数总是以下形式：
- en: '`Level + Levelname` in capital letters. Anything else will crash the game.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大写字母的`Level + Levelname`。其他任何形式都会导致游戏崩溃。
- en: 'We now have a loaded level but there is nothing interactive about it; we have
    no player yet. And although having **it works!** on the screen at all times is
    quite motivating, it''s also mildly blocking our vision. So let''s delete the
    following code from `main.js` and move on to our `player` entity using the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个加载的关卡，但它没有任何交互性；我们还没有玩家。尽管在屏幕上始终显示**it works!**相当激励，但也会轻微地阻碍我们的视野。所以让我们从`main.js`中删除以下代码，然后继续使用以下代码来创建我们的`player`实体：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: We need to start building our game from scratch in this chapter. Therefore we
    need the originally downloaded ImpactJS files. Put them in a separate folder in
    your server working directory. Also test whether you get the **it works!** message.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从头开始构建我们的游戏。因此，我们需要最初下载的ImpactJS文件。将它们放在服务器工作目录的一个单独文件夹中。还要测试一下是否收到了**it
    works!**消息。
- en: Add the `chapter 3` folder's `media` files to the folder you just set up.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chapter 3`文件夹的`media`文件添加到你刚刚设置的文件夹中。
- en: Open the Weltmeister level editor and make a layered level. You need a collision
    layer, an entities layer, and three graphical layers. The bottom graphical layer
    will represent the grass. The other two layers represent all other objects that
    will show up in front of or behind the player.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Weltmeister关卡编辑器并创建一个分层关卡。你需要一个碰撞图层，一个实体图层和三个图形图层。底部的图形图层将代表草地。其他两个图层代表所有其他在玩家前面或后面出现的对象。
- en: Draw the graphical layers.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制图形图层。
- en: Include the level file in your `main` script.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`脚本中包含关卡文件。
- en: Delete the `it works!` message from the `main` script.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`main`脚本中删除`it works!`消息。
- en: Adding a playable character
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可玩角色
- en: In order to build our player from scratch we need a new (and empty) `.js` file.
    Create a new file in your code editor and even though it's empty, save it as `player.js`
    in the `entities` folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从头开始构建我们的玩家，我们需要一个新的（并且是空的）`.js`文件。在你的代码编辑器中创建一个新文件，即使它是空的，也将其保存为`entities`文件夹中的`player.js`。
- en: 'Every module starts out in the same way. It consists of the `ig.module()` ,
    `ig.requires()`, and `ig.defines()` methods. For some modules you will not need
    the `requires()` method but all entities will, because here you need to include
    the `impact` script for entities, as shown in the following code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都是以相同的方式开始的。它由`ig.module()`，`ig.requires()`和`ig.defines()`方法组成。对于一些模块，你不需要`requires()`方法，但所有实体都需要，因为在这里你需要包含实体的`impact`脚本，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to build the player based on the `prototype` entity. This prototype
    has several attributes (such as `health` and `velocity`) and several methods (such
    as `kill()` and `receiveDamage()`) predefined. This way we only need to extend
    the original version with the `extend()` method in order to create our player.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据`prototype`实体构建玩家。这个原型有几个属性（比如`health`和`velocity`）和几个方法（比如`kill()`和`receiveDamage()`）预定义。这样我们只需要用`extend()`方法扩展原始版本，就可以创建我们的玩家了。
- en: There are some rules here. If your JavaScript file is called `player.js`, your
    entity will be called `Player`. You assign it to an extension of the `entity`
    prototype by adding `Entity` in front of its name, as shown in the previous code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则。如果你的JavaScript文件叫做`player.js`，你的实体将被称为`Player`。你可以通过在其名称前面添加`Entity`，将其分配给`entity`原型的扩展，如前面的代码所示。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Any deviation from the naming conventions will remove the entity from the Weltmeister
    **Entities** menu. Adding an entity to the Weltmeister editor when it is correctly
    named, and loading the game with faulty naming will result in a crash.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何与命名约定的偏离都将从Weltmeister **Entities**菜单中移除实体。将实体添加到Weltmeister编辑器时，如果命名正确，加载游戏时命名错误将导致崩溃。
- en: 'Also don''t forget to include the `player` entity in the `requires()` method
    within `main.js`. A module can only be used when the `main` module knows about
    its existence. The following code shows that the extension `.player` is assigned
    to the `entities` folder:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要忘记在`main.js`中的`requires()`方法中包含`player`实体。只有当`main`模块知道其存在时，模块才能被使用。以下代码显示了扩展`.player`被分配给`entities`文件夹：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you add the `player` entity to the game with the Weltmeister right now,
    you would notice that there is nothing to see. The player has no visual representation
    yet, we address this issue in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在用Weltmeister添加`player`实体到游戏中，你会注意到什么也看不到。玩家还没有视觉表示，我们将在下面的代码中解决这个问题：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to get a glimpse of our playable character, we need to add an animation
    sheet, which is located in our `media` folder. The animation sheet needs to be
    assigned with the right dimensions if you don't want to see just pieces of your
    characters walk about. We also gave the entity a size. The animation can actually
    be bigger than the size of an entity. If you do not set a size, you will see that
    you can select the `player` entity in Weltmeister, but its boundaries do not encompass
    the entire image. This is because the default size is 16 x 16\. Size is a relevant
    property for collision detection. We also gave the player some health to get started.
    The default health is 10.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们可玩角色的一瞥，我们需要添加一个动画表，它位于我们的`media`文件夹中。如果你不想看到你的角色只是走来走去的话，动画表需要被分配正确的尺寸。我们还给实体分配了一个大小。动画实际上可以比实体的大小大。如果你不设置大小，你会发现你可以在Weltmeister中选择`player`实体，但它的边界并不包含整个图像。这是因为默认大小是16
    x 16。大小是碰撞检测的相关属性。我们还给玩家一些生命值来开始。默认生命值是10。
- en: We are also confronted with the `entity` prototype's `init()` method. The `entity`
    prototype already has its own `init()` function, so it's best to include this
    by calling the `parent()` method within the `init()` function. Having an animation
    sheet defined does not make the entity animated. You need to assign an action
    to the animation sheet. Here, *idling* corresponds to the first image on the sheet.
    You can now safely add your player to the map.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还面临着`entity`原型的`init()`方法。`entity`原型已经有了自己的`init()`函数，所以最好通过在`init()`函数中调用`parent()`方法来包含它。定义动画表并不会使实体动画化。你需要为动画表分配一个动作。在这里，*空闲*对应于表上的第一张图片。现在你可以安全地将你的玩家添加到地图上了。
- en: Great, we have a player in our game! Too bad it doesn't move. Let's work on
    that right now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们的游戏中有了一个玩家！太糟糕了，它还不能移动。让我们现在来解决这个问题。
- en: 'In the `main.js` script you are to add the following to your `init()` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`脚本中，你需要在你的`init()`方法中添加以下内容：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will make sure your arrow keys are bound to an *input state*. From now
    on the game will check automatically whether any of these keys are pressed. Since
    we are building a top-down game here, we need to be able to walk in any direction.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保你的箭头键绑定到一个*输入状态*。从现在开始，游戏将自动检查这些键中是否有任何一个被按下。由于我们在这里正在构建一个俯视游戏，我们需要能够朝任何方向行走。
- en: 'In the `player.js` script, four new animation sequences will need to be added
    to the `init()` function as shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`player.js`脚本中，需要在`init()`函数中添加四个新的动画序列，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the animation sequence of `idle` was composed of one image, we now need
    to assign a true sequence for every direction in which our player can walk. Again,
    the `0.1` value is the time in between images.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`idle`的动画序列由一张图片组成，但现在我们需要为玩家可以行走的每个方向分配一个真正的序列。同样，`0.1`值是图像之间的时间。
- en: In addition, you will need to call and extend the `entity` prototype's `update()`
    function. Don't forget to have a comma to separate the `init()` and `update()`
    functions or you will get an error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要调用和扩展`entity`原型的`update()`函数。不要忘记在`init()`和`update()`函数之间加上逗号，否则会出错。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `update()` function, like `init()`, is a standard method of the prototype
    `entity`. Therefore we need to call the parent function if we don't want to lose
    its ImpactJS entity core functionalities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`函数和`init()`一样，是原型`entity`的标准方法。因此，如果我们不想失去其ImpactJS实体核心功能，我们需要调用父函数。'
- en: For every input state we need separate behavior, so we have this set of *if-then
    operators*. Remember that since we put this code in the `update()` function, it
    is run every time the game goes through an update loop, which is once per frame.
    The `init()` function is only called once, that is, at the moment of player creation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入状态，我们需要单独的行为，因此我们有这组*if-then操作符*。请记住，由于我们将这段代码放在`update()`函数中，它会在游戏每次更新循环时运行，即每帧一次。`init()`函数只会被调用一次，也就是在玩家创建的时候。
- en: 'Within the condition checks, we do two things: allocate a speed on the relevant
    axis and add an animation. If the player does nothing, the velocity in both directions
    is also set to `0`, so continuous input is required for the player to move.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件检查中，我们做了两件事：在相关轴上分配速度并添加动画。如果玩家什么也不做，那么两个方向上的速度也被设置为`0`，因此玩家需要持续输入才能移动。
- en: Instead of `ig.input.state` we could use `ig.input.pressed` . But that would
    result in our player having to button mash his way through the level. For, every
    time he or she presses one of the move buttons, the player would only move a small
    bit and stop immediately. In case of 60 fps and a velocity of 100, the player
    would move 100/60 = 1.67 pixels for one touch. Although `ig.input.pressed` certainly
    has its merits, moving in this way might annoy even the most patient of gamers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ig.input.pressed`而不是`ig.input.state`。但这将导致我们的玩家不得不通过按钮来穿过关卡。因为每次他或她按下移动按钮时，玩家只会移动一小段距离然后立即停下。在60
    fps和速度为100的情况下，玩家每次触摸只会移动100/60 = 1.67像素。尽管`ig.input.pressed`当然有其优点，但以这种方式移动可能会让即使是最有耐心的玩家也感到恼火。
- en: 'We finally have a playable character that moves around gracefully! It can even
    hide behind the tree we created earlier. We still have another problem on our
    hands though, we can''t see our player at all times. Can you imagine the frustration
    of a player getting killed by something because he couldn''t see where he was
    going? I''m sure you can and it has probably even happened to you if you have
    played some games in the past. However, we are in luck because a camera that follows
    the player around is easy to implement, as shown in the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于有了一个优雅移动的可玩角色！它甚至可以躲在我们之前创建的树后面。不过我们手头还有另一个问题，我们不能始终看到我们的玩家。你能想象一个玩家因为看不到自己的位置而被杀死的沮丧吗？我相信你可以，而且如果你过去玩过一些游戏，这种情况可能甚至发生过。不过，我们很幸运，因为一个跟随玩家四处走动的摄像头很容易实现，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding code, two important elements and the player
    are assigned to a local variable. Then the viewport coordinates are set to the
    player's position. If you wanted your camera to put the player in the top-left
    corner of the screen, you wouldn't need your game canvas. But of course, we want
    the player centered, so we adjust its position by half the size of the canvas
    in both dimensions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，两个重要的元素和玩家被分配给了一个本地变量。然后，视口坐标被设置为玩家的位置。如果您希望相机将玩家放在屏幕的左上角，您就不需要游戏画布。但当然，我们希望玩家居中，所以我们通过画布尺寸的一半来调整其位置。
- en: On reloading the browser, you will notice that you can finally walk to the bottom
    of your screen and underneath the tree. Great! Just too bad that there is nothing
    to do here, so next we will introduce something hostile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载浏览器后，您会注意到您终于可以走到屏幕底部和树下面。太好了！只是可惜这里没有什么可做的，所以下一步我们将引入一些敌对的东西。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `player.js`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`player.js`。
- en: Set up the `player.js` script with the standard ImpactJS module code.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`player.js`脚本。
- en: Include `player.js` in your `main` script.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`脚本中包含`player.js`。
- en: Add an animation sheet and sequence to your playable character so that it can
    be found in the Weltmeister. Also provide him with health and a size.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为可玩角色添加动画表和序列，以便在Weltmeister中找到它。还为其提供健康和大小。
- en: Add player controls by binding keyboard keys to input states in the `main` script.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将键盘键绑定到`main`脚本中的输入状态来添加玩家控制。
- en: Bind these input states to move the character's action by manipulating its velocity.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些输入状态绑定到移动角色动作，通过操纵其速度。
- en: Make the movement appear as a smooth animation by introducing extra animation
    sequences and calling them when certain input states are active.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过引入额外的动画序列并在某些输入状态激活时调用它们，使移动看起来像是平滑的动画。
- en: Put in a camera that automatically follows the player around wherever he ventures.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置一个自动跟随玩家四处走动的摄像头。
- en: Introducing a defeatable opponent
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入一个可击败的对手
- en: Again, we will have to start from scratch, so open up a blank JavaScript file
    and save it as `enemy.js`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将不得不从头开始，因此打开一个空的JavaScript文件，并将其保存为`enemy.js`。
- en: The start of entity creation is always the same. Set up your `Entity` file and
    add an `enemy` entity to your `main` script.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实体创建的开始总是相同的。设置您的`Entity`文件并将`enemy`实体添加到您的`main`脚本中。
- en: 'In `main.js.requires` add the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js.requires`中添加以下代码：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `enemy.js` add the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enemy.js`中添加以下代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Adding the previous code snippets creates our entity, which we can add to the
    level by use of the Weltmeister. However, it''s still pretty useless so let''s
    first add some graphics using the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前面的代码片段创建了我们的实体，我们可以通过Weltmeister将其添加到关卡中。不过它还是相当无用的，所以让我们首先使用以下代码添加一些图形：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can add our first enemy to the level. It won't do much though, and you
    will even be able to walk right through him as if he isn't there. This is because
    no collision between entities has been specified yet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的第一个敌人添加到关卡中。不过它不会做太多事情，甚至你甚至可以穿过他走。这是因为实体之间还没有指定碰撞。
- en: Add the following code to the `player` and `enemy` entity as a property. You
    can add them in the `init()` function with the old JavaScript notation or above
    `init()` in literal notation, as shown in the following code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`player`和`enemy`实体作为属性。您可以使用旧的JavaScript表示法在`init()`函数中添加它们，或者在文字表示法中在`init()`上方添加，如下面的代码所示。
- en: 'The following code is for the player:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于玩家的：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code is for the enemy `entity`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于敌人`entity`的：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now push our enemy around the level like a real bully. You might have
    noticed that there is still some space in between the player and the enemy. This
    is because the boundaries of the entities are rectangles, which more than encompass
    the actual drawings. It''s pretty annoying for a player to get hit by an enemy
    when visually it''s not the case. To rectify the situation we need to introduce
    `offset` as a player property. The `size` property determines the size of the
    collision box around the entity. The `offset` property makes your collision box
    shift a few pixels to the right or down. Of course, you can enter a negative number
    at a point at which it will shift left and/or upward. We will need to combine
    these two properties to make a new collision box for the player, which makes him
    harder to hit. However, before proceeding it''s useful to turn on the ImpactJS
    debugger by adding the following line of code to the `main.js` script in the `requires()`
    method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像真正的恶霸一样推动我们的敌人在关卡中四处走动。您可能已经注意到玩家和敌人之间仍然有一些空间。这是因为实体的边界是矩形，远远超出了实际的绘图范围。当视觉上并非如此时，玩家被敌人击中是非常恼人的。为了纠正这种情况，我们需要将`offset`引入为玩家属性。`size`属性确定了实体周围的碰撞框的大小。`offset`属性使您的碰撞框向右或向下移动几个像素。当然，您可以在一个点输入一个负数，它将向左和/或向上移动。我们需要结合这两个属性来为玩家制作一个新的碰撞框，使他更难被击中。但是，在继续之前，通过在`main.js`脚本的`requires()`方法中添加以下代码行来打开ImpactJS调试器是有用的：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s a good habit to have this debugger switched on during development. You
    can delete this code again when preparing it for release. Let''s change the size
    and offset for both player and enemy using the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中保持调试器打开是一个好习惯。当准备发布时，您可以再次删除此代码。让我们使用以下代码更改玩家和敌人的大小和偏移：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The actual image size is 32 x 48\. We changed the size of both entities to
    `18` x `40` with an offset of `7` x `4`. If you open the debugger on the **Entities**
    tab and turn on **Show Collision Boxes**, you will notice the difference in size.
    You might also notice static collision, such as the squares of the collision layer
    that we added to the middle of the tree are not visible because it only shows
    collision for entities, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际图像大小为32 x 48。我们将两个实体的大小都改为`18` x `40`，偏移为`7` x `4`。如果您在**Entities**选项卡上打开调试器并打开**显示碰撞框**，您会注意到大小的差异。您还可能注意到静态碰撞，例如我们添加到树中间的碰撞层的正方形不可见，因为它只显示实体的碰撞，如下面的截图所示：
- en: '![Introducing a defeatable opponent](img/4568_3_4.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![引入一个可战胜的对手](img/4568_3_4.jpg)'
- en: There is no perfect rule for setting collision boxes. It all depends on how
    well centered and symmetrical your image is, how lenient you are when it comes
    to collision, and the difference in image size between the frontal and profile
    look. Here we chose to reduce our width by 14 pixels (32 - 18). In order to keep
    the box centered, the offset was set to half the difference ((32 - 18) / 2 = 7).
    The same reasoning applies to the y axis.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有设置碰撞框的完美规则。这完全取决于您的图像有多好地居中和对称，当涉及到碰撞时您有多宽容，以及前视和侧视之间的图像大小差异。在这里，我们选择将我们的宽度减小14像素（32-18）。为了保持框居中，偏移设置为差值的一半（（32-18）/2
    = 7）。相同的推理适用于y轴。
- en: Now we have an enemy. Let's kill it!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个敌人。让我们杀了它！
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `enemy.js`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件并将其保存为`enemy.js`。
- en: Set up the `enemy.js` script with the standard ImpactJS module code.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的ImpactJS模块代码设置`enemy.js`脚本。
- en: Include `enemy.js` in your `main` script.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`main`脚本中包含`enemy.js`。
- en: Add an animation sheet and several animation sequences, taking into account
    every direction in which your enemy might walk.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个动画表和几个动画序列，考虑到敌人可能行走的每个方向。
- en: Change both the player's and the enemy's `collisions` entities. They need to
    be able to detect each other's presence so the enemy can later on damage the player.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改玩家和敌人的`碰撞`实体。它们需要能够检测到彼此的存在，以便敌人以后可以伤害玩家。
- en: If you haven't already done this, turn on the ImpactJS debugger by including
    it in your `main` script. The aim is to see the entity's collision boxes.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请通过在您的`main`脚本中包含它来打开ImpactJS调试器。目的是看到实体的碰撞框。
- en: Giving the player some weapons
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给玩家一些武器
- en: 'We do like our player to be armed and ready for some action. Let''s first add
    a new key that will be used to attack. In `main.js` add the following key bind:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢我们的玩家武装起来，准备行动。让我们首先添加一个新的按键用于攻击。在`main.js`中添加以下键绑定：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In any combat situation it is the collision of two bodies that causes damage.
    If an arrow hits the mark, it''s the arrow that damages, not the bow. The same
    is true for a nuclear missile. It''s not the launch facility but the blast wave
    of the nuke that collides with whatever happens to be in the way which does the
    damage. In this respect you could say there are three entities at work here: a
    launch facility, a nuke, and its blast wave. You could even add another one if
    you want to make a difference between air pressure and actual conflagration. All
    of this is just to show how you should think when adding weapons to a game. Which
    impact is relevant? In case of a chicken and a chicken launcher, the chicken will
    become an entity while the launcher is a mere drawing.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何战斗情况下，造成伤害的是两个物体的碰撞。如果箭射中目标，造成伤害的是箭，而不是弓。同样的道理适用于核导弹。造成伤害的不是发射设施，而是核弹的爆炸冲击波与任何阻挡在其路径上的物体的碰撞。在这方面，我们可以说这里有三个实体在起作用：发射设施、核弹和其爆炸冲击波。如果你想区分空气压力和实际的大火，甚至可以再添加一个实体。所有这些只是为了展示在向游戏中添加武器时应该如何思考。哪种影响是相关的？在鸡和鸡发射器的情况下，鸡将成为一个实体，而发射器只是一个简单的绘图。
- en: Spawning a projectile
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成一个projectile
- en: For our ranged attack we need a new entity, which we will call `projectile`.
    Make a new script, set up the basics, save it as `projectile.js`, and include
    it in `main.js`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的远程攻击，我们需要一个新的实体，我们将其称为`projectile`。创建一个新的脚本，设置基础，将其保存为`projectile.js`，并在`main.js`中包含它。
- en: 'Include the following code in `main.js`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`中包含以下代码：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Include the following code in `projectile.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projectile.js`中包含以下代码：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ok, the basics don''t seem to be that basic after all. This time around, we
    have two different animation sheets. An arrow tends to be quite a bit longer than
    it is wide. Therefore if the arrow is shot from left to right (or right to left),
    its dimensions differ from an arrow shot up or downwards. When defining an animation
    sheet, we have to define the dimensions that every image will take only once.
    However, in this case we need two different dimensions: `8` x `4` and `4` x `8`.
    Actually in this particular case there is another, probably easier, solution involving
    the angle of the animation. In programming languages there often are different
    ways to get the same or a similar result. However, now we will use multiple animation
    sheets.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，基础看起来似乎并不那么基础。这一次，我们有两个不同的动画表。箭往往比宽度长得多。因此，如果箭从左到右（或从右到左）射出，其尺寸与从上到下射出的箭不同。在定义动画表时，我们只需要一次定义每个图像的尺寸。然而，在这种情况下，我们需要两种不同的尺寸：`8`
    x `4`和`4` x `8`。实际上，在这种特殊情况下，还有另一种可能更简单的解决方案，涉及动画的角度。在编程语言中，通常有不同的方法来获得相同或类似的结果。然而，现在我们将使用多个动画表。
- en: We define two different animation sheets. Instead of initiating them on the
    standard `animSheet` property, we named them `animSheetX` and `animSheetY` to
    indicate the different axes. The `init()` function does not call the `addAnim()`
    method as in the `Player` and `Enemy` entities because it is programmed to take
    the `animSheet` property by default. Instead we directly address `ig.animation`
    to which we can pass our own animation sheets. It's nice to have an image in case
    you would like to add an arrow in Weltmeister, so the `currentAnim` property is
    given the x axis animation sequence as a default.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两种不同的动画表。我们将它们命名为`animSheetX`和`animSheetY`，而不是在标准的`animSheet`属性上初始化它们，以表示不同的轴。`init()`函数不像`Player`和`Enemy`实体那样调用`addAnim()`方法，因为它是按默认设置为`animSheet`属性。相反，我们直接调用`ig.animation`，可以传递我们自己的动画表。如果您想在Weltmeister中添加一个箭头，那么`currentAnim`属性将默认给出x轴动画序列。
- en: 'Now we just need to make the player spawn the arrow. Therefore we need to add
    the following to the player''s `update()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要让玩家生成箭。因此，我们需要在玩家的`update()`函数中添加以下内容：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The arrow will be spawned at the player's location.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 箭将在玩家的位置生成。
- en: 'In case you run the game at this point, the arrow can only fly in one direction:
    to the right. This is because our default velocity was set at `100` pixels per
    second to the right. Also our animation default is an arrow pointed rightwards.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上运行游戏时，箭只能朝一个方向飞行：向右。这是因为我们的默认速度设置为每秒`100`像素向右。而且我们的默认动画是箭头向右。
- en: 'That''s not entirely what we want. Our enemies would at all times have to be
    on our right side in order for us to kill them. So let''s modify the projectile
    code by adding the following code to the `init()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全是我们想要的。我们的敌人必须始终在我们的右侧，我们才能杀死他们。因此，让我们通过在`init()`函数中添加以下代码来修改projectile代码：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add `velocity` as a property as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码显示`velocity`作为一个属性：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What happens now is if the direction of the arrow is right, left, up, or down,
    it will adjust its speed and animation accordingly. There are only two images
    at play here, an arrow pointed upward and one pointed to the right, each in its
    separate animation sheet. We could add one extra image to each sheet, one downward
    pointing arrow, and one aiming to the left. This would be a viable solution but
    here we choose to use the flip property instead. Flip basically makes a mirror
    image of the animation, making the arrow point to the exact opposite direction.
    When using flip, you must make sure it actually makes sense to flip an image instead
    of using a separate one. For instance, if you have a character running from left
    to right and you want to make it run from right to left, flip is pretty ok to
    use. For characters running towards or away from you, this doesn't really work
    since you expect to either see their front or their back.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发生的是，如果箭头的方向是右、左、上或下，它将相应地调整其速度和动画。这里只有两个图像在起作用，一个箭头指向上方，一个指向右边，每个都在其单独的动画表中。我们可以向每个表中添加一个额外的图像，一个指向下的箭头，一个指向左边。这将是一个可行的解决方案，但在这里我们选择使用翻转属性。翻转基本上是制作动画的镜像图像，使箭头指向完全相反的方向。在使用翻转时，您必须确保翻转图像而不是使用单独的图像是有意义的。例如，如果您有一个从左到右奔跑的角色，并且希望使其从右到左奔跑，使用翻转是可以接受的。对于朝向您或远离您奔跑的角色，这并不起作用，因为您期望看到他们的正面或背面。
- en: This is all very nice but where does it get its *direction* from? Let's initiate
    the direction with a default value and then modify the player so it can pass on
    its own direction to the projectile.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但它的*方向*从哪里得到呢？让我们用默认值初始化方向，然后修改玩家，使其可以将自己的方向传递给抛射物。
- en: 'Add the following code to `projectile.js`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`projectile.js`：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Perform the following for `player.js`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对`player.js`执行以下操作：
- en: 'For every direction, add a variable called `lastpressed` with the same value
    as the input state, as shown in the following code snippet, for going to the right:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个方向，添加一个名为`lastpressed`的变量，其值与输入状态相同，如下面的代码片段所示，用于向右移动：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Make the `spawnEntity` method pass the direction parameter using the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码使`spawnEntity`方法传递方向参数：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Great! We now have our hero shooting arrows in every direction like a boss.
    At the moment, our arrows are still pretty indestructible and are quite harmless
    to our lucky foe. They just hit the edge of our level and stay there forever or
    until the game gets reloaded.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在的英雄可以像老板一样朝各个方向射箭。目前，我们的箭头仍然相当坚固，对我们幸运的敌人来说相当无害。它们只是击中我们关卡的边缘，永远停留在那里，或者直到游戏重新加载。
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的内容，步骤如下：
- en: Open a new JavaScript file and save it as `projectile.js`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的JavaScript文件，并将其保存为`projectile.js`。
- en: Set up the `projectile.js` script. Give it two animation sheets.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`projectile.js`脚本。给它两个动画表。
- en: Add the `projectile` script to the `main` script.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`projectile`脚本添加到`main`脚本中。
- en: Change the player's `update` function so the player can spawn a projectile when
    the `attack` input state is activated.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改玩家的`update`函数，以便玩家在激活`attack`输入状态时可以生成一个抛射物。
- en: Adapt the projectile's direction and animation depending on which direction
    the player is facing when firing.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据玩家射击时面对的方向，调整抛射物的方向和动画。
- en: 'Make sure the direction of the player is transferred to the `projectile` script
    when spawning it. This is done by filling out the optional parameter of the standard
    ImpactJS entity: the `spawn` function.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在生成时将玩家的方向传递给`projectile`脚本。这是通过填写标准ImpactJS实体的可选参数：`spawn`函数来完成的。
- en: Causing harm with a projectile
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用抛射物造成伤害
- en: 'We can make the arrow disappear when hitting an enemy or when in the air for
    some time using the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码使箭头在击中敌人或在空中一段时间后消失：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Initiating a new property called `lifetime` at `0` and adding a counter with
    the `kill()` function to the `update()` function will make the arrow disappear
    after flying for `100` frames. Again, don't forget to separate the `init()` and
    `update()` functions with a comma (`,`), or the literal notation will not forgive
    you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0`处初始化一个名为`lifetime`的新属性，并在`update()`函数中使用`kill()`函数添加一个计数器，将使箭头在飞行了`100`帧后消失。再次，不要忘记用逗号（`,`）分隔`init()`和`update()`函数，否则文字表达式不会原谅您。
- en: 'In order to damage the enemy, we will need our arrow to check whether it encountered
    one. We make the arrow a `TYPE A` entity like the `player` entity, and let it
    check for the `TYPE B` entities like the `enemies` entity in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对敌人造成伤害，我们需要让箭头检查它是否遇到了敌人。我们将箭头设置为`TYPE A`实体，就像`player`实体一样，并让它检查`TYPE B`实体，就像以下代码中的`enemies`实体一样：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By adding the `check()` function we can make the arrow check for every entity
    it needs to check for (as set by the `checkAgainst` property). If it encounters
    an entity of type `B`, that entity receives a damage of `100` as shown in the
    following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`check()`函数，我们可以使箭头检查它需要检查的每个实体（由`checkAgainst`属性设置）。如果遇到类型为`B`的实体，该实体将受到`100`的伤害，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we still didn't solve the problem of the arrow camping against the edge
    of the level or any other place where map collision is present. So let's make
    some bouncing arrows! No worries, we made sure they couldn't hurt the player since
    they will only check for entities of type `B` and will fly right through our player.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们仍然没有解决箭头在关卡边缘或任何其他地图碰撞存在的地方露营的问题。所以让我们制作一些反弹的箭头！别担心，我们确保它们不会伤害玩家，因为它们只会检查类型为`B`的实体，并且会直接穿过我们的玩家。
- en: 'First set the `bounciness` to `1`, which means all speed is kept when bouncing
    back, using the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`bounciness`设置为`1`，这意味着在反弹时保持所有速度，使用以下代码：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we only need to check if the speed has inverted (if the arrow has bounced),
    and invert the animation if required. Of course, this needs to be done in the
    `update()` function as shown in the following code snippet since it can happen
    at all times:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is a very naive check since it relies on the assumption that the speed
    of the arrow remains the same at all times, even after a bounce. However, for
    the sake of keeping the example simple, it will do.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We didn't even set the `health` value of our enemy and we can already damage
    and kill it. This is because by default the `health` value of an entity is set
    to `10`. Let's change this property so that our enemy can at least survive the
    first hit.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the change as per the following code in `enemy.js`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our enemy has become harder to kill but it's not as if he's a challenge for
    us yet. It's time to get into some basic **AI** or **Artificial Intelligence**
    of a non-playable character.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Add a maximum lifespan to your projectile so it can't remain in the game forever.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add entity collision detection so it can collide with an enemy.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the projectile's `check` function so that when the projectile collides
    with an enemy, the projectile is killed and the enemy is damaged.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `bounciness` so it can bounce off walls.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `health` property of your enemy so it does not get hit by the very first
    projectile.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bringing your NPCs to life with artificial intelligence
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Artificial intelligence can be one of the most complicated, if not *the* most
    complicated element of a game. As the name states, AI is artificial or simulated
    intelligence. The entities in your game will need to act and react to the things
    you as a player are doing to them or their environment. When writing AI, you are
    in effect trying to put the human brain or something more powerful, into the computer.
    For strategy games, AI can make or break the gameplay since it is what keeps the
    player engaged when playing skirmish matches offline. For other genres such as
    2D shooters, you might be contented with enemies who do more than just shooting
    at you. The problem with complicated AI is that it needs to take so many parameters
    into account that it can become almost impossible for a single programmer to fathom.
    Let''s make a division in three types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-strategy AI**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple-strategy AI**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven AI**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategies** are patterns of behavior that an entity will follow in a specific
    situation. An enemy can charge at you with full ferocity when at full health,
    but retreat and look for a safe place to heal itself when badly injured. This
    is an example of using two different strategies while a *single strategy* enemy
    might just keep on attacking you until it is dead, regardless of its own life.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '*Data driven AI* is something else altogether. It is not hardcoded behavior
    but requires tons of player data, which gets uploaded to a single location. There
    the data is processed and statistical procedures such as regressions, decision
    tree modeling, and neural networks are applied to make the AI more competent in
    the future. What you get is a learning entity, which becomes increasingly harder
    to defeat and automatically invents new strategies depending on the models'' predictions.
    To some people, the thought of a computer being able to learn and adapt behavior
    might be rather scary. However, it is today''s reality, and the future is bound
    to bring increasingly smarter AI. Whether computers will eventually take over
    the world, like in the movies Terminator and The Matrix, remains to be seen.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: For now we will forget about all those data-driven statistical solutions and
    just have a look at a single strategy AI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: When writing AI, we want to keep a clear division between the decision and the
    actual behavior. You can see it as the division between the human brain and the
    body. The brain takes the decision and sends impulses to the body to perform the
    action. For this reason we will write our "brain" in a separate module, while
    the actions an enemy is able to perform will stay in the `enemy` entity itself
    as methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The NPC's behavior
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script, name it `ai.js`, and save it under the `plugins` folder
    as shown in the following code snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We kick off by defining our brand new module, our first plugin. Let''s not
    forget to require the script in our `main.js` as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The AI will need to give orders to the entity. For this to happen they need
    to speak a common tongue. Just like your legs will need to interpret your nerve
    signals, our enemy will need to interpret the actions it needs to perform at any
    given time. We define these commands in our `init()` function, as shown in the
    following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `action` array holds all the possible actions the `AI` module can send.
    The `init()` function takes in the entity it needs to command as its input. It
    is not necessary to assign an entity to `this.entity` as shown in the previous
    code snippet (`this.entity=entity;`), but it merely confirms that `this` is not
    the entity itself but its AI. The fact that the input parameter `entity` is not
    assigned to `this` but to `this.entity` would make it possible to have a collective
    `ai`, capable of also making decisions for a group of enemies as a whole. This
    collective AI or hive mind will be addressed in [Chapter 5](ch05.html "Chapter 5. Adding
    Some Advanced Features to Your Game"), *Adding Some Advanced Features to your
    Game*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If you would now take a look at your Firebug DOM in Firefox, you can see the
    `AI` class as part of the `ig` object and it currently only holds the `init()`
    function we just wrote. It's always a good idea to keep a track of how your DOM
    evolves while writing code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![The NPC''s behavior](img/4568_3_5.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have defined the signals we will send, let''s have a look at where
    they end up. Open the `enemy.js` script and add the following `update()` function
    to it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We could write all the behavior in separate methods, which would then take the
    `AI` commands to see if they need to do something. These methods can then be put
    in the `update()` function of the entity in order to keep its orders up to date.
    We are not going to make this division in methods in this case. Because things
    aren't too complex in this case, all behavioral code will fit into the `update()`
    function without creating intermediate methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update()` function now consists of two main parts: a *call to the AI module*
    to receive the action it needs to perform and *actually performing the action*.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The action is stored in a local variable called `action` by calling the `ai.getAction()`
    method. However, in order to do this we need to add the AI to our enemy''s `requires`
    function next to the `impact` entity code, as shown in the following code snippet:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also give your enemy a speed parameter, as shown in the following code, since
    the case statements use it for setting their movement:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All actions that we defined in the `AI` module are represented in the `update()`
    function. In order to make the series of case checks more efficient, a break is
    inserted at the end of each action. This way, once an action matches with the
    case it will stop checking if other cases match. We know that we want to give
    only *one order at every given time* so this makes sense. All code within `update()`
    functions should be written as efficiently as possible since it will be called
    60 times per second if the game runs at a frame rate of 60\. Four of our actions
    are geared towards moving in the correct direction, and then we have `attack`
    and `rest`. To make sure every situation is handled, a `default` value is set.
    This way, if the enemy is given a command that he doesn't understand, he will
    just stay put. You could rewrite the `default` part of the code and overwrite
    it with the `attack` case if you like; this way the enemy will always attack if
    he doesn't understand what he needs to do; barbaric but effective.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In case the enemy attacks, he calls the player's `receive damage` function.
    This is interesting since the `receive damage` method of the player can be overwritten
    in `player.js` to incorporate damage reduction from armor and the like.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: However, for now let's take a look at the actual brain or decision making itself.
    Therefore we need to return to our `AI` module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the conclusions are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The AI of an entity is its ability to make decisions based on external input,
    often using several strategies
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code, the decision making should be separated from the actual behavior where
    possible
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `ai.js`. As an analogy to the human
    body, this file will contain everything about the brain.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `ai.js` script so it becomes an ImpactJS class extension.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `ai.js` in your `main` script.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the language that will bind behavioral decisions to actual behavior.
    As an analogy to the human body, these would be the electrical impulses your nervous
    system transmits.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the actual behavioral patterns an enemy will follow for every command
    he can receive. As an analogy to the human body, this would be the body's reaction
    to certain nerve impulses.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the function that calls for an AI command. As an analogy to the human
    body, this function call would be the nerves themselves.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The NPC's decision making process
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just saw that the AI `getAction()` method was called but not yet fully explained.
    Its main purpose is to return an action when called. The possible actions here
    are moving in a certain direction, attacking, blocking incoming attacks, or not
    moving at all. What action to take is decided by the distance between the player
    and the `enemy` entity that needs to take the decision, as shown in the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add this function to the `AI` module. Just like the `init()` function, it takes
    the entity as an input parameter. A series of local variables is calculated to
    decide what path needs to be taken in order to get to the player. The enemy needs
    to know its distance from the player and the angle towards the player. Collision
    is calculated by use of the `collision.trace()` method. The inputs for this method
    are the entities `position`, `size`, and `distance` to its target, in this case,
    the player. Here you shouldn't see collision as a real physical collision but
    rather as a line of sight. `res.x.collision` should be interpreted as "is the
    player in line of sight if I look in a horizontal line across the screen?"
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the line of sight for the enemy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![The NPC''s decision making process](img/4568_3_6.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: If this is the case, there is no more need to move up or down. The same reasoning
    works for the y-axis and moving left or right. This is only to show you how this
    function works leaving out the first two `if` statements, and calculation of the
    `res` variable will still give the same result because of the logic in the next
    two `if` statements.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'A check on the distance between the enemy and the player happens after this.
    If the enemy is close enough to attack (this is hardcoded at `30` pixels), the
    enemy attacks. This cut off could be changed by reading the actual range of the
    enemy and using this instead of just using `30`. Also, the enemy has the opportunity
    to attack once per frame; this makes for 60 attacks per second. Have you ever
    been hit with a sword 60 times in one second? It hurts. We could lower that by
    increasing the chance of the enemy doing nothing at all. Changing these two things,
    the code could look like the following code snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Of course you would need to change the actual damage done since 2 damages might
    not be that impressive or challenging for a player with 200 hit points. The following
    code snippet shows the change in damage:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the distance between the enemy and the player is 300, the enemy will move
    towards the player. As explained earlier it uses the angle to decide what direction
    to go first. In all other cases, the AI advises the entity to rest. So if the
    player is far away, the enemy will not attack. This way you avoid being attacked
    by all enemies at once. If your speed is greater you can even run away.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one small thing left. As you might have noticed, an action is not
    immediately returned but sent through the `doAction()` method. The following code
    snippet shows how this is done:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method, which is also added to the `AI` module, is only used to store the
    last action that the entity has performed. You could do without this function,
    but it is often handy to keep track of the last move that was performed. Applications
    for this are not shown in this short AI tutorial.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: If you were to reload the game at this point, you should have an enemy that
    actually tries to kill you instead of just being passive as a stone(r).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Calling the brain to act is done with our `getAction()` function. This function
    takes the entity for which a decision needs to be made as an input argument, and
    will return a command or an action. The logic inside this function can be as simple
    or complex as you like. In this example, distance to the player is the most important
    determinant for the action that needs to be taken.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `line of sight` ImpactJS function to determine if the enemy will be able
    to see the player.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What an AI should do is a totally subjective thing; try adding your own commands
    and behavioral patterns.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pickup items to help out your player
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our enemy fights back, we might be in need for some extra assistance
    in the form of the `pickup` items and extra weapons.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: One useful `pickup` item would be an instant `healthpotion` entity so that we
    can heal from the damage we got.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Healing your player with a potion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build ourselves an entity called `healthpotion` and include it in the
    `main` script `main.js`, as shown in the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Include the following code in the `healthpotion.js` script:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `healthpotion` entity is a very straightforward entity. It has no real behavior
    except for detecting whether a player touches it and then healing the player if
    he or she does.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Interesting to note here is how the `receiveDamage()` method is used with negative
    damage in order to heal the target. This health potion is used on pickup; it does
    not always have to be like this and some things can be counted by use of a `gameinfo`
    array.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `healthpotion.js`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `healthpotion.js` script with the standard ImpactJS module code.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the `healthpotion.js` script in your `main` script.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet and a sequence.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `collision` entity so it can detect when the player touches it.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `receivedamage()` function with a negative damage; this will heal the
    player instead of dealing with the damage. Make the `healthpotion` entity destroy
    itself.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Becoming rich with coins
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `coin` entity is an example of an item that we might want to keep a count
    of. It is almost the same as the `healthpotion` entity except for its name, animation
    sheet, and the `check` function, which is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instead of healing the player, a method called `addCoin()` is applied. This
    function does not work yet so you can put this line of code in a comment until
    we change this in the section, *Keeping score for player feedback*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s address another issue. If you added the `coin` and `healthpotion`
    entities to the game with the Weltmeister, you might have noticed that you can
    actually kill the `healthpotion` and `coin` entities by shooting them. If you
    don''t like this behavior, it can be fixed by giving every entity a unique name,
    as shown in the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can check for it in the check functions as shown in the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now let's get our score system to work.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `coin.js`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `coin.js` file with the standard ImpactJS module code.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `coin.js` in your `main` script.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet and a sequence.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `collision` entity so it can detect when the player touches it.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When touching the `player` entity, the `coin` entity must destroy itself and
    call the `addcoin()` function, which sends feedback to the game info system. The
    function will be defined later this chapter, so turn it on when implemented.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping score for player feedback
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keeping track of a number of things is all about leaving it outside the currently
    loaded game. This way it can be transferred across levels and even across games.
    Add the following to `main.js` above the `MyGame` definition:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`GameInfo.coins` and `GameInfo.score` will now keep track of how many coins
    we have gathered and what is our current score.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we do need two functions, which will actually increase these game
    properties. Therefore let''s add these functions to the `MyGame` definition in
    the `main.js` script:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now you can safely get the `ig.game.addCoin()` method out of the comments without
    fear of game crashes. Also, we can add a call to the `increaseScore` function
    at the death of an enemy. To do this, we need to change the `kill` function of
    our enemies in the `enemy.js` script, as shown in the following code snippet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, we keep the original function by adding the `this.parent()`
    line of code but add our code for increasing the score just before it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to restrict ourselves to things that can only go up. We could
    put a limit on the number of projectiles our hero has and keep a count of them.
    Add the initial number of projectiles to the `GameInfo` array as shown in the
    following code snippet:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are in need of two new functions, which we can add to `MyGame` like we did
    for `addCoin()` and `increaseScore()`. The code for adding the two functions is
    as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our new attack code for the `player` entity will look like the following code
    snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First we check whether we have enough projectiles and after launching one, a
    `projectile` entity is subtracted from our original stack.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! But how do we resupply? We could just create another `pickup` item for
    this purpose as shown in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Add some of these to your game and you will be able to shoot your way through
    anything like a real Rambo!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: There are many other appliances for this `GameInfo` array out there, but it's
    up to you to make good use of it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Some information needs to be kept outside of the actual game so it can be used
    and stored after a game is finished. This overhead information is kept in a `gameinfo`
    array, defined in the `main` script.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `gameinfo` array and reserve a place for storing both the number
    of coins that are collected and the overall score a player achieves.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `addcoin()` and `increasescore()` functions. `addcoin()` will increase
    the number of coins by one when called. `increasescore()` can take a numeric input
    parameter, which is the score that it needs to add to the total.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the `addcoin()` function in the `coin` entity.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the enemy's `kill` method to incorporate the `increasescore()` function.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the same logic, create both the `addProjectile()` and `substractprojectile()`
    functions.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `player` entity code. So it will check how many projectiles a player
    has before it becomes possible to fire. When a projectile is fired, a `projectile`
    entity is subtracted from the remaining ammo.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use everything you learned about `pickup` items to make a `pickup` projectile
    that will replenish the player's ammo supply.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transitioning from one area to another
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a map transition for an RPG has been thoroughly explained in [Chapter
    2](ch02.html "Chapter 2. Introducing ImpactJS"), *Introducing ImpactJS*. We will
    just have a quick recap and some pointers in this section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might remember, we have used a combination of three entity files to
    build gateways between levels. Add the `trigger`, `levelchange`, and `void` entities
    to the `entities` folder and include them in the `main` script, as shown in the
    following code snippet:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To have a level to connect to, we need to build one first. The following screenshot
    shows the `endgame` level to which we should connect:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitioning from one area to another](img/4568_3_7.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: 'This level is the `endgame` content; it will soon feature the dangerous boss
    of this little RPG. Don''t forget to include it in `main.js`, as shown in the
    following code snippet:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that all necessary components are ready, connect the level in the same way
    as shown in [Chapter 2](ch02.html "Chapter 2. Introducing ImpactJS"), *Introducing
    ImpactJS*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Use the `trigger` entity to trigger the `levelchange` entity when the player
    walks over it. The `void` entity is used as the `spawn` location.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing needs to be pointed out here. When the player moves from one area
    (level) to another, his health is reset to the default value because the `levelchange`
    script spawns a new player. This can be avoided by either moving the `health`
    value before loading the new level to an independent array of variables, or by
    changing the `levelchange` script itself. The second option is shown in the following
    code snippet. Open `levelchange.js` to find the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Before actually loading the `level` entity, the `health` value is stored to
    a local variable`health`, which is then reassigned to the newly spawned player.
    The same can be done to any attribute, or a temporal copy can be made of the `player`
    entity, which then overwrites the freshly spawned one.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `trigger`, `levelchange`, and `void` entities from the `chapter 2`
    folder and put them in the `entities` folder.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include all three entities in the `main` script.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a level transition using these three entities as shown in [Chapter 2](ch02.html
    "Chapter 2. Introducing ImpactJS"), *Introducing ImpactJS*.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `levelchange` entity so the player's health is temporarily stored
    in between level loads.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NPCs and conversation
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many 2D RPGs the epic story is told by the sole use of text. The player interacts
    with various **NPC**s (**Non Playable Characters**) before he or she can beat
    the game. An enemy is also an NPC but in most contexts, the NPC is regarded as
    the non-hostile character who helps the hero reach his goal by giving hints, quests,
    and items. We will introduce such a peaceful creature and make him speak in the
    next section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The speech balloon
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this we will use a text balloon, which we treat as an entity of its own.
    Let''s prepare a new JavaScript file and call it `textballoon.js` using the following
    code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will once again need to let our `main` script know of its existence, so add
    `'game.entities.textballoon'` to the `main` script.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file we will not only define our `textballoon` entity but also an inner
    class, which we will use in the `textballoon` entity: `WordWrap`. `WordWrap` is
    a class invented by a person who goes under the name of Kingsley on the ImpactJS
    forum, and all thanks should go to him. Once again this proves that looking up
    on forums is a good idea. Someone might have already done what you intend to do.
    `WordWrap` organizes the inputted text in such a way that you can fit it on objects
    such as speech balloons. We can define this class in any of our JavaScript files
    but since it''s used exclusively by our `textballoon` entity, it makes sense to
    place the script as shown in the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `WordWrap` class is an extension of the general Impact class just like
    our `AI` module. It is in fact a function, which takes three arguments: a piece
    of text, a maximum width for a line of text, and whether the function should cut
    off by character or word. When a new `WordWrap` class is created, these three
    things are assigned to local arguments as can be seen in the `init()` function.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: However, the most important thing is the `wrap` method of the `WordWrap` class.
    It only contains two lines of code but does all the work. In the first line, a
    regular expression is built, which is then interpreted and returned in the second
    line. A regular expression is a flexible way to recognize specified strings of
    text. How this text pattern recognition code works is not covered here since it
    is not within the scope of this book.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the most vital function for our `textballoon` entity, we can
    build the `textballoon` entity itself using the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `balloon` entity is not much more than an image with text, which is shown
    on top of everything else (`zIndex = 1000`) when spawned. In the `Init()` method
    of our `balloon` entity, the `WordWrap()` function is used to wrap the text to
    the correct dimensions. It is interesting to note here how the font is initialized
    (`font : new ig.Font(''media/font.png'')`).The font that will be used is already
    present in our `media` folder in the `.png` format and in order to assign it to
    our local variable font, a new impact method is used: `ig.Font()`. Unlike the
    font from Word, here it has a predefined color and size. A free font tool is available
    if you want to make your own font for your ImpactJS game on the following link:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[http://impactjs.com/font-tool/](http://impactjs.com/font-tool/)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a variable called `lifeTime`, which will keep track of the remaining
    number of frames until the `balloon` entity is dismissed. This check is done in
    the `update()` function as shown in the following code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In every new frame, the lifetime drops by one. When the `lifeTime` value reaches
    `0`, the `balloon` entity is killed. More intelligent balloon timers could be
    implemented by counting the amount of text that should be read and adjusting the
    time you have to read it, but this is a simple example.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we will need is the entity''s `draw()` method. `Draw()` is called
    for every frame just like the `update()` function, but is dedicated to what needs
    to be displayed as shown in the following code snippet:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'All entities have a `draw` method and it is called automatically. We will have
    a look at it now because our balloon needs to be adjusted a bit. In the `draw()`
    function, first its parent function is called followed by positioning and drawing
    the text that needs to be shown on top of our balloon. The order of things is
    very important here. If you would first draw the text and put `this.parent();`
    at the end, the text will be written first, followed by the balloon. You can try
    this once we have an entity to spawn our `balloon` entity; for now you should
    get an empty speech balloon. The following screenshot shows a fully functioning
    speech balloon:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![The speech balloon](img/4568_3_8.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a fully functioning speech balloon, it is time to introduce
    an entity that wants to talk to us: the `NPC` entity.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the conclusions are as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Lots of games have friendly creatures walking about and providing the player
    with hints.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A talking character consists of a friendly `NPC` entity and its speech balloon,
    which can be regarded as a separate entity. Additionally, we make use of a `wordwrap()`
    function, which will keep the sentences within the borders of the speech balloon.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `textballoon.js`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `wordwrap()` function as an extension to the `ImpactJS` class.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `textballoon.js` file with the standard ImpactJS module code.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `textballoon.js` in your `main` script.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet, an animation sequence, a size, and a default position.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the z-index property to a high number so the speech balloon is always shown
    on top of every other entity.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `wordwrap()` function to transform a text of your choice and add it
    as a property of the speech balloon.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to make your own font for your game, use the ImpactJS font tool
    to convert it into a file that Impact can use. The font tool is located at the
    following URL: [http://impactjs.com/font-tool/](http://impactjs.com/font-tool/).'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `update` function of the speech balloon so that it will keep track
    of how much time has passed since the speech balloon was spawned. The `update`
    function will also kill off the balloon when a preset number of frames have past.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the default `draw` function so it will draw your text on top of the
    speech balloon itself.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a talking non-playable character
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and save it as `Talkie.js`. `Talkie` will be the name of
    our lovely NPC as shown in the following code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Like for any regular entity, the `Talkie` script properties are defined before
    or in the `init()` function, depending on whether you wish to write them in the
    literal notation or not, as shown in the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`Talkie` has two states, either he is doing nothing (`idle`) or he is talking
    (`Talk`) and his animation changes accordingly. He should only stay in the `Talk`
    state while the balloon is there, so a timer is set to synchronize the balloon
    with Talkie''s animation using the following code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The animation remains in place for `200` frames; when done Talkie returns to
    his idle state.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`Talkie` needs to check if the player is in the vicinity so he can start talking.
    When the player is close, the `textballoon` entity is spawned and Talkie will
    not talk again. `ig.game.sortEntitiesDeferred()` resorts the entities in the game
    by its z-value; this way you are sure the balloon is shown on top. The following
    code is used for this purpose:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that we have our Talkie code finished, try adding him to one of the levels
    and get near him. A balloon should pop up saying **Epicness awaits you!**
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Talkie is right because we are almost at the end of our game.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We now need a character capable of delivering the message to the player. We
    will call this character `Talkie`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `Talkie.js`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `Talkie.js` file with the standard ImpactJS module code.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `Talkie.js` in your `main` script.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation sheet, an animation sequence, a size, name, and several other
    properties for the Talkie.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property `talked`, which keeps track of whether Talkie already talked
    or not. And a property `times`, which is the number of frames for which the Talkie
    needs to look as if he is actually talking. The time span for which the talk animation
    is shown is best to be equal to the life span of the speech balloon.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the `update` function to make the speech animation work.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the `check` function and collision detection so that a `textballoon`
    entity is spawned when the player touches the Talkie if he has not yet talked
    before.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final battle
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually a game ends with a grand finale; a boss of great strength, you need
    to slay in order to reap everlasting fame!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the final `Boss` entity:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, the `Boss` entity is nothing more than a strong enemy. There is
    no need to do an exact copy and paste of the `enemy` entity and adjust code separately
    on the elements they share. It is more efficient to extend the `enemy` class and
    only fill out the differences. Our boss has another name, more health, more speed,
    looks different, and takes less damage from a hit. In order to be able to build
    upon the original `enemy` entity, you need to include it in its `require` function.
    As the enemy is already built upon the ImpactJS `entity` class, there is no more
    need to include `impact.entity`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to tell the `projectile` entity that it is also allowed
    to hit the `Boss` entity, as shown in the following code snippet:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In `projectile.js`, the `if` statement is adjusted to cope with our `Boss` entity.
    You might have noticed that the death of our enemy triggers the end of the game.
    We will look into that and the opening splash screen in [Chapter 5](ch05.html
    "Chapter 5. Adding Some Advanced Features to Your Game"), *Adding Some Advanced
    Features to Your Game*. You can add a `Boss` entity to the `endgame` level and
    fight him for glory!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the conclusions are as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: A final boss is often the long anticipated antagonist that a player needs to
    defeat in order to finish a game or stage. He often has more health, does more
    damage, and thus is generally harder to defeat than a regular foe.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can base our boss's character on a regular enemy by extending the `enemy`
    class when creating the `boss` entity.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up the preceding content, the steps are as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Open a new JavaScript file and save it as `Boss.js`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `Boss.js` file by extending the `enemy` class.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `Boss.js` in your `main` script.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change all the properties that need to distinguish the boss from a lesser foe.
    This includes health, damage, speed, and even armor. Armor can be implemented
    as a damage reduction by overwriting the `receivedamage()` function.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the `receivedamage()` function to make sure the end of the game is
    called when the boss dies. This GameEnd is explained in [Chapter 5](ch05.html
    "Chapter 5. Adding Some Advanced Features to Your Game"), *Adding Some Advanced
    Features to Your Game* so you can turn it off for now.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the `projectile` entity so it also damages the `Boss` entity and not just
    the `enemy` entity.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have been able to build our own top-down game from scratch.
    In order to do this, we have built levels with the ImpactJS Weltmeister and added
    a controllable character known as **player**. The game becomes more challenging
    by adding intelligent enemies and the weapons to defeat them. We were able to
    add some more depth to the game by introducing a friendly NPC. The final element
    was keeping score in order to provide the player with some feedback on how well
    he or she is doing.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
