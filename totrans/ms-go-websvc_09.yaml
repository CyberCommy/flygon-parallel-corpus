- en: Chapter 9. Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When all is said and done, and you're ready to launch your web service or API,
    there are always considerations that need to be taken into account with regards
    to launching, from code repository, to staging, to live environments, to stop,
    start, and update policies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Deploying compiled applications always carries a little more complexity than
    doing so with interpreted applications. Luckily, Go is designed to be a very modern,
    compiled language. By this, we mean that a great deal of thought has been devoted
    to the kinds of problems that traditionally plagued servers and services built
    in C or C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, in this chapter, we're going to look at some tools and strategies
    that are available to us for painlessly deploying and updating our application
    with minimal downtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to examine some things that we can do to reduce the internal
    load of our web service, such as offloading image storage and messaging as part
    of our deployment strategy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have some Go-specific and general tips
    that will minimize some of the heartache that is endemic to deploying APIs and
    web services, particularly those that are frequently updated and require the least
    amount of downtime.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Application design and structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment options and strategies for the cloud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilization of messaging systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling image hosting from our API server and connecting it with a cloud-based
    CDN
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structures
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the design and infrastructure of your application is a matter of institutional
    and personal preference, the way you plan its architecture can have a very real
    impact on the approach that you use to deploy your application to the cloud or
    anywhere in production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly review the structure that we have for our application, keeping
    in mind that we won''t need package objects unless we intend to produce our application
    for mass cross-platform usage:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The structure of our application may be noteworthy depending on how we deploy
    it to the cloud.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: If there's a conduit process before deployment that handles the build, dependency
    management, and push to the live servers, then this structure is irrelevant as
    the source and Go package dependencies can be eschewed in lieu of the binary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: However, in scenarios where the entire project is pushed to each application
    server or servers or NFS/file servers, the structure remains essential. In addition,
    as noted earlier, any place where cross-platform distribution is a consideration,
    the entire structure of the Go project should be preserved.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Even when this is not critical, if the build machine (or machines) are not exactly
    like the target machines, this impacts your process for building the binary, although
    it does not preclude solely dealing with that binary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In an example GitHub repository, it might also require to obfuscate the nonbinary
    code if there is any open directory access, similar to our `interface.go` application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Using process control to keep your API running
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods for handling version control and development processes are beyond
    the scope of this book, but a fairly common issue with building and deploying
    compiled code for the Web is the process of installing and restarting the said
    processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Managing the way updates happen while minimizing or removing downtime is critical
    for live applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: For scripting languages and languages that rely on an external web server to
    expose the application via the Web, this process is easy. The scripts either listen
    for changes and restart their internal web serving or they are interpreted when
    they are uncached and the changes work immediately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: This process becomes more complicated with long-running binaries, not only for
    updating and deploying our application but also for ensuring that our application
    is alive and does not require manual intervention if the service stops.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are a couple of easy ways to handle this. The first is just strict
    process management for automatic maintenance. The second is a Go-specific tool.
    Let's look at process managers first and how they work with a Go web service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几种简单的方法来处理这个问题。第一种是自动维护的严格进程管理。第二种是一个特定于Go的工具。让我们首先看看进程管理器以及它们如何与Go Web服务一起工作。
- en: Using supervisor
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用监督者
- en: 'There are a few big solutions here for *nix servers, from the absurdly simple
    to the more complex and granular. There''s not a lot of difference in the way
    they operate, so we''ll just briefly examine how we can manage our web service
    with one: Supervisor. Supervisor is readily available on most Linux distributions
    as well as on OS X, so it is a good example for testing locally.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*nix服务器来说，这里有几个大的解决方案，从非常简单到更复杂和细粒度的解决方案。它们的操作方式没有太大的区别，因此我们将简要地介绍如何使用Supervisor来管理我们的Web服务。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some other process managers of note are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些值得注意的进程管理器如下：
- en: 'Upstart: [http://upstart.ubuntu.com/](http://upstart.ubuntu.com/)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Upstart: [http://upstart.ubuntu.com/](http://upstart.ubuntu.com/)'
- en: 'Monit: [http://mmonit.com/monit/](http://mmonit.com/monit/)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Monit: [http://mmonit.com/monit/](http://mmonit.com/monit/)'
- en: 'Runit: [http://smarden.org/runit/](http://smarden.org/runit/)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Runit: [http://smarden.org/runit/](http://smarden.org/runit/)'
- en: The basic premise of these direct supervision init daemon monitoring process
    managers is to listen for running applications if there are no live attempts to
    restart them based on a set of configured rules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些直接监督初始化守护进程监控进程管理器的基本原则是监听运行的应用程序，如果没有根据一组配置的规则尝试重新启动它们。
- en: It's worth pointing out here that these systems have no real distributed methods
    that allow you to manage multiple servers' processes in aggregate, so you'll generally
    have to yield to a load balancer and network monitoring for that type of feedback.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，这些系统没有真正的分布式方法，允许您以聚合方式管理多个服务器的进程，因此通常需要依靠负载均衡器和网络监控来获取此类反馈。
- en: 'In the case of Supervisor, after installing it, all we need is a simple configuration
    file that can be typically located by navigating to `/etc/supervisor/conf.d/`
    on *nix distros. Here''s an example of such a file for our application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Supervisor的情况下，安装完成后，我们只需要一个简单的配置文件，通常可以通过导航到*nix发行版上的`/etc/supervisor/conf.d/`来找到。以下是我们应用程序的一个示例文件：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While you can get more complex—for example, grouping multiple applications together
    to allow synchronous restarts that are useful for upgrades—that's all you should
    need to keep our long-running API going.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以变得更加复杂，例如，将多个应用程序组合在一起以允许同步重启，这对升级非常有用，但这就是您需要保持我们长时间运行的API的全部内容。
- en: 'When it''s time for updates, say from GIT to staging to live, a process that
    restarts the service can be triggered either manually or programmatically through
    a command such as the following one:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更新时，比如从GIT到暂存再到线上，可以手动触发一个重新启动服务的进程，也可以通过命令以编程方式触发，比如以下命令：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This allows you to not only keep your application running, but it also imposes
    a full update process that pushes your code live and triggers a restart of the
    process. This ensures the least possible amount of downtime.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅可以使您的应用程序保持运行，还可以强制执行一个完整的更新过程，将您的代码推送到线上并触发进程的重新启动。这确保了最小的停机时间。
- en: Using Manners for more graceful servers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Manners创建更加优雅的服务器
- en: While init replacement process managers work very well on their own, they do
    lack some control from within the application. For example, simply killing or
    restarting the web server would almost surely drop any active requests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然替代进程管理器在自己的工作中表现得很好，但它们在应用程序内部缺乏一些控制。例如，简单地杀死或重新启动Web服务器几乎肯定会中断任何活动的请求。
- en: On its own, Manners lacks some of the listening control of a process such as
    **goagain**, which is a library that corrals your TCP listeners in goroutines
    and allows outside control for restarts via SIGUSR1/SIGUSR2 interprocess custom
    signals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用Manners时，缺少一些像**goagain**这样的进程的监听控制，它是一个将TCP监听器聚合到goroutines中，并允许通过SIGUSR1/SIGUSR2进程间自定义信号进行外部控制的库。
- en: However, you can use the two together to create such a process. Alternatively,
    you can write the internal listener directly, as goagain may end up being a slight
    overkill for the aim of gracefully restarting a web server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以将两者结合使用来创建这样的进程。或者，您可以直接编写内部监听器，因为对于优雅地重新启动Web服务器的目的，goagain可能会有点过度。
- en: 'An example of using Manners as a drop-in replacement/wrapper around `net/http`
    will look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Manners作为`net/http`的替代/包装器的示例将如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After running within a goroutine and blocking with the channel that is listening
    for SIGUSR1 or SIGUSR2, we will pass our Boolean along the `Server.Shutdown` channel
    when such a signal is received.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在goroutine中运行并阻塞的通道监听SIGUSR1或SIGUSR2时，当接收到这样的信号时，我们将布尔值传递给`Server.Shutdown`通道。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is just a rehash of our `Init()` function within `api.go`. This registers
    the Gorilla router that we'll need for our Manners wrapper.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们在`api.go`中`Init()`函数的重新处理。这注册了我们需要Manners包装的Gorilla路由器。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `main()` function, instead of just starting our `http.ListenAndServe()`
    function, we use the Manners server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们不仅启动`http.ListenAndServe()`函数，还使用Manners服务器。
- en: This will prevent open connections from breaking when we send a shutdown signal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止在发送关闭信号时断开开放的连接。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can install Manners with `go get github.com/braintree/manners`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`go get github.com/braintree/manners`来安装Manners。
- en: You can read more about Manners at [https://github.com/braintree/manners](https://github.com/braintree/manners).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/braintree/manners](https://github.com/braintree/manners)了解更多关于Manners的信息。
- en: You can install goagain with `go get github.com/rcrowley/goagain`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`go get github.com/rcrowley/goagain`来安装goagain。
- en: You can read more about goagain at [https://github.com/rcrowley/goagain](https://github.com/rcrowley/goagain).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/rcrowley/goagain](https://github.com/rcrowley/goagain)了解更多关于goagain的信息。
- en: Deploying with Docker
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker部署
- en: In the last few years, there have been very few server-side products that have
    made as big a wave as Docker in the tech world.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Docker creates something akin to easily deployable, preconfigured virtual machines
    that have a much lower impact on the host machine than traditional VM software
    such as VirtualBox, VMWare, and the like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: It is able to do this with much less overall weight than VMs by utilizing Linux
    Containers, which allows the user space to be contained while retaining access
    to a lot of the operating system itself. This prevents each VM from needing to
    be a full image of the OS and the application for all practical purposes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In order to be used in Go, this is generally a good fit, particularly if we
    create builds for multiple target processors and wish to easily deploy Docker
    containers for any or all of them. It is even better that the setup aspect is
    largely handled out of the box now, as Docker has created language stacks and
    included Go within them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: While at its core Docker is essentially just an abstraction of a typical Linux
    distribution image, using it can make upgrading and quickly provisioning a breeze,
    and it may even provide additional security benefits. The last point depends a
    bit on your application and its dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Docker operates with the use of very simple configuration files, and using a
    language stack, you can easily create a container that can be launched and has
    everything we need for our API.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this Docker file example to see how we''d get all the necessary
    packages for our social networking web service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The file can then be built and run using simple commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see how, at bare minimum, this would greatly speed up the Go update
    procedure across multiple instances (or containers in this case).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Complete Docker the base images are also available for the Google Cloud Platform.
    These are useful for quickly deploying the most recent version of Go if you use
    or would like to test Google Cloud.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Deploying in cloud environments
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who remember the days of rooms full of physical single-purpose servers,
    devastating hardware faults, and insanely slow rebuild and backup times, the emergence
    of cloud hosting has in all likelihood been a godsend.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, a full architecture can often be built from templates in short order,
    and autoscaling and monitoring are easier than ever. Now, there are a lot of players
    in the market too, from Google, Microsoft, and Amazon to smaller companies such
    as Linode and Digital Ocean that focus on simplicity, thrift, and ease of usage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Each web service comes with its own feature set as well as disadvantages, but
    most share a very common workflow. For the sake of exploring additional functionality
    that may be available via APIs within Golang itself, we'll look at Amazon Web
    Services.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that similar tools exist for other cloud platforms in Go. Even Microsoft's
    platform, Azure, has a client library that is written for Go.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many of the aforementioned cloud services, deploying to Amazon Web Service
    or AWS is by and large no different than deploying it to any standard physical
    server's infrastructure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: There are a few differences with AWS though. The first is the breadth of services
    provided by it. Amazon does not strictly deal with only static virtual servers.
    It also deals with an array of supportive services such as DNS, e-mail, and SMS
    services (via their SNS service), long-term storage, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Despite all that has been said so far, note that many of the alternate cloud
    services provide similar functionality that may prove analogous to that provided
    with the following examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Using Go to interface directly with AWS
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While some cloud services do offer some form of an API with their service, none
    are as robust as Amazon Web Services.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The AWS API provides direct access to every possible action in its environment,
    from adding instances, to provisioning IP addresses, to adding DNS entries and
    much more.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, interfacing directly with this API can open up a lot of
    possibilities since it relates to automating the health of your application as
    well as managing updates and bug fixes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'To interface with AWS directly, we''ll initiate our application with the `goamz`
    package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To grab the two dependencies to run this example, run the `go get launchpad.net/goamz/aws`
    command and the `go get launchpad.net/goamz/ec2` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional documentation about this at [http://godoc.org/launchpad.net/goamz](http://godoc.org/launchpad.net/goamz).
    The `goamz` package also includes a package for the Amazon S3 storage service
    and some additional experimental packages for Amazon's SNS service and Simple
    Database Service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new instance based on an image is simple. Perhaps it is too simple
    if you're used to deploying it manually or through a controlled, automated, or
    autoscaled process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this instance `ami-9eaa1cf6` refers to Ubuntu Server 14.04.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Having an interface to Amazon's API will be important in our next section where
    we'll take our image data and move it out of our relational database and into
    a CDN.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Handling binary data and CDNs
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that way back in [Chapter 3](ch03.html "Chapter 3. Routing and
    Bootstrapping"), *Routing and Bootstrapping*, we looked at how to store binary
    data, specifically image data, for our application in a database in the BLOB format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: At that time, we handled this in a very introductory way to simply get binary
    image data into some sort of a storage system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Amazon S3 is part of the content distribution/delivery network aspect of AWS,
    and it operates on the notion of buckets as collections of data, with each bucket
    having its own set of access control rights. It should be noted that AWS also
    presents a true CDN called Cloudfront, but S3 can be used for this purpose as
    a storage service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at using the `goamz` package to list up to 100 items in a
    given bucket:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace ----------- in the code with your credentials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our social network example, we're handling this as part of the `/api/user/:id:`
    endpoint.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Return uploaded, instead we either check for the error and continue attempting
    to process the image or we move on. We''ll show how to handle an empty value here
    in a bit:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point we've attempted to read the image and extract the data—if we cannot,
    we print the response through `fmt.Println` or `log.Println` and skip the remaining
    steps, but do not panic as we can continue editing in other ways.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In [Chapter 3](ch03.html "Chapter 3. Routing and Bootstrapping"), *Routing and
    Bootstrapping*, we took the data as it was uploaded in our form, converted it
    into a Base64-encoded string, and saved it in our database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re now going to save the image data directly, we can skip this final
    step. We can instead read anything from the `FormFile` function in our request
    and take the entire data and send it to our S3 bucket, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It would make sense for us to ensure that we have a unique identifier for this
    image—one that avoids race conditions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the existence of a file upload
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FormFile()`function actually calls `ParseMultipartForm()` under the hood
    and returns default values for the file, the file header, and a standard error
    if nothing exists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails with net/smtp
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decoupling our API and social network from ancillary tools is a good idea to
    create a sense of specificity in our system, reduce conflicts between these systems,
    and provide more appropriate system and maintenance rules for each.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be simple enough to equip our e-mail system with a socket client that
    allows the system to listen directly for messages from our API. In fact, this
    could be accomplished with just a few lines of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s look at the actual send function that will deliver our message from
    the registration process in our API to the e-mail server:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While this system will work well, as we can listen on TCP and receive messages
    that tell us what to send and to what address, it's not particularly fault tolerant
    on its own.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个系统可以很好地工作，因为我们可以监听TCP并接收告诉我们要发送什么和发送到什么地址的消息，但它本身并不特别容错。
- en: We can address this problem easily by employing a message queue system, which
    we'll look at next with RabbitMQ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用消息队列系统轻松解决这个问题，接下来我们将使用RabbitMQ来看一下。
- en: RabbitMQ with Go
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RabbitMQ with Go
- en: An aspect of web design that's specially relevant to APIs, but is a part of
    almost any web stack, is the idea of a message passing between servers and other
    systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Web设计的一个方面，特别与API相关，但几乎是任何Web堆栈的一部分，是服务器和其他系统之间的消息传递的概念。
- en: It is commonly referred to as **Advanced Message Queuing Protocol** or **AMQP**.
    It can be an essential piece to an API/web service since it allows services that
    are otherwise separated to communicate with each other without utilizing yet another
    API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常被称为**高级消息队列协议**或**AMQP**。它可以成为API/web服务的重要组成部分，因为它允许否则分离的服务相互通信，而无需使用另一个API。
- en: By message passing, we're talking here about generic things that can or should
    be shared between dissonant systems getting moved to the relevant recipient whenever
    something important happens.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息传递，我们在这里谈论的是可以或应该在发生重要事件时在不同的系统之间共享的通用事物被传递给相关的接收者。
- en: To draw another analogy, it's like a push notification on your phone. When a
    background application has something to announce to you, it generates the alert
    and passes it through a message passing system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再举个类比，就像手机上的推送通知。当后台应用程序有要通知您的事情时，它会生成警报并通过消息传递系统传递。
- en: 'The following diagram is a basic representation of this system. The sender
    (S), in our case the API, will add messages to the stack that will then be retrieved
    by the receiver (R) or the e-mail sending process:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是该系统的基本表示。发送者（S），在我们的情况下是API，将消息添加到堆栈，然后接收者（R）或电子邮件发送过程将检索这些消息：
- en: '![RabbitMQ with Go](img/1304OS_09_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![RabbitMQ with Go](img/1304OS_09_01.jpg)'
- en: We believe that these processes are especially important to APIs because often,
    there's a institutional desire to segregate an API from the rest of the infrastructure.
    Although this is done to keep an API resource from impacting a live site or to
    allow two different applications to operate on the same data safely, it can also
    be used to allow one service to accept many requests while permitting a second
    service or system to process them as resources permit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这些过程对API特别重要，因为通常有机构希望将API与基础设施的其余部分隔离开来。尽管这样做是为了防止API资源影响现场站点或允许两个不同的应用程序安全地在相同的数据上运行，但也可以用于允许一个服务接受多个请求，同时允许第二个服务或系统根据资源的允许情况进行处理。
- en: This also provides a very basic data glue for applications written in different
    programming languages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这还为用不同编程语言编写的应用程序提供了非常基本的数据粘合剂。
- en: In our web service, we can use an AMQP solution to tell our e-mail system to
    generate a welcome e-mail upon successful registration. This frees our core API
    from having to worry about doing that and it can instead focus on the core of
    our system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Web服务中，我们可以使用AMQP解决方案告诉我们的电子邮件系统在成功注册后生成欢迎电子邮件。这使我们的核心API不必担心这样做，而是可以专注于我们系统的核心。
- en: 'There are a number of ways in which we can formalize the requests between system
    A and system B, but the easiest way to demonstrate a simple e-mail message is
    by setting a standard message and title and passing it in JSON:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过制定标准消息和标题并将其传递为JSON来形式化系统A和系统B之间的请求的多种方式之一：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Receiving e-mails in this way instead of via an open TCP connection enables
    us to protect the integrity of the messages. In our previous example, any message
    that would be lost due to failure, crash, or shutdown would be lost forever.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式接收电子邮件，而不是通过开放的TCP连接，使我们能够保护消息的完整性。在我们之前的例子中，由于故障、崩溃或关闭而丢失的任何消息将永远丢失。
- en: Message queues, on the other hand, operate like mailboxes with levels of configurable
    durability that allow us to dictate how messages should be saved, when they expire,
    and what processes or users should have access to them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列，另一方面，就像具有可配置耐久性级别的邮箱一样运作，这使我们能够决定消息应该如何保存，何时过期，以及哪些进程或用户应该访问它们。
- en: In this case, we use a literal message that is delivered as part of a package
    that will be ingested by our mail service through the queue. In the case of a
    catastrophic failure, the message will still be there for our SMTP server to process.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用一个文字消息，作为一个包的一部分交付，将通过队列被我们的邮件服务摄取。在发生灾难性故障的情况下，消息仍将存在，供我们的SMTP服务器处理。
- en: Another important feature is its ability to send a "receipt" to the message
    initiator. In this case, an e-mail system would tell the API or web service that
    the e-mail message was successfully taken from the queue by the e-mail process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是它能够向消息发起者发送“收据”。在这种情况下，电子邮件系统会告诉API或Web服务，电子邮件消息已成功从队列中被电子邮件进程取走。
- en: This is something that is not inconsequential to replicate within our simple
    TCP process. The number of fail-safes and contingencies that we'd have to build
    in would make it a very heavy, standalone product.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们简单的TCP过程中复制的一些东西。我们必须构建的故障保护和应急措施的数量将使其成为一个非常沉重的独立产品。
- en: 'Luckily, integrating a message queue is pretty simple within Go:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在Go中集成消息队列是相当简单的：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is just our connection to the RabbitMQ server. If any error with the connection
    is detected, we will stop the process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们与RabbitMQ服务器的连接。如果检测到连接出现任何错误，我们将停止该过程。
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The name of the queue here is somewhat arbitrary like a memcache key or a database
    name. The key is to make sure that both the sending and receiving mechanisms search
    for the same queue name:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里队列的名称有点像memcache键或数据库名称一样任意。关键是确保发送和接收机制搜索相同的队列名称：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our loop here, we listen for messages and invoke the `Send()` method when
    we receive one. In this case, we''re passing JSON that is then unmarshalled into
    a `Message` struct, but this format is entirely up to you:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And, in our `main()` function, we need to make sure that we replace our infinite
    TCP listener with the `Listen()` function that calls the AMQP listener:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we have the ability to take messages (in the e-mail sense) from the queue
    of messages (in the message queue sense), which means that we'd simply need to
    include this functionality in our web service as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In the example usage that we discussed, a newly registered user would receive
    an e-mail that prompts for the activation of the account. This is generally done
    to prevent sign ups with fake e-mail addresses. This is not an airtight security
    mechanism by any means, but it ensures that our application can communicate with
    a person who ostensibly has access to a real e-mail address.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Sending to the queue is also easy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that we''re sharing credentials across two separate applications, it
    makes sense to formalize this into a separate package:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this way, both our API and our listener can import our `emailQueue` package
    and share these credentials. In our `api.go` file, add the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And in our `e-mail.go` process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AMQP is a more generalized message passing interface with RabbitMQ extensions.
    You can read more about it at [https://github.com/streadway/amqp](https://github.com/streadway/amqp).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: More information on Grab Rabbit Hole is available at [https://github.com/michaelklishin/rabbit-hole](https://github.com/michaelklishin/rabbit-hole)
    or can be downloaded using the `go get github.com/michaelklishin/rabbit-hole`
    command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By separating the logic of our API from our hosted environment and ancillary,
    supportive services, we can reduce the opportunity for feature creep and crashes
    due to non-essential features.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we moved image hosting out of our database and into the cloud
    and stored raw image data and the resulting references to S3, a service that is
    often used as a CDN. We then used RabbitMQ to demonstrate how message passing
    can be utilized in deployment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a grasp of offloading these services as well
    as a better understanding of the available strategies for deployment, updates,
    and graceful restarts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll begin to round out the final, necessary requirements
    of our social network and in doing so, explore some ways to increase the speed,
    reliability, and overall performance of our web service.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: We'll also introduce a secondary service that allows us to chat within our social
    network from the SPA interface as well as expand our image-to-CDN workflow to
    allow users to create galleries. We'll look at ways in which we can maximize image
    presentation and acquisition through both the interface and the API directly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
