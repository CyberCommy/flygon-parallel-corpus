- en: Chapter 9. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When all is said and done, and you're ready to launch your web service or API,
    there are always considerations that need to be taken into account with regards
    to launching, from code repository, to staging, to live environments, to stop,
    start, and update policies.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying compiled applications always carries a little more complexity than
    doing so with interpreted applications. Luckily, Go is designed to be a very modern,
    compiled language. By this, we mean that a great deal of thought has been devoted
    to the kinds of problems that traditionally plagued servers and services built
    in C or C++.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, in this chapter, we're going to look at some tools and strategies
    that are available to us for painlessly deploying and updating our application
    with minimal downtime.
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to examine some things that we can do to reduce the internal
    load of our web service, such as offloading image storage and messaging as part
    of our deployment strategy.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have some Go-specific and general tips
    that will minimize some of the heartache that is endemic to deploying APIs and
    web services, particularly those that are frequently updated and require the least
    amount of downtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Application design and structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment options and strategies for the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilization of messaging systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling image hosting from our API server and connecting it with a cloud-based
    CDN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the design and infrastructure of your application is a matter of institutional
    and personal preference, the way you plan its architecture can have a very real
    impact on the approach that you use to deploy your application to the cloud or
    anywhere in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly review the structure that we have for our application, keeping
    in mind that we won''t need package objects unless we intend to produce our application
    for mass cross-platform usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The structure of our application may be noteworthy depending on how we deploy
    it to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: If there's a conduit process before deployment that handles the build, dependency
    management, and push to the live servers, then this structure is irrelevant as
    the source and Go package dependencies can be eschewed in lieu of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: However, in scenarios where the entire project is pushed to each application
    server or servers or NFS/file servers, the structure remains essential. In addition,
    as noted earlier, any place where cross-platform distribution is a consideration,
    the entire structure of the Go project should be preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Even when this is not critical, if the build machine (or machines) are not exactly
    like the target machines, this impacts your process for building the binary, although
    it does not preclude solely dealing with that binary.
  prefs: []
  type: TYPE_NORMAL
- en: In an example GitHub repository, it might also require to obfuscate the nonbinary
    code if there is any open directory access, similar to our `interface.go` application.
  prefs: []
  type: TYPE_NORMAL
- en: Using process control to keep your API running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods for handling version control and development processes are beyond
    the scope of this book, but a fairly common issue with building and deploying
    compiled code for the Web is the process of installing and restarting the said
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the way updates happen while minimizing or removing downtime is critical
    for live applications.
  prefs: []
  type: TYPE_NORMAL
- en: For scripting languages and languages that rely on an external web server to
    expose the application via the Web, this process is easy. The scripts either listen
    for changes and restart their internal web serving or they are interpreted when
    they are uncached and the changes work immediately.
  prefs: []
  type: TYPE_NORMAL
- en: This process becomes more complicated with long-running binaries, not only for
    updating and deploying our application but also for ensuring that our application
    is alive and does not require manual intervention if the service stops.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are a couple of easy ways to handle this. The first is just strict
    process management for automatic maintenance. The second is a Go-specific tool.
    Let's look at process managers first and how they work with a Go web service.
  prefs: []
  type: TYPE_NORMAL
- en: Using supervisor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few big solutions here for *nix servers, from the absurdly simple
    to the more complex and granular. There''s not a lot of difference in the way
    they operate, so we''ll just briefly examine how we can manage our web service
    with one: Supervisor. Supervisor is readily available on most Linux distributions
    as well as on OS X, so it is a good example for testing locally.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some other process managers of note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upstart: [http://upstart.ubuntu.com/](http://upstart.ubuntu.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monit: [http://mmonit.com/monit/](http://mmonit.com/monit/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runit: [http://smarden.org/runit/](http://smarden.org/runit/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic premise of these direct supervision init daemon monitoring process
    managers is to listen for running applications if there are no live attempts to
    restart them based on a set of configured rules.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth pointing out here that these systems have no real distributed methods
    that allow you to manage multiple servers' processes in aggregate, so you'll generally
    have to yield to a load balancer and network monitoring for that type of feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Supervisor, after installing it, all we need is a simple configuration
    file that can be typically located by navigating to `/etc/supervisor/conf.d/`
    on *nix distros. Here''s an example of such a file for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While you can get more complex—for example, grouping multiple applications together
    to allow synchronous restarts that are useful for upgrades—that's all you should
    need to keep our long-running API going.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it''s time for updates, say from GIT to staging to live, a process that
    restarts the service can be triggered either manually or programmatically through
    a command such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to not only keep your application running, but it also imposes
    a full update process that pushes your code live and triggers a restart of the
    process. This ensures the least possible amount of downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using Manners for more graceful servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While init replacement process managers work very well on their own, they do
    lack some control from within the application. For example, simply killing or
    restarting the web server would almost surely drop any active requests.
  prefs: []
  type: TYPE_NORMAL
- en: On its own, Manners lacks some of the listening control of a process such as
    **goagain**, which is a library that corrals your TCP listeners in goroutines
    and allows outside control for restarts via SIGUSR1/SIGUSR2 interprocess custom
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can use the two together to create such a process. Alternatively,
    you can write the internal listener directly, as goagain may end up being a slight
    overkill for the aim of gracefully restarting a web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using Manners as a drop-in replacement/wrapper around `net/http`
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After running within a goroutine and blocking with the channel that is listening
    for SIGUSR1 or SIGUSR2, we will pass our Boolean along the `Server.Shutdown` channel
    when such a signal is received.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is just a rehash of our `Init()` function within `api.go`. This registers
    the Gorilla router that we'll need for our Manners wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `main()` function, instead of just starting our `http.ListenAndServe()`
    function, we use the Manners server.
  prefs: []
  type: TYPE_NORMAL
- en: This will prevent open connections from breaking when we send a shutdown signal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install Manners with `go get github.com/braintree/manners`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about Manners at [https://github.com/braintree/manners](https://github.com/braintree/manners).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install goagain with `go get github.com/rcrowley/goagain`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about goagain at [https://github.com/rcrowley/goagain](https://github.com/rcrowley/goagain).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few years, there have been very few server-side products that have
    made as big a wave as Docker in the tech world.
  prefs: []
  type: TYPE_NORMAL
- en: Docker creates something akin to easily deployable, preconfigured virtual machines
    that have a much lower impact on the host machine than traditional VM software
    such as VirtualBox, VMWare, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: It is able to do this with much less overall weight than VMs by utilizing Linux
    Containers, which allows the user space to be contained while retaining access
    to a lot of the operating system itself. This prevents each VM from needing to
    be a full image of the OS and the application for all practical purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be used in Go, this is generally a good fit, particularly if we
    create builds for multiple target processors and wish to easily deploy Docker
    containers for any or all of them. It is even better that the setup aspect is
    largely handled out of the box now, as Docker has created language stacks and
    included Go within them.
  prefs: []
  type: TYPE_NORMAL
- en: While at its core Docker is essentially just an abstraction of a typical Linux
    distribution image, using it can make upgrading and quickly provisioning a breeze,
    and it may even provide additional security benefits. The last point depends a
    bit on your application and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Docker operates with the use of very simple configuration files, and using a
    language stack, you can easily create a container that can be launched and has
    everything we need for our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this Docker file example to see how we''d get all the necessary
    packages for our social networking web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The file can then be built and run using simple commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see how, at bare minimum, this would greatly speed up the Go update
    procedure across multiple instances (or containers in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Complete Docker the base images are also available for the Google Cloud Platform.
    These are useful for quickly deploying the most recent version of Go if you use
    or would like to test Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying in cloud environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who remember the days of rooms full of physical single-purpose servers,
    devastating hardware faults, and insanely slow rebuild and backup times, the emergence
    of cloud hosting has in all likelihood been a godsend.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, a full architecture can often be built from templates in short order,
    and autoscaling and monitoring are easier than ever. Now, there are a lot of players
    in the market too, from Google, Microsoft, and Amazon to smaller companies such
    as Linode and Digital Ocean that focus on simplicity, thrift, and ease of usage.
  prefs: []
  type: TYPE_NORMAL
- en: Each web service comes with its own feature set as well as disadvantages, but
    most share a very common workflow. For the sake of exploring additional functionality
    that may be available via APIs within Golang itself, we'll look at Amazon Web
    Services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that similar tools exist for other cloud platforms in Go. Even Microsoft's
    platform, Azure, has a client library that is written for Go.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many of the aforementioned cloud services, deploying to Amazon Web Service
    or AWS is by and large no different than deploying it to any standard physical
    server's infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few differences with AWS though. The first is the breadth of services
    provided by it. Amazon does not strictly deal with only static virtual servers.
    It also deals with an array of supportive services such as DNS, e-mail, and SMS
    services (via their SNS service), long-term storage, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all that has been said so far, note that many of the alternate cloud
    services provide similar functionality that may prove analogous to that provided
    with the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go to interface directly with AWS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While some cloud services do offer some form of an API with their service, none
    are as robust as Amazon Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS API provides direct access to every possible action in its environment,
    from adding instances, to provisioning IP addresses, to adding DNS entries and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, interfacing directly with this API can open up a lot of
    possibilities since it relates to automating the health of your application as
    well as managing updates and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interface with AWS directly, we''ll initiate our application with the `goamz`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To grab the two dependencies to run this example, run the `go get launchpad.net/goamz/aws`
    command and the `go get launchpad.net/goamz/ec2` command.
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional documentation about this at [http://godoc.org/launchpad.net/goamz](http://godoc.org/launchpad.net/goamz).
    The `goamz` package also includes a package for the Amazon S3 storage service
    and some additional experimental packages for Amazon's SNS service and Simple
    Database Service.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new instance based on an image is simple. Perhaps it is too simple
    if you're used to deploying it manually or through a controlled, automated, or
    autoscaled process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this instance `ami-9eaa1cf6` refers to Ubuntu Server 14.04.
  prefs: []
  type: TYPE_NORMAL
- en: Having an interface to Amazon's API will be important in our next section where
    we'll take our image data and move it out of our relational database and into
    a CDN.
  prefs: []
  type: TYPE_NORMAL
- en: Handling binary data and CDNs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that way back in [Chapter 3](ch03.html "Chapter 3. Routing and
    Bootstrapping"), *Routing and Bootstrapping*, we looked at how to store binary
    data, specifically image data, for our application in a database in the BLOB format.
  prefs: []
  type: TYPE_NORMAL
- en: At that time, we handled this in a very introductory way to simply get binary
    image data into some sort of a storage system.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon S3 is part of the content distribution/delivery network aspect of AWS,
    and it operates on the notion of buckets as collections of data, with each bucket
    having its own set of access control rights. It should be noted that AWS also
    presents a true CDN called Cloudfront, but S3 can be used for this purpose as
    a storage service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at using the `goamz` package to list up to 100 items in a
    given bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace ----------- in the code with your credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our social network example, we're handling this as part of the `/api/user/:id:`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Return uploaded, instead we either check for the error and continue attempting
    to process the image or we move on. We''ll show how to handle an empty value here
    in a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point we've attempted to read the image and extract the data—if we cannot,
    we print the response through `fmt.Println` or `log.Println` and skip the remaining
    steps, but do not panic as we can continue editing in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 3](ch03.html "Chapter 3. Routing and Bootstrapping"), *Routing and
    Bootstrapping*, we took the data as it was uploaded in our form, converted it
    into a Base64-encoded string, and saved it in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re now going to save the image data directly, we can skip this final
    step. We can instead read anything from the `FormFile` function in our request
    and take the entire data and send it to our S3 bucket, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It would make sense for us to ensure that we have a unique identifier for this
    image—one that avoids race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the existence of a file upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FormFile()`function actually calls `ParseMultipartForm()` under the hood
    and returns default values for the file, the file header, and a standard error
    if nothing exists.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails with net/smtp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decoupling our API and social network from ancillary tools is a good idea to
    create a sense of specificity in our system, reduce conflicts between these systems,
    and provide more appropriate system and maintenance rules for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be simple enough to equip our e-mail system with a socket client that
    allows the system to listen directly for messages from our API. In fact, this
    could be accomplished with just a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the actual send function that will deliver our message from
    the registration process in our API to the e-mail server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While this system will work well, as we can listen on TCP and receive messages
    that tell us what to send and to what address, it's not particularly fault tolerant
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: We can address this problem easily by employing a message queue system, which
    we'll look at next with RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ with Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An aspect of web design that's specially relevant to APIs, but is a part of
    almost any web stack, is the idea of a message passing between servers and other
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: It is commonly referred to as **Advanced Message Queuing Protocol** or **AMQP**.
    It can be an essential piece to an API/web service since it allows services that
    are otherwise separated to communicate with each other without utilizing yet another
    API.
  prefs: []
  type: TYPE_NORMAL
- en: By message passing, we're talking here about generic things that can or should
    be shared between dissonant systems getting moved to the relevant recipient whenever
    something important happens.
  prefs: []
  type: TYPE_NORMAL
- en: To draw another analogy, it's like a push notification on your phone. When a
    background application has something to announce to you, it generates the alert
    and passes it through a message passing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a basic representation of this system. The sender
    (S), in our case the API, will add messages to the stack that will then be retrieved
    by the receiver (R) or the e-mail sending process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RabbitMQ with Go](img/1304OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We believe that these processes are especially important to APIs because often,
    there's a institutional desire to segregate an API from the rest of the infrastructure.
    Although this is done to keep an API resource from impacting a live site or to
    allow two different applications to operate on the same data safely, it can also
    be used to allow one service to accept many requests while permitting a second
    service or system to process them as resources permit.
  prefs: []
  type: TYPE_NORMAL
- en: This also provides a very basic data glue for applications written in different
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: In our web service, we can use an AMQP solution to tell our e-mail system to
    generate a welcome e-mail upon successful registration. This frees our core API
    from having to worry about doing that and it can instead focus on the core of
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways in which we can formalize the requests between system
    A and system B, but the easiest way to demonstrate a simple e-mail message is
    by setting a standard message and title and passing it in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Receiving e-mails in this way instead of via an open TCP connection enables
    us to protect the integrity of the messages. In our previous example, any message
    that would be lost due to failure, crash, or shutdown would be lost forever.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues, on the other hand, operate like mailboxes with levels of configurable
    durability that allow us to dictate how messages should be saved, when they expire,
    and what processes or users should have access to them.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use a literal message that is delivered as part of a package
    that will be ingested by our mail service through the queue. In the case of a
    catastrophic failure, the message will still be there for our SMTP server to process.
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature is its ability to send a "receipt" to the message
    initiator. In this case, an e-mail system would tell the API or web service that
    the e-mail message was successfully taken from the queue by the e-mail process.
  prefs: []
  type: TYPE_NORMAL
- en: This is something that is not inconsequential to replicate within our simple
    TCP process. The number of fail-safes and contingencies that we'd have to build
    in would make it a very heavy, standalone product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, integrating a message queue is pretty simple within Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is just our connection to the RabbitMQ server. If any error with the connection
    is detected, we will stop the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the queue here is somewhat arbitrary like a memcache key or a database
    name. The key is to make sure that both the sending and receiving mechanisms search
    for the same queue name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our loop here, we listen for messages and invoke the `Send()` method when
    we receive one. In this case, we''re passing JSON that is then unmarshalled into
    a `Message` struct, but this format is entirely up to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in our `main()` function, we need to make sure that we replace our infinite
    TCP listener with the `Listen()` function that calls the AMQP listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the ability to take messages (in the e-mail sense) from the queue
    of messages (in the message queue sense), which means that we'd simply need to
    include this functionality in our web service as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the example usage that we discussed, a newly registered user would receive
    an e-mail that prompts for the activation of the account. This is generally done
    to prevent sign ups with fake e-mail addresses. This is not an airtight security
    mechanism by any means, but it ensures that our application can communicate with
    a person who ostensibly has access to a real e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: Sending to the queue is also easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that we''re sharing credentials across two separate applications, it
    makes sense to formalize this into a separate package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, both our API and our listener can import our `emailQueue` package
    and share these credentials. In our `api.go` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And in our `e-mail.go` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AMQP is a more generalized message passing interface with RabbitMQ extensions.
    You can read more about it at [https://github.com/streadway/amqp](https://github.com/streadway/amqp).
  prefs: []
  type: TYPE_NORMAL
- en: More information on Grab Rabbit Hole is available at [https://github.com/michaelklishin/rabbit-hole](https://github.com/michaelklishin/rabbit-hole)
    or can be downloaded using the `go get github.com/michaelklishin/rabbit-hole`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By separating the logic of our API from our hosted environment and ancillary,
    supportive services, we can reduce the opportunity for feature creep and crashes
    due to non-essential features.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we moved image hosting out of our database and into the cloud
    and stored raw image data and the resulting references to S3, a service that is
    often used as a CDN. We then used RabbitMQ to demonstrate how message passing
    can be utilized in deployment.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a grasp of offloading these services as well
    as a better understanding of the available strategies for deployment, updates,
    and graceful restarts.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll begin to round out the final, necessary requirements
    of our social network and in doing so, explore some ways to increase the speed,
    reliability, and overall performance of our web service.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also introduce a secondary service that allows us to chat within our social
    network from the SPA interface as well as expand our image-to-CDN workflow to
    allow users to create galleries. We'll look at ways in which we can maximize image
    presentation and acquisition through both the interface and the API directly.
  prefs: []
  type: TYPE_NORMAL
