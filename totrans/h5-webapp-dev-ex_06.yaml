- en: Chapter 6. Piano Man
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"More than art, more than literature, music is universally accessible." – Billy
    Joel'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this chapter, we will learn how to use audio by creating a virtual piano
    application. First, we will learn about the HTML5 Audio element and API. Then
    we will create an audio manager to load audio files asynchronously and cache them
    for playback later. We will create a keyboard using HTML elements and style it
    using CSS.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 `<audio>` element and its attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Audio API to control audio in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to dynamically load audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle keyboard events to turn the computer keyboard into a piano keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a range input to control the volume of an audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to check if the range input type is supported by your browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 audio overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing our piano application, we need to learn the basics of
    how to use HTML5 audio. So let's start with an overview of the `<audio>` element
    and its API.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 <audio> element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML5 `<audio>` element is used to define an audio file to play in your
    web page or application. The `audio` element can have visible controls on the
    page or it can remain hidden and be controlled from JavaScript. Here are a few
    of the most useful attributes it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`: URL of the audio file to load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoplay`: Used to specify that the file should start playing as soon as it''s
    loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controls`: Tells the browser to display audio controls on the page. Otherwise,
    nothing is displayed for the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: Specifies that the audio will play in a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`muted`: Specifies that the audio will be muted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preload`: Defines how the audio file is loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto`: Loads the audio file when the page loads. This is the default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: Does not preload the file, waits until it is played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: Loads only metadata about the file when the page loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following plays `audioFile.mp3` automatically after the page loads and
    shows the audio controls on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it looks like when displayed on the page in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTML5 <audio> element](img/5947_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the browser doesn't support the `<audio>` element, it will display whatever
    content is inside the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can specify the file to load using the `src` attribute, it is
    not recommended. Different browsers support different file types, so if you only
    specify one it may not work on all browsers. Instead, you should specify `<source>`
    child elements inside the `<audio>` element to define a list of different audio
    files to use. The browser will use the first one that it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The three primary audio types supported are MP3, Ogg, and WAV. You should at
    least provide the MP3 and Ogg files, since all of the major browsers support one
    or the other. If you also want to include a WAV file, put it last in the list
    since WAV files are not compressed and therefore take a lot of bandwidth to download.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 Audio API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all you could do with HTML5 audio is put an element on a web page to let
    the user listen to music, it would be pretty boring, and this chapter would be
    over. But like the `<canvas>` element, the `<audio>` element has a whole API backing
    it up. We can use the Audio API to control how and when audio clips are played
    from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Audio API contains a large number of methods and properties. Here are a
    few of the most useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`play()`: Starts playing the audio clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause()`: Pauses playback of the audio clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canPlayType(type)`: Used to determine if a certain audio type is supported
    by the browser. Pass in an audio MIME type such as `"audio/ogg"` or `"audio/mpeg"`.
    It returns one of the following values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"probably"`: Most likely supports it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"maybe"`: The browser may be able to play it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""` (empty string): Doesn''t support it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentTime`: Used to get or set the current playback time in seconds. This
    allows us to cue up the sound at a certain point before playing it. Usually we
    will set it to `0` to restart the sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: Used to get or set the volume. Can be any value between `0` and `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ended`: Used to determine if the sound has played all the way through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `<audio>` and `<video>` elements both share the same API. So if
    you know how to use HTML audio, you know how to use video as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Audio API to do some interesting things with sounds. In this
    chapter, we will create a virtual piano that the user can play on the web page
    by clicking the keys of a piano keyboard on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Loading audio files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You could define all of the audio files for your application by adding `<audio>`
    elements for each one to your HTML file. However, we can also load audio files
    dynamically from JavaScript to control how and when they are loaded. We can load
    them just like we loaded image files dynamically in the previous chapter. First,
    we create a new `<audio>` element and set the `src` attribute to the name of the
    audio file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add an event handler to get notified when the audio file has finished
    loading. There are two events that we can use. The `canplay` event is fired as
    soon as the browser has enough data to start playing the audio. The `canplaythrough`
    event is fired after the file has been completely loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – creating an AudioManager object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's encapsulate the loading of audio files into a re-usable object. We will
    create a new object called `AudioManager` and place it in a file named `audioManager.js`.
    This object will abstract all of the code needed to load, cache, and access audio
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for our object takes one parameter named `audioPath`, which
    is the path to where audio files are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If `audioPath` isn''t defined, we default it to an empty string. Then we add
    a variable named `audios` which is an object that will be used to cache all of
    the `<audio>` elements that are loaded. Finally, we define a variable to hold
    the audio file extension supported by the browser, which we will determine by
    calling the `getSupportedFileTypeExt()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `<audio>` element in memory and use that to call the
    `canPlayType()` method to determine the file type the browser supports. Then we
    return the file extension for that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a way to get the audio files from the `AudioManager` object.
    Let''s add a public `getAudio()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `getAudio()` method takes three parameters. The first is the name of the
    audio file without the extension. We will add the audio path and default extension
    to it later when loading the file. The next two parameters are optional. The second
    parameter is a function that will get called when the file has finished loading.
    The third is a function that will get called if there was an error loading the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing `getAudio()` does is check the `audios` object to see if we
    already loaded and cached that file. The `audios` object is used like an associative
    array in this case, where the key is the filename and the value is the audio element.
    This makes it easy to look up `<audio>` elements by name.
  prefs: []
  type: TYPE_NORMAL
- en: If the file hasn't been added to the cache yet, then we create a new `audio`
    element and load it by calling the `createAudio()` method, which we will implement
    next. Then it adds the new element to the `audios` object to cache it.
  prefs: []
  type: TYPE_NORMAL
- en: If the filename was already in the cache, then we immediately call the `onLoaded()`
    handler function that was passed in as a parameter since the file has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the private `createAudio()` method. It takes the same parameters
    as the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `<audio>` element using jQuery. Then we add an event
    listener for `canplaythrough`. When the event is fired, we check if an `onLoaded`
    function was passed into the method. If so, we call it passing it the new `<audio>`
    element. We also need to remove the event listener because some browsers will
    call it every time the audio is played.
  prefs: []
  type: TYPE_NORMAL
- en: We also add an `onerror` handler to the `<audio>` element to check for errors
    while loading the file. If we get an error, it calls the `onError` function, if
    it was defined.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the `src` attribute of the `<audio>` element to the URL of the
    audio file. We build the URL by combining `audioPath`, the name parameter, and
    `audioExt`. This will cause the audio file to start loading. Finally, we return
    the new `<audio>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created an object called `AudioManager` to load and cache audio files. The
    first time we request an audio file, it gets loaded and cached. The next time
    it uses the cached audio. For example, if our browser supports Ogg files, the
    following code will load the `audio/2C.ogg` audio file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: HTML5 piano application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's create our HTML5 piano application. We will have two octaves worth
    of piano keys, both black and white, and we will use some styling to make it look
    like a real keyboard. When the user clicks on a key with the mouse, it will play
    the corresponding note, which is defined in an audio file.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this section in `chapter6/example6.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a virtual piano
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start as usual by copying our application template that we created in
    [Chapter 1](ch01.html "Chapter 1. The Task at Hand"), *The Task at Hand*, and
    renaming the files to `piano.html`, `piano.css`, and `piano.js`. We also need
    `touchEvents.js` that we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `piano.js`, we''ll change the application object to `PianoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an instance of `AudioManager` and pass in the path to our audio files,
    which will be the `audio` folder. Now let''s open our HTML file and add all of
    the piano keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Inside of the "main" element, we add a `<div>` tag with `id` set to `keyboard`.
    Inside there we have a `<div>` tag that will be the backboard and a `<div>` tag
    that will contain all of the keys. Each key is defined by an element that contains
    a class of `piano-key` and a class of either `white` or `black` depending on the
    key color. Each key element also has a `data-note` custom data attribute. This
    will be set to the name of the piano key's note and will also be the name of the
    matching audio file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our piano has two full octaves of piano keys. Each key has its own audio file.
    Since each octave has 12 notes, and we have one more C note at the end of the
    keyboard, we will have 25 audio files named `2C` through `4C`. We want to supply
    audio files in both Ogg and MP3 formats to support all browsers, so in all we
    have 50 audio files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a virtual piano](img/5947_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s open `piano.css` and style the application. First of all we''ll make
    the application take up the whole browser window by setting `position` to `absolute`
    and setting all of the `position` values to `0`. We''ll give it a linear gradient
    from white to blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set the `footer` selector''s `position` attribute to `absolute` and
    `bottom` to `0`, so it hugs the bottom of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main section, we set `text-align` to `center`, so the keyboard is centered
    on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s style the keyboard to make it look like a real piano keyboard. First,
    we give the entire keyboard a gradient from dark brown to light brown and a shadow
    to give it some depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we style the backboard, which hides the tops of the keys. We give it
    a dark brown color, make it `32` pixels high, and give it a shadow to add depth.
    In order to get the shadow to draw over the piano keys, we need to set `position`
    as `relative`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the piano keys share some base styling that is defined with the `piano-key`
    class. First, we set `display` as `inline-block` so they stay on the same line
    and also have width and height. Then we give the bottom a border radius to make
    them look rounded. We''ll also set the `cursor` property to `pointer` so the user
    gets an indication that they can be clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get to the black and white keys'' styles. The white keys are a
    little wider and taller than the black keys. We also give them an ivory color
    and a shadow. Lastly, we need to set `z-index` to `1`, because they need to be
    displayed behind the black keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The black keys are a little smaller than the white. In order to make the black
    keys show over top of the white keys, we give set `z-index` to `2`. To make them
    seem to be in between the white keys, we set their `position` properties to `relative`
    and use a negative `left` offset to move them over top of the white keys. We also
    need a negative `right-margin` value, so the next white key gets pulled over and
    under it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how our piano would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a virtual piano](img/5947_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first image shows the keys with no margins set. Doesn't look much like a
    real keyboard, does it? The next image shows what it looks like with the `left`
    margin set. It's getting better but the white key hasn't moved over. Setting the
    right margin takes care of that.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a new HTML5 piano application starting with our application template.
    We defined all of the keys in HTML and then we styled them using negative offsets
    and margins to make the keys line up like a real keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it! We now have a two octave keyboard that looks pretty darn
    realistic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – loading the notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a keyboard but there's no sound yet. Let's head back over to our JavaScript
    and load all of the audio files. We will create a new method called `loadAudio()`
    and call it from the application's `start()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways by which we could load all the files. We could load them
    one at a time by calling `audioManager.getAudio()` for each file, which would
    be very verbose and require a lot of typing. Or we can iterate over all of the
    `piano-key` elements and get the filename from their `data-note` attributes. By
    using this method we could add more piano keys to the HTML and wouldn''t even
    have to touch the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is define some variables to keep track of the number of
    audio files that are being loaded and the number that have been loaded. We will
    use those to calculate the percent complete. We also need a variable to set if
    we get an error loading a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we do is select all of the `piano-key` elements using jQuery
    and call `each()` to iterate over them. For each one we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add 1 to the `count` variable to keep track of the total number of files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the note name, which is also the filename, from the `data-note` attribute.
    Notice that we must use the `escape()` function because some notes contain the
    sharp sign `#`, which is illegal in a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `audioManager.getAudio()` passing in the note name. This will cause the
    audio file to get loaded and cached. The next time we call `getAudio()` for this
    note, it will be loaded and ready to play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter to `getAudio()` is a function that gets called when each
    file has finished loading successfully. In this function we increment the loaded
    variable. Then we check if all of the files have been loaded and if so, show a
    ready message. Otherwise, we compute the percent complete of loaded files and
    show it in the footer by calling `setStatus()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last parameter to `getAudio()` is a function that gets called if there is
    an error loading a file. When that happens, we set the `error` variable to `true`
    and display a message showing the file that couldn't be loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you are running this application through a web server such as IIS,
    you may need to add the `.ogg` file type to the list of MIME types for your site
    (`.ogg`, `audio/ogg`). Otherwise, you will get an error saying that the file is
    not found.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `AudioManager` object to load all of the sounds for each keyboard
    key dynamically using their `data-note` attributes as the filename. Now we have
    all of our audio files loaded, cached, and ready to play.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – playing the notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing we need to do is add event handlers to play an `<audio>` element
    when a piano key is clicked or touched. We will hook up and event handlers to
    all of our piano keys and play the associated note when they are fired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of this writing, the state of audio on mobile devices isn't very
    good. Although a touch device would be perfect for a piano app, the sounds don't
    always play correctly because of the way mobile browsers cache audio (or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a method called `initKeyboard()` that will be called from the
    application''s `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we use jQuery to select all of the `piano-key` elements on the keyboard.
    Then,we use the touch event's jQuery extension to check if the browser supports
    touch events. If so, we hook up touch event handlers to the piano keys. Otherwise,
    we hook up the mouse event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: When a key is touched or the mouse clicked down, it calls the `keyDown()` method
    passing in the key element wrapped in a jQuery object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in this context, `this` is the element that was clicked. When the
    key is untouched or the mouse released, or the mouse leaves the element, we call
    the `keyUp()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `keyDown()` method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `keyDown()` method we first check if the key is already pressed down
    by checking if it has a class of `down`. If not, we add a class of `down` to the
    key element. We will use this to style the key to make it look like it's pressed.
    Then, we get the key's note name from the `data-note` custom attribute. We pass
    that to the `audioManager.getAudio()` method to get the `<audio>` element. To
    start playing the audio clip, we first set the `currentTime` property to `0` to
    cue up the sound at the start. Then we call the Audio API's `play()` method to
    start playing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `keyUp()` method simply removes the `down` class from the element, so the
    key won't be styled in the down position any more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is add the styling for the key down state. We
    will use a gradient to make it look like the end of the key is pressed down. We
    also make the shadow a little smaller since the key is not as high when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We hooked up event handlers to the piano keys to play the associated notes when
    they are clicked with the mouse or touched on a touch device. We added some styling
    to give a visual indication that the key is pressed down. Now we have a functioning
    piano using HTML5 Audio. Go ahead and open it in your browser and bang out some
    tunes.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Keyboard events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the mouse to play notes on our piano works okay, but it would be better
    if we could play more than one note at a time. To do that, we can use the computer's
    keyboard to play notes. To do this we will add keyboard event handlers to the
    DOM `document` in JavaScript and map keyboard keys to piano keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top two rows of the keyboard will be used for the first octave and the
    bottom two for the second octave. For example, pressing the *Q* key will play
    the lowest C note. Pressing the *2* key will play C#, *W* will play D, and so
    on. For the second octave, pressing *Z* will play middle C, *S* will play C#,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Keyboard events](img/5947_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can find the code for this section in `chapter6/example6.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding keyboard events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is add `keycodes.js` to our application. This
    file contains a global static object named `keyCodes` that maps keys on the keyboard
    to their associated key code. For example, `keyCodes.ENTER` is equal to `13`.
    Using this will make our code more readable than using key code numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is open the HTML and add a new custom data attribute
    to the `piano-key` elements. We will call it `data-keycode` and it will be set
    to the value in the `keyCode` object we want to associate with the piano key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to map key codes to the notes. We will add an object to our application
    called `keyCodesToNotes` to hold our mappings. We will initialize it in the `initKeyboard()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we iterate over all `piano-key` elements, getting the `data-keycode` custom
    attribute for each one and using that to get the key code from the `keyCodes`
    object. Then we add the mapping to `keyCodesToNotes` by setting it to the element's
    `data-note` custom attribute. For example, the key code for the *Q* key is 81
    and the associated piano key note is 2C. So `keyCodesToNotes[81]` will be set
    to `2C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the keyboard event handlers. When checking for key down, up,
    or pressed events, you need to attach your event handlers to the HTML document.
    Let''s add `keydown` and `keyup` event handlers in the `start()` method of our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keydown` event handler calls the `onKeyDown()` method. The `keyup` handler
    calls `onKeyUp()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onKeyDown()` method we look up the note for the key that was pressed
    using the `keyCodesToNotes` object. jQuery defines a `which` field on the key
    event object that contains the key code. If the key code matched to a note on
    our keyboard, then we call the `pressPianoKey()` method passing it the `note`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `onKeyUp()` method works the same way except that we call the `releasePianoKey()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `pressPianoKey()` method, we get the name of the note to play as a parameter.
    Then we call `getPianoKeyElement()` to get the piano key element associated with
    that note. Finally, we pass that element into the `keyDown()` method that we already
    implemented when we added mouse and touch events. In this way, we simulate the
    user clicking a piano key element on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `releasePianoKey()` method works exactly the same way except it calls the
    existing `keyUp()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the `getPianoKeyElement()` method, we find the `piano-key` element associated
    with a note by using a jQuery select matching on the `data-note` custom attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added keyboard key event handlers to the HTML document of our application.
    We mapped the key codes when a key is pressed to a piano key, so that the user
    can press keys on the keyboard to play the piano. By passing the `piano-key` element
    into `keyDown()` and `keyUp()`, we simulate the user clicking on those keys. They
    get the `down` class added to them so it looks like they are really being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Check it out for yourself. Try pressing two or three keys at a time and play
    some chords.
  prefs: []
  type: TYPE_NORMAL
- en: Volume and sustain controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add some controls to our piano to allow the user to change the volume
    and sustain. As you may recall, the volume of an `audio` element may be set to
    any value from `0` to `1.0`. We will use a range input control that allows the
    user to control that via a slider.
  prefs: []
  type: TYPE_NORMAL
- en: The sustain control allows a note to remain playing after the piano key is released.
    When sustain is turned off, the note will stop playing as soon as the key is released.
    We will add a checkbox to turn this off and on.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this section in `chapter6/example6.3`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a sustain control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add a sustain control to the application. We will use a
    checkbox input control to turn sustain on and off. In our HTML file, we will add
    a new `<div>` element with a class of `controls` under the keyboard to hold our
    controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We define a label and a checkbox with an `id` attribute of `sustain.` We also
    set it checked by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the code for the checkbox in our `PianoApp` application
    object. First, we need to add a variable named `sustain` and set it to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we hook up a `change` event handler to get notified when the checkbox
    changes. We will do this in the application''s `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the checkbox changes, we figure out if it is checked using the jQuery `is()`
    filter method passing it the `:checked` filter. If it is checked, the `sustain`
    variable gets set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make some changes to the `keyUp()` method. All the method does
    now is to remove the `down` class from the `piano-key` element. We need to add
    code to check the `sustain` variable and stop the sound from playing if this variable
    is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After removing the `down` class, we check the `sustain` variable. If sustain
    is not set, we get the note name from the `piano-key` element's `data-note` custom
    attribute and use that to get the `<audio>` element from the `audioManager` object.
    Then we call the `pause()` method to stop playing the sound.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a checkbox to allow the user to turn the sustain control on and off.
    When sustain is off and the user releases a piano key, we call the Audio API's
    `pause()` method to stop playback of the note.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a volume control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back into the HTML, let''s add a range input control to allow the user
    to change the volume. We will put it right under the sustain label and control
    we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We define a label and a range input with an `id` attribute of `volume`. We set
    the range of the control from `1` to `100` with a `step` value of `1`. We also
    default the value to `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `PianoApp` object we add another global variable named `volume`
    and set it to `1.0`, the maximum volume, by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `sustain` checkbox, we need to add a `change` event handler to the
    `start()` method of our application for the range control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that our range input control has a range of `1` to `100`,
    while the volume of an `audio` element is defined from `0` to `1.0`. Therefore,
    in our event handler, we set the `volume` variable to the value of the range control
    divided by `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is add one line of code to the `keyDown()` method to
    set the `volume` property of the `audio` element before playing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do a little styling in our CSS now for the `controls` section of the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We set the top margin to give the controls a little breathing room, set vertical
    align for the controls so labels line up in the middle, and set the width of the
    volume range control.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more thing we should do to make our application more dynamic.
    The range input control isn''t widely supported by all browsers, so let''s add
    some code to check if it''s supported. We''ll add an `isInputTypeSupported()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `<input>` element in memory. Then we set the `type` attribute
    to the type we are testing. In our case, that will be `range`. Then we check the
    `type` attribute to see if it is stuck. If the element retains that type, then
    the browser supports it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `start()` method we''ll add a check for the range type. If you recall
    from [Chapter 3](ch03.html "Chapter 3. The Devil is in the Details"), *The Devil
    is in the Details*, that if an input type isn''t supported, it will just be displayed
    as a text input field. So if the range type isn''t supported, we''ll change the
    width of the field to make it smaller. We don''t want a text input field that''s
    `10em` wide to input a number from `0` to `100` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We added a range input control to allow the user to change the volume of the
    sounds with a slider. Before playing the sound, we set the volume to the value
    selected by the user. We also wrote a method to check if certain HTML5 input types
    are supported by the browser. The following is what we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a wrapper object for `<audio>` elements that takes the element as a constructor
    and contains public methods to access the Audio API methods. Add some convenience
    methods, for example, `rewind()`, which sets `audio.currentTime = 0`, or `stop()`,
    which calls `pause()` and `rewind()`.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What audio type does the `<audio>` element support?
  prefs: []
  type: TYPE_NORMAL
- en: Ogg
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MP3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wav
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which object do you attach keyboard events to?
  prefs: []
  type: TYPE_NORMAL
- en: '`window`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`document`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`div`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`audio`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Audio tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we leave this chapter, I would like to tell you about a couple of free
    audio tools that you can use to get and manipulate audio files for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: FreeSound.org
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[FreeSound.org](http://FreeSound.org) is a website from where you can get audio
    files that are released under Creative Commons licenses. That means you can use
    them free of charge with various usage restrictions. There are public domain sounds,
    which you can use without doing anything. There are sounds that you can do anything
    with as long as you give the author credit. And there are sounds that you can
    use for anything except commercial purposes. The FreeSound database is vast and
    has great searching and browsing capabilities. You can find almost any sound you
    need on this website.'
  prefs: []
  type: TYPE_NORMAL
- en: Audacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Audacity is a free open source audio editor for recording, slicing, and mixing
    audio that runs on many different operating systems. Audacity works great for
    converting between multiple file types, which is great for us since we need to
    support different audio types for different browsers. It supports all of the main
    audio types used by the major web browsers, including Ogg, MP3 and WAV.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use the HTML5 `audio` element and API to
    add sounds to web applications. We saw how to load and cache audio files by creating
    a re-usable audio manager object. Then we used HTML5 audio to create a virtual
    piano application for playing the piano in a web page. We used keyboard events
    to allow the user to play the piano keys via the keyboard. We added controls to
    change the volume and sustain notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to add the HTML5 `<audio>` element to a web page and use its attributes
    to control it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Audio API from JavaScript to programmatically control the playback
    of an audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load audio files and cache them for playback later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to play, pause, and reset an audio file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to hook up keyboard events to the document and handle them in our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to change the volume of an `audio` element using a range input control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to check if any HTML5 input type is supported by the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will take our piano application and turn it into a game
    called Piano Hero. We will learn about timing, animating elements, and playing
    back music by creating an audio sequencer.
  prefs: []
  type: TYPE_NORMAL
