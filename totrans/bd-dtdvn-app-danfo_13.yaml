- en: '*Chapter 10*: Introduction to TensorFlow.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you were introduced to the basics of **machine learning**
    (**ML**), and you learned some theoretical foundations that are required in order
    to build and use ML models.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll introduce you to an efficient and popular ML library
    in JavaScript called TensorFlow.js. By the end of this chapter, you'll know how
    to install and use TensorFlow.js, how to create tensors, how to operate on tensors
    using the Core **application programming interface** (**API**), as well as how
    to build a regression model using TensorFlow.js's Layer API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is TensorFlow.js?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using TensorFlow.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tensors and basic operations on tensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple regression model with TensorFlow.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along in this chapter, you should have these tools or resources:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern browser such as Chrome, Safari, Opera, or Firefox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js installed on your system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable internet connection for downloading packages and datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available and can be cloned from GitHub at [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter10](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is TensorFlow.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TensorFlow.js** (**tfjs**) is a JavaScript library for creating, training,
    and deploying ML models in the browser or in Node.js. It was created at Google
    by Nikhil Thorat and Daniel Smilkov and was initially called Deeplearn.js, before
    being merged into the TensorFlow team in 2018 and renamed as TensorFlow.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TensorFlow.js provides two main layers, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CoreAPI**: This is the low-level API that deals directly with tensors—the
    core data structure of TensorFlow.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LayerAPI**: A high-level layer built on top of the CoreAPI layer for easily
    building ML models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In later sections, *Tensors and basic operations on tensors* and *Building a
    simple regression model with TensorFlow.js*, you will learn more details about
    the CoreAPI and LayerAPI layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With TensorFlow.js, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform hardware-accelerated mathematical operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop ML models for the browser or Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrain existing ML models using **transfer learning** (**TL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse existing ML models trained with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will cover performing hardware-accelerated mathematical
    operations and developing ML models with TensorFlow.js. If you want to learn about
    the last two use cases—retraining and reusing ML models—then the official TensorFlow.js
    documentation ([https://www.tensorflow.org/js/guide](https://www.tensorflow.org/js/guide))
    is a great place to start.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the introduction out of the way, in the next section, we'll show
    you how to install and use TensorFlow.js in both the browser and Node.js environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using TensorFlow.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, TensorFlow.js can be installed and run in both the
    browser and Node.js environment. In the following paragraphs, we'll show you how
    to achieve this, starting off with the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up TensorFlow.js in the browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of installing TensorFlow.js in the browser. These are outlined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Via script tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using package managers such as **Node Package Manager** (**npm**) or **Yarn**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing via script tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing TensorFlow.js via a `script` tag is easy. Just place the `script`
    tag in the header file of your **HyperText Markup Language** (**HTML**) file,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm that TensorFlow.js is installed, open the HTML file in the browser,
    and check the network tabs. You should see the name `tf.min.js` and a status code
    of `200`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Network tab showing the successful installation of tfjs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Network tab showing the successful installation of tfjs
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a simple script in the body of your HTML file to confirm the successful
    installation of `tfjs`. In a `script` section of your HTML file, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet logs the text `Tensorflow.js loaded` `successfully!`
    to the browser console, as soon as TensorFlow.js is loaded and ready on the page.
    To see the output, open the HTML file in the browser and check the console output.
    You should see an output result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Tensor output from add operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Tensor output from add operation
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how to install `tfjs` via package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Installing via package managers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install `tfjs` via package managers such as `npm` or `yarn`. This is
    useful when you need to use `tfjs` in client-side projects such as React and Vue
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install with `npm`, run the following command in your **command-line interface**
    (**CLI**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And to install with `yarn`, just run the following command in the CLI as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can successfully install packages using `npm` or `yarn` via the
    CLI, you must have either of them installed in your system—preferably globally.
    If you have Node.js installed, then you already have `npm`. To install `yarn`,
    you can follow the steps here: [https://classic.yarnpkg.com/en/docs/install/#mac-stable](https://classic.yarnpkg.com/en/docs/install/#mac-stable).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On successful installation, you can import and use `tfjs`, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code snippet will produce the following output in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Output from testing tfjs installed with package managers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Output from testing tfjs installed with package managers
  prefs: []
  type: TYPE_NORMAL
- en: By following the steps in the preceding code blocks, you should be able to install
    and use `tfjs` in the browser or client-side frameworks. In the next section,
    we'll show you how to install `tfjs` in a Node.js environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing TensorFlow.js in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing `tfjs` in Node.js is quite simple, but first, ensure you have Node.js,
    `npm`, or `yarn` installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: TensorFlow.js in Node.js has three options, and the choice of installation will
    depend on your system specification. In the following sub-sections, we'll show
    you these three options.
  prefs: []
  type: TYPE_NORMAL
- en: Installing TensorFlow.js with native C++ bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@tensorflow/tfjs-node` ([https://www.npmjs.com/package/@tensorflow/tfjs-node](mailto:https://www.npmjs.com/package/%40tensorflow/tfjs-node?subject=))
    version of `tfjs` connects directly to TensorFlow's native C++ bindings. This
    makes it fast, as well as giving it a close performance with the Python version
    of TensorFlow. This means that both `tfjs-node` and `tf.keras` use the same C++
    bindings under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `tfjs-node`, just run the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if using `yarn`, run the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Installing TensorFlow.js with GPU support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@tensorflow/tfjs-node-gpu` version of `tfjs` provides support for running
    operations on `tfjs-node-gpu` are generally faster than that of `tfjs-node` as
    operations can be easily vectorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `tfjs-node-gpu`, just run the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you''re using `yarn`, run the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Installing plain TensorFlow.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@tensorflow/tfjs` version is the pure JavaScript version of `tfjs`. It
    is the slowest in terms of performance and should rarely be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install this version, just run the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you''re using `yarn`, run the following command via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you followed the preceding steps, then you should have at least one of the
    versions of `tfjs` installed. You can test for successful installation using the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We call the `print()` function on a tensor when we want to see the underlying
    data. If we use the default `console.log`, we get the `Tensor` object instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding code should output the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Output from testing tfjs installed in Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Output from testing tfjs installed in Node.js
  prefs: []
  type: TYPE_NORMAL
- en: Now you have successfully installed `tfjs` in your project, in the next section,
    we'll introduce you to the core data structure of `tfjs`—tensors.
  prefs: []
  type: TYPE_NORMAL
- en: Tensors and basic operations on tensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tensor is a basic data structure in `tfjs`. You can think of tensors as a
    generalization of vectors, matrices, or high-dimensional arrays. The **CoreAPI**,
    which we introduced in the *What is TensorFlow.js?* section, exposes different
    functions for creating and working with tensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a simple comparison between scalars, vectors,
    and a matrix with a tensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Comparison between simple n-dimensional arrays and a tensor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Comparison between simple n-dimensional arrays and a tensor
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is a grid of `m x n` numbers, where `m` represents the number of rows
    and `n` represents the number of columns. A matrix can be of one or more dimensions,
    and matrixes of the same shape support direct mathematical operations on each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: A vector, on the other hand, is a one-dimensional matrix with shape (1, 1);
    that is, it has a single row and column—for example, [2, 3], [3, 1, 4].
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned earlier that a tensor is more of a generalized matrix—that is,
    it extends the concept of a matrix. Tensors can be described by their rank. A
    rank is similar to the idea of a shape but is represented by a single number as
    opposed to a shape. In the following list, we see the different types of tensor
    ranks with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A tensor of rank 0 is a scalar—for example, 1, 20, or 100\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tensor with rank 1 is a vector—for example, [1, 20] or [20, 100, 23.6].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tensor with a rank of 2 is a matrix—for example, [[1, 3, 6], [2.3, 5, 7]].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that we can have tensors of rank 4 or more, and these are called higher
    dimension tensors and can be difficult to visualize. See the following screenshot
    for a better understanding of tensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Comparison of tensors with different ranks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Comparison of tensors with different ranks
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the rank, tensors have other properties such as `dtype`, `data`, `axis`,
    and `shape`. These are described in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `dtype` property (data type) is the type of data a tensor holds—for example,
    a rank 1 tensor with the following data [2.5, 3.8] has a dtype of `float32`. By
    default, numeric tensors have a dtype of `float32`, but this can be changed during
    creation. TensorFlow.js supports `float32`, `int32`, `bool`, `complex64`, and
    `string` data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` property is the content of a tensor. This is usually stored as an
    array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `axis` property is the particular dimension of a tensor—for example, an
    *m x n* tensor has an axis of *m* or *n*. The axis can be used to specify which
    dimension an operation is performed on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shape` property is the dimension of the tensor. Think of the shape as the
    number of elements across each axis of a tensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you have a basic understanding of what tensors are, in the next sub-section,
    we'll show you how to create tensors and perform some basic operations on or with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A tensor can be created with the `tf.tensor()` method, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we pass a flat array (vector) to the `tf.tensor()`
    method to create a `tfjs` tensor. After creating this, we now have access to different
    properties and functions that can be used to manipulate or transform the tensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such property is the `shape` property, which we can call as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when you log the tensor with `console.log`, you get a tensor object.
    If you need to see the underlying tensor array, you can call the `print()` function
    on the tensor, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need access to the underlying data of a tensor, you can call the `array()`
    or `arraySync()` method. The difference between the two is that `array()` runs
    asynchronously and returns a promise that resolves to the underlying array, while
    `arraySync()` runs synchronously. You can see an example of this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create tensors by specifying a `shape` parameter. For example,
    in the following code snippet, we create a 2 x 2 (**two-dimensional** (**2D**))
    tensor from a flat array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can create a 1 x 4 (**one-dimensional** (**1D**)) tensor, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, however, that the shapes must match the number of elements—for example,
    you cannot create a `2 x 5`-dimensional tensor from a flat array with four elements.
    The following code will throw a shape error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Error thrown from shape mismatch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Error thrown from shape mismatch
  prefs: []
  type: TYPE_NORMAL
- en: '`Tfjs` explicitly provides functions for creating 1D, 2D, `shape` parameter.
    You can read more about creating tensors from the official `tfjs` API here: [https://js.tensorflow.org/api/latest/#Tensors-Creation](https://js.tensorflow.org/api/latest/#Tensors-Creation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a tensor has a `dtype` property of `float32`, so any and every
    tensor you create will have a `dtype` of `float32`. If this is not the desired
    `dtype`, you can specify the type on tensor creation, as we demonstrate in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to create a tensor, we are going to move on to operating on
    tensors.
  prefs: []
  type: TYPE_NORMAL
- en: Operating on tensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tensors, as we said earlier, store data in grids and allow numerous operations
    for manipulating or transforming this data. `tfjs` provides many operators for
    linear algebra and ML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations in `tfjs` are grouped into different sections. Here is an explanation
    of some of the common operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()` for the addition of tensors, `sub()` for the subtraction of tensors,
    `mul()` for the multiplication of tensors, and `div()` for the division of tensors.
    See a full list with examples here: [https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic](https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cos()` for computing the cosine of a tensor, `sin()` for computing the sine
    of a tensor, `exp()` for computing the exponential of a tensor, and `log()` for
    computing the natural logarithm of a tensor. See a full list with examples here:
    [https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math](https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matrices**: These operators are used for matrix operations such as dot products,
    norms, or transposes. You can see a full list of supported operators here: [https://js.tensorflow.org/api/3.7.0/#Operations-Matrices](https://js.tensorflow.org/api/3.7.0/#Operations-Matrices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conv1d`, which computes a 1D convolution over the input `x`, and `maxpool3D`,
    which computes a 3D max-pooling operation. See a full list here: [https://js.tensorflow.org/api/3.7.0/#Operations-Convolution](https://js.tensorflow.org/api/3.7.0/#Operations-Convolution).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`, `max`, `sum`, `mean`, `argMax`, and `argMin`. You can see a full list
    with examples here: [https://js.tensorflow.org/api/3.7.0/#Operations-Reduction](https://js.tensorflow.org/api/3.7.0/#Operations-Reduction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal`, `greater`, `greaterEqual`, and `less`. You can see a full list with
    examples here: [https://js.tensorflow.org/api/3.7.0/#Operations-Logical](https://js.tensorflow.org/api/3.7.0/#Operations-Logical).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see a full list of supported operations in the official API here: [https://js.tensorflow.org/api/3.7.0/#Operations](https://js.tensorflow.org/api/3.7.0/#Operations).'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a basic understanding of the available tensor operators, we'll
    show some code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Applying arithmetic operations on tensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add two tensors by directly calling the `add()` method on the first
    tensor and passing the second tensor as an argument, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can also add or apply any operator directly by calling the operator
    on the `tf` object, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this knowledge, you can perform other arithmetic operations such as subtraction,
    multiplication, division, and power operations, as we demonstrate in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth mentioning that the order of the tensors passed to the operators
    matter, as a change in the order causes the result to be different. For example,
    if we swap the order of the preceding `div` operation from `const tfsub = tf.sub(b,
    a)` to `const tfsub = tf.sub(a, b)`, then we get a negative result, as shown in
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all operations involving two tensors will only work if both tensors
    have the same shape. For example, the following operation would throw an invalid
    shape error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.8 – Invalid shape error when performing an operation on tensors
    with a different shape'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Invalid shape error when performing an operation on tensors with
    a different shape
  prefs: []
  type: TYPE_NORMAL
- en: In the next sub-section, we look at some examples of basic math operations on
    tensors.
  prefs: []
  type: TYPE_NORMAL
- en: Applying basic math operations on tensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the example format from the previous sub-section, *Applying arithmetic
    operations on tensors*, we give some examples of computing math operations on
    tensors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned earlier, you can call operators directly from the `tf` object—for
    example, `x.cos()` becomes `tf.cos(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying reduction operations on tensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also apply reduction operations such as `mean`, `min`, `max`, `argMin`,
    and `argMax` to tensors. Here are some examples of `mean`, `min`, `max`, `argMin`,
    and `argMax` in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Armed with the basic knowledge of ML, tensors, and operations that can be performed
    on tensors, you are now ready to build a simple ML model. In the next section
    of this chapter, we will consolidate all that you have learned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple regression model with TensorFlow.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [*Chapter 9*](B17076_09_ePub_RK.xhtml#_idTextAnchor166),
    *Basics of Machine Learning*, you were introduced to the basics of ML, especially
    the theoretical aspect of regression and classification models. In this section,
    we'll show you how to create and train a regression model using `tfjs` **LayerAPI**.
    Specifically, by the end of this section, you'll have a regression model that
    can predict sales prices from supermarket data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your environment locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before building the regression model, you have to set up your environment locally.
    In this section, we'll be working in a Node.js environment. This means that we'll
    be using the `node` version of TensorFlow.js and Danfo.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps here to set up your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new work directory, create a folder for your project. We will create one
    called `sales_predictor`, as demonstrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open a Terminal in the folder directory and initialize a new `npm` project
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the `Danfo.js` node package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also from the terminal, create an `src` folder and add `train.js`, `model.js`,
    and `data` `_proc.js` files. You can create these folders/files manually from
    your code editor or by running the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now you have your project and files set up, we'll move on to the data retrieval
    and processing step in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and processing the training dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dataset we'll be using for model training is called the *BigMart sales dataset*
    ([https://www.kaggle.com/devashish0507/big-mart-sales-prediction](https://www.kaggle.com/devashish0507/big-mart-sales-prediction)).
    It is available as a public dataset on Kaggle, which is a popular data science
    competition platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the dataset directly from this chapter''s code repository
    here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv).
    After successful download, create a folder called `dataset` in your project directory
    and copy the dataset into it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm everything is in order, your project `src` folder should have the
    following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As with all data science problems, a general problem statement is made available
    to guide you on the problem you''re solving. In terms of the BigMart sales dataset,
    the problem statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BigMart have collected 2013 sales data for 1,559 products across 10 stores
    in different cities. Also, certain attributes of each product and store have been
    defined. The aim is to build a predictive model and find out the sales of each
    product at a particular store.*'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding problem statement, you will notice that the aim of building
    this model is to help BigMart effectively predict sales of each product at a particular
    store. Now, sales price here means a continuous value, so as such, we have a regression
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have access to the data and have understood the problem statement, you're
    going to load the dataset with `Danfo.js` and perform some data processing and
    cleaning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided a separate **Danfo Notebook** (**Dnotebook**) file in the
    code repository here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json).
    In the notebook, we did some data exploration and analysis of the sales dataset,
    a majority of which will help us in the following processing steps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `data_proc.js` file opened in your code editor, follow the steps given
    here to process the BigMart sales dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import `danfojs-node`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a function called `processData` that accepts the dataset path,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the body of the `processData` function, we load the dataset using
    the `read_csv` function and print the header, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure data loading works, you can pass the path of your dataset to the
    `processData` function, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And in your terminal, run the `data_proc.js` file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Displaying the head value of the BigMart sales dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Displaying the head value of the BigMart sales dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'From the analysis in the Dnotebook file, we noticed that two columns, `Item_Weight`
    and `Outlet_Sales`, have missing values. In the following code snippet, we''ll
    fill these missing values using the mean and the modal value respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have noticed, the dataset is a mixture of categorical (strings) columns
    and numeric (`float32` and `int32`) columns. This means we must convert all categorical
    columns to numeric form before we can pass them to our model. In the following
    code snippet, we use Danfo.js''s `LabelEncoder` to encode each categorical column
    to a numeric one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll separate the target from the training dataset. The target, as
    we have noticed from the problem statement, is the sales price. This corresponds
    to the last column, `Item_Outlet_Sales`. In the following code snippet, we''ll
    split the dataset using the `iloc` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll standardize our dataset. Standardizing our dataset forces every
    column to be in the scale, and as such improves model training. In the following
    code snippet, we use Danfo.js''s `StandardScaler` to standardize the dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to complete the `processData` function, we''ll return the raw tensors,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the full code in the code repository here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing and printing the tensors from the final `data_proc.js` file should
    give you tensors like those shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Final BigMart data tensors after processing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Final BigMart data tensors after processing
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a function that can process a raw dataset and return tensors, let's
    move on to creating models with `tfjs`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models with TensorFlow.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, `tfjs` provides a Layers API that can be used to define
    and create ML models. The Layers API is similar to the popular Keras API, and
    as such, Python developers already familiar with Keras can easily port their code
    to `tfjs`.
  prefs: []
  type: TYPE_NORMAL
- en: The Layers API provides two ways of creating models—a sequential and a model
    format. We'll briefly explain and give examples of these in the following sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: The sequential way of creating models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the easiest and most common way of creating models. It is simply a stack
    of multiple model layers, where the first layer in the stack defines the input
    and the last layer defines the output, while the middle layers can be as many
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a two-layer sequential model is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You will notice from the preceding code snippet that the first layer in the
    sequence provides an `inputShape` parameter. This means that the model is expecting
    an input with `50` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a sequential layer by passing a list of layers, as demonstrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at the model format.
  prefs: []
  type: TYPE_NORMAL
- en: The model way of creating models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model format of creating models provides more flexibility when creating
    models. Instead of simply accepting a stack of linear layers, models defined with
    the model layer can be non-linear, cyclical, and as advanced or connected as you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code snippet, we create a two-layer network using
    the model format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example code, you can see that we are explicitly calling
    the `apply` function and passing the layer we want to connect as a parameter.
    This way, we can build hybrid and highly complex models that have graph-like connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Layers API from the official `tfjs` documentation
    here: [https://js.tensorflow.org/api/latest/#Models](https://js.tensorflow.org/api/latest/#Models).'
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to create models with the Layer API, we are going to create
    a simple three-layer regression model in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple three-layer regression model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A regression model, as we have explained in the previous chapter, [*Chapter
    9*](B17076_09_ePub_RK.xhtml#_idTextAnchor166), *Basics of Machine Learning*, is
    a model with a continuous output. To create a regression model with `tfjs`, we
    define stacks of layers, and in the last layer, we set the number of `units` to
    `1`. For example, open the `model.js` file in the code repository. On *lines 7-11*,
    you should see the following sequential model definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the first layer, we set the `inputShape` parameter to `11`. This
    is because we have `11` training columns in our BigMart dataset. You can confirm
    this by printing the shape of the processed tensors. In the last layer, we set
    the `units` property to `1` because we want to predict a single continuous value.
  prefs: []
  type: TYPE_NORMAL
- en: The layers in between can be as many we want, and the units can take on any
    number. So, in essence, adding more layers in between gives us a deeper model,
    and adding more units gives us a wider model. The choice of layers to use will
    depend not only on the problem but also on performing multiple experiments and
    training.
  prefs: []
  type: TYPE_NORMAL
- en: And with just those few lines of code, you have successfully created a three-layer
    regression model in `tfjs`.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a model, the next thing you would normally do is compile the
    model. So, what does compilation do? Well, compilation is the process of preparing
    a model for training and evaluation. This means that, in the compilation stage,
    we have to set the model's optimizers, loss, and/or training metrics.
  prefs: []
  type: TYPE_NORMAL
- en: A `tfjs` model must be compiled before you can start training. So, how do we
    compile a model in `tfjs`? This can be done by calling the `compile` function
    on a defined model and setting the optimizer and metrics you want to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'On *lines 13-17* of the `model.js` file, we compiled our regression model by
    setting the optimizer to `Adam`, and the `loss` and `metrics` properties to `meanSquaredError`.
    See the following code snippet to view this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that there are different types of optimizers to pick
    from; see a full list at [https://js.tensorflow.org/api/latest/#Training-Optimizers](https://js.tensorflow.org/api/latest/#Training-Optimizers).
    The choice of which optimizer to use will depend on your experience, as well as
    on multiple experimentations.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of loss, the problem will inform you on which loss function to use.
    In our case, since it's a regression problem, we can use the **mean squared error**
    (**MSE**) function. To see a full list of available loss functions, visit [https://js.tensorflow.org/api/latest/#Training-Losses](https://js.tensorflow.org/api/latest/#Training-Losses).
  prefs: []
  type: TYPE_NORMAL
- en: And finally, in terms of metrics that are calculated and displayed during model
    training, we can specify multiple options, and just as with the loss, the specified
    metric will depend on the problem you are trying to solve. In our case, we can
    also calculate an MSE. To see the full list of supported metrics, visit [https://js.tensorflow.org/api/latest/#Metrics](https://js.tensorflow.org/api/latest/#Metrics).
  prefs: []
  type: TYPE_NORMAL
- en: Now you have defined and compiled the model, we will move on to the next and
    final part of this chapter, which is about training the model.
  prefs: []
  type: TYPE_NORMAL
- en: Training the model with the processed dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `train.js` file contains the code for training the three-layer regression
    model on the processed dataset. In the following steps, we''ll walk you through
    the whole process of model training:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s load and process the dataset using the `processData` function,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the model using the `getModel` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, and very importantly, we call the `fit` function on the model, pass the
    training data, the target, and a couple of parameters such as the `epoch`, `batchSize`,
    and `validationSplits` parameters, and a callback function called `onEpochEnd`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what the parameters we passed to the `fit` function do, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Xtrain`: The training data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ytrain`: The target data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`epoch`: The epoch size is the number of times to iterate over the training
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`batchSize`: The batch size is the number of data points or samples used in
    computing one gradient update.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validationSplit`: The validation split is a handy parameter that tells `tfjs`
    to reserve the specified percentage of data for validation. This can be used when
    we do not want to manually split our dataset into train and test sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callbacks`: A callback, as the name suggests, accepts a list of functions
    that are called during different life cycles of the model training. Callbacks
    are important in monitoring model training. See a full list of callbacks here:
    [https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset](https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we save the model so that we can use it in making new predictions,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `train.js` file will load and process the dataset, load the model,
    and run the model training for the specified number of epochs. The callback (`onEpochEnd`)
    we have specified will print out the loss and the root MSE after each epoch, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Model training logs showing loss and root MSE'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Model training logs showing loss and root MSE
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! You have successfully created, trained, and saved a regression
    model that can predict sale prices using TensorFlow.js. In the next and final
    section of this chapter, we'll show you how to load your saved model and use it
    to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Making predictions with the trained model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make predictions, we have to load the saved model and call the
    `predict` function on it. TensorFlow.js provides a `loadLayersModel` function
    that can be used to load saved models from a filesystem. In the following steps,
    we show you how to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `predict.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `predict.js` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code loads the saved model from the file path and prints a summary.
    The output of the summary should be similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Model summary of the saved model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Model summary of the saved model
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new function called `predict` that uses the saved model to make
    a prediction, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we call the `predict` function on the model and pass
    a tensor with the correct shape (batch, 11) our model is expecting. This returns
    a tensor of the prediction and from this tensor, we get the underlying value.
    From this, we can tell a product with those specific values will sell for approximately
    **US Dollars** (**USD**) $739.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world application, you would generally load a test dataset from another
    **comma-separated values** (**CSV**) file and apply the same data processing steps
    as we did during training. The example uses an inline data point, just to demonstrate
    using a saved model to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter! Congratulations on making it this
    far. I'm sure you have learned a lot. In the next chapter, we'll go deeper by
    building a more practical application—a recommendation system!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the basics of TensorFlow.js. Specifically,
    you learned how to install TensorFlow.js both in the browser and Node.js environment,
    you learned about tensors and the core data structure of `tfjs`, you learned about
    the Core and Layer APIs, and finally, you learned how to build, train, and save
    a regression model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go deeper into a more practical and hands-on project,
    and the knowledge gained here will help you build great products with TensorFlow.js
    and Danfo.js.
  prefs: []
  type: TYPE_NORMAL
